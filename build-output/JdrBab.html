<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta name="referrer" content="no-referrer-when-downgrade">
<!-- Generated on 2025-09-12T15:49:04.406Z by JdrBab Build System -->
<title>JDRâ€‘BAB â€” Livret de rÃ¨gles</title>
<meta content="Livret web multipages des rÃ¨gles JDRâ€‘BAB, thÃ¨me parchemin, illustrations par catÃ©gorie/classe/sousâ€‘classe, export HTML autonome." name="description">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&amp;family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600&amp;display=swap" rel="stylesheet">

<!-- PWA Configuration - Manifest embedded as JSON -->
<script>
// Embed manifest for PWA functionality
window.MANIFEST_DATA = {
  "name": "JDR-BAB - Livret de rÃ¨gles",
  "short_name": "JDR-BAB",
  "description": "Livret web multipages des rÃ¨gles JDR-BAB, thÃ¨me parchemin, illustrations par catÃ©gorie/classe/sous-classe",
  "version": "1.0.0",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#f4f0e6",
  "theme_color": "#8b4513",
  "orientation": "any",
  "scope": "/",
  "lang": "fr",
  "categories": ["games", "entertainment", "productivity"],
  "icons": [
    {
      "src": "../assets/pwa/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "../assets/pwa/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "../assets/pwa/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "../assets/pwa/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "../assets/pwa/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any"
    }
  ],
  "shortcuts": [
    {
      "name": "CrÃ©ation de personnage",
      "short_name": "CrÃ©ation",
      "description": "AccÃ©der directement Ã  la crÃ©ation de personnage",
      "url": "/#/creation",
      "icons": [
        {
          "src": "../assets/pwa/icon-96x96.png",
          "sizes": "96x96",
          "type": "image/png"
        }
      ]
    },
    {
      "name": "Classes",
      "short_name": "Classes",
      "description": "Consulter les classes de personnage",
      "url": "/#/classes",
      "icons": [
        {
          "src": "../assets/pwa/icon-96x96.png",
          "sizes": "96x96",
          "type": "image/png"
        }
      ]
    },
    {
      "name": "Sorts",
      "short_name": "Sorts",
      "description": "Consulter la liste des sorts",
      "url": "/#/sorts",
      "icons": [
        {
          "src": "../assets/pwa/icon-96x96.png",
          "sizes": "96x96",
          "type": "image/png"
        }
      ]
    },
    {
      "name": "Dons",
      "short_name": "Dons",
      "description": "Consulter la liste des dons",
      "url": "/#/dons",
      "icons": [
        {
          "src": "../assets/pwa/icon-96x96.png",
          "sizes": "96x96",
          "type": "image/png"
        }
      ]
    }
  ]
};
</script>
<meta name="theme-color" content="#8b4513">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="JDR-BAB">
<meta name="application-name" content="JDR-BAB">
<meta name="msapplication-TileColor" content="#8b4513">

<!-- Favicon (embedded SVG) -->
<link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjUxMi4wMDAwMDBwdCIgaGVpZ2h0PSI1MTIuMDAwMDAwcHQiIHZpZXdCb3g9IjAgMCA1MTIuMDAwMDAwIDUxMi4wMDAwMDAiIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIG1lZXQiPg0KPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsNTEyLjAwMDAwMCkgc2NhbGUoMC4xMDAwMDAsLTAuMTAwMDAwKSIgZmlsbD0iIzhiNDUxMyIgc3Ryb2tlPSJub25lIj4NCjxwYXRoIGQ9Ik0yMTQwIDUxMTAgYy0yODYgLTI3IC01NzEgLTExMyAtODI1IC0yNDkgLTcyMSAtMzg3IC0xMTc3IC0xMDcyIC0xMjcyIC0xOTExIC0yNiAtMjMwIC0xNSAtNTE1IDI1IC03MTAgMTY1IC04MDEgNjgwIC0xNDQ2IDE0MjIgLTE3ODAgMjM4IC0xMDcgNDQ5IC0xNjQgNzIwIC0xOTUgMTM5IC0xNiA0ODEgLTYgNjIwIDE4IDcyNiAxMjcgMTM1NiA1NjMgMTczNSAxMjAyIDI0NCA0MTEgMzY0IDg1OCAzNjQgMTM1NSAwIDM0NyAtNTUgNjQ3IC0xNzkgOTc1IC0zMzkgOTAwIC0xMDg0IDE0ODkgLTIwMTUgMTU5NCAtMTE5IDEzIC00NzYgMTQgLTU5NSAxeiBtNTgwIC00NTkgYzY2MyAtMTAxIDEyMzUgLTUyMyAxNTMwIC0xMTI5IDExOSAtMjQ0IDE3OCAtNDc1IDE4NyAtNzMyIDIxIC01OTEgLTE4NiAtMTE1MSAtNTgyIC0xNTc1IC0zOTYgLTQyNCAtOTI0IC02NzUgLTE1MDUgLTcxNSAtMTQ4IC0xMCAtNDEwIC00IC01NDUgMTMgLTU5MSA3NCAtMTEyMyAzNzkgLTE0OTEgODU1IC0yNDQgMzE2IC0zOTggNjgyIC00NjQgMTEwMiAtMjIgMTQwIC0yNSA0MTAgLTYgNTQ1IDc0IDUzMCAyOTMgOTg2IDY1MSAxMzU1IDQyNCA0MzcgOTg1IDY5MCAxNjE1IDcyOCA4MyA1IDUyNyAtMyA2MTAgLTEyeiIvPg0KPHBhdGggZD0iTTIyOTggNDQ1NCBjLTUgLTQgLTggLTIxIC04IC0zOCAwIC0yNyAtNCAtMzEgLTMyIC0zNCAtNDMgLTUgLTY4IC0zNiAtNjggLTg1IDAgLTQ5IDI1IC04MCA2OCAtODUgMjggLTMgMzIgLTcgMzIgLTM0IDAgLTE3IDMgLTM0IDggLTM4IDExIC0xMSA2MiAtMTEgNzMgMCA1IDQgOCAyMSA4IDM4IDAgMjcgNCAzMSAzMiAzNCA0MyA1IDY4IDM2IDY4IDg1IDAgNDkgLTI1IDgwIC02OCA4NSAtMjggMyAtMzIgNyAtMzIgMzQgMCAxNyAtMyAzNCAtOCAzOCAtMTEgMTEgLTYyIDExIC03MyAweiIvPg0KPHBhdGggZD0iTTE4NzAgMzk4MCBjLTYwIC02MCAtNCAtMTYwIDgyIC0xNDggMzggNSA2OCAzNSA2OCA2OCAwIDMzIC0zMCA2MyAtNjggNjggLTE5IDIgLTQyIC0zIC01NyAtMTIgLTIwIC0xMiAtMjUgLTEyIC0yNSA0eiIvPg0KPHBhdGggZD0iTTI3MjAgMzk4MCBjLTE1IC0xNSAtMjAgLTMzIC0yMCAtNzAgMCAtNTAgMyAtNTQgMzUgLTY4IDQ5IC0yMiA5NSAtNSAxMTcgNDIgMzIgNjggLTIxIDEzNiAtOTQgMTIwIC0xOSAtNCAtMjggLTEgLTM4IDE0eiIvPg0KPC9nPg0KPC9zdmc+">
<style>
/* â€”â€” ThÃ¨me Heroic Fantasy - Enhanced Parchment â€”â€” */
:root{
  --paper:#f4f0e6;        /* parchemin ancien */
  --paper-ink:#2c1810;    /* encre noire profonde */
  --paper-muted:#8b6f47;  /* bronze ancien */
  --accent:#d4af37;       /* accent dorÃ© pour backgrounds */
  --accent-ink:#4a2c17;   /* titres sombres */
  --rule:#d4c4a8;         /* bordures dorÃ©es */
  --card:#faf6ee;         /* cartes parchemin */
  --link:#8b4513;         /* liens cuivre */
  --gold:#d4af37;         /* or */
  --bronze:#cd7f32;       /* bronze */
  --shadow:0 8px 32px rgba(0,0,0,.15), 0 2px 8px rgba(139,69,19,.1);
  --card-shadow:0 6px 20px rgba(0,0,0,.1), 0 2px 6px rgba(139,69,19,.08);
  --image-border:3px solid #8b4513;
  --image-shadow:0 4px 12px rgba(0,0,0,.2), inset 0 1px 2px rgba(212,175,55,.3);
  
  /* Enhanced Parchment Textures */
  --parchment-texture: 
    radial-gradient(circle at 20% 80%, rgba(139,69,19,.03) 0%, transparent 50%),
    radial-gradient(circle at 80% 20%, rgba(212,175,55,.02) 0%, transparent 50%),
    radial-gradient(circle at 40% 40%, rgba(139,69,19,.01) 0%, transparent 30%),
    linear-gradient(45deg, rgba(139,69,19,.005) 25%, transparent 25%),
    linear-gradient(-45deg, rgba(212,175,55,.005) 25%, transparent 25%);
    
  --parchment-border:
    linear-gradient(45deg, 
      rgba(139,69,19,.8) 0%, 
      rgba(212,175,55,.6) 25%, 
      rgba(139,69,19,.4) 50%, 
      rgba(212,175,55,.6) 75%, 
      rgba(139,69,19,.8) 100%);
      
  --aged-paper: 
    radial-gradient(ellipse at top left, rgba(139,69,19,.04), transparent 60%),
    radial-gradient(ellipse at top right, rgba(212,175,55,.03), transparent 60%),
    radial-gradient(ellipse at bottom left, rgba(139,69,19,.02), transparent 60%),
    radial-gradient(ellipse at bottom right, rgba(212,175,55,.025), transparent 60%);
  
  /* Enhanced Element Colors System - Improved Contrast & Accessibility */
  --feu:#e63946; --feu-bg:rgba(230,57,70,.12); --feu-border:rgba(230,57,70,.4);
  --air:#457b9d; --air-bg:rgba(69,123,157,.12); --air-border:rgba(69,123,157,.4);
  --eau:#1d3557; --eau-bg:rgba(29,53,87,.12); --eau-border:rgba(29,53,87,.4);
  --terre:#6f4e37; --terre-bg:rgba(111,78,55,.12); --terre-border:rgba(111,78,55,.4);
  --divin:#f1c40f; --divin-bg:rgba(241,196,15,.12); --divin-border:rgba(241,196,15,.4);
  --malefique:#6a2c70; --malefique-bg:rgba(106,44,112,.12); --malefique-border:rgba(106,44,112,.4);
  
  /* Spacing system */
  --space-xs:4px; --space-sm:6px; --space-md:8px; --space-lg:12px; --space-xl:16px; --space-2xl:24px;
  
  /* Common transitions */
  --transition-fast:.2s ease; --transition-normal:.3s ease; --transition-slow:.5s ease;
}

/* Enhanced Accessibility & High Contrast Support */
@media (prefers-color-scheme: dark) { 
  :root{ 
    --paper:#f4f0e6; /* Keep light theme for fantasy aesthetic */
    --card:#faf6ee; 
    --paper-ink:#2c1810; 
  } 
}

@media (prefers-contrast: high) {
  :root {
    --paper-ink: #000000;
    --accent-ink: #1a0d08;
    --bronze: #8b4513;
    --gold: #b8860b;
    --rule: #8b4513;
  }
  
  .card, .card-base {
    border-width: 3px;
  }
  
  .btn-base {
    border-width: 3px;
  }
}

/* Base styles */
html,body{height:100%; overflow-x:hidden} /* Prevent horizontal scroll */
body{
  margin:0;
  background:
    radial-gradient(1600px 800px at 50% -10%, rgba(212,175,55,.08), transparent 45%),
    radial-gradient(1400px 700px at 120% 10%, rgba(139,69,19,.06), transparent 40%),
    radial-gradient(800px 400px at 20% 80%, rgba(205,127,50,.04), transparent 30%),
    repeating-linear-gradient(90deg, rgba(74,44,23,.02) 0 1px, transparent 1px 3px),
    repeating-linear-gradient(0deg, rgba(139,69,19,.015) 0 1px, transparent 1px 4px),
    var(--paper);
  color:var(--paper-ink); 
  font:17px/1.65 "Source Serif Pro", "Cinzel", ui-serif, Georgia, Cambria, "Times New Roman", Times, serif; 
  -webkit-font-smoothing:antialiased; 
  text-rendering:optimizeLegibility;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ¨ ENHANCED TYPOGRAPHY SYSTEM - Centered & Harmonized
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Link Styling */
a {
  color: var(--link);
  text-decoration: none;
  transition: all var(--transition-fast);
  position: relative;
}

a:hover {
  text-decoration: underline;
  color: var(--gold);
  text-shadow: 0 1px 3px rgba(212,175,55,0.3);
}

/* Text Emphasis */
strong, b {
  font-weight: 700;
  font-family: "Source Serif Pro", serif;
  color: var(--accent-ink);
  text-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

em, i {
  font-style: italic;
  font-weight: 400;
  color: var(--bronze);
}

/* Enhanced Headings System */
h1, h2, h3, h4, h5, h6 {
  font-family: "Cinzel", "Trajan Pro", ui-serif, Georgia, Cambria, Times, serif;
  color: var(--accent-ink);
  text-shadow: 2px 2px 4px rgba(0,0,0,.1);
  text-align: center;
  margin: 1.5rem auto 1rem;
  position: relative;
  line-height: 1.2;
  letter-spacing: 0.02em;
}

/* Main Title */
h1 {
  font-size: clamp(28px, 4.5vw, 48px);
  letter-spacing: 0.05em;
  margin: 2rem auto 1.5rem;
  font-weight: 700;
  background: linear-gradient(135deg, var(--gold), var(--bronze), var(--gold));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-shadow: none;
  position: relative;
}

h1::before {
  content: 'â—†';
  position: absolute;
  left: -20px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--gold);
  font-size: 0.6em;
  opacity: 0.7;
}

h1::after {
  content: 'â—†';
  position: absolute;
  right: -20px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--gold);
  font-size: 0.6em;
  opacity: 0.7;
}

/* Section Headings */
h2 {
  font-size: clamp(22px, 3.2vw, 32px);
  margin: 1.8rem auto 1.2rem;
  font-weight: 600;
  color: var(--bronze);
  position: relative;
}

h2::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 80px;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--bronze), transparent);
  opacity: 0.8;
}

/* Subsection Headings */
h3 {
  font-size: clamp(18px, 2.4vw, 26px);
  margin: 1.5rem auto 1rem;
  font-weight: 500;
  color: var(--accent-ink);
  position: relative;
}

h3::before {
  content: 'â€»';
  position: absolute;
  left: -15px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--bronze);
  font-size: 0.8em;
  opacity: 0.6;
}

h3::after {
  content: 'â€»';
  position: absolute;
  right: -15px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--bronze);
  font-size: 0.8em;
  opacity: 0.6;
}

/* Smaller Headings */
h4 {
  font-size: clamp(16px, 2vw, 20px);
  margin: 1.2rem auto 0.8rem;
  font-weight: 500;
  color: var(--paper-muted);
}

h5, h6 {
  font-size: clamp(14px, 1.8vw, 18px);
  margin: 1rem auto 0.6rem;
  font-weight: 500;
  color: var(--paper-muted);
}

/* Text Utilities */
.muted {
  color: var(--paper-muted);
  font-style: italic;
}

.lead {
  font-size: 18px;
  line-height: 1.6;
  text-align: center;
  margin: 1.5rem auto;
  color: var(--accent-ink);
  font-weight: 400;
}

/* Enhanced Separator Rule */
.rule {
  height: 3px;
  background: linear-gradient(90deg, 
    transparent, 
    var(--bronze), 
    var(--gold), 
    var(--bronze), 
    transparent);
  margin: 2rem auto;
  border-radius: 2px;
  opacity: 0.8;
  position: relative;
}

.rule::before {
  content: 'â‹';
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  background: var(--paper);
  color: var(--gold);
  padding: 0 8px;
  font-size: 14px;
}

/* Decorative Separators */
.separator-ornate {
  text-align: center;
  margin: 2.5rem auto;
  font-size: 1.5em;
  color: var(--gold);
  opacity: 0.7;
}

.separator-ornate::before {
  content: 'â—† â‹ â—†';
}

/* Centered Text Blocks */
.text-center {
  text-align: center;
}

.text-center-block {
  text-align: center;
  margin: 1.5rem auto;
  max-width: 800px;
}

/* Mobile Typography Adjustments */
@media (max-width: 480px) {
  h1::before, h1::after,
  h3::before, h3::after {
    display: none;
  }
  
  .rule::before {
    font-size: 12px;
    padding: 0 6px;
  }
  
  .lead {
    font-size: 16px;
    margin: 1rem auto;
  }
}
/* === UTILITY CLASSES === */

/* Spacing utilities */
.m-0{margin:0} .m-1{margin:var(--space-xs)} .m-2{margin:var(--space-md)} .m-3{margin:var(--space-lg)} .m-4{margin:var(--space-xl)}
.mt-0{margin-top:0} .mt-1{margin-top:var(--space-xs)} .mt-2{margin-top:var(--space-md)} .mt-3{margin-top:var(--space-lg)}
.mb-0{margin-bottom:0} .mb-1{margin-bottom:var(--space-xs)} .mb-2{margin-bottom:var(--space-md)} .mb-3{margin-bottom:var(--space-lg)}
.p-0{padding:0} .p-1{padding:var(--space-xs)} .p-2{padding:var(--space-md)} .p-3{padding:var(--space-lg)} .p-4{padding:var(--space-xl)}

/* Flex utilities */
.flex{display:flex} .flex-col{flex-direction:column} .flex-wrap{flex-wrap:wrap}
.items-center{align-items:center} .items-start{align-items:flex-start} .items-end{align-items:flex-end}
.justify-center{justify-content:center} .justify-start{justify-content:flex-start} .justify-end{justify-content:flex-end}
.gap-1{gap:var(--space-xs)} .gap-2{gap:var(--space-md)} .gap-3{gap:var(--space-lg)}

/* Element color utilities */
.text-feu{color:var(--feu)} .text-air{color:var(--air)} .text-eau{color:var(--eau)} .text-terre{color:var(--terre)} .text-divin{color:var(--divin)} .text-malefique{color:var(--malefique)}
.bg-feu{background:var(--feu-bg);border-color:var(--feu-border)} .bg-air{background:var(--air-bg);border-color:var(--air-border)}
.bg-eau{background:var(--eau-bg);border-color:var(--eau-border)} .bg-terre{background:var(--terre-bg);border-color:var(--terre-border)}
.bg-divin{background:var(--divin-bg);border-color:var(--divin-border)} .bg-malefique{background:var(--malefique-bg);border-color:var(--malefique-border)}

/* Grid utilities */
.grid{display:grid;gap:var(--space-lg)}
.cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}
.cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}
@media (max-width: 900px){ .cols-3{grid-template-columns:1fr} }
@media (max-width: 768px){ .cols-2{grid-template-columns:1fr !important} }

/* Misc utilities */
.subclass-stack{display:flex;flex-direction:column;gap:var(--space-lg)}
.chip{font-size:14px;border:2px solid var(--rule);border-radius:999px;padding:6px 12px;background:rgba(155,107,47,.12);font-weight:600;box-shadow:0 2px 6px rgba(0,0,0,.1)}
.chips{display:flex;flex-wrap:wrap;gap:8px;justify-content:center}

/* Mobile-specific utilities for Game Master pages */
@media (max-width: 480px) {
  .mobile-stack { flex-direction: column !important; }
  .mobile-center { text-align: center !important; }
  .mobile-hide { display: none !important; }
  .mobile-full-width { width: 100% !important; }
  .mobile-touch-target { min-height: 44px !important; min-width: 44px !important; }
  .mobile-no-margin { margin-left: 0 !important; margin-right: 0 !important; }
  .mobile-wrap { flex-wrap: wrap !important; }
  .mobile-break-word { word-break: break-word !important; }
}
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ—ï¸ LAYOUT SYSTEM - Enhanced Responsive Design
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Main Shell Layout */
.shell {
  display: grid;
  grid-template-rows: 1fr auto;
  min-height: 100svh;
  position: relative;
  overflow-x: hidden; /* Prevent horizontal scroll on mobile */
}

/* Main Content Area - Enhanced Parchment Background */
.page {
  position: relative;
  min-height: 100vh;
  padding: 18px; /* Equal padding all around */
  transition: padding var(--transition-normal);
  background: 
    var(--parchment-texture),
    var(--aged-paper),
    var(--paper);
}

/* Content Container - Dynamic Centering (handled by JavaScript) */
#views {
  max-width: 1400px;
  /* Fallback positioning - will be overridden by DynamicCentering.js */
  margin-left: 0; /* Reset to 0 - will be handled by responsive design */
  margin-right: 20px;
  padding: 0 var(--space-lg);
  animation: fadeInUp 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

/* Desktop layout with sidebar */
@media (min-width: 1025px) {
  #views {
    margin-left: 370px; /* Only apply sidebar margin on large screens */
  }
}

/* Mobile Responsiveness */
@media (max-width: 980px) { 
  .page {
    padding: 12px;
    background: var(--paper);
  }
  
  #views {
    margin-left: 0; /* Reset sidebar margin on mobile */
    margin-right: 0;
    padding: 0 var(--space-md);
    max-width: 100%;
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Enhanced Sidebar Navigation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.sidebar {
  position: fixed;
  top: 0;
  left: 0;
  width: 350px;
  height: 100vh;
  overflow-y: auto;
  overflow-x: hidden;
  z-index: 100;
  background: 
    var(--parchment-texture),
    linear-gradient(180deg, var(--paper), rgba(244,240,230,0.95)),
    var(--aged-paper);
  backdrop-filter: blur(8px);
  border-right: 4px solid transparent;
  border-image: var(--parchment-border) 1;
  box-shadow: 
    4px 0 20px rgba(0,0,0,0.08),
    inset -1px 0 0 rgba(212,175,55,0.1);
  transition: transform var(--transition-normal);
}

.sidebar::before {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  width: 2px;
  height: 100%;
  background: linear-gradient(180deg, 
    var(--gold) 0%, 
    var(--bronze) 50%, 
    var(--gold) 100%);
  opacity: 0.6;
}

/* Mobile and Tablet Sidebar with Collapsible Navigation */
@media (max-width: 1024px) { 
  .sidebar {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    height: 100dvh; /* Dynamic viewport height for better mobile support */
    min-height: 100vh;
    min-height: 100dvh;
    background: 
      linear-gradient(135deg, var(--card), rgba(244,240,230,0.98)),
      radial-gradient(circle at 50% 30%, rgba(212,175,55,0.05), transparent 70%);
    border-right: none;
    border-bottom: 3px solid var(--rule);
    backdrop-filter: blur(8px);
    box-shadow: 
      0 8px 32px rgba(0,0,0,0.15),
      inset 0 -1px 0 rgba(212,175,55,0.1);
    transform: translateY(-100%);
    transition: transform var(--transition-normal);
    z-index: 200;
    overflow: hidden; /* Prevent sidebar itself from scrolling */
  }
  
  .sidebar.mobile-open {
    transform: translateY(0);
  }
  
  /* Adjust page layout for mobile and tablet */
  .page {
    padding: 80px 12px 12px 12px; /* Top padding for mobile nav button */
  }
  
  /* Ensure content uses full width on tablet */
  #views {
    margin-left: 0 !important;
    margin-right: 0 !important;
    max-width: 100% !important;
    padding: 0 var(--space-md) !important;
  }
  
  .sidebar::before {
    display: none;
  }
  
  /* Mobile Navigation Toggle Button */
  .mobile-nav-toggle {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 300;
    background: linear-gradient(135deg, var(--gold), var(--bronze));
    color: white;
    border: 2px solid var(--rule);
    border-radius: 12px;
    padding: 12px 16px;
    cursor: pointer;
    box-shadow: 
      0 6px 20px rgba(0,0,0,.15),
      inset 0 1px 0 rgba(255,255,255,.2);
    transition: all var(--transition-fast);
    font-family: 'Cinzel', serif;
    font-weight: 600;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 44px;
    min-height: 44px;
    justify-content: center;
  }
  
  .mobile-nav-toggle:hover {
    transform: scale(1.05);
    box-shadow: 
      0 8px 25px rgba(0,0,0,.2),
      inset 0 1px 0 rgba(255,255,255,.3);
  }
  
  .mobile-nav-toggle:active {
    transform: scale(0.98);
  }
  
  .mobile-nav-toggle .icon {
    font-size: 16px;
    transition: transform var(--transition-fast);
  }
  
  .mobile-nav-toggle.open .icon {
    transform: rotate(180deg);
  }
  
  /* Hide toggle on desktop */
  @media (min-width: 1025px) {
    .mobile-nav-toggle {
      display: none;
    }
  }
}
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Enhanced Panel System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.panel {
  background: 
    linear-gradient(135deg, var(--card), rgba(250,246,238,0.9)),
    radial-gradient(circle at 20% 30%, rgba(212,175,55,0.03), transparent 70%);
  border: 2px solid var(--rule);
  border-radius: 18px;
  box-shadow: 
    var(--card-shadow),
    inset 0 1px 0 rgba(255,255,255,0.1);
  padding: 18px;
  position: relative;
  overflow: hidden;
  margin: 12px;
  transition: all var(--transition-normal);
  backdrop-filter: blur(2px);
}

.panel::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, 
    transparent, 
    var(--gold), 
    var(--bronze), 
    var(--gold), 
    transparent);
  opacity: .6;
}

.panel::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--bronze), transparent);
  opacity: .3;
}

.panel:hover {
  transform: translateY(-1px);
  box-shadow: 
    0 8px 32px rgba(0,0,0,.12),
    0 2px 8px rgba(139,69,19,.1),
    inset 0 1px 0 rgba(255,255,255,.15);
}

/* Table of Contents - Full height sidebar OVERRIDE */
.sidebar .panel {
  height: calc(100vh - 24px) !important; /* Full height minus margin - FORCE */
  margin: 12px !important;
  padding: 18px !important; /* Keep original panel padding */
  display: flex !important;
  flex-direction: column !important;
  overflow: hidden !important;
  box-sizing: border-box !important;
}

.sidebar .panel .searchbar {
  flex-shrink: 0 !important; /* Don't shrink searchbar */
  margin-bottom: 16px !important;
}

.sidebar .panel .tools {
  flex-shrink: 0 !important; /* Don't shrink tools */
  margin: 0 0 16px 0 !important;
}

.toc {
  flex: 1 !important; /* Take all remaining space - FORCE */
  overflow-y: auto !important;
  overflow-x: hidden !important;
  scrollbar-width: thin;
  scrollbar-color: var(--bronze) transparent;
  padding-right: 4px;
  min-height: 0 !important; /* Allow flex shrinking */
}

/* Tablet/Mobile TOC */
@media (max-width: 1024px) {
  .sidebar .panel {
    height: 100% !important; /* Use full sidebar height */
    min-height: 100% !important;
    margin: 0 !important; /* Remove margins for full coverage */
    border-radius: 0 !important; /* Remove rounded corners for edge-to-edge */
    display: flex !important;
    flex-direction: column !important;
    overflow: hidden !important;
    box-sizing: border-box !important;
  }
  
  .sidebar .panel .searchbar,
  .sidebar .panel .tools {
    flex-shrink: 0 !important; /* Keep fixed size for controls */
    margin: 12px !important; /* Add margin back to controls only */
  }
  
  .toc {
    flex: 1 !important; /* Take all remaining space */
    overflow-y: auto !important;
    overflow-x: hidden !important;
    min-height: 0 !important;
    margin: 0 12px 12px 12px !important; /* Add margin to TOC content only */
  }
}

.toc::-webkit-scrollbar {
  width: 6px;
}

.toc::-webkit-scrollbar-track {
  background: transparent;
}

.toc::-webkit-scrollbar-thumb {
  background: var(--bronze);
  border-radius: 3px;
}

.toc::-webkit-scrollbar-thumb:hover {
  background: var(--gold);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Enhanced TOC Styling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.toc h4 {
  margin: 8px 10px 12px;
  color: var(--bronze);
  text-transform: uppercase;
  font-size: 13px;
  letter-spacing: 0.15em;
  font-weight: 700;
  font-family: 'Cinzel', serif;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
  position: relative;
  padding-bottom: 6px;
  text-align: center;
}

.toc h4::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 2px;
  background: linear-gradient(90deg, var(--bronze), transparent);
  border-radius: 1px;
}

/* Hierarchical TOC Sections */
.toc-section {
  margin-bottom: 8px;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid rgba(139,69,19,0.1);
  background: linear-gradient(135deg, 
    rgba(255,248,220,0.3) 0%, 
    rgba(212,175,55,0.05) 100%);
}

.toc-section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 12px;
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.15) 0%, 
    rgba(139,69,19,0.08) 100%);
  cursor: pointer;
  transition: all var(--transition-normal);
  border-bottom: 1px solid rgba(139,69,19,0.1);
}

.toc-section-header:hover {
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.25) 0%, 
    rgba(139,69,19,0.15) 100%);
  transform: translateY(-1px);
}

.toc-section-title {
  font-weight: 600;
  font-family: 'Cinzel', serif;
  color: var(--bronze);
  font-size: 14px;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
}

.toc-section-toggle {
  color: var(--bronze);
  font-size: 12px;
  transition: transform var(--transition-normal);
  opacity: 0.7;
}

.toc-section.collapsed .toc-section-toggle {
  transform: rotate(-90deg);
}

.toc-section-content {
  padding: 6px;
  max-height: none; /* Permettre l'expansion automatique par dÃ©faut */
  overflow: visible;
  transition: max-height var(--transition-normal), opacity var(--transition-normal);
}

.toc-section-content .toc-category {
  /* Remove scroll limits - let everything be visible naturally */
  max-height: none;
  overflow: visible;
}

.toc-section.collapsed .toc-section-content {
  max-height: 0 !important;
  opacity: 0 !important;
  padding-top: 0;
  padding-bottom: 0;
  overflow: hidden;
}
.toc a {
  display: flex;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 12px;
  color: inherit;
  border: 2px solid transparent;
  transition: all var(--transition-normal);
  position: relative;
  overflow: hidden;
  font-weight: 500;
  margin: 2px 0;
  backdrop-filter: blur(1px);
}
.toc a::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, 
    transparent, 
    rgba(212,175,55,.2), 
    rgba(139,69,19,.1), 
    transparent);
  transition: left 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  z-index: 0;
}
.toc a:hover {
  transform: translateX(6px) scale(1.02);
  background: 
    linear-gradient(135deg, rgba(212,175,55,.12), rgba(139,69,19,.08));
  border-color: rgba(139,69,19,.4);
  box-shadow: 
    0 6px 20px rgba(139,69,19,.2),
    inset 0 1px 3px rgba(212,175,55,.25),
    inset 0 -1px 1px rgba(139,69,19,.1);
  color: var(--accent-ink);
}

.toc a:hover::before {
  left: 100%;
}
.toc a > *{position:relative; z-index:1}
.toc a.active {
  background: linear-gradient(135deg, 
    rgba(212,175,55,.18), 
    rgba(139,69,19,.12));
  border-color: var(--gold);
  box-shadow: 
    inset 0 2px 6px rgba(212,175,55,.3),
    inset 0 -1px 2px rgba(139,69,19,.2),
    0 2px 8px rgba(139,69,19,.1);
  transform: translateX(4px) scale(1.01);
  color: var(--accent-ink);
  font-weight: 600;
}
.toc-category{margin:0}
.toc-category > a{position:relative; cursor:pointer}
.toc-category > a::after{content:'â–¼'; position:absolute; right:8px; top:50%; transform:translateY(-50%); 
                         font-size:10px; transition:transform .3s ease; color:var(--bronze)}
.toc-category.collapsed > a::after{transform:translateY(-50%) rotate(-90deg)}
.toc-sub{margin-left:24px;border-left:2px solid var(--rule);padding-left:8px; 
         overflow:hidden; transition:all .3s ease}
.toc-category.collapsed .toc-sub{max-height:0; opacity:0; padding-top:0; padding-bottom:0; margin-top:0; margin-bottom:0}
.toc-category:not(.collapsed) .toc-sub{max-height: none; opacity:1}
.toc-sub a{font-size:14px;padding:6px 8px; margin-left:4px}
.toc-sub a:hover{transform:translateX(6px); margin-left:0}

/* Outils latÃ©raux */
.tools{display:flex;gap:var(--space-md);flex-wrap:wrap;margin:var(--space-md) 0}

/* Article and section layout */
article{display:none}
article.active{display:block}
section{background:var(--card);border:1px solid var(--rule);border-radius:14px;box-shadow:var(--shadow);padding:18px;margin:0 0 14px}

/* Footer */
footer{padding:24px;text-align:center;color:var(--paper-muted)}

/* Print styles */
@media print{ 
  .sidebar, .tools{display:none} 
  .page{grid-template-columns:1fr;padding:0} 
  section{break-inside:avoid;box-shadow:none} 
}

/* PWA Mode Styles */
.pwa-mode {
  /* Remove any browser chrome when running as PWA */
  -webkit-user-select: none;
  user-select: none;
}

.pwa-mode input, .pwa-mode textarea {
  -webkit-user-select: auto;
  user-select: auto;
}

/* PWA display mode detection */
@media (display-mode: standalone) {
  body {
    /* App-like appearance when installed */
    background: var(--paper);
  }
  
  /* Hide any web-specific elements in PWA mode */
  .web-only {
    display: none !important;
  }
  
  /* Enhance touch targets for PWA */
  button, .btn, .toc a {
    min-height: 44px;
    min-width: 44px;
  }
}

/* ========================================
   ğŸ¯ GAME MASTER PAGES - MOBILE FIXES
   ======================================== */

/* Monster Cards - Responsive Stats Grid */
@media (max-width: 480px) {
  .card[data-section-type="monster"] .monster-stats-grid,
  .monster-stats-grid {
    display: grid !important;
    grid-template-columns: 1fr !important;
    gap: 0.5rem !important;
    font-size: 0.85em !important;
  }
  
  .card[data-section-type="monster"] .monster-elemental-grid,
  .monster-elemental-grid {
    display: grid !important;
    grid-template-columns: 1fr 1fr !important;
    gap: 0.3rem !important;
    font-size: 0.75em !important;
  }
  
  .card[data-section-type="monster"] .tag-chip,
  .monster-card .tag-chip {
    display: inline-block !important;
    margin: 2px 4px 2px 0 !important;
    font-size: 0.75em !important;
    padding: 1px 4px !important;
  }
}

/* Treasure Tables - Responsive Fourchettes */
@media (max-width: 480px) {
  .fourchette-row,
  .responsive-fourchette {
    display: flex !important;
    flex-direction: column !important;
    align-items: flex-start !important;
    justify-content: flex-start !important;
    gap: 8px !important;
  }
  
  .fourchette-range {
    min-width: auto !important;
    margin-bottom: 4px !important;
  }
  
  .fourchette-objet {
    flex: none !important;
    margin-left: 0 !important;
    margin-bottom: 8px !important;
    word-break: break-word !important;
    width: 100% !important;
  }
  
  .fourchette-actions {
    margin-left: 0 !important;
    flex-wrap: wrap !important;
    gap: 6px !important;
    justify-content: flex-start !important;
    width: 100% !important;
  }
  
  .fourchette-actions button {
    font-size: 0.7em !important;
    padding: 4px 8px !important;
    min-height: 44px !important; /* Touch-friendly */
    min-width: 44px !important;
  }
}

/* Campaign Page - Responsive Selectors */
@media (max-width: 480px) {
  .campaign-selector > div,
  .campaign-controls {
    flex-direction: column !important;
    align-items: stretch !important;
    gap: 12px !important;
  }
  
  .campaign-selector select,
  .campaign-controls select {
    width: 100% !important;
    font-size: 16px !important; /* Prevents zoom on iOS */
    min-height: 44px !important;
    padding: 8px 12px !important;
  }
  
  .subpage-selector,
  .campaign-subpages {
    flex-direction: column !important;
    gap: 8px !important;
  }
  
  .subpage-selector button,
  .campaign-subpages button {
    width: 100% !important;
    min-height: 44px !important;
  }
}

/* Audio Page - Touch-Friendly Controls */
@media (max-width: 480px) {
  #audio-controls-page button,
  .audio-player button,
  .playlist-controls button {
    min-height: 44px !important;
    min-width: 44px !important;
    padding: 8px 12px !important;
    font-size: 14px !important;
  }
  
  .playlist-item,
  .audio-track {
    padding: 12px !important;
    margin: 8px 0 !important;
  }
  
  .audio-controls-grid {
    display: grid !important;
    grid-template-columns: 1fr !important;
    gap: 8px !important;
  }
}

/* General MJ Page Improvements */
@media (max-width: 768px) {
  /* Better button spacing for all MJ pages */
  .btn.danger,
  .btn.small,
  .edit-btn,
  .delete-btn {
    min-height: 44px;
    min-width: 44px;
    margin: 2px;
  }
  
  /* Responsive tables for all MJ content */
  .mj-table,
  .stats-table,
  .treasure-table {
    display: block;
    overflow-x: auto;
    white-space: nowrap;
  }
  
  .mj-table th,
  .mj-table td,
  .stats-table th,
  .stats-table td {
    min-width: 120px;
    padding: 8px 4px;
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Enhanced Mobile & Tablet Responsiveness â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* Tablet Landscape (1024px and below) - Full width when TOC hidden */
@media (max-width: 1024px) {
  .sidebar {
    width: 320px;
  }
  
  .page {
    /* Remove fixed left padding - let content use full width when TOC is hidden */
    padding: 18px;
  }
  
  #views {
    margin-left: 0 !important; /* Always reset margin on tablet */
    margin-right: 0 !important;
    max-width: 100% !important;
    padding: 0 var(--space-md) !important;
  }
}

/* Tablet Portrait (768px and below) */
@media (max-width: 768px) {
  #views {
    margin-left: 0; /* Reset margins for tablet portrait */
    margin-right: 0;
  }
  
  .illus .thumb { 
    width: 100%; 
    max-width: 280px; 
    height: auto; 
  }
  
  .card, .card-base {
    margin: 1rem 0;
    padding: 16px;
  }
  
  .btn-base {
    padding: var(--space-sm) var(--space-md);
    font-size: 0.9em;
  }
  
  .filter-chips {
    gap: 0.5rem;
  }
  
  .filter-chip {
    padding: 6px 12px;
    font-size: 0.85em;
  }
}

/* Mobile (480px and below) - Standalone Version Optimized */
@media (max-width: 480px) {
  .page {
    padding: 8px;
  }
  
  #views {
    padding: 0 var(--space-sm);
  }
  
  .panel {
    margin: 8px;
    padding: 12px;
    border-radius: 12px;
  }
  
  .card, .card-base {
    padding: 12px;
    margin: 0.8rem 0;
    border-radius: 12px;
  }
  
  .spell-title {
    font-size: clamp(1rem, 3vw, 1.2rem) !important;
    margin: 0 0 0.8rem 0 !important;
  }
  
  .btn-base {
    padding: var(--space-sm);
    font-size: 0.85em;
    gap: var(--space-sm);
  }
  
  .filter-chips {
    gap: 0.4rem;
  }
  
  .filter-chip {
    padding: 4px 8px;
    font-size: 0.8em;
    border-radius: 16px;
  }
  
  /* Mobile-optimized images */
  .illus img {
    max-width: 100% !important;
    width: auto !important;
    height: auto !important;
  }
  
  .illus-spell img,
  .card .illus img {
    max-width: 240px !important;
    max-height: 180px !important;
  }
  
  /* Mobile TOC enhancements */
  .toc a {
    padding: 8px 10px;
    font-size: 0.9em;
  }
  
  .toc-sub a {
    padding: 6px 8px;
    font-size: 0.85em;
  }
  
  /* Mobile search optimizations */
  .searchbar {
    flex-direction: column;
    gap: var(--space-sm);
  }
  
  .searchbar input {
    width: 100%;
    font-size: 16px; /* Prevents zoom on iOS */
  }
  
  .search-results-grid {
    grid-template-columns: 1fr;
    gap: var(--space-md);
  }
  
  .search-result-card {
    min-height: 120px;
    padding: var(--space-md);
  }
}
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ¨ COMPONENT SYSTEM - Modern Heroic Fantasy Design
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Typography Components â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.spell-title {
  font-family: "Cinzel", serif !important;
  font-size: clamp(1.2rem, 2.5vw, 1.4rem) !important;
  background: linear-gradient(135deg, var(--gold), var(--bronze), var(--gold)) !important;
  -webkit-background-clip: text !important;
  -webkit-text-fill-color: transparent !important;
  background-clip: text !important;
  font-weight: 600 !important;
  text-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
  letter-spacing: 0.8px !important;
  text-transform: uppercase !important;
  text-align: center !important;
  margin: 0 0 1rem 0 !important;
  position: relative !important;
}

.spell-title::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 60px;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--gold), transparent);
  opacity: 0.7;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Image Optimization Components â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.lazy-load {
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
  background: #f0f0f0;
  min-height: 100px;
}

.lazy-loaded {
  opacity: 1;
}

/* Improve image rendering performance */
img {
  will-change: auto;
  transform: translateZ(0); /* Force GPU acceleration */
}

/* Placeholder for lazy loading */
.illus img[src*="data:image/svg+xml"] {
  background: linear-gradient(45deg, #f8f8f8 25%, transparent 25%), 
              linear-gradient(-45deg, #f8f8f8 25%, transparent 25%), 
              linear-gradient(45deg, transparent 75%, #f8f8f8 75%), 
              linear-gradient(-45deg, transparent 75%, #f8f8f8 75%);
  background-size: 20px 20px;
  background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
  animation: loading 2s infinite linear;
}

@keyframes loading {
  0% { background-position: 0 0, 0 10px, 10px -10px, -10px 0px; }
  100% { background-position: 20px 20px, 20px 30px, 30px 10px, 10px 20px; }
}

/* Loading Screen Components */
.loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #2c1810, #1a0f0a);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  opacity: 1;
  transition: opacity 0.5s ease-out;
}

.loading-screen.fade-out {
  opacity: 0;
  pointer-events: none;
}

.loading-content {
  text-align: center;
  color: var(--gold);
  max-width: 300px;
  padding: 2rem;
}

.loading-content h2 {
  font-family: "Cinzel", serif;
  font-size: 2rem;
  margin: 1rem 0;
  color: var(--gold);
  text-shadow: 0 2px 4px rgba(0,0,0,0.5);
}

.loading-content p {
  color: var(--text-secondary);
  margin-bottom: 2rem;
}

.loading-spinner {
  width: 60px;
  height: 60px;
  border: 3px solid rgba(212, 175, 55, 0.3);
  border-top: 3px solid var(--gold);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 0 auto 1rem auto;
}

.loading-progress {
  width: 100%;
  height: 4px;
  background: rgba(212, 175, 55, 0.2);
  border-radius: 2px;
  overflow: hidden;
}

.loading-bar {
  height: 100%;
  background: linear-gradient(90deg, var(--gold), var(--bronze), var(--gold));
  width: 0%;
  border-radius: 2px;
  transition: width 0.3s ease-out;
  animation: loading-pulse 2s ease-in-out infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes loading-pulse {
  0%, 100% { background: linear-gradient(90deg, var(--gold), var(--bronze), var(--gold)); }
  50% { background: linear-gradient(90deg, var(--bronze), var(--gold), var(--bronze)); }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Page Header Components â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.page-header {
  text-align: center;
  margin: 2rem auto;
  max-width: 1200px;
  padding: 0 var(--space-lg);
}

.page-header h1 {
  color: var(--gold);
  font-family: "Cinzel", serif;
  font-size: 2.5rem;
  margin-bottom: 1rem;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}

/* Content centering for all page types */
.page-content {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 var(--space-lg);
}

/* Fallback centering for collections and similar content without specific containers */
.editable-section {
  max-width: 1200px;
  margin-left: auto;
  margin-right: auto;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Collections Page Components â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.collections-search {
  margin: 2rem auto;
  text-align: center;
  max-width: 1200px;
  padding: 0 var(--space-lg);
}

.search-container {
  display: flex;
  gap: 1rem;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
}

.search-input {
  padding: 12px 16px;
  font-size: 1.1rem;
  border: 2px solid var(--bronze);
  border-radius: 8px;
  background: var(--card);
  color: var(--text);
  min-width: 300px;
  font-family: "Source Serif Pro", serif;
}

.search-input:focus {
  outline: none;
  border-color: var(--gold);
  box-shadow: 0 0 8px rgba(212, 175, 55, 0.3);
}

.search-button {
  padding: 12px 20px;
  background: linear-gradient(135deg, var(--gold), var(--bronze));
  color: var(--dark-text);
  border: none;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  font-size: 1rem;
  transition: all 0.3s ease;
}

.search-button:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(212, 175, 55, 0.4);
}

.collections-grid {
  display: grid;
  gap: 1.5rem; /* Balanced gap */
  margin: 2rem auto;
  max-width: 1400px; /* More space = more columns possible */
  justify-content: center;
  
  /* Use auto-fit with smaller minmax - collections can be smaller */
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
}

.collection-card {
  background: var(--card);
  border: 2px solid var(--bronze);
  border-radius: 12px;
  padding: 1.5rem;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  width: 100%; /* Take full column width */
  margin: 0; /* No margin, use grid gap */
  box-sizing: border-box; /* Include padding and border in width */
}

.collection-card:hover {
  transform: translateY(-2px);
  border-color: var(--gold);
  box-shadow: 0 8px 20px rgba(212, 175, 55, 0.2);
}

.collection-icon {
  font-size: 3rem;
  margin-bottom: 1rem;
}

.collection-card h3 {
  color: var(--gold);
  font-family: "Cinzel", serif;
  margin: 0.5rem 0;
  font-size: 1.3rem;
}

.collection-card p {
  color: var(--text-muted);
  font-size: 0.95rem;
  line-height: 1.4;
  margin: 0;
}

.collection-error {
  background: linear-gradient(135deg, #fee2e2 0%, #fef2f2 100%);
  border: 2px solid #f87171;
  border-radius: 12px;
  padding: 2rem;
  text-align: center;
  margin: 1rem 0;
  animation: fadeIn 0.5s ease;
}

.collection-error h2 {
  color: #dc2626;
  font-family: "Cinzel", serif;
  margin: 0 0 1rem 0;
  font-size: 1.5rem;
}

.collection-error p {
  color: #7f1d1d;
  font-size: 1rem;
  line-height: 1.6;
  margin: 0.5rem 0;
}

.collection-error strong {
  color: #b91c1c;
  font-weight: 600;
}

/* Collection Development Controls */
.collection-dev-controls {
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid var(--bronze);
  display: flex;
  gap: 0.5rem;
  justify-content: center;
}

.collection-dev-actions {
  text-align: center;
  margin: 1rem 0;
}

.edit-object-btn {
  background: var(--gold);
  color: var(--bg);
  border: none;
  padding: 0.4rem 0.8rem;
  border-radius: 6px;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.edit-object-btn:hover {
  background: #c9a96e;
  transform: translateY(-1px);
}

.delete-object-btn {
  background: #ef4444;
  color: white;
  border: none;
  padding: 0.4rem 0.8rem;
  border-radius: 6px;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.delete-object-btn:hover {
  background: #dc2626;
  transform: translateY(-1px);
}

.remove-from-collection-btn {
  background: #f59e0b;
  color: white;
  border: none;
  padding: 0.4rem 0.8rem;
  border-radius: 6px;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.remove-from-collection-btn:hover {
  background: #d97706;
  transform: translateY(-1px);
}

.add-object-btn {
  background: #10B981;
  color: white;
  border: none;
  padding: 0.6rem 1rem;
  border-radius: 8px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
  font-weight: 500;
}

.add-object-btn:hover {
  background: #059669;
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
}

/* New collection card styling */
.new-collection-card {
  border: 2px dashed var(--bronze) !important;
  background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%) !important;
}

.new-collection-card:hover {
  border-color: var(--gold) !important;
  background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%) !important;
}

.create-collection-btn {
  background: var(--gold);
  color: var(--bg);
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 6px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
  font-weight: 500;
  margin-top: 0.5rem;
}

.create-collection-btn:hover {
  background: #c9a96e;
  transform: translateY(-1px);
}

/* Hide dev controls in dev-off mode */
body.dev-off .collection-dev-controls,
body.dev-off .collection-dev-actions,
body.dev-off .new-collection-card {
  display: none !important;
}

.collection-results {
  margin: 2rem 0;
}

.collection-header {
  text-align: center;
  margin-bottom: 2rem;
  padding: 1.5rem;
  background: var(--accent-bg);
  border-radius: 12px;
  border: 2px solid var(--gold);
}

.collection-header h2 {
  color: var(--gold);
  font-family: "Cinzel", serif;
  margin: 0 0 0.5rem 0;
  font-size: 1.8rem;
}

.back-button {
  background: var(--secondary-bg);
  color: var(--text);
  border: 1px solid var(--bronze);
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.9rem;
  margin-top: 1rem;
  transition: all 0.3s ease;
}

.back-button:hover {
  background: var(--bronze);
  color: white;
}

.tag-filters {
  margin: 1.5rem 0;
  text-align: center;
}

.tag-filters h3 {
  color: var(--text);
  font-family: "Cinzel", serif;
  margin-bottom: 1rem;
  font-size: 1.2rem;
}

.tag-buttons {
  display: flex;
  gap: 0.5rem;
  justify-content: center;
  flex-wrap: wrap;
}

.tag-filter-btn {
  padding: 8px 16px;
  background: var(--secondary-bg);
  color: var(--text);
  border: 1px solid var(--bronze);
  border-radius: 20px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: all 0.3s ease;
}

.tag-filter-btn:hover,
.tag-filter-btn.active {
  background: var(--gold);
  color: var(--dark-text);
  border-color: var(--gold);
}

.collection-items {
  display: grid;
  gap: 1.5rem; /* Balanced gap */
  margin: 2rem auto;
  max-width: 1400px; /* More space = more columns possible */
  justify-content: center;
  
  /* Use auto-fit with smaller minmax to allow more columns */
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
}

/* Consistent sizing for object cards within collections */
.collection-items .card {
  width: 100%; /* Take full column width */
  margin: 0; /* Remove default margin, use grid gap instead */
  box-sizing: border-box; /* Include padding and border in width calculation */
}

/* Objects page container optimization for better space usage */
#objets-container {
  display: grid;
  gap: 1.5rem;
  justify-content: center;
  align-items: start;
  padding: 0;
  margin: 2rem auto;
  max-width: 1400px; /* Increase max width for better space usage */
  
  /* Responsive grid: 1 to 4 objects per row based on screen size */
  grid-template-columns: 1fr;
}

/* 2 objects per row on small tablets */
@media (min-width: 640px) {
  #objets-container {
    grid-template-columns: repeat(2, 1fr);
  }
}

/* 3 objects per row on tablets/small desktop */
@media (min-width: 960px) {
  #objets-container {
    grid-template-columns: repeat(3, 1fr);
  }
}

/* 4 objects per row on large desktop */
@media (min-width: 1280px) {
  #objets-container {
    grid-template-columns: repeat(4, 1fr);
  }
}

/* 5 objects per row on extra large desktop */
@media (min-width: 1600px) {
  #objets-container {
    grid-template-columns: repeat(5, 1fr);
    max-width: 1600px;
  }
}

/* Object cards sizing optimization */
#objets-container .card {
  min-width: 280px;
  max-width: 350px;
  width: 100%;
  margin: 0; /* Remove default margin, use grid gap instead */
}

/* Mobile optimization for objects page */
@media (max-width: 640px) {
  #objets-container {
    padding: 0 1rem;
    gap: 1rem;
  }
  
  #objets-container .card {
    min-width: auto;
    max-width: none;
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Card System Enhanced - Authentic Parchment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.card,
.card-base {
  background: 
    var(--parchment-texture),
    var(--aged-paper),
    var(--card);
  border: 3px solid transparent;
  border-image: var(--parchment-border) 1;
  border-radius: 16px;
  box-shadow: 
    0 8px 32px rgba(139,69,19,.2),
    0 2px 8px rgba(139,69,19,.15),
    inset 0 1px 0 rgba(255,255,255,.2),
    inset 0 -1px 0 rgba(139,69,19,.08);
  padding: 20px;
  position: relative;
  overflow: hidden;
  transition: all var(--transition-normal);
  backdrop-filter: blur(1px);
}

.card::before,
.card-base::before {
  content: '';
  position: absolute;
  top: 2px;
  left: 2px;
  right: 2px;
  bottom: 2px;
  border: 1px solid rgba(139,69,19,.15);
  border-radius: 13px;
  pointer-events: none;
}

.card::after,
.card-base::after {
  content: '';
  position: absolute;
  top: 4px;
  left: 4px;
  right: 4px;
  height: 2px;
  background: 
    radial-gradient(ellipse at center, rgba(212,175,55,.3) 0%, transparent 60%),
    linear-gradient(90deg, transparent, rgba(139,69,19,.2), transparent);
  opacity: .6;
}

.card:hover,
.card-base:hover {
  transform: translate3d(0, -3px, 0) scale(1.01); /* Use 3D transform for better mobile performance */
  box-shadow: 
    0 16px 48px rgba(139,69,19,.25),
    0 6px 16px rgba(139,69,19,.18),
    inset 0 1px 0 rgba(255,255,255,.3),
    inset 0 -1px 0 rgba(139,69,19,.12);
}

/* Improve mobile performance with will-change on interactive elements */
.card,
.card-base,
.btn-base,
.toc a {
  will-change: transform;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Button System Enhanced â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.btn-base {
  display: inline-flex;
  gap: var(--space-md);
  align-items: center;
  background: linear-gradient(135deg, var(--card), rgba(244,240,230,0.8));
  border: 2px solid var(--rule);
  border-radius: 12px;
  padding: var(--space-md) var(--space-lg);
  min-height: 44px; /* Ensure minimum touch target size */
  box-shadow: 
    0 4px 16px rgba(0,0,0,.08),
    0 2px 4px rgba(139,69,19,.1),
    inset 0 1px 0 rgba(255,255,255,.2);
  cursor: pointer;
  transition: all var(--transition-fast);
  font-weight: 500;
  font-family: "Source Serif Pro", serif;
  text-transform: capitalize;
  position: relative;
  overflow: hidden;
}

.btn-base::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(212,175,55,.15), transparent);
  transition: left var(--transition-normal);
}

.btn-base:hover {
  transform: translate3d(0, -2px, 0) scale(1.02); /* Use 3D transform for better mobile performance */
  box-shadow: 
    0 8px 32px rgba(0,0,0,.15),
    0 4px 8px rgba(139,69,19,.12),
    inset 0 1px 0 rgba(255,255,255,.3);
  border-color: var(--bronze);
}

.btn-base:hover::before {
  left: 100%;
}

.btn-base:active {
  transform: translateY(-1px) scale(1.01);
  transition: all 0.1s ease;
}

.btn-small {
  padding: var(--space-sm) var(--space-md);
  font-size: 0.9em;
  min-height: 44px; /* Ensure minimum touch target size */
  min-width: 44px;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Card Variants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.card-enhanced {
  margin: 1.5rem 0;
  animation: cardEntry 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.card.spell-card {
  border-left: 4px solid var(--feu);
  background: linear-gradient(135deg, var(--card), rgba(255,107,53,0.02));
}

.card.don-card {
  border-left: 4px solid var(--bronze);
  background: linear-gradient(135deg, var(--card), rgba(205,127,50,0.02));
}

.card.class-card {
  border-left: 4px solid var(--gold);
  background: linear-gradient(135deg, var(--card), rgba(212,175,55,0.02));
}

@keyframes cardEntry {
  0% {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Enhanced Tags & Filters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.tag-filters {
  margin: 1.5rem 0;
  padding: 1.5rem;
  background: 
    linear-gradient(135deg, var(--card), rgba(244,240,230,0.9)),
    radial-gradient(circle at 20% 50%, rgba(212,175,55,0.05), transparent),
    radial-gradient(circle at 80% 50%, rgba(139,69,19,0.03), transparent);
  border: 2px solid var(--rule);
  border-radius: 16px;
  box-shadow: 
    0 4px 20px rgba(0,0,0,.08),
    inset 0 1px 0 rgba(255,255,255,.1);
  position: relative;
  overflow: hidden;
}

.tag-filters::before {
  content: 'ğŸ·ï¸ Filtres';
  position: absolute;
  top: -1px;
  left: 20px;
  background: var(--card);
  padding: 4px 12px;
  font-size: 0.85em;
  font-weight: 600;
  color: var(--bronze);
  border: 2px solid var(--rule);
  border-top: none;
  border-radius: 0 0 8px 8px;
  font-family: "Cinzel", serif;
}

.filter-chips {
  display: flex;
  gap: 0.75rem;
  flex-wrap: wrap;
  margin-top: 0.5rem;
}

.filter-chip {
  padding: 8px 16px;
  background: linear-gradient(135deg, var(--bronze), rgba(205,127,50,0.9));
  color: white;
  border-radius: 20px;
  font-size: 0.9em;
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition-fast);
  border: 2px solid transparent;
  box-shadow: 
    0 2px 8px rgba(0,0,0,.1),
    inset 0 1px 0 rgba(255,255,255,.2);
  position: relative;
  overflow: hidden;
}

.filter-chip::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,.2), transparent);
  transition: left var(--transition-fast);
}

.filter-chip:hover {
  background: linear-gradient(135deg, var(--gold), rgba(212,175,55,0.9));
  transform: translateY(-2px) scale(1.05);
  box-shadow: 
    0 6px 20px rgba(0,0,0,.15),
    inset 0 1px 0 rgba(255,255,255,.3);
}

.filter-chip:hover::before {
  left: 100%;
}

.filter-chip.active {
  background: linear-gradient(135deg, var(--accent-ink), rgba(74,44,23,0.9));
  border-color: var(--gold);
  transform: scale(1.02);
  box-shadow: 
    0 4px 16px rgba(0,0,0,.2),
    inset 0 1px 0 rgba(255,255,255,.1);
}

.tag-chip {
  display: inline-block;
  padding: 2px 8px;
  background: var(--bronze);
  color: white;
  border-radius: 8px;
  font-size: 0.8em;
  font-weight: 500;
  margin: 2px;
}

/* Gestionnaire de filtres */
.filter-manager-btn {
  background: var(--bronze) !important;
  color: white !important;
}

.filter-manager-btn:hover {
  background: var(--accent) !important;
}

.modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);z-index:999999;display:flex;align-items:center;justify-content:center}
.modal-base{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);z-index:99999;display:none;align-items:center;justify-content:center}
.modal-base.visible{display:flex}
.modal-content-base{background:var(--card);border:2px solid var(--rule);border-radius:16px;padding:var(--space-2xl);box-shadow:var(--shadow);position:relative}

/* Legacy Cards - Enhanced with Modern Styling */
.card{
  border:2px solid var(--rule);
  border-radius:16px;
  padding:20px;
  background:linear-gradient(145deg, #faf7f0, var(--card), #f8f4e8);
  box-shadow:
    0 8px 32px rgba(0,0,0,.12),
    0 2px 8px rgba(139,69,19,.08),
    inset 0 1px 0 rgba(255,255,255,.1);
  position:relative;
  overflow:hidden;
  transition: all var(--transition-normal);
  backdrop-filter: blur(1px);
}

.card::before{
  content:'';
  position:absolute;
  top:0;
  left:0;
  right:0;
  height:3px;
  background:linear-gradient(90deg, transparent, var(--gold), var(--bronze), var(--gold), transparent);
  opacity:.8;
}

.card::after{
  content:'';
  position:absolute;
  bottom:0;
  left:0;
  right:0;
  height:1px;
  background:linear-gradient(90deg, transparent, var(--bronze), transparent);
  opacity:.5;
}

.card:hover {
  transform: translateY(-2px);
  box-shadow: 
    0 12px 48px rgba(0,0,0,.15),
    0 4px 12px rgba(139,69,19,.12),
    inset 0 1px 0 rgba(255,255,255,.15);
  border-color: var(--gold);
}
.card ul, ul{padding-left:35px !important;margin-left:0 !important}

/* Buttons */
.btn{display:inline-flex;gap:var(--space-md);align-items:center;background:var(--card);border:2px solid var(--rule);border-radius:12px;padding:var(--space-md) var(--space-lg);box-shadow:var(--card-shadow);cursor:pointer;
     transition:var(--transition-fast); font-weight:500}
.btn:hover{transform:translateY(-1px); box-shadow:0 8px 25px rgba(0,0,0,.15); border-color:var(--bronze)}
.btn.small{padding:var(--space-sm) var(--space-md)}

/* Search bar */
.searchbar{display:flex;gap:var(--space-md);align-items:center}
.searchbar input{flex:1 1 auto;max-width:100%;height:38px;font-size:15px;padding:var(--space-md) 10px;border-radius:10px;border:1px solid var(--rule);background:#fff6e8;color:inherit}
.searchbar button{height:38px}

/* TOC Search bar - compact horizontal layout in table of contents */
.toc-search{
  display:flex;
  gap:8px;
  align-items:center;
  margin-bottom:16px;
  padding:12px;
  background:rgba(255,246,232,0.5);
  border-radius:12px;
  border:1px solid var(--rule);
}
.toc-search input{
  flex:1 1 auto;
  height:32px;
  font-size:14px;
  padding:6px 12px;
  border-radius:8px;
  border:1px solid var(--rule);
  background:#fff6e8;
  color:inherit;
}
.toc-search .btn-clear{
  display:flex;
  align-items:center;
  justify-content:center;
  width:32px;
  height:32px;
  background:#dc2626;
  color:white;
  border:none;
  border-radius:8px;
  cursor:pointer;
  font-size:14px;
  transition:var(--transition-fast);
  flex-shrink:0;
}
.toc-search .btn-clear:hover{
  background:#b91c1c;
  transform:scale(1.05);
}

/* Search results */
.search-results-container {
  font-size: 14px;
  line-height: 1.4;
}

.search-results-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: var(--gold);
  color: #4a4a4a;
  font-weight: 500;
  border-bottom: 1px solid var(--bronze);
}

.search-close {
  background: none;
  border: none;
  font-size: 16px;
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 4px;
  transition: background-color 0.2s;
}

.search-close:hover {
  background: rgba(0,0,0,0.1);
}

.search-results-list {
  max-height: 320px;
  overflow-y: auto;
}

.search-result-item {
  padding: 10px 12px;
  border-bottom: 1px solid #f0f0f0;
  cursor: pointer;
  transition: background-color 0.2s;
}

.search-result-item:hover {
  background: #f8f4e8;
}

.search-result-item:last-child {
  border-bottom: none;
}

.search-result-summary {
  font-weight: 500;
  color: #333;
  margin-bottom: 2px;
}

.search-result-category {
  font-size: 12px;
  color: #666;
  opacity: 0.8;
}

.search-no-results {
  padding: 20px;
  text-align: center;
  color: #666;
}

.search-no-results p {
  margin: 0;
  font-style: italic;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Collections Grid System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.collections-grid {
  display: grid;
  gap: 1.5rem;
  margin: 2rem auto;
  max-width: 1400px;
  justify-content: center;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
}

.collection-card {
  background: 
    linear-gradient(135deg, var(--card), rgba(250,246,238,0.9)),
    radial-gradient(circle at 20% 30%, rgba(212,175,55,0.03), transparent 70%);
  border: 2px solid var(--bronze);
  border-radius: 16px;
  padding: 1.5rem;
  text-align: center;
  cursor: pointer;
  transition: all var(--transition-normal);
  box-shadow: 
    0 6px 20px rgba(0,0,0,.1),
    0 2px 6px rgba(139,69,19,.08),
    inset 0 1px 0 rgba(255,255,255,.1);
  width: 100%;
  margin: 0;
  box-sizing: border-box;
  position: relative;
  overflow: hidden;
}

.collection-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, 
    transparent, 
    var(--gold), 
    var(--bronze), 
    var(--gold), 
    transparent);
  opacity: 0.6;
}

.collection-card:hover {
  transform: translateY(-4px) scale(1.02);
  box-shadow: 
    0 12px 32px rgba(139,69,19,.2),
    0 4px 12px rgba(139,69,19,.15),
    inset 0 1px 0 rgba(255,255,255,.2);
  border-color: var(--gold);
}

.collection-icon {
  font-size: 3rem;
  margin-bottom: 1rem;
  display: block;
}

.collection-card h3 {
  color: var(--bronze);
  font-family: 'Cinzel', serif;
  font-size: 1.3rem;
  margin: 0.5rem 0 1rem 0;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
}

.collection-card p {
  margin: 0.5rem 0;
  color: var(--paper-muted);
  line-height: 1.4;
}

.collection-description {
  font-size: 0.9em;
  font-style: italic;
  color: var(--paper-ink);
  opacity: 0.8;
}

.collection-dev-controls {
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid var(--rule);
  display: flex;
  gap: 0.5rem;
  justify-content: center;
  flex-wrap: wrap;
}

.new-collection-card {
  border: 2px dashed var(--bronze);
  background: 
    linear-gradient(135deg, rgba(212,175,55,0.05), rgba(139,69,19,0.02)),
    var(--card);
  opacity: 0.8;
}

.new-collection-card:hover {
  opacity: 1;
  border-style: solid;
}

/* Collection items display */
.collection-items {
  display: grid;
  gap: 1.5rem;
  margin-top: 2rem;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
}

.collection-header {
  text-align: center;
  padding: 2rem 0;
  border-bottom: 2px solid var(--rule);
  margin-bottom: 1.5rem;
}

.collection-header h2 {
  color: var(--bronze);
  font-family: 'Cinzel', serif;
  margin: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 1rem;
}

.collection-results {
  margin-top: 2rem;
}

/* Collections search styles */
.collections-search {
  margin: 2rem 0;
  max-width: 600px;
  margin-left: auto;
  margin-right: auto;
}

.search-container {
  display: flex;
  gap: 0.5rem;
  align-items: stretch;
}

.search-input {
  flex: 1;
  padding: 0.75rem 1rem;
  border: 2px solid var(--rule);
  border-radius: 12px;
  font-size: 16px; /* Prevents zoom on iOS */
  background: var(--card);
  color: var(--paper-ink);
  font-family: inherit;
}

.search-button {
  background: linear-gradient(135deg, var(--gold), var(--bronze));
  color: white;
  border: 2px solid var(--bronze);
  border-radius: 12px;
  padding: 0.75rem 1.5rem;
  cursor: pointer;
  font-weight: 600;
  transition: all var(--transition-fast);
  white-space: nowrap;
  min-height: 44px; /* Touch target */
}

.search-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(139,69,19,.3);
}

/* Tag filters */
.tag-filters {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin: 1.5rem 0;
  justify-content: center;
}

.tag-filter-btn {
  background: var(--card);
  border: 2px solid var(--bronze);
  border-radius: 20px;
  padding: 0.4rem 1rem;
  cursor: pointer;
  transition: all var(--transition-fast);
  font-size: 0.9rem;
  font-weight: 500;
  color: var(--paper-ink);
  min-height: 44px; /* Touch target */
  display: flex;
  align-items: center;
}

.tag-filter-btn:hover {
  background: linear-gradient(135deg, var(--gold), rgba(212,175,55,0.8));
  color: white;
  transform: translateY(-1px);
}

.tag-filter-btn.active {
  background: var(--bronze);
  color: white;
  border-color: var(--gold);
}

/* Mobile Responsive Design for Collections */
@media (max-width: 768px) {
  .collections-grid {
    grid-template-columns: 1fr; /* Single column on mobile */
    gap: 1rem;
    margin: 1rem 0;
    max-width: 100%;
    padding: 0 1rem;
  }
  
  .collection-card {
    padding: 1rem;
    min-height: auto;
  }
  
  .collection-card h3 {
    font-size: 1.1rem;
  }
  
  .collection-icon {
    font-size: 2.5rem;
    margin-bottom: 0.8rem;
  }
  
  .collection-items {
    grid-template-columns: 1fr; /* Single column for items on mobile */
    gap: 1rem;
    margin-top: 1rem;
  }
  
  .collection-header {
    padding: 1rem 0;
  }
  
  .collection-header h2 {
    font-size: 1.3rem;
    flex-direction: column;
    gap: 0.5rem;
  }
  
  .collection-dev-controls {
    gap: 0.3rem;
  }
  
  .collection-dev-controls .btn.small {
    padding: 0.4rem 0.8rem;
    font-size: 0.8rem;
  }
  
  /* Mobile search improvements */
  .collections-search {
    margin: 1rem;
    max-width: 100%;
    padding: 0 0.5rem;
  }
  
  .search-container {
    flex-direction: column;
    gap: 0.75rem;
  }
  
  .search-input,
  .search-button {
    width: 100%;
    padding: 0.8rem 1rem;
  }
  
  .search-button {
    order: 2;
  }
  
  .tag-filters {
    gap: 0.4rem;
    margin: 1rem 0;
  }
  
  .tag-filter-btn {
    font-size: 0.85rem;
    padding: 0.5rem 0.8rem;
    min-height: 44px;
  }
}

/* Small tablets */
@media (min-width: 769px) and (max-width: 1024px) {
  .collections-grid {
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1.25rem;
    padding: 0 1rem;
  }
  
  .collection-card {
    padding: 1.25rem;
  }
  
  .collection-items {
    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Treasure Tables Components â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.fourchette-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px;
  margin: 4px 0;
  background: rgba(139, 92, 23, 0.1);
  border-radius: 6px;
  border-left: 3px solid var(--bronze);
  transition: all var(--transition-fast);
}

.fourchette-row:hover {
  background: rgba(139, 92, 23, 0.15);
  transform: translateX(2px);
}

.fourchette-range {
  font-weight: bold;
  color: var(--bronze);
  min-width: 80px;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
}

.fourchette-objet {
  flex: 1;
  margin-left: 12px;
  color: var(--paper-ink);
}

.fourchette-objet a {
  color: var(--link);
  text-decoration: none;
  font-weight: 500;
}

.fourchette-objet a:hover {
  color: var(--bronze);
  text-decoration: underline;
}

.fourchette-actions {
  margin-left: 8px;
  display: flex;
  gap: 4px;
}

.fourchette-actions button {
  padding: 2px 6px;
  font-size: 0.7em;
  border-radius: 4px;
  transition: all var(--transition-fast);
  min-height: 32px;
  min-width: 32px;
}

/* Treasure table page layout */
.treasure-tables-page {
  max-width: 1200px;
  margin: 0 auto;
}

.treasure-filter-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin: 1rem 0;
  justify-content: center;
}

/* Mobile-specific treasure table improvements */
@media (max-width: 768px) {
  .treasure-tables-page {
    padding: 0 1rem;
  }
  
  .treasure-filter-tags {
    gap: 0.25rem;
    margin: 0.5rem 0;
  }
  
  .fourchette-actions button {
    min-height: 40px;
    min-width: 40px;
    padding: 4px 6px;
  }
}

/* Search results page */
.search-page {
  padding: var(--space-lg);
}

.search-page-header {
  margin-bottom: var(--space-xl);
  text-align: center;
  border-bottom: 2px solid var(--rule);
  padding-bottom: var(--space-lg);
}

.search-page-header h1 {
  color: var(--gold);
  margin-bottom: var(--space-md);
  font-family: var(--font-title);
}

.search-results-count {
  color: #666;
  margin-bottom: var(--space-lg);
  font-style: italic;
}

.search-results-grid {
  display: grid;
  gap: var(--space-lg);
  max-width: 800px;
  margin: 0 auto;
  grid-template-columns: 1fr;
}

.search-result-card {
  cursor: pointer;
  transition: all 0.2s ease;
  border: 2px solid var(--rule);
  background: var(--card);
  padding: var(--space-lg);
  border-radius: 14px;
  box-shadow: var(--card-shadow);
  /* Force visibility */
  display: block !important;
  visibility: visible !important;
  opacity: 1 !important;
  min-height: 150px;
}

.search-result-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(0,0,0,0.15);
  border-color: var(--bronze);
}

.search-result-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: var(--space-md);
}

.search-result-header h3 {
  margin: 0;
  color: var(--bronze);
  font-size: 1.2em;
  text-align: center;
}

.search-result-type {
  background: var(--gold);
  color: #4a4a4a;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 0.8em;
  font-weight: 500;
}

.search-result-content {
  margin-bottom: var(--space-lg);
}

.search-result-summary {
  font-weight: 500;
  margin-bottom: var(--space-md);
  color: #333;
  font-size: 1.05em;
  padding: var(--space-sm);
  background: linear-gradient(90deg, var(--gold), transparent);
  border-radius: 4px;
  opacity: 0.9;
}

.search-result-category {
  font-size: 0.9em;
  color: #666;
  margin-bottom: var(--space-md);
}

.search-result-preview {
  background: #f8f4e8;
  padding: var(--space-md);
  border-radius: 8px;
  border-left: 3px solid var(--bronze);
}

.preview-field {
  margin-bottom: var(--space-sm);
  line-height: 1.4;
  font-size: 0.9em;
  padding: var(--space-sm);
  background: rgba(0,0,0,0.02);
  border-left: 3px solid var(--gold);
  border-radius: 0 4px 4px 0;
}

.preview-field:last-child {
  margin-bottom: 0;
}

.preview-field strong {
  color: var(--bronze);
  font-weight: 600;
}

.search-result-footer {
  text-align: right;
  padding-top: var(--space-md);
  border-top: 1px solid #eee;
}

.search-result-btn {
  background: var(--bronze);
  color: white;
  border-color: var(--bronze);
}

.search-result-btn:hover {
  background: #b8860b;
  border-color: #b8860b;
}

/* Force search results visibility */
.search-page .search-results-grid .search-result-card {
  display: block !important;
  visibility: visible !important;
  opacity: 1 !important;
  height: auto !important;
  min-height: 150px !important;
  background: var(--card) !important;
  border: 2px solid var(--bronze) !important;
  margin-bottom: var(--space-lg) !important;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Advanced Animations & Transitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* Page Transitions */
@keyframes pageSlideIn {
  0% {
    opacity: 0;
    transform: translateX(30px);
  }
  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes pageSlideInFromTop {
  0% {
    opacity: 0;
    transform: translateY(-20px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Content Animation */
article {
  animation: pageSlideIn 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

article.active {
  animation: pageSlideInFromTop 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

/* Staggered Entry Animation for Lists */
.staggered-entry > * {
  opacity: 0;
  animation: staggeredEntry 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}

.staggered-entry > *:nth-child(1) { animation-delay: 0.1s; }
.staggered-entry > *:nth-child(2) { animation-delay: 0.2s; }
.staggered-entry > *:nth-child(3) { animation-delay: 0.3s; }
.staggered-entry > *:nth-child(4) { animation-delay: 0.4s; }
.staggered-entry > *:nth-child(5) { animation-delay: 0.5s; }
.staggered-entry > *:nth-child(n+6) { animation-delay: 0.6s; }

@keyframes staggeredEntry {
  0% {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* Loading Animation */
@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.loading-shimmer {
  position: relative;
  overflow: hidden;
  background: linear-gradient(90deg, #f0f0f0, #e0e0e0, #f0f0f0);
  animation: shimmer 1.5s infinite linear;
}

.loading-shimmer::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
  animation: shimmer 1.5s infinite linear;
}

/* Floating Elements Animation */
@keyframes float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}

.floating {
  animation: float 3s ease-in-out infinite;
}

.floating:nth-child(2n) {
  animation-delay: 1s;
}

.floating:nth-child(3n) {
  animation-delay: 2s;
}

/* Pulse Animation for Important Elements */
@keyframes pulse {
  0%, 100% { 
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(212, 175, 55, 0.4);
  }
  50% { 
    transform: scale(1.02);
    box-shadow: 0 0 0 10px rgba(212, 175, 55, 0);
  }
}

.pulse-attention {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Text Glow Effect */
@keyframes textGlow {
  0%, 100% {
    text-shadow: 
      0 0 5px rgba(212, 175, 55, 0.2),
      0 0 10px rgba(212, 175, 55, 0.1);
  }
  50% {
    text-shadow: 
      0 0 10px rgba(212, 175, 55, 0.4),
      0 0 20px rgba(212, 175, 55, 0.2),
      0 0 30px rgba(212, 175, 55, 0.1);
  }
}

.text-glow {
  animation: textGlow 3s ease-in-out infinite;
}

/* Enhanced Hover Transitions */
.interactive-element {
  transition: 
    transform var(--transition-fast),
    box-shadow var(--transition-fast),
    background-color var(--transition-fast),
    border-color var(--transition-fast),
    color var(--transition-fast);
}

.interactive-element:hover {
  transform: translateY(-2px) scale(1.02);
}

/* Magical Sparkle Effect */
@keyframes sparkle {
  0%, 100% { opacity: 0; transform: scale(0); }
  50% { opacity: 1; transform: scale(1); }
}

.sparkle-effect::before {
  content: 'âœ¨';
  position: absolute;
  top: -5px;
  right: -5px;
  font-size: 0.8em;
  animation: sparkle 2s ease-in-out infinite;
  animation-delay: 0.5s;
}

.sparkle-effect::after {
  content: 'â­';
  position: absolute;
  bottom: -5px;
  left: -5px;
  font-size: 0.6em;
  animation: sparkle 2s ease-in-out infinite;
  animation-delay: 1.5s;
}

/* Smooth Content Transitions */
.content-transition {
  transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

.content-fade-in {
  animation: fadeInUp 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

@keyframes fadeInUp {
  0% {
    opacity: 0;
    transform: translateY(30px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Clean up card styling */

/* Illustrations */
.illus{display:flex;gap:12px;align-items:center;justify-content:center;flex-wrap:wrap;margin:.6rem 0}
.illus img{max-width:100%;height:auto;border-radius:12px; transition:all .3s ease}
.illus img.enlarged{transition:none !important}
.illus .thumb{max-width:500px;max-height:300px;width:auto;height:auto;object-fit:contain}

/* Images avec cadres - systÃ¨me unifiÃ© */
.illus-spell, .illus-class, .illus-subclass, .illus-don,
article[data-page="guerrier"] .illus,
article[data-page="mage"] .illus,
article[data-page="pretre"] .illus,
article[data-page="rodeur"] .illus,
article[data-page="enchanteur"] .illus,
.illus[data-illus-key^="class:"],
.illus[data-illus-key^="subclass:"],
.illus[data-illus-key^="spell:"],
.illus[data-illus-key^="sort:"],
.illus[data-illus-key^="spellcategory:"],
.illus[data-illus-key^="don:"] {
  display:flex !important; flex-direction:column !important; align-items:center !important;
  justify-content:center !important; margin:1rem auto !important;
}

.illus-spell img, .illus-class img, .illus-subclass img, .illus-don img,
article[data-page="guerrier"] .illus img,
article[data-page="mage"] .illus img,
article[data-page="pretre"] .illus img,
article[data-page="rodeur"] .illus img,
article[data-page="enchanteur"] .illus img,
.illus[data-illus-key^="class:"] img,
.illus[data-illus-key^="subclass:"] img,
.illus[data-illus-key^="spell:"] img,
.illus[data-illus-key^="sort:"] img,
.illus[data-illus-key^="spellcategory:"] img,
.illus[data-illus-key^="don:"] img {
  border:var(--image-border) !important; 
  box-shadow:var(--image-shadow) !important;
  padding:4px !important; 
  background:transparent !important;
  border-radius:16px !important; 
  max-width:fit-content !important;
  width:auto !important;
  cursor:pointer !important;
}

.illus-spell img:hover, .illus-class img:hover, .illus-subclass img:hover, .illus-don img:hover,
article[data-page="guerrier"] .illus img:hover,
article[data-page="mage"] .illus img:hover,
article[data-page="pretre"] .illus img:hover,
article[data-page="rodeur"] .illus img:hover,
article[data-page="enchanteur"] .illus img:hover,
.illus[data-illus-key^="class:"] img:hover,
.illus[data-illus-key^="subclass:"] img:hover,
.illus[data-illus-key^="spell:"] img:hover,
.illus[data-illus-key^="sort:"] img:hover,
.illus[data-illus-key^="spellcategory:"] img:hover,
.illus[data-illus-key^="don:"] img:hover {
  transform:scale(1.03) !important; 
  box-shadow:var(--image-shadow), 0 8px 25px rgba(139,69,19,.25) !important;
}

/* Variantes de taille d'images */
.illus-small img { max-width: 150px !important; }
.illus-large img { max-width: 400px !important; }

/* Style spÃ©cial pour les sorts - cadre dorÃ© et taille augmentÃ©e */
.illus-spell img,
.card .illus img {
  border: 3px solid var(--gold) !important;
  box-shadow: var(--image-shadow), 0 0 10px rgba(212,175,55,.3) !important;
  max-width: 350px !important;
  max-height: 250px !important;
  object-fit: contain !important;
}

/* Style spÃ©cial pour les sous-classes - 2 images centrÃ©es et collÃ©es */
.subclass-images {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0;
  margin: 0.6rem 0;
}

.subclass-images .illus {
  margin: 0;
  flex: 0 0 auto;
}

.subclass-images .illus img {
  max-width: 400px !important;
  max-height: 300px !important;
  object-fit: contain !important;
  border-radius: 12px 0 0 12px !important;
}

.subclass-images .illus:last-child img {
  border-radius: 0 12px 12px 0 !important;
}

/* Mobile: Stack subclass images vertically */
@media (max-width: 980px) {
  .subclass-images {
    flex-direction: column !important;
    gap: 8px !important;
  }
  
  .subclass-images .illus img {
    border-radius: 12px !important;
    max-width: 100% !important;
    width: 100% !important;
  }
  
  /* RÃ©duire l'espace des cadres d'images sur mobile */
  .illus-spell img, .illus-class img, .illus-subclass img, .illus-don img,
  article[data-page="guerrier"] .illus img,
  article[data-page="mage"] .illus img,
  article[data-page="pretre"] .illus img,
  article[data-page="rodeur"] .illus img,
  article[data-page="enchanteur"] .illus img,
  .illus[data-illus-key^="class:"] img,
  .illus[data-illus-key^="subclass:"] img,
  .illus[data-illus-key^="spell:"] img,
  .illus[data-illus-key^="sort:"] img,
  .illus[data-illus-key^="spellcategory:"] img,
  .illus[data-illus-key^="don:"] img {
    padding: 2px !important; /* RÃ©duire le padding de 4px Ã  2px */
    border-width: 2px !important; /* RÃ©duire l'Ã©paisseur des bordures */
    max-width: 100% !important;
    width: auto !important;
    height: auto !important;
    object-fit: contain !important;
  }
  
  /* RÃ©duire l'espace entre les images de classe et sous-classe */
  .illus {
    gap: 4px !important; /* RÃ©duire de 12px Ã  4px */
    margin: 0.3rem 0 !important; /* RÃ©duire les marges */
  }
  
  /* Images de sorts plus compactes sur mobile */
  .illus-spell img,
  .card .illus img {
    max-width: 100% !important;
    max-height: 180px !important; /* RÃ©duire de 250px Ã  180px */
    border-width: 2px !important; /* Bordure plus fine */
  }
  
  .subclass-images .illus:last-child img {
    border-radius: 12px !important;
  }
}

/* Style spÃ©cial pour les titres de sous-classes */
.subclass-title {
  font-size: 2.2rem !important;
  font-weight: 800 !important;
  text-align: center !important;
  margin: 0 0 1.5rem 0 !important;
  color: var(--accent-ink) !important;
  font-family: 'Cinzel', serif !important;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.2) !important;
  letter-spacing: 0.8px !important;
}

/* Style spÃ©cial pour les descriptions de sous-classes */
.card[data-section-type="subclass"] .editable[data-edit-section*="description"] {
  text-align: center !important;
  color: var(--paper-ink) !important;
}

.card[data-section-type="subclass"] .editable[data-edit-section*="description"] em,
.card[data-section-type="subclass"] .editable[data-edit-section*="description"] i {
  color: var(--paper-ink) !important;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ“± MOBILE & TOUCH OPTIMIZATION - Final Enhancements
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Touch-friendly interactions for mobile devices */
@media (hover: none) and (pointer: coarse) {
  .btn-base, .filter-chip, .toc a, .card {
    min-height: 44px; /* iOS/Android minimum touch target */
    min-width: 44px;
  }
  
  .toc a {
    padding: 12px;
    margin: 4px 0;
  }
  
  .filter-chip {
    padding: 8px 16px;
    margin: 2px;
  }
  
  /* Disable hover effects on touch devices */
  .card:hover, .btn-base:hover, .filter-chip:hover, .toc a:hover {
    transform: none;
    box-shadow: initial;
    background: initial;
    border-color: initial;
  }
  
  /* Add tap feedback instead */
  .btn-base:active, .filter-chip:active, .toc a:active, .card:active {
    transform: scale(0.98);
    transition: transform 0.1s ease;
    opacity: 0.8;
  }
}

/* Reduce animation complexity on low-performance devices */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
  
  .floating, .pulse-attention, .text-glow, 
  .shimmer-effect, .sparkle-effect {
    animation: none !important;
  }
  
  .card, .btn-base, .filter-chip {
    transition: none !important;
  }
}

/* Mobile-specific improvements */
@media (max-width: 480px) {
  /* Improve text readability on small screens */
  body {
    font-size: 16px;
    line-height: 1.6;
    -webkit-text-size-adjust: 100%;
  }
  
  /* Ensure images don't break layout */
  img {
    max-width: 100% !important;
    height: auto !important;
  }
  
  /* Optimize cards for mobile */
  .card, .card-base {
    border-radius: 12px;
    box-shadow: 0 4px 16px rgba(0,0,0,.1);
  }
  
  /* Mobile-friendly buttons */
  .btn-base {
    border-radius: 8px;
    font-size: 16px; /* Prevent iOS zoom */
  }
  
  /* Improve modal sizing on mobile */
  .modal-content-base {
    margin: 10px;
    max-width: calc(100vw - 20px);
    max-height: calc(100vh - 20px);
    overflow-y: auto;
  }
  
  /* Mobile search optimization */
  .searchbar input {
    font-size: 16px; /* Prevents zoom on iOS */
    padding: 12px;
    border-radius: 8px;
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ“„ SECTION SELECTION MODAL
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

.section-selection-modal {
  z-index: 999999 !important;
}

.section-selection-modal .modal-content {
  max-width: 500px;
  padding: 2rem;
}

.sections-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin: 1.5rem 0;
}

.section-option {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  border: 2px solid var(--rule);
  border-radius: 12px;
  cursor: pointer;
  transition: all var(--transition-normal);
  background: var(--card);
}

.section-option:hover {
  border-color: var(--bronze);
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.1) 0%, 
    rgba(139,69,19,0.05) 100%);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(139,69,19,0.15);
}

.section-option.selected {
  border-color: var(--gold);
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.2) 0%, 
    rgba(139,69,19,0.1) 100%);
  box-shadow: 
    0 0 0 2px rgba(212,175,55,0.3),
    0 4px 16px rgba(139,69,19,0.2);
}

.section-icon {
  font-size: 2rem;
  width: 60px;
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 12px;
  background: linear-gradient(135deg, var(--bronze), var(--gold));
  color: white;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
}

.section-info {
  flex: 1;
}

.section-title {
  font-weight: 600;
  font-size: 1.1em;
  color: var(--accent-ink);
  margin-bottom: 0.25rem;
  font-family: 'Cinzel', serif;
}

.section-description {
  color: var(--paper-muted);
  font-size: 0.9em;
  line-height: 1.4;
}

.page-details {
  padding: 1.5rem;
  background: var(--paper-soft);
  border: 1px solid var(--rule);
  border-radius: 12px;
  margin: 1rem 0;
}

.form-group {
  margin-bottom: 1rem;
}

.form-group:last-child {
  margin-bottom: 0;
}

.form-group label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 600;
  color: var(--accent-ink);
}

.form-group input {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid var(--rule);
  border-radius: 8px;
  font-size: 1em;
  background: var(--card);
  color: var(--paper-ink);
}

.form-group input:focus {
  outline: none;
  border-color: var(--bronze);
  box-shadow: 0 0 0 2px rgba(212,175,55,0.2);
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 1rem;
  margin-top: 1.5rem;
}

.btn-primary {
  background: var(--bronze) !important;
  color: white !important;
  border-color: var(--bronze) !important;
}

.btn-primary:hover {
  background: var(--gold) !important;
  border-color: var(--gold) !important;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Favoris Components â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* Cartes avec favoris - permettre l'overflow pour les boutons Ã©toile */
.card:has(.favoris-star) {
  overflow: visible !important;
}

/* Fallback pour navigateurs sans support :has() */
.spell-card,
.item-card {
  overflow: visible !important;
}

.favoris-star {
  position: absolute;
  top: 8px;
  right: 8px;
  background: rgba(0,0,0,0.1);
  border: none;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  cursor: pointer;
  transition: all 0.2s ease;
  z-index: 10;
  backdrop-filter: blur(4px);
}

.favoris-star:hover {
  background: rgba(0,0,0,0.2);
  transform: scale(1.1);
}

.favoris-star.favoris-active {
  background: rgba(255,215,0,0.2);
  color: #ffd700;
}

.favoris-star.favoris-active:hover {
  background: rgba(255,215,0,0.3);
  transform: scale(1.15);
}

/* Notification des favoris */
.favoris-notification {
  position: fixed;
  top: 20px;
  right: 20px;
  background: var(--surface-color, #f0f0f0);
  color: var(--text-color, #333);
  padding: 12px 16px;
  border-radius: 8px;
  border-left: 4px solid var(--accent-color, #d4af37);
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  z-index: 10000;
  font-size: 14px;
  max-width: 300px;
}

.favoris-notification.favoris-success {
  border-left-color: #22c55e;
  background: rgba(34,197,94,0.1);
}

.favoris-notification.favoris-info {
  border-left-color: #3b82f6;
  background: rgba(59,130,246,0.1);
}

/* Animations pour les notifications */
@keyframes slideInRight {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOutRight {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
}

/* Page favoris */
.favoris-section {
  margin: 2rem 0;
}

.favoris-section h2 {
  color: var(--accent-ink);
  border-bottom: 2px solid var(--gold);
  padding-bottom: 0.5rem;
  margin-bottom: 1rem;
}

/* Sections pliables favoris */
.favoris-collapsible {
  border: 1px solid var(--rule);
  border-radius: 12px;
  background: var(--card);
  overflow: hidden;
  transition: all 0.3s ease;
}

.favoris-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.5rem;
  cursor: pointer;
  background: var(--surface-subtle);
  border-bottom: 1px solid var(--rule);
  transition: background 0.2s ease;
}

.favoris-header:hover {
  background: var(--surface-color);
}

.favoris-header h2 {
  margin: 0;
  border: none;
  padding: 0;
  font-size: 1.3em;
  color: var(--accent-ink);
}

.favoris-toggle {
  font-size: 1.2em;
  color: var(--accent-ink);
  transition: transform 0.3s ease;
  user-select: none;
}

.favoris-collapsible.collapsed .favoris-toggle {
  transform: rotate(-90deg);
}

.favoris-content {
  padding: 1.5rem;
  max-height: none;
  overflow: visible;
  transition: max-height 0.3s ease, padding 0.3s ease;
}

.favoris-collapsible.collapsed .favoris-content {
  max-height: 0;
  padding-top: 0;
  padding-bottom: 0;
  overflow: hidden;
}

.favoris-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 1rem;
  width: 100%;
  margin: 0.5rem 0;
}

@media (max-width: 768px) {
  .favoris-grid {
    grid-template-columns: 1fr;
    gap: 0.75rem;
  }
}

.favoris-empty {
  text-align: center;
  color: var(--muted-ink);
  font-style: italic;
  padding: 2rem;
  background: var(--surface-subtle);
  border-radius: 12px;
  border: 2px dashed var(--rule);
}

/* Mise en position relative pour les cartes avec Ã©toiles */
.card.spell-card,
.card.item-card {
  position: relative;
}

/* Responsive */
@media (max-width: 768px) {
  .favoris-star {
    width: 28px;
    height: 28px;
    font-size: 14px;
    top: 6px;
    right: 6px;
  }
  
  .favoris-notification {
    right: 10px;
    top: 10px;
    max-width: calc(100vw - 20px);
  }
}

/* Mobile optimization for section selection modal */
@media (max-width: 480px) {
  .section-selection-modal .modal-content {
    padding: 1rem;
    margin: 1rem;
  }
  
  .section-option {
    padding: 0.75rem;
    gap: 0.75rem;
  }
  
  .section-icon {
    width: 48px;
    height: 48px;
    font-size: 1.5rem;
  }
  
  .modal-actions {
    flex-direction: column;
  }
  
  .modal-actions .btn {
    width: 100%;
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ–¨ï¸ PRINT STYLES - Ã‰tats imprimables
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

.print-button {
  background: var(--bronze) !important;
  color: white !important;
  border: 2px solid var(--gold) !important;
  border-radius: 8px;
  padding: 0.5rem 1rem;
  font-family: "Cinzel", serif;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.print-button:hover {
  background: var(--gold) !important;
  border-color: var(--bronze) !important;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

/* Styles pour la version imprimable */
@media print {
  @page {
    margin: 0 !important;
    size: A4 !important;
  }
  
  html, body {
    font-family: "Times New Roman", serif !important;
    background: white !important;
    color: black !important;
    margin: 0 !important;
    padding: 0 !important;
    height: auto !important;
    overflow: visible !important;
  }
  
  .printable-states {
    display: block !important;
    padding: 15mm !important;
    margin: 0 !important;
    background: white !important;
    color: black !important;
    font-size: 10pt !important;
    line-height: 1.2 !important;
    width: 100% !important;
    height: auto !important;
    position: relative !important;
    top: 0 !important;
    left: 0 !important;
  }
  
  .printable-states h1 {
    font-size: 16pt !important;
    font-weight: bold !important;
    text-align: center !important;
    margin-bottom: 5mm !important;
    color: black !important;
    text-shadow: none !important;
    background: none !important;
    -webkit-text-fill-color: initial !important;
  }
  
  .printable-states-grid {
    display: grid !important;
    grid-template-columns: 1fr 1fr !important;
    gap: 3mm !important;
    margin: 0 !important;
  }
  
  .printable-state-item {
    background: white !important;
    border: 1pt solid #ccc !important;
    border-radius: 2mm !important;
    padding: 2mm !important;
    margin: 0 !important;
    page-break-inside: avoid !important;
    font-size: 9pt !important;
    line-height: 1.1 !important;
  }
  
  .printable-state-item h3 {
    font-size: 11pt !important;
    font-weight: bold !important;
    margin: 0 0 1mm 0 !important;
    color: black !important;
    text-shadow: none !important;
    background: none !important;
    -webkit-text-fill-color: initial !important;
  }
  
  .printable-state-item p {
    margin: 0.5mm 0 !important;
    color: black !important;
    font-size: 9pt !important;
  }
  
  /* Masquer les Ã©lÃ©ments de l'interface lors de l'impression */
  #sidebar, #views, .print-button, nav, header, footer, .edit-btn, .btn {
    display: none !important;
  }
  
  /* Afficher uniquement le contenu imprimable */
  .printable-states {
    display: block !important;
  }
  
  .printable-states-grid {
    display: grid !important;
  }
  
  .printable-state-item {
    display: block !important;
  }
  
  .printable-state-item h3 {
    display: block !important;
  }
  
  .printable-state-item div {
    display: block !important;
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸµ AUDIO CONTROLS - Lecteur audio flottant
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

.audio-controls {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 1000;
  background: var(--card);
  border: 2px solid var(--bronze);
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.3);
  backdrop-filter: blur(10px);
  min-width: 280px;
  font-family: "Cinzel", serif;
}

.audio-panel {
  padding: 1rem;
}

.audio-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 0.75rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--rule);
}

.audio-icon {
  font-size: 1.2rem;
}

.audio-title {
  font-weight: 600;
  color: var(--gold);
  font-size: 0.9rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.audio-toggle-btn {
  background: none;
  border: none;
  font-size: 1.1rem;
  cursor: pointer;
  padding: 0.25rem;
  border-radius: 4px;
  transition: background 0.2s ease;
}

.audio-toggle-btn:hover {
  background: var(--rule);
}

.audio-info {
  margin-bottom: 0.75rem;
  text-align: center;
}

.playlist-name {
  font-weight: 600;
  color: var(--accent-ink);
  font-size: 0.85rem;
  margin-bottom: 0.25rem;
}

.track-name {
  font-size: 0.75rem;
  color: var(--paper-muted);
  font-style: italic;
}

.audio-controls-row {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  margin-bottom: 0.75rem;
}

.audio-btn {
  background: var(--bronze);
  border: 1px solid var(--gold);
  border-radius: 6px;
  padding: 0.5rem;
  cursor: pointer;
  font-size: 0.9rem;
  color: white;
  transition: all 0.2s ease;
  min-width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.audio-btn:hover {
  background: var(--gold);
  transform: translateY(-1px);
}

.audio-btn:active {
  transform: translateY(0);
}

.audio-volume-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.8rem;
}

.volume-icon {
  font-size: 0.9rem;
  min-width: 20px;
}

.volume-slider {
  flex: 1;
  height: 4px;
  background: var(--rule);
  border-radius: 2px;
  outline: none;
  -webkit-appearance: none;
  appearance: none;
}

.volume-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--bronze);
  cursor: pointer;
  border: 2px solid var(--gold);
}

.volume-slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--bronze);
  cursor: pointer;
  border: 2px solid var(--gold);
}

.volume-value {
  min-width: 35px;
  text-align: right;
  font-weight: 600;
  color: var(--accent-ink);
}

/* Responsive pour mobile */
@media (max-width: 480px) {
  .audio-controls {
    bottom: 10px;
    right: 10px;
    left: 10px;
    min-width: auto;
  }
  
  .audio-panel {
    padding: 0.75rem;
  }
  
  .audio-title {
    font-size: 0.8rem;
  }
  
  .audio-controls-row {
    gap: 0.75rem;
  }
  
  .audio-btn {
    min-width: 40px;
    height: 40px;
    font-size: 1rem;
  }
}

/* Masquer lors de l'impression */
@media print {
  .audio-controls {
    display: none !important;
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ”§ AUDIO PAGE CONTROLS - Boutons stables pour la page audio
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

.audio-control-btn {
  background: var(--bronze) !important;
  color: white !important;
  border: none !important;
  padding: 1rem 2rem !important;
  border-radius: 8px !important;
  cursor: pointer !important;
  font-family: "Cinzel", serif !important;
  font-size: 1rem !important;
  font-weight: 600 !important;
  text-transform: uppercase !important;
  letter-spacing: 0.5px !important;
  transition: none !important;
  min-width: 160px !important;
  min-height: 50px !important;
  user-select: none !important;
  -webkit-user-select: none !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  text-align: center !important;
}

.audio-control-btn:hover {
  background: var(--gold) !important;
  transform: none !important;
  box-shadow: none !important;
}

.audio-control-btn:active {
  background: var(--bronze) !important;
  transform: scale(0.98) !important;
}

.playlist-select-btn {
  background: var(--bronze) !important;
  color: white !important;
  border: none !important;
  padding: 1rem 1.5rem !important;
  border-radius: 6px !important;
  cursor: pointer !important;
  font-family: "Cinzel", serif !important;
  font-size: 0.95rem !important;
  font-weight: 600 !important;
  transition: none !important;
  min-width: 120px !important;
  min-height: 45px !important;
  user-select: none !important;
  -webkit-user-select: none !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  text-align: center !important;
}

.playlist-select-btn:hover {
  background: var(--gold) !important;
  transform: none !important;
  box-shadow: none !important;
}

.playlist-select-btn:active {
  transform: scale(0.98) !important;
}

/* Slider de volume amÃ©liorÃ© */
#master-volume {
  -webkit-appearance: none !important;
  appearance: none !important;
  height: 6px !important;
  background: var(--rule) !important;
  border-radius: 3px !important;
  outline: none !important;
  cursor: pointer !important;
  transition: none !important;
}

#master-volume::-webkit-slider-thumb {
  -webkit-appearance: none !important;
  appearance: none !important;
  width: 20px !important;
  height: 20px !important;
  border-radius: 50% !important;
  background: var(--bronze) !important;
  cursor: pointer !important;
  border: 2px solid var(--gold) !important;
  transition: none !important;
}

#master-volume::-webkit-slider-thumb:hover {
  background: var(--gold) !important;
  border-color: var(--bronze) !important;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Notification Animations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
@keyframes slideInRight {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOutRight {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
}

/* Notification positioning and styles */
.notification {
  position: fixed !important;
  top: 20px !important;
  right: 20px !important;
  padding: 12px 20px !important;
  border-radius: 8px !important;
  z-index: 1001 !important;
  font-size: 14px !important;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3) !important;
  font-family: inherit !important;
  font-weight: 500 !important;
}

#master-volume::-moz-range-thumb {
  width: 20px !important;
  height: 20px !important;
  border-radius: 50% !important;
  background: var(--bronze) !important;
  cursor: pointer !important;
  border: 2px solid var(--gold) !important;
  transition: none !important;
}

#master-volume::-moz-range-thumb:hover {
  background: var(--gold) !important;
  border-color: var(--bronze) !important;
}


/* Editor and Dev Mode styles */

/* === HIDE ALL EDITING ELEMENTS IN STANDALONE MODE === */
/* Hide all editing elements when dev mode is OFF */

/* ULTRA NUCLEAR OPTION - Hide ALL editing buttons when dev mode is OFF */
/* This rule will override ANY other CSS that might be showing edit buttons */
body.dev-off button[title*="âœï¸"],
body.dev-off *[class*="edit"],
body.dev-off *[class*="Edit"],

body.dev-off button[data-category-name],
body.dev-off button[data-spell-name], 
body.dev-off button[data-don-name],
body.dev-off button[data-section-name],
body.dev-off button[data-section-type],
body.dev-off .btn:is([class*="add"], [class*="delete"], [class*="remove"], [class*="move"], [class*="edit"]),
body.dev-off .add-paragraph-btn,
body.dev-off .section-delete,
body.dev-off .spell-delete,
body.dev-off .don-delete,
body.dev-off .objet-delete,
body.dev-off .spell-category-delete,
body.dev-off .don-category-delete,
body.dev-off .objet-category-delete,
body.dev-off .don-move-up,
body.dev-off .don-move-down,
body.dev-off .remove-section-btn,
body.dev-off .illus .up,
body.dev-off .illus .rm,
body.dev-off .illus label.up,
body.dev-off .illus button.rm,
body.dev-off .illus label,
body.dev-off .illus input[type="file"],
body.dev-off button[class*="add"]:not(.menu-toggle),
body.dev-off button[class*="delete"],
body.dev-off button[class*="remove"],
body.dev-off button[class*="move"],
body.dev-off button[class*="edit"],
body.dev-off .spell-add,
body.dev-off .don-add,
body.dev-off .objet-add,
body.dev-off .category-add,
body.dev-off .add-*,
body.dev-off [data-bound] .up,
body.dev-off [data-bound] .rm,
body.dev-off [data-bound] label,
body.dev-off [data-bound] button,
body.dev-off .illus[data-bound] .up,
body.dev-off .illus[data-bound] .rm,
body.dev-off .illus[data-bound] label,
body.dev-off .illus[data-bound] button,
body.dev-off .illus[data-bound] input[type="file"],
body.dev-off [data-dev-only],
body.dev-off div[data-dev-only],
body.dev-off .dev-mode-buttons,
body.dev-off .manage-tags-btn,
body.dev-off .add-monster-btn,
body.dev-off button[data-content-type],
body.dev-off .tags-manager-btn,
body.dev-off .filter-manager-btn,
body.dev-off button[class*="tags"],
body.dev-off button[class*="manage"],
/* Specific button selectors */
body.dev-off button[data-category-name],
body.dev-off button[data-spell-name],
body.dev-off button[data-don-name],
body.dev-off button[data-section-name],
body.dev-off button[data-section-type],
/* Input file upload elements */
body.dev-off input[type="file"],
body.dev-off label[for*="file"],
/* Additional specific selectors */
body.dev-off .add-subclass-btn,
body.dev-off .add-new-section,
/* COMPREHENSIVE EDIT BUTTON HIDING */
body.dev-off .edit-btn,
body.dev-off .edit-title-btn,
body.dev-off .edit-paragraph-btn,
body.dev-off .edit-list-btn,
body.dev-off .edit-field-btn,
body.dev-off .edit-effect-btn,
body.dev-off .edit-stats-btn,
body.dev-off .edit-section-btn,
body.dev-off button.edit-btn,
body.dev-off button.edit-title-btn,
body.dev-off button.edit-paragraph-btn,
body.dev-off button.edit-list-btn,
body.dev-off button.edit-field-btn,
body.dev-off button.edit-effect-btn,
body.dev-off button.edit-stats-btn,
body.dev-off button.edit-section-btn,
body.dev-off .editable-section .edit-btn,
body.dev-off .editable-section button[class*="edit"],
body.dev-off .card .edit-btn,
body.dev-off .card button[class*="edit"],
body.dev-off .editable-item .edit-btn,
body.dev-off .editable-item button[class*="edit"],
body.dev-off [data-section-type] .edit-btn,
body.dev-off [data-section-type] button[class*="edit"],
body.dev-off .add-*-btn,
/* Very specific selectors for inline styled buttons */
body.dev-off button[style*="background: #ff6b6b"],
body.dev-off button[style*="background: var(--bronze)"],
body.dev-off button[style*="background: #dc2626"],
body.dev-off button[style*="background: var(--accent)"],
/* Target buttons by text content patterns */
body.dev-off .btn.small[data-category-name],
body.dev-off .btn.small[data-spell-name],  
body.dev-off .btn.small[data-don-name],
body.dev-off .btn.small[data-section-name],
body.dev-off .btn.small[data-don-index],
/* ULTRA FORCÃ‰ - Cacher TOUS les boutons de gestion des tags */
/* ULTRA-SPECIFIC RULES FOR IMAGE UPLOAD BUTTONS */
body.dev-off .illus label.up,
body.dev-off .illus button.rm,
body.dev-off label:contains("ğŸ“·"),
body.dev-off label:contains("Ajouter"),
body.dev-off button:contains("ğŸ—‘"),
body.dev-off button:contains("Retirer"),
body.dev-off .card .illus .up,
body.dev-off .card .illus .rm,
body.dev-off .card .illus label,
body.dev-off .card .illus button,
body.dev-off .card [data-bound] .up,
body.dev-off .card [data-bound] .rm,
/* ULTRA-SPECIFIC RULES FOR OBJECTS PAGE */
body.dev-off article[data-page="objets"] .illus label.up,
body.dev-off article[data-page="objets"] .illus button.rm,
body.dev-off article[data-page="objets"] .card .illus label,
body.dev-off article[data-page="objets"] .card .illus button,
body.dev-off #objets-container .illus label.up,
body.dev-off #objets-container .illus button.rm,
body.dev-off #objets-container .card .illus label,
body.dev-off #objets-container .card .illus button,
/* RULES WITH DATA ATTRIBUTES FOR OBJECTS */
body.dev-off .card[data-type="objet"] .illus label.up,
body.dev-off .card[data-type="objet"] .illus button.rm,
body.dev-off .card[data-type="objet"] .illus label,
body.dev-off .card[data-type="objet"] .illus button,
body.dev-off .card[data-category="objets"] .illus label.up,
body.dev-off .card[data-category="objets"] .illus button.rm,
body.dev-off .card[data-category="objets"] .illus label,
body.dev-off .card[data-category="objets"] .illus button,
/* Collections d'objets page specific rules */
body.dev-off article[data-page="collections-objets"] .illus label.up,
body.dev-off article[data-page="collections-objets"] .illus button.rm,
body.dev-off article[data-page="collections-objets"] .illus label,
body.dev-off article[data-page="collections-objets"] .illus button,
body.dev-off #collection-items .illus label.up,
body.dev-off #collection-items .illus button.rm,
body.dev-off #collection-items .illus label,
body.dev-off #collection-items .illus button,
/* ULTRA-SPECIFIC RULES FOR TAG MANAGER BUTTONS */
body.dev-off button.manage-tags-btn,
body.dev-off button.tags-manager-btn,
body.dev-off .btn.manage-tags-btn,
body.dev-off .btn.tags-manager-btn,
body.dev-off button[data-content-type="monster"],
body.dev-off button[data-content-type="objet"],
body.dev-off button[data-content-type="tableTresor"],
body.dev-off .dev-mode-buttons button,
body.dev-off div[data-dev-only] button,
body.dev-off div[data-dev-only],
body.dev-off .btn.btn-small.manage-tags-btn,
body.dev-off button.btn.btn-small.manage-tags-btn,
body.dev-off .dev-mode-buttons .manage-tags-btn,
body.dev-off [data-dev-only] .manage-tags-btn,
body.dev-off .tableTresor-add,
body.dev-off .add-monster-btn,
body.dev-off .btn.add-monster-btn,
body.dev-off .tags-manager-btn,
body.dev-off .filter-manager-btn,
body.dev-off button[title*="GÃ©rer les tags"],
body.dev-off button[title*="gÃ©rer les tags"],
body.dev-off button[onclick*="showTagsManagementModal"],
body.dev-off button[onclick*="showMonsterTagsManagement"],
/* Additional super specific selectors for any possible generated button */
html body.dev-off button.manage-tags-btn,
html body.dev-off button.tags-manager-btn,
html body.dev-off .btn.manage-tags-btn,
html body.dev-off .btn.tags-manager-btn,
/* Text content matching */
body.dev-off button:contains("ğŸ·ï¸ GÃ©rer les tags"),
body.dev-off button:contains("GÃ©rer les tags") {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  position: absolute !important;
  left: -9999px !important;
  width: 0 !important;
  height: 0 !important;
  overflow: hidden !important;
  pointer-events: none !important;
}

/* Styles for dev buttons container */
.dev-buttons-container {
  display: flex;
  gap: 8px;
  margin-bottom: 1rem;
  flex-wrap: wrap;
}

/* Hide dev buttons container completely in dev-off mode */
body.dev-off .dev-buttons-container,
body.dev-off div[data-dev-only] {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
}

/* Element selectors for spells and monsters - Solution ultra-forcÃ©e */
.spell-element-selector,
.spell-element-selector *,
div.spell-element-selector,
.card .spell-element-selector,
.monster-element-selector,
.monster-element-selector *,
div.monster-element-selector,
.card .monster-element-selector {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  position: absolute !important;
  left: -9999px !important;
  width: 0 !important;
  height: 0 !important;
  overflow: hidden !important;
}

/* Modal buttons should always be visible */
dialog .delete-monster-tag-btn,
dialog .btn,
dialog button {
  display: inline-flex !important;
  visibility: visible !important;
  opacity: 1 !important;
  pointer-events: auto !important;
  position: static !important;
  left: auto !important;
  width: auto !important;
  height: auto !important;
  overflow: visible !important;
}

/* SEULEMENT visible en mode dev */
body.dev-on .spell-element-selector,
body.dev-on .spell-element-selector *,
body.dev-on div.spell-element-selector,
body.dev-on .card .spell-element-selector,
body.dev-on .monster-element-selector,
body.dev-on .monster-element-selector *,
body.dev-on div.monster-element-selector,
body.dev-on .card .monster-element-selector {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  position: static !important;
  left: auto !important;
  width: auto !important;
  height: auto !important;
  overflow: visible !important;
}

body.dev-off .spell-element-display,
body.dev-off .monster-element-display {
  display: block !important;
}

body.dev-on .spell-element-display,
body.dev-on .monster-element-display {
  display: none !important;
}

/* COMPREHENSIVE SHOW RULES FOR DEV MODE - High specificity to override dev-off hiding */
body.dev-on .edit-btn,
body.dev-on button.edit-btn,
body.dev-on button[class*="edit"],
body.dev-on button[class*="add"]:not(.menu-toggle),
body.dev-on button[class*="delete"],
body.dev-on button[class*="remove"],
body.dev-on button[class*="move"],
body.dev-on .section-delete,
body.dev-on .spell-delete,
body.dev-on .don-delete,
body.dev-on .add-subclass-btn,
body.dev-on .delete-subclass-btn,
body.dev-on .add-paragraph-btn,
body.dev-on .remove-section-btn,
body.dev-on .illus .up,
body.dev-on .illus .rm,
body.dev-on .illus label,
body.dev-on .illus input[type="file"],
body.dev-on button[data-category-name],
body.dev-on button[data-spell-name],
body.dev-on button[data-don-name],
body.dev-on button[data-section-name],
body.dev-on button[data-section-type],
/* Extra specific selectors to match the hiding rules exactly */
body.dev-on .spell-add,
body.dev-on .don-add,
body.dev-on .objet-add,
body.dev-on .category-add,
body.dev-on .spell-category-delete,
body.dev-on .don-category-delete,
body.dev-on .objet-category-delete,
body.dev-on .don-move-up,
body.dev-on .don-move-down,
body.dev-on button[title*="Ã‰diter"],
body.dev-on button[title*="Edit"],
body.dev-on button[title*="Supprimer"],
body.dev-on button[title*="Ajouter"],
body.dev-on [data-dev-only],
body.dev-on .dev-mode-buttons,
body.dev-on .manage-tags-btn,
body.dev-on .add-monster-btn,
body.dev-on .tags-manager-btn {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  pointer-events: auto !important;
  position: relative !important;
}

/* Limit objects to max 4 per row in dev mode */
body.dev-on #objets-container {
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  max-width: 1300px; /* Ensures max 4 columns on most screens */
}

/* Force max 4 columns on larger screens in dev mode */
@media (min-width: 1600px) {
  body.dev-on #objets-container {
    grid-template-columns: repeat(4, 1fr);
    max-width: 1300px;
  }
}

/* ULTIMATE SOLUTION: Force dimensions to prevent 0x0 collapse */
html body.dev-on .edit-btn,
html body.dev-on button[class*="edit"],
html body.dev-on button[class*="add"],
html body.dev-on button[class*="delete"],
html body.dev-on .section-delete,
html body.dev-on .add-paragraph-btn {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  width: 28px !important;
  height: 28px !important;
  min-width: 28px !important;
  min-height: 28px !important;
  background: rgba(139,69,19,0.1) !important;
  border: 1px solid var(--bronze) !important;
  border-radius: 6px !important;
  color: var(--bronze) !important;
  font-size: 14px !important;
  padding: 4px !important;
  margin-left: 8px !important;
  box-sizing: border-box !important;
  line-height: 1 !important;
  cursor: pointer !important;
  position: relative !important;
  top: 0 !important;
  left: 0 !important;
  transform: none !important;
  z-index: 10 !important;
}
/* Target specific button classes from renderer */
body.dev-off .spell-add,
body.dev-off .don-add,
body.dev-off .objet-add,
body.dev-off .spell-delete,
body.dev-off .don-delete,
body.dev-off .objet-delete,
body.dev-off .spell-category-delete,
body.dev-off .don-category-delete,
body.dev-off .objet-category-delete,
body.dev-off .don-move-up,
body.dev-off .don-move-down,
body.dev-off .section-delete,
body.dev-off .remove-section-btn,
/* Universal button selectors with edit-related titles */
body.dev-off button[title*="diter"],
body.dev-off button[title*="Edit"],
body.dev-off button[title*="Supprimer"],
body.dev-off button[title*="Ajouter"],
body.dev-off button[title*="Haut"],
body.dev-off button[title*="Bas"],
/* AJOUT: SÃ©lecteurs pour les boutons add/delete */
body.dev-off button[class*="add"],
body.dev-off button[class*="delete"],
body.dev-off button[class*="remove"],
body.dev-off button[class*="move"],
body.dev-off button[class*="upload"],
body.dev-off button[class*="edit"] {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  pointer-events: none !important;
}

/* Exception: les boutons favoris doivent TOUJOURS Ãªtre visibles */
body.dev-off button.favoris-star,
body.dev-on button.favoris-star {
  display: flex !important;
  visibility: visible !important;
  opacity: 1 !important;
  pointer-events: auto !important;
}

/* SPÃ‰CIFIQUE: RÃ¨gles avec spÃ©cificitÃ© maximale pour forcer le masquage */
body.dev-off button.spell-add.btn,
body.dev-off button.don-add.btn,
body.dev-off button.objet-add.btn,
body.dev-off button.spell-category-delete.btn,
body.dev-off button.don-category-delete.btn,
body.dev-off button.objet-category-delete.btn,
/* ULTRA-SPÃ‰CIFIQUE: Tags manager buttons */
body.dev-off button.tags-manager-btn.btn,
body.dev-off button.filter-manager-btn.btn,
html body.dev-off .tags-manager-btn,
html body.dev-off .filter-manager-btn,
html body.dev-off button.tags-manager-btn,
html body.dev-off button.filter-manager-btn {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  pointer-events: none !important;
}

/* Ancien systÃ¨me d'agrandissement - dÃ©sactivÃ© */
.illus img.enlarged {
  /* Plus de style ici - gÃ©rÃ© par JavaScript modal */
}

/* Forcer l'Ã©tat stable sur hover pour les images agrandies */
.illus img.enlarged:hover,
article[data-page="guerrier"] .illus img.enlarged:hover,
article[data-page="mage"] .illus img.enlarged:hover,
article[data-page="pretre"] .illus img.enlarged:hover,
article[data-page="rodeur"] .illus img.enlarged:hover,
article[data-page="enchanteur"] .illus img.enlarged:hover,
.illus[data-illus-key^="class:"] img.enlarged:hover,
article[data-page="sorts-mage"] .illus img.enlarged:hover,
article[data-page="sorts-pretre"] .illus img.enlarged:hover,
article[data-page="sorts-enchanteur"] .illus img.enlarged:hover,
.illus[data-illus-key^="spellcategory:"] img.enlarged:hover {
  transform:translate(-50%, -50%) !important;
  transition:none !important;
}

/* Ancien backdrop - plus utilisÃ© */
.image-backdrop {
  display: none !important;
}

/* Interactive buttons */
.btn-action{display:inline-flex;gap:var(--space-sm);align-items:center;padding:var(--space-sm) 10px;border-radius:10px;cursor:pointer;border:1px solid}
.btn-upload{border-color:rgba(0,0,0,.25);border-style:dashed;background:#fff8ee}
.btn-remove{border-color:rgba(120,0,0,.25);background:#fee2e2}
.btn-add{border-color:rgba(0,120,0,.25);background:#f0fff4;margin-bottom:10px}
.btn-delete{padding:var(--space-xs) var(--space-md);border-radius:6px;font-size:12px;margin-left:10px}
.illus .up{border-color:rgba(0,0,0,.25);border-style:dashed;background:#fff8ee}
.illus .rm, .spell-delete{border-color:rgba(120,0,0,.25);background:#fee2e2}
.spell-add{border-color:rgba(0,120,0,.25);background:#f0fff4;margin-bottom:10px}
.spell-delete{padding:var(--space-xs) var(--space-md);border-radius:6px;font-size:12px;margin-left:10px}

/* Bouton d'ajout de paragraphe - seulement dans les articles */
.add-paragraph-btn {
  display:none !important;
}
/* Masquer explicitement dans la sidebar et le sommaire */
.sidebar .add-paragraph-btn,
.toc .add-paragraph-btn,
#toc .add-paragraph-btn {
  display:none !important;
  visibility:hidden !important;
}
/* Afficher SEULEMENT dans les articles actifs en mode dev */
body.dev-on article.active .add-paragraph-btn {
  display:block !important; margin:10px 0; padding:8px 12px; background:var(--card); 
  border:2px dashed var(--bronze); border-radius:8px; cursor:pointer;
  color:var(--bronze); text-align:center; transition:all .2s ease;
}
body.dev-on article.active .add-paragraph-btn:hover {
  background:rgba(139,69,19,.08); border-color:var(--gold);
  color:var(--gold);
}

/* Bouton d'ajout de sous-classe */
.add-subclass-btn {
  display:none; margin:12px 0 4px 0; padding:8px 12px; background:var(--card);
  border:1px dashed var(--bronze); border-radius:8px; cursor:pointer;
  color:var(--bronze); text-align:center; font-size:13px;
  transition:all .2s ease; width:100%;
}
/* Afficher dans les pages de classes en mode dev */
body.dev-on article[data-page="guerrier"] .add-subclass-btn,
body.dev-on article[data-page="mage"] .add-subclass-btn,
body.dev-on article[data-page="pretre"] .add-subclass-btn,
body.dev-on article[data-page="rodeur"] .add-subclass-btn,
body.dev-on article[data-page="enchanteur"] .add-subclass-btn {
  display:block !important;
}
body.dev-on article[data-page="guerrier"] .add-subclass-btn:hover,
body.dev-on article[data-page="mage"] .add-subclass-btn:hover,
body.dev-on article[data-page="pretre"] .add-subclass-btn:hover,
body.dev-on article[data-page="rodeur"] .add-subclass-btn:hover,
body.dev-on article[data-page="enchanteur"] .add-subclass-btn:hover {
  background:rgba(139,69,19,.08); border-color:var(--gold);
  color:var(--gold); transform:translateY(-1px);
  box-shadow:0 4px 8px rgba(0,0,0,.1);
}

/* Modales */
.category-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.category-modal.visible {
  display:flex;
}
.category-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:500px; width:90%; box-shadow:var(--shadow);
  position:relative;
}

/* Modal pour les icÃ´nes */
.icons-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.icons-modal.visible {
  display:flex;
}
.icons-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:600px; width:90%; max-height:80vh; overflow-y:auto;
  box-shadow:var(--shadow); position:relative;
}
.icons-grid {
  display:grid; grid-template-columns:repeat(auto-fill, minmax(60px, 1fr));
  gap:var(--space-md); margin:var(--space-xl) 0; max-height:400px; overflow-y:auto;
  border:1px solid var(--rule); border-radius:var(--space-md); padding:var(--space-xl);
}
.icon-item {
  display:flex; align-items:center; justify-content:center;
  padding:var(--space-lg); border:1px solid var(--rule); border-radius:var(--space-md);
  cursor:pointer; transition:var(--transition-fast); font-size:24px;
  background:var(--paper);
}
.icon-item:hover {
  background:var(--bronze); color:white; transform:scale(1.1);
  box-shadow:0 4px 8px rgba(0,0,0,.2);
}
.icon-item.copied {
  background:var(--gold); color:white; animation:copyFlash .5s ease;
}
@keyframes copyFlash {
  0% { transform:scale(1.1); }
  50% { transform:scale(1.3); }
  100% { transform:scale(1.1); }
}

/* Modal pour les Ã©lÃ©ments */
.elements-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:2147483647; display:none; align-items:center; justify-content:center;
}
.elements-modal.visible {
  display:flex;
}
.elements-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:400px; width:90%; 
  box-shadow:var(--shadow); position:relative;
}
.elements-list {
  display:flex; flex-direction:column; gap:var(--space-md); margin:var(--space-xl) 0;
}
.element-item {
  display:flex; align-items:center; gap:var(--space-md); padding:var(--space-md);
  border:2px solid var(--rule); border-radius:var(--space-md); cursor:pointer;
  transition:var(--transition-fast); background:var(--card);
}
.element-item:hover {
  background:var(--paper); border-color:var(--bronze); transform:translateY(-2px);
  box-shadow:0 4px 12px rgba(0,0,0,.1);
}
.element-item:active {
  transform:translateY(0) scale(0.98);
}
.element-icon {
  width:24px; height:24px; border-radius:50%; flex-shrink:0;
}
.element-name {
  font-weight:600; flex-grow:1;
}
.copy-indicator {
  font-size:12px; color:var(--paper-muted); opacity:0;
  transition:opacity 0.3s ease;
}
.element-item.copied .copy-indicator {
  opacity:1;
}

/* Ã‰tats modal styles */
.etats-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:2147483647; display:none; align-items:center; justify-content:center;
}
.etats-modal.visible {
  display:flex;
}
.etats-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:500px; width:90%; 
  box-shadow:var(--shadow); position:relative; max-height:80vh; overflow-y:auto;
}
.etats-list {
  display:flex; flex-direction:column; gap:var(--space-md); margin:var(--space-xl) 0;
}
.etat-item {
  display:flex; align-items:flex-start; gap:var(--space-md); padding:var(--space-md);
  border:2px solid var(--rule); border-radius:var(--space-md); cursor:pointer;
  transition:var(--transition-fast); background:var(--card); position:relative;
}
.etat-content {
  flex:1; display:flex; flex-direction:column;
}
.etat-item:hover {
  background:var(--paper); border-color:var(--bronze); transform:translateY(-2px);
  box-shadow:0 4px 12px rgba(0,0,0,.1);
}
.etat-item:active {
  transform:translateY(0) scale(0.98);
}
.etat-icon {
  width:24px; height:24px; border-radius:50%; flex-shrink:0;
  background:var(--bronze); color:white; display:flex; align-items:center;
  justify-content:center; font-size:14px;
}
.etat-name {
  font-weight:600; color:var(--accent-ink); margin-bottom:4px;
}
.etat-description {
  font-size:12px; color:var(--paper-muted); line-height:1.4;
}
.etat-item .copy-indicator {
  position:absolute; top:50%; right:var(--space-md); transform:translateY(-50%);
  font-size:12px; color:var(--bronze); opacity:0; font-weight:600;
  transition:opacity 0.3s ease;
}
.etat-item.copied .copy-indicator {
  opacity:1;
}

/* Styles pour les tooltips d'Ã©tats */
span[title] {
  cursor: help;
  border-bottom: 2px solid var(--bronze);
  position: relative;
  display: inline-block;
  background: linear-gradient(135deg, rgba(205,127,50,0.1), rgba(212,175,55,0.05));
  padding: 2px 4px;
  border-radius: 3px;
  font-weight: 700;
}

/* Styles pour les liens de sorts */
.spell-link {
  color: #ea7332 !important; /* Orange au lieu du jaune */
  cursor: pointer;
  text-decoration: underline;
  font-weight: 600;
  transition: color 0.2s ease;
}

.spell-link:hover {
  color: var(--bronze) !important;
}

/* Styles pour les liens d'Ã©tats */
.etat-link {
  color: #ea7332 !important; /* Orange au lieu du jaune */
  cursor: pointer;
  text-decoration: underline;
  font-weight: 600;
  transition: color 0.2s ease;
}

.etat-link:hover {
  color: var(--bronze) !important;
}

/* Modal des liens de sorts */
.spell-links-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  z-index: 2147483647;
  display: none;
  align-items: center;
  justify-content: center;
}

.spell-links-modal.visible {
  display: flex;
}

.spell-links-modal-content {
  background: var(--card);
  border: 2px solid var(--rule);
  border-radius: 16px;
  padding: var(--space-2xl);
  max-width: 600px;
  width: 90%;
  box-shadow: var(--shadow);
  position: relative;
  max-height: 80vh;
  overflow-y: auto;
}

.spell-item {
  display: flex;
  align-items: flex-start;
  gap: var(--space-md);
  padding: var(--space-md);
  border: 2px solid var(--rule);
  border-radius: var(--space-md);
  cursor: pointer;
  transition: var(--transition-fast);
  background: var(--card);
  position: relative;
  margin-bottom: 8px;
}

.spell-item:hover {
  background: var(--paper);
  border-color: var(--bronze);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.spell-item:active {
  transform: translateY(0) scale(0.98);
}

.spell-info {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.spell-name {
  font-weight: 600;
  margin-bottom: 4px;
  font-size: 14px;
}

.spell-meta {
  font-size: 12px;
  color: var(--paper-muted);
  margin-bottom: 6px;
}

.spell-description {
  font-size: 14px;
  color: var(--paper-muted);
  line-height: 1.4;
}

.spell-item .copy-indicator {
  position: absolute;
  top: 50%;
  right: var(--space-md);
  transform: translateY(-50%);
  font-size: 12px;
  color: var(--bronze);
  opacity: 0;
  font-weight: 600;
  transition: opacity 0.3s ease;
}

.spell-item.copied .copy-indicator {
  opacity: 1;
}

/* Styles pour les monstres - identiques aux sorts */
.monster-item {
  display: flex;
  align-items: flex-start;
  gap: var(--space-md);
  padding: var(--space-md);
  border: 2px solid var(--rule);
  border-radius: var(--space-md);
  cursor: pointer;
  transition: var(--transition-fast);
  background: var(--card);
  position: relative;
  margin-bottom: 8px;
}

.monster-item:hover {
  background: var(--paper);
  border-color: var(--bronze);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.monster-item:active {
  transform: translateY(0) scale(0.98);
}

.monster-info {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.monster-name {
  font-weight: 600;
  margin-bottom: 4px;
  font-size: 14px;
}

.monster-meta {
  font-size: 12px;
  color: var(--paper-muted);
  margin-bottom: 6px;
}

.monster-description {
  font-size: 14px;
  color: var(--paper-muted);
  line-height: 1.4;
}

.monster-item .copy-indicator {
  position: absolute;
  top: 50%;
  right: var(--space-md);
  transform: translateY(-50%);
  font-size: 12px;
  color: var(--bronze);
  opacity: 0;
  font-weight: 600;
  transition: opacity 0.3s ease;
}

.monster-item.copied .copy-indicator {
  opacity: 1;
}

/* Popup de prÃ©visualisation des monstres */
.monster-preview-popup {
  position: fixed;
  z-index: 10001;
  background: var(--card);
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  max-width: 450px;
  max-height: 600px;
  overflow-y: auto;
  font-family: 'Roboto', sans-serif;
  line-height: 1.4;
}

.monster-preview-popup .monster-preview-header {
  background: linear-gradient(135deg, var(--bronze), var(--accent));
  color: white;
  padding: var(--space-lg);
  border-radius: 8px 8px 0 0;
  font-weight: bold;
  font-size: 16px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.monster-preview-popup .monster-preview-content {
  padding: var(--space-lg);
}

.monster-preview-popup .monster-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 8px;
  margin: var(--space-md) 0;
}

.monster-preview-popup .monster-stat {
  background: var(--paper);
  padding: 8px;
  border-radius: 4px;
  text-align: center;
  font-size: 12px;
}

.monster-preview-popup .monster-stat-label {
  font-weight: 600;
  color: var(--paper-muted);
  margin-bottom: 2px;
}

.monster-preview-popup .monster-stat-value {
  font-weight: bold;
  font-size: 14px;
}

/* Popup de prÃ©visualisation des sorts */
.spell-preview-popup {
  position: fixed;
  z-index: 10001;
  background: var(--card);
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  max-width: 400px;
  max-height: 500px;
  overflow-y: auto;
  font-family: 'Roboto', sans-serif;
  line-height: 1.4;
}

.spell-preview-content {
  padding: 0;
}

.spell-preview-header {
  padding: 16px;
  background: var(--paper);
  border-radius: 8px 8px 0 0;
  position: relative;
  border-left: 4px solid var(--accent);
}

.spell-title {
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 4px;
  font-family: 'Cinzel', serif;
}

/* RÃ¨gle gÃ©nÃ©rale pour spell-element dans les cartes */
.card .spell-element {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  /* Pas de couleur par dÃ©faut - utilise les couleurs inline des Ã©lÃ©ments */
}

/* Couleur de fallback uniquement si aucune couleur inline n'est dÃ©finie */
.card .spell-element:not([style*="color"]) {
  color: var(--paper-muted);
}

/* Badge d'Ã©lÃ©ment avec texte noir pour lisibilitÃ© */
.element-badge {
  color: var(--paper-ink) !important;
  text-shadow: none !important;
}

/* S'assurer que la toolbox dev reste cliquable mÃªme avec modale ouverte */
#devToggle,
#devToolbox,
.tools,
.dev-toolbox {
  position: relative;
  z-index: 999999 !important;
}

/* Boutons de la toolbox dev toujours cliquables */
body.dev-on #devToggle,
body.dev-on #devToolbox *,
body.dev-on .tools *,
body.dev-on .dev-toolbox * {
  z-index: 999999 !important;
  pointer-events: auto !important;
}

/* Z-index maximum pour l'interface dev au-dessus des modales et dialogues */
.tools button,
.dev-toolbox button,
#devToggle,
#devToolbox button {
  z-index: 9999999 !important;
  position: relative;
}

/* Conteneur principal des outils dev */
.tools,
.dev-toolbox {
  z-index: 9999999 !important;
  position: relative;
}

/* Forcer les modales toolbox Ã  apparaÃ®tre devant les dialogues d'Ã©dition HTML */
.elements-modal,
.etats-modal, 
.spell-links-modal,
.monster-links-modal {
  z-index: 2147483647 !important; /* Maximum z-index possible */
}

.elements-modal-content,
.etats-modal-content,
.spell-links-modal-content,
.monster-links-modal-content {
  z-index: 2147483647 !important;
  position: relative;
}

/* RÃ¨gle spÃ©cifique pour spell-element dans les popups de prÃ©visualisation */
.spell-preview-popup .spell-element {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  /* Pas de couleur dÃ©finie ici - elle sera dÃ©finie en inline */
}

/* Force les couleurs des Ã©lÃ©ments - spÃ©cificitÃ© maximale */
.spell-links-modal .spell-meta[style*="color"],
.spell-preview-popup .spell-element[style*="color"] {
  color: var(--accent-ink) !important;
}

/* RÃ¨gles pour les nouveaux attributs de donnÃ©es */
[data-element-display],
[data-spell-meta] {
  color: inherit !important;
  font-weight: 600;
}

/* Alternative: couleurs directes par Ã©lÃ©ment */
.spell-preview-popup .spell-element[style*="#e25822"] { color: #e25822 !important; }
.spell-preview-popup .spell-element[style*="#2563eb"] { color: #2563eb !important; }
.spell-preview-popup .spell-element[style*="#92400e"] { color: #92400e !important; }
.spell-preview-popup .spell-element[style*="#059669"] { color: #059669 !important; }
.spell-preview-popup .spell-element[style*="#d97706"] { color: #d97706 !important; }
.spell-preview-popup .spell-element[style*="#6b21a8"] { color: #6b21a8 !important; }
.spell-preview-popup .spell-element[style*="#7c2d12"] { color: #7c2d12 !important; }
.spell-preview-popup .spell-element[style*="#7c3aed"] { color: #7c3aed !important; }

.spell-links-modal .spell-meta[style*="#e25822"] { color: #e25822 !important; }
.spell-links-modal .spell-meta[style*="#2563eb"] { color: #2563eb !important; }
.spell-links-modal .spell-meta[style*="#92400e"] { color: #92400e !important; }
.spell-links-modal .spell-meta[style*="#059669"] { color: #059669 !important; }
.spell-links-modal .spell-meta[style*="#d97706"] { color: #d97706 !important; }
.spell-links-modal .spell-meta[style*="#6b21a8"] { color: #6b21a8 !important; }
.spell-links-modal .spell-meta[style*="#7c2d12"] { color: #7c2d12 !important; }
.spell-links-modal .spell-meta[style*="#7c3aed"] { color: #7c3aed !important; }

/* Page Links Modal */
.page-links-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  z-index: 2147483647;
  display: none;
  align-items: center;
  justify-content: center;
}

.page-links-modal.visible {
  display: flex;
}

.page-links-modal-content {
  background: var(--card);
  border: 2px solid var(--rule);
  border-radius: 16px;
  padding: var(--space-2xl);
  max-width: 600px;
  width: 90%;
  box-shadow: var(--shadow);
  position: relative;
  max-height: 80vh;
  overflow-y: auto;
}

.page-item {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  padding: 12px;
  margin-bottom: 8px;
  border: 1px solid var(--rule);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  background: var(--surface);
}

.page-item:hover {
  background: var(--accent-bg);
  border-color: var(--accent);
  transform: translateX(4px);
}

.page-item.copied {
  background: rgba(34, 197, 94, 0.1);
  border-color: #22c55e;
}

.page-info {
  flex: 1;
}

.page-name {
  font-weight: 600;
  color: var(--accent-ink);
  margin-bottom: 4px;
  font-size: 14px;
}

.page-section {
  font-size: 12px;
  color: var(--paper-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.copy-indicator {
  position: absolute;
  top: 50%;
  right: 12px;
  transform: translateY(-50%);
  background: #22c55e;
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.page-item.copied .copy-indicator {
  opacity: 1;
}

@media (max-width: 768px) {
  .page-links-modal-content {
    max-width: calc(100vw - 16px);
    padding: 16px;
  }
}

.spell-preview-close {
  position: absolute;
  top: 12px;
  right: 12px;
  background: none;
  border: none;
  font-size: 16px;
  cursor: pointer;
  color: var(--paper-muted);
  padding: 4px;
  border-radius: 4px;
  transition: all 0.2s ease;
}

.spell-preview-close:hover {
  background: var(--rule);
  color: var(--accent-ink);
}

.spell-preview-body {
  padding: 16px;
}

/* Ã‰tats preview popup */
.etat-preview-popup {
  position: fixed;
  z-index: 10001;
  background: var(--card);
  border: 2px solid #7c2d12;
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.3);
  max-width: 300px;
  padding: 1rem;
  font-size: 14px;
  line-height: 1.4;
  color: var(--paper-ink);
  pointer-events: auto;
}

.etat-preview-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--rule);
}

.etat-title {
  font-weight: 600;
  font-size: 16px;
  color: #7c2d12;
}

.etat-preview-close {
  background: none;
  border: none;
  font-size: 16px;
  cursor: pointer;
  color: var(--paper-muted);
  padding: 4px;
  border-radius: 4px;
  transition: all 0.2s ease;
}

.etat-preview-close:hover {
  background: var(--rule);
  color: var(--accent-ink);
}

.etat-preview-body {
  margin-top: 0.5rem;
}

.etat-description {
  white-space: pre-line;
}

.spell-field {
  margin-bottom: 12px;
  font-size: 14px;
  line-height: 1.5;
}

.spell-field:last-child {
  margin-bottom: 0;
}

.spell-description {
  margin-bottom: 16px;
  font-style: italic;
  color: var(--paper-muted);
  font-size: 14px;
}

/* Responsive pour mobile */
@media (max-width: 768px) {
  .spell-preview-popup {
    max-width: calc(100vw - 16px);
    max-height: calc(100vh - 32px);
    left: 8px !important;
    top: 16px !important;
  }
  
  .spell-links-modal-content {
    max-width: calc(100vw - 16px);
    padding: 16px;
  }
}

span[title]:hover {
  border-bottom-color: var(--gold);
  border-bottom-width: 3px;
  background: linear-gradient(135deg, rgba(212,175,55,0.2), rgba(205,127,50,0.1));
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* Tooltip personnalisÃ© pour une meilleure visibilitÃ© */
span[title]:hover::after {
  content: attr(title);
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: var(--accent-ink);
  color: white;
  padding: 10px 15px;
  border-radius: 8px;
  font-size: 13px;
  white-space: pre-line;
  z-index: 999999;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  pointer-events: none;
  min-width: 200px;
  max-width: 320px;
  text-align: center;
  line-height: 1.5;
  animation: tooltipFadeIn 0.3s ease;
  border: 2px solid var(--gold);
  word-wrap: break-word;
}

span[title]:hover::before {
  content: '';
  position: absolute;
  bottom: calc(100% + 2px);
  left: 50%;
  transform: translateX(-50%);
  border: 6px solid transparent;
  border-top-color: var(--accent-ink);
  z-index: 999999;
  pointer-events: none;
}

/* Forcer l'overflow visible pour les tooltips */
.card:has(span[title]:hover),
.editable:has(span[title]:hover),
article:has(span[title]:hover) {
  overflow: visible !important;
}

/* Fallback pour navigateurs sans :has() */
.card,
.editable,
article {
  position: relative;
}

.card span[title]:hover::after,
.editable span[title]:hover::after,
article span[title]:hover::after {
  z-index: 99999 !important;
}

@keyframes tooltipFadeIn {
  from { opacity: 0; transform: translateX(-50%) translateY(5px); }
  to { opacity: 1; transform: translateX(-50%) translateY(0); }
}

/* === UNIFIED EDIT BUTTONS FOR ALL SECTIONS === */
.editable-section {
  position: relative;
  margin: 8px 0;
}

.edit-btn {
  background: var(--bronze);
  color: white;
  border: none;
  border-radius: 6px;
  padding: 4px 8px;
  cursor: pointer;
  font-size: 12px;
  opacity: 0.7;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.edit-btn:hover {
  opacity: 1;
  transform: scale(1.05);
  background: var(--gold);
}

/* Inline edit buttons (titles, etc.) */
.edit-btn.edit-title-btn,
.edit-btn.edit-paragraph-btn {
  position: relative;
  margin-left: 8px;
}

/* Section edit buttons (absolute positioning) */
.editable-section .edit-btn.edit-section-btn,
[style*="position:relative"] .edit-btn.edit-section-btn {
  position: absolute;
  right: 8px;
  top: 8px;
  z-index: 10;
}

.editable-section:hover .edit-btn {
  opacity: 1;
  transform: scale(1.05);
  background: var(--gold);
}

.editable-section .edit-btn:hover {
  background: var(--gold) !important;
  transform: scale(1.1) !important;
  box-shadow: 0 3px 8px rgba(0,0,0,0.2);
}

.editable-section .edit-btn:active {
  transform: scale(0.95) !important;
}

/* Special positioning for different types */
.editable-list-container .edit-btn {
  right: 16px;
  top: 16px;
}

.editable-section[data-section-type="intro"] .edit-btn {
  right: 12px;
  top: 12px;
}

/* Title edit buttons */
.edit-title-btn {
  position: relative !important;
  right: auto !important;
  top: auto !important;
  margin-left: 12px;
  transform: none !important;
}

.edit-title-btn:hover {
  transform: scale(1.1) !important;
}

/* When editing, hide the button and expand content */
.editable-section[data-editing="true"] .edit-btn {
  display: none;
}

/* Visual feedback for editable sections */
.editable-section:hover {
  background: rgba(184, 134, 11, 0.05);
  border-radius: 8px;
  transition: background 0.2s ease;
}

.editable-section[data-editing="true"] {
  background: rgba(255, 255, 0, 0.1);
  border: 1px dashed var(--bronze);
  border-radius: 8px;
  padding: 8px;
}

/* Legacy support for old list items */
.editable-item {
  position: relative;
  padding-right: 40px;
}

.editable-content {
  display: block;
  margin-right: 35px;
}

/* === MJ-ONLY VISIBILITY CONTROLS === */
/* Show MJ-only elements when MJ state is active */
body.mj-on .mj-only {
  display: block !important;
}

/* Hide MJ-only elements by default and when MJ is off */
.mj-only,
body.mj-off .mj-only {
  display: none !important;
}

/* Show non-MJ elements by default and when MJ is off */
.non-mj-only,
body.mj-off .non-mj-only {
  display: block !important;
}

/* Hide non-MJ elements when MJ is on */
body.mj-on .non-mj-only {
  display: none !important;
}

/* For flex and inline-flex elements */
body.mj-on .mj-only[style*="display: flex"] {
  display: flex !important;
}

body.mj-on .mj-only[style*="display: inline-flex"] {
  display: inline-flex !important;
}

/* === DEV-ONLY VISIBILITY CONTROLS === */
/* Show dev-only elements when dev mode is active */
body.dev-on .dev-only {
  display: block !important;
}

/* Hide dev-only elements by default and when dev is off */
.dev-only,
body.dev-off .dev-only {
  display: none !important;
}

/* Show non-dev elements by default and when dev is off */
.non-dev-only,
body.dev-off .non-dev-only {
  display: block !important;
}

/* Hide non-dev elements when dev is on */
body.dev-on .non-dev-only {
  display: none !important;
}

/* For flex and inline-flex elements in dev mode */
body.dev-on .dev-only[style*="display: flex"] {
  display: flex !important;
}

body.dev-on .dev-only[style*="display: inline-flex"] {
  display: inline-flex !important;
}
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸš€ SCROLL PERFORMANCE OPTIMIZATIONS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Smooth scrolling behavior */
html {
  scroll-behavior: smooth;
}

/* Optimize scroll performance during scrolling */
.scrolling * {
  pointer-events: none !important;
}

.scrolling .card,
.scrolling .spell-card,
.scrolling .item-card {
  transition: none !important;
  animation: none !important;
}

/* Content visibility optimizations for modern browsers - ONLY for visible articles */
/* EXCLUDE collections and filtered content to avoid display conflicts */
article.active .card:not([style*="display: none"]),
article.active .spell-card:not([style*="display: none"]), 
article.active .item-card:not([style*="display: none"]) {
  content-visibility: auto;
  contain-intrinsic-size: 0 250px;
  /* Lighter containment for better compatibility */
  contain: layout style;
}

/* Ensure hidden elements stay hidden */
article.active .card[style*="display: none"],
article.active .spell-card[style*="display: none"],
article.active .item-card[style*="display: none"] {
  display: none !important;
  content-visibility: hidden;
}

/* GPU acceleration for visible cards - ONLY in active articles */
article.active .card.visible,
article.active .spell-card.visible,
article.active .item-card.visible {
  transform: translateZ(0);
  backface-visibility: hidden;
  perspective: 1000px;
}

/* Virtualized viewport styling */
.virtualized-viewport {
  will-change: scroll-position;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: thin;
  scrollbar-color: var(--bronze) transparent;
}

.virtualized-viewport::-webkit-scrollbar {
  width: 8px;
}

.virtualized-viewport::-webkit-scrollbar-track {
  background: rgba(212, 175, 55, 0.1);
  border-radius: 4px;
}

.virtualized-viewport::-webkit-scrollbar-thumb {
  background: var(--bronze);
  border-radius: 4px;
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.virtualized-viewport::-webkit-scrollbar-thumb:hover {
  background: var(--gold);
}

.virtualized-content {
  overflow: hidden;
}

/* Lazy loading image optimizations */
img[loading="lazy"] {
  filter: blur(0.5px);
  transition: filter 0.3s ease;
}

img.lazy-loaded {
  filter: none;
}

img.lazy-load {
  background: linear-gradient(135deg, 
    rgba(212, 175, 55, 0.1) 0%, 
    rgba(139, 69, 19, 0.05) 100%);
  min-height: 120px;
  border-radius: 8px;
}

/* Class page specific optimizations - ONLY in active articles */
article.active .editable-section[data-section-type="subclass"] {
  contain: layout style;
}

.editable-section[data-loading-state="deferred"] {
  background: rgba(212, 175, 55, 0.02);
  border: 1px dashed rgba(139, 69, 19, 0.1);
}

.editable-section[data-loading-state="loaded"] {
  border: 1px solid var(--rule);
}

/* Optimize subclass images specifically */
.editable-section[data-section-type="subclass"] img {
  object-fit: contain;
  max-width: 100%;
  height: auto;
  image-rendering: -webkit-optimize-contrast;
}

/* Spell cards specific optimizations - ONLY if not filtered */
article.active .spell-card:not([style*="display: none"]) {
  /* More aggressive containment for complex spell cards */
  contain: layout style paint;
}

.spell-card[data-loading-state="deferred-spell"] {
  background: rgba(255, 107, 53, 0.03); /* Subtle fire color */
  border: 1px dashed rgba(226, 88, 34, 0.2);
}

.spell-card[data-loading-state="loaded"] {
  border: 1px solid var(--rule);
}

/* Optimize spell card internal elements */
article.active .spell-card hr {
  contain: layout paint;
  will-change: auto;
}

article.active .spell-card [data-edit-type="generic"] {
  /* Optimize complex text content in spells */
  contain: layout style;
}

/* Spell element badges optimization */
article.active .spell-card .spell-element {
  transform: translateZ(0);
  contain: layout paint;
}

/* Reduce reflow on spell cards during scroll */
.scrolling .spell-card * {
  pointer-events: none !important;
  will-change: auto !important;
}

/* Spell cards get priority GPU layers when visible */
article.active .spell-card:nth-child(-n+7) {
  transform: translateZ(0);
  backface-visibility: hidden;
}

/* Optimize animation performance during scroll */
@media (prefers-reduced-motion: no-preference) {
  article.active .card:not(.scrolling *) {
    transition: transform 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }
  
  article.active .card:not(.scrolling *):hover {
    transform: translateY(-1px) scale(1.005);
  }
}

/* Force hardware acceleration for smooth scrolling */
article.active {
  transform: translateZ(0);
  will-change: scroll-position;
}

article.active #views,
article.active .grid {
  transform: translateZ(0);
  backface-visibility: hidden;
}

/* Critical: Override any optimization for filtered/hidden content */
.card[style*="display: none"],
.card[style*="display:none"],
.spell-card[style*="display: none"],
.spell-card[style*="display:none"],
.item-card[style*="display: none"],
.item-card[style*="display:none"],
#collection-results[style*="display: none"],
#available-collections[style*="display: none"] {
  display: none !important;
  content-visibility: hidden !important;
  contain: none !important;
  opacity: 0 !important;
  pointer-events: none !important;
  position: absolute !important;
  left: -9999px !important;
  visibility: hidden !important;
  width: 0 !important;
  height: 0 !important;
  margin: 0 !important;
  padding: 0 !important;
  transform: none !important;
}

/* Ensure ID search works properly */
#objets-container .card[style*="display: none"] {
  display: none !important;
}

/* Reduce motion for accessibility */
@media (prefers-reduced-motion: reduce) {
  html {
    scroll-behavior: auto;
  }
  
  .card,
  .spell-card,
  .item-card {
    transition: none !important;
    animation: none !important;
    transform: none !important;
  }
}

/* Mobile scroll optimizations */
@media (max-width: 768px) {
  .card,
  .spell-card,
  .item-card {
    contain-intrinsic-size: 0 200px;
  }
  
  .virtualized-viewport {
    height: 60vh !important;
  }
  
  /* Prevent scroll bounce on iOS */
  body {
    overscroll-behavior-y: contain;
    -webkit-overflow-scrolling: touch;
  }
}

/* High DPI display optimizations */
@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 2dppx) {
  .card,
  .spell-card,
  .item-card {
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
  }
}

/* Container query optimizations for modern browsers */
@supports (container-type: inline-size) {
  #views {
    container-type: inline-size;
  }
  
  @container (max-width: 600px) {
    .card,
    .spell-card,
    .item-card {
      contain-intrinsic-size: 0 180px;
    }
  }
}

/* Focus management during scroll */
.scrolling :focus {
  outline: none;
}

/* Intersection Observer loading states */
.card[data-loading="true"] {
  background: linear-gradient(135deg, 
    rgba(212, 175, 55, 0.05) 0%, 
    rgba(139, 69, 19, 0.02) 100%);
  opacity: 0.7;
}

.card[data-loading="false"] {
  opacity: 1;
  transition: opacity 0.3s ease;
}

/* Performance hints for browsers */
.card,
.spell-card,
.item-card {
  /* Hint that this element will change */
  will-change: auto;
}

.card:hover,
.spell-card:hover,
.item-card:hover {
  will-change: transform;
}

/* Print optimizations */
@media print {
  .virtualized-viewport {
    height: auto !important;
    overflow: visible !important;
  }
  
  .virtualized-content {
    position: static !important;
    height: auto !important;
  }
  
  .card,
  .spell-card,
  .item-card {
    content-visibility: visible;
    contain: none;
    transform: none !important;
    position: static !important;
  }
}
</style>
</head>
<body class="dev-off">

<div class="shell">
  <button aria-controls="sidebar" aria-expanded="false" aria-label="Ouvrir le sommaire" class="menu-toggle" id="menuToggle" style="display:none">â˜° Sommaire</button>
  <div class="backdrop" hidden="" id="backdrop"></div>
  
  <main class="page">
    <aside class="sidebar" id="sidebar">
      <div class="panel">
        <div class="tools">
          <!-- Dev mode disabled in standalone version -->
        </div>
        <div class="toc" id="toc">
          <!-- Table of contents will be generated by JavaScript -->
        </div>
      </div>
    </aside>
    
    <div id="views">
      <!-- Main content will be generated by JavaScript -->
      <div id="app-loading">Chargement...</div>
    </div>
  </main>
  
  <footer></footer>
</div>

<script>

    // Ensure window object exists
    window = window || {};
    
    // Global data from modular files
    window.SORTS = [
  {
    "nom": "Sorts de Mage",
    "description": "Sorts de destruction.",
    "sorts": [
      {
        "nom": "Boule de Feu",
        "element": "Feu",
        "description": "Lance une boule de feu sur un adversaire, qui peut s'enflammer.",
        "categorie": "Mage",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 15m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 4",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige 5 dÃ©gats de <span style=\"color: #e25822; font-weight: bold;\">Feu</span> Ã  la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Les dÃ©gats passent Ã  7 et la cible s'enflamme, infligeant 5 dÃ©gats de feu au prochain tour du lanceur."
      },
      {
        "nom": "Ã‰clair",
        "element": "Air",
        "description": "Le lanceur concentre une sphÃ¨re crÃ©pitante dâ€™Ã©nergie instable qui fuse vers sa cible et explose dans un Ã©clair.",
        "categorie": "Mage",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 12m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 4",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> Esquive.",
        "effetNormal": "<strong>Effet:</strong> Â Inflige 5 dÃ©gats d'<span style=\"color: #22c55e; font-weight: bold;\">Air</span> Ã  la cible.<br>Â Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:Â </strong> Les dÃ©gÃ¢ts passent Ã  7 et ils sont aussi infligÃ© Ã  un ennemi Ã  moins de 3m de la cible."
      },
      {
        "nom": "Vague dÃ©ferlante",
        "element": "Eau",
        "description": "Une puissante vague d'eau s'abat sur vos ennemis et les repousse.",
        "categorie": "Sorts de Mage",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 2",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 6m",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 8",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> Volant.",
        "effetNormal": "<strong>Effet:</strong> &nbsp;Inflige 7 dÃ©gats d'<span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span> aux crÃ©atures devant le lanceur (largeur 3m distance 6m) et les repousse jusqu'Ã  6m.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:Â </strong> les dÃ©gats passent Ã  12 et les enemis sont touchÃ©s/repoussÃ©s Ã  12m."
      },
      {
        "nom": "VolÃ©e de pierres",
        "element": "Terre",
        "description": "Invoque une volÃ©e de pierres qui tournoient autour du lanceur, puis qui sont Ã©jectÃ©es devant lui.",
        "categorie": "Sorts de Mage",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 2",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 6m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 8",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Inflige 7 dÃ©gats de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> aux crÃ©atures autour du lanceur (3m). <br>Puis inflige le mÃªme montant aux crÃ©atures devant le lanceur sur 6m.<br><br>Â Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Les dÃ©gats passent Ã  12. Les cibles non volantes et de taille moyennes sont <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span> pendant 1 tour."
      },
      {
        "nom": "Faisceau lumineux",
        "element": "LumiÃ¨re",
        "description": "Un faisceau lumineux canalisÃ© jaillit des mains du lanceur, transperÃ§ant les ennemis dâ€™une Ã©nergie pure.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 3",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 9m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 10",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Inflige 10 points de dÃ©gats de <span style=\"color: #ffd700; font-weight: bold;\">LumiÃ¨re</span>  aux crÃ©atures devant le lanceur (9m).\n<br><br>Le lanceur peut continuer de <b>canaliser</b> le sort (ne pouvant plus esquiver ou faire d'actions). S'il le fait, n'importe crÃ©ature qui rendre dans la zone subit les dÃ©gats, et toutes les creatures encore dans la zone au prochain tour du lanceur subiront les dÃ©gats. A chaque dÃ©but de tour, le lanceur consomme alors <b>la moitiÃ© du coÃ»t en mana</b> du sort.\n\n\n<br><br>Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:Â </strong>Â Les dÃ©gats passent Ã  15, et les crÃ©atures ayant une Resistance alÃ©ration infÃ©rieure Ã  l'Intelligence du lanceur sont <span class=\"etat-link\" data-etat=\"AveuglÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">AveuglÃ©</span> pendant 2 tours."
      },
      {
        "nom": "Vague sombre",
        "element": "Nuit",
        "description": "Une onde de tÃ©nÃ¨bres mouvantes se dÃ©ploie, repoussant violemment les adversaires alentours.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 4",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 9m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 15",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Â Inflige 13 dÃ©gats de <span style=\"color: #1a1a1a; font-weight: bold;\">Nuit</span> aux crÃ©atures dans un cone devant le lanceur (largeur 9m, distance 9m) et les repousse chacune de 3m.<br>Â Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:Â </strong>Â Les dÃ©gats passent Ã  20 et les cibles sont repoussÃ©es de 6m."
      },
      {
        "nom": "Missile magique",
        "element": "LumiÃ¨re",
        "description": "Un projectile dâ€™Ã©nergie condensÃ©e file Ã  longue portÃ©e, frappant la cible avec la force dâ€™un impact physique.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 5",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 30m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 10",
        "resistance": "<strong>Sans effet si:</strong> Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige 15 dÃ©gats physiques Ã  la cible. Ces dÃ©gats sont rÃ©duits par l'armure.\n<br>Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:Â </strong>Â Les dÃ©gats passent Ã  25 et la cible (si elle est de taille Moyenne ou moins) subit l'Ã©tat <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span>."
      },
      {
        "nom": "Nuage toxique",
        "element": "Terre",
        "description": "Une brume opaque se dÃ©ploie Ã  lâ€™endroit choisi, persistant plusieurs tours et infligeant son toxique insidieux.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 6",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 18m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 20",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> CrÃ©e Ã  la position d'une cible Ã  portÃ©e, un nuage toxique qui inflige 15 points de dÃ©gats de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span>.\n\n<br>Chaque dÃ©but de tour, le lanceur peut choisir de dÃ©penser une action principale et 5 points de mana pour que le nuage se dÃ©place inflige ses dÃ©gats Ã  une cible Ã  portÃ©e du lanceur. Sinon, le nuage disparait.\n\n<br><br>Â Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:Â </strong> Les dÃ©gats sont de 25 et la cible est <span class=\"etat-link\" data-etat=\"Ralenti\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Ralenti</span> pendant 1 tour."
      }
    ]
  },
  {
    "nom": "Sorts de PrÃªtre",
    "description": "Sorts de soutiens et anti mort-vivants.",
    "sorts": [
      {
        "nom": "ChÃ¢timent",
        "element": "Divin",
        "description": "Invoque un magie divine qui blesse les morts-vivants",
        "categorie": "Anti-mort-vivant",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 3",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 18m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 6",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> &nbsp;<br>- Non mort-vivant <br>- Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige *Intelligence* dÃ©gÃ¢ts <span style=\"color: #d0d0d0; font-weight: bold; background: rgba(0, 0, 0, 0.4); padding: 2px 4px; border-radius: 3px;\">Divin</span> Ã  la cible.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>Double dÃ©gÃ¢ts."
      },
      {
        "nom": "Refermer les blessures",
        "element": "Divin",
        "description": "Une magie divine soigne les blessures rÃ©centes du hÃ©ros ou d'un alliÃ© proche.",
        "categorie": "Sorts de PrÃªtre",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 3m",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 5",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> Â \n<br>- Hors combat.",
        "effetNormal": "<strong>Effet:</strong> Soigne la cible de 5 points de vie. Tous les 5 points d'intelligence, augmente le soin de 1.",
        "effetCritique": "<strong>Coup Critique:Â </strong>Le soin passe Ã  10."
      },
      {
        "nom": "Protection",
        "element": "LumiÃ¨re",
        "description": "ProtÃ¨ge le lanceur ou un alliÃ©.",
        "categorie": "Sorts de PrÃªtre",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 2",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 3m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 5",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Augmente l'armure de 2 pendant 5 tours.<br> Tous les 5 d'Intelligence, augmente l'armure de 1 supplÃ©mentaire.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> L'armure est augmentÃ©e de 4."
      },
      {
        "nom": "Arme de lumiÃ¨re",
        "element": "LumiÃ¨re",
        "description": "Une lumiÃ¨re destructrice s'imprÃ¨gne de l'arme du prÃªtre.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> -",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 5",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> L'arme du prÃªtre infligera 2 dÃ©gats de lumiÃ¨re Ã  chaque coup, pendant 4 tours.<br> Tous les 5 d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Les dÃ©gats passent Ã  4."
      },
      {
        "nom": "RÃ©vÃ©lation mineure",
        "element": "LumiÃ¨re",
        "description": "Un Ã©clat de lumiÃ¨re se pose sur la cible, dÃ©voilant son nom et son Ã©lÃ©ment dâ€™affiliation.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 2",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 18m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 5",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> RÃ©vÃ¨le le nom et l'Ã©lÃ©ment dâ€™affiliation d'une cible.",
        "effetCritique": "<strong>Coup Critique:Â </strong>Â RÃ©vÃ¨le Ã©galement son armure physique et Ã©lÃ©mentaire."
      },
      {
        "nom": "Resistance",
        "element": "Divin",
        "description": "Enveloppe le porteur dâ€™une aura protectrice qui le rend moins vulnÃ©rable aux altÃ©rations dâ€™Ã©tat.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 3",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 3m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 8",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong>  Augmente la RÃ©sistance altÃ©ration de 3 pendant 5 tours.<br> Tous les 5 d'Intelligence, l'augmente de 1 supplÃ©mentaire.",
        "effetCritique": "<strong>Coup Critique:Â </strong>Â  La RÃ©sistance altÃ©ration est augmentÃ©e de 5."
      },
      {
        "nom": "GuÃ©rison du poison",
        "element": "Terre",
        "description": "Dissipe le poison du corps de la cible, purifiant instantanÃ©ment son sang.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 4",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 3m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 10",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> EnlÃ¨ve l'Ã©tat <span class=\"etat-link\" data-etat=\"EmpoisonnÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">EmpoisonnÃ©</span> de la cible.",
        "effetCritique": "<strong>Coup Critique:Â </strong>Â La cible est Ã©galement soignÃ©e de 5 points de vie."
      },
      {
        "nom": "Nova lumineuse",
        "element": "LumiÃ¨re",
        "description": "CrÃ©e une zone de lumiÃ¨re brÃ»lante autour du lanceur.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 4",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 6m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 10",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Inflige 5 dÃ©gats de <span style=\"color: #ffd700; font-weight: bold;\">LumiÃ¨re</span> Ã  toutes les crÃ©atures Ã  moins de 6m du lanceur.<br>Â Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:Â </strong>Â Les dÃ©gats passent Ã  8, et les crÃ©atures ayant une Resistance alÃ©ration infÃ©rieure Ã  l'Intelligence du lanceur sont <span class=\"etat-link\" data-etat=\"AveuglÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">AveuglÃ©</span> pendant 2 tours."
      },
      {
        "nom": "Toucher Lointain",
        "element": "Divin",
        "description": "Projette une onde de guÃ©rison Ã  distance qui restaure superficiellement les blessures dâ€™un alliÃ©.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 5",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 12m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 10",
        "resistance": "<strong>Sans effet si:</strong> Â \n<br>- Hors combat.",
        "effetNormal": "<strong>Effet:</strong> Soigne la cible de 5 points de vie. Tous les 5 points d'intelligence, augmente le soin de 1.",
        "effetCritique": "<strong>Coup Critique:Â </strong>Le soin passe Ã  10."
      },
      {
        "nom": "RÃ©vÃ©lation majeure",
        "element": "LumiÃ¨re",
        "description": "Le halo lumineux perce le secret des dÃ©fenses de la cible.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 5",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 18m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 10",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong>  RÃ©vÃ¨le le nom et l'Ã©lÃ©ment dâ€™affiliation d'une cible, ainsi que son armure physique et Ã©lÃ©mentaire et ses points de vie.",
        "effetCritique": "<strong>Coup Critique:Â </strong>Â RÃ©vÃ¨le Ã©galement son Esquive, et sa resistance altÃ©ration."
      },
      {
        "nom": "RÃ©vÃ©lation ultime",
        "element": "LumiÃ¨re",
        "description": "Un faisceau Ã©clatant dÃ©voile toute lâ€™essence de lâ€™adversaire.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 10",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 18m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 20",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> RÃ©vÃ¨le le nom et l'Ã©lÃ©ment dâ€™affiliation d'une cible, ainsi que son armure physique et Ã©lÃ©mentaire, et ses points de vie. RÃ©vÃ¨le Ã©galement son Esquive, sa resistance altÃ©ration, ses chances de coup critiques physiques et magiques.",
        "effetCritique": "<strong>Coup Critique:Â </strong>Â RÃ©vÃ¨le une capacitÃ© de la cible."
      }
    ]
  },
  {
    "nom": "Sorts d'Enchanteur",
    "description": "Sorts d'amÃ©lioration et d'affaiblissement.",
    "sorts": [
      {
        "nom": "Accroche terrestre",
        "element": "Terre",
        "description": "Le sol se soulÃ¨ve et s'agrippe aux jambes de la cible, alourdissant ses pas d'une Ã©treinte de pierre vivante.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 30m",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 3",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> <br>- RÃ©sistance altÃ©rations >= Intelligence du lanceur<br>- LÃ©vitation ou Volant.",
        "effetNormal": "<strong>Effet:</strong>&nbsp;La cible contracte l'Ã©tat <span class=\"etat-link\" data-etat=\"Ralenti\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Ralenti</span> pendant 5 tours.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>La cible ne peut plus effectuer de dÃ©placement pendant la durÃ©e du sort."
      },
      {
        "nom": "AccÃ©lÃ©ration",
        "element": "Air",
        "description": "Une magie des vents accÃ©lÃ¨re un alliÃ© ou le lanceur.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 6m",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 4",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> Aucune",
        "effetNormal": "<strong>Effet:</strong> &nbsp;La vitesse de dÃ©placement de la cible est augmentÃ©e de 3m pendant 5 tours. Non Cumulable.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> La vitesse est augmentÃ©e de 6m."
      },
      {
        "nom": "Sommeil",
        "element": "Nuit",
        "description": "Un voile d'ombre caresse la cible, l'enveloppant dans un sommeil surnaturel.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 2",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 3m",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 8",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> <br>- RÃ©sistance altÃ©rations &gt;= Intelligence du lanceur<br>- Element <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span>",
        "effetNormal": "<strong>Effet:</strong> La cible passe dans l'Ã©tat <span class=\"etat-link\" data-etat=\"Endormi/assomÃ©/EffrayÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Endormi</span> pendant ses 2 prochains tours.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> L'effet dure 4 tours."
      },
      {
        "nom": "LÃ©vitation",
        "element": "Air",
        "description": "Une bourrasque ascendante enveloppe la cible, lui permettant de sâ€™Ã©lever lÃ©gÃ¨rement dans les airs et dâ€™Ã©chapper aux entraves du sol.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 2",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 3m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 6",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> La cible lÃ©vite pendant 5 tours. Elle ignore les dÃ©gÃ¢ts/ralentissements venant du sol, ainsi que l'Ã©tat <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span>.",
        "effetCritique": "<strong>Coup Critique:Â </strong>Â La cible a Ã©galement sa vitesse de dÃ©placement augmentÃ©e de 3m."
      },
      {
        "nom": "ImprÃ©gnation Ã©lÃ©mentaire feu terre nuit",
        "element": "Feu",
        "description": "ImprÃ¨gne une arme de la puissance d'un Ã©lÃ©ment.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 3",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 3m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 14",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Le lanceur choisi un Ã©lÃ©ment au choix entre <span style=\"color: #ff6b35; font-weight: bold;\">Feu</span>, <span style=\"color: #8b4513; font-weight: bold;\">Terre</span>, et <span style=\"color: #1a1a1a; font-weight: bold;\">Nuit</span>. \n<br>La cible voit son arme imprÃ©gnÃ©e de cet Ã©lement, qui infligera 4 points de degats de cet Ã©lÃ©ment Ã  chaque coup. <br>Dure 5 tours. Non cumulable.\n<br><br> Chaque 5 points d'Intelligence, les dÃ©gats Ã©lÃ©mentaires sont augmentÃ©s de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Le coup en mana est rÃ©duit de moitiÃ©."
      },
      {
        "nom": "ImprÃ©gnation Ã©lÃ©mentaire eau air lumiÃ¨re",
        "element": "Eau",
        "description": "ImprÃ¨gne une arme de la puissance d'un Ã©lÃ©ment.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 3",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 3m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 14",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Le lanceur choisi un Ã©lÃ©ment au choix entre <span style=\"color: #4682b4; font-weight: bold;\">Eau</span>, <span style=\"color: #22c55e; font-weight: bold;\">Air</span>, et <span style=\"color: #ffd700; font-weight: bold;\">LumiÃ¨re</span>.\n<br>La cible voit son arme imprÃ©gnÃ©e de cet Ã©lement, qui infligera 4 points de degats de cet Ã©lÃ©ment Ã  chaque coup. <br>Dure 5 tours. Non cumulable.\n<br><br> Chaque 5 points d'Intelligence, les dÃ©gats Ã©lÃ©mentaires sont augmentÃ©s de 1.",
        "effetCritique": "<strong>Coup Critique:Â </strong>Â Le coup en mana est rÃ©duit de moitiÃ©."
      },
      {
        "nom": "Silence",
        "element": "Nuit",
        "description": "Une aura muette se referme sur la cible, Ã©touffant toute incantation.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 4",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 12m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 10",
        "resistance": "<strong>Sans effet si:</strong> <br>- RÃ©sistance altÃ©rations &gt;= Intelligence du lanceur.",
        "effetNormal": "<strong>Effet:</strong> La cible est incapable de lancer des sorts pendant 3 tours.",
        "effetCritique": "<strong>Coup Critique:Â </strong>Â L'effet dure 5 tours."
      },
      {
        "nom": "Puissance magique",
        "element": "Feu",
        "description": "Le corps de la cible sâ€™illumine dâ€™arcanes, dÃ©cuplant la force de ses sorts.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 5",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 3m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 14",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "Inutilisable Hors combat.           \n<br> <strong>Effet:</strong> Augmente les dÃ©gats Ã©lÃ©mentaires effectuÃ©s par les sorts de la cible de 3. <br>Dure jusqu'au retour hors combat.<br><br>Â Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:Â </strong>Â Les dÃ©gats sont augmentÃ©s de 5."
      },
      {
        "nom": "Puissance physique",
        "element": "Terre",
        "description": "Une vigueur surnaturelle envahit les muscles, augmentant chaque coup portÃ©.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 6",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 3m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 14",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "Inutilisable Hors combat.           \n<br> <strong>Effet:</strong> Augmente la force de la cible de 5. <br>Dure jusqu'au retour hors combat.<br><br>Â Tous les 5 points d'intelligence, augmente la force prodiguÃ©e de 1.",
        "effetCritique": "<strong>Coup Critique:Â </strong>Â La force prodiguÃ©e passe Ã  8."
      },
      {
        "nom": "Confusion",
        "element": "MalÃ©fique",
        "description": "Un voile dâ€™illusions trouble lâ€™esprit de la cible, la rendant incapable de distinguer alliÃ©s et ennemis.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 7",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 12m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 15",
        "resistance": "<strong>Sans effet si:</strong> <br>- RÃ©sistance altÃ©rations >= Intelligence du lanceur<br>- Element <span style=\"color: #8b5cf6; font-weight: bold;\">MalÃ©fique</span>",
        "effetNormal": "<strong>Effet:</strong> La cible passe dans l'Ã©tat <span class=\"etat-link\" data-etat=\"Confus\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Confus</span>, pendant 4 tours.",
        "effetCritique": "<strong>Coup Critique:Â </strong>Â L'effet dure 6 tours."
      },
      {
        "nom": "Armure Ã©lÃ©mentaire Feu Terre Nuit",
        "element": "Feu",
        "description": "Un voile protecteur dâ€™Ã©nergie enveloppe la cible, renforÃ§ant son armure Ã©lÃ©mentaire.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 8",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 3m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 14",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Le lanceur choisi un Ã©lÃ©ment au choix entre <span style=\"color: #ff6b35; font-weight: bold;\">Feu</span>, <span style=\"color: #8b4513; font-weight: bold;\">Terre</span>, et <span style=\"color: #1a1a1a; font-weight: bold;\">Nuit</span>. \n<br>La cible voit son armure de cet Ã©lement, augmentant l'armure Ã©lÃ©mentaire de cet Ã©lÃ©ment de 5. <br>Dure 5 tours. Non cumulable.\n<br><br> Chaque 5 points d'Intelligence, les dÃ©gats Ã©lÃ©mentaires sont augmentÃ©s de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Le coup en mana est rÃ©duit de moitiÃ©."
      },
      {
        "nom": "Armure Ã©lÃ©mentaire Eau Air LumiÃ¨re",
        "element": "Eau",
        "description": "Un voile protecteur dâ€™Ã©nergie enveloppe la cible, renforÃ§ant son armure Ã©lÃ©mentaire.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 8",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 3m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 14",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Le lanceur choisi un Ã©lÃ©ment au choix entre <span style=\"color: #4682b4; font-weight: bold;\">Eau</span>, <span style=\"color: #22c55e; font-weight: bold;\">Air</span>, et <span style=\"color: #ffd700; font-weight: bold;\">LumiÃ¨re</span>.\n<br>La cible voit son armure de cet Ã©lement, augmentant l'armure Ã©lÃ©mentaire de cet Ã©lÃ©ment de 5. <br>Dure 5 tours. Non cumulable.\n<br><br> Chaque 5 points d'Intelligence, les dÃ©gats Ã©lÃ©mentaires sont augmentÃ©s de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Le coup en mana est rÃ©duit de moitiÃ©."
      }
    ]
  }
];
    window.CLASSES = [
  {
    "nom": "Guerrier",
    "resume": "HÃ©ros sans Ã©gal au combat au corp Ã  corp.",
    "capacites": "<ul><li><em>Expert de l'Ã©quipement</em> : Capable d'utiliser toutes les armes (Ã©pÃ©es, arcs, batons, dagues, exotiques, une main et deux mains), armures (robes, lÃ©gÃ¨res, lourdes), et boucliers.</li><li><em>Hardiesse</em> : Gagne la compÃ©tence Hardiesse rang 1.</li></ul>",
    "sousClasses": [
      {
        "nom": "Nain des montagnes",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>5</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>1</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>10</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>1</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>5</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>1</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +2 Force ğŸ’ª, +3 Endurance ğŸ›¡ï¸, +1 VolontÃ©âš¡   <strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Brise rocher : </em> Gagne 1 de compÃ©tence sur les tests de compÃ©tence Hardiesse pour une destruction d'objet.</li><li><em>VolontÃ© inflexible :</em> Les nains possÃ¨dent une volontÃ© inflexible qui les rendent rÃ©sistants aux sortilÃ¨ges (caractÃ©ristique VolontÃ© Ã©levÃ©e).</li></ul>",
        "description": "<i>Race robuste et inflexible, dotÃ©e dâ€™une endurance exceptionnelle. ForgÃ©s par la roche et les sommets, ils rÃ©sistent aux Ã©preuves et possÃ¨dent une force colossale capable de briser murs, armures et crÃ©atures cuirassÃ©es.</i>"
      },
      {
        "nom": "Berserker",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>5</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>4</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>8</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>1</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>1</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>1</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +3 Force ğŸ’ª, +1 AgilitÃ© ğŸƒ, +1 Endurance ğŸ›¡ï¸<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Tourbillon de rage :</em> Sur un critique au corps Ã  corps, touche aussi tous les adversaires Ã  moins de 3m.</li><li><em>Risque sauvage :</em> +1 chance de critique physique s'il ne porte pas de bouclier.</li></ul>",
        "description": "<i>Combattant sauvage, maÃ®tre des armes Ã  deux mains. Sa rage dÃ©cuple sa force, lui permettant dâ€™abattre ses ennemis dans un dÃ©chaÃ®nement de puissance brute et de coups imparables.</i>"
      },
      {
        "nom": "Aventurier",
        "description": "<i>HÃ©ros polyvalent et ingÃ©nieux, il affronte lâ€™inconnu avec courage, et manie tous les outils Ã  sa portÃ©e pour triompher.</i>",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>5</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>2</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>8</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>1</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>1</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>5</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +2 Force ğŸ’ª, +2 Endurance ğŸ›¡ï¸, +1 Chance ğŸ€, <strong> +2 Au choix</strong>",
        "capacites": "<ul><em>PassÃ© glorieux : </em>  Gagne la compÃ©tence Eloquence rang 1.<br><em>Sans failles :</em>  Dispose d'un Effort maximum supplÃ©mentaire .<br><em>Polyvalent : </em> Dispose d'un point de Don supplÃ©mentaire.</ul>"
      },
      {
        "nom": "MaÃ®tre dâ€™armes",
        "description": "<i>Guerrier Ã©rudit et redoutable, il manie avec aisance toutes les armes, des plus communes aux plus exotiques, transformant chaque outil de guerre en prolongement de son bras.</i>",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>5</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>2</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>8</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>1</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>3</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>1</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +3 Force ğŸ’ª, +2 Endurance ğŸ›¡ï¸<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Volte dâ€™armes :</em> Peut changer d'arme sans utiliser d'action secondaire.\n</li>\n               <li><em>Expert martial :</em> Lorsqu'il utilise une arme exotique, relance le dÃ© en cas d'echec critique.\n</li>\n   <li><em>Erudit des lames :</em> Gagne 1 de compÃ©tence sur les tests de compÃ©tence RÃ©flexion sur l'effet ou la provenance d'une arme.\n</li>\n\n</ul>"
      }
    ]
  },
  {
    "nom": "Mage",
    "resume": "SpÃ©cialiste de la magie destructrice.",
    "capacites": "<ul><li><em>Ã‰quipement de mage</em> : bÃ¢tons (une et deux mains), robes.</li><li><em>Sorts de mage</em> : Apprend et lance des sorts de mage.</li></ul>",
    "sousClasses": [
      {
        "nom": "Ã‰rudit",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>1</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>1</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>4</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>6</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>3</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>1</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +3 Intelligence ğŸ§ , +2 VolontÃ© âš¡<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Instruit</em> : Gagne la compÃ©tence RÃ©flexion rang 1.</li><li><em>Apprentissage accÃ©lÃ©rÃ©</em> : Le niveau de l'Ã©rudit est considÃ©rÃ© plus Ã©levÃ© d'un niveau pour les prÃ©requis d'apprentissage de sorts.</li>\n<li><em>Mana inÃ©puisable</em> : Chaque point de volontÃ© augmente le mana de 3 au lieu de 2.</li>\n<li><em>Magie interdite</em> : Capable d'utiliser ses lectures (s'il les comprends) pour apprendre de nouveaux sorts.</li></ul>",
        "description": "<i>Mage avide de savoir, dotÃ© dâ€™une mÃ©moire prodigieuse. Il assimile les arcanes avec une rapiditÃ© fulgurante et maÃ®trise de nouveaux sorts bien plus vite que ses pairs.</i>"
      },
      {
        "nom": "Elfe",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>2</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>2</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>6</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>3</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>2</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>1</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +1 Force ğŸ’ª, +1 AgilitÃ© ğŸƒ, +1 Endurance ğŸ›¡ï¸, +1 Intelligence ğŸ§ , +1 VolontÃ© âš¡<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Instinct elfique</em> : Gagne la compÃ©tence Coordination rang 1.</li><li><em>Ã‰quipement d'elfe</em> : EpÃ©es Ã  une main, armures lÃ©gÃ¨res.</li><li><em>Briseur de sceaux</em> : Gagne 1 de compÃ©tence sur les tests de compÃ©tence pour comprendre ou ouvrir une porte scellÃ©e magiquement</li></ul>",
        "description": "<i>Guerrier-mage polyvalent, aussi agile quâ€™Ã©lÃ©gant. MaÃ®tre des arcanes comme du combat rapprochÃ©, il allie puissance magique et adresse martiale avec une grÃ¢ce inÃ©galÃ©e.</i>"
      }
    ]
  },
  {
    "nom": "PrÃªtre",
    "resume": "SpÃ©cialiste de la magie de soutien et anti morts-vivants.",
    "capacites": "<ul><li><em>Ã‰quipement de prÃªtre</em> : bÃ¢tons (une et deux mains), robes.</li><li><em>Sorts de prÃªtre</em> : Apprend et lance des sorts de PrÃªtre.</li><li><em>Eloquence</em> : Gagne la compÃ©tence Eloquence rang 1.</li></ul>",
    "sousClasses": [
      {
        "nom": "Inquisiteur",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>3</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>1</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>7</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>3</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>5</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>1</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +1 Force ğŸ’ª, +1 Intelligence ğŸ§ , +2 VolontÃ© âš¡, +1 Endurance ğŸ›¡ï¸<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Equipement d'inquisiteur</em> : Peut s'Ã©quiper d'armures lÃ©gÃ¨res et de boucliers.</li><li><em>FlÃ©au des morts-vivants</em> : Les attaques physiques contre les morts-vivants ne ratent jamais.</li><li><em>LumiÃ¨re purificatrice</em> : Double l'effet de l'intelligence sur les dÃ©gats des sorts d'Ã©lÃ©ment <span style=\"color: #ffd700; font-weight: bold;\">LumiÃ¨re</span> ou <span style=\"color: #f5f5f5; font-weight: bold; background: rgba(100, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;\">Divin</span>.</li></ul>",
        "description": "<i>Champion de la foi, il renforce ses alliÃ©s par la magie sacrÃ©e et traque sans relÃ¢che les morts-vivants. Quand la lumiÃ¨re seule ne suffit plus, il nâ€™hÃ©site pas Ã  prendre les armes et combattre en premiÃ¨re ligne.</i>"
      },
      {
        "nom": "Clerc Divin",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>1</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>1</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>5</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>3</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>5</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>5</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +2 Intelligence ğŸ§ , +2 VolontÃ© âš¡, +1 Chance ğŸ€<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>MaÃ®tre des soins</em> : Double l'effet de l'intelligence sur les sorts de soins.</li><li><em> Pieu </em>:  Gagne 1 de compÃ©tence sur les tests de compÃ©tence Reflexion sur un dieu ou une religion.</li><li><em> Protection divine </em>:  Dispose d'une armure Ã©lementaire <span style=\"color: #f5f5f5; font-weight: bold; background: rgba(100, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;\">Divin</span> et <span style=\"color: #ffd700; font-weight: bold;\">LumiÃ¨re</span> de 10.</li></ul>",
        "description": "<i>Serviteur sacrÃ©, maÃ®tre des arts de guÃ©rison. Sa puissante magie de soins protÃ¨ge ses alliÃ©s et les relÃ¨ve mÃªme aux portes de la mort.</i>"
      }
    ]
  },
  {
    "nom": "RÃ´deur",
    "resume": "HÃ©ros trÃ¨s agile.",
    "capacites": "<ul><li><em>Ã‰quipement de rÃ´deur</em> : Dagues, robes, armures lÃ©gÃ¨res.</li><li><em>Coordination</em> : Gagne la compÃ©tence Coordination rang 1.</li></ul>",
    "sousClasses": [
      {
        "nom": "Voleur",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>3</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>5</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>5</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>2</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>2</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>5</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +2 AgilitÃ© ğŸƒ, +2 Force ğŸ’ª, +1 Endurance ğŸ›¡ï¸<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Mains expertes :</em> Gagne la compÃ©tence Finesse rang 1.</li><li><em>Sprint :</em> Peut utiliser une action secondaire pour doubler sa vitesse de dÃ©placement.</li><li><em>Vicieux :</em> Double les chances de critiques physiques au corps Ã  corps sur les cibles subissant un Ã©tat qui les empeche d'esquiver.</li></ul>",
        "description": "<i>MaÃ®tre de la finesse et de lâ€™agilitÃ©, il se dÃ©place avec rapiditÃ© fulgurante et frappe lÃ  oÃ¹ Ã§a fait le plus mal. </i>"
      },
      {
        "nom": "Chasseur",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>3</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>5</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>5</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>4</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>2</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>1</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +2 AgilitÃ© ğŸƒ, +1 Force ğŸ’ª, +1 Endurance ğŸ›¡ï¸, +1 Intelligence ğŸ§ <strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Armes du Chasseur</em> : Peut utiliser les arcs.</li><li><em>Cueillette</em> : Une fois par jour, lors dâ€™un repos, le personnage peut rÃ©colter 5 plantes locales (au choix du MJ). Leur efficacitÃ© dÃ©pend de lâ€™Intelligence de lâ€™utilisateur.</li><li><em>Connaissance du milieu naturel</em> : Gagne 1 de compÃ©tence sur les tests de RÃ©flexion liÃ© Ã  animal, un monstre, une plante, ou la dÃ©couverte de passages dÃ©robÃ©s en milieu naturel.</li></ul>",
        "description": "<i>PrÃ©cis et agile, il complÃ¨te son art de lâ€™arc par la science des herbes anciennes.</i>"
      }
    ]
  },
  {
    "nom": "Enchanteur",
    "resume": "DÃ©tenteur d'une magie singuliÃ¨re, qui fait de lui un alliÃ© prÃ©cieux.",
    "capacites": "<ul><li><em>Ã‰quipement d'enchanteur</em> : bÃ¢tons (une et deux mains), dagues, Robes.</li><li><em>Sorts d'enchanteur</em> : Apprend et lance des sorts d'Enchanteur.</li></ul>",
    "sousClasses": [
      {
        "nom": "Esprit de la grande FÃ©e",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>1</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>5</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>5</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>5</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>2</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>1</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +1 AgilitÃ© ğŸƒ, +1 Intelligence ğŸ§ , +1 Endurance ğŸ›¡ï¸, +1 VolontÃ© âš¡, +1 Chance ğŸ€<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Tatillon</em> : Gagne la compÃ©tence Finesse rang 1.</li><li><em>LÃ©vitation</em> : Ignore dÃ©gÃ¢ts/ralentissements venant du sol, ainsi que l'Ã©tat <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span>.</li><li><em>Rayon de l'AmitiÃ©</em> : Par une action secondaire, peut rÃ©pÃ©ter sur une autre cible Ã  portÃ©e un sort bÃ©nÃ©fique qui a ciblÃ© un alliÃ© se tour ci, sans coÃ»t en mana supplÃ©mentaire.</li></ul>",
        "description": "<i>ÃŠtre mystique qui flotte au-dessus du sol, il invoque des sorts imprÃ©visibles pour soutenir ses alliÃ©s.</i>"
      },
      {
        "nom": "Lutin",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>1</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>1</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>4</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>5</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>2</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>5</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +1 Intelligence ğŸ§ , +2 VolontÃ© âš¡, +2 Chance ğŸ€<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Secrets bien gardÃ©s</em> : Gagne la compÃ©tence Reflexion rang 1.</li><li><em>Expert des baguettes</em> : Sur un critique Ã  la baguette, la charge n'est pas consommÃ©e.</li><li><em>Rire malicieux</em> : Par une action secondaire, peut rÃ©pÃ©ter sur une autre cible Ã  portÃ©e un sort d'altÃ©ration qui a ciblÃ© un enemi ce tour ci, sans coÃ»t en mana supplÃ©mentaire.</li></ul>",
        "description": "<i>Esprit espiÃ¨gle et rusÃ©, passÃ© maÃ®tre dans lâ€™art des altÃ©rations magiques. </i>"
      }
    ]
  }
];
    window.DONS = [
  {
    "nom": "Generaux",
    "description": "Dons accessibles Ã  toutes les classes.",
    "dons": [
      {
        "nom": "DouÃ©",
        "description": "Gagne une compÃ©tence rang 1.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 points de don"
      },
      {
        "nom": "Toujours pret",
        "description": "Le maximum d'efforts maximum augmente de 1.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Brillant",
        "description": "Gagne une compÃ©tence rang 2.",
        "prerequis": "<strong> PrÃ©requis :</strong> La compÃ©tence rang 1.",
        "cout": "2 points de don"
      },
      {
        "nom": "Prodigieux",
        "description": "Gagne une compÃ©tence rang 3.",
        "prerequis": "<strong> PrÃ©requis :</strong> La compÃ©tence rang 2.",
        "cout": "3 point de don"
      },
      {
        "nom": "Hyperactif",
        "description": "Le hÃ©ros dispose maintenant de deux actions secondaires par tour.",
        "prerequis": "<strong> PrÃ©requis :</strong> Niveau 3",
        "cout": "2 points de don"
      },
      {
        "nom": "Equitation",
        "description": "Permet de monter Ã  cheval ou Ã©quivalent.",
        "prerequis": "<strong> PrÃ©requis :</strong> Niveau 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Gros mangeur",
        "description": "Les points de vie rendus en mangeant de la nourriture sont doublÃ©s. De plus, il est possible de consommer 4 rations de nourriture par jour au lieu de 2.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Grand sacs",
        "description": "Augmente le poid maximum transportable de 3, et le nombre de consommables transportables de 3.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Maitrise de la dague",
        "description": "Le hÃ©ros est capable d'Ã©quiper et d'utiliser des Dagues.",
        "prerequis": "<strong> PrÃ©requis :</strong> ğŸƒ AgilitÃ© 5.",
        "cout": "1 point de don"
      },
      {
        "nom": "Maitrise de l'arc",
        "description": "Le hÃ©ros est capable d'Ã©quiper et d'utiliser des Arcs.",
        "prerequis": "<strong> PrÃ©requis :</strong> ğŸƒ AgilitÃ© 10.",
        "cout": "1 point de don"
      },
      {
        "nom": "Sommeil lÃ©ger",
        "description": "Pendant qu'il dort, le hÃ©ros est aussi alerte que s'il effectuait un tour de garde.\nDe plus, le hÃ©ros ne necessite que 4 heures par nuit pour Ã©viter l'Ã©tat <span class=\"etat-link\" data-etat=\"FatiguÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">FatiguÃ©</span>.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Guerrier",
    "description": "Dons accessibles aux guerriers.",
    "dons": [
      {
        "nom": "Expertise du bouclier",
        "description": "Si le hÃ©ros a un bouclier Ã©quipÃ©, il peut utiliser une action secondaire pour doubler l'armure physique du bouclier jusqu'au prochain tour.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Charge",
        "description": "Une fois par combat, peut utiliser une action secondaire pour doubler sa vitesse de dÃ©placement et forcer un coup critique sur la prochaine attaque physique de ce tour (si elle rÃ©ussie).",
        "prerequis": "<strong> PrÃ©requis :</strong> ğŸƒAgilitÃ© 5",
        "cout": "1 point de don"
      },
      {
        "nom": "VolontÃ© de fer",
        "description": "Une fois par jour, le hÃ©ros peut utiliser une action secondaire pour se dÃ©barasser de toutes ses alterations magiques.",
        "prerequis": "<strong> PrÃ©requis :</strong> âš¡VolontÃ© 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Coup de bouclier",
        "description": "Si le hÃ©ros a un bouclier Ã©quipÃ©, lorsque le hÃ©ros subit des dÃ©gats aux corps Ã  corps, il peut choisir d'utiliser une action secondaire pour infliger Ã  l'attaquant des dÃ©gats Ã©quivalents Ã  l'armure du bouclier.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Coup de pommeau",
        "description": "Description du don.",
        "prerequis": "Aucun prÃ©requis",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "RÃ´deur",
    "description": "Dons accessibles aux rodeurs.",
    "dons": [
      {
        "nom": "Croche-patte",
        "description": "Peut utiliser une action principale pour effectuer un croche- patte :\n\n\n<br><br><b>Sans effet si :</b> \n<br>- Esquive.\n<br>- Volant ou lÃ©vitant.\n<br>- Taille supÃ©rieure Ã  Moyen.\n\n<br><br><b>Effet :</b> Inflige (Force) dÃ©gats Physiques Ã  la cible. Met la cible dans l'Ã©tat <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span>.\nâœï¸\n<br><br><b>Coup Critique :</b>  Les dÃ©gats sont doublÃ©s et la cible est <span class=\"etat-link\" data-etat=\"Endormi/assomÃ©/EffrayÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">AssomÃ©</span> 1 tour.\n\n<br><br><hr>",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Chasse et pÃªche",
        "description": "Le hÃ©ros n'as plus besoin de sa ration de nourriture quotidienne.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Attaque d'opportunitÃ©",
        "description": "Description du don.",
        "prerequis": "Aucun prÃ©requis",
        "cout": "1 point de don"
      },
      {
        "nom": "D",
        "description": "Description du don.",
        "prerequis": "Aucun prÃ©requis",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Mage",
    "description": "Description de cette catÃ©gorie de dons.",
    "dons": [
      {
        "nom": "Gemme de mana",
        "description": "Une fois par jour, le hÃ©ros peut rÃ©cupÃ©rer l'intÃ©gralitÃ© de son Mana en utilisant une action secondaire.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Resistance Ã©lÃ©mentaire 1",
        "description": "Le hÃ©ros gagne 5 d'armure Ã©lÃ©mentaire de <span style=\"color: #e25822; font-weight: bold;\">Feu</span>, <span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span>, <span style=\"color: #8b5e34; font-weight: bold;\">Terre</span>, <span style=\"color: #22c55e; font-weight: bold;\">Air</span>.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Resistance magique 1",
        "description": "Le hÃ©ros gagne 5 d'armure Ã©lÃ©mentaire de <span style=\"color: #ffd700; font-weight: bold;\">LumiÃ¨re</span>, <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span>, <span style=\"color: #d0d0d0; font-weight: bold; background: rgba(0, 0, 0, 0.4); padding: 2px 4px; border-radius: 3px;\">Divin</span>, <span style=\"color: #a855f7; font-weight: bold;\">MalÃ©fique</span>.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "SpÃ©cialisation Ã©lÃ©mentaire 1",
        "description": "Le hÃ©ros peut choisir un Ã©lÃ©ment et augmenter de 5 les dÃ©gats infligÃ©s avec les sorts de cet Ã©lÃ©ment.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Infusion Ã©lÃ©mentaire",
        "description": "AprÃ©s avoir lancÃ© un sort, le hÃ©ros peut, en utilisant une action secondaire, imprÃ©gner son arme de l'Ã©lÃ©ment du sort. Elle infligera Ã  sa prochaine attaque physique des dÃ©gats de cet Ã©lÃ©ment Ã©quivalents au niveau du sort.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Polyglotte",
        "description": "Peut lire et parler toutes les langues.",
        "prerequis": "<strong> PrÃ©requis :</strong> Reflexion rang 2.",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Pretre",
    "description": "Description de cette catÃ©gorie de dons.",
    "dons": [
      {
        "nom": "MÃ©crÃ©ants",
        "description": "Les dÃ©gats physiques infligÃ©s aux crÃ©atures de l'Ã©lÃ©ment <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span> ou <span style=\"color: #a855f7; font-weight: bold;\">MalÃ©fique</span> sont doublÃ©s.",
        "prerequis": "<strong> PrÃ©requis :</strong>-",
        "cout": "1 point de don"
      },
      {
        "nom": "Au milieu du combat",
        "description": "Permet d'utiliser s'Ã©quiper de dagues.",
        "prerequis": "<strong> PrÃ©requis :</strong>ğŸƒAgilitÃ© 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Jugement Ã©clair",
        "description": "Si le PrÃªtre a effectuÃ© un sort ce tour ci, il peut effectuer une attaque au corp Ã  corp avec une action secondaire.",
        "prerequis": "<strong> PrÃ©requis :</strong>ğŸ’ªForce 3",
        "cout": "1 point de don"
      },
      {
        "nom": "Musique",
        "description": "Permet d'apprendre un instrument de musique (ou de savoir chanter) au choix, gagnant 2 de compÃ©tences sur les tests de compÃ©tence Ã©loquence le nÃ©cÃ©ssitant.",
        "prerequis": "<strong> PrÃ©requis :</strong>-",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Enchanteur",
    "description": "Dons accessibles aux enchanteurs.",
    "dons": [
      {
        "nom": "RÃ©parateur de baguettes",
        "description": "Permet de regagner une charge de baguette, une fois par jour.",
        "prerequis": "<strong> PrÃ©requis :</strong>-",
        "cout": "1 point de don"
      },
      {
        "nom": "Magie alÃ©atoire destructrice",
        "description": "Permet de choisir et d'apprendre un sort de mage et de pouvoir le lancer Ã  volontÃ©. Le sort ne peut pas Ãªtre changÃ© par la suite.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Magie alÃ©atoire de soutien",
        "description": "Permet de choisir et d'apprendre un sort de prÃªtre et de pouvoir le lancer Ã  volontÃ©. Le sort ne peut pas Ãªtre changÃ© par la suite.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Alteration risquÃ©e",
        "description": "Lorsque un sort d'alteration magique est effectuÃ© alors que la cible est au corps Ã  corps, ses chances de critiques sont doublÃ©es.",
        "prerequis": "<strong> PrÃ©requis :</strong>-",
        "cout": "1 point de don"
      }
    ]
  }
];
    window.OBJETS = {
  "objets": [
    {
      "nom": "Espadon",
      "numero": 1,
      "image": "https://i.ibb.co/35rpP6ZS/Epee2M1.png",
      "description": "<i>Longue Ã©pÃ©e Ã  deux mains, lourde mais puissante.</i>",
      "tags": [
        "Arme",
        "Ã‰pÃ©e",
        "Deux mains"
      ],
      "effet": "<strong>DÃ©gÃ¢ts: </strong> Inflige (4  + Force) points de dÃ©gats physiques.",
      "prix": "ğŸ”· <strong>Prix:</strong> 35",
      "poids": "âš–ï¸ <strong>Poids:</strong> 2"
    },
    {
      "nom": "Simple Ã©pÃ©e",
      "numero": 2,
      "image": "https://i.ibb.co/PsSXvSXx/Epee1.png",
      "description": "<i>Arme droite et Ã©quilibrÃ©e, conÃ§ue pour Ãªtre maniÃ©e dâ€™une seule main</i>",
      "tags": [
        "Arme",
        "Ã‰pÃ©e",
        "Une main"
      ],
      "effet": "<span style=\"font-weight: 700; font-family: \" source=\"\" serif=\"\" pro\",=\"\" serif;=\"\" color:=\"\" rgb(74,=\"\" 44,=\"\" 23);=\"\" text-shadow:=\"\" rgba(0,=\"\" 0,=\"\" 0.05)=\"\" 0px=\"\" 1px=\"\" 2px;\"=\"\">DÃ©gÃ¢ts: </span> Inflige (2  + Force) points de dÃ©gats physiques.",
      "prix": "ğŸ”· <strong>Prix:</strong> 20",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Dague en fer",
      "numero": 3,
      "image": "https://i.ibb.co/1fCwy6cR/Dague1.png",
      "description": "<i>Petite lame simple, lÃ©gÃ¨re et maniable.</i>",
      "tags": [
        "Arme",
        "Une main",
        "Dague"
      ],
      "effet": "<strong>DÃ©gÃ¢ts: </strong> Inflige (1  + Force) points de dÃ©gats physiques.",
      "prix": "ğŸ”· <strong>Prix:</strong> 10",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "BÃ¢ton en bois",
      "numero": 4,
      "image": "https://i.ibb.co/PsyCNw86/Baton1.png",
      "description": "<i>Long bÃ¢ton solide, utilisÃ© comme arme et appui.</i>",
      "tags": [
        "Arme",
        "Deux mains",
        "Baton"
      ],
      "effet": "<strong>DÃ©gÃ¢ts: </strong> Inflige (2  + Force) points de dÃ©gats physiques.",
      "prix": "ğŸ”· <strong>Prix:</strong> 5",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Gourdin",
      "numero": 5,
      "image": "https://i.ibb.co/whZCKww0/Baton2.png",
      "description": "<i>Arme rudimentaire faite de bois dur. </i>",
      "tags": [
        "Arme",
        "Une main",
        "Baton"
      ],
      "effet": "<strong>DÃ©gÃ¢ts: </strong> Inflige (1  + Force) points de dÃ©gats physiques.",
      "prix": "ğŸ”· <strong>Prix:</strong> 10",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Arc simple",
      "numero": 6,
      "image": "https://i.ibb.co/cKb1JKZQ/Arc1.png",
      "description": "<i>Arc basique en bois, sans ornement.</i>",
      "tags": [
        "Arme",
        "Deux mains",
        "Arc"
      ],
      "effet": "<strong>PortÃ©e: </strong> 12m.<br>\n<strong>DÃ©gÃ¢ts: </strong> Inflige (Force) points de dÃ©gats physiques.",
      "prix": "ğŸ”· <strong>Prix:</strong> 30",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Bouclier en bois",
      "numero": 7,
      "image": "https://i.ibb.co/67bK4Bw8/Bouclier1.png",
      "description": "<i>Un bouclier grossier taillÃ© dans des planches Ã©paisses, marquÃ© de cicatrices de bataille.</i>",
      "tags": [
        "Bouclier"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 2.",
      "prix": "ğŸ”· <strong>Prix:</strong> 15",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Robe simple",
      "numero": 8,
      "image": "https://i.ibb.co/VYFpnz8h/Robe1.png",
      "description": "<i>Une robe de toile modeste, aux plis fatiguÃ©s mais encore emplis de dignitÃ©.</i>",
      "tags": [
        "Armure",
        "Robe"
      ],
      "effet": "<strong>Effet:</strong> Augmente la VolontÃ© de 1.",
      "prix": "ğŸ”· <strong>Prix:</strong> 20",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Armure de cuir",
      "numero": 9,
      "image": "https://i.ibb.co/9Hkw2VFb/Armure-Cuir1.png",
      "description": "<i>Une armure souple en cuir tannÃ©, taillÃ©e pour offrir une protection rudimentaire.</i>",
      "tags": [
        "Armure",
        "Armure lÃ©gÃ¨re"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 1.",
      "prix": "ğŸ”· <strong>Prix:</strong> 30",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Armure en maille",
      "numero": 10,
      "image": "https://i.ibb.co/cXtwzw5b/Armure-Lourde1.png",
      "description": "<i>Une cotte de mailles dont chaque anneau forgÃ© promet rÃ©sistance et endurance au combat.</i>",
      "tags": [
        "Armure",
        "Armure lourde"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 3.",
      "prix": "ğŸ”· <strong>Prix:</strong> 65",
      "poids": "âš–ï¸ <strong>Poids:</strong> 2"
    },
    {
      "nom": "Armure de plaque",
      "numero": 11,
      "image": "https://i.ibb.co/fVg5Fp6h/Armure-Lourde2.png",
      "description": "<i>Une imposante armure de mÃ©tal poli, dont les plaques luisantes forment une carapace presque impÃ©nÃ©trable.</i>",
      "tags": [
        "Armure",
        "Armure lourde"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 6.",
      "prix": "ğŸ”· <strong>Prix:</strong> 200",
      "poids": "âš–ï¸ <strong>Poids:</strong> 2"
    },
    {
      "nom": "Petite potion de vie",
      "numero": 12,
      "image": "https://i.ibb.co/Mw2Qb8Y/LifePot1.png",
      "description": "<i>Une fiole Ã©carlate dont le liquide vif rÃ©gÃ©nÃ¨re les blessures et ranime les forces vitales.</i>",
      "tags": [
        "Consommable"
      ],
      "effet": "<strong>Effet:</strong> Rend 15 (critique : 25) points de vie au hÃ©ros.",
      "prix": "ğŸ”· <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Petite potion de mana",
      "numero": 13,
      "image": "https://i.ibb.co/MkwzbQ3S/Potion-Mana1.png",
      "description": "<i>Une essence azur miroitante qui restaure lâ€™Ã©nergie magique et ravive le flux des arcanes.</i>",
      "tags": [
        "Consommable"
      ],
      "effet": "<strong>Effet:</strong> Rend 20 (critique : 35) points de mana au hÃ©ros.",
      "prix": "ğŸ”· <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Baguette de boule de feu",
      "numero": 14,
      "image": "https://i.ibb.co/JwXs3k2V/Baguette-Feu.png",
      "description": "<i>Une fine tige runique qui libÃ¨re des flammes brÃ»lantes au commandement de son porteur.</i>",
      "tags": [
        "Consommable",
        "Catalyseur"
      ],
      "effet": "<strong>Effet:</strong> Remplace votre prochaine action principale par le sort de mage <span class=\"spell-link\" data-spell=\"Boule de Feu\" data-category=\"Sorts de Mage\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Boule de Feu</span>. <br><i>Les prÃ©requis pour le sort ne sont pas requis mais le mana et les statistiques du hÃ©ros sont utilisÃ©s.</i>\n    <br><br><strong>Charges :</strong> 3",
      "prix": "ğŸ”· <strong>Prix:</strong> 25",
      "poids": ""
    },
    {
      "nom": "Feuilleclaire",
      "numero": 15,
      "image": "https://i.ibb.co/bMDstDVV/Herb1.png",
      "description": "<i>Herbe des forÃªts profondes, aux feuilles luisantes et aux petites fleurs rosÃ©es. AppliquÃ©e directement sur la peau, elle referme les plaies et apaise la douleur presque instantanÃ©ment.</i>",
      "tags": [
        "Consommable",
        "Plante"
      ],
      "effet": "<strong>Effet:</strong> Rend 10 (critique : 20) points de vie au hÃ©ros ou Ã  une cible proche.\n<br>Tous les 5 points d'intelligence, augmente les soins de 1.",
      "prix": "ğŸ”· <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Nocteline",
      "numero": 16,
      "image": "https://i.ibb.co/7JpQ7Kr7/Herb2.png",
      "description": "<i>une plante sombre aux fleurs violettes dont lâ€™essence neutralise les venins et purifie le sang.</i>",
      "tags": [
        "Consommable",
        "Plante"
      ],
      "effet": "<strong>PrÃ©requis:</strong> Intelligence 5.<br>\n<strong>Effet:</strong> Soigne le hÃ©ros ou une cible proche du poison. \n<br><b>Critique</b> : Rend Ã©galement 5 points de vie.",
      "prix": "ğŸ”· <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Baguette de d'accÃ©lÃ©ration",
      "numero": 17,
      "image": "https://i.ibb.co/zT29mKBd/Baguette-Lumiere.png",
      "description": "<i>Une fine tige de cristal rayonnant, dont lâ€™Ã©clat sacrÃ© nimbe son porteur dâ€™une aura Ã©clatante, lui confÃ©rant une vitesse surnaturelle et des rÃ©flexes fulgurants.</i>",
      "tags": [
        "Consommable",
        "Catalyseur"
      ],
      "effet": "<strong>Effet:</strong> Remplace votre prochaine action principale par le sort d'enchanteur <span class=\"spell-link\" data-spell=\"AccÃ©lÃ©ration\" data-category=\"Sorts d'Enchanteur\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">AccÃ©lÃ©ration</span>. <br><i>Les prÃ©requis pour le sort ne sont pas requis mais le mana et les statistiques du hÃ©ros sont utilisÃ©s.</i>\n    <br><br><strong>Charges :</strong> 3",
      "prix": "ğŸ”· <strong>Prix:</strong> 30",
      "poids": ""
    },
    {
      "nom": "Baguette de sommeil",
      "numero": 18,
      "image": "https://i.ibb.co/bMXNS4gy/Baguette-Nuit.png",
      "description": "<i>Une tige sombre incrustÃ©e de gemmes lunaires, qui libÃ¨re une aura tÃ©nÃ©breuse plongeant ses cibles dans un profond sommeil enchantÃ©.</i>",
      "tags": [
        "Consommable",
        "Catalyseur"
      ],
      "effet": "<strong>Effet:</strong> Remplace votre prochaine action principale par le sort d'enchanteur <span class=\"spell-link\" data-spell=\"Sommeil\" data-category=\"Sorts d'Enchanteur\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Sommeil</span>. <br><i>Les prÃ©requis pour le sort ne sont pas requis mais le mana et les statistiques du hÃ©ros sont utilisÃ©s.</i>\n    <br><br><strong>Charges :</strong> 3",
      "prix": "ğŸ”· <strong>Prix:</strong> 30",
      "poids": ""
    },
    {
      "nom": "Ration de nourriture",
      "numero": 19,
      "image": "https://i.ibb.co/tT6gW6p0/Food1.png",
      "description": "<i>Un paquet frugal de pain sec et de viande salÃ©e.</i>",
      "tags": [
        "Nourriture"
      ],
      "effet": "Inutilisable en combat.\n<br><strong>Effet:</strong> Restore 5 points de vie. <br>CouplÃ© Ã  un sommeil de 8h, permet d'Ã©viter l'etat <span class=\"etat-link\" data-etat=\"FatiguÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">FatiguÃ©</span>.",
      "prix": "ğŸ”· <strong>Prix:</strong> 5",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Ration copieuse de nourriture",
      "numero": 20,
      "image": "https://i.ibb.co/7JZW2ZZT/Food2.png",
      "description": "<i>Un coffret garni de mets fins et de vin Ã©picÃ©, offrant rÃ©confort et vigueur bien au-delÃ  de la simple survie</i>",
      "tags": [
        "Nourriture"
      ],
      "effet": "Inutilisable en combat.\n<br><strong>Effet:</strong> Restore 8 points de vie. <br>CouplÃ© Ã  un sommeil de 8h, permet d'Ã©viter l'etat <span class=\"etat-link\" data-etat=\"FatiguÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">FatiguÃ©</span>.\n<br><b>Charges :</b> 3",
      "prix": "ğŸ”· <strong>Prix:</strong> 15",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Fruits de la forÃªt",
      "numero": 21,
      "image": "https://i.ibb.co/svC0cDH6/food3.png",
      "description": "<i>Des baies juteuses et sucrÃ©es, cueillies Ã  lâ€™ombre des grands arbres, qui redonnent fraÃ®cheur et Ã©nergie.</i>",
      "tags": [
        "Nourriture"
      ],
      "effet": "Inutilisable en combat.\n<br><strong>Effet:</strong> Restore 5 points de vie. <br>CouplÃ© Ã  un sommeil, permet d'Ã©viter l'etat <span class=\"etat-link\" data-etat=\"FatiguÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">FatiguÃ©</span>. <br>De plus, lorsque consommÃ©, le mangeur ne neccessite plus que 4 heures de sommeil ce jour-ci.\n<br><br><b>Charges :</b> 3",
      "prix": "ğŸ”· <strong>Prix:</strong> 20",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Ration de survie",
      "numero": 22,
      "image": "https://i.ibb.co/Py57FHy/Food0.png",
      "description": "<i>Un maigre assemblage de galettes sÃ¨ches, de viande fumÃ©e et dâ€™eau amÃ¨re, conÃ§u pour soutenir la flamme vitale dans les heures les plus sombres.</i>",
      "tags": [
        "Nourriture"
      ],
      "effet": "Inutilisable en combat. Maximum deux nourritures consommÃ©es par jour.\n<br>\n<br><strong>Effet:</strong> CouplÃ© Ã  un sommeil de 8h, permet d'Ã©viter l'etat <span class=\"etat-link\" data-etat=\"FatiguÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">FatiguÃ©</span>.",
      "prix": "",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "FlÃ¨che aiguisÃ©e",
      "numero": 23,
      "image": "https://i.ibb.co/4Z7qKXCx/Fleche-Aiguis-e.png",
      "description": "<i>Un trait finement taillÃ©, dont la pointe acÃ©rÃ©e perce lâ€™armure avec une prÃ©cision mortelle.</i>",
      "tags": [
        "Consommable",
        "FlÃ¨che"
      ],
      "effet": "<b>Effet :</b> Renforce la prochaine attaque Ã  l'arc et lui rajoute +3 (critique : +5) points de dÃ©gats physiques en cas de rÃ©ussite de l'attaque.\n\n<br><br><b>Charges :</b> 3",
      "prix": "ğŸ”· <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "FlÃ¨che de la terre",
      "numero": 24,
      "image": "https://i.ibb.co/ZpScRTwS/Fleche-Terre.png",
      "description": "<i>Une flÃ¨che alourdie de pierres runiques, qui libÃ¨re la force brutale de lâ€™Ã©lÃ©ment Terre Ã  lâ€™impact.</i>",
      "tags": [
        "Consommable",
        "FlÃ¨che"
      ],
      "effet": "<b>Effet :</b> Renforce la prochaine attaque Ã  l'arc et lui rajoute +5 (critique : +10) points de dÃ©gats Ã©lÃ©mentaire de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> en cas de rÃ©ussite de l'attaque.\n\n<br><br><b>Charges :</b> 3",
      "prix": "ğŸ”· <strong>Prix:</strong> 20",
      "poids": ""
    },
    {
      "nom": "Bandage d'urgence",
      "numero": 25,
      "image": "https://i.ibb.co/4ZPsSM3p/Bandages.png",
      "description": "<i>Liens grossiers appliquÃ©s Ã  la hÃ¢te en plein combat, permettant de maintenir un hÃ©ros en vie quelques instants de plus</i>",
      "tags": [
        "Consommable"
      ],
      "effet": "Inutilisable hors combat.      \n<br><strong>PortÃ©e :</strong>   3m.\n<br><strong>Effet:</strong> Rend 5 (critique : 10) points de vie Ã  la cible.\n<br><strong>Charges:</strong> 3.",
      "prix": "ğŸ”· <strong>Prix:</strong> 10",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Bracelet mÃ©dicinal de la forÃªt",
      "numero": 26,
      "image": "https://i.ibb.co/k2h292gV/Bracelet-Foret.png",
      "description": "<i>TressÃ© de plantes mÃ©dicinales, il purifie le sang de son porteur et dissipe les poisons.</i>",
      "tags": [
        "Accessoire"
      ],
      "effet": "<strong>Effet:</strong> Soigne son porteur du poison. Utilisable une fois par jour maximum.",
      "prix": "ğŸ”· <strong>Prix:</strong> ?",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Dent de Grouink",
      "numero": 27,
      "image": "https://i.ibb.co/whc5dwnw/Dent-Grouik.png",
      "description": "<i>PortÃ©e en collier, cette Ã©norme canine de bÃªte sauvage insuffle Ã  son porteur une force brute et indomptÃ©e.</i>",
      "tags": [
        "Accessoire"
      ],
      "effet": "<strong>Effet:</strong> Augmente la Force du porteur de 3.",
      "prix": "ğŸ”· <strong>Prix:</strong> ?",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Echarpe de chaman Groink",
      "numero": 28,
      "image": "https://i.ibb.co/W4tfpFcH/Echarpe-Chaman.png",
      "description": "<i>TissÃ©e de symboles anciens et imprÃ©gnÃ©e de sagesse mystique.</i>",
      "tags": [
        "Accessoire"
      ],
      "effet": "<strong>Effet:</strong> Augmente de 3m la portÃ©e des sorts d'alterations magiques et d'amÃ©liorations temporaires.",
      "prix": "ğŸ”· <strong>Prix:</strong> ?",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Fourrure d'ours",
      "numero": 29,
      "image": "https://i.ibb.co/9HhVCqvk/Fourrure-Ours.png",
      "description": "<i>Ã‰paisse et robuste, cette peau intacte pourrait aisÃ©ment Ãªtre taillÃ©e en une armure protectrice.</i>",
      "tags": [
        "Composant"
      ],
      "effet": "",
      "prix": "ğŸ”· <strong>Prix:</strong> 100",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Pierre Ã  aiguiser",
      "numero": 30,
      "image": "https://i.ibb.co/SX10mS2q/Buff01.png",
      "description": "<i>Outil simple mais efficace, elle redonne du tranchant aux lames et prÃ©pare les armes pour le combat.</i>",
      "tags": [
        "Consommable"
      ],
      "effet": "<strong>Effet:</strong> Augmente les dÃ©gats de la prochaine attaque physique de 3.\n  <br><strong>Charges:</strong> 3.",
      "prix": "ğŸ”· <strong>Prix:</strong> 20",
      "poids": ""
    },
    {
      "nom": "Cristal d'effort",
      "numero": 31,
      "image": "https://i.ibb.co/k2MHGqhx/Cristal-Effort.png",
      "description": "<i>Fragment lumineux empli dâ€™Ã©nergie, il ravive la volontÃ© du porteur et lui rend la force dâ€™accomplir un nouvel effort. </i>",
      "tags": [
        "Consommable"
      ],
      "effet": "<strong>Effet:</strong> Recharge un effort utilisable par le hÃ©ros.<br><strong>Charges:</strong> 3.",
      "prix": "ğŸ”· <strong>Prix:</strong> 50",
      "poids": ""
    },
    {
      "nom": "Pince de crabe gÃ©ant des forÃªts",
      "numero": 32,
      "image": "https://i.ibb.co/VWKF2ysm/Masse-Foret1.png",
      "description": "<i>Massive et bleutÃ©e, vestige dâ€™une crÃ©ature des forÃªts profondes, elle tÃ©moigne dâ€™une puissance brute capable de broyer la pierre.</i>",
      "tags": [
        "Arme",
        "Une main",
        "Baton"
      ],
      "effet": "<strong>DÃ©gÃ¢ts: </strong> Inflige (3  + Force) points de dÃ©gats physiques.\n<br> L'arme est imprÃ©gnÃ©e de 5 points de dÃ©gats d'Ã©lÃ©ment <span style=\"color: #4682b4; font-weight: bold;\">Eau</span>.",
      "prix": "ğŸ”· <strong>Prix:</strong> ?",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Clairgivre",
      "numero": 33,
      "image": "https://i.ibb.co/s9CJtsPr/Herb5.png",
      "description": "<i>Une herbe bleu clair, semblant givrÃ©e en permanence, mÃªme au soleil.</i>",
      "tags": [
        "Consommable",
        "Plante",
        "Non identifiÃ©"
      ],
      "effet": "<strong>PrÃ©requis:</strong> Intelligence 10.     \n<br><strong>Effet:</strong> Le hÃ©ros ou la cible proche dispose de deux actions principales au lieu d'une (non cumulable). \n<br><strong>DurÃ©e:</strong> 2 tours (Critique : 3).",
      "prix": "ğŸ”· <strong>Prix:</strong> 65",
      "poids": ""
    },
    {
      "nom": "AurÃ©line des Roches",
      "numero": 34,
      "image": "https://i.ibb.co/My3mcc60/Herb3.png",
      "description": "<i>une fleur jaune Ã©clatante aux pÃ©tales veinÃ©s de brun, poussant sur les falaises et prÃ¨s des riviÃ¨res.</i>",
      "tags": [
        "Consommable",
        "Plante",
        "Non identifiÃ©"
      ],
      "effet": "<strong>Effet:</strong> Augmente la protection Ã©lÃ©mentaire de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> et d'<span style=\"color: #4682b4; font-weight: bold;\">Eau</span>  du hÃ©ros ou d'une cible proche du niveau d'Intelligence du hÃ©ros. <br><b>Critique :</b> le bonus d'armure est amÃ©liorÃ© de 5.\n<br><strong>DurÃ©e:</strong> 5 tours.",
      "prix": "ğŸ”· <strong>Prix:</strong> 25",
      "poids": ""
    },
    {
      "nom": "NÃ©brelle dâ€™Azur",
      "numero": 35,
      "image": "https://i.ibb.co/bMn4mMyK/Herb4.png",
      "description": "<i>Une herbe fine, aux brins violets et bleus luminescents, qui pousse dans les clairiÃ¨res baignÃ©es de lune.</i>",
      "tags": [
        "Consommable",
        "Plante",
        "Non identifiÃ©"
      ],
      "effet": "<b>Effet:</b> Rend au hÃ©ros Ã  une cible proche une quantitÃ©e de mana Ã©quilavent au niveau d'Intelligence du hÃ©ros.\n<br><b>Ciritique :</b> Mana rendu augmentÃ© de 5.",
      "prix": "ğŸ”· <strong>Prix:</strong> 25",
      "poids": ""
    },
    {
      "nom": "Aile de scarabÃ©e gÃ©ant",
      "numero": 36,
      "image": "https://i.ibb.co/RGZM6Tfx/Cape-Scarab.png",
      "description": "<i>Cape faite dâ€™une aile translucide arrachÃ©e Ã  un scarabÃ©e gÃ©ant. Elle bruisse Ã  chaque mouvement.</i>",
      "tags": [
        "Accessoire"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'initiative de 4 et l'armure Ã©lÃ©mentaire d'<span style=\"color: #22c55e; font-weight: bold;\">Air</span> de 5.",
      "prix": "ğŸ”· <strong>Prix:</strong> ?",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Bottes en cuir de guÃªpe gÃ©ante",
      "numero": 37,
      "image": "https://i.ibb.co/k2V6Df2z/Botte-Guepe.png",
      "description": "<i>Bottes souples taillÃ©es dans le cuir chitineux dâ€™une guÃªpe gÃ©ante. Leur lÃ©gÃ¨retÃ© accroÃ®t la rapiditÃ©.</i>",
      "tags": [
        "Accessoire"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'Esquive de 1.",
      "prix": "ğŸ”· <strong>Prix:</strong> ?",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Gants patte d'ours",
      "numero": 38,
      "image": "https://i.ibb.co/KzrZRGcd/Gants-Patte-Ours.png",
      "description": "<i>De vÃ©ritables pattes dâ€™ours, Ã©vidÃ©es et enfilÃ©es comme des gants. Bruts et redoutables, elles permettent dâ€™abattre des coups capables de faire chuter un adversaire.</i>",
      "tags": [
        "Accessoire"
      ],
      "effet": "<strong>Effet:</strong> En cas de coup critique physique sur une attaque au corp Ã  corp, l'adversaire sera mis dans l'Ã©tat <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span>.\n<br><strong>Sans effet si :</strong> <br>- Adversaire de taille Grand ou supÃ©rieur <br>- Adversaire volant ou lÃ©vitant.",
      "prix": "ğŸ”· <strong>Prix:</strong> ?",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Bouclier de la forÃªt",
      "numero": 39,
      "image": "https://i.ibb.co/Zpkw8qVL/Bouclier-Foret.png",
      "description": "<i>Bouclier rond taillÃ© dans un bois ancien et ornÃ© dâ€™un arbre majestueux dont les racines et les branches sâ€™entrelacent en relief.</i>",
      "tags": [
        "Bouclier"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 4. Augmente l'armure Ã©lÃ©mentaire de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> de 5.",
      "prix": "ğŸ”· <strong>Prix:</strong> ?",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Couronne d'Ã©pines",
      "numero": 40,
      "image": "https://i.ibb.co/d09YYyy8/Couronne-Epines.png",
      "description": "<i>DiadÃ¨me tressÃ© de ronces encore vivantes, dont les pointes sâ€™enfoncent lÃ©gÃ¨rement dans la peau. La douleur quâ€™elle inflige endurcit le porteur.</i>",
      "tags": [
        "Accessoire"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'endurance de 3.",
      "prix": "ğŸ”· <strong>Prix:</strong> ?",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Collier terrestre",
      "numero": 41,
      "image": "https://i.ibb.co/ksxCppN8/Collier-Terrestre.png",
      "description": "<i>Un pendentif massif ornÃ© dâ€™une gemme verte veinÃ©e, sertie dans un motif dorÃ© Ã©voquant les racines et la roche. Il pulse dâ€™une force tellurique.</i>",
      "tags": [
        "Non identifiÃ©",
        "Accessoire"
      ],
      "effet": "<strong>Effet:</strong> Les attaques physiques sont imprÃ©gnÃ©s d'une force Ã©lÃ©mentaire, qui inflige 4 dÃ©gats de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span>.",
      "prix": "ğŸ”· <strong>Prix:</strong> ?",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Dard de guÃªpe gÃ©ante",
      "numero": 42,
      "image": "https://i.ibb.co/mjcDdck/Dague2.png",
      "description": "<i>Un dard chitineux acÃ©rÃ©, arrachÃ© Ã  une guÃªpe gÃ©ante, utilisÃ© comme une dague imprÃ©gnÃ©e de venin.</i>",
      "tags": [
        "Arme",
        "Une main",
        "Dague"
      ],
      "effet": "<strong>DÃ©gÃ¢ts: </strong> Inflige (4  + Force) points de dÃ©gats physiques.\n<br> Si la cible a une rÃ©sistance alteration infÃ©rieure Ã  5, elle subit l'Ã©tat <span class=\"etat-link\" data-etat=\"EmpoisonnÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">EmpoisonnÃ©</span> 2, pendant 5 tours.",
      "prix": "ğŸ”· <strong>Prix:</strong> ?",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Arc de chasseur",
      "numero": 43,
      "image": "https://i.ibb.co/bRXH0Vwj/Arc2.png",
      "description": "<i>Un arc de chasseur finement faÃ§onnÃ©, dont la courbure Ã©lÃ©gante et la corde tendue promettent des tirs prÃ©cis et implacables.</i>",
      "tags": [
        "Arme",
        "Deux mains",
        "Arc"
      ],
      "effet": "<strong>PortÃ©e: </strong> 15m.<br>\n<strong>DÃ©gÃ¢ts: </strong> Inflige (Force) points de dÃ©gats physiques.\n<br> En cas de coup critique, si une charge de consomable flÃ¨che avait Ã©tÃ© utilisÃ©e, elle est rÃ©cupÃ©rÃ©e.",
      "prix": "ğŸ”· <strong>Prix:</strong> 100",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Grande hache de bÃ»cheron",
      "numero": 44,
      "image": "https://i.ibb.co/gMbq4QZD/Hache-Bucheron.png",
      "description": "<i>Une lourde hache Ã  long manche de bois renforcÃ©, dont la large lame dâ€™acier est faite pour fendre les troncs les plus Ã©pais.</i>",
      "tags": [
        "Arme",
        "Arme exotique",
        "Deux mains"
      ],
      "effet": "<strong>DÃ©gÃ¢ts: </strong> Inflige (7  + Force) points de dÃ©gats physiques.",
      "prix": "ğŸ”· <strong>Prix:</strong> 100",
      "poids": "âš–ï¸ <strong>Poids:</strong> 2"
    },
    {
      "nom": "Tunique d'explorateur",
      "numero": 45,
      "image": "https://i.ibb.co/Kj070KVw/Robe2.png",
      "description": "<i>LÃ©gÃ¨re et pratique, elle est garnie de poches et de laniÃ¨res pour affronter de longues marches et rÃ©sister aux intempÃ©ries.</i>",
      "tags": [
        "Armure",
        "Robe"
      ],
      "effet": "<strong>Effet:</strong> Augmente la Chance de 3.\n<br> Permet de stocker 2 consommables supplÃ©mentaires dans le sac.",
      "prix": "ğŸ”· <strong>Prix:</strong> 130",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Robe de la forÃªt",
      "numero": 46,
      "image": "https://i.ibb.co/Kj070KVw/Robe2.png",
      "description": "<i>TissÃ©e de fibres vertes et ornÃ©e de feuillage vivant, elle se fond dans la vÃ©gÃ©tation et amÃ©liore son porteur par la magie sylvestre.</i>",
      "tags": [
        "Armure",
        "Robe",
        "Non identifiÃ©"
      ],
      "effet": "<strong>Effet:</strong> Augmente les dÃ©gats Ã©lÃ©mentaires de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> et d'<span style=\"color: #4682b4; font-weight: bold;\">Eau</span> infligÃ©s par les sorts de 5.",
      "prix": "ğŸ”· <strong>Prix:</strong> ?",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Armure en cuir d'ours",
      "numero": 47,
      "image": "https://i.ibb.co/C3bVcQkV/Armure-Ours.png",
      "description": "<i>Massive et chaude, faite dâ€™une Ã©paisse fourrure brune et de cuir tannÃ©, elle confÃ¨re force et rÃ©sistance sauvage.</i>",
      "tags": [
        "Armure",
        "Armure lÃ©gÃ¨re"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 3.\n<br>Augmente l'armure Ã©lÃ©mentaire <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> et <span style=\"color: #22c55e; font-weight: bold;\">Air</span> de 5.",
      "prix": "ğŸ”· <strong>Prix:</strong> 200",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "RapiÃ¨re elfique",
      "numero": 48,
      "image": "https://i.ibb.co/Z1FnQ4TH/Rapi-re-Elfique.png",
      "description": "<i>Fine et Ã©lÃ©gante, gravÃ©e de runes lumineuses, elle canalise lâ€™Ã©nergie des anciens bois pour renforcer la magie de son porteur.</i>",
      "tags": [
        "Arme",
        "Ã‰pÃ©e",
        "Une main",
        "Non identifiÃ©"
      ],
      "effet": "<strong>DÃ©gats:</strong> Inflige (4 + Force) points de dÃ©gats physiques.\n<br><strong>Effet:</strong> Augmente l'intelligence de 5.",
      "prix": "ğŸ”· <strong>Prix:</strong> ?",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Armure de cuir de monstre",
      "numero": 49,
      "image": "https://i.ibb.co/MyZR8SYt/Armure-Cuir-Monstre.png",
      "description": "<i>Une armure lÃ©gÃ¨re tannÃ©e dans la peau rugueuse dâ€™une bÃªte abattue, souple mais marquÃ©e de cicatrices naturelles qui tÃ©moignent de la sauvagerie de la crÃ©ature.</i>",
      "tags": [
        "Armure",
        "Armure lÃ©gÃ¨re"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'Armure physique de 2.<br> Augmente l'Endurance de 2.",
      "prix": "ğŸ”· <strong>Prix:</strong> 120",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Cristal de Sel",
      "numero": 50,
      "image": "",
      "description": "<i>Sel raffinÃ© qui sublime le goÃ»t de chaque plat.</i>",
      "tags": [
        "Nourriture"
      ],
      "effet": "<strong>Effet:</strong> Double les soins prodiguÃ©s par une nourriture.\n\n<br>          <strong>Charges:</strong> 5.",
      "prix": "ğŸ”· <strong>Prix:</strong> 50",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    }
  ],
  "filterSettings": {
    "visibleTags": [
      "Consommable"
    ],
    "displayedFilterButtons": [
      "Arme",
      "Armure",
      "Consommable",
      "Bouclier"
    ]
  },
  "categoryDescription": "Ã‰quipements, armes, armures et objets divers que peuvent possÃ©der les personnages.",
  "description": "Fortune + d20"
};
    window.MONSTRES = [
  {
    "nom": "AraignÃ©e GÃ©ante",
    "tags": [
      "ForÃªt"
    ],
    "image": "data/images/Monstres/foret/Monstre_ForÃªt_AraignÃ©eGÃ©ante.png",
    "element": "Nuit",
    "pointsDeVie": 15,
    "armurePhysique": "0",
    "esquive": "2",
    "initiative": "3",
    "coupCritique": "1",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "3",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": "2",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": "5",
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Morsure venimeuse:</strong> Inflige 5 dÃ©gÃ¢ts Physiques. <br> Si (resistance altÃ©rations &lt; 3)  + <span class=\"etat-link\" data-etat=\"EmpoisonnÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">EmpoisonnÃ©</span> 1 pendant 5 tours.<br><br><strong>Toile:</strong> PortÃ©e 9m, equivable, <span class=\"etat-link\" data-etat=\"EntravÃ©/EntoilÃ©/EmbourbÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Entoile</span> la cible pendant 2 tour.",
    "butin": "<strong>Butin:</strong>",
    "monster-abilites": "AAAAAAAA",
    "monster-armurephysique": "0",
    "monster-coupcritique": "1",
    "monster-esquive": "2",
    "monster-resistancealterations": "3",
    "monster-coupcritiquesorts": "0",
    "monster-armureterre": "2",
    "monster-armureobscurite": "5",
    "monster-initiative": "3"
  },
  {
    "nom": "Crabe des Bois",
    "tags": [
      "ForÃªt"
    ],
    "image": "data/images/Monstres/foret/Monstre_ForÃªt_CrabedesBois.png",
    "element": "Eau",
    "pointsDeVie": "30",
    "armurePhysique": "5",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "1",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "5",
    "armureFeu": 0,
    "armureEau": "5",
    "armureTerre": "2",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "Attaque deux fois<br>  <strong>Pinces acÃ©rÃ©es:</strong> Inflige 7 dÃ©gÃ¢ts",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "Groink",
    "tags": [
      "ForÃªt"
    ],
    "image": "data/images/Monstres/foret/Monstre_ForÃªt_Groink.png",
    "element": "Terre",
    "pointsDeVie": "15",
    "armurePhysique": "0",
    "esquive": "1",
    "initiative": 1,
    "coupCritique": "0",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": 3,
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": "3",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": "2",
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Charge brutale:</strong> Fonce et Inflige 5 dÃ©gÃ¢ts. Critique : <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span><br><strong>Lance rocher:</strong> PortÃ©e 15m,  4 dÃ©gats physiques.",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "Groinka",
    "tags": [
      "ForÃªt"
    ],
    "image": "data/images/Monstres/foret/Monstre_ForÃªt_Groinka.png",
    "element": "Terre",
    "pointsDeVie": "15",
    "armurePhysique": "0",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "0",
    "coupCritiqueSorts": "1",
    "resistanceAlterations": "4",
    "armureFeu": "0",
    "armureEau": "0",
    "armureTerre": "3",
    "armureAir": "0",
    "armureLumiere": 0,
    "armureObscurite": 2,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "Attaque : <span class=\"spell-link\" data-spell=\"VolÃ©e de pierres\" data-category=\"Sorts de Mage\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">VolÃ©e de pierres</span>  <br>Soin : <span class=\"spell-link\" data-spell=\"Soin mineur\" data-category=\"Sorts de PrÃªtre\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Soin mineur</span> <br> Alteration: \n<span class=\"spell-link\" data-spell=\"Accroche terrestre\" data-category=\"Sorts d'Enchanteur\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Accroche terrestre</span>",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "GuÃªpe GÃ©ante",
    "tags": [
      "ForÃªt"
    ],
    "image": "data/images/Monstres/foret/Monstre_ForÃªt_GuÃªpeGÃ©ante.png",
    "element": "Air",
    "pointsDeVie": "15",
    "armurePhysique": 0,
    "esquive": "5",
    "initiative": 1,
    "coupCritique": "3",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "3",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": 0,
    "armureAir": "5",
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Volant</strong>: Necessite de sauter pour attaque au corps Ã  corps.<br><strong>Dard: </strong> Inflige 5 degats physiques + 3 <span style=\"color: #22c55e; font-weight: bold;\">Air</span>. Critique : <span class=\"etat-link\" data-etat=\"EmpoisonnÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">EmpoisonnÃ©</span> 1 , 5 tours",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "5"
  },
  {
    "nom": "Ours des Bois",
    "tags": [
      "ForÃªt"
    ],
    "image": "data/images/Monstres/foret/Monstre_ForÃªt_OursdesBois.png",
    "element": "Terre",
    "pointsDeVie": "40",
    "armurePhysique": 4,
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "1",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "4",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": 2,
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 1,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Griffes dÃ©vastatrices:</strong> Inflige 7 dÃ©gÃ¢ts physiques Ã  une cible.<br><strong>Rugissement:</strong> Cible Ã  9m  <span class=\"etat-link\" data-etat=\"Affaibli\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Affaibli</span> , si  (resistance altÃ©rations &lt; 4)",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "1"
  },
  {
    "nom": "Pouple de la forÃªt",
    "tags": [
      "ForÃªt"
    ],
    "image": "",
    "element": "Eau",
    "pointsDeVie": "10",
    "armurePhysique": "0",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "0",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "0",
    "armureFeu": 0,
    "armureEau": "5",
    "armureTerre": 0,
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Accroche:</strong> Inflige 4 dÃ©gÃ¢ts physiques. S'attache Ã  la cible, qui devient <span class=\"etat-link\" data-etat=\"Ralenti\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Ralenti</span>.",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "2"
  },
  {
    "nom": "Serpent de la forÃªt",
    "tags": [
      "ForÃªt"
    ],
    "image": "",
    "element": "Terre",
    "pointsDeVie": 20,
    "armurePhysique": "0",
    "esquive": 5,
    "initiative": 1,
    "coupCritique": "2",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": 3,
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": "5",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Morsure venimeuse:</strong> Inflige 5 dÃ©gÃ¢ts Physiques. <br> Si (resistance altÃ©rations &lt; 4)  + <span title=\"Des dÃ©gats sont appliquÃ©s Ã  chaque dÃ©but de tour du lanceur, rÃ©duits ni par l'armure physique ni par l'armure Ã©lÃ©mentaire.\">EmpoisonnÃ©</span>2 pendant 5 tours.<br><br>",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "4"
  },
  {
    "nom": "ScarabÃ©e gÃ©ant",
    "tags": [
      "ForÃªt"
    ],
    "image": "",
    "element": "Air",
    "pointsDeVie": 20,
    "armurePhysique": "3",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "0",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "5",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": 0,
    "armureAir": "5",
    "armureLumiere": 0,
    "armureObscurite": "5",
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Volant</strong>: Necessite de sauter pour attaque au corps Ã  corps.<br><strong>Morsure: </strong> inflige 5 physique.\n<br><strong>Vent aveuglant: </strong> PortÃ©e 6m, esquivable, inflige 5 <span style=\"color: #22c55e; font-weight: bold;\">Air</span>. Si (Res Alt &lt; 4) <span class=\"etat-link\" data-etat=\"AveuglÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">AveuglÃ©</span>",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "5"
  },
  {
    "nom": "Boss ForÃªt",
    "tags": [
      "ForÃªt",
      "Boss"
    ],
    "image": "",
    "element": "Terre",
    "pointsDeVie": "200",
    "armurePhysique": "3",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "2",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "10",
    "armureFeu": 0,
    "armureEau": "0",
    "armureTerre": "10",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": "5",
    "armureDivin": 0,
    "armureMalefique": "5",
    "abilites": "Double attaque.<br><strong>Attaque basique:</strong> Inflige 10 dÃ©gÃ¢ts physiques. <br><strong>Hurlement:</strong> Tous les adversaires Ã  15m, avec Resistance altÃ©ration &lt; 6, sont <span class=\"etat-link\" data-etat=\"Affaibli\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Affaibli</span>.  \n<br><b>Repoussoir</b>: Repousse une une cible Ã  9m. Inflige 5 dÃ©gats.\n<br><b>Appel </b>: Hurle et fait venir 2 Groinkas.\n<br><b>Tremblement de terre </b>: Tous les adversaires Ã  15m, 7 dÃ©gats <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> , critique 12.",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "3"
  }
];
    window.TABLES_TRESORS = {
  "tables": [
    {
      "nom": "Monstre forÃªt commun",
      "description": "feffez",
      "tags": [
        "ForÃªt"
      ],
      "fourchettes": [
        {
          "min": 1,
          "max": 3,
          "objet": {
            "type": "reference",
            "numero": 15,
            "nom": "Feuilleclaire"
          }
        },
        {
          "min": 4,
          "max": 6,
          "objet": {
            "type": "reference",
            "numero": 16,
            "nom": "Nocteline"
          }
        },
        {
          "min": 7,
          "max": 9,
          "objet": {
            "type": "reference",
            "numero": 13,
            "nom": "Petite potion de mana"
          }
        },
        {
          "min": 10,
          "max": 12,
          "objet": {
            "type": "reference",
            "numero": 12,
            "nom": "Petite potion de vie"
          }
        },
        {
          "min": 13,
          "max": 15,
          "objet": {
            "type": "reference",
            "numero": 21,
            "nom": "Fruits de la forÃªt"
          }
        },
        {
          "min": 16,
          "max": 19,
          "objet": {
            "type": "reference",
            "numero": 17,
            "nom": "Baguette de d'accÃ©lÃ©ration"
          }
        }
      ]
    },
    {
      "nom": "Boss forÃªt",
      "description": "BBB",
      "tags": [
        "ForÃªt",
        "Boss"
      ],
      "fourchettes": [
        {
          "min": 1,
          "max": 3,
          "objet": {
            "type": "reference",
            "numero": 21,
            "nom": "Fruits de la forÃªt"
          }
        },
        {
          "min": 4,
          "max": 8,
          "objet": {
            "type": "reference",
            "numero": 11,
            "nom": "Armure de plaque"
          }
        },
        {
          "min": 9,
          "max": 12,
          "objet": {
            "type": "reference",
            "numero": 18,
            "nom": "Baguette de sommeil"
          }
        },
        {
          "min": 13,
          "max": 16,
          "objet": {
            "type": "reference",
            "numero": 8,
            "nom": "Robe simple"
          }
        },
        {
          "min": 17,
          "max": 20,
          "objet": {
            "type": "reference",
            "numero": 4,
            "nom": "BÃ¢ton en bois"
          }
        }
      ]
    },
    {
      "nom": "ProvisionAuberge",
      "description": "Table de butin pour une situation spÃ©cifique.",
      "tags": [
        "Auberge"
      ],
      "fourchettes": [
        {
          "min": 1,
          "max": 5,
          "objet": {
            "type": "reference",
            "numero": 22,
            "nom": "Ration de survie"
          }
        },
        {
          "min": 5,
          "max": 8,
          "objet": {
            "type": "reference",
            "numero": 19,
            "nom": "Ration de nourriture"
          }
        },
        {
          "min": 9,
          "max": 12,
          "objet": {
            "type": "reference",
            "numero": 15,
            "nom": "Feuilleclaire"
          }
        },
        {
          "min": 13,
          "max": 17,
          "objet": {
            "type": "reference",
            "numero": 25,
            "nom": "Bandage d'urgence"
          }
        },
        {
          "min": 18,
          "max": 21,
          "objet": {
            "type": "reference",
            "numero": 12,
            "nom": "Petite potion de vie"
          }
        },
        {
          "min": 22,
          "max": 30,
          "objet": {
            "type": "reference",
            "numero": 20,
            "nom": "Ration copieuse de nourriture"
          }
        },
        {
          "min": 31,
          "max": 35,
          "objet": {
            "type": "reference",
            "numero": 1,
            "nom": "Nouvel objet"
          }
        }
      ]
    }
  ],
  "_metadata": {
    "availableTags": [
      "ForÃªt",
      "Boss",
      "Coffre",
      "Auberge"
    ]
  }
};
    window.COLLECTIONS = {
  "collections": [
    {
      "id": "d-part",
      "nom": "DÃ©part",
      "description": "Objets disponibles Ã  la crÃ©ation du personnage.",
      "icon": "ğŸ“¦",
      "objets": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        12,
        16,
        15,
        14,
        13,
        19,
        20,
        23,
        25
      ]
    }
  ]
};
    window.IMAGES = {
  "images": {
    "subclass:Guerrier:Nain des montagnes": "https://i.ibb.co/Zpv02X9p/e8c10c36dc90.jpg",
    "subclass:Guerrier:Berserker": "https://i.ibb.co/DPYjyGVd/b85000c2afa4.jpg",
    "subclass:Mage:Ã‰rudit": "https://i.ibb.co/M5pcNmF9/05fa4e535010.jpg",
    "subclass:Mage:Elfe": "https://i.ibb.co/K1SMkgb/d738588e0528.jpg",
    "subclass:PrÃªtre:Inquisiteur": "https://i.ibb.co/dJ02RNMc/c9cd3553df7e.jpg",
    "subclass:PrÃªtre:Clerc Divin": "https://i.ibb.co/8gFGZYqJ/698304cc75ee.jpg",
    "subclass:RÃ´deur:Voleur": "https://i.ibb.co/q3jSxDnQ/90e89c692b47.jpg",
    "subclass:RÃ´deur:Chasseur": "https://i.ibb.co/70wP75z/53de7da9e55c.jpg",
    "subclass:Enchanteur:Esprit de la grande FÃ©e": "https://i.ibb.co/Cswfsyzz/9920a4e75242.jpg",
    "subclass:Enchanteur:Lutin": "https://i.ibb.co/Fbspq9hP/dd5e7b366e0f.jpg",
    "sort:Sorts de Mage:Boule de Feu": "https://i.ibb.co/vCWmgrQ5/Boule-De-Feu.png",
    "sort:Sorts de Mage:Ã‰clair": "https://i.ibb.co/VYCTyMdH/Eclair.png",
    "sort:Sorts de Mage:Vague dÃ©ferlante": "https://i.ibb.co/BSHtL8K/Vague.png",
    "sort:Sorts de PrÃªtre:ChÃ¢timent": "https://i.ibb.co/JRPyXx1L/Chatiment-Sacr.png",
    "sort:Sorts de PrÃªtre:Soin mineur": "https://i.ibb.co/YBC2HSnK/Soin-Mineur.png",
    "sort:Sorts d'Enchanteur:Accroche terrestre": "https://i.ibb.co/27W4NtSQ/Accroche-Terre.png",
    "sort:Sorts d'Enchanteur:AccÃ©lÃ©ration": "https://i.ibb.co/Vc072qQB/Acceleration.png",
    "sort:Sorts d'Enchanteur:Sommeil": "https://i.ibb.co/rKyTh27C/Sleep.png",
    "sort:Sorts de PrÃªtre:Nouveau Sort": "https://i.ibb.co/7d1L9BCj/Nova-Lumineuse.png",
    "sort:Sorts de PrÃªtre:Protection": "https://i.ibb.co/QvK52kxH/Protection.png",
    "subclass:Guerrier:Nain des montagnes:1": "https://i.ibb.co/FL9m5HJn/Nain.png",
    "subclass:Guerrier:Nain des montagnes:2": "https://i.ibb.co/wNnJxSbj/NaineF.png",
    "subclass:Guerrier:Berserker:1": "https://i.ibb.co/YBWFbTKv/berseker.png",
    "subclass:Guerrier:Berserker:2": "https://i.ibb.co/20b74x2R/Berseker-F.png",
    "subclass:Mage:Ã‰rudit:1": "https://i.ibb.co/N8qT2Hf/Mage.png",
    "subclass:Mage:Ã‰rudit:2": "https://i.ibb.co/LdcPDSJQ/MageF.png",
    "subclass:Mage:Elfe:2": "https://i.ibb.co/VWDTjY8H/ElfeF.png",
    "subclass:Mage:Elfe:1": "https://i.ibb.co/gFVKrTcV/Elfe.png",
    "subclass:PrÃªtre:Inquisiteur:1": "https://i.ibb.co/tMcsCB8s/Inquisiteur.png",
    "subclass:PrÃªtre:Clerc Divin:1": "https://i.ibb.co/209W4ZHW/Pr-tre.png",
    "subclass:RÃ´deur:Voleur:1": "https://i.ibb.co/NghMq11n/Voleur-min.png",
    "subclass:RÃ´deur:Voleur:2": "https://i.ibb.co/h1BtkGMX/VoleurF.png",
    "subclass:RÃ´deur:Chasseur:1": "https://i.ibb.co/yF8jrJYr/Chasseur-min.png",
    "subclass:RÃ´deur:Chasseur:2": "https://i.ibb.co/3mQjLJbp/Chasseur-F.png",
    "subclass:Enchanteur:Esprit de la grande FÃ©e:1": "https://i.ibb.co/VY9cQHNh/F-eM.png",
    "subclass:Enchanteur:Esprit de la grande FÃ©e:2": "https://i.ibb.co/pjxDfXBC/F-e.png",
    "subclass:Enchanteur:Lutin:1": "https://i.ibb.co/6cxkMW1d/Lutin.png",
    "subclass:Enchanteur:Lutin:2": "https://i.ibb.co/qLbjJhxw/LutinF.png",
    "subclass:PrÃªtre:Inquisiteur:2": "https://i.ibb.co/LXwmWYR3/Inquisiteur-F.png",
    "subclass:PrÃªtre:Clerc Divin:2": "https://i.ibb.co/HfBVNLM3/PretreF.png",
    "sort:Sorts de PrÃªtre:Arme de lumiÃ¨re": "https://i.ibb.co/cXh57Pdn/ArmeLum.png",
    "objet:Ã‰pÃ©e Longue": "https://i.ibb.co/35rpP6ZS/Epee2M1.png",
    "objet:Espadon": "https://i.ibb.co/35rpP6ZS/Epee2M1.png",
    "objet:Simple Ã©pÃ©e": "https://i.ibb.co/PsSXvSXx/Epee1.png",
    "objet:Dague en fer": "https://i.ibb.co/1fCwy6cR/Dague1.png",
    "objet:BÃ¢ton en bois": "https://i.ibb.co/PsyCNw86/Baton1.png",
    "objet:Gourdin": "https://i.ibb.co/whZCKww0/Baton2.png",
    "objet:Arc simple": "https://i.ibb.co/cKb1JKZQ/Arc1.png",
    "objet:Bouclier en bois": "https://i.ibb.co/67bK4Bw8/Bouclier1.png",
    "objet:Robe simple": "https://i.ibb.co/VYFpnz8h/Robe1.png",
    "objet:Armure de cuir": "https://i.ibb.co/9Hkw2VFb/Armure-Cuir1.png",
    "objet:Armure en maille": "https://i.ibb.co/cXtwzw5b/Armure-Lourde1.png",
    "objet:Armure de plaque": "https://i.ibb.co/fVg5Fp6h/Armure-Lourde2.png",
    "subclass:Guerrier:Aventurier:1": "https://i.ibb.co/9HcQkbb2/Aventurier.png",
    "subclass:Guerrier:Aventurier:2": "https://i.ibb.co/nH8Yj3h/Aventurier-F.png",
    "objet:Petite potion de vie": "https://i.ibb.co/Mw2Qb8Y/LifePot1.png",
    "objet:Petite potion de mana": "https://i.ibb.co/MkwzbQ3S/Potion-Mana1.png",
    "objet:Baguette de boule de feu": "https://i.ibb.co/JwXs3k2V/Baguette-Feu.png",
    "objet:Feuilleclaire": "https://i.ibb.co/bMDstDVV/Herb1.png",
    "objet:Nocteline": "https://i.ibb.co/7JpQ7Kr7/Herb2.png",
    "objet:Nouvel Objet": "https://i.ibb.co/3Y0fvrCG/Sel.png",
    "objet:Baguette de sommeil": "https://i.ibb.co/bMXNS4gy/Baguette-Nuit.png",
    "monster:AraignÃ©e GÃ©ante": "https://i.ibb.co/b0XHjQJ/Monstre-For-t-Araign-e.png",
    "monster:Crabe des Bois": "https://i.ibb.co/7dY3GgJS/Monstre-For-t-Crab.png",
    "monster:Groink": "https://i.ibb.co/MDngQGcS/Monstre-For-t-Groink.png",
    "monster:Groinka": "https://i.ibb.co/YThB7Q29/Monstre-For-t-Groink-Chaman.png",
    "monster:GuÃªpe GÃ©ante": "https://i.ibb.co/bjSq3pPj/Monstre-For-t-Guepe-Geante.png",
    "monster:Ours des Bois": "https://i.ibb.co/N2NcD6n2/Monstre-For-t-Ours.png",
    "monster:Pouple de la forÃªt": "https://i.ibb.co/0jG2WLsv/Monstre-For-t-Poulpe.png",
    "monster:Serpent de la forÃªt": "https://i.ibb.co/svhHLvKZ/Monstre-For-t-Serpent.png",
    "monster:ScarabÃ©e gÃ©ant": "https://i.ibb.co/wF5bRvts/Monstre-For-t-Scarabe-Geant.png",
    "monster:Boss ForÃªt": "https://i.ibb.co/1JR11CC7/Monstre-For-t-Boss.png",
    "sort:Sorts de Mage:VolÃ©e de pierres": "https://i.ibb.co/GfPFdZPG/Volee-Pierre.png",
    "objet:Baguette de d'accÃ©lÃ©ration": "https://i.ibb.co/zT29mKBd/Baguette-Lumiere.png",
    "objet:Ration de nourriture": "https://i.ibb.co/tT6gW6p0/Food1.png",
    "objet:Ration copieuse de nourriture": "https://i.ibb.co/7JZW2ZZT/Food2.png",
    "objet:Fruits de la forÃªt": "https://i.ibb.co/svC0cDH6/food3.png",
    "sort:Sorts de PrÃªtre:Refermer les blessures": "https://i.ibb.co/zV1rzFkd/Soin-Mineur.png",
    "objet:Ration de survie": "https://i.ibb.co/Py57FHy/Food0.png",
    "subclass:Guerrier:Nouvelle sous-classe:1": "https://i.ibb.co/dsPhMWkY/Ma-tre-d-armes.png",
    "subclass:Guerrier:MaÃ®tre dâ€™armes:1": "https://i.ibb.co/dsPhMWkY/Ma-tre-d-armes.png",
    "subclass:Guerrier:MaÃ®tre dâ€™armes:2": "https://i.ibb.co/BVD015MF/Ma-tre-d-armes-F.png",
    "objet:FlÃ¨che aiguisÃ©e": "https://i.ibb.co/4Z7qKXCx/Fleche-Aiguis-e.png",
    "objet:FlÃ¨che de la terre": "https://i.ibb.co/ZpScRTwS/Fleche-Terre.png",
    "page:geographie": "https://i.ibb.co/svmYXJbN/Carte-fantastique-d-taill-e-et-color-e.png",
    "sort:Sorts de PrÃªtre:RÃ©vÃ©lation mineure": "https://i.ibb.co/DP5md5sT/Revelation-Mineure.png",
    "sort:Sorts de PrÃªtre:RÃ©vÃ©lation majeure": "https://i.ibb.co/hRhqmPCK/Revelation-Majeure.png",
    "sort:Sorts de PrÃªtre:RÃ©vÃ©lation ultime": "https://i.ibb.co/7xY0wvNK/Revelation-Ultime.png",
    "objet:Bandage d'urgence": "https://i.ibb.co/4ZPsSM3p/Bandages.png",
    "objet:Bracelet mÃ©dicinal de la forÃªt": "https://i.ibb.co/k2h292gV/Bracelet-Foret.png",
    "objet:Dent de Grouink": "https://i.ibb.co/whc5dwnw/Dent-Grouik.png",
    "objet:Echarpe de chaman Groink": "https://i.ibb.co/W4tfpFcH/Echarpe-Chaman.png",
    "objet:Fourrure d'ours": "https://i.ibb.co/9HhVCqvk/Fourrure-Ours.png",
    "objet:Pierre Ã  aiguiser": "https://i.ibb.co/SX10mS2q/Buff01.png",
    "objet:Cristal d'effort": "https://i.ibb.co/k2MHGqhx/Cristal-Effort.png",
    "objet:Pince de crabe gÃ©ant des forÃªts": "https://i.ibb.co/VWKF2ysm/Masse-Foret1.png",
    "objet:Clairgivre": "https://i.ibb.co/s9CJtsPr/Herb5.png",
    "objet:AurÃ©line des Roches": "https://i.ibb.co/My3mcc60/Herb3.png",
    "objet:NÃ©brelle dâ€™Azur": "https://i.ibb.co/bMn4mMyK/Herb4.png",
    "objet:Aile de scarabÃ©e gÃ©ant": "https://i.ibb.co/RGZM6Tfx/Cape-Scarab.png",
    "objet:Bottes en cuir de guÃªpe gÃ©ante": "https://i.ibb.co/k2V6Df2z/Botte-Guepe.png",
    "objet:Gants patte d'ours": "https://i.ibb.co/KzrZRGcd/Gants-Patte-Ours.png",
    "objet:Bouclier de la forÃªt": "https://i.ibb.co/Zpkw8qVL/Bouclier-Foret.png",
    "objet:Couronne d'Ã©pines": "https://i.ibb.co/d09YYyy8/Couronne-Epines.png",
    "objet:Collier terrestre": "https://i.ibb.co/ksxCppN8/Collier-Terrestre.png",
    "objet:Arc de chasseur": "https://i.ibb.co/bRXH0Vwj/Arc2.png",
    "objet:Dard de guÃªpe gÃ©ante": "https://i.ibb.co/mjcDdck/Dague2.png",
    "objet:Grande hache de bÃ»cheron": "https://i.ibb.co/gMbq4QZD/Hache-Bucheron.png",
    "objet:Tunique d'explorateur": "https://i.ibb.co/Kj070KVw/Robe2.png",
    "objet:Robe de la forÃªt": "https://i.ibb.co/Zp7bLygX/Robe3.png",
    "objet:Armure en cuir d'ours": "https://i.ibb.co/C3bVcQkV/Armure-Ours.png",
    "objet:RapiÃ¨re elfique": "https://i.ibb.co/Z1FnQ4TH/Rapi-re-Elfique.png",
    "sort:Sorts de PrÃªtre:Resistance": "https://i.ibb.co/TxWg9bns/Resistance.png",
    "sort:Sorts de PrÃªtre:GuÃ©rison du poison": "https://i.ibb.co/4nhGwkjX/Anti-Poison.png",
    "sort:Sorts de PrÃªtre:Nova lumineuse": "https://i.ibb.co/7d1L9BCj/Nova-Lumineuse.png",
    "sort:Sorts de PrÃªtre:Toucher Lointain": "https://i.ibb.co/k2Z2WrP4/Soin-Distance.png",
    "sort:Sorts de Mage:Faisceau lumineux": "https://i.ibb.co/KpXwSx6V/Faiseau-Lum.png",
    "sort:Sorts de Mage:Vague sombre": "https://i.ibb.co/0yRTFkqy/Vague-sombre.png",
    "sort:Sorts de Mage:Missile magique": "https://i.ibb.co/bM9VS8GB/Missile-Magique.png",
    "sort:Sorts de Mage:Nuage toxique": "https://i.ibb.co/35C4DgdS/Nuage-Toxique.png",
    "sort:Sorts d'Enchanteur:Nouveau Sort": "https://i.ibb.co/FLbCrnKQ/L-vitation.png",
    "sort:Sorts d'Enchanteur:LÃ©vitation": "https://i.ibb.co/FLbCrnKQ/L-vitation.png",
    "sort:Sorts d'Enchanteur:ImprÃ©gnation Ã©lÃ©mentaire feu terre nuit": "https://i.ibb.co/RkrW8CRC/Enchant-Element.png",
    "sort:Sorts d'Enchanteur:ImprÃ©gnation Ã©lÃ©mentaire eau air lumiÃ¨re": "https://i.ibb.co/WNWfc1jC/Enchant-Element2.png",
    "sort:Sorts d'Enchanteur:Silence": "https://i.ibb.co/7JRKfdMw/Silence.png",
    "sort:Sorts d'Enchanteur:Puissance magique": "https://i.ibb.co/FbtF1PjX/Puissance-Sort.png",
    "sort:Sorts d'Enchanteur:Puissance physique": "https://i.ibb.co/VckPSx1C/Puissance-Physique.png",
    "sort:Sorts d'Enchanteur:Confusion": "https://i.ibb.co/vCwsVnR5/Confusion.png",
    "sort:Sorts d'Enchanteur:Armure Ã©lÃ©mentaire Feu Terre Nuit": "https://i.ibb.co/SH5jcyv/Armure-El-mentaire1.png",
    "sort:Sorts d'Enchanteur:Armure Ã©lÃ©mentaire Eau Air LumiÃ¨re": "https://i.ibb.co/jP9RKzdq/Armure-El-mentaire2.png",
    "objet:Armure de cuir de monstre": "https://i.ibb.co/MyZR8SYt/Armure-Cuir-Monstre.png"
  },
  "meta": {
    "total_images": 131,
    "exported_date": "2025-09-11",
    "note": "Ces images incluent les nouvelles images uploadÃ©es"
  }
};
    
    // Page descriptions
    window.MONSTRES_PAGE_DESC = {
  "description": "CrÃ©atures, ennemis et adversaires que peuvent affronter les hÃ©ros dans leurs aventures."
};
    window.TABLES_TRESORS_PAGE_DESC = {
  "description": "Fortune + d20"
};
    
    // Custom page descriptions for collections and other dynamic pages
    window.CUSTOM_PAGE_DESCRIPTIONS = {
  "collections-objets": "Recherchez et explorez des collections d'objets.\n<br>Par exemple, tapez <b>DÃ©part</b> pour voir les objets disponnibles lors de la crÃ©ation du personnage.\n<br>Les collections sont cachÃ©es de base pour Ã©viter le <b>spoil</b>."
};
    
    // TOC Structure for advanced navigation
    window.TOC_STRUCTURE = {
  "directPages": [
    {
      "type": "page",
      "id": "favoris",
      "title": "â­ Favoris",
      "icon": "â­"
    }
  ],
  "sections": [
    {
      "id": "heros",
      "title": "ğŸ¦¸ HÃ©ros",
      "icon": "ğŸ¦¸",
      "description": "CrÃ©ation et dÃ©veloppement des personnages",
      "collapsed": false,
      "items": [
        {
          "type": "page",
          "id": "creation",
          "title": "CrÃ©ation d'un personnage",
          "icon": "ğŸ­"
        },
        {
          "type": "category",
          "id": "classes",
          "title": "Classes",
          "icon": "âš”ï¸",
          "items": "CLASSES"
        },
        {
          "type": "category",
          "id": "dons",
          "title": "Dons",
          "icon": "ğŸ–ï¸",
          "items": "DONS"
        },
        {
          "type": "page",
          "id": "feuille-personnage",
          "title": "Feuille de personnage",
          "icon": "ğŸ“‹"
        }
      ]
    },
    {
      "id": "arsenal",
      "title": "âš”ï¸ Arsenal",
      "icon": "âš”ï¸",
      "description": "Sorts, objets et Ã©quipements",
      "collapsed": false,
      "items": [
        {
          "type": "category",
          "id": "sorts",
          "title": "Sorts",
          "icon": "ğŸ”®",
          "items": "SORTS"
        },
        {
          "type": "page",
          "id": "objets",
          "title": "Objets",
          "icon": "ğŸ“¦"
        },
        {
          "type": "page",
          "id": "collections-objets",
          "title": "Collections d'Objets",
          "icon": "ğŸ“š"
        }
      ]
    },
    {
      "id": "regles",
      "title": "ğŸ“š RÃ¨gles",
      "icon": "ğŸ“š",
      "description": "MÃ©caniques de jeu et rÃ©fÃ©rences",
      "collapsed": false,
      "items": [
        {
          "type": "page",
          "id": "elements",
          "title": "Ã‰lÃ©ments",
          "icon": "ğŸŒŸ"
        },
        {
          "type": "page",
          "id": "stats",
          "title": "Statistiques",
          "icon": "ğŸ“Š"
        },
        {
          "type": "page",
          "id": "competences-tests",
          "title": "CompÃ©tences & Tests",
          "icon": "ğŸ¯"
        },
        {
          "type": "page",
          "id": "etats",
          "title": "Ã‰tats",
          "icon": "âš¡"
        },
        {
          "type": "page",
          "id": "combat",
          "title": "Combat",
          "icon": "âš”ï¸"
        },
        {
          "type": "page",
          "id": "gestion-des-ressources",
          "title": "Gestion des ressources",
          "icon": "ğŸ’"
        }
      ]
    },
    {
      "id": "maitre-de-jeu",
      "title": "ğŸ­ MaÃ®tre de jeu",
      "icon": "ğŸ­",
      "description": "Outils et ressources pour le MaÃ®tre de jeu",
      "collapsed": false,
      "requiresMJ": true,
      "items": [
        {
          "type": "page",
          "id": "monstres",
          "title": "Monstres",
          "icon": "ğŸ‘¹"
        },
        {
          "type": "page",
          "id": "tables-tresors",
          "title": "Tables de trÃ©sors",
          "icon": "ğŸ’"
        },
        {
          "type": "page",
          "id": "audio",
          "title": "Musiques d'ambiance",
          "icon": "ğŸµ"
        },
        {
          "type": "page",
          "id": "traumas",
          "title": "Traumas",
          "icon": "ğŸ©¹"
        },
        {
          "type": "page",
          "id": "campagne",
          "title": "Campagne",
          "icon": "ğŸ“–"
        },
        {
          "type": "page",
          "id": "gestion-objets",
          "title": "Gestion des Objets",
          "icon": "âš”ï¸"
        }
      ]
    },
    {
      "id": "monde",
      "title": "ğŸŒ Monde",
      "icon": "ğŸŒ",
      "description": "Univers et connaissances du monde",
      "collapsed": false,
      "items": [
        {
          "type": "page",
          "id": "histoire",
          "title": "Histoire",
          "icon": "ğŸ“œ"
        },
        {
          "type": "page",
          "id": "dieux",
          "title": "Dieux",
          "icon": "ğŸ›ï¸"
        },
        {
          "type": "page",
          "id": "geographie",
          "title": "Geographie",
          "icon": "ğŸ“œ"
        }
      ]
    }
  ]
};
    
    // Build STATIC_PAGES dynamically from all loaded page data
    window.STATIC_PAGES = {
      'creation': {
  "page": "creation",
  "title": "CrÃ©ation d'un personnage",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "",
      "id": "section-0"
    },
    {
      "type": "card",
      "id": "etapes-creation",
      "title": "Ã‰tapes de crÃ©ation",
      "content": "<ol><li>Choisir une <strong>classe</strong> puis une <strong>sousâ€‘classe</strong> : <a href=\"#/guerrier\" style=\"color: var(--accent); text-decoration: underline;\">Guerrier</a>.</li><li>Choisir un <strong>Ã©lÃ©ment</strong> d'affiliation : <a href=\"#/elements\" style=\"color: var(--accent); text-decoration: underline;\">Ã‰lÃ©ments</a>.</li><li>Choisir les <strong>dons</strong> (avec 2 points de dons) : <a href=\"#/dons-generaux\" style=\"color: var(--accent); text-decoration: underline;\">Generaux (dons)</a>.</li><li>Choisir l'<strong>Ã©quipement</strong> de dÃ©part (avec 100 Ã©clats) : <a href=\"#/collections-objets\" style=\"color: var(--accent); text-decoration: underline;\">Collections d'Objets</a>.</li><li>DÃ©finir le <strong>nom</strong>, l'<strong>histoire</strong> et l'<strong>apparence</strong>.</li><li>Remplir sa feuille de personnage : <a href=\"#/feuille-personnage\" style=\"color: var(--accent); text-decoration: underline;\">Feuille de personnage</a>.</li></ol>",
      "deletable": true,
      "sectionName": "Ã‰tapes de crÃ©ation"
    }
  ]
},
      'elements': {
  "page": "elements",
  "title": "Elements",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "elements-system",
      "title": "SystÃ¨me d'Ã©lÃ©ments",
      "content": "<p>Il existe huit Ã©lÃ©ments, chacun ayant un opposÃ©. ChaquÃ© HÃ©ros oÃ¹ monstre possÃ¨de un Ã©lÃ©ment d'affiliation.<br><br> Une crÃ©ature affiliÃ©e Ã  un Ã©lÃ©ment :<br> - ReÃ§oit <strong>deux fois moins </strong> (arrondi infÃ©rieur) de dÃ©gats venant des sorts et attaques de cet Ã©lÃ©ment, et ne peut pas recevoir d'effet critique d'une alteration magique de cet Ã©lÃ©ment.<br>- Recevra systÃ©matiquement des <strong>effets critiques</strong> venant des sorts et altÃ©rations de l'Ã©lÃ©ment opposÃ©. Les dÃ©gats Ã©lÃ©mentaires rattachÃ©s Ã  une attaque physique (venant d'un objet ou sort) voit ses dÃ©gats doublÃ©s s'il est d'un Ã©lÃ©ment opposÃ©.</p>"
    },
    {
      "type": "card",
      "id": "element-pairs",
      "title": "Paires opposÃ©es",
      "content": "<div class=\"element-pairs\"><div class=\"pair\">ğŸ”¥ <span style=\"color: #ff6b35; font-weight: bold;\">Feu</span> âŸ· ğŸ’§ <span style=\"color: #4682b4; font-weight: bold;\">Eau</span></div><div class=\"pair\">ğŸ¤ <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> âŸ· ğŸŸ¢ <span style=\"color: #22c55e; font-weight: bold;\">Air</span></div><div class=\"pair\">â˜€ï¸ <span style=\"color: #ffd700; font-weight: bold;\">LumiÃ¨re</span> âŸ· âš« <span style=\"color: #1a1a1a; font-weight: bold;\">Nuit</span></div><div class=\"pair\">âšª <span style=\"color: #f5f5f5; font-weight: bold; background: rgba(100, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;\">Divin</span> âŸ· ğŸŸ£ <span style=\"color: #8b5cf6; font-weight: bold;\">MalÃ©fique</span></div></div>"
    },
    {
      "type": "card",
      "id": "element-defense",
      "title": "DÃ©fense",
      "content": "<p>Certaines armures/objets/bonus peuvent procurer une armure spÃ©cifique Ã  un Ã©lÃ©ment. Il faudra alors dÃ©duire au resultat final. Le calcul de dÃ©gats se fait dans cet ordre :</p><div><strong>DÃ©gats â†’ critique â†’ Ã—0.5 si affiliation Ã©lÃ©ment â†’ rÃ©duction de l'armure</strong></div>",
      "deletable": true,
      "sectionName": "DÃ©fense"
    },
    {
      "type": "card",
      "id": "element-attack",
      "title": "Attaque",
      "content": "<p>Une attaque ne peut avoir qu'<strong>un seul Ã©lÃ©ment</strong> (en plus d'Ã©ventuels dÃ©gats physiques). Si plusieurs sorts/Ã©quipements/bonus donnent un Ã©lÃ©ment Ã  l'attaque, le hÃ©ros devra choisir quel est l'Ã©lÃ©ment utilisÃ©.</p> Plusieurs bonus d'un mÃªme Ã©lÃ©ment peuvent se cumuler.\n<br><br> Si l'Ã©lÃ©ment rattachÃ© Ã  une attaque physiques est opposÃ© Ã  l'Ã©lÃ©ment d'affiliation de la cible, alors les dÃ©gats Ã©lÃ©mentaires sont doublÃ©s.",
      "deletable": true,
      "sectionName": "Attaque"
    }
  ]
},
      'stats': {
  "page": "stats",
  "title": "Statistiques",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "stats-base",
      "title": "Statistiques de base",
      "content": "<hr><div class=\"stats-grid\"><div class=\"stat-card\"><h4>ğŸ’ª Force</h4><p>AmÃ©liore les dÃ©gÃ¢ts physiques.</p></div><hr>\n\n<div class=\"stat-card\"><h4>ğŸ›¡ï¸ Endurance</h4><p>Les points de vie maximum sont de : <strong>(2 x Endurance)</strong></p><p></div>\n\n<hr><div class=\"stat-card\">\n<h4>ğŸƒ AgilitÃ©</h4><p>Chaque 5 points ajoutent <strong>+1</strong> aux jets d'esquive et de critique physique.\n<br><br>Augmente l'initiative d'autant.</p></div><hr>\n\n<div class=\"stat-card\"><h4>ğŸ§  Intelligence</h4><p>DÃ©termine la puissance des sorts.</p></div><hr><div class=\"stat-card\"><h4>âš¡ VolontÃ©</h4><p>Le mana maximum est de : <strong>(10 + 2 x VolontÃ©)</strong></p><p>Augmente la RÃ©sistance altÃ©rations.</p>\n\n</div><hr><div class=\"stat-card\"><h4>ğŸ€ Chance</h4><p>AmÃ©liore la Fortune d'autant.</p><p>De plus, chaque 5 points ajoutent <strong>+1</strong> aux chances de coup critique avec les sorts et les consommables.</p></div></div>",
      "deletable": true,
      "sectionName": "Statistiques de base"
    },
    {
      "type": "card",
      "id": "stats-new-3-1755784997112",
      "title": "Statistiques secondaires",
      "content": "<hr><br><br><strong>Chance de coup critique (physique) </strong> : Lors d'une attaque physique, le lanceur de l'attaque lance un d20. S'il fait 20, alors les dÃ©gats physiques (et seulement physiques) sont doublÃ©s.<br> Augmenter les chances de coup critique rÃ©duit la valeur du dÃ© nÃ©cÃ©ssaire pour faire un critique. Par exemple, avec 3 de chance de coup critique, si le dÃ© fait de 17 Ã  20, l'attaque est critique.\n\n<br><br><hr><br><strong>Chance de coup critique (sorts et consommables)</strong> : Lorsque un hÃ©ros ou un monstre lance un sort ou utilise un consommable, il lance un d20. S'il fait 20, alors le sort est critique, chaque sort/consommable ayant un effet critique diffÃ©rent (indiquÃ© dans sa description).<br> Augmenter les chances de coup critique des sorts et consommables rÃ©duit la valeur du dÃ© nÃ©cÃ©ssaire pour faire un critique. Par exemple, avec 3 de chance de coup critique, si le dÃ© fait de 17 Ã  20, le resultat est critique. \n\n<br><br><hr><br><strong>Esquive </strong> : Lors d'une attaque physique, ou d'un sort sans effet si esquive (indiquÃ© dans la fiche du sort), lorsque le lanceur lance son d20, si le resultat est 1, l'attaque est sans effet. Avoir de l'esquive pour la cible de l'attaque augmente la valeur du dÃ© jusqu'a laquelle l'attaque Ã©choue. Par exemple, avec 3 d'esquive, si le dÃ© fait 4 ou moins, l'attaque Ã©choue. La valeur d'esquive ne peut jamais dÃ©passer 9, quel que soit l'equipement ou bonus d'un joueur ou monstre.\n\n\n<br><br><hr><br><strong>RÃ©sistance altÃ©rations </strong> : Lorsqu'un lanceur de sort tente d'infliger une alteration magique Ã  une cible, on compare la valeur de l'intelligence du lanceur Ã  la RÃ©sistance altÃ©rations de la cible. Si l'intelligence est strictement supÃ©rieure, alors l'ateration rÃ©ussit, sinon elle est sans effet.\n\n\n<br><br><hr><br><strong>Armure physique </strong> : Lorsqu'un hÃ©ros ou monstre reÃ§oit des dÃ©gats physiques, ils sont alors rÃ©duit de la valeur de l'armure physique pour savoir combien de points de vies sont retirÃ©s Ã  la cible. Cette valeur est retirÃ© en dernier sur les degats (aprÃ©s avoir Ã©ventuellement doublÃ© les dÃ©gats si critique etc...)\n\n<br><br><hr><br><strong>Armure Ã©lÃ©mentaire </strong> : L'armure Ã©lÃ©mentaire est spÃ©cifique pour chaque Ã©lÃ©ment, il y a donc 8 types d'armure Ã©lÃ©mentaire. Lorsqu'un hÃ©ros ou monstre subit des dÃ©gats Ã©lÃ©mentaire correspondant Ã  l'armure Ã©lÃ©mentaire, ils sont alors rÃ©duit de la valeur de l'armure pour savoir combien de points de vies sont retirÃ©s Ã  la cible. Cette valeur est retirÃ© en dernier sur les degats (aprÃ©s avoir Ã©ventuellement doublÃ© les dÃ©gats si critique etc...).\n\n<br><br><hr><br><strong>Mana </strong> : Il s'agit de la ressource utilisÃ©e pour lancer des sorts. Hors combat, il revient automatiquement au maximum aprÃ©s plus d'une heure sans Ãªtre en combat. En combat, il est consommÃ© aprÃ©s le lancement de chaque sort (le coÃ»t en mana Ã©tant indiquÃ© dans la description de chaque sort). Si un sort devait faire passer le mana d'un hÃ©ros en dessous de 0, alors le sort n'est pas effectif et le hÃ©ros devient <span class=\"etat-link\" data-etat=\"Endormi/assomÃ©/EffrayÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">paralysÃ©</span> pendant 2 tours.\n\n<br><br><hr><br><strong>Vie </strong> : Les points de vie reprÃ©sentent la vitalitÃ© dâ€™un hÃ©ros ou dâ€™un monstre, la mesure de son endurance face aux blessures. Tant quâ€™il lui reste des PV, le personnage peut continuer Ã  se battre, Ã  courir et Ã  agir. Quand ses PV tombent Ã  zÃ©ro, il sâ€™effondre, mourant. Voir la page <a href=\"#/combat\" style=\"color: var(--accent); text-decoration: underline;\">Combat</a>.\nUn personnage qui effectue un repos rÃ©gÃ©nÃ¨re un nombre de points de vie Ã©gal Ã  sa valeur dâ€™Endurance.<br>\n\n<hr><br><strong>Fortune</strong> : Lorsquâ€™un Ã©vÃ©nement fait appel Ã  la Fortune (par exemple ouvrir un coffre et espÃ©rer y trouver un objet rare), le joueur lance un d20 et ajoute sa valeur de Fortune. Plus le total est Ã©levÃ©, meilleur sera le butin obtenu. \n\n<br><hr><br> <strong>Initiative</strong> : Cette valeur est comparÃ©e au dÃ©but du combat avec tous les hÃ©ros/monstres pour determiner l'ordre des tours de combat. Plus la valeur est Ã©levÃ©e, plus le hÃ©ros commence en premier.\n\n\n<br><hr><br> <strong>Taille </strong> : DÃ©termine la taille dâ€™une crÃ©ature. Certains effets ne fonctionnent que sur certaines tailles :\n<ul>\n  <li><b>Petit</b> : 1 mÃ¨tre ou moins</li>\n  <li><b>Moyen</b> : moins de 2 mÃ¨tres</li>\n  <li><b>Grand</b> : moins de 3,5 mÃ¨tres</li>\n  <li><b>GÃ©ant</b> : plus de 3,5 mÃ¨tres</li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'competences-tests': {
  "page": "competences-tests",
  "title": "CompÃ©tences & Tests",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "grid",
      "cols": 2,
      "content": [
        {
          "type": "card",
          "id": "efforts",
          "title": "Efforts",
          "content": "<ul><li>Chaque hÃ©ros dispose de 3 Efforts maximum.</li><li>Les hÃ©ros rÃ©cupÃ¨rent des efforts lors de repos courts ou longs.</li><li>Les Efforts peuvent Ãªtre dÃ©pensÃ©s pour amÃ©liorer un test de compÃ©tence.</li></ul>",
          "deletable": true,
          "sectionName": "Efforts"
        },
        {
          "type": "card",
          "id": "competences-list",
          "title": "CompÃ©tences",
          "content": "<ul><li><em>Hardiesse</em>: Pousser, casser, sauterâ€¦</li><li><em>Finesse</em>: Crocheter, fabriquer, Ãªtre discretâ€¦</li><li><em>Coordination</em>: Percevoir, Ã©quilibre, piloterâ€¦</li><li><em>RÃ©flexion</em>: Savoir, comprendre, devinerâ€¦</li><li><em>Ã‰loquence</em>: Persuader, mentir, intimiderâ€¦</li></ul>",
          "deletable": true,
          "sectionName": "CompÃ©tences"
        }
      ]
    },
    {
      "type": "card",
      "id": "tests",
      "title": "Tests de compÃ©tences",
      "content": "<p>Quand un MJ annonce un test de compÃ©tence, un hÃ©ros peut choisir de dÃ©penser des efforts pour booster sa compÃ©tence. La difficultÃ© d'un test est seule connue du MJ, et est entre 1 et 5 (Exigeant, Complexe , Ã‰prouvant, Prodigieux , <strong>Impossible</strong>).</p><p>Une fois le test rÃ©solu, le MaÃ®tre de Jeu annonce le rÃ©sultat. Si le joueur a dÃ©pensÃ© plus d'Efforts que nÃ©cessaire, l'excÃ©dent est perdu.</p><br> A noter que certaines actions sont impossibles Ã  rÃ©aliser et un hÃ©ros peut alors s'Ã©puiser pour rien, s'il n'a pas bien Ã©valuÃ© la difficultÃ© de la tÃ¢che. A l'inverse, les tÃ¢ches simples ne demandent pas de test de compÃ©tences.",
      "deletable": true,
      "sectionName": "Tests de compÃ©tences"
    }
  ]
},
      'etats': {
  "page": "etats",
  "title": "Etats",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "Lorsque un joueur subit un Ã©tat, vous pouvez prendre une carte ou note pour avoir un rappel de l'effet. De plus, si c'est un Ã©tat Ã  durÃ©e limitÃ©, vous pouvez prendre un dÃ© et le placer face au nombre de tour restant (en oubliant pas de changer sa valeur chaque dÃ©but de tour).<br> Quand vous infligez des effets/alterations Ã  un monstre, vous pouvez Ã©galement utiliser un dÃ© pour rappel (potentiellement d'une autre couleur, pour aider).\n<br>"
    },
    {
      "type": "card",
      "id": "a-terre",
      "title": "A terre",
      "content": "<p>Ne peut plus faire d'actions.</p><p> Ne peut plus esquiver.</p><p> Doit dÃ©penser une action secondaire pour se relever.</p>",
      "deletable": true,
      "sectionName": "A terre"
    },
    {
      "type": "card",
      "id": "endormi-effraye",
      "title": "Endormi/assomÃ©/EffrayÃ©",
      "content": "<p>Ne peut plus faire d'actions.</p><p> Ne peut plus esquiver.</p><p> Des dÃ©gats infligÃ©s Ã  la crÃ©ature la sort de son Ã©tat.</p>",
      "deletable": true,
      "sectionName": "Endormi/assomÃ©/EffrayÃ©"
    },
    {
      "type": "card",
      "id": "etats-new-4-1755725440741",
      "title": "Ralenti",
      "content": "Vitesse de dÃ©placement rÃ©duite de 6m.<br> Impossible de sauter ou d'esquiver.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-5-1755762657383",
      "title": "EmpoisonnÃ©",
      "content": "Des dÃ©gats sont appliquÃ©s Ã  chaque dÃ©but de tour, rÃ©duits ni par l'armure physique ni par l'armure Ã©lÃ©mentaire.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-6-1755762796465",
      "title": "EntravÃ©/EntoilÃ©/EmbourbÃ©",
      "content": "<p>Ne peut plus faire d'actions.</p><p>Ne peut plus esquiver.</p> Le hÃ©ros ou un alliÃ© peut sortir le hÃ©ros de l'Ã©tat via un test de compÃ©tence hardiesse.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-7-1755762977439",
      "title": "Affaibli",
      "content": "Les dÃ©gats physiques effectuÃ©s sont rÃ©duits de moitiÃ©s. Les tests de hardiesse ont une difficultÃ© de 2 plus Ã©levÃ©s.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-para-8-1755891140510",
      "title": "Silence",
      "content": "Incapable de lancer des sorts.",
      "deletable": true,
      "sectionName": "Nouveau paragraphe"
    },
    {
      "type": "card",
      "id": "etats-new-9-1756400691334",
      "title": "VulnÃ©rable",
      "content": "Plus aucune protection apportÃ© par l'armure physique ou Ã©lÃ©mentaire.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-10-1756400890785",
      "title": "Confus",
      "content": "A chaque dÃ©but de tour, lancez un d20. si le resultat est de 10 ou moins, passe sont tour Ã  se dÃ©placer et attaquer au corp Ã  corp la cible la plus proche.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-11-1756401053782",
      "title": "Maudit",
      "content": "Impossible d'effectuer des coups critiques (physiques ou magiques), et la resistance altÃ©ration est divisÃ© par 2.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-12-1756401063266",
      "title": "DÃ©bilitÃ©",
      "content": "La cible est incpable d'effectuer la moindre action ou d'esquiver. A chaque dÃ©but de tour, elle perd des points de vie, rÃ©duits ni par l'armure physique ni par l'armure Ã©lÃ©mentaire.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-13-1756408622987",
      "title": "FatiguÃ©",
      "content": "Incapable d'utiliser des efforts. CoÃ»t en mana des sorts doublÃ©s. DÃ©gats physiques infligÃ©s rÃ©duits de moitiÃ©.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-14-1756637917339",
      "title": "AveuglÃ©",
      "content": "Toutes les attaques et sorts ont une portÃ©e maximum de 3m. Incapable d'esquiver.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'combat': {
  "page": "combat",
  "title": "Combat",
  "sections": [
    {
      "type": "intro",
      "content": "Lorsqu'un combat commence, on compare l'Initiative de tous les participants (hÃ©ros et monstres), et on dÃ©termine alors un ordre de tour. Celui qui a la plus grande initiative commence, puis c'est au tour du second avec la plus grande initiative , etc...\n\n<br><br>Chaque participant joue son tour (dÃ©placement et actions), puis on passe au suivant. Lorsque tous les monstres ou tous les hÃ©ros sont morts ou hors d'Ã©tat de se battre, le combat s'arrÃ¨te."
    },
    {
      "type": "card",
      "id": "combat-new-2-1756401371776",
      "title": "DÃ©placement",
      "content": "Ã€ chaque tour, un hÃ©ros peut se dÃ©placer de 9 mÃ¨tres (plus sâ€™il bÃ©nÃ©ficie de bonus), en plus de ses actions.\n<br><br>Certains terrains, comme la boue ou le sable, sont considÃ©rÃ©s comme des terrains difficiles : la vitesse y est alors rÃ©duite de moitiÃ©.\n<br><br>Un hÃ©ros ou un monstre ne peut pas traverser un adversaire occupant une largeur de 3 mÃ¨tres. Si plusieurs ennemis se tiennent cÃ´te Ã  cÃ´te, ils forment un vÃ©ritable mur infranchissable.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-3-1756401384086",
      "title": "Actions",
      "content": "Chaque tour, un hÃ©ros dispose d'une <b>action principale</b>, pour effectuer une attaque physique ou un sort.\nElle est perdue si elle n'est pas utilisÃ© pendant son tour. Elle permet Ã©galement de faire toute action qui nÃ©cÃ©ssite un test de compÃ©tence (ouvrir une porte, casser un rocher...).\n\n<br><br>Il dispose Ã©galement d'une <b>action secondaire</b>, qui permet de faire un certains nombre de choses :\n<br>- Sauter.\n<br>- Utiliser un objet.\n<br>- Changer d'arme.\n<br>Certains dons ou abilitÃ©s permettent Ã©galement d'effectuer d'autres choses en utilisant l'action secondaire.\n\n<br><br> Les hÃ©ros peuvent effectuer leur dÃ©placement, action principale et secondaire dans l'ordre qui leur plait.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-4-1756401409186",
      "title": "Attaques, sorts, armure",
      "content": "<b>Attaque physique</b>\n\n<ul>\n  <li>Il faut Ãªtre Ã  bonne portÃ©e (1,5 m pour une arme de mÃªlÃ©e, ou selon la portÃ©e indiquÃ©e sur lâ€™arme).</li>\n  <li>Il faut effectuer un saut pour toucher un monstre volant.</li>\n</ul>\n\n<p>\nEnsuite lâ€™attaquant lance un <b>d20</b> :\n</p>\n\n<ul>\n  <li>Si le rÃ©sultat est â‰¤ <b>(1 + Esquive)</b> du dÃ©fenseur, lâ€™attaque rate.</li>\n  <li>Si le rÃ©sultat est â‰¥ <b>(20 - Chance de Critique)</b> de lâ€™attaquant, lâ€™attaque est un <b>coup critique</b> et les dÃ©gÃ¢ts physiques sont doublÃ©s.</li>\n</ul>\n\n<p>\nSi des <b>dÃ©gÃ¢ts Ã©lÃ©mentaires</b> sont rattachÃ©s Ã  lâ€™arme (via sort, objet ou autre), ils ne sont critiques que si lâ€™Ã©lÃ©ment de lâ€™attaque est opposÃ© Ã  lâ€™Ã©lÃ©ment dâ€™affiliation de la cible.\n</p>\n\n<p>\nSi lâ€™attaque rÃ©ussit :\n</p>\n<ul>\n  <li>On soustrait lâ€™armure physique aux dÃ©gÃ¢ts physiques, puis on retire ce total aux points de vie du dÃ©fenseur.</li>\n  <li>On fait de mÃªme avec les dÃ©gÃ¢ts Ã©lÃ©mentaires en utilisant lâ€™armure Ã©lÃ©mentaire correspondante.</li>\n</ul>\n\n<hr>\n\n<br><b>Lancer un sort</b>\n\n<ul>\n  <li>Le lanceur doit Ãªtre Ã  portÃ©e de la cible.</li>\n  <li>Le lanceur dÃ©pense le mana en fonction du coÃ»t du sort. S'il passe en dessous de 0, le sort Ã©choue et le lanceur devient <span class=\"etat-link\" data-etat=\"Endormi/assomÃ©/EffrayÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">ParalysÃ©</span> pendant 2 tours.</li>\n</ul>\n\n<p>\nEnsuite le lanceur lance un <b>d20</b> :\n</p>\n\n<ul>\n  <li>Si le rÃ©sultat est â‰¤ 1, le sort Ã©choue.</li>\n  <li>Si le rÃ©sultat est â‰¥ <b>(20 - Chance de Critique des sorts)</b> du lanceur, lâ€™effet du sort sera <b>critique</b> (sâ€™il rÃ©ussit).</li>\n</ul>\n\n<b>Cas Â« Sans effet si Â» :</b>\n<br>Chaque sort indique sans sa decription dans quels cas le sort peut Ã©chouer.\n<ul>\n  <li>Sâ€™il est annulÃ© en cas dâ€™esquive, on vÃ©rifie si le rÃ©sultat du dÃ© est â‰¤ <b>(1 + Esquive)</b> du dÃ©fenseur.</li>\n  <li>Sâ€™il nâ€™affecte pas certaines crÃ©atures en fonction de leur Ã©lÃ©ment dâ€™assignation, le MJ indiquera si le sort est sans effet.</li>\n  <li>Sâ€™il sâ€™agit dâ€™un sort dâ€™altÃ©ration magique, on compare lâ€™<b>Intelligence</b> du lanceur avec la <b>RÃ©sistance Ã  lâ€™altÃ©ration</b> du dÃ©fenseur : si elle nâ€™est pas strictement supÃ©rieure, le sort est sans effet.</li>\n</ul>\n\n<p>\nSi aucun des cas Â« Sans effet si Â» ne sâ€™applique, on rÃ©sout le sort :\n</p>\n\n<ul>\n  <li>Si lâ€™Ã©lÃ©ment du sort est opposÃ© Ã  lâ€™affiliation de la cible, lâ€™effet est <b>forcÃ©ment critique</b>.</li>\n  <li>Son effet est appliquÃ© (en cas d'effet critique, la description du sort indique les effets).</li>\n  <li>Si le sort inflige des dÃ©gÃ¢ts Ã©lÃ©mentaires, on soustrait lâ€™armure Ã©lÃ©mentaire correspondante.</li>\n  <li>Si le sort inflige une altÃ©ration, on place un dÃ© indiquant le nombre de tours restants.</li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-5-1756401438556",
      "title": "Coup critique et esquive",
      "content": "<hr><br><br><strong>Chance de coup critique (physique) </strong> : Lors d'une attaque physique, le lanceur de l'attaque lance un d20. S'il fait 20, alors les dÃ©gats physiques (et seulement physiques) sont doublÃ©s.<br> Augmenter les chances de coup critique rÃ©duit la valeur du dÃ© nÃ©cÃ©ssaire pour faire un critique. Par exemple, avec 3 de chance de coup critique, si le dÃ© fait de 17 Ã  20, l'attaque est critique.\n\n<br><br><hr><br><strong>Chance de coup critique (sorts et consommables)</strong> : Lorsque un hÃ©ros ou un monstre lance un sort ou utilise un consommable, il lance un d20. S'il fait 20, alors le sort est critique, chaque sort/consommable ayant un effet critique diffÃ©rent (indiquÃ© dans sa description).<br> Augmenter les chances de coup critique des sorts et consommables rÃ©duit la valeur du dÃ© nÃ©cÃ©ssaire pour faire un critique. Par exemple, avec 3 de chance de coup critique, si le dÃ© fait de 17 Ã  20, le resultat est critique. \n\n<br><br><hr><br><strong>Esquive </strong> : Lors d'une attaque physique, ou d'un sort sans effet si esquive (indiquÃ© dans la fiche du sort), lorsque le lanceur lance son d20, si le resultat est 1, l'attaque est sans effet. Avoir de l'esquive pour la cible de l'attaque augmente la valeur du dÃ© jusqu'a laquelle l'attaque Ã©choue. Par exemple, avec 3 d'esquive, si le dÃ© fait 4 ou moins, l'attaque Ã©choue. La valeur d'esquive ne peut jamais dÃ©passer 9, quel que soit l'equipement ou bonus d'un joueur ou monstre.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-6-1756401461053",
      "title": "Mort",
      "content": "<p>\nLorsque les <b>points de vie</b> dâ€™un hÃ©ros passent sous la barre des 0, il devient <b>inconscient</b> jusquâ€™Ã  la fin du combat. \nAprÃ¨s le combat, si un alliÃ© le soigne (via objet ou sort), il redevient capable dâ€™agir. \nCependant, il gagne <b>un trauma</b>, reprÃ©sentant un handicap dÃ©finitif en fonction de ce qui lâ€™a abattu. \nAu bout du <b>troisiÃ¨me trauma</b>, le hÃ©ros <b>meurt dÃ©finitivement</b>.\n</p>\n\n<p>\nLe joueur devra alors crÃ©er un nouveau personnage.  \nIl se murmure que certaines <b>magies trÃ¨s puissantes</b> sont capables de ressusciter un hÃ©ros mort, Ã  condition quâ€™elles soient pratiquÃ©es rapidement aprÃ¨s le dÃ©cÃ¨s.\n</p>\n\n<p>\n<b>Exemples de traumas</b>\n</p>\n<ul>\n  <li><b>Cicatrice profonde</b> : â€“1 en compÃ©tence Ã‰loquence.</li>\n  <li><b>AmnÃ©sie partielle</b> : Oubli dâ€™un sort, dâ€™une langue ou dâ€™une compÃ©tence.</li>\n  <li><b>Claudication</b> : Vitesse de dÃ©placement rÃ©duite de 3 m.</li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-7-1756407955417",
      "title": "Incantation sur plusieurs tours",
      "content": "Certains sorts ont un effet qui dure plusieurs tours.\n<br> Dans ce cas, le dÃ© qui determine si l'effet est critique doit Ãªtre relancÃ© Ã  chaque tour (l'effet \"critique\" d'un sort ne dure qu'un seul tour).<br>  <br>\n\n<hr>\n\n<br>Certains sorts puissants nÃ©cÃ©ssitent plusieurs tours d'incantation.\n\n<br><br>AprÃ©s avoir commencÃ© une incantation, aucun dÃ©placement/action n'est possible. Les effets du sort sont effectuÃ©s au dernier tour de l'incantation, tour oÃ¹ la crÃ©ature pourra de nouveau effectuer des actions/dÃ©placement.\n<br> Les dÃ©gÃ¢ts subis nâ€™interrompent pas lâ€™incantation, sauf en cas de mort ou dâ€™effet empechant d'effectuer des actions (exemple : <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span>).\n<br><hr>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-8-1756926911533",
      "title": "Combat - Hors combat",
      "content": "<p><b>Hors combat</b></p>\n<p>Par dÃ©faut, les hÃ©ros sont hors combat. Ils agissent librement : discuter, se dÃ©placer, manger des rations, changer dâ€™Ã©quipement, etc.</p>\n\n<p><b>DÃ©clenchement dâ€™un combat</b></p>\n<p>Quand un affrontement commence, on passe en mode <b>tour par tour</b>. Certaines actions deviennent alors interdites :</p>\n<ul>\n  <li>Changer dâ€™Ã©quipement (armures, accessoires).</li>\n  <li>Utiliser des objets <i>non consommables</i> comme de la nourriture.</li>\n  <li>Effectuer des actions longues (Ã  lâ€™apprÃ©ciation du MJ).</li>\n</ul>\n<p>Le mode tour par tour sâ€™arrÃªte lorsque le dernier adversaire est neutralisÃ©.</p>\n\n<p><b>AprÃ¨s-combat (10 minutes)</b></p>\n<p>Ã€ la fin dâ€™un combat, les hÃ©ros restent sous tension pendant <b>10 minutes</b> : ils ne sont pas encore considÃ©rÃ©s comme hors combat.</p>\n<ul>\n  <li>Ils ne regagnent pas encore leur mana.</li>\n  <li>Manger, dormir ou entreprendre des activitÃ©s longues reste impossible.</li>\n  <li>Les effets Â« en combat Â» sâ€™estompent selon leur durÃ©e.</li>\n  <li>Les hÃ©ros peuvent parler librement, utiliser leur mana restant et faire toute autre activitÃ© rapide.</li>\n</ul>\n\n<p><b>Retour hors combat</b></p>\n<p>Une fois ces 10 minutes Ã©coulÃ©es, les hÃ©ros redeviennent hors combat : ils <b>rÃ©cupÃ¨rent tout leur mana</b>, peuvent manger et dormir. Les <b>sorts/effets rÃ©servÃ©s au combat</b> deviennent alors indisponibles (notamment certains sorts de soins).</p>\n\n<p><b>Note sur les soins</b></p>\n<p>La plupart des blessures se soignent plus difficilement une fois lâ€™adrÃ©naline retombÃ©e : de nombreux effets de soin ne sont donc plus utilisables hors combat.</p>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'gestion-des-ressources': {
  "page": "gestion-des-ressources",
  "title": "Gestion des ressources",
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-2-1756401478745",
      "title": "Inventaire",
      "content": "<p>Chaque hÃ©ros dispose de <b>quatre inventaires</b> :</p>\n\n<ul>\n  <li>\n    <b>Ã‰quipement</b> : Toujours portÃ© et actif, il est constituÃ© dâ€™une arme, dâ€™une armure, \n    dâ€™un Ã©ventuel bouclier et de <b>3 accessoires</b>.\n  </li>\n  <li>\n    <b>Sac de consommables</b> : Peut contenir jusquâ€™Ã  <b>10 consommables</b>. MÃªme si un hÃ©ro possÃ¨de plusieur fois le mÃªme consommable, ils prendront chacun une place.\n  </li>\n  <li>\n    <b>Sac gÃ©nÃ©ral</b> : Dispose dâ€™une capacitÃ© maximale de <b>10 points de poids</b>. \n    Chaque objet entreposÃ© y possÃ¨de une valeur de poids indiquÃ©e dans sa description.\n  </li>\n <li>\n    <b>Objets de quÃªte</b> : Aucune limite pour ces objets, utiles pour l'aventure (clÃ©s, cartes...).\n  </li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-3-1756401493443",
      "title": "Mana",
      "content": "Il s'agit de la ressource utilisÃ©e pour lancer des sorts. Hors combat, il revient automatiquement quand le hÃ©ros passe hors combat (c'est Ã  dire aprÃ©s 10 minutes sans Ãªtre en combat). En combat, il est consommÃ© aprÃ©s le lancement de chaque sort (le coÃ»t en mana Ã©tant indiquÃ© dans la description de chaque sort). Si un sort devait faire passer le mana d'un hÃ©ros en dessous de 0, alors le sort n'est pas effectif et le hÃ©ros devient <span class=\"etat-link\" data-etat=\"Endormi/assomÃ©/EffrayÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">paralysÃ©</span> pendant 2 tours.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-4-1756401498518",
      "title": "Vie",
      "content": "Les points de vie reprÃ©sentent la vitalitÃ© dâ€™un hÃ©ros ou dâ€™un monstre, la mesure de son endurance face aux blessures. Tant quâ€™il lui reste des PV, le personnage peut continuer Ã  se battre, Ã  courir et Ã  agir. Quand ses PV tombent Ã  zÃ©ro, il sâ€™effondre, mourant. Voir la page <a href=\"#/combat\" style=\"color: var(--accent); text-decoration: underline;\">Combat</a>.\nUn personnage qui effectue un repos rÃ©gÃ©nÃ¨re un nombre de points de vie Ã©gal Ã  sa valeur dâ€™Endurance.<br>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-5-1756401504961",
      "title": "Fortune",
      "content": "Lorsquâ€™un Ã©vÃ©nement fait appel Ã  la Fortune (par exemple ouvrir un coffre et espÃ©rer y trouver un objet rare), le joueur lance un d20 et ajoute sa valeur de Fortune. Plus le total est Ã©levÃ©, meilleur sera le butin obtenu.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-7-1756408519770",
      "title": "Sommeil et repas",
      "content": "Chaque jour, un hÃ©ros doit manger une ration et dormir au moins 8 heures sous peine d'Ãªtre dans l'Ã©tat <span class=\"etat-link\" data-etat=\"FatiguÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">FatiguÃ©</span>.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-7-1756634178476",
      "title": "Experience et niveau",
      "content": "<p>Lorsquâ€™un groupe trouve et utilise un <b>cristal dâ€™expÃ©rience</b>, tous les membres du groupe <b>gagnent</b> des points dâ€™expÃ©rience.</p>\n<p>Les <b>cristaux dâ€™expÃ©rience</b> provenant dâ€™un mÃªme type de monstre sont de moins en moins efficaces, car la magie quâ€™ils renferment a dÃ©jÃ  Ã©tÃ© assimilÃ©e.</p>\n\n\n<p>Lorsquâ€™un hÃ©ros atteint <b>10 points dâ€™expÃ©rience</b>, il gagne un niveau et son expÃ©rience revient Ã  <b>0</b>. Il obtient alors :</p>\n<ul>\n  <li><b>1 point de don</b> (quâ€™il peut dÃ©penser ou cumuler).</li>\n  <li>Des <b>statistiques fixes</b> (selon la sous-classe).</li>\n  <li><b>2 points de statistiques</b> Ã  rÃ©partir.</li>\n  <li>Lâ€™<b>accÃ¨s Ã  de nouveaux sorts</b> (pour les classes qui le peuvent).</li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-8-1756658008017",
      "title": "Equipements",
      "content": "<li>Que l'on porte une arme Ã  une main ou Ã  deux mains, il est uniquement possible d'Ãªtre Ã©quipÃ© d'une seule arme.\n</li><li>Lorsque on porte une arme Ã  deux mains, il est impossible de porter un bouclier.\n</li><li>Il est possible via une action secondaire de changer l'arme active en plein combat, mais pas l'armure ou les accessoires, qui ne peuvent Ãªtre changÃ©s que hors combat.</li>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'histoire': {
  "page": "histoire",
  "title": "Histoire",
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "ere-legendaire",
      "title": "",
      "content": "<b>Foresia, royaume ancien aux mille visages</b><br>\nDans les terres de <b>Foresia</b>, un royaume ancien aux mille visages, la <b>magie</b> imprÃ¨gne chaque pierre et chaque souffle de vent. \nForÃªts luminescentes, volcans grondants, temples enfouis et ruines cyclopÃ©ennes rappellent que les dieux et les anciens peuples ont marquÃ© cette terre de leur puissance.\n\n<br><br><b>La rÃ©gion de Mabresia</b><br>\nAu cÅ“ur de ce royaume sâ€™Ã©tend la rÃ©gion de <b>Mabresia</b>, autrefois fertile et paisible, oÃ¹ se dressaient des citÃ©s marchandes prospÃ¨res et des villages agricoles nourris par des riviÃ¨res cristallines.\n\n<br><br><b>La malÃ©diction des cristaux</b><br>\nMais depuis quelques dÃ©cennies, un mal mystÃ©rieux sâ€™est abattu sur la contrÃ©e. \nDes <b>cristaux magiques</b> surgis des profondeurs de la terre altÃ¨rent la nature et les Ãªtres vivants : animaux, monstres, et mÃªme parfois les races intelligentes. \nCes cristaux provoquent des <b>mutations</b> et une <b>soif de violence</b> incontrÃ´lable.\n\n<br><br><b>Peuples et tensions</b><br>\nLes habitants de Foresia â€” <b>humains</b>, <b>elfes</b>, <b>nains</b>, mais aussi des crÃ©atures plus sombres comme <b>dÃ©mons</b> et <b>morts-vivants</b> â€” vivent dÃ©sormais dans une tension permanente, oscillant entre alliances fragiles et guerres ouvertes. \nChacun cherche Ã  <b>exploiter</b> ou <b>dÃ©truire</b> ces cristaux, selon ses croyances et ambitions.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "chronologie",
      "title": "ğŸ“… Chronologie",
      "content": "<b>Il y a 300 ans</b> â€“ Lâ€™Empire des Anciens, peuple oubliÃ©, Ã©rige dâ€™immenses temples et scelle dans leurs fondations des secrets de magie que nul ne comprendra jamais entiÃ¨rement.<br><br>\n\n<b>Il y a 200 ans</b> â€“ Chute de lâ€™Empire : guerres entre dieux mineurs et rois mortels. Les temples sont abandonnÃ©s, et les ruines se couvrent de vÃ©gÃ©tation.<br><br>\n\n<b>Il y a 80 ans</b> â€“ Premiers rÃ©cits dâ€™Ã©tranges cristaux luminescents dÃ©couverts dans les montagnes de Mabresia. Au dÃ©but considÃ©rÃ©s comme bÃ©nÃ©dictions, certains se rÃ©vÃ¨lent instables.<br><br>\n\n<b>Il y a 50 ans</b> â€“ Des bÃªtes sauvages commencent Ã  muter et deviennent plus fÃ©roces. Les premiers villages sont dÃ©truits par des crÃ©atures altÃ©rÃ©es.<br><br>\n\n<b>Il y a 30 ans</b> â€“ Les cristaux se rÃ©pandent : on les retrouve dans les forÃªts, les marÃ©cages et mÃªme les ruines anciennes. De plus en plus de crÃ©atures sont transformÃ©es.<br><br>\n\n<b>Il y a 20 ans</b> â€“ Les premiÃ¨res guerres Ã©clatent entre royaumes frontaliers : certains veulent sâ€™emparer des cristaux comme armes, dâ€™autres cherchent Ã  les dÃ©truire.<br><br>\n\n<b>Aujourdâ€™hui</b> â€“ La rÃ©gion de Mabresia est devenue une terre sauvage, oÃ¹ nul nâ€™est Ã  lâ€™abri : les routes sont envahies de crÃ©atures mutÃ©es, les villages se fortifient, et des aventuriers de tous horizons sâ€™y aventurent Ã  la recherche de gloire, de savoirâ€¦ ou de pouvoir.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'dieux': {
  "page": "dieux",
  "title": "Dieux",
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "dieux-new-2-1756899335313",
      "title": "Dieu des Humains â€“ Aedor, le Forgeron-Soleil",
      "content": "Symbole : un marteau aurÃ©olÃ© dâ€™un disque solaire.<br>\nDomaine : courage, guerre juste, travail artisanal.<br>\nCroyances : les humains voient en lui celui qui Ã©claire leur chemin et leur donne la force de bÃ¢tir des citÃ©s.<br>\nParticularitÃ© : ses prÃªtres prÃ´nent la discipline et la reconstruction, mais certains royaumes lâ€™utilisent aussi pour justifier leurs conquÃªtes.<br><br>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "dieux-para-3-1756899336921",
      "title": "Dieu des Nains â€“ Durnak, le CÅ“ur-de-Pierre",
      "content": "Symbole : une enclume fissurÃ©e dâ€™oÃ¹ sâ€™Ã©coule une lueur rouge.<br>\nDomaine : terre, montagne, persÃ©vÃ©rance, serments.<br>\nCroyances : gardien des mines et des profondeurs, il protÃ¨ge les clans nains et punit sÃ©vÃ¨rement ceux qui trahissent leur parole.<br>\nParticularitÃ© : les nains affirment que ses battements rÃ©sonnent dans les montagnes, guidant les mineurs vers les mÃ©taux rares.<br><br>",
      "deletable": true,
      "sectionName": "Nouveau paragraphe"
    },
    {
      "type": "card",
      "id": "dieux-new-4-1756899338873",
      "title": "DÃ©esse des Elfes â€“ Liryel, la Dame des Brumes",
      "content": "Symbole : une feuille argentÃ©e flottant sur lâ€™eau.<br>\nDomaine : forÃªts, magie ancienne, mÃ©moire.<br>\nCroyances : les elfes la vÃ©nÃ¨rent comme gardienne du cycle de la vie et de la magie pure.<br>\nParticularitÃ© : ses temples sont souvent des clairiÃ¨res protÃ©gÃ©es par des enchantements, oÃ¹ les brumes recouvrent les intrus.<br><br>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "dieux-new-5-1756899431837",
      "title": "Dieu des FÃ©es et des Lutins â€“ Myrin, lâ€™Ã‰clat-Changeant",
      "content": "Symbole : une luciole ou une Ã©toile facÃ©tieuse Ã  cinq branches.<br>\nDomaine : illusions, rÃªves, joie, malice.<br>\nCroyances : les fÃ©es et lutins croient quâ€™il danse entre les mondes, semant Ã  la fois la protection et la farce.<br>\nParticularitÃ© : ses fidÃ¨les accordent beaucoup dâ€™importance aux fÃªtes, Ã  la musique et aux pactes imprÃ©visibles.<br><br>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'geographie': {
  "page": "geographie",
  "title": "Geographie",
  "sections": [
    {
      "type": "intro",
      "content": "Voici la carte de la rÃ©gion de Mabresia, dans le Royaume de Foresia"
    }
  ]
},
      'campagne': {
  "id": "campagne",
  "title": "Campagne",
  "icon": "ğŸ“–",
  "sections": [
    {
      "type": "intro",
      "content": "<strong>ğŸ­ Espace Campagne</strong><br>CrÃ©ez et gÃ©rez vos campagnes avec leurs sous-pages personnalisÃ©es. Cette section est uniquement visible en mode MaÃ®tre de Jeu."
    },
    {
      "type": "campaign-manager",
      "content": {
        "title": "Gestionnaire de Campagnes",
        "campaigns": {}
      }
    }
  ],
  "subPages": {
    "Classique": {
      "name": "Classique",
      "description": "",
      "subPages": {
        "Long terme": {
          "title": "Long terme",
          "content": "<b> Le Dieu MalÃ©fique</b>\n\n<br><br>Nerhaz, le SÃ©pulcral (Symbole : un cristal noir fendu, entourÃ© de chaÃ®nes)\n\n\n<br><br> Histoire : banni par lâ€™Empire des Anciens, il fut scellÃ© dans leurs temples. Mais les cristaux magiques, instables, ont servi de rÃ©ceptacles Ã  ses murmures.\n\n<br><br>ParticularitÃ© : Nerhaz attire les ambitieux et les dÃ©sespÃ©rÃ©s, promettant pouvoir en Ã©change de sacrifices. Son retour progressif est liÃ© Ã  lâ€™altÃ©ration des crÃ©atures par les cristaux."
        },
        "Auberge": {
          "title": "Auberge",
          "content": "<hr>\nAvant de partir la femme de l'aubergiste qui a entendu les hÃ©ros, leur propose de piocher dans le sac a provision, mais leur demande de n'en prendre que un par personne maximum. Table de loot <i>ProvisionAuberge</i> <a href=\"#/tables-tresors\" style=\"color: var(--accent); text-decoration: underline;\">Tables de trÃ©sors</a>."
        },
        "ForÃªt": {
          "title": "ForÃªt",
          "content": "combat <span class=\"monster-link\" data-monster=\"Groink\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Groink</span>  <span class=\"monster-link\" data-monster=\"Groinka\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Groinka</span>\n<hr>\npierre a pousser pour reveler TP\nchemins diffÃ©rents avec un qui mene a pierre qui revele la puissance de chacun\n<hr>\nautre chemins avec platforme/pieges/ passage secret\nCombat groinks Ã©nervÃ©s + porte en metal\n<hr>\nport avec bateau pas dispo\nCombat <span class=\"monster-link\" data-monster=\"Crabe des Bois\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Crabe des Bois</span>   <span class=\"monster-link\" data-monster=\"Pouple de la forÃªt\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Pouple de la forÃªt</span>\n<hr>\n\nnuit attaque de  <span class=\"monster-link\" data-monster=\"AraignÃ©e GÃ©ante\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">AraignÃ©e GÃ©ante</span>\n<hr>\nriviere avec tronc , pont qui casse...\ncombat  <span class=\"monster-link\" data-monster=\"Serpent de la forÃªt\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Serpent de la forÃªt</span>  <span class=\"monster-link\" data-monster=\"ScarabÃ©e gÃ©ant\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">ScarabÃ©e gÃ©ant</span>  \n<hr>\nmaison bucheron avec jeu du tonneau, portes fermÃ©s mais loot bucheron \n<span class=\"monster-link\" data-monster=\"Ours des Bois\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Ours des Bois</span>   + <span class=\"monster-link\" data-monster=\"GuÃªpe GÃ©ante\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">GuÃªpe GÃ©ante</span>\n<hr>\nDialogue bucheron\ncombat  <span class=\"monster-link\" data-monster=\"Boss ForÃªt\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Boss ForÃªt</span>\n<hr>\nretourner camp bucheron, reveler tablette\nTP"
        }
      }
    }
  },
  "meta": {
    "requiresMJ": true,
    "allowSubPages": true,
    "lastModified": "2025-01-01T00:00:00.000Z"
  }
}
    };
    
    // Static pages configuration
    window.STATIC_PAGES_CONFIG = {
  "pages": [
    {
      "id": "favoris",
      "title": "Favoris",
      "file": "favoris.json",
      "active": true,
      "order": 0
    },
    {
      "id": "creation",
      "title": "CrÃ©ation d'un personnage",
      "file": "creation.json",
      "active": true,
      "order": 1
    },
    {
      "id": "elements",
      "title": "Elements",
      "file": "elements.json",
      "active": true,
      "order": 2
    },
    {
      "id": "stats",
      "title": "Statistiques",
      "file": "stats.json",
      "active": true,
      "order": 3
    },
    {
      "id": "competences-tests",
      "title": "CompÃ©tences & Tests",
      "file": "competences-tests.json",
      "active": true,
      "order": 4
    },
    {
      "id": "etats",
      "title": "Etats",
      "file": "etats.json",
      "active": true,
      "order": 5
    },
    {
      "id": "histoire",
      "title": "Histoire",
      "file": "histoire.json",
      "active": true,
      "order": 6
    },
    {
      "id": "combat",
      "title": "Combat",
      "file": "combat.json",
      "active": true,
      "order": 7
    },
    {
      "id": "gestion-des-ressources",
      "title": "Gestion des ressources",
      "file": "gestion-des-ressources.json",
      "active": true,
      "order": 8
    },
    {
      "id": "dieux",
      "title": "Dieux",
      "file": "dieux.json",
      "active": true,
      "order": 9
    },
    {
      "id": "geographie",
      "title": "Geographie",
      "file": "geographie.json",
      "active": true,
      "order": 10
    },
    {
      "id": "audio",
      "title": "Musiques d'ambiance",
      "file": "audio.json",
      "active": true,
      "order": 11
    },
    {
      "id": "traumas",
      "title": "Traumas",
      "file": "traumas.json",
      "active": true,
      "order": 12
    },
    {
      "id": "campagne",
      "title": "Campagne",
      "file": "campagne.json",
      "active": true,
      "order": 13,
      "requiresMJ": true
    }
  ],
  "template": {
    "page": "new-page",
    "title": "Nouvelle page",
    "static": true,
    "sections": [
      {
        "type": "intro",
        "content": "Contenu de la nouvelle page."
      }
    ]
  }
};
    
    // Mark as standalone version for renderer
    window.STANDALONE_VERSION = true;
    
    // Initialize app when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      // Ensure dev mode is off
      document.body.className = 'dev-off';
      
      // Initialize in standalone mode with embedded data
      
      // Wait a bit to ensure all modules are loaded
      setTimeout(function() {
        // Initialize JdrApp if it exists
        if (window.JdrApp && window.JdrApp.init) {
          window.JdrApp.init();
        } else {
          console.error('JdrApp not found!', window.JdrApp);
        }
      }, 100);
    });
  
// ============================================================================
// JDR-BAB APPLICATION - CORE MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // MAIN APPLICATION NAMESPACE
  // ========================================
  window.JdrApp = {
    // Core data
    data: {
      SORTS: null,
      CLASSES: null,
      DONS: null,
      OBJETS: null,
      MONSTRES: null,
      STATIC_PAGES: {},
      editedData: {},
      customPageDescriptions: {
        'collections-objets': 'Recherchez et explorez des collections d\'objets organisÃ©es par thÃ¨me'
      }
    },
    
    // Application state
    state: {
      isMJ: false // Boolean pour contrÃ´ler l'accÃ¨s MJ
    },
    
    // Core modules
    modules: {
      router: {},
      renderer: {},
      editor: {},
      storage: {},
      images: {}
    },
    
    // Utilities
    utils: {
      dom: {},
      events: {},
      data: {}
    },

    // Initialization
    async init() {
      try {
        this.updateLoadingProgress(10);
        await this.loadData();
        
        this.updateLoadingProgress(40);
        await this.loadContent();
        
        this.updateLoadingProgress(70);
        this.initializeModules();
        
        this.updateLoadingProgress(90);
        
        // Execute data validation after all modules are loaded
        setTimeout(() => {
          this.validateDataIntegrity();
          this.updateLoadingProgress(100);
          this.hideLoadingScreen();
        }, 500);
        
        // Auto-enable MJ mode with additional delay to ensure router is ready
        setTimeout(() => {
          this.autoEnableMJModeInDevelopment();
        }, 800);
      } catch (error) {
        this.hideLoadingScreen();
        // Silent error handling for initialization
      }
    },

    // Update loading progress
    updateLoadingProgress(percentage) {
      const progressBar = document.querySelector('.loading-bar');
      if (progressBar) {
        progressBar.style.width = `${percentage}%`;
      }
    },

    // Hide loading screen with animation
    hideLoadingScreen() {
      const loadingScreen = document.getElementById('app-loading');
      if (loadingScreen) {
        loadingScreen.classList.add('fade-out');
        setTimeout(() => {
          if (loadingScreen.parentNode) {
            loadingScreen.parentNode.removeChild(loadingScreen);
          }
        }, 500);
      }
    },

    async loadData() {
      try {
        // Check if we're in standalone mode (data already injected)
        if (window.SORTS && window.CLASSES && window.DONS && window.OBJETS && window.STATIC_PAGES) {
          const sorts = window.SORTS;
          const classes = window.CLASSES;
          const dons = window.DONS;
          const objets = window.OBJETS;
          let monstres = window.MONSTRES || [];
          let tablesTresors = window.TABLES_TRESORS || { tables: [] };
          let collections = window.COLLECTIONS || { collections: [] };
          
          // Safety check - if MONSTRES is not an array, it might be page config
          if (!Array.isArray(monstres)) {
            this.clearCorruptedMonsterData();
            monstres = [];
          }
          
          const staticPagesData = window.STATIC_PAGES;
          const staticPagesConfig = window.STATIC_PAGES_CONFIG || {};
          
          // Ensure custom page descriptions are available in standalone mode
          // In standalone mode, CUSTOM_PAGE_DESCRIPTIONS might be injected, sync with JdrApp.data
          if (window.CUSTOM_PAGE_DESCRIPTIONS) {
            this.data.customPageDescriptions = { ...this.data.customPageDescriptions, ...window.CUSTOM_PAGE_DESCRIPTIONS };
          } else {
            window.CUSTOM_PAGE_DESCRIPTIONS = { ...this.data.customPageDescriptions };
          }
          
          this.data.SORTS = sorts;
          this.data.CLASSES = classes;
          this.data.DONS = dons;
          this.data.OBJETS = objets;
          this.data.MONSTRES = monstres;
          this.data.TABLES_TRESORS = tablesTresors;
          this.data.COLLECTIONS = collections;
          this.data.STATIC_PAGES = staticPagesData;
          this.data.STATIC_PAGES_CONFIG = staticPagesConfig;
          
          window.SORTS = sorts;
          window.CLASSES = classes;
          window.DONS = dons;
          window.OBJETS = objets;
          window.MONSTRES = monstres;
          window.TABLES_TRESORS = tablesTresors;
          window.COLLECTIONS = collections;
          window.STATIC_PAGES = staticPagesData;
          window.STATIC_PAGES_CONFIG = staticPagesConfig;
          
          // Load stored edits AFTER setting up the data structure
          this.loadStoredEditsEarly();
          
          // Initialize default filters for objects
          this.initializeDefaultFilters();
          return;
        }
        
        // Development mode - fetch files
        const [sorts, classes, dons, objets, monstres, tablesTresors, collections, staticPagesConfig, tocStructure, audioConfig] = await Promise.all([
          fetch('data/sorts.json').then(r => r.json()),
          fetch('data/classes.json').then(r => r.json()),
          fetch('data/dons.json').then(r => r.json()),
          fetch('data/objets.json').then(r => r.json()),
          fetch('data/monstres.json').then(r => r.json()),
          fetch('data/tables-tresors.json').then(r => r.json()),
          fetch('data/collections.json').then(r => r.json()),
          fetch('data/static-pages-config.json').then(r => r.json()),
          fetch('data/toc-structure.json').then(r => r.json()),
          fetch('data/audio-config.json').then(r => r.json()).catch(() => null)
        ]);

        // Load page descriptions (optional, with fallbacks)
        try {
          window.MONSTRES_PAGE_DESC = await fetch('data/monstres-page-desc.json').then(r => r.json());
        } catch (error) {
          // Fallback if file doesn't exist
          window.MONSTRES_PAGE_DESC = {
            description: "CrÃ©atures, ennemis et adversaires que peuvent affronter les hÃ©ros dans leurs aventures."
          };
        }

        try {
          window.TABLES_TRESORS_PAGE_DESC = await fetch('data/tables-tresors-page-desc.json').then(r => r.json());
        } catch (error) {
          // Fallback if file doesn't exist
          window.TABLES_TRESORS_PAGE_DESC = {
            description: "Tables de butin permettant de gÃ©nÃ©rer alÃ©atoirement des rÃ©compenses selon les fourchettes dÃ©finies. Lancez un dÃ© 20 et consultez la table correspondante pour dÃ©terminer l'objet obtenu."
          };
        }

        // Load custom page descriptions (collections, etc.)
        try {
          const customDescriptions = await fetch('data/custom-page-descriptions.json').then(r => r.json());
          this.data.customPageDescriptions = { ...this.data.customPageDescriptions, ...customDescriptions };
          // Make it available globally for ContentFactory (keep in sync)
          window.CUSTOM_PAGE_DESCRIPTIONS = { ...this.data.customPageDescriptions };
        } catch (error) {
          // Keep default values if file doesn't exist
          window.CUSTOM_PAGE_DESCRIPTIONS = { ...this.data.customPageDescriptions };
        }

        const staticPagesData = {};
        const activePages = staticPagesConfig.pages.filter(page => page.active);
        
        for (const pageConfig of activePages) {
          try {
            const pageData = await fetch(`data/${pageConfig.file}`).then(r => r.json());
            staticPagesData[pageConfig.id] = pageData;
          } catch (error) {
            // Silent handling for missing static pages
          }
        }

        this.data.SORTS = sorts;
        this.data.CLASSES = classes;
        this.data.DONS = dons;
        this.data.OBJETS = objets;
        this.data.MONSTRES = monstres;
        this.data.TABLES_TRESORS = tablesTresors;
        this.data.COLLECTIONS = collections;
        this.data.STATIC_PAGES = staticPagesData;
        this.data.STATIC_PAGES_CONFIG = staticPagesConfig;
        this.data.AUDIO_CONFIG = audioConfig;
        this.data.TOC_STRUCTURE = tocStructure;

        window.SORTS = sorts;
        window.CLASSES = classes;
        window.DONS = dons;
        window.OBJETS = objets;
        window.MONSTRES = monstres;
        window.TABLES_TRESORS = tablesTresors;
        window.COLLECTIONS = collections;
        window.STATIC_PAGES = this.data.STATIC_PAGES;
        window.STATIC_PAGES_CONFIG = this.data.STATIC_PAGES_CONFIG;
        window.TOC_STRUCTURE = this.data.TOC_STRUCTURE;
        window.AUDIO_CONFIG = audioConfig;
        
        // Load stored edits in development mode (after data is loaded)
        this.loadStoredEditsEarly();
        
        // Initialize default filters for objects
        this.initializeDefaultFilters();
      } catch (error) {
        throw error;
      }
    },

    async loadContent() {
      try {
        // Check if we're in standalone mode (already has HTML structure)
        const viewsDiv = document.getElementById('views');
        const loadingDiv = document.getElementById('app-loading');
        
        if (viewsDiv) {
          // Standalone mode - HTML structure already exists
          if (loadingDiv) {
            loadingDiv.innerHTML = '<!-- Content will be generated by renderer -->';
          }
        } else if (loadingDiv) {
          // Development mode - need to inject HTML structure
          const contentHTML = await this.getContentHTML();
          loadingDiv.outerHTML = contentHTML;
        }
      } catch (error) {
        throw error;
      }
    },

    async getContentHTML() {
      // This would ideally load from a separate HTML file
      // For now, we'll return the content structure
      return `
        <div class="shell">
          <button aria-controls="sidebar" aria-expanded="false" aria-label="Ouvrir le sommaire" class="menu-toggle" id="menuToggle" style="display:none">â˜° Sommaire</button>
          <div class="backdrop" hidden="" id="backdrop"></div>
          <main class="page">
            <aside class="sidebar" id="sidebar">
              <div class="panel">
                <div class="tools">
                  <button class="btn small" id="devToggle" title="Activer/dÃ©sactiver le mode dÃ©veloppeur">ğŸ›  Dev Mode: OFF</button>
                </div>
                <div class="dev-toolbox" id="devToolbox" style="display: none;">
                  <!-- Dev toolbox content will be injected here -->
                </div>
                <div class="toc" id="toc">
                  <div class="toc-search">
                    <input autocomplete="off" id="search" placeholder="Rechercher une rÃ¨gle, une classeâ€¦">
                    <button class="btn-clear" id="clear" title="Effacer">âœ–</button>
                  </div>
                  <!-- Table of contents will be injected here -->
                </div>
              </div>
            </aside>
            <div id="views">
              <!-- Dynamic content will be injected here -->
            </div>
          </main>
          <footer></footer>
        </div>
      `;
    },

    // Load stored edits early in the loading process (before rendering)
    loadStoredEditsEarly() {
      // Ne plus charger automatiquement le localStorage
      // Laisser les JSON files Ãªtre la source de vÃ©ritÃ©
    },

    initializeModules() {
      if (this.utils.events && this.utils.events.init) this.utils.events.init();
      if (this.utils.dom && this.utils.dom.init) this.utils.dom.init();
      if (this.modules.images && this.modules.images.init) this.modules.images.init();
      if (this.modules.audio && this.modules.audio.init) this.modules.audio.init();
      if (this.modules.renderer && this.modules.renderer.init) this.modules.renderer.init();
      if (this.modules.router && this.modules.router.init) this.modules.router.init();
      if (this.modules.editor && this.modules.editor.init) this.modules.editor.init();
      if (this.modules.storage && this.modules.storage.init) this.modules.storage.init();
      if (this.modules.ui && this.modules.ui.init) this.modules.ui.init();
      
      // Initialize performance optimizations after all modules are loaded
      if (window.ScrollOptimizer && window.ScrollOptimizer.init) {
        window.ScrollOptimizer.init();
      }
      
      // Re-enable filter event handlers with fixed implementation
      this.initializeFilterEventHandlers();
    },

    initializeFilterEventHandlers() {
      // Store reference to this for use in event handlers
      const self = this;
      
      // Use event delegation for ALL filter chips (both regular and GM)
      document.addEventListener('click', (e) => {
        
        // Handle regular filter chips (monstres, tables, etc.)
        if (e.target.classList.contains('filter-chip')) {
          e.preventDefault();
          e.stopPropagation();
          
          const tag = e.target.dataset.tag;
          if (!tag) return;
          
          // Determine which page we're on based on current route
          const currentPage = window.location.hash.replace('#/', '') || 'creation';
          
          if (currentPage === 'monstres') {
            this.handleMonsterFilter(tag);
          } else if (currentPage === 'tables-tresors') {
            this.handleTableTresorFilter(tag);
          } else {
            console.log('Filter not supported on this page:', currentPage);
          }
          
          return;
        }
        
        // Handle GM filter chips (objets page GM)
        if (e.target.classList.contains('gm-filter-chip')) {
          e.preventDefault();
          e.stopPropagation();
          
          const tag = e.target.dataset.tag;
          if (!tag) return;
          
          // Only proceed if we're actually on the GM objects page
          const currentPage = window.location.hash.replace('#/', '') || 'creation';
          if (currentPage !== 'gestion-objets') {
            console.log('GM filter clicked but not on gestion-objets page, ignoring');
            return;
          }
          
          // Initialize GM tags if needed
          if (!window.ACTIVE_GM_OBJECT_TAGS) {
            window.ACTIVE_GM_OBJECT_TAGS = [];
          }
          
          // Toggle the tag
          const index = window.ACTIVE_GM_OBJECT_TAGS.indexOf(tag);
          if (index > -1) {
            // Remove tag
            window.ACTIVE_GM_OBJECT_TAGS.splice(index, 1);
          } else {
            // Add tag
            window.ACTIVE_GM_OBJECT_TAGS.push(tag);
          }
          
          // For GM filters, reload the page via router
          try {
            if (window.JdrApp && window.JdrApp.modules && window.JdrApp.modules.router) {
              window.JdrApp.modules.router.renderGMObjectsPage();
            }
          } catch (error) {
            console.error('Error reloading GM objects page:', error);
          }
        }
      });
    },

    handleMonsterFilter(tag) {
      // Initialize filter state if needed
      if (!window.MONSTRES_FILTER_STATE) {
        const config = window.ContentTypes?.monster?.filterConfig;
        window.MONSTRES_FILTER_STATE = {
          visibleTags: config?.defaultVisibleTags || ['ForÃªt']
        };
      }
      
      const state = window.MONSTRES_FILTER_STATE;
      const index = state.visibleTags.indexOf(tag);
      
      if (index > -1) {
        // Remove tag
        state.visibleTags.splice(index, 1);
      } else {
        // Add tag
        state.visibleTags.push(tag);
      }
      
      // Reload monsters page to apply filter
      try {
        if (window.JdrApp && window.JdrApp.modules && window.JdrApp.modules.router) {
          window.JdrApp.modules.router.renderMonstersPage();
        }
      } catch (error) {
        console.error('Error reloading monsters page:', error);
      }
    },

    handleTableTresorFilter(tag) {
      // Initialize filter state if needed
      if (!window.TABLES_TRESORS_FILTER_STATE) {
        const config = window.ContentTypes?.tableTresor?.filterConfig;
        window.TABLES_TRESORS_FILTER_STATE = {
          visibleTags: config?.defaultVisibleTags || ['Commun']
        };
      }
      
      const state = window.TABLES_TRESORS_FILTER_STATE;
      const index = state.visibleTags.indexOf(tag);
      
      if (index > -1) {
        // Remove tag
        state.visibleTags.splice(index, 1);
      } else {
        // Add tag
        state.visibleTags.push(tag);
      }
      
      // Reload tables page to apply filter
      try {
        if (window.JdrApp && window.JdrApp.modules && window.JdrApp.modules.router) {
          window.JdrApp.modules.router.renderTablesTresorsPage();
        }
      } catch (error) {
        console.error('Error reloading tables page:', error);
      }
    },

    updateGMObjectsDisplay() {
      console.log('Updating GM objects display...');
      
      if (!window.OBJETS || !window.ACTIVE_GM_OBJECT_TAGS) {
        console.error('Missing dependencies for GM display update');
        return;
      }
      
      // Only proceed if we're actually on the GM objects page
      const gmArticle = document.querySelector('article[data-page="gestion-objets"]');
      if (!gmArticle) {
        console.log('Not on GM objects page, skipping update');
        return;
      }
      
      try {
        const allObjects = window.OBJETS.objets || [];
        const activeTags = window.ACTIVE_GM_OBJECT_TAGS;
        
        console.log('Applying filters:', activeTags);
        
        // Filter objects based on active tags
        const filteredObjects = activeTags.length === 0 
          ? allObjects
          : allObjects.filter(obj => {
              if (!obj.tags || obj.tags.length === 0) return false;
              return activeTags.every(activeTag => obj.tags.includes(activeTag));
            });
        
        console.log(`Showing ${filteredObjects.length}/${allObjects.length} objects`);
        
        // Update ONLY the objects container
        const objectsContainer = document.getElementById('gestion-objets-container');
        if (objectsContainer && CardBuilder) {
          objectsContainer.innerHTML = filteredObjects.map((item, index) => 
            CardBuilder.create('objet', item, 'objets', index).build()
          ).join('');
          
          console.log('Objects container updated successfully');
        } else {
          console.error('Objects container or CardBuilder not found');
        }
        
        // Update ONLY the filter chips visual state
        const filterChips = document.querySelectorAll('.gm-filter-chip');
        filterChips.forEach(chip => {
          const tag = chip.dataset.tag;
          const isActive = activeTags.includes(tag);
          
          if (isActive) {
            chip.style.background = '#16a34a';
            chip.style.opacity = '1';
            chip.textContent = `âœ“ ${tag}`;
            chip.classList.add('active');
            chip.classList.remove('inactive');
          } else {
            chip.style.background = '#6b7280';
            chip.style.opacity = '0.6';
            chip.textContent = tag;
            chip.classList.add('inactive');
            chip.classList.remove('active');
          }
        });
        
        console.log('Filter chips updated successfully');
        
        // Auto-load images if available
        if (this.modules.renderer && this.modules.renderer.autoLoadImages) {
          this.modules.renderer.autoLoadImages();
        }
        
      } catch (error) {
        console.error('Error updating GM objects display:', error);
      }
    },

    // Force reload JSON data (clear localStorage cache)
    forceReloadData() {
      // Effacer seulement les Ã©ditions temporaires
      localStorage.removeItem('jdr-bab-edits');
      localStorage.removeItem('jdr-bab-last-modified');
      window.location.reload();
    },

    // Clear corrupted localStorage data specifically for monsters
    clearCorruptedMonsterData() {
      const edits = JSON.parse(localStorage.getItem('jdr-bab-edits') || '{}');
      
      // Remove any MONSTRES data that might be corrupted
      if (edits.MONSTRES) {
        delete edits.MONSTRES;
        localStorage.setItem('jdr-bab-edits', JSON.stringify(edits));
      }
      
      // Also clear any other monster-related storage
      if (edits.monster) {
        delete edits.monster;
        localStorage.setItem('jdr-bab-edits', JSON.stringify(edits));
      }
    },

    // Public method to manually clear storage via console
    clearMonsterStorage() {
      this.clearCorruptedMonsterData();
      this.forceReloadData();
    },

    // Initialize default filters for objects on page load
    initializeDefaultFilters() {
      try {
        // Only initialize if OBJETS exists and ContentTypes is available
        if (window.OBJETS && window.ContentTypes?.objet?.filterConfig) {
          const defaultTags = window.ContentTypes.objet.filterConfig.defaultVisibleTags || [];
          
          // Initialize filterSettings only if it doesn't exist or is empty
          if (!window.OBJETS.filterSettings || !window.OBJETS.filterSettings.visibleTags) {
            window.OBJETS.filterSettings = {
              visibleTags: [...defaultTags], // Active filters (defaults only)
              displayedFilterButtons: [...defaultTags] // Displayed filter buttons (defaults initially)
            };
          }
          
          // Ensure displayedFilterButtons exists even if visibleTags already existed
          if (!window.OBJETS.filterSettings.displayedFilterButtons) {
            window.OBJETS.filterSettings.displayedFilterButtons = [...defaultTags];
          }
          
        }
      } catch (error) {
        // Silent error handling for filter initialization
      }
    },

    // Validate data integrity on application startup
    validateDataIntegrity() {
      try {
        // Validate monster data if available
        if (window.MONSTRES && Array.isArray(window.MONSTRES) && JdrApp.modules.images) {
          // Force sync monster images and paths
          JdrApp.modules.images.forceSyncMonsterImages();
        }
        
        // Validate UnifiedEditor if available
        if (JdrApp.modules.editor && JdrApp.modules.editor.validateAndRepairMonsterData) {
          JdrApp.modules.editor.validateAndRepairMonsterData();
        }
        
      } catch (error) {
        // Silent error handling for data validation
      }
    },

    autoEnableMJModeInDevelopment() {
      try {
        // Better detection: Check if we're in standalone mode
        // Standalone mode sets window.STANDALONE_VERSION = true in the build
        const isStandalone = window.STANDALONE_VERSION === true;
        
        
        if (!isStandalone) {
          
          // Enable MJ mode (not dev mode!) automatically in development
          if (!this.state.isMJ) {
            this.state.isMJ = true;
            
            // Update MJ button visual if available and regenerate TOC
            if (JdrApp.modules.router && JdrApp.modules.router.updateMJButtonVisual) {
              JdrApp.modules.router.updateMJButtonVisual();
              JdrApp.modules.router.generateTOC();
              
              // Refresh current page if it's tables-tresors to show edit buttons
              const currentHash = window.location.hash;
              if (currentHash === '#/tables-tresors') {
                setTimeout(() => {
                  if (JdrApp.modules.router && JdrApp.modules.router.renderTablesTresorsPage) {
                    JdrApp.modules.router.renderTablesTresorsPage();
                  }
                }, 200);
              }
              
            } else {
              // Router not ready yet, retry
              setTimeout(() => this.autoEnableMJModeInDevelopment(), 1000);
              return;
            }
            
          }
        }
      } catch (error) {
        // Retry once more after error
        setTimeout(() => this.autoEnableMJModeInDevelopment(), 2000);
      }
    }
  };

  // Auto-initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => window.JdrApp.init());
  } else {
    window.JdrApp.init();
  }

})();
// ============================================================================
// JDR-BAB APPLICATION - CONSTANTS
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // UI CONSTANTS
  // ========================================
  window.UI_CONSTANTS = {
    // Layout dimensions
    SIDEBAR_WIDTH: 350,
    SIDEBAR_WIDTH_TABLET: 320,
    
    // Image processing defaults
    IMAGE_MAX_WIDTH: 800,
    IMAGE_QUALITY: 0.85,
    
    // Timing constants (milliseconds)
    TIMEOUTS: {
      VALIDATION_DELAY: 500,
      AUTO_MJ_DELAY: 800,
      RENDER_DELAY: 100,
      ROUTER_RETRY_DELAY: 1000,
      ERROR_RETRY_DELAY: 2000,
      DYNAMIC_CENTERING_DELAY: 50
    },
    
    // Breakpoints (aligned with CSS media queries)
    BREAKPOINTS: {
      MOBILE: 768,  // Updated to match CSS @media (max-width: 768px)
      TABLET_PORTRAIT: 768,
      TABLET_LANDSCAPE: 1024,
      DESKTOP: 980
    }
  };

  // ========================================
  // ELEMENT COLORS
  // ========================================
  window.ELEMENT_COLORS = {
    FEU: { color: '#ff6b35', weight: 'bold' },
    EAU: { color: '#4682b4', weight: 'bold' },
    TERRE: { color: '#8b4513', weight: 'bold' },
    AIR: { color: '#87ceeb', weight: 'bold' },
    DIVIN: { color: '#ffd700', weight: 'bold' },
    MALEFIQUE: { color: '#8b008b', weight: 'bold' },
    NEUTRE: { color: '#696969', weight: 'normal' }
  };

  // ========================================
  // STORAGE KEYS
  // ========================================
  window.STORAGE_KEYS = {
    EDITS: 'jdr-bab-edits',
    LAST_MODIFIED: 'jdr-bab-last-modified',
    MONSTER_BACKUPS: 'jdr-bab-monster-backups',
    FILTER_SETTINGS: 'jdr-bab-filter-settings',
    FAVORIS: 'jdr-bab-favoris'
  };

  // ========================================
  // EVENT CONSTANTS
  // ========================================
  window.Events = {
    STORAGE_SAVE: 'storage:save',
    PAGE_RENDER: 'page:render',
    CONTENT_UPDATE: 'content:update',
    FAVORIS_ADD: 'favoris:add',
    FAVORIS_REMOVE: 'favoris:remove',
    FAVORIS_UPDATE: 'favoris:update'
  };

  // ========================================
  // DEFAULT VALUES
  // ========================================
  window.DEFAULT_VALUES = {
    // Monster backup retention
    MAX_MONSTER_BACKUPS: 10,
    
    // Filter defaults
    DEFAULT_VISIBLE_TAGS: ['Arme', 'Armure', 'Bouclier', 'Consommable'],
    
    // Image defaults
    DEFAULT_MONSTER_IMAGE: 'data/images/Monstres/foret/default-monster.png',
    DEFAULT_SPELL_IMAGE: 'data/images/Sorts/default-spell.png',
    DEFAULT_CLASS_IMAGE: 'data/images/Classes/default-class.png'
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - CONTENT TYPES CONFIGURATION
// ============================================================================

(() => {
  "use strict";

  window.ContentTypes = {
    spell: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        element: { type: 'select', label: 'Ã‰lÃ©ment', required: true, options: ['Feu', 'Eau', 'Terre', 'Air', 'LumiÃ¨re', 'Nuit', 'Divin', 'MalÃ©fique'] },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'PrÃ©requis', required: true },
        portee: { type: 'richtext', label: 'PortÃ©e', required: true },
        tempsIncantation: { type: 'richtext', label: "Temps d'incantation", required: true },
        coutMana: { type: 'richtext', label: 'CoÃ»t mana', required: true },
        resistance: { type: 'richtext', label: 'RÃ©sistance', required: true },
        effetNormal: { type: 'richtext', label: 'Effet normal', required: true },
        effetCritique: { type: 'richtext', label: 'Effet critique', required: false }
      },
      editMapping: {
        'spell-name': 'nom',
        'spell-element': 'element',
        'spell-description': 'description',
        'spell-prerequis': 'prerequis',
        'spell-portee': 'portee',
        'spell-mana': 'coutMana',
        'spell-temps-incantation': 'tempsIncantation',
        'spell-resistance': 'resistance',
        'spell-effect-normal': 'effetNormal',
        'spell-effect-critical': 'effetCritique'
      },
      identifiers: {
        name: 'nom',
        category: 'sorts'
      },
      template: 'spell-card',
      container: 'sorts',
      dataKey: 'SORTS',
      icons: { 
        category: 'ğŸ”®', 
        item: 'âœ¨',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      defaultValues: {
        nom: "Nouveau Sort",
        element: "Feu",
        description: "Lance une boule de Feu sur un adversaire.",
        prerequis: "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        portee: "ğŸ¯ <strong>PortÃ©e:</strong> 20m",
        tempsIncantation: "â° <strong>Temps d'incantation:</strong> 1 tour",
        coutMana: "ğŸ”µ <strong>CoÃ»t mana:</strong> 3",
        resistance: "<strong>Sans effet si:</strong> Esquive.",
        effetNormal: "<strong>Effet:</strong> Inflige 5 dÃ©gats de <span style='color: #e25822; font-weight: bold;'>Feu</span> Ã  la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        effetCritique: "<strong>Coup Critique:&nbsp;</strong>&nbsp;Double les dÃ©gÃ¢ts et enflamme la cible."
      }
    },

    don: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'PrÃ©requis', required: true },
        cout: { type: 'richtext', label: 'CoÃ»t', required: true }
      },
      editMapping: {
        'don-name': 'nom',
        'don-description': 'description',
        'don-prerequis': 'prerequis',
        'don-cout': 'cout'
      },
      identifiers: {
        name: 'nom',
        category: 'dons'
      },
      template: 'don-card',
      container: 'dons',
      dataKey: 'DONS',
      icons: { 
        category: 'ğŸ–ï¸', 
        item: 'ğŸ†',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      defaultValues: {
        nom: "Nouveau Don",
        description: "Description du don.",
        prerequis: "Aucun prÃ©requis",
        cout: "1 point de don"
      }
    },

    class: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        resume: { type: 'textarea', label: 'RÃ©sumÃ©', required: true },
        capacites: { type: 'list', label: 'CapacitÃ©s', required: true }
      },
      editMapping: {
        'class-name': 'nom',
        'class-resume': 'resume',
        'class-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: null
      },
      template: 'class-page',
      container: 'classes',
      dataKey: 'CLASSES',
      icons: { 
        category: 'âš”ï¸', 
        item: 'ğŸ›¡ï¸',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      }
    },

    subclass: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        base: { type: 'stats', label: 'Statistiques de base', required: true },
        progression: { type: 'richtext', label: 'Progression', required: true },
        capacites: { type: 'list', label: 'CapacitÃ©s', required: true }
      },
      editMapping: {
        'subclass-name': 'nom',
        'subclass-description': 'description',
        'subclass-stats': 'base',
        'subclass-progression': 'progression',
        'subclass-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: 'sousClasses',
        parent: 'class'
      },
      template: 'subclass-card',
      icons: { 
        item: 'âš¡',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      defaultValues: {
        nom: "Nouvelle sous-classe",
        description: "Description de la sous-classe",
        base: {
          Force: 3,
          AgilitÃ©: 3,
          Endurance: 3,
          Intelligence: 3,
          VolontÃ©: 3,
          Chance: 3
        },
        progression: "<strong>ğŸ“ˆ Progression par niveau:</strong> +1 Force ğŸ’ª, +1 AgilitÃ© ğŸƒ",
        capacites: [
          "<em>CapacitÃ© unique</em>: Description de la capacitÃ© spÃ©ciale de cette sous-classe."
        ]
      }
    },

    objet: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        numero: { type: 'number', label: 'NumÃ©ro', required: true },
        image: { type: 'text', label: 'Image', required: false },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        effet: { type: 'richtext', label: 'Effet', required: true },
        prix: { type: 'richtext', label: 'Prix', required: true },
        poids: { type: 'richtext', label: 'Poids', required: true }
      },
      editMapping: {
        'objet-name': 'nom',
        'objet-numero': 'numero',
        'objet-image': 'image',
        'objet-description': 'description',
        'objet-tags': 'tags',
        'objet-effet': 'effet',
        'objet-prix': 'prix',
        'objet-poids': 'poids'
      },
      identifiers: {
        name: 'nom',
        category: 'objets'
      },
      template: 'objet-card',
      container: 'objets',
      dataKey: 'OBJETS',
      pageType: 'single', // Page unique avec filtres
      icons: { 
        category: 'ğŸ“¦', 
        item: 'ğŸ’',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      // Configuration des filtres disponibles (MISE Ã€ JOUR AUTOMATIQUE)
      filterConfig: {
        availableTags: [
          "Arme",
          "Armure",
          "Consommable",
          "Bouclier",
          "Ã‰pÃ©e",
          "Arme exotique",
          "Une main",
          "Deux mains",
          "Baton",
          "Dague",
          "Arc",
          "Armure lourde",
          "Armure lÃ©gÃ¨re",
          "Robe",
          "Plante",
          "Catalyseur",
          "Nouvel objet",
          "Nourriture",
          "Non identifiÃ©",
          "FlÃ¨che",
          "Accessoire",
          "Composant"
],
        defaultVisibleTags: [
          "Arme"
] // Filtres affichÃ©s par dÃ©faut
      },
      defaultValues: {
        nom: "Nouvel Objet",
        numero: 1,
        image: "",
        description: "Description de l'objet.",
        tags: ["Nouvel objet"],
        effet: "<strong>Effet:</strong> Description de l'effet de l'objet.",
        prix: "ğŸ”· <strong>Prix:</strong> 10",
        poids: "âš–ï¸ <strong>Poids:</strong> 1"
      }
    },

    monster: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        image: { type: 'text', label: 'Image', required: false },
        element: { 
          type: 'select', 
          label: "Ã‰lÃ©ment d'affiliation", 
          required: true,
          options: [
            { value: 'Feu', label: 'ğŸ”¥ Feu' },
            { value: 'Eau', label: 'ğŸ’§ Eau' },
            { value: 'Terre', label: 'ğŸ¤ Terre' },
            { value: 'Air', label: 'ğŸŸ¢ Air' },
            { value: 'Lumiere', label: 'â˜€ï¸ LumiÃ¨re' },
            { value: 'Nuit', label: 'âš« Nuit' },
            { value: 'Divin', label: 'âšª Divin' },
            { value: 'Malefique', label: 'ğŸŸ£ MalÃ©fique' }
          ]
        },
        pointsDeVie: { type: 'number', label: 'Points de vie', required: true },
        armurePhysique: { type: 'number', label: 'Armure physique', required: true },
        esquive: { type: 'number', label: 'Esquive', required: true },
        coupCritique: { type: 'number', label: 'Coup critique', required: true },
        coupCritiqueSorts: { type: 'number', label: 'Critique sorts', required: true },
        resistanceAlterations: { type: 'number', label: 'RÃ©sistance altÃ©rations', required: true },
        armureFeu: { type: 'number', label: 'Armure Feu', required: true },
        armureEau: { type: 'number', label: 'Armure Eau', required: true },
        armureTerre: { type: 'number', label: 'Armure Terre', required: true },
        armureAir: { type: 'number', label: 'Armure Air', required: true },
        armureLumiere: { type: 'number', label: 'Armure LumiÃ¨re', required: true },
        armureObscurite: { type: 'number', label: 'Armure ObscuritÃ©', required: true },
        armureDivin: { type: 'number', label: 'Armure Divin', required: true },
        armureMalefique: { type: 'number', label: 'Armure MalÃ©fique', required: true },
        abilites: { type: 'richtext', label: 'AbilitÃ©s', required: false },
        butin: { type: 'richtext', label: 'Butin', required: false }
      },
      editMapping: {
        'monster-name': 'nom',
        'monster-tags': 'tags',
        'monster-image': 'image',
        'monster-element': 'element',
        // Stats principaux
        'monster-pointsdevie': 'pointsDeVie',
        'monster-armurephysique': 'armurePhysique', 
        'monster-esquive': 'esquive',
        'monster-coupcritique': 'coupCritique',
        'monster-coupcritiquesorts': 'coupCritiqueSorts',
        'monster-resistancealterations': 'resistanceAlterations',
        // Armures Ã©lÃ©mentaires
        'monster-armurefeu': 'armureFeu',
        'monster-armureeau': 'armureEau',
        'monster-armureterre': 'armureTerre',
        'monster-armureair': 'armureAir',
        'monster-armurelumiere': 'armureLumiere',
        'monster-armureobscurite': 'armureObscurite',
        'monster-armuredivin': 'armureDivin',
        'monster-armuremalefique': 'armureMalefique',
        // Contenu narratif
        'monster-abilites': 'abilites',
        'monster-butin': 'butin'
      },
      identifiers: {
        name: 'nom',
        category: 'monstres'
      },
      template: 'monster-card',
      container: 'monstres',
      dataKey: 'MONSTRES',
      pageType: 'single',
      filterMode: 'AND',
      icons: { 
        category: 'ğŸ²', 
        item: 'ğŸ‘¾',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      filterConfig: {
        availableTags: [
          "ForÃªt",
          "Boss"
],
        defaultVisibleTags: [
          "ForÃªt"
]
      },
      defaultValues: {
        nom: "Nouveau Monstre",
        tags: ["ForÃªt"],
        image: "",
        element: "Feu",
        pointsDeVie: 20,
        armurePhysique: 2,
        esquive: 5,
        coupCritique: 10,
        coupCritiqueSorts: 8,
        resistanceAlterations: 3,
        armureFeu: 0,
        armureEau: 0,
        armureTerre: 0,
        armureAir: 0,
        armureLumiere: 0,
        armureObscurite: 0,
        armureDivin: 0,
        armureMalefique: 0,
        abilites: "<strong>Attaque basique:</strong> Inflige 5 dÃ©gÃ¢ts physiques.",
        butin: "<strong>Butin:</strong> 10-50 piÃ¨ces d'or."
      }
    },

    tableTresor: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        fourchettes: { type: 'list', label: 'Fourchettes', required: true }
      },
      editMapping: {
        'table-tresor-name': 'nom',
        'table-tresor-description': 'description',
        'table-tresor-tags': 'tags'
      },
      identifiers: {
        name: 'nom',
        category: 'tables'
      },
      template: 'table-tresor-card',
      container: 'tables-tresors',
      dataKey: 'TABLES_TRESORS',
      pageType: 'single',
      filterMode: 'OR',
      icons: { 
        category: 'ğŸ’', 
        item: 'ğŸ“¦',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      filterConfig: {
        // availableTags managed dynamically via window.TABLES_TRESORS._metadata.availableTags
        defaultVisibleTags: [
          "ForÃªt",
          "Boss"
        ]
      },
      defaultValues: {
        nom: "Nouvelle Table de TrÃ©sor",
        description: "Table de butin pour une situation spÃ©cifique.",
        tags: ["ForÃªt"],
        fourchettes: [
          {
            min: 1,
            max: 10,
            objet: {
              type: "reference",
              numero: 1,
              nom: "Objet par dÃ©faut"
            }
          }
        ]
      }
    },

    staticPage: {
      fields: {
        title: { type: 'text', label: 'Titre', required: true },
        sections: { type: 'sections', label: 'Sections', required: true }
      },
      template: 'static-page',
      icons: { 
        category: 'ğŸ“„', 
        item: 'ğŸ“'
      }
    }
  };

  window.StatIcons = {
    'Force': 'ğŸ’ª',
    'AgilitÃ©': 'ğŸƒ',
    'Endurance': 'ğŸ›¡ï¸',
    'Intelligence': 'ğŸ§ ',
    'VolontÃ©': 'âš¡',
    'Chance': 'ğŸ€'
  };

  window.ElementColors = {
    'Feu': { color: '#ff6b35', weight: 'bold' },
    'Eau': { color: '#4682b4', weight: 'bold' },
    'Terre': { color: '#8b4513', weight: 'bold' },
    'Air': { color: '#22c55e', weight: 'bold' },
    'LumiÃ¨re': { color: '#ffd700', weight: 'bold' },
    'Nuit': { color: '#1a1a1a', weight: 'bold' },
    'Divin': { color: '#f5f5f5', weight: 'bold', background: 'rgba(100, 100, 100, 0.3)', padding: '2px 4px', borderRadius: '3px' },
    'MalÃ©fique': { color: '#8b5cf6', weight: 'bold' }
  };

  window.ElementIcons = {
    'Feu': 'ğŸ”¥',
    'Eau': 'ğŸ’§',
    'Terre': 'ğŸ¤',
    'Air': 'ğŸŸ¢',
    'LumiÃ¨re': 'â˜€ï¸',
    'Nuit': 'âš«',
    'Divin': 'âšª',
    'MalÃ©fique': 'ğŸŸ£'
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - EVENT BUS
// ============================================================================

(() => {
  "use strict";

  class EventBus {
    constructor() {
      this.listeners = new Map();
    }

    static getInstance() {
      if (!EventBus.instance) {
        EventBus.instance = new EventBus();
      }
      return EventBus.instance;
    }

    on(eventType, callback) {
      if (!this.listeners.has(eventType)) {
        this.listeners.set(eventType, []);
      }
      this.listeners.get(eventType).push(callback);
      return () => this.off(eventType, callback);
    }

    off(eventType, callback) {
      const callbacks = this.listeners.get(eventType);
      if (callbacks) {
        const index = callbacks.indexOf(callback);
        if (index > -1) {
          callbacks.splice(index, 1);
        }
      }
    }

    emit(eventType, payload = {}) {
      const callbacks = this.listeners.get(eventType);
      if (callbacks) {
        callbacks.forEach(callback => {
          try {
            callback(payload);
          } catch (error) {
            console.error(`Error in event callback for ${eventType}:`, error);
          }
        });
      }
    }

    once(eventType, callback) {
      const unsubscribe = this.on(eventType, (payload) => {
        callback(payload);
        unsubscribe();
      });
      return unsubscribe;
    }
  }

  window.EventBus = EventBus.getInstance();

  window.Events = {
    CONTENT_ADD: 'content:add',
    CONTENT_DELETE: 'content:delete',
    CONTENT_UPDATE: 'content:update',
    CONTENT_MOVE: 'content:move',
    PAGE_RENDER: 'page:render',
    EDITOR_TOGGLE: 'editor:toggle',
    IMAGE_UPLOAD: 'image:upload',
    IMAGE_DELETE: 'image:delete',
    STORAGE_SAVE: 'storage:save',
    SEARCH_PERFORM: 'search:perform',
    MODAL_OPEN: 'modal:open',
    MODAL_CLOSE: 'modal:close',
    NOTIFICATION_SHOW: 'notification:show'
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - BASE ENTITY
// ============================================================================

(() => {
  "use strict";

  class BaseEntity {
    constructor(type, dataArray) {
      this.type = type;
      this.data = dataArray || [];
      this.config = window.ContentTypes[type];
      
      // Handle special case for objects with new structure
      if (type === 'objet' && this.data && !Array.isArray(this.data) && this.data.objets) {
        // Convert to pseudo-category structure for compatibility
        this.objectsData = this.data; // Keep reference to original structure
        this.data = [{ nom: 'objets', objets: this.data.objets }]; // Wrap in array format
      }
      
      // Handle special case for treasure tables with structure: { tables: [...], _metadata: {...} }
      if (type === 'tableTresor' && this.data && !Array.isArray(this.data) && this.data.tables) {
        // Convert to pseudo-category structure for compatibility
        this.tablesData = this.data; // Keep reference to original structure
        this.data = [{ nom: 'tables', tables: this.data.tables }]; // Wrap in array format
      }
    }

    getAll() {
      return this.data;
    }

    findCategory(categoryName) {
      return this.data.find(category => category.nom === categoryName);
    }

    findItem(itemName, categoryName = null) {
      if (categoryName) {
        const category = this.findCategory(categoryName);
        if (!category || !category[this.getItemsProperty()]) return null;
        
        const item = category[this.getItemsProperty()].find(item => item.nom === itemName);
        return item ? { item, category: category.nom } : null;
      }

      for (const category of this.data) {
        if (!category[this.getItemsProperty()]) continue;
        const item = category[this.getItemsProperty()].find(item => item.nom === itemName);
        if (item) {
          return { item, category: category.nom };
        }
      }
      return null;
    }

    addItem(categoryName, itemData) {
      const category = this.findCategory(categoryName);
      if (!category) return false;

      const itemsProperty = this.getItemsProperty();
      if (!category[itemsProperty]) {
        category[itemsProperty] = [];
      }

      const defaultValues = this.config?.defaultValues || {};
      const newItem = { ...defaultValues, ...itemData };
      category[itemsProperty].push(newItem);

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_ADD, {
        type: this.type,
        category: categoryName,
        item: newItem
      });

      return newItem;
    }

    deleteItem(categoryName, itemName) {
      const category = this.findCategory(categoryName);
      if (!category) return false;

      const itemsProperty = this.getItemsProperty();
      const items = category[itemsProperty];
      if (!items) return false;

      const index = items.findIndex(item => item.nom === itemName);
      if (index === -1) return false;

      const deletedItem = items.splice(index, 1)[0];

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_DELETE, {
        type: this.type,
        category: categoryName,
        item: deletedItem
      });

      return true;
    }

    updateItem(categoryName, itemName, property, value) {
      const result = this.findItem(itemName, categoryName);
      if (!result) return false;

      const { item } = result;
      
      if (property === 'capacites' && Array.isArray(value)) {
        item[property] = value;
      } else if (property === 'base' && typeof value === 'object') {
        item[property] = { ...item[property], ...value };
      } else {
        item[property] = value;
      }

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_UPDATE, {
        type: this.type,
        category: categoryName,
        item: item,
        property: property,
        value: value
      });

      return true;
    }

    moveItem(categoryName, itemName, direction) {
      const category = this.findCategory(categoryName);
      if (!category) return false;

      const itemsProperty = this.getItemsProperty();
      const items = category[itemsProperty];
      if (!items) return false;

      const currentIndex = items.findIndex(item => item.nom === itemName);
      if (currentIndex === -1) return false;

      const newIndex = currentIndex + direction;
      if (newIndex < 0 || newIndex >= items.length) return false;

      [items[currentIndex], items[newIndex]] = [items[newIndex], items[currentIndex]];

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_MOVE, {
        type: this.type,
        category: categoryName,
        itemName: itemName,
        direction: direction
      });

      return true;
    }

    getItemsProperty() {
      switch (this.type) {
        case 'spell': return 'sorts';
        case 'don': return 'dons';
        case 'objet': return 'objets';
        case 'class': return 'sousClasses';
        case 'tableTresor': return 'tables';
        default: return 'items';
      }
    }

    search(query) {
      const results = [];
      const normalizedQuery = query.toLowerCase().trim();

      this.data.forEach(category => {
        const itemsProperty = this.getItemsProperty();
        if (!category[itemsProperty]) return;

        category[itemsProperty].forEach(item => {
          const searchableText = Object.values(item).join(' ').toLowerCase();
          if (searchableText.includes(normalizedQuery)) {
            results.push({
              item,
              category: category.nom,
              type: this.type
            });
          }
        });
      });

      return results;
    }

    // Sync changes back to original objects data structure
    syncObjectsData() {
      // Sync objects data
      if (this.type === 'objet' && this.objectsData && this.data.length > 0) {
        const objectsCategory = this.data[0];
        if (objectsCategory && objectsCategory.objets) {
          this.objectsData.objets = objectsCategory.objets;
        }
      }
      
      // Sync treasure tables data
      if (this.type === 'tableTresor' && this.tablesData && this.data.length > 0) {
        const tablesCategory = this.data[0];
        if (tablesCategory && tablesCategory.tables) {
          this.tablesData.tables = tablesCategory.tables;
        }
      }
      
      // Sync monsters data - CRITICAL for preventing data reversion
      if (this.type === 'monster' && window.MONSTRES && Array.isArray(this.data)) {
        // Ensure window.MONSTRES stays synchronized with our internal data
        window.MONSTRES.length = 0; // Clear array
        window.MONSTRES.push(...this.data); // Replace with current data
        
        // Also sync image mappings
        if (JdrApp.modules.images && typeof JdrApp.modules.images.ensureMonsterImageMappings === 'function') {
          JdrApp.modules.images.ensureMonsterImageMappings();
        }
      }
    }
  }

  window.BaseEntity = BaseEntity;

})();
// ============================================================================
// JDR-BAB APPLICATION - CONTENT FACTORY
// ============================================================================

(() => {
  "use strict";

  class ContentFactory {
    constructor() {
      this.entities = new Map();
      this.initialize();
    }

    static getInstance() {
      if (!ContentFactory.instance) {
        ContentFactory.instance = new ContentFactory();
      }
      return ContentFactory.instance;
    }

    initialize() {
      // Lazy initialization - only create entities when data is available
      if (window.SORTS) {
        this.entities.set('spell', new BaseEntity('spell', window.SORTS));
      }
      if (window.DONS) {
        this.entities.set('don', new BaseEntity('don', window.DONS));
      }
      if (window.CLASSES) {
        this.entities.set('class', new BaseEntity('class', window.CLASSES));
      }
      if (window.OBJETS) {
        this.entities.set('objet', new BaseEntity('objet', window.OBJETS));
      }
      if (window.MONSTRES) {
        this.entities.set('monster', new BaseEntity('monster', window.MONSTRES));
      }
      if (window.TABLES_TRESORS) {
        this.entities.set('tableTresor', new BaseEntity('tableTresor', window.TABLES_TRESORS));
      }
    }

    getEntity(type) {
      // Ensure entity exists, create if data is available but entity is missing
      if (!this.entities.has(type)) {
        this.initializeEntity(type);
      }
      return this.entities.get(type);
    }

    initializeEntity(type) {
      switch (type) {
        case 'spell':
          if (window.SORTS) {
            this.entities.set('spell', new BaseEntity('spell', window.SORTS));
          }
          break;
        case 'don':
          if (window.DONS) {
            this.entities.set('don', new BaseEntity('don', window.DONS));
          }
          break;
        case 'class':
          if (window.CLASSES) {
            this.entities.set('class', new BaseEntity('class', window.CLASSES));
          }
          break;
        case 'objet':
          if (window.OBJETS) {
            this.entities.set('objet', new BaseEntity('objet', window.OBJETS));
          }
          break;
        case 'monster':
          if (window.MONSTRES) {
            this.entities.set('monster', new BaseEntity('monster', window.MONSTRES));
          }
          break;
        case 'tableTresor':
          if (window.TABLES_TRESORS) {
            this.entities.set('tableTresor', new BaseEntity('tableTresor', window.TABLES_TRESORS));
          }
          break;
      }
    }

    getSpells() {
      return this.getEntity('spell');
    }

    getDons() {
      return this.getEntity('don');
    }

    getClasses() {
      return this.getEntity('class');
    }

    getObjets() {
      return this.getEntity('objet');
    }

    getMonsters() {
      return this.getEntity('monster');
    }

    getTablesTresors() {
      return this.getEntity('tableTresor');
    }

    findItem(type, itemName, categoryName = null) {
      const entity = this.getEntity(type);
      return entity ? entity.findItem(itemName, categoryName) : null;
    }

    addItem(type, categoryName, itemData) {
      const entity = this.getEntity(type);
      return entity ? entity.addItem(categoryName, itemData) : false;
    }

    deleteItem(type, categoryName, itemName) {
      const entity = this.getEntity(type);
      return entity ? entity.deleteItem(categoryName, itemName) : false;
    }

    updateItem(type, categoryName, itemName, property, value) {
      const entity = this.getEntity(type);
      return entity ? entity.updateItem(categoryName, itemName, property, value) : false;
    }

    moveItem(type, categoryName, itemName, direction) {
      const entity = this.getEntity(type);
      return entity ? entity.moveItem(categoryName, itemName, direction) : false;
    }

    searchAll(query) {
      const allResults = [];
      
      this.entities.forEach((entity, type) => {
        const results = entity.search(query);
        allResults.push(...results);
      });

      return allResults;
    }

    refreshData() {
      this.entities.clear();
      this.initialize();
    }

    // ============================================================================
    // UNIFIED PAGE DESCRIPTION SYSTEM
    // ============================================================================

    getPageDescription(type) {
      const config = window.ContentTypes[type];
      
      if (!config || !config.pageDescription) {
        return '';
      }
      
      const pageDesc = config.pageDescription;
      
      if (pageDesc.dataSource === 'external') {
        // Utilisation d'un fichier externe via dataKey
        const dataObj = window[pageDesc.dataKey];
        if (!dataObj) {
          // CrÃ©er l'objet externe s'il n'existe pas
          window[pageDesc.dataKey] = { [pageDesc.storageKey]: pageDesc.defaultValue };
          return pageDesc.defaultValue;
        }
        return dataObj[pageDesc.storageKey] || pageDesc.defaultValue;
      } else {
        // Source de donnÃ©es intÃ©grÃ©e dans le dataKey principal
        const mainDataKey = config.dataKey;
        const mainData = window[mainDataKey];
        
        if (!mainData) {
          return pageDesc.defaultValue;
        }
        
        // Initialiser la description si elle n'existe pas
        if (!mainData[pageDesc.storageKey]) {
          mainData[pageDesc.storageKey] = pageDesc.defaultValue;
        }
        
        return mainData[pageDesc.storageKey];
      }
    }

    updatePageDescription(type, newDescription) {
      
      // Ensure collections type exists (fallback injection)
      if (type === 'collections' && (!window.ContentTypes || !window.ContentTypes.collections)) {
        this.ensureCollectionsType();
      }
      
      const config = window.ContentTypes[type];
      
      if (!config || !config.pageDescription) {
        // No page description config found for type
        return false;
      }
      
      const pageDesc = config.pageDescription;
      
      try {
        if (pageDesc.dataSource === 'external') {
          // Mise Ã  jour d'un fichier externe via dataKey
          const dataObj = window[pageDesc.dataKey];
          if (!dataObj) {
            window[pageDesc.dataKey] = {};
          }
          window[pageDesc.dataKey][pageDesc.storageKey] = newDescription;
          
          // Also update JdrApp.data.customPageDescriptions for consistency with router and storage
          if (!JdrApp.data.customPageDescriptions) {
            JdrApp.data.customPageDescriptions = {};
          }
          JdrApp.data.customPageDescriptions[pageDesc.storageKey] = newDescription;
        } else {
          // Mise Ã  jour dans le dataKey principal
          const mainDataKey = config.dataKey;
          const mainData = window[mainDataKey];
          
          if (!mainData) {
            return false;
          }
          
          mainData[pageDesc.storageKey] = newDescription;
        }
        
        // Ã‰mettre un Ã©vÃ©nement pour notifier le changement
        if (window.EventBus) {
          window.EventBus.emit('pageDescriptionUpdated', { type, description: newDescription });
        }
        
        return true;
      } catch (error) {
        return false;
      }
    }

    getConfig(type) {
      return window.ContentTypes[type];
    }

    createDefaultItem(type, overrides = {}) {
      const config = this.getConfig(type);
      if (!config?.defaultValues) return {};

      return { ...config.defaultValues, ...overrides };
    }

    ensureCollectionsType() {
      if (!window.ContentTypes) {
        window.ContentTypes = {};
      }
      
      // Inject collections type if missing
      window.ContentTypes.collections = {
        fields: {
          description: { type: 'richtext', label: 'Description', required: true }
        },
        template: 'collections-page',
        container: 'collections',
        icons: { 
          category: 'ğŸ“š', 
          item: 'ğŸ“¦'
        },
        pageDescription: {
          dataSource: 'external',
          dataKey: 'CUSTOM_PAGE_DESCRIPTIONS',
          storageKey: 'collections-objets',
          defaultValue: "Recherchez et explorez des collections d'objets organisÃ©es par thÃ¨me"
        },
        defaultValues: {
          description: "Recherchez et explorez des collections d'objets organisÃ©es par thÃ¨me"
        }
      };
      
      // Collections type injected into ContentTypes
    }
  }

  window.ContentFactory = ContentFactory.getInstance();

})();
// ============================================================================
// JDR-BAB APPLICATION - CARD BUILDER
// ============================================================================

(() => {
  "use strict";

  class CardBuilder {
    constructor(type, data, categoryName = null, index = null) {
      this.type = type;
      this.data = data;
      this.categoryName = categoryName;
      this.index = index;
      this.config = window.ContentTypes[type];
      this.isPreview = categoryName === 'preview'; // Mode preview si categoryName est 'preview'
    }

    static create(type, data, categoryName = null, index = null) {
      return new CardBuilder(type, data, categoryName, index);
    }

    // Simple unified dev mode check
    get shouldShowEditButtons() {
      return JdrApp.utils.isDevMode() && !this.isPreview;
    }

    build() {
      let html = '';
      
      switch (this.type) {
        case 'spell':
          html = this.buildSpellCard();
          break;
        case 'don':
          html = this.buildDonCard();
          break;
        case 'subclass':
          html = this.buildSubclassCard();
          break;
        case 'objet':
          html = this.buildObjetCard();
          break;
        case 'monster':
          html = this.buildMonsterCard();
          break;
        case 'tableTresor':
          html = this.buildTableTresorCard();
          break;
        default:
          html = this.buildGenericCard();
          break;
      }
      
      // Apply HTML minification for performance optimization in standalone mode
      if (window.STANDALONE_VERSION && JdrApp.utils && JdrApp.utils.minifyHTML) {
        html = JdrApp.utils.minifyHTML(html);
      }
      
      return html;
    }

    buildSpellCard() {
      const favorisButtonHTML = this.buildFavorisButton('sorts', this.data.nom);
      
      const result = `
        <div class="card editable-section spell-card" data-section-type="spell" data-spell-name="${this.data.nom}" data-spell-index="${this.index}" data-category-name="${this.categoryName}">
          ${favorisButtonHTML}
          ${this.buildEditableTitle(this.data.nom, 'spell-name')}
          ${this.buildSpellElement()}
          ${this.buildIllustration(`sort:${this.categoryName}:${this.data.nom}`, this.data.nom)}
          ${this.buildEditableField(this.data.description, 'spell-description', 'Description', { style: 'text-align: center; font-style: italic; margin: 1rem 0;' })}
          <hr style="margin: 1rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.6;">
          ${this.buildEditableField(this.data.prerequis, 'spell-prerequis', 'PrÃ©requis')}
          ${this.buildEditableField(this.data.portee, 'spell-portee', 'PortÃ©e')}
          ${this.buildEditableField(this.data.coutMana, 'spell-mana', 'CoÃ»t mana')}
          ${this.buildEditableField(this.data.tempsIncantation, 'spell-temps-incantation', 'Temps d\'incantation')}
          <hr style="margin: 0.5rem 0; border: none; border-top: 1px solid var(--rule);">
          ${this.buildEditableField(this.data.resistance, 'spell-resistance', 'RÃ©sistance')}
          ${this.buildEditableEffect(this.data.effetNormal, 'spell-effect-normal', 'Effet normal')}
          <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
          ${this.data.effetCritique ? this.buildEditableEffect(this.data.effetCritique, 'spell-effect-critical', 'Effet critique') : ''}
          ${this.buildDeleteButton('spell')}
        </div>
      `;
      
      return result;
    }

    buildDonCard() {
      const index = this.index !== null ? this.index : (this.categoryName ? this.getCategoryData().dons?.indexOf(this.data) || 0 : 0);
      const totalItems = this.categoryName ? this.getCategoryData().dons?.length || 1 : 1;

      return `
        <div class="card editable-section" data-section-type="don" data-don-name="${this.data.nom}" data-don-index="${this.index}" data-category-name="${this.categoryName}">
          ${this.buildEditableTitle(this.data.nom, 'don-name')}
          ${this.buildIllustration(`don:${this.data.nom}`, this.data.nom)}
          ${this.buildEditableField(this.data.description, 'don-description', 'Description')}
          ${this.buildEditableField(this.data.prerequis, 'don-prerequis', 'PrÃ©requis')}
          ${this.buildEditableField(this.data.cout, 'don-cout', 'CoÃ»t', { style: 'color: var(--bronze); font-weight: 600;' })}
          ${this.buildMoveButtons('don', index, totalItems)}
        </div>
      `;
    }

    buildSubclassCard() {
      return `
        <div class="card editable-section" data-section-type="subclass" data-class-name="${this.categoryName}" data-subclass-name="${this.data.nom}">
          ${this.buildEditableTitle(this.data.nom, 'subclass-name')}
          ${this.buildEditableField(this.data.description || 'Description de la sous-classe', 'subclass-description', 'Description', { style: 'text-align: center; color: inherit;' })}
          ${this.buildSubclassImages()}
          <div style="margin-bottom: 1rem;">
            ${this.buildStatsSection()}
          </div>
          ${this.buildEditableField(this.data.progression, 'subclass-progression', 'Progression')}
          <div class="rule" style="margin: 1.5rem auto; height: 2px; background: linear-gradient(90deg, transparent, var(--bronze), transparent); opacity: 0.6;"></div>
          ${this.buildEditableList(this.data.capacites, 'subclass-capacites', 'CapacitÃ©s')}
          ${this.buildDeleteButton('subclass')}
        </div>
      `;
    }

    buildObjetCard() {
      // Pour les objets en page unique, l'index est basÃ© sur tous les objets
      const allObjects = window.OBJETS?.objets || [];
      const index = allObjects.indexOf(this.data) || 0;
      const totalItems = allObjects.length;
      
      // Construire l'affichage des tags
      const tagsDisplay = this.data.tags && this.data.tags.length > 0 
        ? this.data.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';

      return `
        <div class="card editable-section item-card" data-section-type="objet" data-objet-name="${this.data.nom}" data-category-name="${this.categoryName}">
          ${this.buildFavorisButton('objets', this.data.nom)}
          ${this.buildEditableTitle(this.data.nom, 'objet-name')}
          ${this.buildIllustration(`objet:${this.data.nom}`, this.data.nom)}
          <div style="display: flex; justify-content: space-between; align-items: center; margin: 0.5rem 0; font-size: 0.9em; color: var(--bronze);">
            ${this.buildEditableField(`NÂ°${this.data.numero}`, 'objet-numero', 'NumÃ©ro', { style: 'font-weight: bold;' })}
            <div style="flex: 1; text-align: right;">
              <div style="margin: 2px 0;">
                ${this.buildEditableTagsField(tagsDisplay, 'objet-tags', 'Tags')}
              </div>
            </div>
          </div>
          ${this.buildEditableField(this.data.description, 'objet-description', 'Description')}
          <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
          ${this.buildEditableField(this.data.effet, 'objet-effet', 'Effet')}
          <div style="display: flex; justify-content: space-between; gap: 1rem; margin: 0.5rem 0;">
            <div style="flex: 1;">${this.buildEditableField(this.data.prix, 'objet-prix', 'Prix')}</div>
            <div style="flex: 1;">${this.buildEditableField(this.data.poids, 'objet-poids', 'Poids')}</div>
          </div>
        </div>
      `;
    }

    buildMonsterCard() {
      const allMonsters = window.MONSTRES || [];
      const index = allMonsters.indexOf(this.data) || 0;
      const totalItems = allMonsters.length;
      
      // Construire l'affichage des tags
      const tagsDisplay = this.data.tags && this.data.tags.length > 0 
        ? this.data.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';

      return `
        <div class="card editable-section" data-section-type="monster" data-monster-name="${this.data.nom}">
          ${this.buildEditableTitle(this.data.nom, 'monster-name')}
          ${this.buildIllustration(`monster:${this.data.nom}`, this.data.nom)}
          
          <div style="display: flex; justify-content: space-between; align-items: flex-start; margin: 0.5rem 0; gap: 1rem;">
            <div style="flex: 1;">
              ${this.buildEditableTagsField(tagsDisplay, 'monster-tags', 'Tags')}
            </div>
            <div style="flex-shrink: 0;">
              ${this.buildMonsterElement()}
            </div>
          </div>
          
          <!-- SÃ©paration avant les stats principales -->
          <hr style="margin: 1.5rem 0 1rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.3;">
          
          <div class="monster-stats-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin: 1rem 0; font-size: 0.9em;">
            <div>${this.buildEditableStatField('ğŸ¯ Initiative', this.data.initiative, 'monster-initiative', 'Initiative')}</div>
            <div>${this.buildEditableStatField('â¤ï¸ PV', this.data.pointsDeVie, 'monster-pointsdevie', 'Points de vie')}</div>
            <div>${this.buildEditableStatField('âš¡ Critique', this.data.coupCritique, 'monster-coupcritique', 'Coup critique')}</div>
            <div>${this.buildEditableStatField('ğŸ›¡ï¸ Armure', this.data.armurePhysique, 'monster-armurephysique', 'Armure physique')}</div>
            <div>${this.buildEditableStatField('ğŸ”® Crit. Sorts', this.data.coupCritiqueSorts, 'monster-coupcritiquesorts', 'Critique sorts')}</div>
            <div>${this.buildEditableStatField('ğŸƒ Esquive', this.data.esquive, 'monster-esquive', 'Esquive')}</div>
            <div></div>
            <div>${this.buildEditableStatField('âœ¨ RÃ©s. Alt.', this.data.resistanceAlterations, 'monster-resistancealterations', 'RÃ©sistance altÃ©rations')}</div>
          </div>

          <!-- SÃ©paration aprÃ¨s les stats principales -->
          <hr style="margin: 1rem 0 1.5rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.3;">

          <div style="margin: 1rem 0;">
            <strong>ğŸŒŸ Armures Ã‰lÃ©mentaires:</strong>
            <div class="monster-elemental-grid" style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 0.25rem; font-size: 0.8em; margin-top: 0.5rem;">
              <div>${this.buildEditableStatField(this.getElementIcon('Feu'), this.data.armureFeu, 'monster-armurefeu', 'Armure Feu')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Eau'), this.data.armureEau, 'monster-armureeau', 'Armure Eau')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Terre'), this.data.armureTerre, 'monster-armureterre', 'Armure Terre')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Air'), this.data.armureAir, 'monster-armureair', 'Armure Air')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('LumiÃ¨re'), this.data.armureLumiere, 'monster-armurelumiere', 'Armure LumiÃ¨re')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Nuit'), this.data.armureObscurite, 'monster-armureobscurite', 'Armure ObscuritÃ©')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Divin'), this.data.armureDivin, 'monster-armuredivin', 'Armure Divin')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('MalÃ©fique'), this.data.armureMalefique, 'monster-armuremalefique', 'Armure MalÃ©fique')}</div>
            </div>
          </div>

          ${this.data.abilites ? `
            <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
            ${this.buildEditableField(this.data.abilites, 'monster-abilites', 'AbilitÃ©s', { style: 'margin-top: 0.5rem;' })}
          ` : ''}

          ${this.data.butin ? `
            <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
            ${this.buildEditableField(this.data.butin, 'monster-butin', 'Butin', { style: 'margin-top: 0.5rem;' })}
          ` : ''}

          ${this.buildDeleteButton('monster')}
        </div>
      `;
    }

    buildEditableTitle(content, editType, centerAlign = true) {
      const style = centerAlign ? 'margin: 0 0 1rem 0; text-align: center;' : '';
      const spellTitleClass = this.type === 'spell' ? ' spell-title' : '';
      const subclassTitleClass = this.type === 'subclass' ? ' subclass-title' : '';
      const editTypeClass = editType ? ` ${editType}` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <h4 style="${style}" class="editable editable-title${spellTitleClass}${subclassTitleClass}${editTypeClass}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}">${content}</h4>
          ${this.buildEditButton('title')}
        </div>
      `;
    }

    buildEditableField(content, editType, label, options = {}) {
      const style = options.style ? `style="${options.style}"` : '';
      const className = options.className || 'editable-field';
      
      // Add the editType as a class for reliable detection
      const editTypeClass = editType ? ` ${editType}` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable ${className}${editTypeClass}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" ${style}>
            ${content}
          </div>
          ${this.buildEditButton('field')}
        </div>
      `;
    }

    buildEditableStatField(title, value, editType, label, options = {}) {
      const style = options.style ? `style="${options.style}"` : '';
      const className = options.className || 'editable-stat';
      
      // Display the value only as editable, but show title + value visually
      return `
        <div class="editable-section" data-section-type="html">
          <div style="display: flex; align-items: center;">
            <strong style="margin-right: 0.25rem;">${title}:</strong>
            <div class="editable ${className}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" ${style}>
              ${value}
            </div>
          </div>
          ${this.buildEditButton('field')}
        </div>
      `;
    }
    
    buildEditableTagsField(content, editType, label, options = {}) {
      const style = options.style ? `style="${options.style}"` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable editable-tags" data-edit-type="tags" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" ${style}>
            ${content}
          </div>
          ${this.buildEditButton('field')}
        </div>
      `;
    }

    buildEditableEffect(content, editType, label) {
      const editTypeClass = editType ? ` ${editType}` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable editable-effect${editTypeClass}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" style="margin: 1rem 0;">
            ${content}
          </div>
          ${this.buildEditButton('effect')}
        </div>
      `;
    }

    buildEditableList(items, editType, label) {
      // Everything should be HTML format only
      let listHTML;
      if (typeof items === 'string') {
        // HTML string format
        listHTML = items;
      } else {
        // Fallback if somehow still array format - convert once
        if (Array.isArray(items)) {
          listHTML = '<ul>' + items.map(item => '<li>' + item + '</li>').join('') + '</ul>';
        } else {
          listHTML = '<ul><li>Aucune capacitÃ© dÃ©finie</li></ul>';
        }
      }
      
      // Use the editType directly instead of creating compound identifier
      return `
        <h5>${label}</h5>
        <div class="editable-section" data-section-type="html">
          <div class="editable" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}">
            ${listHTML}
          </div>
          ${this.buildEditButton('list')}
        </div>
      `;
    }

    buildStatsSection() {
      // Stats are special - they remain as objects since they're structured data
      // But check if they were converted to HTML string by editing
      let statsHTML;
      
      if (typeof this.data.base === 'string') {
        // Already converted to HTML by editing
        statsHTML = this.data.base;
      } else if (typeof this.data.base === 'object') {
        // Original object format - convert to HTML
        statsHTML = '<div class="chips">' + 
          Object.entries(this.data.base).map(([stat, value]) => {
            const icon = window.StatIcons[stat] || 'âš¡';
            return '<span class="chip">' + icon + ' ' + stat + ': <strong>' + value + '</strong></span>';
          }).join('') + 
          '</div>';
      } else {
        statsHTML = '<div>Aucune statistique dÃ©finie</div>';
      }
      
      // Use subclass-stats directly
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable editable-stats" data-edit-type="generic" data-edit-section="subclass-stats" data-item-identifier="${this.data.nom}">
            ${statsHTML}
          </div>
          ${this.buildEditButton('stats')}
        </div>
      `;
    }

    buildSubclassImages() {
      const illusKey1 = `subclass:${this.categoryName}:${this.data.nom}:1`;
      const illusKey2 = `subclass:${this.categoryName}:${this.data.nom}:2`;
      
      return `
        <div class="subclass-images">
          ${this.buildIllustration(illusKey1, `${this.data.nom} (Image 1)`, 'subclass')}
          ${this.buildIllustration(illusKey2, `${this.data.nom} (Image 2)`, 'subclass')}
        </div>
      `;
    }

    buildIllustration(illusKey, altText = '', styleType = 'default') {
      let imageUrl = '';
      let imageStyle = 'display: none;';
      let removeStyle = 'display: none;';
      
      if (window.JdrApp?.modules?.images?.getImageUrl) {
        imageUrl = window.JdrApp.modules.images.getImageUrl(illusKey);
        if (imageUrl) {
          imageUrl = window.JdrApp.modules.images.processImageUrl(imageUrl);
          imageStyle = 'display: inline-block;';
          removeStyle = 'display: inline-flex;';
        }
      }

      let containerClasses = 'illus';
      if (['spell', 'class', 'subclass', 'don', 'objet', 'monster'].includes(styleType)) {
        containerClasses += ` illus-${styleType}`;
      }

      // HYBRID APPROACH: Never generate buttons in standalone, always generate in dev mode
      const isStandalone = window.STANDALONE_VERSION === true;
      
      if (isStandalone) {
        // STANDALONE: Never generate image buttons at all
        return `
          <div class="${containerClasses}" data-illus-key="${illusKey}" data-style-type="${styleType}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb lazy-load" loading="lazy" style="${imageStyle}"${imageUrl ? ` data-src="${imageUrl}"` : ''} src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjE1MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjBmMGYwIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkNoYXJnZW1lbnQuLi48L3RleHQ+PC9zdmc+">
          </div>
        `;
      } else {
        // DEV MODE: Always generate buttons, let CSS handle visibility
        return `
          <div class="${containerClasses}" data-illus-key="${illusKey}" data-style-type="${styleType}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
            <label class="up">ğŸ“· Ajouter<input accept="image/*" hidden="" type="file"></label>
            <button class="rm" type="button" style="${removeStyle}">ğŸ—‘ Retirer</button>
          </div>
        `;
      }
    }

    buildSpellElement() {
      return `
        <div class="spell-element-section">
          <div class="spell-element-display" style="text-align: center; margin: 0.5rem 0;">
            <span class="element-badge" style="display: inline-block; padding: 4px 12px; background: var(--accent); color: white; border-radius: 16px; font-size: 0.9em; font-weight: 600;">
              ${this.getElementIcon(this.data.element)} ${this.data.element}
            </span>
          </div>
          <div class="spell-element-selector" style="text-align: center; margin: 0.5rem 0; display: none;">
            <label for="spell-element-${this.data.nom}" style="display: block; margin-bottom: 0.25rem; font-weight: 600;">Ã‰lÃ©ment:</label>
            <select id="spell-element-${this.data.nom}" class="editable" data-edit-type="select" data-edit-section="spell-element" data-item-identifier="${this.data.nom}">
              <option value="Feu" ${this.data.element === 'Feu' ? 'selected' : ''}>${this.getElementIcon('Feu')} Feu</option>
              <option value="Eau" ${this.data.element === 'Eau' ? 'selected' : ''}>${this.getElementIcon('Eau')} Eau</option>
              <option value="Terre" ${this.data.element === 'Terre' ? 'selected' : ''}>${this.getElementIcon('Terre')} Terre</option>
              <option value="Air" ${this.data.element === 'Air' ? 'selected' : ''}>${this.getElementIcon('Air')} Air</option>
              <option value="LumiÃ¨re" ${this.data.element === 'LumiÃ¨re' ? 'selected' : ''}>${this.getElementIcon('LumiÃ¨re')} LumiÃ¨re</option>
              <option value="Nuit" ${this.data.element === 'Nuit' ? 'selected' : ''}>${this.getElementIcon('Nuit')} Nuit</option>
              <option value="Divin" ${this.data.element === 'Divin' ? 'selected' : ''}>${this.getElementIcon('Divin')} Divin</option>
              <option value="MalÃ©fique" ${this.data.element === 'MalÃ©fique' ? 'selected' : ''}>${this.getElementIcon('MalÃ©fique')} MalÃ©fique</option>
            </select>
          </div>
        </div>
      `;
    }

    buildMonsterElement() {
      const elementColor = this.getElementColor(this.data.element);
      
      return `
        <div class="monster-element-section">
          <div class="monster-element-display">
            <span class="element-badge" style="
              display: inline-flex; 
              align-items: center; 
              padding: 4px 8px; 
              background: rgba(${parseInt(elementColor.slice(1,3), 16)}, ${parseInt(elementColor.slice(3,5), 16)}, ${parseInt(elementColor.slice(5,7), 16)}, 0.1); 
              border-radius: 6px; 
              border: 1px solid ${elementColor};
              font-size: 0.8em;
              font-weight: 600;
            ">
              <span style="margin-right: 4px;">${this.getElementIcon(this.data.element)}</span>
              <span style="color: ${elementColor};">${this.data.element}</span>
            </span>
          </div>
          <div class="monster-element-selector" style="margin-top: 0.5rem; display: none;">
            <select class="editable" data-edit-type="select" data-edit-section="monster-element" data-item-identifier="${this.data.nom}" style="width: 100%; padding: 4px; border: 1px solid ${elementColor}; border-radius: 4px; font-size: 0.8em;">
              <option value="Feu" ${this.data.element === 'Feu' ? 'selected' : ''}>${this.getElementIcon('Feu')} Feu</option>
              <option value="Eau" ${this.data.element === 'Eau' ? 'selected' : ''}>${this.getElementIcon('Eau')} Eau</option>
              <option value="Terre" ${this.data.element === 'Terre' ? 'selected' : ''}>${this.getElementIcon('Terre')} Terre</option>
              <option value="Air" ${this.data.element === 'Air' ? 'selected' : ''}>${this.getElementIcon('Air')} Air</option>
              <option value="LumiÃ¨re" ${this.data.element === 'LumiÃ¨re' ? 'selected' : ''}>${this.getElementIcon('LumiÃ¨re')} LumiÃ¨re</option>
              <option value="Nuit" ${this.data.element === 'Nuit' ? 'selected' : ''}>${this.getElementIcon('Nuit')} Nuit</option>
              <option value="Divin" ${this.data.element === 'Divin' ? 'selected' : ''}>${this.getElementIcon('Divin')} Divin</option>
              <option value="MalÃ©fique" ${this.data.element === 'MalÃ©fique' ? 'selected' : ''}>${this.getElementIcon('MalÃ©fique')} MalÃ©fique</option>
            </select>
          </div>
        </div>
      `;
    }

    getElementIcon(element) {
      return window.ElementIcons?.[element] || 'âš¡';
    }

    getElementColor(element) {
      return window.ElementColors?.[element]?.color || '#666';
    }

    buildTableTresorCard() {
      const tableIndex = window.TABLES_TRESORS?.tables ? window.TABLES_TRESORS.tables.indexOf(this.data) : 0;
      const totalTables = window.TABLES_TRESORS?.tables?.length || 1;
      
      // Condition amÃ©liorÃ©e pour afficher les boutons d'Ã©dition des fourchettes
      const shouldShowFourchetteButtons = this.shouldShowEditButtons || 
                                         (!window.STANDALONE_VERSION && window.location.search.includes('dev=1')) ||
                                         (document.body.classList.contains('dev-on')) ||
                                         (window.location.protocol === 'file:' && !window.STANDALONE_VERSION) ||
                                         // Condition de fallback pour le dÃ©veloppement
                                         (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1');
      
      // Construire l'affichage des tags
      const tagsDisplay = this.data.tags && this.data.tags.length > 0 
        ? this.data.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';
      
      // Construire l'affichage des fourchettes
      const fourchetteDisplay = this.data.fourchettes?.map((fourchette, index) => {
        const objet = fourchette.objet;
        const objetLink = objet?.type === 'reference' 
          ? `<a href="#" class="object-preview-link" data-object-numero="${objet.numero}" style="color: var(--accent); text-decoration: none;" title="Cliquer pour prÃ©visualiser l'objet #${objet.numero}">ğŸ“¦ ${objet.nom} (NÂ°${objet.numero})</a>`
          : `ğŸ“¦ ${objet?.nom || 'Objet inconnu'}`;
        
        const editButtons = shouldShowFourchetteButtons ? `
          <div class="fourchette-actions" style="margin-left: 8px; display: flex; gap: 4px;">
            ${index > 0 ? `<button class="move-fourchette-up-btn" data-table-name="${this.data.nom}" data-fourchette-index="${index}" title="DÃ©placer vers le haut" style="background: #059669; color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;">â¬†ï¸</button>` : ''}
            ${index < this.data.fourchettes.length - 1 ? `<button class="move-fourchette-down-btn" data-table-name="${this.data.nom}" data-fourchette-index="${index}" title="DÃ©placer vers le bas" style="background: #059669; color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;">â¬‡ï¸</button>` : ''}
            <button class="edit-fourchette-btn" data-table-name="${this.data.nom}" data-fourchette-index="${index}" title="Ã‰diter cette fourchette" style="background: #3b82f6; color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;">âœï¸</button>
            <button class="delete-fourchette-btn" data-table-name="${this.data.nom}" data-fourchette-index="${index}" title="Supprimer cette fourchette" style="background: #dc2626; color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;">ğŸ—‘ï¸</button>
          </div>
        ` : '';
        
        return `
          <div class="fourchette-row" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; margin: 4px 0; background: rgba(139, 92, 23, 0.1); border-radius: 6px; border-left: 3px solid var(--bronze);">
            <div class="fourchette-range" style="font-weight: bold; color: var(--bronze); min-width: 80px;">
              ğŸ² ${fourchette.min || 1}-${fourchette.max || 1}
            </div>
            <div class="fourchette-objet" style="flex: 1; margin-left: 12px;">
              ${objetLink}
            </div>
            ${editButtons}
          </div>
        `;
      }).join('') || '<div style="font-style: italic; color: #666; text-align: center; padding: 1rem;">Aucune fourchette dÃ©finie</div>';

      return `
        <div class="card editable-section" data-section-type="tableTresor" data-table-tresor-name="${this.data.nom}" data-category-name="${this.categoryName}">
          ${this.buildEditableTitle(this.data.nom, 'table-tresor-name')}
          <div style="text-align: center; margin: 0.5rem 0;">
            ${this.buildEditableTagsField(tagsDisplay, 'table-tresor-tags', 'Tags')}
          </div>
          
          <hr style="margin: 1rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.6;">
          
          <div class="fourchettes-section">
            <h4 style="color: var(--bronze); margin: 1rem 0 0.5rem 0; display: flex; align-items: center; gap: 8px;">
              ğŸ² Fourchettes de butin
            </h4>
            <div class="fourchettes-list">
              ${fourchetteDisplay}
            </div>
          </div>
          
          ${shouldShowFourchetteButtons ? `
            <div class="edit-actions" style="margin-top: 1rem; text-align: center; display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center;">
              <button class="table-tresor-add-fourchette btn" data-table-tresor-name="${this.data.nom}" type="button" style="background: var(--accent); color: white;">
                â• Ajouter fourchette
              </button>
              ${this.buildMoveButtons('table-tresor', tableIndex, totalTables)}
            </div>
            ${this.buildDeleteButton('table-tresor')}
          ` : ''}
        </div>
      `;
    }

    buildObjetCard() {
      const favorisButtonHTML = this.buildFavorisButton('objets', this.data.nom);
      
      // Build tags display
      const tagsDisplay = this.data.tags && this.data.tags.length > 0
        ? this.data.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';
      
      return `
        <div class="card editable-section objet-card" data-section-type="objet" data-objet-name="${this.data.nom}" data-numero="${this.data.numero}" data-object-numero="${this.data.numero}" data-category-name="${this.categoryName}">
          ${favorisButtonHTML}
          ${this.buildEditableTitle(this.data.nom, 'objet-name')}
          ${this.data.numero ? `<div style="text-align: center; font-weight: bold; color: var(--bronze); margin-bottom: 0.5rem;">NÂ°${this.data.numero}</div>` : ''}
          
          ${this.buildIllustration(`objet:${this.data.nom}`, this.data.nom, 'objet')}
          
          <div style="text-align: center; margin: 0.5rem 0;">
            ${this.buildEditableTagsField(tagsDisplay, 'objet-tags', 'Tags')}
          </div>
          
          ${this.buildEditableField(this.data.description, 'objet-description', 'Description', { style: 'text-align: center; font-style: italic; margin: 1rem 0;' })}
          
          <hr style="margin: 1rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.6;">
          
          ${this.buildEditableField(this.data.effet, 'objet-effet', 'Effet', { style: 'margin: 1rem 0;' })}
          
          <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 1rem; font-size: 0.9em;">
            ${this.data.prix ? `<div>${this.buildEditableField(this.data.prix, 'objet-prix', 'Prix')}</div>` : ''}
            ${this.data.poids ? `<div>${this.buildEditableField(this.data.poids, 'objet-poids', 'Poids')}</div>` : ''}
          </div>
          
          ${this.buildDeleteButton('objet')}
        </div>
      `;
    }

    buildGenericCard() {
      return `
        <div class="card">
          <h4>${this.data.nom || 'Unknown'}</h4>
          <p>Generic card for type: ${this.type}</p>
        </div>
      `;
    }

    buildEditButton(buttonType) {
      return `<button class="edit-btn" type="button" title="âœï¸ Ã‰diter" data-button-type="${buttonType}">âœï¸</button>`;
    }

    buildDeleteButton(type) {
      const config = this.config;
      const deleteIcon = config?.icons?.delete || 'ğŸ—‘ï¸';
      
      return `
        <div class="delete-button-container" style="margin-top: 1rem; text-align: center;">
          <button class="${type}-delete btn" data-${type}-name="${this.data.nom}" ${this.categoryName ? `data-category-name="${this.categoryName}"` : ''} type="button" style="background: #dc2626; color: white; border: 2px solid #b91c1c;">
            ${deleteIcon} Supprimer ${type}
          </button>
        </div>
      `;
    }

    buildMoveButtons(type, index, totalItems) {
      if (totalItems <= 1) {
        return '';
      }

      return `
        <div class="move-buttons" style="display: flex; gap: 0.5rem; justify-content: center; margin-top: 1rem;">
          <button class="${type}-move-up btn small" data-${type}-name="${this.data.nom}" data-category-name="${this.categoryName}" type="button" style="background: #3b82f6; color: white; padding: 4px 8px; font-size: 0.8em;" ${index === 0 ? 'disabled' : ''}>
            â†‘ Haut
          </button>
          <button class="${type}-move-down btn small" data-${type}-name="${this.data.nom}" data-category-name="${this.categoryName}" type="button" style="background: #3b82f6; color: white; padding: 4px 8px; font-size: 0.8em;" ${index >= totalItems - 1 ? 'disabled' : ''}>
            â†“ Bas
          </button>
        </div>
      `;
    }

    getCategoryData() {
      if (this.type === 'don' && this.categoryName) {
        const categoryData = window.DONS.find(cat => cat.nom === this.categoryName);
        return categoryData || { dons: [] };
      }
      return { [this.type + 's']: [] };
    }

    /**
     * Construit le bouton Ã©toile pour les favoris
     * @param {string} type - Type de contenu ('sorts' ou 'objets')
     * @param {string} nom - Nom de l'Ã©lÃ©ment
     * @returns {string} HTML du bouton favoris
     */
    buildFavorisButton(type, nom) {
      // VÃ©rifier que le FavorisManager est disponible
      if (typeof window.FavorisManager === 'undefined') {
        return '';
      }
      
      return window.FavorisManager.createStarButton(type, nom);
    }
  }

  window.CardBuilder = CardBuilder;

})();
// ============================================================================
// JDR-BAB APPLICATION - PAGE BUILDER
// ============================================================================

(() => {
  "use strict";

  class PageBuilder {
    constructor() {
      // Will use unified dev mode check
    }

    // Simple unified dev mode check
    get shouldShowEditButtons() {
      return JdrApp.utils.isDevMode();
    }

    static getInstance() {
      if (!PageBuilder.instance) {
        PageBuilder.instance = new PageBuilder();
      }
      return PageBuilder.instance;
    }

    buildCategoryPage(type, category) {
      const config = window.ContentTypes[type];
      
      // Gestion spÃ©ciale pour les objets (page unique avec filtres)
      if (type === 'objet' && config.pageType === 'single') {
        return this.buildSingleObjectPage(category);
      }
      
      // Gestion spÃ©ciale pour les tables de trÃ©sors (page unique)
      if (type === 'tableTresor' && config.pageType === 'single') {
        return this.buildSingleTableTresorPage(category);
      }
      
      const pageId = `${config.container}-${this.sanitizeId(category.nom || 'unknown')}`;
      const itemsProperty = this.getItemsProperty(type);
      
      // Get items and sort them for spells
      let items = category[itemsProperty] || [];
      if (type === 'spell') {
        items = this.sortSpellsByLevel([...items]);
      }

      return `
        <article class="" data-page="${pageId}">
          <section>
            ${this.buildCategoryHeader(category, type)}
            ${type === 'spell' ? this.buildSpellLevelFilter() : ''}
            <div style="display: flex; gap: 8px; margin-bottom: 1rem; flex-wrap: wrap;">
              ${this.buildAddButton(type, category.nom)}
              ${this.buildDeleteCategoryButton(type, category.nom)}
            </div>
            <div class="grid cols-2" id="${config.container}-container-${this.sanitizeId(category.nom)}">
              ${items.map((item, index) => 
                CardBuilder.create(type, item, category.nom, index).build()
              ).join('')}
            </div>
            ${this.buildGeneralDonsSection(type, category.nom)}
          </section>
        </article>
      `;
    }
    
    buildSingleObjectPage(objectData) {
      const allObjects = objectData.objets || [];
      
      // Objects page now only shows ID search - all objects hidden by default
      return `
        <article class="" data-page="objets">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2>ğŸ“¦ Objets</h2>
              ${this.buildIllustration('page:objets')}
            </div>
            
            ${this.buildPageDescription('objet')}
            
            ${this.buildIdSearchFilter()}
            
            <div class="grid cols-2" id="objets-container">
              ${allObjects.map((item, index) => {
                const cardHTML = CardBuilder.create('objet', item, 'objets', index).build();
                // Hide all objects by default - only ID search will show them
                return cardHTML.replace('<div class="card', '<div class="card" style="display: none;"');
              }).join('')}
            </div>
            
            ${!window.activeIdSearch ? '<p style="text-align: center; color: #666; margin: 2rem 0;">Utilisez la recherche par ID ci-dessus pour trouver un objet spÃ©cifique.</p>' : ''}
          </section>
        </article>
      `;
    }

    buildGameMasterObjectPage(objectData) {
      const config = window.ContentTypes['objet'];
      const allObjects = objectData.objets || [];
      const availableTags = config?.filterConfig?.availableTags || [];
      
      // Initialize active tags for GM page
      if (!window.ACTIVE_GM_OBJECT_TAGS) {
        window.ACTIVE_GM_OBJECT_TAGS = [];
      }
      const activeTags = window.ACTIVE_GM_OBJECT_TAGS;
      
      // Filter objects based on active tags
      const filteredObjects = activeTags.length === 0 
        ? allObjects // No tags active = show all objects
        : allObjects.filter(obj => {
            // AND logic - object must have ALL active tags
            if (!obj.tags || obj.tags.length === 0) return false;
            return activeTags.every(activeTag => obj.tags.includes(activeTag));
          });
      
      
      const result = `
        <article class="" data-page="gestion-objets">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2>ğŸ“¦ Gestion des Objets</h2>
              ${this.buildIllustration('page:gestion-objets')}
            </div>
            
            <div style="margin: 1rem 0; padding: 1rem; background: var(--card); border-radius: 8px; border-left: 4px solid var(--bronze);">
              <p class="lead">Page dÃ©diÃ©e au MaÃ®tre de jeu pour gÃ©rer, crÃ©er et modifier les objets du jeu. Utilisez les filtres pour organiser votre contenu et les outils de crÃ©ation pour ajouter de nouveaux Ã©quipements.</p>
            </div>
            
            ${this.buildIdSearchFilter()}
            ${this.buildGMTagFilters(activeTags, availableTags)}
            
            <div style="display: flex; gap: 8px; margin-bottom: 1rem; flex-wrap: wrap;">
              ${this.buildAddButton('objet', 'objets')}
              ${this.buildTagsManagerButton()}
            </div>
            
            <div class="grid cols-2" id="gestion-objets-container">
              ${filteredObjects.map((item, index) => 
                CardBuilder.create('objet', item, 'objets', index).build()
              ).join('')}
            </div>
            
            ${filteredObjects.length === 0 ? '<p style="text-align: center; color: #666; margin: 2rem 0;">Aucun objet ne correspond aux filtres sÃ©lectionnÃ©s.</p>' : ''}
          </section>
        </article>
      `;
      
      return result;
    }

    buildSingleMonsterPage(monsterData) {
      let config = window.ContentTypes?.['monster'];
      const allMonsters = monsterData || [];
      const instance = PageBuilder.getInstance(); // CrÃ©er une instance pour accÃ©der aux mÃ©thodes
      
      // Defensive check for config with fallback
      if (!config || !config.filterConfig) {
        console.warn('Monster config not loaded, using fallback defaults');
        console.log('ContentTypes available:', window.ContentTypes ? Object.keys(window.ContentTypes) : 'undefined');
        config = {
          filterConfig: {
            defaultVisibleTags: ['ForÃªt'],
            availableTags: ['ForÃªt', 'Boss', 'Minion', 'Volant', 'Aquatique', 'Terrestre']
          }
        };
      }
      
      // Utiliser le state du filtre s'il existe, sinon les tags par dÃ©faut
      const visibleTags = window.MONSTRES_FILTER_STATE?.visibleTags || config.filterConfig.defaultVisibleTags;
      
      // Filter monsters according to visible tags (AND mode)
      const filteredMonsters = visibleTags.length === 0 
        ? [] // If no tags are visible, show nothing
        : allMonsters.filter(monster => {
            // Check that the monster has the required tags to be visible
            if (!monster.tags) return false;
            
            // In AND mode: monster must have ALL visible tags
            const hasAllVisibleTags = visibleTags.every(tag => monster.tags.includes(tag));
            if (!hasAllVisibleTags) return false;
            
            return true;
          });
      
      return `
        <article class="" data-page="monstres">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2>ğŸ² Monstres</h2>
              ${instance.buildIllustration('page:monstres')}
            </div>
            
            ${instance.buildPageDescription('monster')}
            
            ${instance.buildTagFilters(visibleTags, config.filterConfig.availableTags, 'monster')}
            
            <div style="display: flex; gap: 8px; margin-bottom: 1rem; flex-wrap: wrap;">
              ${instance.buildAddButton('monster', 'monstres')}
              ${instance.buildTagsManagerButton()}
            </div>
            
            <div class="grid cols-2" id="monstres-container">
              ${filteredMonsters.map((item, index) => 
                CardBuilder.create('monster', item, 'monstres', index).build()
              ).join('')}
            </div>
            
            ${filteredMonsters.length === 0 ? '<p style="text-align: center; color: #666; margin: 2rem 0;">Aucun monstre ne correspond aux filtres sÃ©lectionnÃ©s.</p>' : ''}
          </section>
        </article>
      `;
    }

    buildClassPage(classData) {
      const pageId = this.sanitizeId(classData.nom);
      
      return `
        <article class="" data-page="${pageId}" data-page-title="${classData.nom}">
          <section>
            ${this.buildClassHeader(classData)}
            ${this.buildEditableSection(classData.resume, 'class-resume', 'paragraph', classData.nom)}
            <h3>CapacitÃ©s de classe</h3>
            ${this.buildSimpleEditableContent(classData.capacites, 'class-capacites', classData.nom)}
            <h3>Sous-classes</h3>
            <div class="subclass-stack">
              ${classData.sousClasses ? classData.sousClasses.map(sousClasse => 
                CardBuilder.create('subclass', sousClasse, classData.nom).build()
              ).join('') : ''}
            </div>
            ${this.buildAddSubclassButton()}
          </section>
        </article>
      `;
    }

    buildStaticPage(pageId, pageData) {
      const isActive = pageId === 'creation' ? 'active' : '';
      
      // Defense against missing or malformed pageData
      if (!pageData || typeof pageData !== 'object') {
        console.warn('buildStaticPage: invalid pageData', pageData);
        return `<article class="${isActive}" data-page="${pageId}"><section><h2>Page non disponible</h2><p>Les donnÃ©es de cette page ne sont pas disponibles.</p></section></article>`;
      }
      
      const title = pageData.title || pageId;
      const page = pageData.page || pageId;
      
      // Special handling for favoris page
      if (pageId === 'favoris') {
        return this.buildFavorisPage(pageId, pageData);
      }
      
      // Special handling for campaign page
      if (pageId === 'campagne') {
        return this.buildCampaignPage(pageId, pageData);
      }
      
      return `
        <article class="${isActive}" data-page="${page}" data-static-page="true" data-page-title="${title}">
          <section>
            ${this.buildStaticPageHeader(pageData)}
            ${this.buildSections(pageData.sections)}
            ${this.buildAddSectionButton()}
          </section>
        </article>
      `;
    }

    buildCategoryHeader(category, type) {
      const config = window.ContentTypes[type];
      
      // Don't show descriptions for spell categories
      const showDescription = type !== 'spell';
      
      return `
        <div style="text-align:center;margin-bottom:2rem;">
          ${this.buildEditableTitle(category.nom, `${type}-category-name`)}
          ${this.buildIllustration(`${type}category:${category.nom}`)}
        </div>
        ${showDescription ? this.buildEditableSection(category.description, `${type}-category-description`, 'paragraph', category.nom) : ''}
      `;
    }

    buildClassHeader(classData) {
      return `
        <div style="text-align:center;margin-bottom:2rem;">
          ${this.buildEditableTitle(classData.nom, 'class-name', classData.nom)}
          ${this.buildIllustration(`class:${classData.nom}`)}
        </div>
      `;
    }

    buildStaticPageHeader(pageData) {
      const printButton = pageData.page === 'etats' ? this.buildPrintButton() : '';
      
      return `
        <div style="text-align:center;margin-bottom:2rem;">
          <div style="display:inline-flex;align-items:center;gap:8px;">
            <h2 class="editable editable-title" data-edit-type="generic" data-edit-section="page-title">${pageData.title}</h2>
            ${this.buildEditButton('title')}
          </div>
          ${this.buildIllustration(`page:${pageData.page}`)}
          ${printButton}
        </div>
      `;
    }

    buildCompactCampaignHeader(pageData) {
      return `
        <div style="text-align:center;margin-bottom:0.5rem;">
          <div style="display:inline-flex;align-items:center;gap:8px;">
            <h2 class="editable editable-title" data-edit-type="generic" data-edit-section="page-title">${pageData.title}</h2>
            ${this.buildEditButton('title')}
          </div>
        </div>
      `;
    }

    buildEditableTitle(content, editType, editSection = null) {
      return `
        <div style="display:inline-flex;align-items:center;gap:8px;justify-content:center;">
          <h2 class="editable editable-title" data-edit-type="generic" data-edit-section="${editSection || content}">${content}</h2>
          ${this.buildEditButton('title')}
        </div>
      `;
    }

    buildEditableSection(content, editType, sectionType, editSection) {
      const className = sectionType === 'paragraph' ? 'lead editable editable-paragraph' : 'editable editable-field';
      
      return `
        <div class="editable-section" data-section-type="${editType}">
          <p class="${className}" data-edit-type="generic" data-edit-section="${editSection}">${content}</p>
          ${this.buildEditButton(sectionType)}
        </div>
      `;
    }


    buildSimpleEditableContent(content, editType, editSection) {
      // Everything should be HTML format only
      let htmlContent;
      if (typeof content === 'string') {
        htmlContent = content || '';
      } else {
        // Fallback if somehow still array format - convert once and warn
        console.warn('Found array format in buildSimpleEditableContent, converting to HTML:', content);
        if (Array.isArray(content)) {
          htmlContent = '<ul>' + content.map(item => '<li>' + item + '</li>').join('') + '</ul>';
        } else {
          htmlContent = '';
        }
      }
      
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable" data-edit-type="generic" data-edit-section="${editSection}">
            ${htmlContent}
          </div>
          ${this.buildEditButton('section')}
        </div>
      `;
    }

    buildSections(sections) {
      // Defense against undefined sections
      if (!sections || !Array.isArray(sections)) {
        console.warn('buildSections: sections is not an array', sections);
        return '';
      }
      
      return sections.map((section, sectionIndex) => {
        switch (section.type) {
          case 'intro':
            return this.buildIntroSection(section, sectionIndex);
          case 'card':
            return this.buildCardSection(section, sectionIndex);
          case 'grid':
            return this.buildGridSection(section, sectionIndex);
          case 'filters':
            return this.buildFiltersSection(section, sectionIndex);
          case 'monster-list':
            return this.buildMonsterListSection(section, sectionIndex);
          default:
            return `<div><!-- Unknown section type: ${section.type} --></div>`;
        }
      }).join('');
    }

    buildIntroSection(section, sectionIndex) {
      const editSection = `intro-${sectionIndex}`;
      return `
        <div class="editable-section" data-section-type="intro" data-section-index="${sectionIndex}">
          <p class="editable editable-intro" data-edit-type="generic" data-edit-section="${editSection}">${section.content}</p>
          ${this.buildEditButton('section')}
        </div>
        ${this.buildAddParagraphButton('intro')}
      `;
    }

    buildCardSection(cardData, sectionIndex) {
      let cardHTML = `<div class="card editable-section" data-section-type="card" data-section-index="${sectionIndex}">`;
      
      if (cardData.deletable && cardData.sectionType) {
        cardHTML += `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${cardData.id}-title">${cardData.title}</h3>
            ${this.buildEditButton('title')}
            ${this.buildRemoveSectionButton(cardData.sectionType)}
          </div>
        `;
      } else {
        cardHTML += `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${cardData.id}-title">${cardData.title}</h3>
            ${this.buildEditButton('title')}
          </div>
        `;
      }

      // Handle different content formats
      let htmlContent = '';
      let editSection = cardData.id || 'card-' + sectionIndex;
      
      if (typeof cardData.content === 'string') {
        // Direct HTML string
        htmlContent = cardData.content;
      } else if (typeof cardData.content === 'object' && cardData.content?.content) {
        // Object with nested content property
        htmlContent = cardData.content.content;
        if (cardData.content.editSection) {
          editSection = cardData.content.editSection;
        }
      } else {
        htmlContent = cardData.content || '';
      }
      
      cardHTML += `
        <div style="position:relative;">
          <div class="editable" data-edit-type="generic" data-edit-section="${editSection}">${htmlContent}</div>
          ${this.buildEditButton('section')}
        </div>
      `;

      if (cardData.deletable && cardData.sectionName) {
        // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
        cardHTML += `
          <div style="margin-top: 1rem; text-align: center;">
            <button class="section-delete btn small" data-section-name="${cardData.sectionName}" type="button" style="background: #ff6b6b; color: white;">ğŸ—‘ Supprimer section</button>
          </div>
        `;
      }
      
      cardHTML += `</div>`;
      return cardHTML;
    }


    buildContentItem(item) {
      if (item.type === 'paragraph') {
        const content = `
          <div class="editable-section" data-section-type="paragraph">
            <p class="editable editable-paragraph" data-edit-type="generic" data-edit-section="${item.editSection}">${item.content}</p>
            ${this.buildEditButton('paragraph')}
          </div>
        `;
        const addBtn = this.buildAddParagraphButton(item.editSection);
        return content + addBtn;
      }
      return `<div>${item.content}</div>`;
    }

    buildGridSection(gridSection, sectionIndex) {
      const items = gridSection.content || gridSection.items || [];
      if (!Array.isArray(items)) {
        return '<div><!-- Grid items is not an array --></div>';
      }

      const cols = gridSection.cols || 2;
      let gridHTML = `<div class="grid" style="display: grid; grid-template-columns: repeat(${cols}, 1fr); gap: 1rem;">`;
      
      items.forEach((item, itemIndex) => {
        gridHTML += this.buildCardSection(item, `${sectionIndex}-${itemIndex}`);
      });
      
      gridHTML += '</div>';
      return gridHTML;
    }

    buildComplexContent(content) {
      // Generic HTML content - no special processing
      return content || '';
    }


    buildIllustration(illusKey, altText = '') {
      let imageUrl = '';
      let imageStyle = 'display: none;';
      let removeStyle = 'display: none;';
      
      if (window.JdrApp?.modules?.images?.getImageUrl) {
        imageUrl = window.JdrApp.modules.images.getImageUrl(illusKey);
        if (imageUrl) {
          imageUrl = window.JdrApp.modules.images.processImageUrl(imageUrl);
          imageStyle = 'display: inline-block;';
          removeStyle = 'display: inline-flex;';
        }
      }

      // HYBRID APPROACH: Never generate buttons in standalone, always generate in dev mode
      const isStandalone = window.STANDALONE_VERSION === true;
      
      if (isStandalone) {
        // STANDALONE: Never generate image buttons at all
        return `
          <div class="illus" data-illus-key="${illusKey}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
          </div>
        `;
      } else {
        // DEV MODE: Always generate buttons, let CSS handle visibility
        return `
          <div class="illus" data-illus-key="${illusKey}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
            <label class="up">ğŸ“· Ajouter<input accept="image/*" hidden="" type="file"></label>
            <button class="rm" type="button" style="${removeStyle}">ğŸ—‘ Retirer</button>
          </div>
        `;
      }
    }

    buildFiltersSection(section, sectionIndex) {
      const contentType = section.contentType || 'monster';
      
      // Ensure ContentTypes is loaded
      if (!window.ContentTypes) {
        console.warn('ContentTypes not loaded yet, skipping filters');
        return '';
      }
      
      let config = window.ContentTypes[contentType];
      const filterMode = section.filterMode || 'OR';
      
      // Fallback configuration for monster if not loaded
      if (!config && contentType === 'monster') {
        config = {
          filterConfig: {
            availableTags: ["Foret", "Animal", "Humanoid", "Dragon", "Faible", "Puissant", "Boss", "Feu", "Eau", "Terre", "Air", "Rapide", "Poison"],
            defaultVisibleTags: ["Foret", "Animal", "Humanoid"]
          }
        };
      }
      
      if (!config || !config.filterConfig) {
        return '';
      }
      
      const availableTags = config.filterConfig.availableTags || [];
      const defaultTags = config.filterConfig.defaultVisibleTags || [];
      
      return `
        <div class="filter-section" data-content-type="${contentType}" data-filter-mode="${filterMode}">
          <h3>ğŸ” Filtres (${filterMode === 'AND' ? 'ET' : 'OU'})</h3>
          <div class="filter-tags" data-default-tags='${JSON.stringify(defaultTags)}'>
            ${availableTags.map(tag => `
              <label class="filter-tag ${defaultTags.includes(tag) ? 'active' : ''}">
                <input type="checkbox" value="${tag}" ${defaultTags.includes(tag) ? 'checked' : ''}>
                <span>${tag}</span>
              </label>
            `).join('')}
          </div>
          ${this.buildDevModeButtons(contentType)}
        </div>
      `;
    }

    buildMonsterListSection(section, sectionIndex) {
      const contentType = section.contentType || 'monster';
      
      return `
        <div class="monster-list-section" data-content-type="${contentType}">
          <div class="monsters-grid" id="monsters-container">
            <!-- Les monstres seront gÃ©nÃ©rÃ©s par JavaScript -->
          </div>
        </div>
      `;
    }

    buildDevModeButtons(contentType) {
      // Ensure ContentTypes is loaded for proper button generation
      if (!window.ContentTypes) {
        return '';
      }
      
      // For monster type, generate buttons even if config is missing (they'll work with fallback)
      if (contentType !== 'monster' && !window.ContentTypes[contentType]) {
        return '';
      }
      
      // Use the same approach as modal buttons - conditional rendering based on dev mode
      const isDevMode = JdrApp.utils.isDevMode();
      const displayStyle = isDevMode ? 'block' : 'none';
      
      return `
        <div class="dev-mode-buttons" style="margin-top: 1rem; display: ${displayStyle};" data-dev-only="true">
          <button class="btn btn-small add-${contentType}-btn">â• Ajouter ${contentType === 'monster' ? 'un monstre' : 'un Ã©lÃ©ment'}</button>
          <button class="btn btn-small manage-tags-btn" data-content-type="${contentType}">ğŸ·ï¸ GÃ©rer les tags</button>
        </div>
      `;
    }

    buildEditButton(type) {
      const titles = {
        title: 'Ã‰diter le titre',
        paragraph: 'Ã‰diter ce paragraphe',
        field: 'Ã‰diter ce champ',
        list: 'Ã‰diter cette liste',
        section: 'Ã‰diter cette section'
      };

      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="edit-btn edit-${type}-btn" title="${titles[type] || 'Ã‰diter'}">âœï¸</button>`;
    }

    buildAddButton(type, categoryName) {
      const config = window.ContentTypes[type];
      const icon = config?.icons?.add || 'â•';
      
      // ALWAYS generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="${type}-add btn" data-category-name="${categoryName}" type="button" style="background: var(--accent); color: white;">${icon} Ajouter un ${type === 'spell' ? 'sort' : type === 'don' ? 'don' : type === 'monster' ? 'monstre' : 'Ã©lÃ©ment'}</button>`;
    }

    buildDeleteCategoryButton(type, categoryName) {
      const config = window.ContentTypes[type];
      const deleteIcon = config?.icons?.delete || 'ğŸ—‘ï¸';
      
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="${type}-category-delete btn" data-category-name="${categoryName}" data-category-type="${type}" type="button" style="background: #dc2626; color: white;">${deleteIcon} Supprimer catÃ©gorie</button>`;
    }

    buildAddSubclassButton() {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<div class="add-subclass-btn">â• Ajouter une sous-classe</div>`;
    }

    buildAddSectionButton() {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<div class="add-paragraph-btn" data-target="section">â• Ajouter une nouvelle section</div>`;
    }

    buildAddParagraphButton(target) {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<div class="add-paragraph-btn" data-target="${target}">â• Ajouter un paragraphe</div>`;
    }

    buildRemoveSectionButton(sectionType) {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="remove-section-btn" data-section-type="${sectionType}" type="button" style="background: #dc2626; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 12px;">ğŸ—‘ Supprimer section</button>`;
    }

    getItemsProperty(type) {
      switch (type) {
        case 'spell': return 'sorts';
        case 'don': return 'dons';
        case 'objet': return 'objets';
        case 'class': return 'sousClasses';
        default: return 'items';
      }
    }

    // Extract level number from prerequis text
    extractLevelFromPrerequisite(prerequis) {
      if (!prerequis) return 0;
      const match = prerequis.match(/Niveau (\d+)/i);
      return match ? parseInt(match[1], 10) : 0;
    }

    // Sort spells by level (prerequisite level)
    sortSpellsByLevel(spells) {
      return spells.sort((a, b) => {
        const levelA = this.extractLevelFromPrerequisite(a.prerequis);
        const levelB = this.extractLevelFromPrerequisite(b.prerequis);
        return levelA - levelB;
      });
    }

    // Build spell level filter UI
    buildSpellLevelFilter() {
      return `
        <div class="spell-level-filter" style="margin: 1rem 0; padding: 1rem; background: var(--card); border: 2px solid var(--rule); border-radius: 12px;">
          <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
            <label style="font-weight: 600; color: var(--accent-ink);">
              ğŸ¯ Filtrer par niveau maximum :
            </label>
            <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
              <input 
                type="number" 
                id="spell-level-filter" 
                min="0" 
                max="20" 
                value="20"
                style="width: 80px; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px; text-align: center; font-weight: 600;"
              >
              <button 
                id="reset-spell-filter" 
                class="btn small" 
                style="background: var(--bronze); color: white; padding: 0.5rem 1rem;"
                title="RÃ©initialiser le filtre"
              >
                ğŸ”„ Tout afficher
              </button>
              <!-- Texte du filtre ajoutÃ© dynamiquement par SpellFilter.js -->
            </div>
          </div>
        </div>
      `;
    }

    buildIdSearchFilter() {
      const isIdSearchActive = window.activeIdSearch || false;
      const isDevMode = JdrApp.utils.isDevMode();
      const searchBorderColor = isIdSearchActive ? '#16a34a' : 'var(--rule)';
      const searchBoxShadow = isIdSearchActive ? 'box-shadow: 0 0 8px rgba(22, 163, 74, 0.3);' : '';
      const searchIndicator = isIdSearchActive ? 'ğŸ¯ ' : 'ğŸ” ';
      const buttonText = isIdSearchActive ? 'ğŸ”„ Affichage normal' : 'ğŸ”„ Tout afficher';
      const buttonTitle = isIdSearchActive ? 'Retourner Ã  l\'affichage normal avec filtres' : 'Effacer la recherche et afficher tous les objets';
      
      return `
        <div class="id-search-filter" style="margin: 0.5rem 0; background: var(--card); border: 2px solid ${searchBorderColor}; border-radius: 12px; display: flex; flex-direction: column; ${searchBoxShadow}">
          <div style="display: flex; align-items: center; justify-content: center; gap: 1rem; flex-wrap: wrap; padding: 0.375rem; min-height: 2.5rem;">
            <label for="id-search-input" style="font-weight: 600; color: var(--accent-ink); white-space: nowrap; display: flex; align-items: center; height: 100%;">
              ${searchIndicator}Recherche par ID :
            </label>
            <div style="display: flex; align-items: center; gap: 0.5rem; height: 100%;">
              <input 
                type="number" 
                id="id-search-input" 
                min="1" 
                placeholder="NumÃ©ro d'objet (ex: 42)"
                style="padding: 0.2rem; border: 1px solid ${searchBorderColor}; border-radius: 6px; font-size: 0.95em; width: 150px; height: 2rem; display: flex; align-items: center;"
              >
              <button 
                id="search-object-btn" 
                class="btn small" 
                style="background: var(--primary-color); color: white; padding: 0.2rem 0.4rem; white-space: nowrap; font-size: 0.9em; display: flex; align-items: center; height: 2rem; justify-content: center;"
                title="Rechercher cet objet"
              >
                ğŸ” Chercher
              </button>
              <button 
                id="clear-id-search" 
                class="btn small" 
                style="background: var(--bronze); color: white; padding: 0.2rem 0.4rem; white-space: nowrap; font-size: 0.9em; display: ${!isDevMode ? 'none' : 'flex'}; align-items: center; height: 2rem; justify-content: center;"
                title="${buttonTitle}"
              >
                ${buttonText}
              </button>
            </div>
          </div>
          <div id="id-search-result" style="padding: 0 0.375rem 0.375rem; font-size: 0.85em; color: var(--paper-muted); min-height: 0.5em; line-height: 1.2; text-align: center;">
            <!-- RÃ©sultat de la recherche affichÃ© ici -->
          </div>
        </div>
      `;
    }

    buildPageDescription(type) {
      const config = window.ContentTypes[type];
      
      if (!config || !config.pageDescription) {
        return '';
      }
      
      const pageDesc = config.pageDescription;
      
      // Obtenir la description de maniÃ¨re unifiÃ©e
      let description = '';
      
      if (pageDesc.dataSource === 'external') {
        // Utilisation d'un fichier externe via dataKey
        const dataObj = window[pageDesc.dataKey];
        if (!dataObj) {
          // CrÃ©er l'objet externe s'il n'existe pas
          window[pageDesc.dataKey] = { [pageDesc.storageKey]: pageDesc.defaultValue };
        }
        description = window[pageDesc.dataKey][pageDesc.storageKey] || pageDesc.defaultValue;
      } else {
        // Source de donnÃ©es intÃ©grÃ©e dans le dataKey principal
        const mainDataKey = config.dataKey;
        const mainData = window[mainDataKey];
        
        if (!mainData) {
          console.warn(`Main data key ${mainDataKey} not found for type ${type}`);
          description = pageDesc.defaultValue;
        } else {
          // Initialiser la description si elle n'existe pas
          if (!mainData[pageDesc.storageKey]) {
            mainData[pageDesc.storageKey] = pageDesc.defaultValue;
          }
          description = mainData[pageDesc.storageKey];
        }
      }
      
      const cssClass = `${type}-category-description`;
      const sectionType = `${type}-category-description`;
      
      return `
        <div class="${cssClass}" style="margin: 1rem 0; padding: 1rem; background: var(--card); border-radius: 8px; border-left: 4px solid var(--bronze);">
          <div class="editable-section" data-section-type="${sectionType}">
            <p class="lead editable editable-paragraph" data-edit-type="generic" data-edit-section="${pageDesc.editSection}">${description}</p>
            ${this.buildEditButton('section')}
          </div>
        </div>
      `;
    }

    buildTagFilters(activeTags, availableTags, context = 'objet') {
      if (!availableTags || availableTags.length === 0) {
        return '';
      }

      const filterTitle = context === 'monster' ? 'ğŸ¯ Filtrer les monstres par tags :' : 
                         context === 'tableTresor' ? 'ğŸ¯ Filtrer les tables par tags :' : 
                         'ğŸ¯ Filtrer par tags :';

      return `
        <div class="tag-filters" style="margin: 1rem 0; padding: 1rem; background: var(--card); border: 2px solid var(--rule); border-radius: 12px;">
          <div style="margin-bottom: 1rem;">
            <h4 style="margin: 0 0 0.5rem 0; color: var(--accent-ink); font-size: 1em;">
              ${filterTitle}
            </h4>
            <p style="margin: 0; font-size: 0.85em; color: var(--paper-muted); font-style: italic;">
              Cliquez sur les tags pour filtrer le contenu
            </p>
          </div>
          <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
            ${availableTags.map(tag => {
              const isActive = activeTags && activeTags.includes(tag);
              const bgColor = isActive ? '#16a34a' : '#6b7280';
              const opacity = isActive ? '1' : '0.6';
              const prefix = isActive ? 'âœ“ ' : '';
              
              return `
                <button 
                  class="filter-chip" 
                  data-tag="${tag}"
                  style="
                    padding: 0.25rem 0.75rem;
                    border: none;
                    border-radius: 20px;
                    background: ${bgColor};
                    color: white;
                    opacity: ${opacity};
                    font-size: 0.85em;
                    cursor: pointer;
                    transition: all 0.2s ease;
                  "
                  title="${isActive ? 'Cliquez pour dÃ©sactiver' : 'Cliquez pour activer'}"
                >
                  ${prefix}${tag}
                </button>
              `;
            }).join('')}
          </div>
        </div>
      `;
    }

    buildGMTagFilters(activeTags, availableTags) {
      if (!availableTags || availableTags.length === 0) {
        return '';
      }

      return `
        <div class="gm-tag-filters" style="margin: 1rem 0; padding: 1rem; background: var(--card); border: 2px solid var(--bronze); border-radius: 12px;">
          <div style="margin-bottom: 1rem;">
            <h4 style="margin: 0 0 0.5rem 0; color: var(--accent-ink); font-size: 1em;">
              ğŸ¯ Filtrer les objets par tags (Mode GM) :
            </h4>
            <p style="margin: 0; font-size: 0.85em; color: var(--paper-muted); font-style: italic;">
              Cliquez sur les tags pour filtrer les objets. Logique ET (tous les tags sÃ©lectionnÃ©s requis).
            </p>
          </div>
          <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
            ${availableTags.map(tag => {
              const isActive = activeTags && activeTags.includes(tag);
              const bgColor = isActive ? '#16a34a' : '#6b7280';
              const opacity = isActive ? '1' : '0.6';
              const prefix = isActive ? 'âœ“ ' : '';
              
              return `
                <button 
                  class="gm-filter-chip" 
                  data-tag="${tag}"
                  style="
                    padding: 0.25rem 0.75rem;
                    border: none;
                    border-radius: 20px;
                    background: ${bgColor};
                    color: white;
                    opacity: ${opacity};
                    font-size: 0.85em;
                    cursor: pointer;
                    transition: all 0.2s ease;
                  "
                  title="${isActive ? 'Cliquez pour dÃ©sactiver' : 'Cliquez pour activer'}"
                >
                  ${prefix}${tag}
                </button>
              `;
            }).join('')}
          </div>
        </div>
      `;
    }
    
    // SUPPRIMÃ‰: buildFilterManagerButton - fonctionnalitÃ© retirÃ©e

    buildTagsManagerButton() {
      // Only show in dev mode - use direct utils check
      if (!JdrApp.utils.isDevMode()) {
        return '';
      }
      return `<button class="tags-manager-btn btn" type="button" style="background: #dc2626; color: white; border: 2px solid #b91c1c;">ğŸ·ï¸ GÃ©rer les tags</button>`;
    }

    buildGeneralDonsSection(type, categoryName) {
      // Only add General Dons section for 'don' type pages, and not for the 'Generaux' category itself
      if (type !== 'don' || categoryName === 'Generaux') {
        return '';
      }

      // Find the "Generaux" category in the DONS data
      const generalCategory = window.DONS?.find(cat => cat.nom === 'Generaux');
      if (!generalCategory || !generalCategory.dons || generalCategory.dons.length === 0) {
        return '';
      }

      // Generate cards for all general dons
      const generalDonsCards = generalCategory.dons.map((don, index) => 
        CardBuilder.create('don', don, 'Generaux', index).build()
      ).join('');

      return `
        <div style="margin-top: 2rem; padding-top: 1.5rem; border-top: 2px solid var(--rule);">
          <h3 style="color: var(--bronze); margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
            ğŸ–ï¸ Dons GÃ©nÃ©raux
          </h3>
          <p style="margin-bottom: 1.5rem; font-style: italic; color: var(--accent-ink); opacity: 0.8;">
            Ces dons sont accessibles Ã  toutes les classes et peuvent complÃ©ter votre build.
          </p>
          <div class="grid cols-2">
            ${generalDonsCards}
          </div>
        </div>
      `;
    }

    // SUPPRIMÃ‰: buildFilterManagerButton - fonctionnalitÃ© retirÃ©e
    
    buildTagsManagerButton() {
      // ALWAYS generate the button - CSS will control visibility based on body.dev-on/dev-off  
      if (window.STANDALONE_VERSION) return '';
      
      return `<button class="tags-manager-btn btn" type="button" style="background: #dc2626; color: white; border: 2px solid #b91c1c;">ğŸ·ï¸ GÃ©rer les tags</button>`;
    }

    buildPrintButton() {
      return `
        <div style="margin-top: 1rem;">
          <button id="print-etats-btn" class="print-button" type="button" title="Imprimer la liste des Ã©tats">
            ğŸ–¨ï¸ Version imprimable
          </button>
        </div>
      `;
    }

    buildSingleTableTresorPage(tableData) {
      let config = window.ContentTypes?.['tableTresor'];
      const allTables = tableData.tables || [];
      const instance = PageBuilder.getInstance();
      
      // Defensive check for config with fallback
      if (!config || !config.filterConfig) {
        console.warn('TableTresor config not loaded, using fallback defaults');
        config = {
          filterConfig: {
            defaultVisibleTags: ['Commun'],
            availableTags: ['Faible', 'Commun', 'Rare', 'Ã‰pique', 'LÃ©gendaire', 'Boss', 'HumanoÃ¯de', 'BÃªte', 'Dragon', 'Mort-vivant', 'Ã‰lÃ©mentaire']
          }
        };
      }
      
      // Priority: Use saved metadata tags as single source of truth
      let availableTags = window.TABLES_TRESORS?._metadata?.availableTags || [];
      
      // Utiliser le state du filtre s'il existe, sinon les tags par dÃ©faut qui existent vraiment
      let defaultVisibleTags = config.filterConfig.defaultVisibleTags || [];
      // Filter defaultVisibleTags to only include tags that actually exist in metadata
      if (availableTags.length > 0) {
        defaultVisibleTags = defaultVisibleTags.filter(tag => availableTags.includes(tag));
      }
      const visibleTags = window.TABLES_TRESORS_FILTER_STATE?.visibleTags || defaultVisibleTags;
      
      
      // Filter tables according to visible tags
      const filterMode = config.filterMode || 'OR';
      const filteredTables = visibleTags.length === 0 
        ? allTables // If no tags are visible, show all tables
        : allTables.filter(table => {
            // Check that the table has tags when filtering is active
            if (!table.tags || table.tags.length === 0) return false;
            
            if (filterMode === 'AND') {
              // In AND mode: table must have ALL visible tags
              return visibleTags.every(tag => table.tags.includes(tag));
            } else {
              // In OR mode: table must have AT LEAST ONE visible tag
              return visibleTags.some(tag => table.tags.includes(tag));
            }
          });
          
      
      return `
        <article class="" data-page="tables-tresors">
          <section>
            <header class="page-header">
              <h1 class="page-title" style="display: flex; align-items: center; gap: 0.5rem;">
                ğŸ’ Tables de trÃ©sors
              </h1>
            </header>
            
            ${instance.buildPageDescription('tableTresor')}
            
            ${instance.buildTagFilters(visibleTags, availableTags, 'tableTresor')}
            
            <div data-dev-only class="dev-buttons-container">
              ${instance.buildAddButton('tableTresor', 'tables')}
              ${instance.buildTagsManagerButton()}
            </div>
            </div>
            
            <div class="grid cols-1" id="tables-tresors-container" style="gap: 1.5rem;">
              ${filteredTables.map((table, index) => 
                CardBuilder.create('tableTresor', table, 'tables', index).build()
              ).join('')}
            </div>
            
            ${filteredTables.length === 0 ? `
              <div style="text-align: center; padding: 2rem; background: var(--card); border-radius: 12px; margin: 1rem 0;">
                <p style="color: var(--accent-ink); font-size: 1.1em; margin-bottom: 1rem;">
                  ğŸ’ ${allTables.length === 0 ? 'Aucune table de trÃ©sor dÃ©finie' : 'Aucune table ne correspond aux filtres sÃ©lectionnÃ©s'}
                </p>
                <p style="color: var(--paper-muted); font-style: italic;">
                  ${allTables.length === 0 
                    ? (instance.shouldShowEditButtons ? 'Utilisez le bouton "Ajouter une table de trÃ©sor" ci-dessus pour crÃ©er votre premiÃ¨re table.' : 'Le MaÃ®tre de jeu peut crÃ©er des tables de trÃ©sors en mode dÃ©veloppement.')
                    : 'Modifiez vos filtres pour voir d\'autres tables de trÃ©sors.'
                  }
                </p>
              </div>
            ` : ''}
            
            <div style="margin-top: 1rem; padding: 1rem; background: var(--card); border-radius: 8px; border-left: 4px solid var(--bronze);">
              <p style="color: var(--accent-ink); margin: 0;">
                ğŸ“Š RÃ©sultats: ${filteredTables.length} table${filteredTables.length !== 1 ? 's' : ''} affichÃ©e${filteredTables.length !== 1 ? 's' : ''} sur ${allTables.length} au total
              </p>
            </div>
          </section>
        </article>
      `;
    }

    buildCampaignPage(pageId, pageData) {
      const campaigns = pageData.subPages || {};
      const campaignList = Object.keys(campaigns);
      
      // Get current selections (default to first available or empty)
      const selectedCampaign = window.JdrApp?.state?.selectedCampaign || (campaignList.length > 0 ? campaignList[0] : null);
      const currentCampaign = selectedCampaign && campaigns[selectedCampaign] ? campaigns[selectedCampaign] : null;
      const subPageList = currentCampaign ? Object.keys(currentCampaign.subPages || {}) : [];
      const selectedSubPage = window.JdrApp?.state?.selectedSubPage || (subPageList.length > 0 ? subPageList[0] : null);
      const currentSubPage = selectedSubPage && currentCampaign?.subPages?.[selectedSubPage] ? currentCampaign.subPages[selectedSubPage] : null;
      
      return `
        <article class="" data-page="${pageId}" data-static-page="true" data-page-title="${pageData.title}">
          <section>
            ${pageId === 'campagne' ? this.buildCompactCampaignHeader(pageData) : this.buildStaticPageHeader(pageData)}
            ${pageId === 'campagne' ? '' : this.buildSections(pageData.sections)}
            
            <div class="campaign-manager" style="margin-top: 0.5rem;">
              <!-- Campaign Management Controls -->
              <div class="campaign-controls" style="background: var(--card); border-radius: 12px; padding: 1rem; margin-bottom: 0.5rem;">
                <div style="display: flex; justify-content: center; align-items: center; margin-bottom: 0.5rem;">
                  <div class="dev-buttons" style="display: flex; gap: 8px;">
                    <button class="btn primary small dev-only" onclick="JdrApp.modules.ui.addCampaign()" style="display: none;">
                      â• Nouvelle Campagne
                    </button>
                  </div>
                </div>
                
                ${campaignList.length === 0 ? `
                  <div style="text-align: center; padding: 2rem;">
                    <p style="color: var(--accent-ink); font-size: 1.1em; margin-bottom: 1rem;">
                      ğŸ“– Aucune campagne crÃ©Ã©e
                    </p>
                    <p style="color: var(--paper-muted); font-style: italic;">
                      <span class="dev-only" style="display: none;">Utilisez le bouton "Nouvelle Campagne" ci-dessus pour crÃ©er votre premiÃ¨re campagne.</span>
                      <span class="non-dev-only">Le MaÃ®tre de jeu peut crÃ©er des campagnes en mode dÃ©veloppement.</span>
                    </p>
                  </div>
                ` : `
                  <!-- Campaign Selector -->
                  <div class="campaign-selector" style="margin-bottom: 0.5rem; text-align: center;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--accent-ink); text-align: center;">
                      ğŸ“š Campagne Active:
                    </label>
                    <div style="display: inline-flex; align-items: center; gap: 8px;">
                      <select id="campaignSelector" onchange="JdrApp.modules.ui.selectCampaign(this.value)" 
                              style="padding: 8px; border-radius: 6px; border: 2px solid var(--rule); background: var(--paper); font-family: inherit;">
                        ${campaignList.map(name => 
                          `<option value="${name}" ${name === selectedCampaign ? 'selected' : ''}>${name}</option>`
                        ).join('')}
                      </select>
                      <button class="btn danger small dev-only" onclick="JdrApp.modules.ui.deleteCampaign('${selectedCampaign}')" 
                              style="display: none;" ${!selectedCampaign ? 'disabled' : ''}>
                        ğŸ—‘ï¸ Supprimer
                      </button>
                    </div>
                  </div>
                `}
              </div>
              <!-- Campaign Content -->
              ${selectedCampaign && currentCampaign ? this.buildSelectedCampaignContent(selectedCampaign, currentCampaign, selectedSubPage, currentSubPage) : ''}
            </div>
            
            ${this.buildAddSectionButton()}
          </section>
        </article>
      `;
    }

    buildSelectedCampaignContent(campaignName, campaign, selectedSubPage, currentSubPage) {
      const subPageList = campaign.subPages ? Object.keys(campaign.subPages) : [];
      
      return `
        <div class="selected-campaign" style="background: var(--card); border-radius: 12px; padding: 1.5rem; border-left: 4px solid var(--bronze);">
          <!-- Campaign Header -->
          <div class="campaign-header" style="margin-bottom: 1.5rem; border-bottom: 2px solid var(--rule); padding-bottom: 1rem;">
            <div style="display: flex; align-items: center; margin-bottom: 0.5rem;">
              <h3 class="editable" data-edit-type="generic" data-edit-section="campaign-${campaignName}-name" 
                  style="margin: 0; color: var(--accent-ink); flex: 1;">
                ${campaignName}
              </h3>
              ${this.buildEditButton('title')}
            </div>
          </div>
          
          <!-- Sub-pages Section -->
          <div class="campaign-subpages">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
              <button class="btn primary small dev-only" onclick="JdrApp.modules.ui.addCampaignSubPage('${campaignName}')" style="display: none;">
                â• Nouvelle Sous-page
              </button>
            </div>
            
            ${subPageList.length === 0 ? `
              <div style="text-align: center; padding: 2rem; background: var(--paper-light); border-radius: 8px; margin-bottom: 1rem;">
                <p style="color: var(--paper-muted); font-style: italic;">
                  Aucune sous-page crÃ©Ã©e pour cette campagne.
                </p>
                <p class="dev-only" style="color: var(--paper-muted); font-size: 0.9em; display: none;">
                  Utilisez le bouton "Nouvelle Sous-page" pour commencer.
                </p>
              </div>
            ` : `
              <!-- Sub-page Selector -->
              <div class="subpage-selector" style="margin-bottom: 1.5rem;">
                <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--accent-ink);">
                  ğŸ“ Sous-page Active:
                </label>
                <select id="subPageSelector" onchange="JdrApp.modules.ui.selectSubPage(this.value)" 
                        style="padding: 8px; border-radius: 6px; border: 2px solid var(--rule); background: var(--paper); font-family: inherit;">
                  ${subPageList.map(name => 
                    `<option value="${name}" ${name === selectedSubPage ? 'selected' : ''}>${name}</option>`
                  ).join('')}
                </select>
                <button class="btn danger small dev-only" onclick="JdrApp.modules.ui.deleteCampaignSubPage('${campaignName}', '${selectedSubPage}')" 
                        style="margin-left: 8px; display: none;" ${!selectedSubPage ? 'disabled' : ''}>
                  ğŸ—‘ï¸ Supprimer
                </button>
              </div>
              
              <!-- Sub-page Content -->
              ${selectedSubPage && currentSubPage ? this.buildSelectedSubPageContent(campaignName, selectedSubPage, currentSubPage) : ''}
            `}
          </div>
        </div>
      `;
    }

    buildSelectedSubPageContent(campaignName, subPageName, subPage) {
      return `
        <div class="selected-subpage" style="background: var(--paper-light); border-radius: 8px; padding: 1.5rem; border: 2px solid var(--rule);">
          <!-- Sub-page Header -->
          <div class="subpage-header" style="margin-bottom: 1rem; border-bottom: 1px solid var(--rule); padding-bottom: 0.75rem;">
            <div style="display: flex; align-items: center;">
              <h5 class="editable" data-edit-type="generic" data-edit-section="subpage-${campaignName}-${subPageName}-title" 
                  style="margin: 0; color: var(--accent-ink); font-size: 1.2em; flex: 1;">
                ğŸ“„ ${subPage.title || subPageName}
              </h5>
              ${this.buildEditButton('title')}
            </div>
          </div>
          
          <!-- Sub-page Content -->
          <div style="display: flex; align-items: flex-start;">
            <div class="subpage-content editable" data-edit-type="generic" data-edit-section="subpage-${campaignName}-${subPageName}-content" 
                 style="line-height: 1.6; min-height: 200px; flex: 1;">
              ${subPage.content || '<p>Contenu de la sous-page...</p>'}
            </div>
            ${this.buildEditButton('section')}
          </div>
        </div>
      `;
    }

    buildEditButton(buttonType) {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="edit-btn" type="button" style="background: var(--accent); color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 12px; margin-left: 8px;">âœï¸</button>`;
    }
    

    sanitizeId(str) {
      return str.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    }

    /**
     * Construit la page spÃ©ciale des favoris
     * @param {string} pageId - ID de la page
     * @param {Object} pageData - DonnÃ©es de la page
     * @returns {string} HTML de la page favoris
     */
    buildFavorisPage(pageId, pageData) {
      const title = pageData.title || 'Favoris';
      
      return `
        <article class="" data-page="${pageId}" data-static-page="true" data-page-title="${title}">
          <section>
            ${this.buildStaticPageHeader(pageData)}
            
            <div class="favoris-section favoris-collapsible" id="favoris-objets-section">
              <div class="favoris-header" onclick="this.parentElement.classList.toggle('collapsed')">
                <h2>ğŸ“¦ Objets favoris</h2>
                <span class="favoris-toggle">â–¼</span>
              </div>
              <div class="favoris-content">
                <div id="favoris-objets-container" class="favoris-grid">
                  <!-- Les objets favoris seront affichÃ©s ici dynamiquement -->
                </div>
                <div id="favoris-objets-empty" class="favoris-empty" style="display: none;">
                  <p>Aucun objet en favoris</p>
                  <p style="font-size: 0.9em;">Cliquez sur l'Ã©toile â­ Ã  cÃ´tÃ© d'un objet pour l'ajouter Ã  vos favoris</p>
                </div>
              </div>
            </div>

            <div class="favoris-section favoris-collapsible" id="favoris-sorts-section">
              <div class="favoris-header" onclick="this.parentElement.classList.toggle('collapsed')">
                <h2>ğŸ”® Sorts favoris</h2>
                <span class="favoris-toggle">â–¼</span>
              </div>
              <div class="favoris-content">
                <div id="favoris-sorts-container" class="favoris-grid">
                  <!-- Les sorts favoris seront affichÃ©s ici dynamiquement -->
                </div>
                <div id="favoris-sorts-empty" class="favoris-empty" style="display: none;">
                  <p>Aucun sort en favoris</p>
                  <p style="font-size: 0.9em;">Cliquez sur l'Ã©toile â­ Ã  cÃ´tÃ© d'un sort pour l'ajouter Ã  vos favoris</p>
                </div>
              </div>
            </div>
          </section>
        </article>
      `;
    }
  }

  window.PageBuilder = PageBuilder.getInstance();

})();
// ============================================================================
// JDR-BAB APPLICATION - UTILITIES MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // DEV MODE UTILITIES
  // ========================================
  JdrApp.utils.isDevMode = function() {
    // Simple check - if it's standalone, dev mode is always false
    if (window.STANDALONE_VERSION) return false;
    
    // Use the editor's actual state instead of CSS classes for reliability
    if (JdrApp.modules && JdrApp.modules.editor) {
      return JdrApp.modules.editor.isDevMode;
    }
    
    // Fallback: check body class if editor not available yet
    return document.body.classList.contains('dev-on');
  };

  // ========================================
  // CENTRALIZED EVENT MANAGEMENT
  // ========================================
  JdrApp.utils.events = {
    listeners: new Map(),
    
    // Centralized event registration
    register(type, selector, handler, options = {}) {
      const key = `${type}-${selector || 'window'}-${Date.now()}`;
      const wrapper = (e) => {
        if (!selector) {
          handler(e);
        } else {
          // GÃ©rer les sÃ©lecteurs spÃ©ciaux comme [class$="-add"]
          if (this.matchesSelector(e.target, selector)) {
            handler(e);
          }
        }
      };
      
      if (selector) {
        document.addEventListener(type, wrapper, options);
      } else {
        window.addEventListener(type, wrapper, options);
      }
      
      this.listeners.set(key, { type, wrapper, options });
      return key;
    },

    // Helper pour matcher les sÃ©lecteurs complexes
    matchesSelector(element, selector) {
      // GÃ©rer les sÃ©lecteurs d'attributs comme [class$="-add"]
      if (selector.startsWith('[class$="') && selector.endsWith('"]')) {
        const suffix = selector.slice(9, -2); // Extraire "-add" de '[class$="-add"]'
        return element.className && element.className.split(' ').some(cls => cls.endsWith(suffix));
      }
      
      // GÃ©rer les sÃ©lecteurs d'attributs comme [class*="something"]
      if (selector.startsWith('[class*="') && selector.endsWith('"]')) {
        const substring = selector.slice(9, -2); // Extraire "something" 
        return element.className && element.className.includes(substring);
      }
      
      // Utiliser la mÃ©thode native pour les autres sÃ©lecteurs
      try {
        return element.matches(selector) || element.closest(selector);
      } catch (e) {
        // Fallback pour les sÃ©lecteurs invalides
        return false;
      }
    },
    
    // Delayed execution manager
    delayed: new Map(),
    timeout(key, fn, delay = 0) {
      if (this.delayed.has(key)) {
        clearTimeout(this.delayed.get(key));
      }
      const id = setTimeout(() => {
        fn();
        this.delayed.delete(key);
      }, delay);
      this.delayed.set(key, id);
    },
    
    // Common event handlers
    onDOMReady(fn) {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', fn);
      } else {
        fn();
      }
    },
    
    onHashChange(fn) {
      window.addEventListener('hashchange', fn);
    },
    
    onRouteChange(fn) {
      this.onHashChange(() => this.timeout('route-change', fn, 0));
      this.onDOMReady(() => this.timeout('dom-ready-route', fn, 0));
    }
  };

  // ========================================
  // DOM UTILITIES LIBRARY
  // ========================================
  JdrApp.utils.dom = {
    // Common selectors
    $(selector) { return document.querySelector(selector); },
    $(selector) { return document.querySelectorAll(selector); },
    
    // Element creation with common patterns
    create(tag, className = '', innerHTML = '', attributes = {}) {
      const el = document.createElement(tag);
      if (className) el.className = className;
      if (innerHTML) el.innerHTML = innerHTML;
      Object.entries(attributes).forEach(([key, value]) => {
        el.setAttribute(key, value);
      });
      return el;
    },
    
    
    // Safe innerHTML replacement
    safeSetHTML(element, html) {
      if (element) {
        element.innerHTML = html;
      }
    },
    
    // Safe text content setting
    safeSetText(element, text) {
      if (element) {
        element.textContent = text;
      }
    },
    
    // Toggle class utility
    toggleClass(element, className, force = null) {
      if (element) {
        if (force !== null) {
          element.classList.toggle(className, force);
        } else {
          element.classList.toggle(className);
        }
      }
    },
    
    // Show/hide utilities
    show(element, display = 'block') {
      if (element) {
        element.style.display = display;
      }
    },
    
    hide(element) {
      if (element) {
        element.style.display = 'none';
      }
    }
  };

  // ========================================
  // DATA UTILITIES
  // ========================================
  JdrApp.utils.data = {
    // Find spell by name across all categories
    findSpell(name) {
      if (!window.SORTS) return null;
      
      for (const category of window.SORTS) {
        const spell = category.sorts.find(s => s.nom === name);
        if (spell) return { spell, category: category.nom };
      }
      return null;
    },
    
    // Find class by name
    findClass(name) {
      if (!window.CLASSES) return null;
      return window.CLASSES.find(c => c.nom === name);
    },
    
    // Find don by name across all categories
    findDon(name) {
      if (!window.DONS) return null;
      
      for (const category of window.DONS) {
        const don = category.dons.find(d => d.nom === name);
        if (don) return { don, category: category.nom };
      }
      return null;
    },
    
    // Get spell category by name
    getSpellCategory(categoryName) {
      if (!window.SORTS) return null;
      return window.SORTS.find(cat => cat.nom === categoryName);
    },
    
    // Get don category by name
    getDonCategory(categoryName) {
      if (!window.DONS) return null;
      return window.DONS.find(cat => cat.nom === categoryName);
    },
    
    // Deep clone object
    deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    },
    
    // Sanitize string for use as identifier
    sanitizeId(str) {
      return str.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    },
    
    // Generate unique ID
    generateId(prefix = 'id') {
      return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    },
    
    // Escape HTML
    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  };

  // ========================================
  // IMAGE UTILITIES
  // ========================================
  
  // Compress image function
  JdrApp.utils.compressImage = function(file, maxWidth = 800, quality = 0.85) {
    return new Promise((resolve, reject) => {
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      img.onload = function() {
        // Calculate new dimensions
        let { width, height } = img;
        
        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }
        
        // Set canvas size
        canvas.width = width;
        canvas.height = height;
        
        // Detect if image has transparency (PNG)
        const isPNG = file.type === 'image/png' || file.name.toLowerCase().endsWith('.png');
        
        if (isPNG) {
          // For PNG, don't compress at all to preserve quality
          resolve(file);
        } else {
          // For JPEG/other formats, use white background
          ctx.fillStyle = '#FFFFFF';
          ctx.fillRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);
          
          canvas.toBlob((blob) => {
            resolve(blob);
          }, 'image/jpeg', quality);
        }
      };
      
      img.onerror = (error) => {
        reject(error);
      };
      
      img.src = URL.createObjectURL(file);
    });
  };

  // Upload to ImageBB function
  JdrApp.utils.uploadToImageBB = function(file) {
    return new Promise((resolve, reject) => {
      // ImageBB API key
      const API_KEY = '06a98f5c0c2dad952e6ab94b03040f36';
      
      const formData = new FormData();
      formData.append('image', file);
      
      fetch(`https://api.imgbb.com/1/upload?key=${API_KEY}`, {
        method: 'POST',
        body: formData
      })
      .then(response => {
        return response.json();
      })
      .then(data => {
        if (data.success) {
          resolve(data.data.url);
        } else {
          throw new Error('Upload failed: ' + (data.error ? data.error.message : 'Unknown error'));
        }
      })
      .catch(error => {
        // Fallback to local storage
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    });
  };

  // ========================================
  // PERFORMANCE OPTIMIZATION UTILITIES
  // ========================================
  
  // Minify HTML to reduce size (for performance optimization)
  JdrApp.utils.minifyHTML = function(html) {
    if (!html || typeof html !== 'string') return html;
    
    return html
      // Remove comments
      .replace(/<!--[\s\S]*?-->/g, '')
      // Remove extra whitespace between tags
      .replace(/>\s+</g, '><')
      // Remove whitespace at start and end of lines
      .replace(/^\s+|\s+$/gm, '')
      // Remove empty lines
      .replace(/\n\s*\n/g, '\n')
      // Trim the result
      .trim();
  };

  // Debounce function for performance
  JdrApp.utils.debounce = function(func, wait, immediate) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        timeout = null;
        if (!immediate) func.apply(this, args);
      };
      const callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) func.apply(this, args);
    };
  };

  // Throttle function for performance
  JdrApp.utils.throttle = function(func, limit) {
    let inThrottle;
    return function(...args) {
      if (!inThrottle) {
        func.apply(this, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  };

})();
// ============================================================================
// DEVICE DETECTION UTILITIES
// ============================================================================

(() => {
  "use strict";

  window.DeviceDetection = {
    
    // Detect if device is a tablet based on multiple factors
    isTablet() {
      const userAgent = navigator.userAgent.toLowerCase();
      const screen = window.screen;
      const width = Math.max(screen.width, screen.height);
      const height = Math.min(screen.width, screen.height);
      
      // Check user agent for tablet indicators
      const tabletUA = /ipad|android(?!.*mobile)|tablet|kindle|playbook|nook|silk/i.test(userAgent);
      
      // Check for coarse pointer (touch) and tablet-like dimensions
      const hasCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
      const tabletDimensions = (width >= 768 && width <= 1366) && (height >= 600);
      
      // iPad specific check
      const isIPad = /ipad/i.test(userAgent) || 
                   (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      
      // Android tablet check (excludes phones)
      const isAndroidTablet = /android/i.test(userAgent) && !/mobile/i.test(userAgent);
      
      return tabletUA || isIPad || isAndroidTablet || (hasCoarsePointer && tabletDimensions);
    },

    // Detect mobile phones specifically
    isMobile() {
      const userAgent = navigator.userAgent.toLowerCase();
      return /mobile|iphone|ipod|android.*mobile|blackberry|windows.*phone/i.test(userAgent);
    },

    // Check if device has touch capability
    isTouchDevice() {
      return 'ontouchstart' in window || 
             navigator.maxTouchPoints > 0 || 
             navigator.msMaxTouchPoints > 0;
    },

    // Check screen orientation
    isPortrait() {
      return window.innerHeight > window.innerWidth;
    },

    // Check if device should use mobile navigation
    shouldUseMobileNav() {
      const isSmallScreen = window.innerWidth <= 1024;
      const isTabletDevice = this.isTablet();
      const isMobileDevice = this.isMobile();
      
      return isMobileDevice || (isTabletDevice && isSmallScreen) || 
             (this.isTouchDevice() && isSmallScreen);
    },

    // Get device type as string
    getDeviceType() {
      if (this.isMobile()) return 'mobile';
      if (this.isTablet()) return 'tablet';
      return 'desktop';
    },

    // Check if should auto-close sidebar after navigation
    shouldAutoCloseSidebar() {
      return this.shouldUseMobileNav();
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - IMAGES MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // IMAGES MANAGEMENT MODULE
  // ========================================
  JdrApp.modules.images = {
    // Store for preloaded images
    imageStore: {},
    
    async init() {
      await this.loadImageData();
      this.initImageHandlers();
      this.initLazyLoading();
      
      // Auto-sync monster images on startup to ensure consistency
      setTimeout(() => {
        this.ensureMonsterImageMappings();
      }, 1000);
    },

    // Initialize lazy loading with Intersection Observer
    initLazyLoading() {
      if ('IntersectionObserver' in window) {
        this.lazyImageObserver = new IntersectionObserver((entries, observer) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const img = entry.target;
              const dataSrc = img.getAttribute('data-src');
              if (dataSrc) {
                img.src = dataSrc;
                img.removeAttribute('data-src');
                img.classList.remove('lazy-load');
                img.classList.add('lazy-loaded');
                
                // Une fois l'image chargÃ©e, s'assurer que les Ã©vÃ©nements d'agrandissement sont attachÃ©s
                img.addEventListener('load', () => {
                  if (JdrApp.modules.editor && JdrApp.modules.editor.attachImageEvents) {
                    JdrApp.modules.editor.attachImageEvents();
                  }
                }, { once: true });
              }
              observer.unobserve(img);
            }
          });
        }, {
          rootMargin: '50px 0px', // Start loading 50px before image comes into view
          threshold: 0.01
        });
      } else {
        // Fallback for browsers without IntersectionObserver
        this.initFallbackLazyLoading();
      }
    },

    // Fallback lazy loading for older browsers
    initFallbackLazyLoading() {
      const lazyLoad = () => {
        const lazyImages = document.querySelectorAll('img.lazy-load[data-src]');
        lazyImages.forEach(img => {
          const rect = img.getBoundingClientRect();
          if (rect.top < window.innerHeight + 50 && rect.bottom > -50) {
            const dataSrc = img.getAttribute('data-src');
            if (dataSrc) {
              img.src = dataSrc;
              img.removeAttribute('data-src');
              img.classList.remove('lazy-load');
              img.classList.add('lazy-loaded');
              
              // Une fois l'image chargÃ©e, s'assurer que les Ã©vÃ©nements d'agrandissement sont attachÃ©s
              img.addEventListener('load', () => {
                if (JdrApp.modules.editor && JdrApp.modules.editor.attachImageEvents) {
                  JdrApp.modules.editor.attachImageEvents();
                }
              }, { once: true });
            }
          }
        });
      };
      
      // Use throttled scroll events for better performance
      const throttledLazyLoad = JdrApp.utils.throttle(lazyLoad, 100);
      const debouncedLazyLoad = JdrApp.utils.debounce(lazyLoad, 250);
      
      window.addEventListener('scroll', throttledLazyLoad, { passive: true });
      window.addEventListener('resize', debouncedLazyLoad, { passive: true });
      lazyLoad(); // Initial check
    },

    // Load image data from JSON file or embedded data
    async loadImageData() {
      try {
        if (window.IMAGES) {
          this.imageStore = window.IMAGES.images || window.IMAGES || {};
          return;
        }
        
        const response = await fetch('./data/images.json');
        if (response.ok) {
          const data = await response.json();
          this.imageStore = data.images || {};
        } else {
          this.imageStore = {};
        }
      } catch (error) {
        this.imageStore = {};
      }
    },

    // Get image URL for a given key
    getImageUrl(illusKey) {
      return this.imageStore[illusKey] || null;
    },

    // Apply image to an illustration element
    applyImage(illusElement, imageUrl) {
      if (!illusElement || !imageUrl) return;

      const img = illusElement.querySelector('img.thumb');
      if (!img) return;

      // Set image source and make it visible
      img.src = this.processImageUrl(imageUrl);
      img.style.display = 'inline-block';
      img.style.opacity = '1'; // Reset opacity after upload
      
      // Show remove button if it exists
      const removeBtn = illusElement.querySelector('.rm');
      if (removeBtn) {
        removeBtn.style.display = 'inline-flex';
      }

    },

    // Process image URL to handle proxying for mobile compatibility
    processImageUrl(originalUrl) {
      // If it's an i.ibb.co URL, use proxy for better mobile compatibility
      if (originalUrl.includes('i.ibb.co') && !originalUrl.includes('images.weserv.nl')) {
        const format = this.supportsWebP() ? 'webp' : 'jpeg';
        const quality = this.getOptimalQuality();
        return `https://images.weserv.nl/?url=${encodeURIComponent(originalUrl)}&we&output=${format}&q=${quality}&w=400&h=300&fit=inside`;
      }
      
      // For local monster paths, encode only the filename to handle French characters properly
      if (originalUrl.startsWith('data/images/Monstres/')) {
        const pathParts = originalUrl.split('/');
        const filename = pathParts[pathParts.length - 1];
        const pathWithoutFilename = pathParts.slice(0, -1).join('/');
        return `${pathWithoutFilename}/${encodeURIComponent(filename)}`;
      }
      
      return originalUrl;
    },

    // Detect WebP support
    supportsWebP() {
      if (this._webpSupport !== undefined) return this._webpSupport;
      
      try {
        this._webpSupport = document.createElement('canvas')
          .toDataURL('image/webp', 0.5)
          .indexOf('data:image/webp') === 0;
      } catch (err) {
        this._webpSupport = false;
      }
      
      return this._webpSupport;
    },

    // Get optimal quality based on connection speed
    getOptimalQuality() {
      if ('connection' in navigator) {
        const connection = navigator.connection;
        if (connection.effectiveType === '4g') return 85;
        if (connection.effectiveType === '3g') return 75;
        if (connection.effectiveType === '2g') return 65;
        return 60; // slow-2g
      }
      return 80; // Default quality
    },

    autoLoadImages() {
      const illusElements = document.querySelectorAll('[data-illus-key]');
      let loadedCount = 0;

      illusElements.forEach(illusElement => {
        const illusKey = illusElement.dataset.illusKey;
        const imageUrl = this.getImageUrl(illusKey);
        
        if (imageUrl) {
          const img = illusElement.querySelector('img');
          if (img && img.classList.contains('lazy-load')) {
            // For lazy loading, set data-src and observe
            const processedUrl = this.processImageUrl(imageUrl);
            img.setAttribute('data-src', processedUrl);
            if (this.lazyImageObserver) {
              this.lazyImageObserver.observe(img);
            }
          } else {
            // Fallback to immediate loading
            this.applyImage(illusElement, imageUrl);
          }
          loadedCount++;
        }
      });

      return loadedCount;
    },

    // Initialize image upload handlers
    initImageHandlers() {
      // Delegate image upload handling
      document.addEventListener('change', (event) => {
        if (event.target.matches('.illus input[type="file"]')) {
          this.handleImageUpload(event.target);
        }
      });

      // Delegate image removal handling  
      document.addEventListener('click', (event) => {
        if (event.target.matches('.illus .rm')) {
          this.handleImageRemoval(event.target);
        }
      });
    },

    // Handle image upload
    async handleImageUpload(fileInput) {
      const file = fileInput.files[0];
      if (!file) return;

      const illusElement = fileInput.closest('.illus');
      if (!illusElement) return;

      const illusKey = illusElement.dataset.illusKey;
      
      try {
        // Show loading state
        const img = illusElement.querySelector('img.thumb');
        if (img) {
          img.style.opacity = '0.5';
        }

        // Compress and upload image
        const compressedFile = await JdrApp.utils.compressImage(file, 800, 0.8);
        const imageUrl = await JdrApp.utils.uploadToImageBB(compressedFile);
        
        // Apply the uploaded image
        this.applyImage(illusElement, imageUrl);
        
        // Update local store
        this.imageStore[illusKey] = imageUrl;
        
        // Auto-sync to prevent loss of image assignments
        this.autoSyncImages();
        
        
      } catch (error) {
        // Reset loading state
        const img = illusElement.querySelector('img.thumb');
        if (img) {
          img.style.opacity = '1';
        }
        
        alert('Erreur lors du tÃ©lÃ©chargement de l\'image. Veuillez rÃ©essayer.');
      }
      
      // Clear file input
      fileInput.value = '';
    },

    // Handle image removal
    handleImageRemoval(removeBtn) {
      const illusElement = removeBtn.closest('.illus');
      if (!illusElement) return;

      const illusKey = illusElement.dataset.illusKey;
      const img = illusElement.querySelector('img.thumb');
      
      if (img) {
        img.src = '';
        img.style.display = 'none';
      }
      
      removeBtn.style.display = 'none';
      
      // Remove from store
      delete this.imageStore[illusKey];
      
      // Auto-sync to update persistent storage
      this.autoSyncImages();
    },

    // Manually add/update an image
    setImage(illusKey, imageUrl) {
      this.imageStore[illusKey] = imageUrl;
      
      // Apply to any existing elements with this key
      const illusElements = document.querySelectorAll(`[data-illus-key="${illusKey}"]`);
      illusElements.forEach(element => {
        this.applyImage(element, imageUrl);
      });
      
      // Auto-sync to prevent loss
      this.autoSyncImages();
    },

    // Get all current images for export
    getAllImages() {
      return { ...this.imageStore };
    },

    // Import images from external data
    importImages(imageData) {
      if (typeof imageData === 'object' && imageData !== null) {
        Object.assign(this.imageStore, imageData);
        this.autoLoadImages();
      }
    },

    // Auto-sync images to prevent data loss
    autoSyncImages() {
      // Ensure we have monster image mappings for all existing monsters
      this.ensureMonsterImageMappings();
      
      // Ensure we have object image mappings for all existing objects
      this.ensureObjectImageMappings();
      
      // Trigger auto-save if available
      if (JdrApp.modules.storage && JdrApp.modules.storage.saveChanges) {
        JdrApp.modules.storage.saveChanges(true); // Silent save
      }
    },

    // Ensure all monsters have image mappings in images.json structure
    ensureMonsterImageMappings() {
      if (!window.MONSTRES || !Array.isArray(window.MONSTRES)) {
        return;
      }

      let hasUpdates = false;

      window.MONSTRES.forEach(monster => {
        const imageKey = `monster:${monster.nom}`;
        
        // If monster has no image mapping in store, create one
        if (!this.imageStore[imageKey]) {
          // Check if monster has a valid image path
          if (monster.image && monster.image.trim()) {
            this.imageStore[imageKey] = monster.image;
            hasUpdates = true;
          }
        }
        
        // Also validate that the image file exists
        this.validateMonsterImagePath(monster);
      });

      if (hasUpdates) {
      }
    },

    // Validate and fix monster image paths
    validateMonsterImagePath(monster) {
      if (!monster.image || !monster.nom) {
        return false;
      }

      // Extract filename from current path
      const currentPath = monster.image;
      const filename = currentPath.split('/').pop();
      
      // Check if path follows correct format
      const expectedPattern = /^data\/images\/Monstres\/foret\/Monstre_ForÃªt_\w+\.png$/;
      
      if (!expectedPattern.test(currentPath)) {
        // Try to fix common issues
        let correctedPath = null;
        
        // Map common filename patterns to correct paths
        const filenameMap = {
          'araignee-geante.png': 'Monstre_ForÃªt_AraignÃ©e.png',
          'crabe-des-bois.png': 'Monstre_ForÃªt_Crab.png',  
          'groink.png': 'Monstre_ForÃªt_Groink.png',
          'groink-chaman.png': 'Monstre_ForÃªt_Groink_Chaman.png',
          'guepe-geante.png': 'Monstre_ForÃªt_GuepeGeante.png',
          'ours-des-bois.png': 'Monstre_ForÃªt_Ours.png'
        };

        if (filenameMap[filename]) {
          correctedPath = `data/images/Monstres/foret/${filenameMap[filename]}`;
        } else if (!filename.startsWith('Monstre_ForÃªt_')) {
          // Try to construct path from monster name
          const safeName = monster.nom.replace(/[^a-zA-Z0-9Ã Ã¢Ã¤Ã©Ã¨ÃªÃ«Ã¯Ã®Ã´Ã¹Ã»Ã¼Ã¿Ã§Ã€Ã‚Ã„Ã‰ÃˆÃŠÃ‹ÃÃÃ”Ã™Ã›ÃœÅ¸Ã‡_]/g, '');
          correctedPath = `data/images/Monstres/foret/Monstre_ForÃªt_${safeName}.png`;
        }

        if (correctedPath && correctedPath !== currentPath) {
          
          // Update monster data
          monster.image = correctedPath;
          
          // Update image mapping
          const imageKey = `monster:${monster.nom}`;
          this.imageStore[imageKey] = correctedPath;
          
          return true;
        }
      }
      
      return false;
    },

    // Force synchronization of all monster data
    forceSyncMonsterImages() {
      
      let syncCount = 0;
      
      if (window.MONSTRES && Array.isArray(window.MONSTRES)) {
        window.MONSTRES.forEach(monster => {
          const corrected = this.validateMonsterImagePath(monster);
          if (corrected) {
            syncCount++;
          }
        });
      }
      
      this.ensureMonsterImageMappings();
      
      
      // Save changes
      if (JdrApp.modules.storage && JdrApp.modules.storage.saveChanges) {
        JdrApp.modules.storage.saveChanges(true);
      }
      
      return syncCount;
    },

    // Ensure all objects have image mappings in images.json structure
    ensureObjectImageMappings() {
      if (!window.OBJETS || !Array.isArray(window.OBJETS.objets)) {
        return;
      }

      let hasUpdates = false;

      window.OBJETS.objets.forEach(objet => {
        const imageKey = `objet:${objet.nom}`;
        
        // If object has no image mapping in store, create one
        if (!this.imageStore[imageKey]) {
          // Check if object has a valid image path
          if (objet.image && objet.image.trim()) {
            this.imageStore[imageKey] = objet.image;
            hasUpdates = true;
          }
        } else {
          // If imageStore has an image but objet.image is empty, sync it back
          if (this.imageStore[imageKey] && (!objet.image || !objet.image.trim())) {
            objet.image = this.imageStore[imageKey];
            hasUpdates = true;
          }
        }
      });

      if (hasUpdates) {
        // Auto-save objects data if it changed
        if (JdrApp.modules.storage && JdrApp.modules.storage.saveChanges) {
          JdrApp.modules.storage.saveChanges(true);
        }
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - STORAGE MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // STORAGE MODULE
  // ========================================
  JdrApp.modules.storage = {
    
    init() {
      
      // Clear localStorage on startup - JSON files are always source of truth
      this.clearStorageOnStartup();
      
      // Set up save handlers
      JdrApp.utils.events.register('click', '#saveAndExport', () => this.saveAndExportZip());
      
      // Listen for storage save events
      EventBus.on(Events.STORAGE_SAVE, () => {
        this.saveChanges(true); // Silent save
      });
      
      // Auto-save functionality
      this.setupAutoSave();
    },

    setupAutoSave() {
      // Auto-save disabled - we save immediately on each edit instead
      // Previously: Auto-save every 30 seconds if in dev mode
    },

    clearStorageOnStartup() {
      // Clear all localStorage data on page load - JSON files are source of truth
      localStorage.removeItem('jdr-bab-edits');
      localStorage.removeItem('jdr-bab-static-pages');
      localStorage.removeItem('jdr-bab-last-modified');
    },

    saveChanges(silent = false) {
      try {
        // Force collect all pending edits
        const editedData = JdrApp.modules.editor ? JdrApp.modules.editor.forceCollectAllEdits() : {};
        
        // Data is already saved in memory (window.STATIC_PAGES, window.SORTS, etc.)
        // No localStorage persistence needed - JSON files are source of truth
        
        if (!silent) {
          this.showNotification('ğŸ’¾ Modifications sauvegardÃ©es en mÃ©moire', 'success');
        }
        
      } catch (error) {
        console.error('âŒ Failed to save changes:', error);
        if (!silent) {
          this.showNotification('âŒ Erreur lors de la sauvegarde', 'error');
        }
      }
    },

    async saveAndExportZip() {
      try {
        this.showNotification('ğŸ“¦ CrÃ©ation de l\'archive ZIP...', 'info');
        
        // Force collect all pending edits
        JdrApp.modules.editor.forceCollectAllEdits();
        
        // Check if JSZip is available
        if (typeof JSZip === 'undefined') {
          await this.loadJSZip();
        }
        
        const zip = new JSZip();
        
        // Add main HTML file
        const mainHTML = await this.getMainHTML();
        zip.file('index.html', mainHTML);
        
        // Add CSS files
        const cssFiles = ['theme.css', 'utilities.css', 'components.css', 'layout.css', 'editor.css'];
        for (const cssFile of cssFiles) {
          const cssContent = await this.fetchFileContent(`css/${cssFile}`);
          if (cssContent) {
            zip.file(`css/${cssFile}`, cssContent);
          }
        }
        
        // Add JS files
        const jsFiles = ['core.js', 'utils.js', 'router.js', 'renderer.js', 'editor.js', 'storage.js', 'ui.js'];
        for (const jsFile of jsFiles) {
          const jsContent = await this.fetchFileContent(`js/${jsFile}`);
          if (jsContent) {
            zip.file(`js/${jsFile}`, jsContent);
          }
        }
        
        // Add modules
        const moduleFiles = ['images.js'];
        for (const moduleFile of moduleFiles) {
          const moduleContent = await this.fetchFileContent(`js/modules/${moduleFile}`);
          if (moduleContent) {
            zip.file(`js/modules/${moduleFile}`, moduleContent);
          }
        }
        
        // Add data files with current edits
        zip.file('data/sorts.json', JSON.stringify(window.SORTS, null, 2));
        zip.file('data/classes.json', JSON.stringify(window.CLASSES, null, 2));
        zip.file('data/dons.json', JSON.stringify(window.DONS, null, 2));
        zip.file('data/objets.json', JSON.stringify(window.OBJETS, null, 2));
        
        // Add monsters data with current edits
        if (window.MONSTRES) {
          zip.file('data/monstres.json', JSON.stringify(window.MONSTRES, null, 2));
        }
        
        // Add tables tresors data with current edits  
        if (window.TABLES_TRESORS) {
          zip.file('data/tables-tresors.json', JSON.stringify(window.TABLES_TRESORS, null, 2));
        }
        
        // Add collections data with current edits
        if (window.COLLECTIONS) {
          zip.file('data/collections.json', JSON.stringify(window.COLLECTIONS, null, 2));
        }
        
        // Add TOC structure with new pages
        if (window.TOC_STRUCTURE) {
          zip.file('data/toc-structure.json', JSON.stringify(window.TOC_STRUCTURE, null, 2));
        }
        
        // Add ContentTypes configuration (includes availableTags modifications)
        if (window.ContentTypes) {
          const updatedContentTypesJS = this.generateContentTypesJS(window.ContentTypes);
          zip.file('js/config/contentTypes.js', updatedContentTypesJS);
        }
        
        // Add static pages config and data
        if (window.STATIC_PAGES_CONFIG) {
          zip.file('data/static-pages-config.json', JSON.stringify(window.STATIC_PAGES_CONFIG, null, 2));
        }
        
        if (window.STATIC_PAGES) {
          for (const [pageId, pageData] of Object.entries(window.STATIC_PAGES)) {
            zip.file(`data/${pageId}.json`, JSON.stringify(pageData, null, 2));
          }
        }
        
        // Note: All static pages are now handled via window.STATIC_PAGES above
        
        // Ensure all image mappings are synchronized before export
        if (JdrApp.modules.images && JdrApp.modules.images.autoSyncImages) {
          JdrApp.modules.images.autoSyncImages();
        }
        
        // Add current images (including newly uploaded ones)
        if (JdrApp.modules.images && JdrApp.modules.images.getAllImages) {
          const currentImages = JdrApp.modules.images.getAllImages();
          const imagesData = {
            images: currentImages,
            meta: {
              total_images: Object.keys(currentImages).length,
              exported_date: new Date().toISOString().slice(0, 10),
              note: "Ces images incluent les nouvelles images uploadÃ©es"
            }
          };
          zip.file('data/images.json', JSON.stringify(imagesData, null, 2));
        }
        
        // Add page descriptions
        if (window.MONSTRES_PAGE_DESC) {
          zip.file('data/monstres-page-desc.json', JSON.stringify(window.MONSTRES_PAGE_DESC, null, 2));
        }
        
        if (window.TABLES_TRESORS_PAGE_DESC) {
          zip.file('data/tables-tresors-page-desc.json', JSON.stringify(window.TABLES_TRESORS_PAGE_DESC, null, 2));
        }
        
        // Add custom page descriptions (collections, etc.)
        if (JdrApp.data.customPageDescriptions) {
          zip.file('data/custom-page-descriptions.json', JSON.stringify(JdrApp.data.customPageDescriptions, null, 2));
        }
        
        // Add package.json and other config files
        const configFiles = ['package.json'];
        for (const configFile of configFiles) {
          const configContent = await this.fetchFileContent(configFile);
          if (configContent) {
            zip.file(configFile, configContent);
          }
        }
        
        // Generate and download ZIP
        const zipBlob = await zip.generateAsync({type: 'blob'});
        const timestamp = new Date().toISOString().slice(0, 16).replace(/[:-]/g, '');
        this.downloadFile(`JdrBab-${timestamp}.zip`, zipBlob, 'application/zip');
        
        this.showNotification('ğŸ“¦ Archive ZIP crÃ©Ã©e et tÃ©lÃ©chargÃ©e!', 'success');
        
      } catch (error) {
        console.error('âŒ Failed to create ZIP:', error);
        this.showNotification('âŒ Erreur lors de la crÃ©ation du ZIP', 'error');
      }
    },

    generateContentTypesJS(contentTypes) {
      // Generate the updated contentTypes.js file with current availableTags
      const availableTags = contentTypes.objet?.filterConfig?.availableTags || [];
      const defaultVisibleTags = contentTypes.objet?.filterConfig?.defaultVisibleTags || [];
      
      // Get monster tags configuration
      const monsterAvailableTags = contentTypes.monster?.filterConfig?.availableTags || [];
      const monsterDefaultVisibleTags = contentTypes.monster?.filterConfig?.defaultVisibleTags || [];
      
      return `// ============================================================================
// JDR-BAB APPLICATION - CONTENT TYPES CONFIGURATION
// ============================================================================

(() => {
  "use strict";

  window.ContentTypes = {
    spell: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        element: { type: 'select', label: 'Ã‰lÃ©ment', required: true, options: ['Feu', 'Eau', 'Terre', 'Air', 'LumiÃ¨re', 'Nuit', 'Divin', 'MalÃ©fique'] },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'PrÃ©requis', required: true },
        portee: { type: 'richtext', label: 'PortÃ©e', required: true },
        tempsIncantation: { type: 'richtext', label: "Temps d'incantation", required: true },
        coutMana: { type: 'richtext', label: 'CoÃ»t mana', required: true },
        resistance: { type: 'richtext', label: 'RÃ©sistance', required: true },
        effetNormal: { type: 'richtext', label: 'Effet normal', required: true },
        effetCritique: { type: 'richtext', label: 'Effet critique', required: false }
      },
      editMapping: {
        'spell-name': 'nom',
        'spell-element': 'element',
        'spell-description': 'description',
        'spell-prerequis': 'prerequis',
        'spell-portee': 'portee',
        'spell-mana': 'coutMana',
        'spell-temps-incantation': 'tempsIncantation',
        'spell-resistance': 'resistance',
        'spell-effect-normal': 'effetNormal',
        'spell-effect-critical': 'effetCritique'
      },
      identifiers: {
        name: 'nom',
        category: 'sorts'
      },
      template: 'spell-card',
      container: 'sorts',
      dataKey: 'SORTS',
      icons: { 
        category: 'ğŸ”®', 
        item: 'âœ¨',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      defaultValues: {
        nom: "Nouveau Sort",
        element: "Feu",
        description: "Lance une boule de Feu sur un adversaire.",
        prerequis: "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        portee: "ğŸ¯ <strong>PortÃ©e:</strong> 20m",
        tempsIncantation: "â° <strong>Temps d'incantation:</strong> 1 tour",
        coutMana: "ğŸ”µ <strong>CoÃ»t mana:</strong> 3",
        resistance: "<strong>Sans effet si:</strong> Esquive.",
        effetNormal: "<strong>Effet:</strong> Inflige 5 dÃ©gats de <span style='color: #e25822; font-weight: bold;'>Feu</span> Ã  la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        effetCritique: "<strong>Coup Critique:&nbsp;</strong>&nbsp;Double les dÃ©gÃ¢ts et enflamme la cible."
      }
    },

    don: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'PrÃ©requis', required: true },
        cout: { type: 'richtext', label: 'CoÃ»t', required: true }
      },
      editMapping: {
        'don-name': 'nom',
        'don-description': 'description',
        'don-prerequis': 'prerequis',
        'don-cout': 'cout'
      },
      identifiers: {
        name: 'nom',
        category: 'dons'
      },
      template: 'don-card',
      container: 'dons',
      dataKey: 'DONS',
      icons: { 
        category: 'ğŸ–ï¸', 
        item: 'ğŸ†',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      defaultValues: {
        nom: "Nouveau Don",
        description: "Description du don.",
        prerequis: "Aucun prÃ©requis",
        cout: "1 point de don"
      }
    },

    class: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        resume: { type: 'textarea', label: 'RÃ©sumÃ©', required: true },
        capacites: { type: 'list', label: 'CapacitÃ©s', required: true }
      },
      editMapping: {
        'class-name': 'nom',
        'class-resume': 'resume',
        'class-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: null
      },
      template: 'class-page',
      container: 'classes',
      dataKey: 'CLASSES',
      icons: { 
        category: 'âš”ï¸', 
        item: 'ğŸ›¡ï¸',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      }
    },

    subclass: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        base: { type: 'stats', label: 'Statistiques de base', required: true },
        progression: { type: 'richtext', label: 'Progression', required: true },
        capacites: { type: 'list', label: 'CapacitÃ©s', required: true }
      },
      editMapping: {
        'subclass-name': 'nom',
        'subclass-description': 'description',
        'subclass-stats': 'base',
        'subclass-progression': 'progression',
        'subclass-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: 'sousClasses',
        parent: 'class'
      },
      template: 'subclass-card',
      icons: { 
        item: 'âš¡',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      defaultValues: {
        nom: "Nouvelle sous-classe",
        description: "Description de la sous-classe",
        base: {
          Force: 3,
          AgilitÃ©: 3,
          Endurance: 3,
          Intelligence: 3,
          VolontÃ©: 3,
          Chance: 3
        },
        progression: "<strong>ğŸ“ˆ Progression par niveau:</strong> +1 Force ğŸ’ª, +1 AgilitÃ© ğŸƒ",
        capacites: [
          "<em>CapacitÃ© unique</em>: Description de la capacitÃ© spÃ©ciale de cette sous-classe."
        ]
      }
    },

    objet: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        numero: { type: 'number', label: 'NumÃ©ro', required: true },
        image: { type: 'text', label: 'Image', required: false },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        effet: { type: 'richtext', label: 'Effet', required: true },
        prix: { type: 'richtext', label: 'Prix', required: true },
        poids: { type: 'richtext', label: 'Poids', required: true }
      },
      editMapping: {
        'objet-name': 'nom',
        'objet-numero': 'numero',
        'objet-image': 'image',
        'objet-description': 'description',
        'objet-tags': 'tags',
        'objet-effet': 'effet',
        'objet-prix': 'prix',
        'objet-poids': 'poids'
      },
      identifiers: {
        name: 'nom',
        category: 'objets'
      },
      template: 'objet-card',
      container: 'objets',
      dataKey: 'OBJETS',
      pageType: 'single', // Page unique avec filtres
      icons: { 
        category: 'ğŸ“¦', 
        item: 'ğŸ’',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      // Configuration des filtres disponibles (MISE Ã€ JOUR AUTOMATIQUE)
      filterConfig: {
        availableTags: ${JSON.stringify(availableTags, null, 10)},
        defaultVisibleTags: ${JSON.stringify(defaultVisibleTags, null, 10)} // Filtres affichÃ©s par dÃ©faut
      },
      defaultValues: {
        nom: "Nouvel Objet",
        numero: 1,
        image: "",
        description: "Description de l'objet.",
        tags: ["Nouvel objet"],
        effet: "<strong>Effet:</strong> Description de l'effet de l'objet.",
        prix: "ğŸ”· <strong>Prix:</strong> 10",
        poids: "âš–ï¸ <strong>Poids:</strong> 1"
      }
    },

    monster: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        image: { type: 'text', label: 'Image', required: false },
        element: { 
          type: 'select', 
          label: "Ã‰lÃ©ment d'affiliation", 
          required: true,
          options: [
            { value: 'Feu', label: 'ğŸ”¥ Feu' },
            { value: 'Eau', label: 'ğŸ’§ Eau' },
            { value: 'Terre', label: 'ğŸ¤ Terre' },
            { value: 'Air', label: 'ğŸŸ¢ Air' },
            { value: 'Lumiere', label: 'â˜€ï¸ LumiÃ¨re' },
            { value: 'Nuit', label: 'âš« Nuit' },
            { value: 'Divin', label: 'âšª Divin' },
            { value: 'Malefique', label: 'ğŸŸ£ MalÃ©fique' }
          ]
        },
        pointsDeVie: { type: 'number', label: 'Points de vie', required: true },
        armurePhysique: { type: 'number', label: 'Armure physique', required: true },
        esquive: { type: 'number', label: 'Esquive', required: true },
        coupCritique: { type: 'number', label: 'Coup critique', required: true },
        coupCritiqueSorts: { type: 'number', label: 'Critique sorts', required: true },
        resistanceAlterations: { type: 'number', label: 'RÃ©sistance altÃ©rations', required: true },
        armureFeu: { type: 'number', label: 'Armure Feu', required: true },
        armureEau: { type: 'number', label: 'Armure Eau', required: true },
        armureTerre: { type: 'number', label: 'Armure Terre', required: true },
        armureAir: { type: 'number', label: 'Armure Air', required: true },
        armureLumiere: { type: 'number', label: 'Armure LumiÃ¨re', required: true },
        armureObscurite: { type: 'number', label: 'Armure ObscuritÃ©', required: true },
        armureDivin: { type: 'number', label: 'Armure Divin', required: true },
        armureMalefique: { type: 'number', label: 'Armure MalÃ©fique', required: true },
        abilites: { type: 'richtext', label: 'AbilitÃ©s', required: false },
        butin: { type: 'richtext', label: 'Butin', required: false }
      },
      editMapping: {
        'monster-name': 'nom',
        'monster-tags': 'tags',
        'monster-image': 'image',
        'monster-element': 'element',
        // Stats principaux
        'monster-pointsdevie': 'pointsDeVie',
        'monster-armurephysique': 'armurePhysique', 
        'monster-esquive': 'esquive',
        'monster-coupcritique': 'coupCritique',
        'monster-coupcritiquesorts': 'coupCritiqueSorts',
        'monster-resistancealterations': 'resistanceAlterations',
        // Armures Ã©lÃ©mentaires
        'monster-armurefeu': 'armureFeu',
        'monster-armureeau': 'armureEau',
        'monster-armureterre': 'armureTerre',
        'monster-armureair': 'armureAir',
        'monster-armurelumiere': 'armureLumiere',
        'monster-armureobscurite': 'armureObscurite',
        'monster-armuredivin': 'armureDivin',
        'monster-armuremalefique': 'armureMalefique',
        // Contenu narratif
        'monster-abilites': 'abilites',
        'monster-butin': 'butin'
      },
      identifiers: {
        name: 'nom',
        category: 'monstres'
      },
      template: 'monster-card',
      container: 'monstres',
      dataKey: 'MONSTRES',
      pageType: 'single',
      filterMode: 'AND',
      icons: { 
        category: 'ğŸ²', 
        item: 'ğŸ‘¾',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      filterConfig: {
        availableTags: ${JSON.stringify(monsterAvailableTags, null, 10)},
        defaultVisibleTags: ${JSON.stringify(monsterDefaultVisibleTags, null, 10)}
      },
      defaultValues: {
        nom: "Nouveau Monstre",
        tags: ["ForÃªt"],
        image: "",
        element: "Feu",
        pointsDeVie: 20,
        armurePhysique: 2,
        esquive: 5,
        coupCritique: 10,
        coupCritiqueSorts: 8,
        resistanceAlterations: 3,
        armureFeu: 0,
        armureEau: 0,
        armureTerre: 0,
        armureAir: 0,
        armureLumiere: 0,
        armureObscurite: 0,
        armureDivin: 0,
        armureMalefique: 0,
        abilites: "<strong>Attaque basique:</strong> Inflige 5 dÃ©gÃ¢ts physiques.",
        butin: "<strong>Butin:</strong> 10-50 piÃ¨ces d'or."
      }
    },

    tableTresor: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        fourchettes: { type: 'list', label: 'Fourchettes', required: true }
      },
      editMapping: {
        'table-tresor-name': 'nom',
        'table-tresor-description': 'description',
        'table-tresor-tags': 'tags'
      },
      identifiers: {
        name: 'nom',
        category: 'tables'
      },
      template: 'table-tresor-card',
      container: 'tables-tresors',
      dataKey: 'TABLES_TRESORS',
      pageType: 'single',
      filterMode: 'OR',
      icons: { 
        category: 'ğŸ’', 
        item: 'ğŸ“¦',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      filterConfig: {
        // availableTags managed dynamically via window.TABLES_TRESORS._metadata.availableTags
        defaultVisibleTags: [
          "ForÃªt",
          "Boss"
        ]
      },
      defaultValues: {
        nom: "Nouvelle Table de TrÃ©sor",
        description: "Table de butin pour une situation spÃ©cifique.",
        tags: ["ForÃªt"],
        fourchettes: [
          {
            min: 1,
            max: 10,
            objet: {
              type: "reference",
              numero: 1,
              nom: "Objet par dÃ©faut"
            }
          }
        ]
      }
    },

    staticPage: {
      fields: {
        title: { type: 'text', label: 'Titre', required: true },
        sections: { type: 'sections', label: 'Sections', required: true }
      },
      template: 'static-page',
      icons: { 
        category: 'ğŸ“„', 
        item: 'ğŸ“'
      }
    }
  };

  window.StatIcons = {
    'Force': 'ğŸ’ª',
    'AgilitÃ©': 'ğŸƒ',
    'Endurance': 'ğŸ›¡ï¸',
    'Intelligence': 'ğŸ§ ',
    'VolontÃ©': 'âš¡',
    'Chance': 'ğŸ€'
  };

  window.ElementColors = {
    'Feu': { color: '#ff6b35', weight: 'bold' },
    'Eau': { color: '#4682b4', weight: 'bold' },
    'Terre': { color: '#8b4513', weight: 'bold' },
    'Air': { color: '#22c55e', weight: 'bold' },
    'LumiÃ¨re': { color: '#ffd700', weight: 'bold' },
    'Nuit': { color: '#1a1a1a', weight: 'bold' },
    'Divin': { color: '#f5f5f5', weight: 'bold', background: 'rgba(100, 100, 100, 0.3)', padding: '2px 4px', borderRadius: '3px' },
    'MalÃ©fique': { color: '#8b5cf6', weight: 'bold' }
  };

  window.ElementIcons = {
    'Feu': 'ğŸ”¥',
    'Eau': 'ğŸ’§',
    'Terre': 'ğŸ¤',
    'Air': 'ğŸŸ¢',
    'LumiÃ¨re': 'â˜€ï¸',
    'Nuit': 'âš«',
    'Divin': 'âšª',
    'MalÃ©fique': 'ğŸŸ£'
  };

})();`;
    },

    async loadJSZip() {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    },

    async fetchFileContent(filePath) {
      try {
        const response = await fetch(filePath);
        if (response.ok) {
          return await response.text();
        }
        // Could not fetch file
        return null;
      } catch (error) {
        // Error fetching file
        return null;
      }
    },

    async getMainHTML() {
      // Get the current index.html content or reconstruct it
      try {
        const response = await fetch('index.html');
        if (response.ok) {
          return await response.text();
        }
      } catch (error) {
        // Could not fetch index.html, generating from current state
      }
      
      // Fallback: generate HTML from current document state
      return `<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta name="referrer" content="no-referrer-when-downgrade">
<title>JDRâ€‘BAB â€” Livret de rÃ¨gles</title>
<meta content="Livret web multipages des rÃ¨gles JDRâ€‘BAB, thÃ¨me parchemin, illustrations par catÃ©gorie/classe/sousâ€‘classe, export HTML autonome." name="description">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&amp;family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600&amp;display=swap" rel="stylesheet">

<!-- CSS Modulaire -->
<link rel="stylesheet" href="css/theme.css">
<link rel="stylesheet" href="css/utilities.css">
<link rel="stylesheet" href="css/components.css">
<link rel="stylesheet" href="css/layout.css">
<link rel="stylesheet" href="css/editor.css">
</head>
<body class="dev-off" style="">

<!-- Le contenu HTML complet sera injectÃ© ici par le JavaScript -->
<div id="app-loading">Chargement...</div>

<!-- JavaScript Modulaire -->
</body>
</html>`;
    },


    downloadJSON(filename, data) {
      const json = JSON.stringify(data, null, 2);
      this.downloadFile(filename, json, 'application/json');
    },

    downloadFile(filename, content, mimeType = 'text/html') {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.style.display = 'none';
      
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      URL.revokeObjectURL(url);
    },

    showNotification(message, type = 'info') {
      // Simple notification system
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${type === 'success' ? '#10B981' : type === 'error' ? '#EF4444' : '#3B82F6'};
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        font-weight: 500;
        z-index: 10000;
        animation: slideIn 0.3s ease;
      `;
      
      // Add animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      notification.textContent = message;
      document.body.appendChild(notification);
      
      // Auto-remove after 3 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    },

    // Load edits from localStorage on startup
    loadStoredEdits() {
      try {
        const storedEdits = localStorage.getItem('jdr-bab-edits');
        
        if (storedEdits && JdrApp.modules.editor) {
          JdrApp.modules.editor.editedData = JSON.parse(storedEdits);
        }
        
        // Load stored static pages data (includes dynamically created sections)
        const storedStaticPages = localStorage.getItem('jdr-bab-static-pages');
        if (storedStaticPages) {
          const staticPagesData = JSON.parse(storedStaticPages);
          
          // Merge with existing STATIC_PAGES data
          if (window.STATIC_PAGES) {
            Object.assign(window.STATIC_PAGES, staticPagesData);
          } else {
            window.STATIC_PAGES = staticPagesData;
          }
          
          console.log('Restored static pages data from localStorage:', Object.keys(staticPagesData));
        }
        
        // Ne plus charger jdr-bab-data - laisser les JSON Ãªtre la source de vÃ©ritÃ©
        
      } catch (error) {
        console.warn('Failed to load stored edits:', error);
      }
    },

    // Handle ZIP file import
    async handleZipImport(event) {
      const file = event.target.files[0];
      if (!file || file.type !== 'application/zip') {
        this.showNotification('âŒ Veuillez sÃ©lectionner un fichier ZIP', 'error');
        return;
      }

      try {
        this.showNotification('ğŸ“¥ Import en cours...', 'info');

        // Check if JSZip is available
        if (typeof JSZip === 'undefined') {
          await this.loadJSZip();
        }

        const zip = new JSZip();
        const contents = await zip.loadAsync(file);

        // Import data files
        const dataFiles = ['sorts.json', 'classes.json', 'dons.json', 'objets.json', 'monstres.json'];
        for (const dataFile of dataFiles) {
          const zipFile = contents.file(`data/${dataFile}`);
          if (zipFile) {
            const content = await zipFile.async('text');
            const data = JSON.parse(content);
            
            if (dataFile === 'sorts.json') {
              window.SORTS = data;
              JdrApp.data.SORTS = data;
            } else if (dataFile === 'classes.json') {
              window.CLASSES = data;
              JdrApp.data.CLASSES = data;
            } else if (dataFile === 'dons.json') {
              window.DONS = data;
              JdrApp.data.DONS = data;
            } else if (dataFile === 'objets.json') {
              window.OBJETS = data;
              JdrApp.data.OBJETS = data;
            } else if (dataFile === 'monstres.json') {
              window.MONSTRES = data;
              JdrApp.data.MONSTRES = data;
            } else if (dataFile === 'tables-tresors.json') {
              window.TABLES_TRESORS = data;
              JdrApp.data.TABLES_TRESORS = data;
            } else if (dataFile === 'collections.json') {
              window.COLLECTIONS = data;
              JdrApp.data.COLLECTIONS = data;
            } else if (dataFile === 'toc-structure.json') {
              window.TOC_STRUCTURE = data;
              JdrApp.data.TOC_STRUCTURE = data;
            }
          }
        }

        // Import static pages config
        const configFile = contents.file('data/static-pages-config.json');
        if (configFile) {
          const configContent = await configFile.async('text');
          window.STATIC_PAGES_CONFIG = JSON.parse(configContent);
          JdrApp.data.STATIC_PAGES_CONFIG = JSON.parse(configContent);
        }

        // Import static pages data
        if (window.STATIC_PAGES_CONFIG && window.STATIC_PAGES_CONFIG.pages) {
          window.STATIC_PAGES = {};
          JdrApp.data.STATIC_PAGES = {};
          for (const pageConfig of window.STATIC_PAGES_CONFIG.pages) {
            if (pageConfig.active) {
              const pageFile = contents.file(`data/${pageConfig.file}`);
              if (pageFile) {
                const pageContent = await pageFile.async('text');
                const pageData = JSON.parse(pageContent);
                window.STATIC_PAGES[pageConfig.id] = pageData;
                JdrApp.data.STATIC_PAGES[pageConfig.id] = pageData;
              }
            }
          }
        }

        // Import images
        const imagesFile = contents.file('data/images.json');
        if (imagesFile && JdrApp.modules.images && JdrApp.modules.images.importImages) {
          const imagesContent = await imagesFile.async('text');
          const imagesData = JSON.parse(imagesContent);
          if (imagesData.images) {
            JdrApp.modules.images.importImages(imagesData.images);
          }
        }

        // Import custom page descriptions
        const customDescFile = contents.file('data/custom-page-descriptions.json');
        if (customDescFile) {
          const customDescContent = await customDescFile.async('text');
          const customDescData = JSON.parse(customDescContent);
          window.CUSTOM_PAGE_DESCRIPTIONS = customDescData;
          JdrApp.data.customPageDescriptions = { ...JdrApp.data.customPageDescriptions, ...customDescData };
        }

        // Save imported data to localStorage
        this.saveChanges(true);

        this.showNotification('âœ… Import rÃ©ussi! Rechargement...', 'success');

        // Reload page to show imported data
        setTimeout(() => {
          window.location.reload();
        }, 1000);

      } catch (error) {
        this.showNotification('âŒ Erreur lors de l\'import', 'error');
      }

      // Reset file input
      event.target.value = '';
    },


  };

})();
// ============================================================================
// JDR-BAB APPLICATION - SPELL FILTER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // SPELL FILTER MODULE
  // ========================================
  const SpellFilter = {
    // Cache for performance
    _cachedCards: null,
    _lastCategoryHash: null,
    
    init() {
      this.setupEventListeners();
    },

    setupEventListeners() {
      // Use throttled event delegation for better performance
      document.addEventListener('input', (e) => {
        if (e.target && e.target.id === 'spell-level-filter') {
          // Throttle filter calls for smoother performance
          this.throttledFilter(parseInt(e.target.value, 10));
        }
      });

      document.addEventListener('click', (e) => {
        if (e.target && e.target.id === 'reset-spell-filter') {
          e.preventDefault();
          this.resetFilter();
        }
      });

      // Setup when page changes (router events)
      if (window.EventBus && window.Events) {
        EventBus.on(Events.PAGE_RENDER, (payload) => {
          if (payload.type === 'category' && payload.categoryType === 'spell') {
            // Clear cache and re-setup filter after page render
            this.clearCache();
            setTimeout(() => this.initializeFilter(), 200);
          }
        });
      }

      // Also listen to hash changes for direct navigation
      window.addEventListener('hashchange', () => {
        this.clearCache();
        setTimeout(() => this.initializeFilter(), 200);
      });
    },

    // Clear cache when changing pages
    clearCache() {
      this._cachedCards = null;
      this._lastCategoryHash = null;
    },

    // Throttled filter function for better performance
    throttledFilter: (function() {
      let timeout = null;
      return function(maxLevel) {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          this.filterSpellsByLevel(maxLevel);
        }, 100); // 100ms throttle
      };
    })(),

    initializeFilter() {
      const filterInput = document.querySelector('#spell-level-filter');
      if (!filterInput) return;
      
      // Set initial value and apply filter
      const initialValue = parseInt(filterInput.value, 10) || 20;
      this.filterSpellsByLevel(initialValue);
    },

    filterSpellsByLevel(maxLevel) {
      // Get current page from URL hash
      const currentHash = window.location.hash.replace('#/', '');
      
      if (!currentHash.startsWith('sorts-')) {
        return;
      }
      
      // Extract category name from hash - handle double sorts- prefix
      // URLs like 'sorts-sorts-de-mage' or 'sorts-mage' should both work
      let currentCategoryName = currentHash.replace('sorts-', '');
      if (currentCategoryName.startsWith('sorts-')) {
        // Handle double prefix case: 'sorts-sorts-de-mage' -> 'sorts-de-mage'
        currentCategoryName = currentCategoryName.replace('sorts-', '');
      }
      
      // Use cached cards if same category, otherwise refresh cache
      let spellCards;
      if (this._lastCategoryHash === currentHash && this._cachedCards) {
        spellCards = this._cachedCards;
      } else {
        // Only query DOM when necessary
        spellCards = document.querySelectorAll('article.active .card[data-spell-name]');
        this._cachedCards = spellCards;
        this._lastCategoryHash = currentHash;
      }
      
      if (spellCards.length === 0) return;

      let visibleCount = 0;
      let categoryTotalCount = 0;

      spellCards.forEach((card) => {
        const spellName = card.dataset.spellName;
        const categoryName = card.dataset.categoryName;
        
        // More flexible category matching
        const matches = this.categoryMatches(categoryName, currentCategoryName);
        
        if (matches) {
          categoryTotalCount++;
          
          // Find the spell data to get its level
          const spellLevel = this.getSpellLevel(spellName, categoryName);
          
          if (spellLevel <= maxLevel) {
            card.style.display = '';
            visibleCount++;
          } else {
            card.style.display = 'none';
          }
        } else {
          // Hide cards from other categories completely
          card.style.display = 'none';
        }
      });
      
      // Update filter display with count (use category total instead of all spells)
      this.updateFilterDisplay(maxLevel, visibleCount, categoryTotalCount);
    },

    categoryMatches(categoryName, currentCategoryName) {
      if (!categoryName || !currentCategoryName) {
        return false;
      }
      
      const catLower = categoryName.toLowerCase();
      const currentLower = currentCategoryName.toLowerCase();
      
      
      
      // Normalize both strings: replace hyphens with spaces
      const normalizedCat = catLower.replace(/[-_]/g, ' ').trim();
      const normalizedCurrent = currentLower.replace(/[-_]/g, ' ').trim();
      
      // Direct match
      if (normalizedCat === normalizedCurrent) {
        return true;
      }
      
      // Handle all possible URL-to-category mappings (including malformed URLs):
      const categoryMappings = {
        'mage': 'sorts de mage',
        'sorts de mage': 'sorts de mage',
        'de mage': 'sorts de mage',            // After normalization (tirets â†’ espaces)
        'pretre': 'sorts de prÃªtre', 
        'prÃªtre': 'sorts de prÃªtre',
        'pr tre': 'sorts de prÃªtre',           // Malformed: missing Ãª
        'sorts de pr tre': 'sorts de prÃªtre',  // Malformed: missing Ãª
        'de pr tre': 'sorts de prÃªtre',        // After normalization - FIXED!
        'de-pr-tre': 'sorts de prÃªtre',        // Direct URL version (tirets)
        'sorts de prÃªtre': 'sorts de prÃªtre',  // Full name
        'de prÃªtre': 'sorts de prÃªtre',        // After double prefix removal + normalization
        'enchanteur': "sorts d'enchanteur",
        'd enchanteur': "sorts d'enchanteur",  // Malformed: missing '
        'sorts d enchanteur': "sorts d'enchanteur", // Malformed: missing '
        'd enchanteur': "sorts d'enchanteur",  // After normalization - FIXED!
        'd-enchanteur': "sorts d'enchanteur", // Direct URL version (tirets)
        "sorts d'enchanteur": "sorts d'enchanteur", // Full name
        "d'enchanteur": "sorts d'enchanteur"   // After double prefix removal
      };
      
      // Direct mapping lookup (try both original and normalized versions)
      const mappingMatch = categoryMappings[currentLower] || categoryMappings[normalizedCurrent];
      if (mappingMatch && normalizedCat === mappingMatch.toLowerCase()) {
        return true;
      }
      
      // Reverse lookup - strip common prefixes from category
      const strippedCat = normalizedCat
        .replace(/^sorts de /, '')
        .replace(/^sorts d'/, '')
        .replace(/^sorts d /, '')    // Handle missing apostrophe
        .replace(/^sorts /, '');
        
      if (strippedCat === normalizedCurrent) {
        return true;
      }
      
      // Handle various character issues
      const normalizedStrippedCat = strippedCat
        .replace(/Ãª/g, 'e')     // Ãª -> e
        .replace(/'/g, '')      // Remove apostrophes
        .replace(/\s+/g, ' ')   // Normalize spaces
        .trim();
        
      const normalizedExtracted = normalizedCurrent
        .replace(/Ãª/g, 'e')     
        .replace(/'/g, '')      
        .replace(/\s+/g, ' ')   
        .trim();
        
      if (normalizedStrippedCat === normalizedExtracted) {
        return true;
      }
      
      // Additional fuzzy matches for common issues
      if ((strippedCat === 'prÃªtre' || strippedCat === 'pretre') && 
          (normalizedCurrent.includes('pr') && normalizedCurrent.includes('tre'))) {
        return true;
      }
      
      if (strippedCat === 'enchanteur' && 
          (normalizedCurrent.includes('enchanteur') || normalizedCurrent.includes('d enchanteur'))) {
        return true;
      }
      
      
      return false;
    },

    getSpellLevel(spellName, categoryName) {
      if (!window.SORTS) return 0;

      // Find the category using flexible matching
      let category = window.SORTS.find(cat => {
        const catLower = cat.nom.toLowerCase();
        const nameLower = categoryName.toLowerCase();
        
        return catLower === nameLower ||
               catLower === `sorts de ${nameLower}` ||
               catLower === `sorts d'${nameLower}` ||
               catLower.includes(nameLower);
      });
      
      if (!category || !category.sorts) return 0;

      // Find the spell
      const spell = category.sorts.find(sort => sort.nom === spellName);
      if (!spell || !spell.prerequis) return 0;

      // Extract level from prerequisite - handle HTML content
      const cleanPrerequisite = spell.prerequis.replace(/<[^>]*>/g, '');
      const match = cleanPrerequisite.match(/Niveau\s*(\d+)/i);
      
      return match ? parseInt(match[1], 10) : 0;
    },

    updateFilterDisplay(maxLevel, visibleCount, totalCount) {
      const activeArticle = document.querySelector('article.active');
      if (!activeArticle) return;
      
      const filterContainer = activeArticle.querySelector('.spell-level-filter');
      if (!filterContainer) return;
      
      // Chercher le container des contrÃ´les (avec input et bouton)
      const controlsContainer = filterContainer.querySelector('div[style*="flex-wrap"]');
      if (!controlsContainer) return;
      
      // Supprimer les anciens textes
      const allOldTexts = filterContainer.querySelectorAll('.filter-result-text');
      allOldTexts.forEach(old => old.remove());
      
      // CrÃ©er le nouveau texte
      const resultText = document.createElement('span');
      resultText.className = 'filter-result-text';
      resultText.textContent = `ğŸ“Š ${visibleCount}/${totalCount} sorts affichÃ©s (niveau â‰¤ ${maxLevel})`;
      resultText.style.cssText = `
        padding: 0.5rem 1rem !important;
        background-color: #e8f4f8 !important;
        color: #2c5aa0 !important;
        border: 1px solid #b3d9e8 !important;
        border-radius: 6px !important;
        font-size: 0.85rem !important;
        font-weight: 600 !important;
        white-space: nowrap !important;
        display: inline-block !important;
      `;
      
      // L'ajouter dans le container des contrÃ´les
      controlsContainer.appendChild(resultText);
    },

    resetFilter() {
      const filterInput = document.querySelector('#spell-level-filter');
      if (filterInput) {
        filterInput.value = '20';
        this.filterSpellsByLevel(20);
      }
      
      // Clear the count display
      const countContainer = document.querySelector('#spell-filter-count');
      if (countContainer) {
        countContainer.textContent = '';
        countContainer.style.display = 'none';
      }
    }
  };

  // Initialize the spell filter when the app is ready
  function initializeSpellFilter() {
    
    if (window.JdrApp) {
      if (JdrApp.modules) {
        JdrApp.modules.spellFilter = SpellFilter;
      }
    }
    
    // Initialize the filter
    SpellFilter.init();
    
    // Try to initialize the filter after a delay to ensure DOM is ready
    setTimeout(() => {
      if (window.location.hash.includes('sorts-')) {
        SpellFilter.initializeFilter();
      }
    }, 500);
  }

  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeSpellFilter);
  } else {
    // DOM is already ready
    initializeSpellFilter();
  }

  window.SpellFilter = SpellFilter;

})();
// ============================================================================
// JDR-BAB APPLICATION - TABLES DE TRESORS MANAGER
// ============================================================================

(() => {
  "use strict";

  class TablesTresorsManager {
    constructor() {
      this.initialized = false;
      this.currentPreviewModal = null;
      this.currentEditModal = null;
      this.modalIsOpening = false;
    }

    static getInstance() {
      if (!TablesTresorsManager.instance) {
        TablesTresorsManager.instance = new TablesTresorsManager();
      }
      return TablesTresorsManager.instance;
    }

    init() {
      if (this.initialized) return;
      
      this.setupEventListeners();
      this.initialized = true;
      // TablesTresorsManager initialized
    }

    setupEventListeners() {
      // Preview d'objets
      document.addEventListener('click', (e) => {
        if (e.target.matches('.object-preview-link')) {
          e.preventDefault();
          e.stopPropagation();
          const numeroObjet = e.target.dataset.objectNumero;
          this.showObjectPreview(numeroObjet);
        }
      });

      // Ã‰dition de fourchette
      document.addEventListener('click', (e) => {
        if (e.target.matches('.edit-fourchette-btn')) {
          const tableName = e.target.dataset.tableName;
          const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
          this.showEditFourchetteModal(tableName, fourchetteIndex);
        }
      });

      // Suppression de fourchette
      document.addEventListener('click', (e) => {
        if (e.target.matches('.delete-fourchette-btn')) {
          const tableName = e.target.dataset.tableName;
          const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
          this.deleteFourchette(tableName, fourchetteIndex);
        }
      });

      // Ajout de nouvelle fourchette
      document.addEventListener('click', (e) => {
        if (e.target.matches('.table-tresor-add-fourchette')) {
          const tableName = e.target.dataset.tableTresorName;
          this.showEditFourchetteModal(tableName, -1); // -1 pour nouvelle fourchette
        }
      });

      // Fermer les modals en cliquant Ã  l'extÃ©rieur
      document.addEventListener('click', (e) => {
        if (e.target.matches('.modal-overlay')) {
          this.closeAllModals();
        }
      });

      // Fermer avec la touche Escape
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          this.closeAllModals();
        }
      });

      // Preview de table de trÃ©sor via lien HTML
      document.addEventListener('click', (e) => {
        if (e.target.matches('.treasure-table-link')) {
          e.preventDefault();
          const tableName = e.target.dataset.tableName;
          this.showTablePreview(tableName);
        }
      });
    }

    showObjectPreview(numeroObjet) {
      try {
        // Trouver l'objet par son numÃ©ro
        const objet = window.OBJETS?.objets?.find(obj => obj.numero == numeroObjet);
        
        if (!objet) {
          console.error('Objet non trouvÃ©:', numeroObjet);
          return;
        }

        const previewHtml = this.generateObjectPreviewHtml(objet);
        this.showModal(previewHtml, 'object-preview');
        
      } catch (error) {
        console.error('Erreur lors de l\'affichage de la preview:', error);
      }
    }

    showTablePreview(tableName) {
      try {
        // Trouver la table par son nom
        const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === tableName);
        
        if (!table) {
          console.error('Table non trouvÃ©e:', tableName);
          return;
        }

        const previewHtml = this.generateTablePreviewHtml(table);
        const modalContent = `
          <div class="table-preview-content">
            ${previewHtml}
            <div style="text-align: center; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--rule);">
              <button class="btn" onclick="window.TablesTresorsManager.closeAllModals()" style="background: var(--accent); color: white;">
                âœ“ Fermer
              </button>
              <button class="btn" onclick="window.TablesTresorsManager.goToTablesTresorsPage()" style="background: var(--bronze); color: white; margin-left: 0.5rem;">
                ğŸ”— Aller Ã  la page tables de trÃ©sors
              </button>
            </div>
          </div>
        `;
        
        this.showModal(modalContent, 'table-preview');
        
      } catch (error) {
        console.error('Erreur lors de l\'affichage de la preview de table:', error);
      }
    }

    generateObjectPreviewHtml(objet) {
      // Utiliser le CardBuilder pour gÃ©nÃ©rer la card d'objet standard
      const cardHtml = CardBuilder.create('objet', objet, 'preview').build();
      
      // Wrapper la card dans un conteneur de preview avec les boutons
      return `
        <div class="object-preview-content">
          <div style="margin-bottom: 1.5rem;">
            ${cardHtml}
          </div>
          
          <div style="text-align: center; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--rule);">
            <button class="btn" onclick="window.TablesTresorsManager.closeAllModals()" style="background: var(--accent); color: white;">
              âœ“ Fermer
            </button>
            <button class="btn" onclick="window.TablesTresorsManager.goToObject(${objet.numero})" style="background: var(--bronze); color: white; margin-left: 0.5rem;">
              ğŸ”— Aller Ã  la page objets
            </button>
          </div>
        </div>
      `;
    }

    showEditFourchetteModal(tableName, fourchetteIndex) {
      try {
        const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === tableName);
        if (!table) {
          console.error('Table non trouvÃ©e:', tableName);
          return;
        }

        const isNewFourchette = fourchetteIndex === -1;
        const fourchette = isNewFourchette ? { min: 1, max: 1, objet: { type: 'reference', numero: 1, nom: 'Choisir un objet' } } : table.fourchettes[fourchetteIndex];

        if (!isNewFourchette && !fourchette) {
          console.error('Fourchette non trouvÃ©e:', fourchetteIndex);
          return;
        }

        const editHtml = this.generateEditFourchetteHtml(tableName, fourchetteIndex, fourchette, isNewFourchette);
        this.showModal(editHtml, 'edit-fourchette');

      } catch (error) {
        console.error('Erreur lors de l\'affichage du modal d\'Ã©dition:', error);
      }
    }

    generateEditFourchetteHtml(tableName, fourchetteIndex, fourchette, isNewFourchette) {
      // GÃ©nÃ©rer la liste des tags uniques
      const allTags = new Set();
      window.OBJETS?.objets?.forEach(obj => {
        obj.tags?.forEach(tag => allTags.add(tag));
      });
      const sortedTags = Array.from(allTags).sort();
      
      const tagOptions = ['<option value="">Tous les objets</option>']
        .concat(sortedTags.map(tag => `<option value="${tag}">${tag}</option>`))
        .join('');

      // GÃ©nÃ©rer la liste des objets disponibles
      const objetsOptions = window.OBJETS?.objets?.map(obj => 
        `<option value="${obj.numero}" data-tags="${obj.tags?.join(',') || ''}" ${obj.numero == fourchette.objet.numero ? 'selected' : ''}>NÂ°${obj.numero} - ${obj.nom}</option>`
      ).join('') || '<option value="1">Aucun objet disponible</option>';

      return `
        <div class="edit-fourchette-content">
          <header style="text-align: center; margin-bottom: 1rem; border-bottom: 2px solid var(--bronze); padding-bottom: 1rem;">
            <h3 style="margin: 0; color: var(--accent);">
              ${isNewFourchette ? 'â• Ajouter une fourchette' : 'âœï¸ Ã‰diter la fourchette'}
            </h3>
            <div style="color: var(--bronze); font-size: 0.9em;">Table: ${tableName}</div>
          </header>
          
          <form id="edit-fourchette-form">
            <input type="hidden" id="table-name" value="${tableName}">
            <input type="hidden" id="fourchette-index" value="${fourchetteIndex}">
            <input type="hidden" id="is-new-fourchette" value="${isNewFourchette}">
            <div style="margin: 1rem 0;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: bold; color: var(--accent);">
                ğŸ² Fourchette de dÃ© (1-20):
              </label>
              <div style="display: flex; gap: 1rem; align-items: center;">
                <div style="flex: 1;">
                  <label style="font-size: 0.9em; color: var(--paper-muted);">Minimum:</label>
                  <input 
                    type="number" 
                    id="fourchette-min" 
                    min="1" 
                    max="20" 
                    value="${fourchette.min || 1}"
                    style="width: 100%; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px;"
                    required
                  >
                </div>
                <div style="padding: 1rem 0.5rem; color: var(--accent); font-weight: bold;">-</div>
                <div style="flex: 1;">
                  <label style="font-size: 0.9em; color: var(--paper-muted);">Maximum:</label>
                  <input 
                    type="number" 
                    id="fourchette-max" 
                    min="1" 
                    max="20" 
                    value="${fourchette.max || 1}"
                    style="width: 100%; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px;"
                    required
                  >
                </div>
              </div>
            </div>
            
            <div style="margin: 1rem 0;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: bold; color: var(--accent);">
                ğŸ·ï¸ Filtrer par tag:
              </label>
              <select 
                id="tag-filter" 
                style="width: 100%; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px; background: var(--paper-light);"
              >
                ${tagOptions}
              </select>
            </div>
            
            <div style="margin: 1rem 0;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: bold; color: var(--accent);">
                ğŸ“¦ Objet associÃ©:
              </label>
              <select 
                id="fourchette-objet" 
                style="width: 100%; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px;"
                required
              >
                ${objetsOptions}
              </select>
              <div style="margin-top: 0.5rem;">
                <button 
                  type="button" 
                  id="preview-selected-object" 
                  class="btn small" 
                  style="background: var(--bronze); color: white; font-size: 0.8em;"
                >
                  ğŸ‘ï¸ AperÃ§u de l'objet sÃ©lectionnÃ©
                </button>
              </div>
            </div>
            
            <div style="text-align: center; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--rule);">
              <button type="submit" class="btn" style="background: var(--accent); color: white;">
                ${isNewFourchette ? 'â• Ajouter' : 'âœ“ Sauvegarder'}
              </button>
              <button type="button" onclick="window.TablesTresorsManager.closeAllModals()" class="btn" style="background: #6b7280; color: white; margin-left: 0.5rem;">
                âŒ Annuler
              </button>
            </div>
          </form>
        </div>
      `;
    }

    showModal(content, modalClass = '') {
      // Ã‰viter l'ouverture de modals multiples rapidement
      if (this.modalIsOpening) {
        return;
      }
      
      this.modalIsOpening = true;
      this.closeAllModals(); // Fermer les modals existants

      const modalHtml = `
        <div class="modal-overlay ${modalClass}" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 1000;">
          <div class="modal-content" style="background: var(--paper); border-radius: 12px; padding: 2rem; max-width: 90vw; max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 25px rgba(0,0,0,0.3); border: 2px solid var(--rule);">
            ${content}
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML('beforeend', modalHtml);
      
      // Setup form handler si c'est le modal d'Ã©dition
      if (modalClass === 'edit-fourchette') {
        this.setupEditFormHandlers();
      }
      
      // RÃ©initialiser le flag aprÃ¨s un court dÃ©lai
      setTimeout(() => {
        this.modalIsOpening = false;
      }, 200);
    }

    setupEditFormHandlers() {
      const form = document.getElementById('edit-fourchette-form');
      if (!form) return;

      form.addEventListener('submit', (e) => {
        e.preventDefault();
        this.saveFourchette();
      });

      // Preview de l'objet sÃ©lectionnÃ©
      const previewBtn = document.getElementById('preview-selected-object');
      if (previewBtn) {
        previewBtn.addEventListener('click', () => {
          const selectElement = document.getElementById('fourchette-objet');
          const selectedNumero = selectElement.value;
          this.showObjectPreview(selectedNumero);
        });
      }

      // Filtrage par tag
      const tagFilter = document.getElementById('tag-filter');
      const objectSelect = document.getElementById('fourchette-objet');
      
      if (tagFilter && objectSelect) {
        // Stocker toutes les options initiales
        const allOptions = Array.from(objectSelect.options);
        
        tagFilter.addEventListener('change', () => {
          const selectedTag = tagFilter.value;
          const currentSelectedValue = objectSelect.value;
          
          // Vider les options actuelles
          objectSelect.innerHTML = '';
          
          // Filtrer et rÃ©ajouter les options
          const filteredOptions = allOptions.filter(option => {
            if (!selectedTag) return true; // Afficher tous si aucun tag sÃ©lectionnÃ©
            const optionTags = option.dataset.tags || '';
            return optionTags.split(',').includes(selectedTag);
          });
          
          // RÃ©ajouter les options filtrÃ©es
          filteredOptions.forEach(option => {
            objectSelect.appendChild(option.cloneNode(true));
          });
          
          // Restaurer la sÃ©lection si elle est toujours disponible
          const stillAvailable = filteredOptions.find(option => option.value === currentSelectedValue);
          if (stillAvailable) {
            objectSelect.value = currentSelectedValue;
          } else if (filteredOptions.length > 0) {
            objectSelect.selectedIndex = 0;
          }
        });
      }

      // Validation en temps rÃ©el
      const minInput = document.getElementById('fourchette-min');
      const maxInput = document.getElementById('fourchette-max');
      
      const validateRange = () => {
        const min = parseInt(minInput.value);
        const max = parseInt(maxInput.value);
        
        if (min > max) {
          maxInput.value = min;
        }
      };

      minInput.addEventListener('change', validateRange);
      maxInput.addEventListener('change', validateRange);
    }

    saveFourchette() {
      try {
        const form = document.getElementById('edit-fourchette-form');
        const formData = new FormData(form);
        
        const min = parseInt(document.getElementById('fourchette-min').value);
        const max = parseInt(document.getElementById('fourchette-max').value);
        const objetNumero = parseInt(document.getElementById('fourchette-objet').value);
        
        // Trouver l'objet sÃ©lectionnÃ©
        const objet = window.OBJETS?.objets?.find(obj => obj.numero === objetNumero);
        if (!objet) {
          alert('Objet sÃ©lectionnÃ© introuvable');
          return;
        }

        const newFourchette = {
          min: min,
          max: max,
          objet: {
            type: 'reference',
            numero: objet.numero,
            nom: objet.nom
          }
        };

        // Extraire les informations depuis les champs cachÃ©s du formulaire
        const tableName = document.getElementById('table-name').value;
        const fourchetteIndex = parseInt(document.getElementById('fourchette-index').value);
        const isNewFourchette = document.getElementById('is-new-fourchette').value === 'true';
        
        const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === tableName);
        
        if (!table) {
          console.error('Table non trouvÃ©e pour la sauvegarde');
          return;
        }

        if (isNewFourchette) {
          table.fourchettes.push(newFourchette);
        } else {
          // Mode modification - remplacer la fourchette existante
          if (fourchetteIndex >= 0 && fourchetteIndex < table.fourchettes.length) {
            table.fourchettes[fourchetteIndex] = newFourchette;
          } else {
            console.error('Index de fourchette invalide pour la modification:', fourchetteIndex);
            return;
          }
        }

        // Sauvegarder et regÃ©nÃ©rer la page
        this.saveToStorage();
        this.refreshTablesTresorsPage();
        this.closeAllModals();

      } catch (error) {
        console.error('Erreur lors de la sauvegarde:', error);
        alert('Erreur lors de la sauvegarde de la fourchette');
      }
    }

    deleteFourchette(tableName, fourchetteIndex) {
      if (!confirm('ÃŠtes-vous sÃ»r de vouloir supprimer cette fourchette ?')) {
        return;
      }

      try {
        const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === tableName);
        if (!table) {
          console.error('Table non trouvÃ©e:', tableName);
          return;
        }

        if (fourchetteIndex < 0 || fourchetteIndex >= table.fourchettes.length) {
          console.error('Index de fourchette invalide:', fourchetteIndex);
          return;
        }

        table.fourchettes.splice(fourchetteIndex, 1);
        
        this.saveToStorage();
        this.refreshTablesTresorsPage();
        
        // Fourchette supprimÃ©e avec succÃ¨s

      } catch (error) {
        console.error('Erreur lors de la suppression:', error);
        alert('Erreur lors de la suppression de la fourchette');
      }
    }

    goToObject(numeroObjet) {
      this.closeAllModals();
      // Naviguer vers la page objets avec focus sur l'objet spÃ©cifique
      JdrApp.modules.router.navigate('objets');
      
      // Optionnel: highlight l'objet aprÃ¨s navigation
      setTimeout(() => {
        const objectCard = document.querySelector(`[data-objet-name*="${numeroObjet}"]`);
        if (objectCard) {
          objectCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
          objectCard.style.border = '3px solid var(--accent)';
          setTimeout(() => {
            objectCard.style.border = '';
          }, 2000);
        }
      }, 500);
    }

    goToTablesTresorsPage() {
      this.closeAllModals();
      // Naviguer vers la page tables de trÃ©sors
      if (JdrApp.modules.router && JdrApp.modules.router.navigate) {
        JdrApp.modules.router.navigate('tables-tresors');
      } else {
        // Fallback direct navigation
        window.location.hash = '#/tables-tresors';
      }
    }

    closeAllModals() {
      const modals = document.querySelectorAll('.modal-overlay');
      modals.forEach(modal => modal.remove());
      this.currentPreviewModal = null;
      this.currentEditModal = null;
    }

    saveToStorage() {
      // Les modifications sont dÃ©jÃ  dans window.TABLES_TRESORS et seront incluses dans les exports
      // Ã‰mettre l'Ã©vÃ©nement de mise Ã  jour pour notifier les autres modules
      if (window.EventBus && window.Events) {
        EventBus.emit(Events.CONTENT_UPDATE, {
          type: 'tablesTresors',
          data: window.TABLES_TRESORS
        });
      }
    }

    refreshTablesTresorsPage() {
      // RegÃ©nÃ©rer la page des tables de trÃ©sors
      if (JdrApp.modules.router && JdrApp.modules.router.getCurrentRoute() === 'tables-tresors') {
        // Force complete page regeneration via router navigation
        JdrApp.modules.router.navigate('tables-tresors');
      }
    }

    // Generate HTML link with table preview
    generateTreasureTableHtmlLink(tableName) {
      try {
        const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === tableName);
        if (!table) {
          console.error('Table non trouvÃ©e:', tableName);
          return '';
        }

        // Generate table preview HTML
        const tableHtml = this.generateTablePreviewHtml(table);
        
        // Create a compact link with preview tooltip
        const htmlLink = `<span class="treasure-table-link" data-table-name="${tableName}" style="color: var(--accent); cursor: pointer; text-decoration: underline;" title="Cliquer pour voir la table des trÃ©sors">[Table: ${tableName}]</span>`;
        
        return htmlLink;

      } catch (error) {
        console.error('Erreur lors de la gÃ©nÃ©ration du lien HTML:', error);
        return `[Erreur: ${tableName}]`;
      }
    }

    generateTablePreviewHtml(table) {
      const fourchettesList = table.fourchettes.map(fourchette => {
        const range = (fourchette.min || 1) === (fourchette.max || 1) 
          ? `${fourchette.min || 1}` 
          : `${fourchette.min || 1}-${fourchette.max || 1}`;
        
        return `
          <tr>
            <td style="text-align: center; font-weight: bold; color: var(--accent);">${range}</td>
            <td>
              <span class="object-preview-link" data-object-numero="${fourchette.objet.numero}" style="color: var(--accent); cursor: pointer; text-decoration: underline;" title="Cliquer pour voir la preview de l'objet">
                ${fourchette.objet.nom} (NÂ°${fourchette.objet.numero})
              </span>
            </td>
          </tr>
        `;
      }).join('');

      return `
        <div class="treasure-table-preview" style="background: var(--paper); border: 2px solid var(--bronze); border-radius: 12px; padding: 1rem; max-width: 500px;">
          <h3 style="margin: 0 0 1rem 0; color: var(--accent); text-align: center;">ğŸ² ${table.nom}</h3>
          
          <table style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
            <thead>
              <tr style="background: var(--bronze); color: white;">
                <th style="padding: 8px; text-align: center; border: 1px solid var(--rule);">DÃ© (d20)</th>
                <th style="padding: 8px; text-align: left; border: 1px solid var(--rule);">Objet obtenu</th>
              </tr>
            </thead>
            <tbody>
              ${fourchettesList}
            </tbody>
          </table>
        </div>
      `;
    }

    // Copy HTML link to clipboard
    copyTreasureTableHtmlLink(tableName) {
      try {
        const htmlLink = this.generateTreasureTableHtmlLink(tableName);
        
        // Copy to clipboard using modern API
        navigator.clipboard.writeText(htmlLink).then(() => {
          this.showNotification('âœ“ Lien HTML copiÃ© dans le presse-papiers!', 'success');
        }).catch(err => {
          // Fallback for older browsers
          const textArea = document.createElement('textarea');
          textArea.value = htmlLink;
          document.body.appendChild(textArea);
          textArea.select();
          document.execCommand('copy');
          document.body.removeChild(textArea);
          
          this.showNotification('âœ“ Lien HTML copiÃ© dans le presse-papiers!', 'success');
        });

      } catch (error) {
        console.error('Erreur lors de la copie:', error);
        this.showNotification('âŒ Erreur lors de la copie du lien', 'error');
      }
    }

    // Show notification
    showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        z-index: 1001;
        font-size: 14px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        animation: slideInRight 0.3s ease;
      `;
      notification.textContent = message;
      
      document.body.appendChild(notification);
      
      // Auto remove after 3 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.style.animation = 'slideOutRight 0.3s ease';
          setTimeout(() => notification.remove(), 300);
        }
      }, 3000);
    }
  }

  // Exposer globalement pour les event handlers inline
  window.TablesTresorsManager = TablesTresorsManager.getInstance();

  // Auto-initialiser quand le DOM est prÃªt
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => window.TablesTresorsManager.init());
  } else {
    window.TablesTresorsManager.init();
  }

})();
// ============================================================================
// JDR-BAB APPLICATION - FAVORIS MANAGER
// ============================================================================

(() => {
  "use strict";

  /**
   * Gestionnaire des favoris pour sorts et objets
   * Permet d'ajouter/supprimer des Ã©lÃ©ments en favoris avec persistance locale
   */
  class FavorisManager {
    constructor() {
      this.favoris = this.loadFavoris();
      this.initializeEventListeners();
    }

    /**
     * Charge les favoris depuis le stockage local
     */
    loadFavoris() {
      try {
        const saved = localStorage.getItem(window.STORAGE_KEYS.FAVORIS);
        return saved ? JSON.parse(saved) : {
          sorts: [],
          objets: []
        };
      } catch (error) {
        console.warn('Erreur lors du chargement des favoris:', error);
        return {
          sorts: [],
          objets: []
        };
      }
    }

    /**
     * Sauvegarde les favoris dans le stockage local
     */
    saveFavoris() {
      try {
        localStorage.setItem(window.STORAGE_KEYS.FAVORIS, JSON.stringify(this.favoris));
        EventBus.emit(window.Events.FAVORIS_UPDATE, { favoris: this.favoris });
      } catch (error) {
        console.error('Erreur lors de la sauvegarde des favoris:', error);
      }
    }

    /**
     * VÃ©rifie si un Ã©lÃ©ment est en favoris
     * @param {string} type - 'sorts' ou 'objets'
     * @param {string} nom - Nom de l'Ã©lÃ©ment
     * @returns {boolean}
     */
    isFavoris(type, nom) {
      return this.favoris[type] && this.favoris[type].includes(nom);
    }

    /**
     * Ajoute un Ã©lÃ©ment aux favoris
     * @param {string} type - 'sorts' ou 'objets'
     * @param {string} nom - Nom de l'Ã©lÃ©ment
     */
    addFavoris(type, nom) {
      if (!this.favoris[type]) {
        this.favoris[type] = [];
      }
      
      if (!this.favoris[type].includes(nom)) {
        this.favoris[type].push(nom);
        this.saveFavoris();
        
        EventBus.emit(window.Events.FAVORIS_ADD, { 
          type, 
          nom, 
          count: this.favoris[type].length 
        });
        
        this.showFeedback(`âœ¨ ${nom} ajoutÃ© aux favoris`, 'success');
        return true;
      }
      return false;
    }

    /**
     * Supprime un Ã©lÃ©ment des favoris
     * @param {string} type - 'sorts' ou 'objets'
     * @param {string} nom - Nom de l'Ã©lÃ©ment
     */
    removeFavoris(type, nom) {
      if (this.favoris[type]) {
        const index = this.favoris[type].indexOf(nom);
        if (index > -1) {
          this.favoris[type].splice(index, 1);
          this.saveFavoris();
          
          EventBus.emit(window.Events.FAVORIS_REMOVE, { 
            type, 
            nom,
            count: this.favoris[type].length 
          });
          
          this.showFeedback(`ğŸ—‘ï¸ ${nom} retirÃ© des favoris`, 'info');
          return true;
        }
      }
      return false;
    }

    /**
     * Bascule l'Ã©tat favori d'un Ã©lÃ©ment
     * @param {string} type - 'sorts' ou 'objets'
     * @param {string} nom - Nom de l'Ã©lÃ©ment
     */
    toggleFavoris(type, nom) {
      if (this.isFavoris(type, nom)) {
        return this.removeFavoris(type, nom);
      } else {
        return this.addFavoris(type, nom);
      }
    }

    /**
     * RÃ©cupÃ¨re tous les favoris d'un type
     * @param {string} type - 'sorts' ou 'objets'
     * @returns {Array}
     */
    getFavoris(type) {
      return this.favoris[type] || [];
    }

    /**
     * RÃ©cupÃ¨re tous les favoris
     * @returns {Object}
     */
    getAllFavoris() {
      return { ...this.favoris };
    }

    /**
     * Compte le nombre de favoris d'un type
     * @param {string} type - 'sorts' ou 'objets'
     * @returns {number}
     */
    countFavoris(type) {
      return this.favoris[type] ? this.favoris[type].length : 0;
    }

    /**
     * Vide tous les favoris d'un type
     * @param {string} type - 'sorts' ou 'objets'
     */
    clearFavoris(type) {
      if (this.favoris[type]) {
        const count = this.favoris[type].length;
        this.favoris[type] = [];
        this.saveFavoris();
        this.showFeedback(`ğŸ—‘ï¸ ${count} favoris ${type} supprimÃ©s`, 'info');
      }
    }

    /**
     * Initialise les Ã©couteurs d'Ã©vÃ©nements
     */
    initializeEventListeners() {
      // Ã‰couter les clics sur les Ã©toiles de favoris
      document.addEventListener('click', (event) => {
        const starBtn = event.target.closest('.favoris-star');
        if (starBtn) {
          event.preventDefault();
          event.stopPropagation();
          
          const type = starBtn.dataset.type;
          const nom = starBtn.dataset.nom;
          
          this.toggleFavoris(type, nom);
          this.updateStarDisplay(starBtn, type, nom);
        }
      });
    }

    /**
     * Met Ã  jour l'affichage de l'Ã©toile
     * @param {Element} starBtn - Bouton Ã©toile
     * @param {string} type - Type de favori
     * @param {string} nom - Nom de l'Ã©lÃ©ment
     */
    updateStarDisplay(starBtn, type, nom) {
      const isFav = this.isFavoris(type, nom);
      starBtn.innerHTML = isFav ? 'â­' : 'â˜†';
      starBtn.classList.toggle('favoris-active', isFav);
      starBtn.title = isFav ? 'Retirer des favoris' : 'Ajouter aux favoris';
    }

    /**
     * Affiche un feedback utilisateur
     * @param {string} message - Message Ã  afficher
     * @param {string} type - Type de feedback (success, info, warning, error)
     */
    showFeedback(message, type = 'info') {
      // Utilise le systÃ¨me de notification existant si disponible
      if (window.JdrApp && window.JdrApp.ui && window.JdrApp.ui.showNotification) {
        window.JdrApp.ui.showNotification(message, type);
      } else {
        // Fallback simple
        
        // CrÃ©er une notification temporaire
        const notification = document.createElement('div');
        notification.className = `favoris-notification favoris-${type}`;
        notification.textContent = message;
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: var(--surface-color, #f0f0f0);
          color: var(--text-color, #333);
          padding: 12px 16px;
          border-radius: 8px;
          border-left: 4px solid var(--accent-color, #d4af37);
          box-shadow: 0 4px 8px rgba(0,0,0,0.1);
          z-index: 10000;
          font-size: 14px;
          max-width: 300px;
          animation: slideInRight 0.3s ease-out;
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.animation = 'slideOutRight 0.3s ease-in';
          setTimeout(() => {
            if (notification.parentNode) {
              notification.parentNode.removeChild(notification);
            }
          }, 300);
        }, 3000);
      }
    }

    /**
     * CrÃ©e un bouton Ã©toile pour les favoris
     * @param {string} type - 'sorts' ou 'objets'
     * @param {string} nom - Nom de l'Ã©lÃ©ment
     * @returns {string} HTML du bouton Ã©toile
     */
    createStarButton(type, nom, data = null) {
      const isFav = this.isFavoris(type, nom);
      
      return `
        <button class="favoris-star ${isFav ? 'favoris-active' : ''}" 
                data-type="${type}" 
                data-nom="${nom}" 
                title="${isFav ? 'Retirer des favoris' : 'Ajouter aux favoris'}"
                aria-label="${isFav ? 'Retirer des favoris' : 'Ajouter aux favoris'}">
          ${isFav ? 'â­' : 'â˜†'}
        </button>
      `;
    }
  }

  // ========================================
  // INITIALISATION GLOBALE
  // ========================================
  
  // CrÃ©er l'instance globale
  window.FavorisManager = new FavorisManager();
  
  // Exposer dans le namespace JdrApp si disponible
  if (window.JdrApp) {
    window.JdrApp.favoris = window.FavorisManager;
  }

})();
// ============================================================================
// JDR-BAB APPLICATION - FAVORIS RENDERER
// ============================================================================

(() => {
  "use strict";

  /**
   * Gestionnaire de rendu pour la page des favoris
   * Met Ã  jour l'affichage des favoris en temps rÃ©el
   */
  class FavorisRenderer {
    constructor() {
      this.isInitialized = false;
      this.initializeEventListeners();
    }

    /**
     * Initialise les Ã©couteurs d'Ã©vÃ©nements
     */
    initializeEventListeners() {
      // Ã‰couter les changements de favoris
      EventBus.on(window.Events.FAVORIS_UPDATE, (data) => {
        this.updateFavorisDisplay();
      });

      EventBus.on(window.Events.FAVORIS_ADD, (data) => {
        this.updateFavorisDisplay();
      });

      EventBus.on(window.Events.FAVORIS_REMOVE, (data) => {
        this.updateFavorisDisplay();
      });

      // Ã‰couter les changements de page pour mettre Ã  jour au besoin
      EventBus.on('router:page-changed', (data) => {
        if (data.page === 'favoris') {
          setTimeout(() => this.updateFavorisDisplay(), 100);
        }
      });
    }

    /**
     * Met Ã  jour l'affichage complet des favoris
     */
    updateFavorisDisplay() {
      if (!window.FavorisManager) {
        console.warn('FavorisManager not available');
        return;
      }

      // VÃ©rifier si nous sommes sur la page des favoris
      const favorisPage = document.querySelector('[data-page="favoris"]');
      if (!favorisPage || favorisPage.style.display === 'none') {
        return;
      }

      // Mettre Ã  jour dans l'ordre : objets d'abord, puis sorts (mÃªme ordre que PageBuilder)
      this.updateObjetsDisplay();
      this.updateSortsDisplay();
    }

    /**
     * Met Ã  jour l'affichage des sorts favoris
     */
    updateSortsDisplay() {
      const container = document.getElementById('favoris-sorts-container');
      const emptyState = document.getElementById('favoris-sorts-empty');
      const section = document.getElementById('favoris-sorts-section');
      
      if (!container || !emptyState) return;

      const favorisNames = window.FavorisManager.getFavoris('sorts');
      
      if (favorisNames.length === 0) {
        container.style.display = 'none';
        emptyState.style.display = 'block';
        return;
      }

      container.style.display = 'block';
      emptyState.style.display = 'none';

      // RÃ©cupÃ©rer les donnÃ©es des sorts favoris
      const favorisData = this.getSortsData(favorisNames);
      
      // GÃ©nÃ©rer les cartes avec les images
      const cardsHtml = favorisData.map(sortData => {
        return CardBuilder.create('spell', sortData.sort, sortData.category).build();
      }).join('');

      container.innerHTML = cardsHtml;

      // DÃ©clencher le chargement des images aprÃ¨s insertion du contenu
      if (JdrApp.modules.renderer?.autoLoadImages) {
        setTimeout(() => JdrApp.modules.renderer.autoLoadImages(), 50);
      }

      // S'assurer que la section n'est pas pliÃ©e si elle a du contenu
      if (section && favorisNames.length > 0) {
        section.classList.remove('collapsed');
      }
    }

    /**
     * Met Ã  jour l'affichage des objets favoris
     */
    updateObjetsDisplay() {
      const container = document.getElementById('favoris-objets-container');
      const emptyState = document.getElementById('favoris-objets-empty');
      const section = document.getElementById('favoris-objets-section');
      
      if (!container || !emptyState) return;

      const favorisNames = window.FavorisManager.getFavoris('objets');
      
      if (favorisNames.length === 0) {
        container.style.display = 'none';
        emptyState.style.display = 'block';
        return;
      }

      container.style.display = 'block';
      emptyState.style.display = 'none';

      // RÃ©cupÃ©rer les donnÃ©es des objets favoris
      const favorisData = this.getObjetsData(favorisNames);
      
      // GÃ©nÃ©rer les cartes avec les images
      const cardsHtml = favorisData.map(objetData => {
        return CardBuilder.create('objet', objetData, null).build();
      }).join('');

      container.innerHTML = cardsHtml;

      // DÃ©clencher le chargement des images aprÃ¨s insertion du contenu
      if (JdrApp.modules.renderer?.autoLoadImages) {
        setTimeout(() => JdrApp.modules.renderer.autoLoadImages(), 50);
      }

      // S'assurer que la section n'est pas pliÃ©e si elle a du contenu
      if (section && favorisNames.length > 0) {
        section.classList.remove('collapsed');
      }
    }

    /**
     * RÃ©cupÃ¨re les donnÃ©es des sorts favoris
     * @param {Array} favorisNames - Noms des sorts favoris
     * @returns {Array} DonnÃ©es des sorts avec leurs catÃ©gories
     */
    getSortsData(favorisNames) {
      const sortsData = [];
      
      if (!window.SORTS) return sortsData;

      // Parcourir toutes les catÃ©gories de sorts
      window.SORTS.forEach(category => {
        if (category.sorts) {
          category.sorts.forEach(sort => {
            if (favorisNames.includes(sort.nom)) {
              sortsData.push({
                sort: sort,
                category: category.nom
              });
            }
          });
        }
      });

      return sortsData;
    }

    /**
     * RÃ©cupÃ¨re les donnÃ©es des objets favoris
     * @param {Array} favorisNames - Noms des objets favoris
     * @returns {Array} DonnÃ©es des objets
     */
    getObjetsData(favorisNames) {
      const objetsData = [];
      
      if (!window.OBJETS || !window.OBJETS.objets) return objetsData;

      // Parcourir tous les objets
      window.OBJETS.objets.forEach(objet => {
        if (favorisNames.includes(objet.nom)) {
          objetsData.push(objet);
        }
      });

      return objetsData;
    }

    /**
     * Force la mise Ã  jour de l'affichage
     */
    forceUpdate() {
      this.updateFavorisDisplay();
    }

    /**
     * Initialise le renderer quand la DOM est prÃªte
     */
    initialize() {
      if (this.isInitialized) return;
      
      // Attendre que tout soit chargÃ©
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          setTimeout(() => this.updateFavorisDisplay(), 500);
        });
      } else {
        setTimeout(() => this.updateFavorisDisplay(), 100);
      }

      this.isInitialized = true;
    }
  }

  // ========================================
  // INITIALISATION GLOBALE
  // ========================================
  
  // CrÃ©er l'instance globale
  window.FavorisRenderer = new FavorisRenderer();
  
  // Exposer dans le namespace JdrApp si disponible
  if (window.JdrApp) {
    window.JdrApp.favorisRenderer = window.FavorisRenderer;
  }

  // Initialiser automatiquement
  window.FavorisRenderer.initialize();

})();
// ============================================================================
// JDR-BAB APPLICATION - SCROLL OPTIMIZER
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // SCROLL PERFORMANCE OPTIMIZER MODULE
  // ========================================
  window.ScrollOptimizer = {
    _initialized: false,
    _observers: new Map(),
    _virtualizationEnabled: false,
    _visibleCards: new Set(),
    _scrollTimeout: null,
    _lastScrollTime: 0,

    init() {
      if (this._initialized) return;
      
      this.setupScrollOptimizations();
      this.initializeVirtualization();
      this.optimizeExistingContent();
      
      this._initialized = true;
    },

    // Configure scroll event optimizations
    setupScrollOptimizations() {
      // Debounced scroll handler for expensive operations
      const debouncedScrollHandler = this.debounce(() => {
        this.updateVisibleCards();
        this.triggerLazyLoading();
      }, 100);

      // Throttled scroll handler for smooth operations
      const throttledScrollHandler = this.throttle(() => {
        this.handleSmoothScrollEffects();
      }, 16); // ~60fps

      // Add passive scroll listeners
      window.addEventListener('scroll', throttledScrollHandler, { passive: true });
      window.addEventListener('scroll', debouncedScrollHandler, { passive: true });
      
      // Optimize resize events
      window.addEventListener('resize', this.debounce(() => {
        this.recalculateViewport();
        this.updateVisibleCards();
      }, 250), { passive: true });
    },

    // Initialize virtual scrolling for long lists
    initializeVirtualization() {
      // Enable for pages with many cards (>20)
      this.observePageChanges();
    },

    // Observe page changes to apply optimizations
    observePageChanges() {
      if (!('MutationObserver' in window)) return;

      const observer = new MutationObserver((mutations) => {
        mutations.forEach(mutation => {
          if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
            mutation.addedNodes.forEach(node => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                this.optimizeNewContent(node);
              }
            });
          }
        });
      });

      observer.observe(document.getElementById('views') || document.body, {
        childList: true,
        subtree: true
      });

      this._observers.set('pageChanges', observer);
    },

    // Optimize newly added content
    optimizeNewContent(element) {
      // Only optimize content in active articles
      const activeArticle = element.closest('article.active') || element.querySelector('article.active');
      if (!activeArticle && !element.matches('article.active')) {
        return; // Skip optimization for inactive articles
      }
      
      // Skip optimization for collections pages and filtered content
      const targetElement = activeArticle || element;
      if (targetElement.id === 'collections-objets' || 
          targetElement.querySelector('#collection-results') ||
          targetElement.querySelector('.objects-tag-display')) {
        return; // Skip collections and filtered object pages
      }
      
      const cards = targetElement.querySelectorAll('.card:not([style*="display: none"]), .spell-card:not([style*="display: none"]), .item-card:not([style*="display: none"])');
      const subclassSections = targetElement.querySelectorAll('.editable-section[data-section-type="subclass"]');
      
      // Removed console.log for better performance
      
      // Special handling for class pages with subclass sections
      if (subclassSections.length > 5) {
        this.optimizeClassPage(targetElement, subclassSections);
      } else if (cards.length > 15) {
        this.enableVirtualization(targetElement, cards);
      } else {
        this.applyBasicOptimizations(cards);
      }
    },

    // Optimize class pages with many subclasses
    optimizeClassPage(container, subclassSections) {
      // Removed console.log for better performance
      
      // Use progressive loading for subclasses
      subclassSections.forEach((section, index) => {
        if (index > 3) { // Keep first 4 visible
          this.deferSubclassRendering(section, index);
        } else {
          this.optimizeSubclassSection(section);
        }
      });
      
      // Add scroll-triggered loading for deferred sections
      this.setupProgressiveLoading(container, subclassSections);
    },

    // Defer rendering of subclass sections
    deferSubclassRendering(section, index) {
      section.style.cssText = `
        content-visibility: auto;
        contain-intrinsic-size: 0 400px;
        contain: layout style paint;
        opacity: 0.8;
        transform: translateZ(0);
      `;
      
      // Add loading indicator for deferred sections
      section.setAttribute('data-loading-state', 'deferred');
      section.setAttribute('data-section-index', index);
    },

    // Optimize individual subclass sections
    optimizeSubclassSection(section) {
      // Optimize images within subclass
      const images = section.querySelectorAll('img');
      images.forEach(img => {
        this.optimizeImage(img);
      });
      
      // Optimize large text content
      const textElements = section.querySelectorAll('[data-edit-type="generic"]');
      textElements.forEach(element => {
        if (element.textContent.length > 500) {
          element.style.contain = 'layout style';
        }
      });
    },

    // Setup progressive loading for class pages
    setupProgressiveLoading(container, sections) {
      if (!('IntersectionObserver' in window)) return;

      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const section = entry.target;
            const loadingState = section.getAttribute('data-loading-state');
            
            if (loadingState === 'deferred') {
              this.fullyLoadSubclassSection(section);
              observer.unobserve(section);
            }
          }
        });
      }, {
        rootMargin: '100px 0px', // Start loading 100px before visible
        threshold: 0.1
      });

      // Observe deferred sections
      sections.forEach(section => {
        if (section.getAttribute('data-loading-state') === 'deferred') {
          observer.observe(section);
        }
      });

      this._observers.set('classPageLoader', observer);
    },

    // Fully load a deferred subclass section
    fullyLoadSubclassSection(section) {
      // Remove deferral styles
      section.style.cssText = `
        opacity: 1;
        transform: none;
        transition: opacity 0.3s ease;
      `;
      
      section.setAttribute('data-loading-state', 'loaded');
      
      // Optimize the newly loaded content
      this.optimizeSubclassSection(section);
      
      // Ensure images are loaded
      if (JdrApp.modules.images) {
        JdrApp.modules.images.autoLoadImages();
      }
    },

    // Optimize individual images
    optimizeImage(img) {
      if (!img.hasAttribute('loading')) {
        img.setAttribute('loading', 'lazy');
      }
      
      if (!img.hasAttribute('decoding')) {
        img.setAttribute('decoding', 'async');
      }
      
      // Add size hints for layout stability
      if (!img.style.aspectRatio && img.width && img.height) {
        img.style.aspectRatio = `${img.width} / ${img.height}`;
      }
    },

    // Enable virtual scrolling for large lists
    enableVirtualization(container, cards) {
      this._virtualizationEnabled = true;
      
      // Create viewport container
      const viewport = document.createElement('div');
      viewport.className = 'virtualized-viewport';
      viewport.style.cssText = `
        height: 70vh;
        overflow-y: auto;
        position: relative;
      `;

      // Create content container
      const content = document.createElement('div');
      content.className = 'virtualized-content';
      content.style.position = 'relative';

      // Calculate total height and item height
      const itemHeight = this.calculateItemHeight(cards[0]);
      const totalHeight = cards.length * itemHeight;
      content.style.height = `${totalHeight}px`;

      // Set up virtual scrolling
      this.setupVirtualScroll(viewport, content, Array.from(cards), itemHeight);

      // Replace original content
      const parent = container.parentNode;
      parent.insertBefore(viewport, container);
      viewport.appendChild(content);
      container.style.display = 'none';
    },

    // Setup virtual scrolling mechanics
    setupVirtualScroll(viewport, content, items, itemHeight) {
      const visibleCount = Math.ceil(viewport.clientHeight / itemHeight) + 2; // Buffer
      let startIndex = 0;

      const updateVisibleItems = () => {
        const scrollTop = viewport.scrollTop;
        const newStartIndex = Math.floor(scrollTop / itemHeight);
        
        if (newStartIndex === startIndex) return;
        
        startIndex = Math.max(0, newStartIndex);
        const endIndex = Math.min(items.length, startIndex + visibleCount);

        // Clear existing content
        content.innerHTML = '';

        // Render visible items
        for (let i = startIndex; i < endIndex; i++) {
          const item = items[i].cloneNode(true);
          item.style.cssText = `
            position: absolute;
            top: ${i * itemHeight}px;
            width: 100%;
            box-sizing: border-box;
          `;
          content.appendChild(item);
        }

        // Re-initialize lazy loading for new items
        if (JdrApp.modules.images) {
          JdrApp.modules.images.autoLoadImages();
        }
      };

      // Throttled scroll handler for virtual scrolling
      const throttledUpdate = this.throttle(updateVisibleItems, 16);
      viewport.addEventListener('scroll', throttledUpdate, { passive: true });
      
      // Initial render
      updateVisibleItems();
    },

    // Apply basic optimizations to smaller lists
    applyBasicOptimizations(cards) {
      cards.forEach((card, index) => {
        // Special handling for spell cards (more complex)
        if (card.classList.contains('spell-card')) {
          this.optimizeSpellCard(card, index);
        } else {
          // Defer non-critical rendering for other card types
          if (index > 10) {
            this.deferCardRendering(card);
          }
        }
        
        // Optimize images in all cards
        this.optimizeCardImages(card);
      });
    },

    // Optimize spell cards specifically (they're more complex)
    optimizeSpellCard(card, index) {
      // Spell cards are complex, so use more aggressive optimization
      if (index > 6) { // Show only first 7 spell cards immediately
        this.deferSpellCardRendering(card);
      } else {
        this.optimizeVisibleSpellCard(card);
      }
    },

    // Defer rendering for spell cards with intersection observer
    deferSpellCardRendering(card) {
      card.style.cssText = `
        content-visibility: auto;
        contain-intrinsic-size: 0 450px; /* Taller for spell cards */
        contain: layout style;
        opacity: 0.7;
        transform: translateZ(0);
      `;
      
      card.setAttribute('data-loading-state', 'deferred-spell');
      
      // Set up intersection observer for this specific card
      this.observeSpellCard(card);
    },

    // Optimize visible spell cards
    optimizeVisibleSpellCard(card) {
      // Optimize complex HTML structure in spell cards
      const editableFields = card.querySelectorAll('[data-edit-type="generic"]');
      editableFields.forEach(field => {
        if (field.innerHTML.length > 200) {
          field.style.contain = 'layout style';
        }
      });
      
      // Optimize hr elements (lots of them in spell cards)
      const hrs = card.querySelectorAll('hr');
      hrs.forEach(hr => {
        hr.style.contain = 'layout paint';
      });
    },

    // Observe spell cards for lazy loading
    observeSpellCard(card) {
      if (!('IntersectionObserver' in window)) {
        // Fallback: load immediately on older browsers
        this.loadSpellCard(card);
        return;
      }

      if (!this._spellCardObserver) {
        this._spellCardObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              this.loadSpellCard(entry.target);
              this._spellCardObserver.unobserve(entry.target);
            }
          });
        }, {
          rootMargin: '50px 0px',
          threshold: 0.1
        });
        
        this._observers.set('spellCards', this._spellCardObserver);
      }

      this._spellCardObserver.observe(card);
    },

    // Load a deferred spell card
    loadSpellCard(card) {
      card.style.cssText = `
        opacity: 1;
        transform: none;
        transition: opacity 0.2s ease;
      `;
      
      card.setAttribute('data-loading-state', 'loaded');
      this.optimizeVisibleSpellCard(card);
    },

    // Defer rendering of cards outside initial viewport
    deferCardRendering(card) {
      card.style.cssText = `
        content-visibility: auto;
        contain-intrinsic-size: 0 300px;
      `;
    },

    // Optimize images within cards
    optimizeCardImages(card) {
      const images = card.querySelectorAll('img');
      images.forEach(img => {
        if (!img.hasAttribute('loading')) {
          img.setAttribute('loading', 'lazy');
        }
        
        // Add decode hint for better performance
        if (!img.hasAttribute('decoding')) {
          img.setAttribute('decoding', 'async');
        }
      });
    },

    // Update visible cards tracking
    updateVisibleCards() {
      const cards = document.querySelectorAll('.card, .spell-card, .item-card');
      const viewport = {
        top: window.scrollY,
        bottom: window.scrollY + window.innerHeight
      };

      this._visibleCards.clear();

      cards.forEach((card, index) => {
        const rect = card.getBoundingClientRect();
        const absoluteTop = rect.top + window.scrollY;
        const absoluteBottom = absoluteTop + rect.height;

        if (absoluteBottom > viewport.top - 100 && absoluteTop < viewport.bottom + 100) {
          this._visibleCards.add(index);
          
          // Prioritize visible cards for interactions
          card.style.transform = 'translateZ(0)'; // Force GPU layer
        } else {
          // Deprioritize invisible cards
          card.style.transform = '';
        }
      });
    },

    // Handle smooth scroll effects
    handleSmoothScrollEffects() {
      this._lastScrollTime = Date.now();
      
      // Disable heavy animations during scroll
      document.body.classList.add('scrolling');
      
      clearTimeout(this._scrollTimeout);
      this._scrollTimeout = setTimeout(() => {
        document.body.classList.remove('scrolling');
      }, 150);
    },

    // Trigger lazy loading for visible area
    triggerLazyLoading() {
      if (JdrApp.modules.images && JdrApp.modules.images.autoLoadImages) {
        JdrApp.modules.images.autoLoadImages();
      }
    },

    // Recalculate viewport dimensions
    recalculateViewport() {
      // Update any cached viewport dimensions
      this._viewportHeight = window.innerHeight;
      this._viewportWidth = window.innerWidth;
    },

    // Calculate item height for virtualization
    calculateItemHeight(sampleItem) {
      if (!sampleItem) return 200; // Default height
      
      const rect = sampleItem.getBoundingClientRect();
      return rect.height || 200;
    },

    // Optimize existing content on page
    optimizeExistingContent() {
      const existingCards = document.querySelectorAll('.card, .spell-card, .item-card');
      
      if (existingCards.length > 0) {
        this.optimizeNewContent(document.getElementById('views') || document.body);
      }
    },

    // Utility: Debounce function
    debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    },

    // Utility: Throttle function
    throttle(func, limit) {
      let inThrottle;
      return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
          func.apply(context, args);
          inThrottle = true;
          setTimeout(() => inThrottle = false, limit);
        }
      }
    },

    // Clean up optimizations
    cleanup() {
      this._observers.forEach(observer => observer.disconnect());
      this._observers.clear();
      
      clearTimeout(this._scrollTimeout);
      
      this._initialized = false;
    }
  };

})();
// ============================================================================
// DYNAMIC CENTERING SYSTEM
// ============================================================================

(() => {
  "use strict";

  class DynamicCentering {
    constructor() {
      this.sidebarWidth = 350; // Width of the sidebar
      this.isEnabled = false;
      this.observer = null;
      this.rafId = null;
    }

    init() {
      this.isEnabled = true;
      this.setupResizeObserver();
      this.setupWindowResize();
      // Initial calculation
      this.updateCentering();
    }

    setupResizeObserver() {
      if (!window.ResizeObserver) return;

      // Observe changes to the main content container
      const viewsContainer = document.getElementById('views');
      if (!viewsContainer) return;

      this.observer = new ResizeObserver(() => {
        if (this.rafId) {
          cancelAnimationFrame(this.rafId);
        }
        this.rafId = requestAnimationFrame(() => this.updateCentering());
      });

      this.observer.observe(viewsContainer);
    }

    setupWindowResize() {
      let resizeTimer;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => this.updateCentering(), 100);
      });
    }

    updateCentering() {
      if (!this.isEnabled) return;

      const viewsContainer = document.getElementById('views');
      if (!viewsContainer) return;

      const viewportWidth = window.innerWidth;

      // Use CSS media queries for robust device detection (same as CSS breakpoints)
      const isMobileBreakpoint = window.matchMedia('(max-width: 980px)').matches;
      const isTabletBreakpoint = window.matchMedia('(max-width: 1024px)').matches;
      const isCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
      const isTouchOnly = window.matchMedia('(hover: none)').matches;
      
      // Check if sidebar is actually visible/active
      const sidebar = document.querySelector('.sidebar');
      const isSidebarVisible = sidebar && !sidebar.classList.contains('mobile-open') && 
                              window.getComputedStyle(sidebar).position === 'fixed' &&
                              viewportWidth > 1024; // Sidebar only shows above 1024px (desktop only)
      
      // Disable dynamic centering if:
      // 1. CSS mobile breakpoint is active (matches our responsive CSS) OR
      // 2. CSS tablet breakpoint is active (force full width on tablet) OR
      // 3. Device has coarse pointer (touch-first device) OR  
      // 4. Device can't hover (mobile/touch-only) OR
      // 5. Sidebar is not visible
      if (isMobileBreakpoint || isTabletBreakpoint || isCoarsePointer || isTouchOnly || !isSidebarVisible) {
        // Reset to CSS responsive behavior - force full width on tablet/mobile
        viewsContainer.style.marginLeft = '';
        viewsContainer.style.marginRight = '';
        return;
      }

      // Get actual container dimensions
      const containerRect = viewsContainer.getBoundingClientRect();
      const actualContentWidth = containerRect.width;

      // Calculate available space after sidebar
      const availableSpace = viewportWidth - this.sidebarWidth;
      
      // Calculate optimal margin to center content in available space
      const optimalMarginLeft = this.sidebarWidth + (availableSpace - actualContentWidth) / 2;

      // Apply the centering with bounds checking
      const minMarginLeft = this.sidebarWidth + 20; // Minimum clearance
      const maxMarginLeft = viewportWidth - actualContentWidth - 20; // Don't overflow right
      
      const finalMarginLeft = Math.max(minMarginLeft, Math.min(optimalMarginLeft, maxMarginLeft));

      // Apply the calculated margin
      viewsContainer.style.marginLeft = `${finalMarginLeft}px`;
      viewsContainer.style.marginRight = '20px';

      // Debug info (remove in production)
      if (window.location.hash.includes('debug-centering')) {
        console.log('ğŸ¯ Dynamic Centering:', {
          viewportWidth,
          availableSpace,
          actualContentWidth,
          optimalMarginLeft,
          finalMarginLeft
        });
      }
    }

    disable() {
      this.isEnabled = false;
      if (this.observer) {
        this.observer.disconnect();
      }
      if (this.rafId) {
        cancelAnimationFrame(this.rafId);
      }
      
      // Reset to CSS default
      const viewsContainer = document.getElementById('views');
      if (viewsContainer) {
        viewsContainer.style.marginLeft = '';
        viewsContainer.style.marginRight = '';
      }
    }
  }

  // Initialize the dynamic centering system
  const dynamicCentering = new DynamicCentering();

  // Attach to JdrApp
  if (window.JdrApp) {
    JdrApp.modules.dynamicCentering = dynamicCentering;
  }

  // Auto-initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      // Delay initialization to ensure layout is stable
      setTimeout(() => dynamicCentering.init(), 500);
    });
  } else {
    setTimeout(() => dynamicCentering.init(), 500);
  }

  // Make it globally available for debugging
  window.DynamicCentering = dynamicCentering;

})();
// ============================================================================
// JDR-BAB APPLICATION - ROUTER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // ROUTING SYSTEM
  // ========================================
  JdrApp.modules.router = {
    currentRoute: '',
    
    init() {
      
      // Set up route change listeners
      JdrApp.utils.events.onHashChange(() => this.parseRoute());
      JdrApp.utils.events.onDOMReady(() => this.parseRoute());
      
      // Listen for dev mode changes to refresh objects page
      if (window.EventBus && window.Events) {
        EventBus.on(Events.EDITOR_TOGGLE, (payload) => {
          const currentHash = window.location.hash;
          // Refresh objects page specifically when dev mode changes
          if (currentHash === '#/objets') {
            setTimeout(() => {
              // Force a complete refresh by setting the flag
              this._forceObjectsRefresh = true;
              this.renderObjectsPage();
            }, 150);
          }
        });
      }
    },
    
    parseRoute() {
      const hash = location.hash.replace('#/', '');
      const page = hash || 'creation';
      const exists = JdrApp.utils.dom.$(`article[data-page="${page}"]`);
      
      this.currentRoute = page;
      
      // Handle dynamic category routing
      // Fix: check if exists is falsy OR empty NodeList
      const shouldUseRouter = !exists || (exists.length === 0);
      
      if (shouldUseRouter) {
        if (this.handleDynamicRoute(page)) {
          return; // Route was handled dynamically
        }
      }
      
      this.show(exists ? page : 'creation');
    },

    handleDynamicRoute(page) {
      // Handle sorts-* routes
      if (page.startsWith('sorts-')) {
        return this.renderDynamicCategory('sorts', 'spell', page);
      }
      
      // Handle dons-* routes  
      if (page.startsWith('dons-')) {
        return this.renderDynamicCategory('dons', 'don', page);
      }
      
      // Handle single objets page (objects now use unified page with tag filtering)
      if (page === 'objets') {
        return this.renderObjectsPage();
      }
      
      // Handle collections-objets page
      if (page === 'collections-objets') {
        return this.renderCollectionsObjectsPage();
      }
      
      // Handle single monstres page (monsters now use unified page with tag filtering)
      if (page === 'monstres') {
        return this.renderMonstersPage();
      }
      
      // Handle single tables-tresors page  
      if (page === 'tables-tresors') {
        return this.renderTablesTresorsPage();
      }
      
      // Handle feuille-personnage page
      if (page === 'feuille-personnage') {
        return this.renderFeuillePersonnagePage();
      }
      
      // Handle favoris page
      if (page === 'favoris') {
        return this.renderFavorisPage();
      }
      
      // Handle GM objects page
      if (page === 'gestion-objets') {
        return this.renderGMObjectsPage();
      }
      
      return false; // Route not handled
    },

    renderDynamicCategory(prefix, type, page) {
      const categoryId = page.replace(`${prefix}-`, '');
      const dataKey = prefix.toUpperCase();
      const dataSource = window[dataKey];
      
      if (!dataSource) return false;
      
      const category = dataSource.find(cat => 
        JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
      );
      
      if (category) {
        // Render the category page dynamically
        JdrApp.modules.renderer.renderCategoryPage(type, category);
        
        // Update active states
        this.updateActiveStates(page);
        
        return true;
      }
      
      return false;
    },

    updateActiveStates(page) {
      // Remove active class from all articles and hide them
      document.querySelectorAll('article').forEach(a => {
        a.classList.remove('active');
        a.style.display = 'none'; // Force hide all articles
      });
      
      // Remove active class from all TOC links
      document.querySelectorAll('.toc a').forEach(a => a.classList.remove('active'));
      
      // Show the current page article
      const currentArticle = document.querySelector(`article[data-page="${page}"]`);
      if (currentArticle) {
        currentArticle.classList.add('active');
        currentArticle.style.display = 'block'; // Force show current article
        
        // IMPORTANT: Reset the activeIdSearch state when navigating to Objects page
        if (page === 'objets') {
          window.activeIdSearch = false;
          
          // Clear any search results
          const resultDiv = document.getElementById('id-search-result');
          if (resultDiv) {
            resultDiv.textContent = '';
          }
          
          // Clear search input
          const searchInput = document.getElementById('id-search-input');
          if (searchInput) {
            searchInput.value = '';
          }
        }
      }
      
      // Set active link in TOC
      const activeLink = document.querySelector(`a[href="#/${page}"]`);
      if (activeLink) {
        activeLink.classList.add('active');
        
        // Expand parent category if needed
        const category = activeLink.closest('.toc-category');
        if (category) {
          category.classList.remove('collapsed');
        }
      }
    },
    
    show(page) {
      // Hide all articles and remove active class
      document.querySelectorAll('article').forEach(a => {
        a.classList.remove('active');
        a.style.display = 'none';
      });
      
      // Show and activate the target page
      const target = document.querySelector(`article[data-page="${page}"]`);
      if (target) {
        target.classList.add('active');
        target.style.display = 'block';
        
        // Reset ID search state when navigating to Objects page
        if (page === 'objets') {
          window.activeIdSearch = false;
          setTimeout(() => {
            const resultDiv = document.getElementById('id-search-result');
            if (resultDiv) {
              resultDiv.textContent = '';
            }
            const searchInput = document.getElementById('id-search-input');
            if (searchInput) {
              searchInput.value = '';
            }
          }, 100);
        }
      }
      
      // Update TOC active states
      document.querySelectorAll('.toc a').forEach(a => a.classList.remove('active'));
      const activeLink = document.querySelector(`a[href="#/${page}"]`);
      if (activeLink) activeLink.classList.add('active');

      
      // Ensure edit buttons state is properly applied after navigation
      if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
        setTimeout(() => {
          if (JdrApp.modules.editor.isDevMode) {
            JdrApp.modules.editor.forceShowAllEditButtons();
          } else {
            JdrApp.modules.editor.forceHideAllEditButtons();
          }
        }, 50);
      }
    },
    
    navigate(route) {
      location.hash = `#/${route}`;
      // Force parseRoute() in case hashchange event doesn't fire
      setTimeout(() => {
        this.parseRoute();
      }, 10);
    },
    
    getCurrentRoute() {
      return this.currentRoute;
    },
    
    // Generate table of contents based on hierarchical structure
    generateTOC() {
      const tocContainer = document.querySelector('#toc');
      if (!tocContainer) return;

      if (!window.TOC_STRUCTURE) {
        console.warn('TOC_STRUCTURE not loaded, falling back to basic TOC');
        this.generateBasicTOC();
        return;
      }

      const tocHTML = `
        <h4>Sommaire</h4>
        ${window.TOC_STRUCTURE.directPages ? 
          window.TOC_STRUCTURE.directPages.map(page => this.generateTOCItem(page)).join('') : 
          ''}
        ${window.TOC_STRUCTURE.sections
          .filter(section => !section.requiresMJ || window.JdrApp.state.isMJ)
          .map(section => this.generateTOCSection(section)).join('')}
        <div class="mj-toggle-container" style="margin: 1rem 0; text-align: center; border-top: 2px solid var(--rule); padding-top: 1rem;">
          <button id="mjToggleBtn" class="btn-base btn-small" style="background: var(--bronze); color: white; border-color: var(--bronze); position: relative;">
            ğŸ­ MaÃ®tre de jeu
            <span id="mjStatusIndicator" style="position: absolute; top: -5px; right: -5px; width: 12px; height: 12px; border-radius: 50%; background: #dc2626; border: 2px solid white; display: none;"></span>
          </button>
        </div>
      `;
      
      tocContainer.innerHTML = tocHTML;
      
      // Attacher les Ã©vÃ©nements directement aux Ã©lÃ©ments aprÃ¨s crÃ©ation
      this.attachFoldoutEvents();
      
      // Initialiser les hauteurs dynamiques pour toutes les sections ouvertes
      this.initializeDynamicHeights();
      
      // Ajouter l'event listener pour le bouton MJ
      this.setupMJToggle();
    },

    initializeDynamicHeights() {
      // Calculer et appliquer les hauteurs dynamiques pour toutes les sections non-collapsÃ©es
      document.querySelectorAll('.toc-section:not(.collapsed) .toc-section-content').forEach(content => {
        const childCount = content.querySelectorAll('a, .toc-category').length;
        const itemHeight = 50; // Hauteur approximative par Ã©lÃ©ment
        const baseHeight = 100; // Hauteur de base pour le padding
        const dynamicHeight = Math.max(500, (childCount * itemHeight) + baseHeight);
        
        content.style.maxHeight = `${dynamicHeight}px`;
      });
    },

    setupMJToggle() {
      const mjBtn = document.getElementById('mjToggleBtn');
      if (!mjBtn) return;

      // Initialize visual state based on current MJ status
      this.updateMJButtonVisual();
      this.updateMJBodyClass();

      const handleMJToggle = () => {
        if (window.JdrApp.state.isMJ) {
          // DÃ©jÃ  en mode MJ, dÃ©sactiver
          window.JdrApp.state.isMJ = false;
          this.updateMJButtonVisual();
          this.updateMJBodyClass();
          this.generateTOC(); // RÃ©gÃ©nÃ©rer le TOC pour cacher les sections MJ
          
          // Refresh objects display if currently on objects page
          this.refreshObjectsPageIfActive();
        } else {
          // Demander confirmation avant d'activer le mode MJ
          this.showMJConfirmation(() => {
            window.JdrApp.state.isMJ = true;
            this.updateMJButtonVisual();
            this.updateMJBodyClass();
            this.generateTOC(); // RÃ©gÃ©nÃ©rer le TOC pour afficher les sections MJ
            
            // Refresh objects display if currently on objects page
            this.refreshObjectsPageIfActive();
          });
        }
      };

      // Ajouter support tactile pour mobile
      mjBtn.addEventListener('click', handleMJToggle);
      mjBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleMJToggle();
      });
    },

    attachFoldoutEvents() {
      // Attacher les Ã©vÃ©nements directement aux headers de section
      document.querySelectorAll('.toc-section-header').forEach(header => {
        header.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const section = header.closest('.toc-section');
          if (section) {
            const wasCollapsed = section.classList.contains('collapsed');
            section.classList.toggle('collapsed');
            const isCollapsed = section.classList.contains('collapsed');
            
            const toggle = section.querySelector('.toc-section-toggle');
            if (toggle) {
              toggle.textContent = isCollapsed ? 'â–¶' : 'â–¼';
            }
            
            const content = section.querySelector('.toc-section-content');
            if (content) {
              // Force les styles directement en JavaScript pour compatibilitÃ© standalone
              if (isCollapsed) {
                content.style.maxHeight = '0px';
                content.style.opacity = '0';
                content.style.paddingTop = '0';
                content.style.paddingBottom = '0';
                content.style.overflow = 'hidden';
              } else {
                // Calculer dynamiquement la hauteur nÃ©cessaire en fonction du contenu
                const childCount = content.querySelectorAll('a, .toc-category').length;
                const itemHeight = 50; // Hauteur approximative par Ã©lÃ©ment (incluant padding et marge)
                const baseHeight = 100; // Hauteur de base pour le padding
                const dynamicHeight = Math.max(500, (childCount * itemHeight) + baseHeight);
                
                content.style.maxHeight = `${dynamicHeight}px`;
                content.style.opacity = '1';
                content.style.paddingTop = '';
                content.style.paddingBottom = '';
                content.style.overflow = 'visible';
              }
            }
          }
        });
      });

      // Attacher les Ã©vÃ©nements aux liens de catÃ©gorie
      document.querySelectorAll('.toc-category > a').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const category = link.closest('.toc-category');
          if (category) {
            category.classList.toggle('collapsed');
          }
        });
      });

      // Attacher les Ã©vÃ©nements aux liens de navigation normaux
      document.querySelectorAll('.toc a:not(.toc-category > a)').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const route = link.getAttribute('data-route');
          if (route) {
            // Special handling for objects page - force refresh when navigating to it
            if (route === 'objets') {
              // Set a flag to force refresh objects page after navigation
              JdrApp.modules.router._forceObjectsRefresh = true;
            }
            JdrApp.modules.router.navigate(route);
            
            // Auto-close sidebar on mobile/touch devices after navigation
            this.autoCloseMobileSidebar();
          }
        });
      });
    },

    /**
     * Auto-close sidebar on mobile/touch devices after navigation
     */
    autoCloseMobileSidebar() {
      // Check if device should show mobile toggle (touch device or mobile size)
      const isTouchDevice = 'ontouchstart' in window || 
                           navigator.maxTouchPoints > 0 || 
                           navigator.msMaxTouchPoints > 0 ||
                           window.matchMedia('(pointer: coarse)').matches;
      
      const isMobileSize = window.innerWidth <= window.UI_CONSTANTS?.BREAKPOINTS?.MOBILE;
      const shouldAutoClose = isTouchDevice || isMobileSize;
      
      if (shouldAutoClose) {
        const sidebar = document.querySelector('#sidebar');
        const menuToggle = document.querySelector('#menuToggle');
        const backdrop = document.querySelector('#backdrop');
        
        if (sidebar && sidebar.classList.contains('mobile-open')) {
          // Close mobile nav
          sidebar.classList.remove('mobile-open');
          if (menuToggle) menuToggle.setAttribute('aria-expanded', 'false');
          if (backdrop) backdrop.style.display = 'none';
          document.body.style.overflow = '';
        }
      }
    },

    updateMJButtonVisual() {
      const mjBtn = document.getElementById('mjToggleBtn');
      const mjIndicator = document.getElementById('mjStatusIndicator');
      
      if (!mjBtn) return;
      
      if (window.JdrApp.state.isMJ) {
        // Mode MJ activÃ© - bouton dorÃ© avec indicateur vert
        mjBtn.style.background = 'var(--gold)';
        mjBtn.style.borderColor = 'var(--gold)';
        mjBtn.innerHTML = 'ğŸ­ Mode MJ activÃ© <span id="mjStatusIndicator" style="position: absolute; top: -5px; right: -5px; width: 12px; height: 12px; border-radius: 50%; background: #16a34a; border: 2px solid white; display: inline-block;"></span>';
      } else {
        // Mode normal - bouton bronze sans indicateur
        mjBtn.style.background = 'var(--bronze)';
        mjBtn.style.borderColor = 'var(--bronze)';
        mjBtn.innerHTML = 'ğŸ­ MaÃ®tre de jeu <span id="mjStatusIndicator" style="position: absolute; top: -5px; right: -5px; width: 12px; height: 12px; border-radius: 50%; background: #dc2626; border: 2px solid white; display: none;"></span>';
      }
    },

    updateMJBodyClass() {
      const body = document.body;
      if (window.JdrApp.state.isMJ) {
        body.classList.remove('mj-off');
        body.classList.add('mj-on');
      } else {
        body.classList.remove('mj-on');
        body.classList.add('mj-off');
      }
    },

    showMJConfirmation(onConfirm) {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0,0,0,0.7);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
      `;
      
      modal.innerHTML = `
        <div style="
          background: var(--card);
          border: 3px solid var(--bronze);
          border-radius: 16px;
          padding: 2rem;
          max-width: 500px;
          margin: 1rem;
          text-align: center;
          box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        ">
          <h3 style="color: var(--bronze); margin-top: 0;">âš ï¸ Mode MaÃ®tre de jeu</h3>
          <p style="margin: 1.5rem 0; line-height: 1.6;">
            ÃŠtes-vous sÃ»r de vouloir activer le mode MaÃ®tre de jeu?<br><br>
            <strong style="color: var(--bronze);">Si vous Ãªtes juste un joueur, vous risquez d'Ãªtre spoilÃ©!</strong>
          </p>
          <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 2rem;">
            <button id="mjConfirmYes" class="btn-base" style="background: var(--bronze); color: white; border-color: var(--bronze);">
              Oui, je suis MJ
            </button>
            <button id="mjConfirmNo" class="btn-base" style="background: var(--rule); color: var(--accent-ink); border-color: var(--rule);">
              Non, annuler
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      modal.querySelector('#mjConfirmYes').addEventListener('click', () => {
        document.body.removeChild(modal);
        onConfirm();
      });
      
      modal.querySelector('#mjConfirmNo').addEventListener('click', () => {
        document.body.removeChild(modal);
      });
      
      // Fermer en cliquant sur le fond
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
        }
      });
    },

    generateTOCSection(section) {
      // Make all sections collapsed by default (ignoring section.collapsed from data)
      const sectionClass = 'toc-section collapsed';
      const toggleIcon = 'â–¶';
      
      return `
        <div class="${sectionClass}" data-section="${section.id}">
          <div class="toc-section-header">
            <span class="toc-section-title">${section.title}</span>
            <span class="toc-section-toggle">${toggleIcon}</span>
          </div>
          <div class="toc-section-content">
            ${section.items.map(item => this.generateTOCItem(item)).join('')}
          </div>
        </div>
      `;
    },

    generateTOCItem(item) {
      if (item.type === 'page') {
        return `<a data-route="${item.id}" href="#/${item.id}" class="">${item.icon} ${item.title}</a>`;
      } else if (item.type === 'category') {
        return this.generateTOCCategory(item);
      }
      return '';
    },

    generateTOCCategory(item) {
      const dataSource = window[item.items]; // CLASSES, SORTS, DONS
      if (!dataSource) return '';

      if (item.id === 'classes') {
        return `
          <div class="toc-category collapsed">
            <a data-route="classes" href="#/classes" class="">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource.map(classe => 
                `<a data-route="${JdrApp.utils.data.sanitizeId(classe.nom)}" href="#/${JdrApp.utils.data.sanitizeId(classe.nom)}" class="">${this.getClassIcon(classe.nom)} ${classe.nom}</a>`
              ).join('')}
            </div>
          </div>
        `;
      } else if (item.id === 'sorts') {
        return `
          <div class="toc-category">
            <a data-route="sorts" href="#/sorts">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource.map(category => 
                `<a data-route="sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getSortCategoryIcon(category.nom)} ${category.nom}</a>`
              ).join('')}
            </div>
          </div>
        `;
      } else if (item.id === 'dons') {
        return `
          <div class="toc-category collapsed">
            <a data-route="dons" href="#/dons" class="">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource.map(category => 
                `<a data-route="dons-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/dons-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getDonCategoryIcon(category.nom)} ${category.nom}</a>`
              ).join('')}
            </div>
          </div>
        `;
      }

      return '';
    },

    generateBasicTOC() {
      const tocContainer = document.querySelector('#toc');
      if (!tocContainer) return;

      const tocHTML = `
        <h4>Sommaire</h4>
        <a class="" data-route="creation" href="#/creation">ğŸ§™â€â™‚ï¸ CrÃ©ation d'un personnage</a>
        
        <div class="toc-category collapsed">
          <a data-route="classes" href="#/classes" class="">âš”ï¸ Classes</a>
          <div class="toc-sub">
            ${window.CLASSES ? window.CLASSES.map(classe => 
              `<a data-route="${JdrApp.utils.data.sanitizeId(classe.nom)}" href="#/${JdrApp.utils.data.sanitizeId(classe.nom)}" class="">${this.getClassIcon(classe.nom)} ${classe.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <div class="toc-category collapsed">
          <a data-route="sorts" href="#/sorts">ğŸ”® Sorts</a>
          <div class="toc-sub">
            ${window.SORTS ? window.SORTS.map(category => 
              `<a data-route="sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getSortCategoryIcon(category.nom)} ${category.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <div class="toc-category collapsed">
          <a data-route="dons" href="#/dons" class="">ğŸ–ï¸ Dons</a>
          <div class="toc-sub">
            ${window.DONS ? window.DONS.map(category => 
              `<a data-route="dons-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/dons-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getDonCategoryIcon(category.nom)} ${category.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <a data-route="objets" href="#/objets" class="">ğŸ“¦ Objets</a>
        
        <a data-route="elements" href="#/elements" class="">ğŸŒŸ Ã‰lÃ©ments</a>
        <a data-route="stats" href="#/stats" class="">ğŸ“Š Statistiques</a>
        <a data-route="competences-tests" href="#/competences-tests" class="">ğŸ¯ CompÃ©tences & Tests</a>
        <a data-route="etats" href="#/etats" class="">âš¡ Etats</a>
      `;
      
      tocContainer.innerHTML = tocHTML;
    },
    
    renderObjectsPage() {
      if (!window.OBJETS) return false;
      
      // Ensure the page is shown as active first
      this.show('objets');
      
      // Force complete regeneration if coming from navigation or MJ mode change
      const shouldForceRefresh = this._forceObjectsRefresh || false;
      this._forceObjectsRefresh = false; // Reset the flag
      
      // Force complete regeneration of the objects page content
      // This ensures that objects filtered out by MJ restrictions are now properly generated in the DOM
      setTimeout(() => {
        if (JdrApp.modules.renderer && JdrApp.modules.renderer.regenerateCurrentPage) {
          JdrApp.modules.renderer.regenerateCurrentPage();
        }
      }, shouldForceRefresh ? 100 : 50); // Slightly longer delay when forced refresh
      
      return true;
    },


    // Helper method to refresh objects page if currently active
    refreshObjectsPageIfActive() {
      const currentHash = window.location.hash;
      if (currentHash === '#/objets' || currentHash === '#objets') {
        setTimeout(() => {
          // Force full page regeneration to ensure objects filtered by MJ mode are now visible
          // This calls renderObjectsPage() which will regenerate the entire page with current filters
          this.renderObjectsPage();
        }, 150); // Slightly longer delay to ensure MJ state is updated
      }
    },
    
    getClassIcon(className) {
      const icons = {
        'Guerrier': 'ğŸ—¡ï¸',
        'Mage': 'ğŸ”®',
        'PrÃªtre': 'â›ª',
        'RÃ´deur': 'ğŸƒ',
        'Enchanteur': 'âœ¨'
      };
      return icons[className] || 'âš”ï¸';
    },
    
    getSortCategoryIcon(categoryName) {
      const icons = {
        'Sorts de Mage': 'ğŸ”®',
        'Sorts de PrÃªtre': 'â›ª',
        'Sorts d\'Enchanteur': 'âœ¨',
        'Sorts de Monstres': 'ğŸ’€'
      };
      return icons[categoryName] || 'ğŸ”®';
    },
    
    getDonCategoryIcon(categoryName) {
      const icons = {
        'Guerrier': 'ğŸ—¡ï¸',
        'Mage': 'ğŸ”®',
        'Pretre': 'â›ª',  // Sans accent comme dans les donnÃ©es
        'PrÃªtre': 'â›ª',  // Avec accent au cas oÃ¹
        'RÃ´deur': 'ğŸƒ',
        'Enchanteur': 'âœ¨',
        'GÃ©nÃ©raux': 'ğŸ–ï¸',
        'Generaux': 'ğŸ–ï¸'  // Sans accent comme dans les donnÃ©es
      };
      return icons[categoryName] || 'ğŸ–ï¸';
    },

    getMonstreCategoryIcon(categoryName) {
      const icons = {
        'ForÃªt': 'ğŸŒ²',
        'Foret': 'ğŸŒ²',  // Sans accent
        'Donjon': 'ğŸ°',
        'Dragons': 'ğŸ‰',
        'Mort-vivants': 'ğŸ’€',
        'DÃ©mons': 'ğŸ‘¹',
        'Demons': 'ğŸ‘¹',  // Sans accent
        'Animaux': 'ğŸ¦',
        'HumanoÃ¯des': 'ğŸ§Œ',
        'HumanoÃ¯des': 'ğŸ§Œ'  // Sans accent
      };
      return icons[categoryName] || 'ğŸ‘¹';
    },
    
    getObjetCategoryIcon(categoryName) {
      const icons = {
        'Armes': 'âš”ï¸',
        'Armures': 'ğŸ›¡ï¸',
        'Potions': 'ğŸ§ª',
        'Herbes Magiques': 'ğŸŒ¿',
        'Objets Magiques': 'âœ¨',
        'Accessoires': 'ğŸ’',
        'Consommables': 'ğŸ',
        'Composants': 'ğŸ”®',
        'Outils': 'ğŸ”¨'
      };
      return icons[categoryName] || 'ğŸ“¦';
    },

    renderObjectsPage() {
      // Use PageBuilder to generate the objets page dynamically
      JdrApp.modules.renderer.renderUnifiedContentPage('objet', window.OBJETS || []);
      this.updateActiveStates('objets');
      this.show('objets'); // Activer la page
      return true;
    },

    renderGMObjectsPage() {
      if (!window.OBJETS) return false;
      
      // Generate the GM objects page using PageBuilder
      const pageHtml = PageBuilder.buildGameMasterObjectPage(window.OBJETS);
      
      // Find or create the views container
      const viewsContainer = document.querySelector('#views');
      if (!viewsContainer) {
        console.error('Views container not found');
        return false;
      }
      
      // Remove existing GM objects page if it exists
      const existingPage = document.querySelector('[data-page="gestion-objets"]');
      if (existingPage) {
        existingPage.remove();
      }
      
      // Insert the new page
      viewsContainer.insertAdjacentHTML('beforeend', pageHtml);
      
      // Setup search functionality for GM page
      setTimeout(() => {
        this.setupGMObjectSearch();
      }, 100);
      
      // Show and activate page
      this.show('gestion-objets');
      this.updateActiveStates('gestion-objets');
      
      return true;
    },

    setupGMObjectSearch() {
      // Setup ID search for the GM objects page
      const idSearchInput = document.getElementById('id-search-input');
      if (idSearchInput) {
        // Remove existing listeners
        const newInput = idSearchInput.cloneNode(true);
        idSearchInput.parentNode.replaceChild(newInput, idSearchInput);
        
        newInput.addEventListener('keyup', (e) => {
          if (e.key === 'Enter') {
            const searchId = e.target.value.trim();
            if (JdrApp.modules.renderer && JdrApp.modules.renderer.performIdSearch) {
              JdrApp.modules.renderer.performIdSearch(searchId);
            }
          }
        });
      }
      
      // Setup clear button
      const clearButton = document.getElementById('clear-id-search');
      if (clearButton) {
        const newClearButton = clearButton.cloneNode(true);
        clearButton.parentNode.replaceChild(newClearButton, clearButton);
        
        newClearButton.addEventListener('click', () => {
          if (JdrApp.modules.renderer && JdrApp.modules.renderer.clearIdSearch) {
            JdrApp.modules.renderer.clearIdSearch();
          }
        });
      }
    },

    renderMonstersPage() {
      // Use PageBuilder to generate the monstres page dynamically
      JdrApp.modules.renderer.renderUnifiedContentPage('monster', window.MONSTRES || []);
      this.updateActiveStates('monstres');
      this.show('monstres'); // Activer la page
      return true;
    },
    
    renderTablesTresorsPage() {
      // Use PageBuilder to generate the tables-tresors page dynamically
      JdrApp.modules.renderer.renderUnifiedContentPage('tableTresor', window.TABLES_TRESORS || { tables: [] });
      this.updateActiveStates('tables-tresors');
      this.show('tables-tresors'); // Activer la page
      return true;
    },

    renderCollectionsObjectsPage() {
      // Safety check - if collections data is not available, try to wait a bit
      if (!window.COLLECTIONS || !window.COLLECTIONS.collections || window.COLLECTIONS.collections.length === 0) {
        setTimeout(() => this.renderCollectionsObjectsPage(), 100);
        return false;
      }
      
      // Create or find the page element
      let pageElement = document.getElementById('collections-objets');
      
      // If the page doesn't exist, create it
      if (!pageElement) {
        pageElement = document.createElement('article');
        pageElement.id = 'collections-objets';
        pageElement.setAttribute('data-page', 'collections-objets');
        pageElement.className = 'page';
        
        // Insert it into the views container
        const viewsContainer = document.querySelector('#views');
        
        if (viewsContainer) {
          viewsContainer.appendChild(pageElement);
        } else {
          console.error('Views container not found');
          return false;
        }
      }
      
      // Create the collections page content
      const collectionsContent = `
        <div class="page-header">
          <h1>ğŸ“š Collections d'Objets</h1>
          <div class="editable-section" data-section-type="pageDescription">
            <p class="editable" data-edit-type="generic" data-edit-section="description" data-item-identifier="collections-objets" data-page-type="collections">${this.getCollectionsDescription()}</p>
            <button class="edit-btn" data-edit-type="collections-description" style="display: none;">âœï¸ Modifier</button>
          </div>
        </div>
        
        <div class="collections-search">
          <div class="search-container">
            <input 
              type="text" 
              id="collection-search-input" 
              placeholder="Tapez le nom d'une collection..." 
              class="search-input"
              value="DÃ©part"
            />
            <button id="collection-search-btn" class="search-button">ğŸ” Rechercher</button>
          </div>
        </div>
        
        <div id="collection-results" class="collection-results" style="display: none;">
          <div id="collection-header" class="collection-header"></div>
          <div id="tag-filters" class="tag-filters"></div>
          <div id="collection-items" class="collection-items"></div>
        </div>
        
        <div id="available-collections" class="available-collections" style="display: none;">
          <h2>Collections disponibles</h2>
          <div class="collections-grid">
            <!-- Collections will be generated dynamically -->
          </div>
        </div>
      `;
      
      // Insert content into the page
      pageElement.innerHTML = collectionsContent;
      this.setupCollectionsEventListeners();
      
      // Show collections grid in dev mode, auto-fill search in normal mode
      const availableCollections = document.getElementById('available-collections');
      const searchInput = document.getElementById('collection-search-input');
      const isDevMode = this.isDevModeActive();
      
      
      // Generate collections dynamically
      this.generateCollectionsGrid();
      
      if (availableCollections) {
        if (isDevMode) {
          availableCollections.style.display = 'block';
          // In dev mode, show all collections without needing search
          // But keep the search functional for filtering
        } else {
          availableCollections.style.display = 'none';
          // In normal mode, collections are hidden - user must search manually
        }
      } else {
        console.error('âŒ available-collections element not found');
      }
      
      // Setup dev mode change listener
      this.setupDevModeListener();
      
      // Show and activate page after content is inserted
      this.show('collections-objets');
      this.updateActiveStates('collections-objets');
      
      // Ensure the page is visible regardless of dev mode
      if (pageElement) {
        pageElement.classList.add('active');
      }
      
      return true;
    },

    setupCollectionsEventListeners() {
      // console.log('Setting up collections event listeners...');
      const searchInput = document.getElementById('collection-search-input');
      const searchBtn = document.getElementById('collection-search-btn');
      const collectionCards = document.querySelectorAll('.collection-card');
      
      // console.log('Found elements:', {
      //   searchInput: !!searchInput,
      //   searchBtn: !!searchBtn,
      //   collectionCards: collectionCards.length
      // });
      
      // Search functionality
      const performSearch = () => {
        const searchTerm = searchInput.value.trim();
        if (searchTerm) {
          this.displayCollection(searchTerm);
        }
      };
      
      searchBtn.addEventListener('click', performSearch);
      searchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          performSearch();
        }
      });
      
      // Collection card clicks
      collectionCards.forEach(card => {
        card.addEventListener('click', () => {
          const collection = card.getAttribute('data-collection');
          searchInput.value = collection;
          this.displayCollection(collection);
        });
      });
    },

    displayCollection(collectionName) {
      if (!window.OBJETS || !window.OBJETS.objets || !window.COLLECTIONS || !window.COLLECTIONS.collections) return;
      
      // Find the collection by name or ID
      const collection = window.COLLECTIONS.collections.find(coll => 
        coll.id === collectionName || 
        coll.nom.toLowerCase() === collectionName.toLowerCase()
      );
      
      if (!collection) {
        this.showCollectionNotFound(collectionName);
        return;
      }
      
      // Filter objects by collection (using object numbers/IDs defined in collection)
      const filteredObjects = window.OBJETS.objets.filter(obj => {
        return collection.objets && collection.objets.includes(obj.numero);
      });
      
      const resultsContainer = document.getElementById('collection-results');
      const headerContainer = document.getElementById('collection-header');
      const itemsContainer = document.getElementById('collection-items');
      const tagFiltersContainer = document.getElementById('tag-filters');
      const availableCollections = document.getElementById('available-collections');
      
      // Hide available collections and show results
      if (availableCollections) {
        availableCollections.style.display = 'none';
      }
      if (resultsContainer) {
        resultsContainer.style.display = 'block';
      }
      
      const isDevMode = JdrApp.utils.isDevMode();
      
      // Update header with collection info
      if (headerContainer) {
        headerContainer.innerHTML = `
          ${isDevMode ? `
            <div class="collection-navigation" style="margin-bottom: 1rem;">
              <button class="btn small back-to-collections-btn" style="background: #6B7280;">â† Retour aux collections</button>
            </div>
          ` : ''}
          <h2>${collection.icon} ${collection.nom}</h2>
          <p class="collection-description">${collection.description}</p>
          <p>${filteredObjects.length} objet(s) dans cette collection</p>
          ${isDevMode ? `
            <div class="collection-dev-actions" style="margin-top: 1rem;">
              <button class="btn small add-object-btn" data-collection="${collection.id}">â• Ajouter un objet Ã  cette collection</button>
              <button class="btn small remove-object-btn" data-collection="${collection.id}">â– Retirer un objet de cette collection</button>
            </div>
          ` : ''}
        `;
      }
      
      // Get all unique tags from filtered objects for additional filtering
      const allTags = [...new Set(filteredObjects.flatMap(obj => obj.tags || []))];
      
      // Create tag filters if objects have multiple tags
      if (allTags.length > 1 && tagFiltersContainer) {
        tagFiltersContainer.innerHTML = `
          <h3>Filtrer par tag:</h3>
          <div class="tag-buttons">
            <button class="tag-filter-btn active" data-tag="all">Tous</button>
            ${allTags.map(tag => `
              <button class="tag-filter-btn" data-tag="${tag}">${tag}</button>
            `).join('')}
          </div>
        `;
      } else if (tagFiltersContainer) {
        tagFiltersContainer.innerHTML = '';
      }
      
      // Display objects
      this.renderCollectionItems(filteredObjects);
      
      // Setup add/remove object button listeners if in dev mode
      if (isDevMode) {
        const addObjectBtn = document.querySelector('.add-object-btn');
        if (addObjectBtn) {
          addObjectBtn.addEventListener('click', () => {
            const collection = addObjectBtn.getAttribute('data-collection');
            this.addObjectToCollection(collection);
          });
        }
        
        const removeObjectBtn = document.querySelector('.remove-object-btn');
        if (removeObjectBtn) {
          removeObjectBtn.addEventListener('click', () => {
            const collection = removeObjectBtn.getAttribute('data-collection');
            this.removeObjectFromCollection(collection);
          });
        }

        const backToCollectionsBtn = document.querySelector('.back-to-collections-btn');
        if (backToCollectionsBtn) {
          backToCollectionsBtn.addEventListener('click', () => {
            this.showCollectionsGrid();
          });
        }
      }
      
      // Tag filter event listeners
      document.querySelectorAll('.tag-filter-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          // Update active state
          document.querySelectorAll('.tag-filter-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          
          const selectedTag = btn.getAttribute('data-tag');
          let itemsToShow = filteredObjects;
          
          if (selectedTag !== 'all') {
            itemsToShow = filteredObjects.filter(obj => 
              obj.tags && obj.tags.includes(selectedTag)
            );
          }
          
          this.renderCollectionItems(itemsToShow);
        });
      });
    },

    showCollectionNotFound(collectionName) {
      const resultsContainer = document.getElementById('collection-results');
      const headerContainer = document.getElementById('collection-header');
      const itemsContainer = document.getElementById('collection-items');
      const tagFiltersContainer = document.getElementById('tag-filters');
      const availableCollections = document.getElementById('available-collections');
      
      // Show error message for non-existent collection
      if (availableCollections) {
        availableCollections.style.display = 'none';
      }
      if (resultsContainer) {
        resultsContainer.style.display = 'block';
      }
      
      if (headerContainer) {
        const isDevMode = this.isDevModeActive();
        headerContainer.innerHTML = `
          <div class="collection-error">
            <h2>âŒ Collection introuvable</h2>
            <p>Aucune collection nommÃ©e "<strong>${collectionName}</strong>" n'a Ã©tÃ© trouvÃ©e.</p>
            ${isDevMode ? 
              `<p>Les collections disponibles sont listÃ©es ci-dessous.</p>` : 
              `<p>VÃ©rifiez l'orthographe ou contactez un administrateur pour connaÃ®tre les collections disponibles.</p>`
            }
          </div>
        `;
      }
      
      if (itemsContainer) {
        itemsContainer.innerHTML = '';
      }
      if (tagFiltersContainer) {
        tagFiltersContainer.innerHTML = '';
      }
      
      // Clear search input after delay and show available collections only in dev mode
      setTimeout(() => {
        document.getElementById('collection-search-input').value = '';
        
        // Only show collections grid in dev mode
        const isDevMode = this.isDevModeActive();
        if (availableCollections) {
          availableCollections.style.display = isDevMode ? 'block' : 'none';
        }
        if (resultsContainer) {
          resultsContainer.style.display = 'none';
        }
      }, 3000);
    },

    renderCollectionItems(items) {
      const itemsContainer = document.getElementById('collection-items');
      
      // Multiple ways to detect dev mode for robustness
      const isDevMode = (
        (JdrApp && JdrApp.utils && JdrApp.utils.isDevMode && JdrApp.utils.isDevMode()) ||
        document.body.classList.contains('dev-on') ||
        (JdrApp.modules && JdrApp.modules.editor && JdrApp.modules.editor.isDevMode)
      );
      
      
      // Check if CardBuilder is available
      if (!window.CardBuilder) {
        console.error('CardBuilder not available, falling back to simple display');
        const itemsHTML = items.map(item => `
          <div class="card" data-object-numero="${item.numero}">
            <h4>${item.nom}</h4>
            <p><strong>NÂ°${item.numero}</strong></p>
            <p>${item.description}</p>
            <hr>
            <p>${item.effet}</p>
            <div style="display: flex; justify-content: space-between;">
              <span>${item.prix}</span>
              <span>${item.poids}</span>
            </div>
            ${isDevMode ? `
              <div class="dev-controls" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #ccc;">
                <button class="btn small edit-object-btn" data-numero="${item.numero}">âœï¸ Ã‰diter</button>
                <button class="btn small remove-from-collection-btn" data-numero="${item.numero}" style="background: #f59e0b;">â– Retirer</button>
                <button class="btn small delete-object-btn" data-numero="${item.numero}" style="background: #ef4444;">ğŸ—‘ï¸ Supprimer</button>
              </div>
            ` : ''}
          </div>
        `).join('');
        itemsContainer.innerHTML = itemsHTML;
      } else {
        // Use the existing CardBuilder system to ensure consistent formatting and images
        const itemsHTML = items.map(item => {
          return window.CardBuilder.create('objet', item, 'objets').build();
        }).join('');
        
        itemsContainer.innerHTML = itemsHTML;
        
        // Add dev controls after DOM insertion if in dev mode
        if (isDevMode) {
          items.forEach(item => {
            const card = itemsContainer.querySelector(`.card[data-objet-name="${item.nom}"]`);
            if (card) {
              const devControls = document.createElement('div');
              devControls.className = 'dev-controls collection-dev-controls';
              devControls.style.cssText = 'margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #ddd;';
              devControls.innerHTML = `
                <button class="btn small edit-object-btn" data-numero="${item.numero}" style="margin: 2px;">âœï¸ Ã‰diter</button>
                <button class="btn small remove-from-collection-btn" data-numero="${item.numero}" style="margin: 2px; background: #f59e0b;">â– Retirer de cette collection</button>
                <button class="btn small delete-object-btn" data-numero="${item.numero}" style="margin: 2px; background: #ef4444;">ğŸ—‘ï¸ Supprimer dÃ©finitivement</button>
              `;
              card.appendChild(devControls);
            }
          });
        }
      }
      
      // Add event listeners for dev controls
      if (isDevMode) {
        this.setupCollectionEditControls();
      }
      
      // Auto-load images and manage dev mode buttons after rendering
      setTimeout(() => {
        if (JdrApp.modules.renderer && JdrApp.modules.renderer.autoLoadImages) {
          JdrApp.modules.renderer.autoLoadImages();
        }
        
        // Force apply dev mode classes to ensure CSS rules work
        this.ensureDevModeClasses();
      }, 100);
    },

    setupCollectionEditControls() {
      // Edit object buttons
      const editBtns = document.querySelectorAll('.edit-object-btn');
      const removeBtns = document.querySelectorAll('.remove-from-collection-btn');
      const deleteBtns = document.querySelectorAll('.delete-object-btn');
      
      // console.log('ğŸ›ï¸ Setting up object controls:', {
      //   editBtns: editBtns.length,
      //   removeBtns: removeBtns.length,
      //   deleteBtns: deleteBtns.length
      // });

      editBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const objectNumero = parseInt(btn.getAttribute('data-numero'));
          // console.log('âœï¸ Edit object clicked:', objectNumero);
          this.editCollectionObject(objectNumero);
        });
      });

      // Remove from collection buttons
      removeBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const objectNumero = parseInt(btn.getAttribute('data-numero'));
          // console.log('â– Remove from collection clicked:', objectNumero);
          this.removeObjectFromCurrentCollection(objectNumero);
        });
      });

      // Delete object buttons
      deleteBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const objectNumero = parseInt(btn.getAttribute('data-numero'));
          // console.log('ğŸ—‘ï¸ Delete object clicked:', objectNumero);
          this.deleteCollectionObject(objectNumero);
        });
      });
    },

    editCollectionObject(objectNumero) {
      // Find the object in the data (normalize comparison)
      const object = window.OBJETS.objets.find(obj => parseInt(obj.numero) === objectNumero);
      if (!object) {
        console.error('Object not found:', objectNumero);
        return;
      }

      // Navigate to the objects page and trigger edit for this specific object
      // This reuses the existing object editing functionality
      window.location.hash = '#/objets';
      
      // Wait for the page to load, then trigger edit
      setTimeout(() => {
        const objectCard = document.querySelector(`[data-numero="${objectNumero}"]`);
        if (objectCard) {
          // Trigger the existing edit functionality
          const editableElements = objectCard.querySelectorAll('.editable');
          if (editableElements.length > 0) {
            // Focus on the first editable element to start editing
            editableElements[0].click();
          }
        }
      }, 500);
    },

    removeObjectFromCurrentCollection(objectNumero) {
      // Find the object in the data (normalize comparison)
      const object = window.OBJETS.objets.find(obj => parseInt(obj.numero) === objectNumero);
      if (!object) {
        console.error('Object not found:', objectNumero);
        return;
      }

      // Determine which collection we're currently viewing
      const searchInput = document.getElementById('collection-search-input');
      const currentCollectionName = searchInput ? searchInput.value : null;
      
      if (!currentCollectionName) {
        alert('Impossible de dÃ©terminer la collection actuelle.');
        return;
      }

      // Find the current collection
      const collection = window.COLLECTIONS.collections.find(coll => 
        coll.nom === currentCollectionName || coll.id === currentCollectionName
      );
      
      if (!collection) {
        alert(`Collection "${currentCollectionName}" introuvable.`);
        return;
      }

      // Check if the object is in this collection (normalize comparison)
      const objNum = parseInt(objectNumero);
      const isInCollection = collection.objets.includes(objNum) || collection.objets.includes(objectNumero);
      if (!isInCollection) {
        alert(`L'objet "${object.nom}" n'est pas dans la collection "${collection.nom}".`);
        return;
      }

      // Confirm removal
      const confirmRemove = confirm(
        `ÃŠtes-vous sÃ»r de vouloir retirer l'objet "${object.nom}" de la collection "${collection.nom}"?\n\n` +
        `L'objet ne sera pas supprimÃ©, seulement retirÃ© de cette collection.`
      );
      if (!confirmRemove) return;

      // Remove the object from the collection (normalize comparison)
      let objectIndex = collection.objets.indexOf(objNum);
      if (objectIndex === -1) {
        objectIndex = collection.objets.indexOf(objectNumero);
      }
      if (objectIndex !== -1) {
        collection.objets.splice(objectIndex, 1);
        
        // Show notification
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification(`â– Objet "${object.nom}" retirÃ© de la collection "${collection.nom}"`, 'success');
        }

        // Refresh the current collection view
        this.displayCollection(collection.id);
      }
    },

    deleteCollectionObject(objectNumero) {
      // Find the object in the data (normalize comparison)  
      const object = window.OBJETS.objets.find(obj => parseInt(obj.numero) === objectNumero);
      if (!object) {
        console.error('Object not found:', objectNumero);
        return;
      }

      // Confirm deletion
      const confirmDelete = confirm(`ÃŠtes-vous sÃ»r de vouloir supprimer l'objet "${object.nom}" (NÂ°${object.numero}) ?`);
      if (!confirmDelete) return;

      // Remove the object from the data (normalize comparison)
      const objectIndex = window.OBJETS.objets.findIndex(obj => parseInt(obj.numero) === objectNumero);
      if (objectIndex !== -1) {
        window.OBJETS.objets.splice(objectIndex, 1);
        
        // Show notification
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification(`ğŸ—‘ï¸ Objet "${object.nom}" supprimÃ©`, 'success');
        }

        // Refresh the current collection view
        const currentSearch = document.getElementById('collection-search-input').value;
        if (currentSearch) {
          this.displayCollection(currentSearch);
        }
      }
    },

    addObjectToCollection(collectionId) {
      // Find the collection
      const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
      if (!collection) {
        alert('Collection introuvable.');
        return;
      }
      
      // Show a list of all available objects to choose from
      const allObjects = window.OBJETS.objets;
      if (allObjects.length === 0) {
        alert('Aucun objet disponible Ã  ajouter.');
        return;
      }
      
      // Filter out objects already in this collection
      // Normalize number comparison to handle both string and number types
      const availableObjects = allObjects.filter(obj => {
        const objNum = parseInt(obj.numero);
        return !collection.objets.includes(objNum) && !collection.objets.includes(obj.numero);
      });
      
      if (availableObjects.length === 0) {
        alert('Tous les objets sont dÃ©jÃ  dans cette collection.');
        return;
      }
      
      // Create a selection modal with dropdown
      this.showObjectSelectionModal(
        `Ajouter un objet Ã  la collection "${collection.nom}"`,
        availableObjects,
        (selectedObject) => {
          // Add the object to the collection (normalize to number type)
          const objNum = parseInt(selectedObject.numero);
          collection.objets.push(objNum);
          
          // Show notification
          if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
            JdrApp.modules.storage.showNotification(`â• Objet "${selectedObject.nom}" ajoutÃ© Ã  la collection "${collection.nom}"`, 'success');
          }
          
          // Refresh the current collection view to show the added object
          this.displayCollection(collectionId);
          
          // Auto-scroll to the added object
          setTimeout(() => {
            const addedObjectCard = document.querySelector(`[data-numero="${selectedObject.numero}"]`);
            if (addedObjectCard) {
              addedObjectCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
              // Highlight the added object briefly
              addedObjectCard.style.border = '3px solid #10B981';
              setTimeout(() => {
                addedObjectCard.style.border = '';
              }, 2000);
            }
          }, 500);
        }
      );
    },

    removeObjectFromCollection(collectionId) {
      // Find the collection
      const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
      if (!collection) {
        alert('Collection introuvable.');
        return;
      }
      
      if (!collection.objets || collection.objets.length === 0) {
        alert('Cette collection est vide.');
        return;
      }
      
      // Get the objects in this collection
      const collectionObjects = window.OBJETS.objets.filter(obj => 
        collection.objets.includes(obj.numero)
      );
      
      // Create a selection modal with dropdown
      this.showObjectSelectionModal(
        `Retirer un objet de la collection "${collection.nom}"`,
        collectionObjects,
        (selectedObject) => {
          // Remove the object from the collection
          const objectIndex = collection.objets.indexOf(selectedObject.numero);
          if (objectIndex !== -1) {
            collection.objets.splice(objectIndex, 1);
            
            // Show notification
            if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
              JdrApp.modules.storage.showNotification(`â– Objet "${selectedObject.nom}" retirÃ© de la collection "${collection.nom}"`, 'success');
            }
            
            // Refresh the current collection view
            this.displayCollection(collectionId);
          }
        }
      );
    },

    showCollectionsGrid() {
      // Hide collection results and show collections grid only in dev mode
      const resultsContainer = document.getElementById('collection-results');
      const availableCollections = document.getElementById('available-collections');
      const searchInput = document.getElementById('collection-search-input');
      
      if (resultsContainer) {
        resultsContainer.style.display = 'none';
      }
      
      // Only show collections grid in dev mode
      const isDevMode = this.isDevModeActive();
      if (availableCollections) {
        availableCollections.style.display = isDevMode ? 'block' : 'none';
      }
      
      // Clear the search input
      if (searchInput) {
        searchInput.value = '';
      }
      
      // Refresh the collections grid to ensure it's up to date if in dev mode
      if (isDevMode) {
        this.generateCollectionsGrid();
      }
    },

    showObjectSelectionModal(title, objects, onSelectCallback) {
      // Remove any existing modal
      const existingModal = document.querySelector('#object-selection-modal');
      if (existingModal) {
        existingModal.remove();
      }

      // Create modal HTML
      const modal = document.createElement('dialog');
      modal.id = 'object-selection-modal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        border: 3px solid #8B4513;
        border-radius: 12px;
        padding: 0;
        background: transparent !important;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5) !important;
      `;

      const selectOptions = objects
        .map(obj => `<option value="${obj.numero}">NÂ°${obj.numero} - ${obj.nom}</option>`)
        .join('');

      modal.innerHTML = `
        <div style="
          background: white; 
          border-radius: 12px; 
          padding: 1.5rem; 
          border: 3px solid #8B4513;
          font-family: inherit;
          font-size: 16px;
        ">
          <h2 style="
            color: #8B4513; 
            font-family: 'Cinzel', serif; 
            margin: 0 0 1rem 0; 
            text-align: center;
          ">${title}</h2>
          
          <div style="margin: 1rem 0;">
            <label for="object-select" style="
              display: block; 
              margin-bottom: 0.5rem; 
              color: #8B4513; 
              font-weight: bold;
            ">SÃ©lectionnez un objet :</label>
            <select id="object-select" style="
              width: 100%; 
              padding: 0.5rem; 
              border: 2px solid #8B4513; 
              border-radius: 8px; 
              font-size: 16px;
              font-family: inherit;
            ">
              <option value="">-- Choisissez un objet --</option>
              ${selectOptions}
            </select>
          </div>
          
          <div style="
            display: flex; 
            gap: 1rem; 
            justify-content: center; 
            margin-top: 1.5rem;
          ">
            <button class="btn-confirm-selection" style="
              background: #10B981; 
              color: white; 
              border: none; 
              padding: 0.75rem 1.5rem; 
              border-radius: 8px; 
              cursor: pointer; 
              font-weight: bold;
            ">Confirmer</button>
            <button class="btn-cancel-selection" style="
              background: #6B7280; 
              color: white; 
              border: none; 
              padding: 0.75rem 1.5rem; 
              border-radius: 8px; 
              cursor: pointer; 
              font-weight: bold;
            ">Annuler</button>
          </div>
        </div>
      `;

      // Add to body and show
      document.body.appendChild(modal);
      modal.showModal();

      // Set up event handlers
      const select = modal.querySelector('#object-select');
      const confirmBtn = modal.querySelector('.btn-confirm-selection');
      const cancelBtn = modal.querySelector('.btn-cancel-selection');

      confirmBtn.addEventListener('click', () => {
        const selectedNumero = parseInt(select.value);
        if (selectedNumero) {
          const selectedObject = objects.find(obj => obj.numero === selectedNumero);
          if (selectedObject && onSelectCallback) {
            onSelectCallback(selectedObject);
          }
        } else {
          alert('Veuillez sÃ©lectionner un objet.');
          return;
        }
        modal.close();
        modal.remove();
      });

      cancelBtn.addEventListener('click', () => {
        modal.close();
        modal.remove();
      });

      // Handle ESC key
      modal.addEventListener('close', () => {
        modal.remove();
      });
    },

    ensureDevModeClasses() {
      // Ensure the body has the correct dev mode class
      const isDevMode = JdrApp && JdrApp.utils && JdrApp.utils.isDevMode ? JdrApp.utils.isDevMode() : false;
      
      if (isDevMode) {
        document.body.classList.remove('dev-off');
        document.body.classList.add('dev-on');
      } else {
        document.body.classList.remove('dev-on');
        document.body.classList.add('dev-off');
      }
      
      // Force hide image buttons on collections page if not in dev mode
      if (!isDevMode) {
        const collectionItems = document.getElementById('collection-items');
        if (collectionItems) {
          const imageButtons = collectionItems.querySelectorAll('.illus label.up, .illus button.rm');
          imageButtons.forEach(button => {
            button.style.setProperty('display', 'none', 'important');
          });
        }
      }
    },

    getCollectionsDescription() {
      return JdrApp.data.customPageDescriptions['collections-objets'] || 'Recherchez et explorez des collections d\'objets organisÃ©es par thÃ¨me';
    },

    generateCollectionsGrid() {
      if (!window.COLLECTIONS || !window.COLLECTIONS.collections) {
        return;
      }
      
      // Use defined collections instead of extracting from tags
      const collections = window.COLLECTIONS.collections;
      
      // Collection icons are now defined in the collections data itself
      
      const isDevMode = this.isDevModeActive();
      const collectionsGrid = document.querySelector('.collections-grid');
      
      if (!collectionsGrid) return;
      
      // Generate HTML for each collection
      const collectionsHTML = collections
        .map((collection) => {
          const count = collection.objets ? collection.objets.length : 0;
          return `
            <div class="collection-card" data-collection="${collection.id}">
              <div class="collection-icon">${collection.icon}</div>
              <h3>${collection.nom}</h3>
              <p>${count} objet(s)</p>
              <p class="collection-description">${collection.description}</p>
              ${isDevMode ? `
                <div class="collection-dev-controls">
                  <button class="btn small edit-collection-btn" data-collection="${collection.id}" title="Modifier cette collection">âœï¸ Modifier</button>
                  <button class="btn small delete-collection-btn" data-collection="${collection.id}" title="Supprimer cette collection">ğŸ—‘ï¸ Supprimer</button>
                </div>
              ` : ''}
            </div>
          `;
        }).join('');
      
      // Add "create new collection" button in dev mode
      const devActions = isDevMode ? `
        <div class="collection-card new-collection-card">
          <div class="collection-icon">â•</div>
          <h3>Nouvelle Collection</h3>
          <p>CrÃ©er une collection</p>
          <button class="btn small create-collection-btn">â• CrÃ©er</button>
        </div>
      ` : '';
      
      collectionsGrid.innerHTML = collectionsHTML + devActions;
      
      // console.log('ğŸ“¦ Collections grid generated:', {
      //   collectionsCount: collections.length,
      //   hasDevActions: !!devActions,
      //   gridContent: collectionsGrid.innerHTML.length + ' chars'
      // });
      
      // Setup event listeners for collections (always active)
      this.setupCollectionEventListeners();
      
      // Setup dev-specific controls only in dev mode
      if (isDevMode) {
        this.setupCollectionManagementControls();
      }
    },

    isDevModeActive() {
      // Multiple ways to detect dev mode for robustness
      return (
        (JdrApp && JdrApp.utils && JdrApp.utils.isDevMode && JdrApp.utils.isDevMode()) ||
        document.body.classList.contains('dev-on') ||
        (JdrApp.modules && JdrApp.modules.editor && JdrApp.modules.editor.isDevMode)
      );
    },

    setupCollectionEventListeners() {
      // Collection card click listeners (open collection for viewing/editing)
      const collectionCards = document.querySelectorAll('.collection-card:not(.new-collection-card)');
      
      collectionCards.forEach(card => {
        card.addEventListener('click', (e) => {
          // Don't trigger if clicking on control buttons
          if (e.target.closest('.collection-dev-controls')) {
            return;
          }
          
          const collectionId = card.getAttribute('data-collection');
          if (collectionId) {
            // Find collection to get its name
            const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
            if (collection) {
              // Fill search input with collection name
              const searchInput = document.getElementById('collection-search-input');
              if (searchInput) {
                searchInput.value = collection.nom;
              }
              
              // Open the collection
              this.displayCollection(collectionId);
            }
          }
        });
      });
    },

    setupCollectionManagementControls() {
      // Create new collection button
      const createBtn = document.querySelector('.create-collection-btn');
      const editBtns = document.querySelectorAll('.edit-collection-btn');
      const deleteBtns = document.querySelectorAll('.delete-collection-btn');
      
      // console.log('ğŸ›ï¸ Setting up collection controls:', {
      //   createBtn: !!createBtn,
      //   editBtns: editBtns.length,
      //   deleteBtns: deleteBtns.length
      // });
      
      if (createBtn) {
        createBtn.addEventListener('click', () => {
          // console.log('â• Create collection clicked');
          this.createNewCollection();
        });
      }

      // Edit collection buttons (rename)
      editBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const collectionName = btn.getAttribute('data-collection');
          // console.log('âœï¸ Edit collection clicked:', collectionName);
          this.renameCollection(collectionName);
        });
      });

      // Delete collection buttons
      deleteBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const collectionName = btn.getAttribute('data-collection');
          // console.log('ğŸ—‘ï¸ Delete collection clicked:', collectionName);
          this.deleteCollection(collectionName);
        });
      });
    },

    createNewCollection() {
      const collectionName = prompt('Nom de la nouvelle collection:');
      if (!collectionName || !collectionName.trim()) return;
      
      const trimmedName = collectionName.trim();
      
      // Generate an ID from the name
      const collectionId = trimmedName.toLowerCase().replace(/[^a-z0-9]/g, '-');
      
      // Check if collection already exists
      const existingCollection = window.COLLECTIONS.collections.find(coll => 
        coll.id === collectionId || coll.nom.toLowerCase() === trimmedName.toLowerCase()
      );
      
      if (existingCollection) {
        alert(`La collection "${trimmedName}" existe dÃ©jÃ .`);
        return;
      }
      
      // Get collection description and icon
      const collectionDescription = prompt('Description de la collection:', 'Nouvelle collection d\'objets');
      const collectionIcon = prompt('IcÃ´ne de la collection (emoji):', 'ğŸ“¦');
      
      // Create new collection object
      const newCollection = {
        id: collectionId,
        nom: trimmedName,
        description: collectionDescription || 'Nouvelle collection d\'objets',
        icon: collectionIcon || 'ğŸ“¦',
        objets: []
      };
      
      // Add to collections data
      window.COLLECTIONS.collections.push(newCollection);
      
      // Refresh the grid
      this.generateCollectionsGrid();
      
      if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
        JdrApp.modules.storage.showNotification(`âœ… Collection "${trimmedName}" crÃ©Ã©e avec succÃ¨s!`, 'success');
      }
    },

    renameCollection(collectionId) {
      // Find the collection by ID
      const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
      if (!collection) {
        alert('Collection introuvable.');
        return;
      }
      
      const newName = prompt(`Nouveau nom pour la collection "${collection.nom}":`, collection.nom);
      if (!newName || !newName.trim() || newName.trim() === collection.nom) return;
      
      const trimmedNewName = newName.trim();
      
      // Check if new name already exists
      const existingCollection = window.COLLECTIONS.collections.find(coll => 
        coll.id !== collectionId && coll.nom.toLowerCase() === trimmedNewName.toLowerCase()
      );
      
      if (existingCollection) {
        alert(`La collection "${trimmedNewName}" existe dÃ©jÃ .`);
        return;
      }
      
      // Update collection name
      collection.nom = trimmedNewName;
      
      // Refresh the collections grid
      this.generateCollectionsGrid();
      
      if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
        JdrApp.modules.storage.showNotification(`âœ… Collection renommÃ©e en "${trimmedNewName}"`, 'success');
      }
    },

    deleteCollection(collectionId) {
      // Find the collection by ID
      const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
      if (!collection) {
        alert('Collection introuvable.');
        return;
      }
      
      const objectCount = collection.objets ? collection.objets.length : 0;
      
      const confirmDelete = confirm(
        `ÃŠtes-vous sÃ»r de vouloir supprimer la collection "${collection.nom}"?\n` +
        `Cette collection contient ${objectCount} objet(s).\n` +
        `Les objets ne seront pas supprimÃ©s, seulement la collection sera retirÃ©e.`
      );
      
      if (!confirmDelete) return;
      
      // Remove the collection from the collections array
      const collectionIndex = window.COLLECTIONS.collections.findIndex(coll => coll.id === collectionId);
      if (collectionIndex !== -1) {
        window.COLLECTIONS.collections.splice(collectionIndex, 1);
        
        // Refresh the collections grid
        this.generateCollectionsGrid();
        
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification(`ğŸ—‘ï¸ Collection "${collection.nom}" supprimÃ©e`, 'success');
        }
      }
    },

    setupDevModeListener() {
      // Listen for dev mode changes via EventBus
      if (window.EventBus && window.Events) {
        EventBus.on(Events.EDITOR_TOGGLE, (payload) => {
          // console.log('ğŸ”„ Dev mode changed via EventBus:', payload.enabled);
          setTimeout(() => this.refreshCollectionsView(), 50);
        });
      }
      
      // Also listen for body class changes (fallback)
      if (window.MutationObserver) {
        if (this.devModeObserver) {
          this.devModeObserver.disconnect();
        }
        
        // Track the previous dev mode state to avoid loops
        let lastDevMode = this.isDevModeActive();
        
        this.devModeObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
              const currentDevMode = this.isDevModeActive();
              
              // Only refresh if dev mode actually changed
              if (currentDevMode !== lastDevMode) {
                // console.log('ğŸ”„ Body class changed, refreshing views - Dev mode:', currentDevMode);
                lastDevMode = currentDevMode;
                setTimeout(() => this.refreshCollectionsView(), 100);
              }
            }
          });
        });
        
        this.devModeObserver.observe(document.body, {
          attributes: true,
          attributeFilter: ['class']
        });
      }
    },

    refreshCollectionsView() {
      const currentHash = window.location.hash;
      
      // Refresh collections page if we're on it
      if (currentHash === '#/collections-objets') {
        const availableCollections = document.getElementById('available-collections');
        const isDevMode = this.isDevModeActive();
        
        // console.log('ğŸ”„ Refreshing collections view - Dev mode:', isDevMode);
        
        // Regenerate the collections grid
        this.generateCollectionsGrid();
        
        // Update visibility
        if (availableCollections) {
          if (isDevMode) {
              availableCollections.style.display = 'block';
          } else {
              availableCollections.style.display = 'none';
          }
        }
      }
      
      // Also refresh objects page if we're on it (for filter visibility)
      if (currentHash === '#/objets') {
        console.log('ğŸ”„ Refreshing objects page due to dev mode change');
        setTimeout(() => {
          this.renderObjectsPage();
        }, 100); // Augmenter le dÃ©lai pour Ãªtre sÃ»r que le dev mode est Ã  jour
      }
    },

    updateCollectionsDescription(newDescription) {
      JdrApp.data.customPageDescriptions['collections-objets'] = newDescription;
      // Also update via ContentFactory for consistency
      if (window.ContentFactory) {
        ContentFactory.updatePageDescription('collections', newDescription);
      }
    },

    renderFeuillePersonnagePage() {
      // Create or find the page element
      let pageElement = document.getElementById('feuille-personnage');
      
      // If the page doesn't exist, create it
      if (!pageElement) {
        pageElement = document.createElement('article');
        pageElement.id = 'feuille-personnage';
        pageElement.setAttribute('data-page', 'feuille-personnage');
        pageElement.className = 'page';
        
        // Insert it into the views container
        const viewsContainer = document.querySelector('#views');
        
        if (viewsContainer) {
          viewsContainer.appendChild(pageElement);
        } else {
          console.error('Views container not found');
          return false;
        }
      }
      
      // Create full PDF content for all versions  
      const feuillePersonnageContent = `
        <div class="page-header">
          <h1>ğŸ“‹ Feuille de personnage</h1>
        </div>
        
          
          
          <!-- PDF Info and Actions -->
          <div class="pdf-info-container" style="width: 100%; margin: 1rem 0; padding: 2rem; border: 2px solid var(--bronze); border-radius: 12px; background: var(--card); text-align: center;">
            <h3 style="color: var(--gold); font-family: 'Cinzel', serif; margin: 0 0 1rem 0;">ğŸ“„ Feuille de personnage PDF</h3>
            <p style="color: var(--text); margin: 1rem 0;">Feuille de personnage complÃ¨te de 3 pages pour vos aventures BabJDR</p>
            
            <div class="pdf-preview-actions" style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; margin-top: 1.5rem;">
              <button id="open-pdf-new-tab" class="btn-base" style="background: var(--bronze); color: white;">
                ğŸ“– Voir le PDF
              </button>
              <button id="download-pdf-direct" class="btn-base" style="background: var(--emerald); color: white;">
                ğŸ“¥ TÃ©lÃ©charger
              </button>
              <button id="print-pdf-direct" class="btn-base" style="background: var(--gold); color: white;">
                ğŸ–¨ï¸ Imprimer
              </button>
            </div>
            
            <p style="color: var(--text-muted); font-size: 0.9rem; margin-top: 1rem;">
              ğŸ’¡ Astuce : Cliquez sur "Voir le PDF" pour l'ouvrir dans un nouvel onglet
            </p>
          </div>
          
          <div class="pdf-fallback" style="display: none; text-align: center; padding: 2rem; background: var(--accent-bg); border-radius: 8px; margin: 1rem 0;">
            <h3 style="color: var(--bronze);">ğŸ“„ Feuille de personnage BabJDR</h3>
            <p style="color: var(--accent-ink); margin: 1rem 0;">
              Votre navigateur ne peut pas afficher le PDF directement. Utilisez les boutons ci-dessous:
            </p>
            
            <div class="pdf-info" style="background: white; border: 1px solid var(--rule); border-radius: 8px; padding: 1.5rem; margin: 1rem 0; text-align: left;">
              <h4 style="color: var(--bronze); margin-top: 0;">ğŸ“ Contenu de la feuille:</h4>
              <ul style="color: var(--accent-ink); line-height: 1.8;">
                <li><strong>Informations du personnage:</strong> Nom, classe, niveau, expÃ©rience</li>
                <li><strong>CaractÃ©ristiques:</strong> Force, Endurance, AgilitÃ©, Intelligence, VolontÃ©, Chance</li>
                <li><strong>Statistiques dÃ©rivÃ©es:</strong> Vie, Mana, Initiative, Fortune, Armure, Esquive</li>
                <li><strong>CompÃ©tences:</strong> Hardiesse, Finesse, Coordination, RÃ©flexion, Ã‰loquence</li>
                <li><strong>Ã‰lÃ©ments:</strong> Armure Ã©lÃ©mentaire (Feu, Eau, Terre, Air, LumiÃ¨re, Nuit, Divin, MalÃ©fique)</li>
                <li><strong>Sorts et capacitÃ©s:</strong> Liste des sorts connus et dons acquis</li>
                <li><strong>Inventaire:</strong> Consommables et sac gÃ©nÃ©ral</li>
                <li><strong>Background:</strong> Histoire, apparence et personnalitÃ© du personnage</li>
              </ul>
            </div>
          </div>
          
        </div>
        
        <div class="character-sheet-info" style="margin-top: 1rem; text-align: center; color: var(--accent-ink);">
          <p><strong>ğŸ’¡ Info:</strong> La feuille de personnage est un PDF imprimable de 3 pages contenant tous les champs nÃ©cessaires pour votre personnage.</p>
        </div>
      `;
      
      // Insert content into the page
      pageElement.innerHTML = feuillePersonnageContent;
      
      // Setup event listeners for print and download functionality
      this.setupCharacterSheetActions();
      
      
      // Show and activate page
      this.show('feuille-personnage');
      this.updateActiveStates('feuille-personnage');
      
      return true;
    },

    setupCharacterSheetActions() {
      const pdfUrl = 'https://github.com/ben-128/BabJdr/raw/master/data/feuille-personnage.pdf';
      
      // Setup main action buttons
      const openBtn = document.getElementById('open-character-sheet');
      const printBtn = document.getElementById('print-character-sheet');
      const downloadBtn = document.getElementById('download-character-sheet');
      
      // Setup preview action buttons
      const openTabBtn = document.getElementById('open-pdf-new-tab');
      const printDirectBtn = document.getElementById('print-pdf-direct');
      const downloadDirectBtn = document.getElementById('download-pdf-direct');
      
      // Check if PDF embed is supported and handle fallback
      const pdfEmbed = document.getElementById('pdf-embed');
      const pdfFallback = document.querySelector('.pdf-fallback');
      
      if (pdfEmbed) {
        // Add load error handler for PDF embed
        pdfEmbed.addEventListener('error', () => {
          // Hide embed and show fallback
          pdfEmbed.style.display = 'none';
          if (pdfFallback) {
            pdfFallback.style.display = 'block';
          }
        });
        
        // Test if PDF can be loaded after a delay
        setTimeout(() => {
          // Check if the embed has loaded properly
          try {
            const embedDoc = pdfEmbed.contentDocument || pdfEmbed.contentWindow.document;
            if (!embedDoc || embedDoc.body.innerHTML.includes('%PDF')) {
              // PDF is showing as raw text, use fallback
              pdfEmbed.style.display = 'none';
              if (pdfFallback) {
                pdfFallback.style.display = 'block';
              }
            }
          } catch (e) {
            // Can't access content, probably loaded correctly
          }
        }, 1000);
      }
      
      // Open PDF in new tab
      const openPDF = () => {
        window.open(pdfUrl, '_blank');
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification('ğŸ“– PDF ouvert dans un nouvel onglet', 'success');
        }
      };
      
      // Print PDF
      const printPDF = () => {
        const printWindow = window.open(pdfUrl, '_blank');
        if (printWindow) {
          printWindow.focus();
          setTimeout(() => {
            try {
              printWindow.print();
            } catch (e) {
              alert('PDF ouvert. Utilisez Ctrl+P pour imprimer.');
            }
          }, 1000);
        } else {
          alert('Impossible d\'ouvrir le PDF. VÃ©rifiez que les popups ne sont pas bloquÃ©s.');
        }
      };
      
      // Download PDF
      const downloadPDF = () => {
        const link = document.createElement('a');
        link.href = pdfUrl;
        link.download = 'Feuille-Personnage-BabJDR.pdf';
        link.style.display = 'none';
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification('ğŸ“¥ TÃ©lÃ©chargement en cours...', 'success');
        }
      };
      
      // Attach event listeners
      if (openBtn) openBtn.addEventListener('click', openPDF);
      if (printBtn) printBtn.addEventListener('click', printPDF);
      if (downloadBtn) downloadBtn.addEventListener('click', downloadPDF);
      
      if (openTabBtn) openTabBtn.addEventListener('click', openPDF);
      if (printDirectBtn) printDirectBtn.addEventListener('click', printPDF);
      if (downloadDirectBtn) downloadDirectBtn.addEventListener('click', downloadPDF);
    },

    renderFavorisPage() {
      // Use the unified PageBuilder to render the favoris page  
      const favorisData = window.FAVORIS || {
        page: 'favoris',
        title: 'â­ Favoris',
        static: true,
        sections: [
          {
            type: 'intro',
            content: 'Retrouvez ici vos sorts et objets prÃ©fÃ©rÃ©s. Cliquez sur l\'Ã©toile â­ Ã  cÃ´tÃ© des Ã©lÃ©ments pour les ajouter Ã  vos favoris.'
          }
        ]
      };
      
      // Generate the page HTML using PageBuilder directly
      const pageHtml = PageBuilder.buildStaticPage('favoris', favorisData);
      
      // Find or create the views container and insert the page
      const viewsContainer = document.querySelector('#views');
      if (viewsContainer) {
        // Remove existing favoris page if it exists
        const existingPage = document.querySelector('[data-page="favoris"]');
        if (existingPage) {
          existingPage.remove();
        }
        
        viewsContainer.insertAdjacentHTML('beforeend', pageHtml);
      }
      
      // Trigger favoris display update
      if (window.FavorisRenderer) {
        setTimeout(() => window.FavorisRenderer.updateFavorisDisplay(), 100);
      }

      // Show and activate page
      this.show('favoris');
      this.updateActiveStates('favoris');
      
      return true;
    },

    renderObjectsPage() {
      // Check if page already exists and force refresh is requested
      const existingPage = document.querySelector('[data-page="objets"]');
      const shouldRefresh = this._forceObjectsRefresh || !existingPage;
      
      if (!shouldRefresh && existingPage) {
        // Page exists and no refresh needed, just show it
        setTimeout(() => {
          this.setupObjectSearchFunctionality();
        }, 100);
        this.show('objets');
        this.updateActiveStates('objets');
        return true;
      }
      
      // Reset the force refresh flag
      this._forceObjectsRefresh = false;
      
      // Get objects data
      const objectsData = window.OBJETS || { objets: [] };
      
      // Use PageBuilder to generate the objects page
      if (!window.PageBuilder) {
        console.error('PageBuilder not available for objects page');
        return false;
      }
      
      // Generate page HTML using PageBuilder
      const pageHtml = PageBuilder.buildSingleObjectPage(objectsData);
      
      // Find or create the views container
      const viewsContainer = document.querySelector('#views');
      if (!viewsContainer) {
        console.error('Views container not found');
        return false;
      }
      
      // Remove existing objects page if it exists
      if (existingPage) {
        existingPage.remove();
      }
      
      // Insert the new page
      viewsContainer.insertAdjacentHTML('beforeend', pageHtml);
      
      // Setup object search functionality
      setTimeout(() => {
        this.setupObjectSearchFunctionality();
      }, 100);
      
      // Show and activate page
      this.show('objets');
      this.updateActiveStates('objets');
      
      return true;
    },

    refreshObjectsPageIfActive() {
      if (window.location.hash === '#/objets') {
        console.log('ğŸ”„ Refreshing objects page due to state change');
        setTimeout(() => {
          this._forceObjectsRefresh = true;
          this.renderObjectsPage();
        }, 50);
      }
    },

    setupObjectSearchFunctionality() {
      // Setup ID search functionality
      const idSearchInput = document.getElementById('id-search-input');
      const clearButton = document.getElementById('clear-id-search');
      const resultDiv = document.getElementById('id-search-result');
      
      if (!idSearchInput) {
        return;
      }
      
      // Search function
      const performIdSearch = (searchValue) => {
        const objectsContainer = document.getElementById('objets-container');
        if (!objectsContainer) {
          return;
        }
        
        const allCards = objectsContainer.querySelectorAll('.card');
        let foundCard = null;
        
        if (!searchValue || searchValue.trim() === '') {
          // Show all cards when search is empty in dev mode, hide in normal mode
          const isDevMode = JdrApp.utils.isDevMode();
          allCards.forEach(card => {
            card.style.display = isDevMode ? 'block' : 'none';
          });
          window.activeIdSearch = false;
          if (resultDiv) {
            resultDiv.textContent = 'Entrez un numÃ©ro pour rechercher un objet spÃ©cifique';
          }
          return;
        }
        
        // Hide all cards first
        allCards.forEach(card => {
          card.style.display = 'none';
        });
        
        // Find and show matching card
        const searchNumber = parseInt(searchValue);
        if (!isNaN(searchNumber)) {
          allCards.forEach(card => {
            // Try multiple possible attribute names for the object number
            const cardNumero = card.getAttribute('data-numero') || 
                              card.getAttribute('data-object-numero') ||
                              card.getAttribute('data-objet-numero');
            
            if (cardNumero && parseInt(cardNumero) === searchNumber) {
              card.style.display = 'block';
              card.style.visibility = 'visible';
              foundCard = card;
              
              // Center the found object
              setTimeout(() => {
                card.scrollIntoView({ 
                  behavior: 'smooth', 
                  block: 'center', 
                  inline: 'center' 
                });
              }, 100);
            }
          });
        }
        
        window.activeIdSearch = true;
        
        // Update result text
        if (resultDiv) {
          if (foundCard) {
            const objectName = foundCard.querySelector('h4, .card-title')?.textContent || 'Objet trouvÃ©';
            resultDiv.textContent = `âœ… Objet trouvÃ©: ${objectName}`;
            resultDiv.style.color = '#16a34a';
          } else {
            resultDiv.textContent = `âŒ Aucun objet trouvÃ© avec le numÃ©ro ${searchNumber}`;
            resultDiv.style.color = '#ef4444';
          }
        }
      };
      
      // Setup event listeners - Only search on Enter, not on input
      idSearchInput.addEventListener('keyup', (e) => {
        if (e.key === 'Enter') {
          performIdSearch(e.target.value);
        }
      });
      
      if (clearButton) {
        clearButton.addEventListener('click', () => {
          idSearchInput.value = '';
          performIdSearch('');
        });
      }
      
      // Setup tag filter functionality if available
      this.setupObjectTagFilters();
    },

    setupObjectTagFilters() {
      const filterChips = document.querySelectorAll('.filter-chip');
      const objectsContainer = document.getElementById('objets-container');
      
      if (!objectsContainer || filterChips.length === 0) return;
      
      filterChips.forEach(chip => {
        chip.addEventListener('click', (e) => {
          const tag = e.target.getAttribute('data-tag');
          if (!tag) return;
          
          const isActive = e.target.classList.contains('active');
          
          // Toggle the tag in global state
          if (!window.ACTIVE_OBJECT_TAGS) {
            window.ACTIVE_OBJECT_TAGS = [];
          }
          
          if (isActive) {
            // Remove tag
            window.ACTIVE_OBJECT_TAGS = window.ACTIVE_OBJECT_TAGS.filter(t => t !== tag);
          } else {
            // Add tag
            window.ACTIVE_OBJECT_TAGS.push(tag);
          }
          
          // Refresh the objects page to apply filters
          this._forceObjectsRefresh = true;
          this.renderObjectsPage();
        });
      });
    },

    renderGMObjectsPage() {
      if (!window.OBJETS) {
        console.error('OBJETS data not loaded');
        return false;
      }
      
      // Generate the GM objects page HTML
      const pageHTML = window.PageBuilder.buildGameMasterObjectPage(window.OBJETS);
      
      // Update only the specific article instead of wiping entire views container
      let gmObjectsArticle = document.querySelector('article[data-page="gestion-objets"]');
      if (!gmObjectsArticle) {
        // Create the article if it doesn't exist
        const viewsContainer = document.getElementById('views');
        if (viewsContainer) {
          viewsContainer.insertAdjacentHTML('beforeend', pageHTML);
          gmObjectsArticle = document.querySelector('article[data-page="gestion-objets"]');
        }
      } else {
        // Update existing article content
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = pageHTML;
        const newArticleContent = tempDiv.querySelector('article[data-page="gestion-objets"]');
        if (newArticleContent) {
          gmObjectsArticle.innerHTML = newArticleContent.innerHTML;
        }
      }
      
      if (gmObjectsArticle) {
        this.updateActiveStates('gestion-objets');
        this.setupGMObjectSearch();
        return true;
      }
      
      return false;
    },

    setupGMObjectSearch() {
      // Setup ID search for GM objects page
      const idSearchInput = document.getElementById('id-search-input');
      const searchButton = document.getElementById('search-object-btn');
      const clearButton = document.getElementById('clear-id-search');
      
      const performIdSearch = (searchId) => {
        const objectsContainer = document.getElementById('gestion-objets-container');
        if (!objectsContainer) return;
        
        const allCards = objectsContainer.querySelectorAll('.card');
        
        if (!searchId) {
          // Show all objects
          allCards.forEach(card => card.style.display = 'block');
          window.activeIdSearch = false;
          return;
        }
        
        // Hide all first
        allCards.forEach(card => card.style.display = 'none');
        
        // Find and show matching object
        const targetCard = Array.from(allCards).find(card => {
          const cardIdElement = card.querySelector('.object-id');
          return cardIdElement && cardIdElement.textContent.includes(`#${searchId}`);
        });
        
        if (targetCard) {
          targetCard.style.display = 'block';
          targetCard.style.gridColumn = '1 / -1';
          targetCard.style.justifySelf = 'center';
          window.activeIdSearch = true;
        } else {
          window.activeIdSearch = false;
        }
      };
      
      if (searchButton && idSearchInput) {
        searchButton.addEventListener('click', () => {
          const searchId = idSearchInput.value.trim();
          performIdSearch(searchId);
        });
        
        idSearchInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            const searchId = idSearchInput.value.trim();
            performIdSearch(searchId);
          }
        });
      }
      
      if (clearButton) {
        clearButton.addEventListener('click', () => {
          idSearchInput.value = '';
          performIdSearch('');
        });
      }
    },

    renderMonstersPage() {
      if (!window.MONSTRES) {
        console.error('MONSTRES data not loaded');
        return false;
      }
      
      // Generate the monsters page HTML
      const pageHTML = window.PageBuilder.buildSingleMonsterPage(window.MONSTRES);
      
      // Update only the specific article instead of wiping entire views container
      let monstersArticle = document.querySelector('article[data-page="monstres"]');
      if (!monstersArticle) {
        // Create the article if it doesn't exist
        const viewsContainer = document.getElementById('views');
        if (viewsContainer) {
          viewsContainer.insertAdjacentHTML('beforeend', pageHTML);
          monstersArticle = document.querySelector('article[data-page="monstres"]');
        }
      } else {
        // Update existing article content
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = pageHTML;
        const newArticleContent = tempDiv.querySelector('article[data-page="monstres"]');
        if (newArticleContent) {
          monstersArticle.innerHTML = newArticleContent.innerHTML;
        }
      }
      
      if (monstersArticle) {
        this.updateActiveStates('monstres');
        return true;
      }
      
      return false;
    },

    renderTablesTresorsPage() {
      if (!window.TABLES_TRESORS) {
        console.error('TABLES_TRESORS data not loaded');
        return false;
      }
      
      // Generate the tables page HTML
      const pageHTML = window.PageBuilder.buildSingleTableTresorPage(window.TABLES_TRESORS);
      
      // Update only the specific article instead of wiping entire views container
      let tablesArticle = document.querySelector('article[data-page="tables-tresors"]');
      if (!tablesArticle) {
        // Create the article if it doesn't exist
        const viewsContainer = document.getElementById('views');
        if (viewsContainer) {
          viewsContainer.insertAdjacentHTML('beforeend', pageHTML);
          tablesArticle = document.querySelector('article[data-page="tables-tresors"]');
        }
      } else {
        // Update existing article content
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = pageHTML;
        const newArticleContent = tempDiv.querySelector('article[data-page="tables-tresors"]');
        if (newArticleContent) {
          tablesArticle.innerHTML = newArticleContent.innerHTML;
        }
      }
      
      if (tablesArticle) {
        this.updateActiveStates('tables-tresors');
        return true;
      }
      
      return false;
    }
  
  };

})();

// ============================================================================
// JDR-BAB APPLICATION - RENDERER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // CONTENT RENDERER MODULE
  // ========================================
  JdrApp.modules.renderer = {
    currentSearch: '',
    
    init() {
      // Delay content generation to ensure all configurations are loaded
      setTimeout(() => {
        this.generateContent();
        this.autoLoadImages();
      }, 10);
      this.setupEventListeners();
    },

    setupEventListeners() {
      EventBus.on(Events.PAGE_RENDER, (payload) => {
        if (payload.type === 'category') {
          this.renderCategoryPage(payload.categoryType, payload.category);
        }
      });

      EventBus.on(Events.CONTENT_ADD, () => {
        setTimeout(() => this.autoLoadImages(), 100);
      });
    },

    generateContent() {
      JdrApp.modules.router.generateTOC.call(JdrApp.modules.router);
      this.generateArticles();
      this.generateDevToolbox();
      
      if (JdrApp.modules.editor) {
        setTimeout(() => {
          if (JdrApp.modules.editor.isDevMode) {
            JdrApp.modules.editor.forceShowAllEditButtons();
          } else {
            JdrApp.modules.editor.forceHideAllEditButtons();
          }
        }, 100);
      }
    },

    generateArticles() {
      const viewsContainer = document.querySelector('#views');
      if (!viewsContainer) return;

      // Use progressive rendering to avoid blocking the main thread
      this.progressiveRender([
        { fn: () => this.generateStaticPages(), name: 'static' },
        { fn: () => this.generateClassPages(), name: 'classes' },
        { fn: () => this.generateCategoryPages(), name: 'categories' },
        { fn: () => this.generateMonstersPage(), name: 'monsters' },
        { fn: () => this.generateGMObjectsPage(), name: 'gm-objects' }
      ], viewsContainer);
    },

    // Progressive rendering to avoid blocking the UI thread
    async progressiveRender(renderFunctions, container) {
      container.innerHTML = ''; // Clear first
      
      for (let i = 0; i < renderFunctions.length; i++) {
        const { fn, name } = renderFunctions[i];
        
        // Use requestAnimationFrame to yield to browser between renders
        await new Promise(resolve => {
          requestAnimationFrame(() => {
            try {
              const html = fn();
              if (html) {
                container.insertAdjacentHTML('beforeend', html);
              }
            } catch (error) {
              console.warn(`Error rendering ${name}:`, error);
            }
            resolve();
          });
        });
        
        // Yield every few operations to prevent blocking
        if (i % 2 === 0) {
          await new Promise(resolve => setTimeout(resolve, 5));
        }
      }

      // Post-render operations with improved batching
      requestAnimationFrame(() => {
        this.batchPostRenderOperations();
        
      });
    },

    // Batch post-render operations to reduce layout thrashing
    batchPostRenderOperations() {
      // Batch DOM reads first, then writes
      const hasDevMode = JdrApp.modules.editor && JdrApp.modules.editor.isDevMode;
      const hasEditor = JdrApp.modules.editor;
      const monstersContainer = document.getElementById('monsters-container');

      // Batch writes
      this.autoLoadImages();
      
      if (hasEditor) {
        this.applyDevModeToNewContent();
        
        if (hasEditor.attachImageEvents) {
          hasEditor.attachImageEvents();
        }
        
        if (hasDevMode) {
          setTimeout(() => hasEditor.createProxyButtons(), 50);
        }
        
        // Force image event attachment after a delay to catch lazy-loaded images
        setTimeout(() => {
          if (hasEditor.attachImageEvents) {
            hasEditor.attachImageEvents();
          }
        }, 1000);
      }
      
      if (monstersContainer) {
        setTimeout(() => this.populateMonstersPage(), 30);
      }

      // Setup object search functionality if we're on the objects page
      this.setupObjectSearchIfNeeded();
    },

    applyDevModeToNewContent() {
      if (JdrApp.modules.editor) {
        if (JdrApp.utils.isDevMode()) {
          JdrApp.modules.editor.forceShowAllEditButtons();
        } else {
          JdrApp.modules.editor.forceHideAllEditButtons();
        }
      }
    },


    generateStaticPages() {
      let html = '';
      if (window.STATIC_PAGES) {
        Object.entries(window.STATIC_PAGES).forEach(([pageId, pageData]) => {
          html += PageBuilder.buildStaticPage(pageId, pageData);
        });
      }
      return html;
    },


    generateClassPages() {
      if (!window.CLASSES) return '';
      
      return window.CLASSES.map(classe => 
        PageBuilder.buildClassPage(classe)
      ).join('');
    },

    generateCategoryPages() {
      let html = '';
      
      if (window.SORTS) {
        html += window.SORTS.map(category => 
          PageBuilder.buildCategoryPage('spell', category)
        ).join('');
      }

      if (window.DONS) {
        html += window.DONS.map(category => 
          PageBuilder.buildCategoryPage('don', category)
        ).join('');
      }

      // Generate single objects page (different from category pages)
      if (window.OBJETS) {
        html += PageBuilder.buildSingleObjectPage(window.OBJETS);
      }

      return html;
    },

    generateMonstersPage() {
      if (!window.MONSTRES) return '';
      
      return PageBuilder.buildSingleMonsterPage(window.MONSTRES);
    },

    generateGMObjectsPage() {
      if (!window.OBJETS) return '';
      
      return PageBuilder.buildGameMasterObjectPage(window.OBJETS);
    },


    renderCategoryPage(type, category) {
      const config = window.ContentTypes[type];
      
      // Handle special case for objects (single page, no category name)
      let pageId;
      if (type === 'objet') {
        pageId = 'objets'; // Objects use fixed page ID
      } else {
        pageId = `${config.container}-${JdrApp.utils.data.sanitizeId(category.nom)}`;
      }
      
      let article = document.querySelector(`article[data-page="${pageId}"]`);
      
      // Create article if it doesn't exist (for dynamically created categories)
      if (!article) {
        article = document.createElement('article');
        article.setAttribute('data-page', pageId);
        // DON'T make it active immediately - let the show() method handle this
        
        const viewsContainer = document.querySelector('#views');
        if (viewsContainer) {
          viewsContainer.appendChild(article);
        } else {
          // Views container not found
          return;
        }
      }
      
      const newContent = PageBuilder.buildCategoryPage(type, category);
      const parser = new DOMParser();
      const newDoc = parser.parseFromString(newContent, 'text/html');
      const newArticle = newDoc.querySelector('article');
      
      if (newArticle) {
        article.innerHTML = newArticle.innerHTML;
        
        // Make sure only this article is active
        document.querySelectorAll('article').forEach(a => a.classList.remove('active'));
        article.classList.add('active');
        
        // Plus simple et plus fiable
        this.autoLoadImages();
        
        // Attach image events for standalone compatibility
        if (JdrApp.modules.editor && JdrApp.modules.editor.attachImageEvents) {
          JdrApp.modules.editor.attachImageEvents();
        }
        
        // Ensure dev mode state is applied after content change
        setTimeout(() => {
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          } else if (window.STANDALONE_VERSION) {
            // FORCE STANDALONE MODE: Ensure dev-off class and hide all dev buttons
            document.body.className = 'dev-off';
          }
        }, 50);
      }
    },

    renderSortCategory(page) {
      const categoryId = page.replace('sorts-', '');
      const category = window.SORTS?.find(cat => 
        JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
      );
      
      if (category) {
        this.renderCategoryPage('spell', category);
      }
    },

    generateDevToolbox() {
      const devToolbox = JdrApp.utils.dom.$('#devToolbox');
      if (!devToolbox) return;

      const toolboxHTML = `
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--rule);">
          <span style="font-size: 18px;">ğŸ› </span>
          <strong style="color: var(--accent-ink); font-family: 'Cinzel', serif;">Outils de dÃ©veloppement</strong>
        </div>
        
        <div style="margin-bottom: 12px;">
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">âœï¸ Ã‰dition</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="saveAndExport" title="Sauvegarder et exporter tout en ZIP">ğŸ’¾ Export ZIP</button>
          </div>
        </div>
        
        <div style="margin-bottom: 12px;">
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">ğŸ“ CrÃ©ation</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="addCategory" title="CrÃ©er une nouvelle catÃ©gorie/page">ğŸ“„ Nouvelle page</button>
            <button class="btn small" id="addSpellCategory" title="CrÃ©er une nouvelle catÃ©gorie de sorts">ğŸ”® CatÃ©gorie de sorts</button>
            <button class="btn small" id="addDonCategory" title="CrÃ©er une nouvelle catÃ©gorie de dons">ğŸ–ï¸ CatÃ©gorie de dons</button>
          </div>
        </div>
        
      `;

      devToolbox.innerHTML = toolboxHTML;
    },

    autoLoadImages() {
      if (JdrApp.modules.images) {
        return JdrApp.modules.images.autoLoadImages();
      }
      return 0;
    },

    regenerateCurrentPage() {
      // Find the currently active article
      const activeArticle = document.querySelector('article.active');
      if (!activeArticle) return;

      const pageId = activeArticle.dataset.page;
      if (!pageId) return;

      // Determine what type of page it is and regenerate only that page
      if (pageId.startsWith('sorts-')) {
        const categoryId = pageId.replace('sorts-', '');
        const category = window.SORTS?.find(cat => 
          JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
        );
        if (category) {
          this.renderCategoryPage('spell', category);
        }
      } else if (pageId.startsWith('dons-')) {
        const categoryId = pageId.replace('dons-', '');
        const category = window.DONS?.find(cat => 
          JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
        );
        if (category) {
          this.renderCategoryPage('don', category);
        }
      } else if (pageId === 'objets') {
        // Regenerate objects page using the generic approach
        const newHTML = this.generatePageContent(pageId);
        if (newHTML) {
          activeArticle.innerHTML = newHTML;
          this.autoLoadImages();
          
          // Apply dev mode state immediately
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          } else if (window.STANDALONE_VERSION) {
            // FORCE STANDALONE MODE: Ensure dev-off class and hide all dev buttons
            document.body.className = 'dev-off';
          }
        }
      } else {
        // For class pages, static pages, etc. - regenerate the specific content
        const newHTML = this.generatePageContent(pageId);
        if (newHTML) {
          activeArticle.innerHTML = newHTML;
          this.autoLoadImages();
          
          // Apply dev mode state immediately
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          } else if (window.STANDALONE_VERSION) {
            // FORCE STANDALONE MODE: Ensure dev-off class and hide all dev buttons
            document.body.className = 'dev-off';
          }
        }
      }
    },

    generatePageContent(pageId) {
      // Generate content for a specific page without affecting navigation
      if (window.CLASSES) {
        const classe = window.CLASSES.find(c => JdrApp.utils.data.sanitizeId(c.nom) === pageId);
        if (classe) {
          const content = PageBuilder.buildClassPage(classe);
          const parser = new DOMParser();
          const doc = parser.parseFromString(content, 'text/html');
          const article = doc.querySelector('article');
          return article ? article.innerHTML : null;
        }
      }

      if (window.STATIC_PAGES && window.STATIC_PAGES[pageId]) {
        const content = PageBuilder.buildStaticPage(pageId, window.STATIC_PAGES[pageId]);
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        const article = doc.querySelector('article');
        return article ? article.innerHTML : null;
      }

      // Handle objects page
      if (pageId === 'objets' && window.OBJETS) {
        const content = PageBuilder.buildSingleObjectPage(window.OBJETS);
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        const article = doc.querySelector('article');
        return article ? article.innerHTML : null;
      }

      return null;
    },

    populateMonstersPage() {
      const monstersContainer = document.getElementById('monstres-container');
      if (!monstersContainer || !window.MONSTRES) return;

      // Clear existing content
      monstersContainer.innerHTML = '';

      // Generate monster cards directly
      const cardsHTML = window.MONSTRES.map((monster, index) => 
        CardBuilder.create('monster', monster, 'monstres', index).build()
      ).join('');
      
      monstersContainer.innerHTML = cardsHTML;

      // Apply dev mode styling and load images
      this.applyDevModeToNewContent();
      this.autoLoadImages();
    },

    renderUnifiedContentPage(contentType, data) {
      // This method dynamically creates a unified content page (like objets or monstres)
      // using the PageBuilder with the appropriate build method
      let content = '';
      let pageId = '';
      
      if (contentType === 'objet' && data) {
        content = PageBuilder.buildSingleObjectPage(data);
        pageId = 'objets';
      } else if (contentType === 'monster' && data) {
        content = PageBuilder.buildSingleMonsterPage(data);
        pageId = 'monstres';
      } else if (contentType === 'tableTresor' && data) {
        content = PageBuilder.buildSingleTableTresorPage(data);
        pageId = 'tables-tresors';
      }
      
      if (content && pageId) {
        // Find or create the specific article element in #views
        const viewsContainer = document.querySelector('#views');
        if (viewsContainer) {
          // Remove existing article for this page if it exists
          const existingArticle = document.querySelector(`article[data-page="${pageId}"]`);
          if (existingArticle) {
            existingArticle.remove();
          }
          
          // Add the new content to the views container
          viewsContainer.insertAdjacentHTML('beforeend', content);
          
          this.autoLoadImages();
          
          // Apply dev mode state with slight delay to ensure DOM is processed
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            setTimeout(() => {
              if (JdrApp.modules.editor.isDevMode) {
                JdrApp.modules.editor.forceShowAllEditButtons();
              } else {
                JdrApp.modules.editor.forceHideAllEditButtons();
              }
            }, 10);
          }
          
          // Setup object search specifically for objects page
          if (contentType === 'objet') {
            setTimeout(() => {
              this.setupObjectSearchIfNeeded();
            }, 100);
          }
        }
      }
    },

    setupObjectSearchIfNeeded() {
      // Check if we're on the objects page and the search input exists
      const idSearchInput = document.getElementById('id-search-input');
      const clearSearchButton = document.getElementById('clear-id-search');
      
      if (!idSearchInput) return; // Not on objects page or search not available

      // Remove any existing event listeners to avoid duplicates
      const newSearchInput = idSearchInput.cloneNode(true);
      idSearchInput.parentNode.replaceChild(newSearchInput, idSearchInput);
      
      // Add multiple event listeners to catch Enter key
      newSearchInput.addEventListener('keyup', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          e.stopPropagation();
          const searchId = e.target.value.trim();
          this.performIdSearch(searchId);
        }
      });
      
      newSearchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          e.stopPropagation();
          const searchId = e.target.value.trim();
          this.performIdSearch(searchId);
        }
      });
      
      newSearchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          e.stopPropagation();
          const searchId = e.target.value.trim();
          this.performIdSearch(searchId);
        }
      });

      // Setup search button
      const searchButton = document.getElementById('search-object-btn');
      if (searchButton) {
        const newSearchButton = searchButton.cloneNode(true);
        searchButton.parentNode.replaceChild(newSearchButton, searchButton);
        
        newSearchButton.addEventListener('click', () => {
          const searchId = newSearchInput.value.trim();
          this.performIdSearch(searchId);
        });
      }

      // Setup clear search button if it exists
      if (clearSearchButton) {
        const newClearButton = clearSearchButton.cloneNode(true);
        clearSearchButton.parentNode.replaceChild(newClearButton, clearSearchButton);
        
        newClearButton.addEventListener('click', () => {
          this.clearIdSearch();
        });
      }
    },

    performIdSearch(searchId) {
      const resultDiv = document.getElementById('id-search-result');
      const objectsContainer = document.getElementById('objets-container');
      const gmObjectsContainer = document.getElementById('gestion-objets-container');
      
      // Determine which container to use based on current page
      const activeContainer = objectsContainer || gmObjectsContainer;
      
      if (!searchId || !activeContainer) {
        if (resultDiv) resultDiv.textContent = '';
        return;
      }

      // Hide all objects first
      const allObjectCards = activeContainer.querySelectorAll('.card');
      allObjectCards.forEach(card => {
        card.style.display = 'none';
      });

      // Find object by ID (search in data-object-numero attribute)
      const targetCard = activeContainer.querySelector(`[data-object-numero="${searchId}"]`);
      
      if (targetCard) {
        // Show the found object and center it both visually and scroll-wise
        targetCard.style.display = 'block';
        
        // Add highlight effect
        targetCard.style.border = '3px solid #16a34a';
        targetCard.style.boxShadow = '0 0 15px rgba(22, 163, 74, 0.5)';
        
        // CENTER THE OBJECT VISUALLY IN THE GRID
        // When only one object is shown, center it horizontally in the grid
        const container = activeContainer;
        if (container) {
          // Temporarily change grid to center the single item
          const isDesktop = window.innerWidth > 768;
          if (isDesktop) {
            // On desktop: center the single card by spanning both columns
            targetCard.style.gridColumn = '1 / -1'; // Span all columns
            targetCard.style.justifySelf = 'center'; // Center within the span
            targetCard.style.maxWidth = '500px'; // Reasonable max width for single card
          } else {
            // On mobile: grid is already single column, just center it
            targetCard.style.justifySelf = 'center';
            targetCard.style.maxWidth = '100%';
          }
        }
        
        // Center the object on screen with scroll
        setTimeout(() => {
          // Use scrollIntoView for reliable centering
          targetCard.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center', 
            inline: 'center' 
          });
          
          // Additional fine-tuning for better positioning
          setTimeout(() => {
            const rect = targetCard.getBoundingClientRect();
            const viewportHeight = window.innerHeight;
            
            // Only adjust vertically to avoid horizontal scroll issues
            const cardCenterY = rect.top + (rect.height / 2);
            const viewportCenterY = viewportHeight / 2;
            const scrollAdjustY = cardCenterY - viewportCenterY;
            
            // Apply vertical scroll adjustment only
            window.scrollBy({
              top: scrollAdjustY,
              left: 0, // Don't adjust horizontal scroll
              behavior: 'smooth'
            });
          }, 300);
        }, 150);

        // Update search result message
        if (resultDiv) {
          const objectName = targetCard.getAttribute('data-objet-name') || 'Objet';
          resultDiv.innerHTML = `<span style="color: #16a34a;">âœ… Objet #${searchId} trouvÃ©: ${objectName}</span>`;
        }
        
        // Mark search as active
        window.activeIdSearch = true;
      } else {
        // No object found
        if (resultDiv) {
          resultDiv.innerHTML = `<span style="color: #dc2626;">âŒ Aucun objet trouvÃ© avec l'ID #${searchId}</span>`;
        }
        
        // Show all objects if nothing found
        allObjectCards.forEach(card => {
          card.style.display = 'block';
        });
      }
    },

    clearIdSearch() {
      const idSearchInput = document.getElementById('id-search-input');
      const resultDiv = document.getElementById('id-search-result');
      const objectsContainer = document.getElementById('objets-container');
      const gmObjectsContainer = document.getElementById('gestion-objets-container');
      
      // Clear search input
      if (idSearchInput) {
        idSearchInput.value = '';
      }
      
      // Clear result message
      if (resultDiv) {
        resultDiv.textContent = '';
      }
      
      // Show all objects and remove highlights for both containers
      [objectsContainer, gmObjectsContainer].forEach(container => {
        if (container) {
          const allObjectCards = container.querySelectorAll('.card');
          allObjectCards.forEach(card => {
            // For regular objects page, keep objects hidden by default
            // For GM objects page, show all objects
            if (container.id === 'objets-container') {
              card.style.display = 'none'; // Regular page: hide all
            } else if (container.id === 'gestion-objets-container') {
              card.style.display = 'block'; // GM page: show all
            }
            // Remove highlight effects and grid centering styles
            card.style.border = '';
            card.style.boxShadow = '';
            card.style.gridColumn = ''; // Reset grid column span
            card.style.justifySelf = ''; // Reset justify
            card.style.maxWidth = ''; // Reset max width
          });
        }
      });
      
      // Mark search as inactive
      window.activeIdSearch = false;
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - UNIFIED EDITOR SYSTEM
// ============================================================================

(() => {
  "use strict";

  class UnifiedEditor {
    constructor() {
      this.currentEditSession = null;
    }

    /*
     * IMPORTANT: Content Restoration Best Practices
     * =============================================
     * ALWAYS use restoreElementContent() for any content that has been edited
     * NEVER directly assign to innerHTML in editing contexts
     * This prevents HTML tags from being displayed as visible text
     */

    static getInstance() {
      if (!UnifiedEditor.instance) {
        UnifiedEditor.instance = new UnifiedEditor();
      }
      return UnifiedEditor.instance;
    }

    // Parse edit context from DOM element
    parseEditContext(element) {
      // Force reset any stuck elements FIRST
      this.forceResetAllEditingElements();
      
      const editableElement = element.classList.contains('editable-section') 
        ? element.querySelector('.editable') 
        : element;

      if (!editableElement) {
        return null;
      }

      const editType = editableElement.dataset.editType;
      const editSection = editableElement.dataset.editSection;
      
      // For simplified HTML editing, everything is treated as HTML content
      if (editType === 'html') {
        return this.parseHtmlEditContext(element, editSection);
      }
      
      // Generic editing - use contextual detection, don't force type
      if (editType === 'generic') {
        // Use the full parsing logic and keep the detected contentType
        return this.parseHtmlEditContext(element, editSection);
      }

      // Tags editing for objects
      if (editType === 'tags') {
        return this.parseTagsEditContext(element, editSection);
      }

      // Select element editing (for dropdowns like monster elements)
      if (editType === 'select') {
        return this.parseSelectEditContext(element, editSection);
      }

      // All legacy edit types have been migrated to 'generic'
      return null;
    }

    parseHtmlEditContext(element, editSection) {
      // Detect context automatically based on page structure
      // Order matters: check most specific first (spells, dons, classes, then static pages)
      
      // Check if we're in a spell card first (most specific)
      const spellCard = element.closest('.card[data-spell-name]');
      if (spellCard) {
        const spellName = spellCard.dataset.spellName;
        const spellIndex = spellCard.dataset.spellIndex;
        const categoryName = spellCard.dataset.categoryName;
        
        // Use class-based detection for spell sections to avoid index mismatches
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        // Detect the spell property from the element's classes or data attributes
        let spellEditSection = 'description'; // default fallback
        
        // Check for specific section classes to determine the property
        if (editableElement.classList.contains('spell-name') || editableElement.dataset.editSection === 'spell-name') {
          spellEditSection = 'nom';
        } else if (editableElement.classList.contains('spell-description') || editableElement.dataset.editSection === 'spell-description') {
          spellEditSection = 'description';
        } else if (editableElement.classList.contains('spell-prerequis') || editableElement.dataset.editSection === 'spell-prerequis') {
          spellEditSection = 'prerequis';
        } else if (editableElement.classList.contains('spell-portee') || editableElement.dataset.editSection === 'spell-portee') {
          spellEditSection = 'portee';
        } else if (editableElement.classList.contains('spell-mana') || editableElement.dataset.editSection === 'spell-mana') {
          spellEditSection = 'coutMana';
        } else if (editableElement.classList.contains('spell-temps-incantation') || editableElement.dataset.editSection === 'spell-temps-incantation') {
          spellEditSection = 'tempsIncantation';
        } else if (editableElement.classList.contains('spell-resistance') || editableElement.dataset.editSection === 'spell-resistance') {
          spellEditSection = 'resistance';
        } else if (editableElement.classList.contains('spell-effect-normal') || editableElement.dataset.editSection === 'spell-effect-normal') {
          spellEditSection = 'effetNormal';
        } else if (editableElement.classList.contains('spell-effect-critical') || editableElement.dataset.editSection === 'spell-effect-critical') {
          spellEditSection = 'effetCritique';
        }
        
        return {
          contentType: 'spell',
          itemIdentifier: spellName,
          itemIndex: spellIndex,
          categoryName: categoryName,
          property: 'html',
          editType: 'html',
          editSection: spellEditSection,
          config: window.ContentTypes.spell,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a don card
      const donCard = element.closest('.card[data-don-name]');
      if (donCard) {
        const donName = donCard.dataset.donName;
        const donIndex = donCard.dataset.donIndex;
        const categoryName = donCard.dataset.categoryName;
        
        // Use index-based detection for don sections
        const allEditables = Array.from(donCard.querySelectorAll('.editable'));
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const currentIndex = allEditables.indexOf(editableElement);
        
        // Map index to don property based on CardBuilder order
        // 0=nom, 1=description, 2=prerequis, 3=cout
        const donSections = ['nom', 'description', 'prerequis', 'cout'];
        const donEditSection = donSections[currentIndex] || 'description';
        
        return {
          contentType: 'don',
          itemIdentifier: donName,
          itemIndex: donIndex,
          categoryName: categoryName,
          property: 'html',
          editType: 'html',
          editSection: donEditSection,
          config: window.ContentTypes.don,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in an objet card
      const objetCard = element.closest('.card[data-objet-name]');
      if (objetCard) {
        const objetName = objetCard.dataset.objetName;
        const categoryName = objetCard.dataset.categoryName;
        
        // Use index-based detection for objet sections
        const allEditables = Array.from(objetCard.querySelectorAll('.editable'));
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const currentIndex = allEditables.indexOf(editableElement);
        
        // Map index to objet property based on CardBuilder order
        // 0=nom, 1=numero, 2=tags, 3=description, 4=effet, 5=prix, 6=poids
        const objetSections = ['nom', 'numero', 'tags', 'description', 'effet', 'prix', 'poids'];
        const objetEditSection = objetSections[currentIndex] || 'description';
        
        return {
          contentType: 'objet',
          itemIdentifier: objetName,
          categoryName: categoryName,
          property: 'html',
          editType: 'html',
          editSection: objetEditSection,
          config: window.ContentTypes.objet,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        // Use data-item-identifier if available, otherwise fall back to monsterName
        const itemIdentifier = editableElement?.dataset?.itemIdentifier || monsterName;
        
        // Use editSection directly (new format: "monster-fieldName")
        const editSection = editableElement?.dataset?.editSection || 'abilites';
        
        return {
          contentType: 'monster',
          itemIdentifier: itemIdentifier,
          categoryName: categoryName || 'monstres',
          property: 'html',
          editType: 'html', 
          editSection: editSection,
          config: window.ContentTypes.monster,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a table-tresor card
      const tableTresorCard = element.closest('.card[data-table-tresor-name]');
      if (tableTresorCard) {
        const tableName = tableTresorCard.dataset.tableTresorName;
        const categoryName = tableTresorCard.dataset.categoryName;
        
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        // Use data-item-identifier if available, otherwise fall back to tableName
        const itemIdentifier = editableElement?.dataset?.itemIdentifier || tableName;
        
        // Use editSection directly (new format: "table-tresor-fieldName")
        const editSection = editableElement?.dataset?.editSection || 'description';
        
        return {
          contentType: 'tableTresor',
          itemIdentifier: itemIdentifier,
          categoryName: categoryName || 'tables',
          property: 'html',
          editType: 'html', 
          editSection: editSection,
          config: window.ContentTypes.tableTresor,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a class page (before static pages!)
      // IMPORTANT: Exclude static pages even if they have data-page-title
      const classArticle = element.closest('article[data-page-title]:not([data-static-page="true"])');
      if (classArticle) {
        const className = classArticle.dataset.pageTitle;
        
        // Check if we're editing a subclass (look for subclass card)
        const subclassCard = element.closest('.card[data-subclass-name]');
        if (subclassCard) {
          // Determine what part of the subclass we're editing
          let subclassEditSection = 'content';
          
          const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
          
          if (editableElement) {
            const parentSection = editableElement.closest('.editable-section');
            
            // Use index-based detection for subclasses
            const subclassCard = editableElement.closest('.card[data-subclass-name]');
            const allEditables = subclassCard ? Array.from(subclassCard.querySelectorAll('.editable')) : [];
            const currentIndex = allEditables.indexOf(editableElement);
            
            // Map index to property based on subclass structure  
            // UPDATED ORDER: Index 0 = nom (title), Index 1 = description, Index 2 = base (stats), Index 3 = progression, Index 4+ = capacites
            if (element.closest('.stats-grid') || currentIndex === 2) {
              subclassEditSection = 'base';
            } else if (currentIndex === 0) {
              subclassEditSection = 'nom';
            } else if (currentIndex === 1) {
              subclassEditSection = 'description';
            } else if (currentIndex === 3) {
              subclassEditSection = 'progression';  
            } else if (currentIndex >= 4) {
              subclassEditSection = 'capacites';
            }
          }
          
          return {
            contentType: 'subclass',
            itemIdentifier: subclassCard.dataset.subclassName,
            categoryName: className,
            property: 'html',
            editType: 'html',
            editSection: subclassEditSection,
            config: window.ContentTypes.subclass,
            element: element.classList.contains('editable-section') ? element.querySelector('.editable') : element,
            container: element
          };
        }
        
        // Otherwise it's a class - determine what part of the class we're editing
        let classEditSection = 'content';
        
        // More specific detection based on parent elements and content
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        if (editableElement) {
          const parentCard = editableElement.closest('.card');
          const parentSection = editableElement.closest('.editable-section');
          
          // Use index-based detection instead of content analysis
          const classArticle = editableElement.closest('article[data-page-title]');
          const allEditables = classArticle ? Array.from(classArticle.querySelectorAll('.editable')) : [];
          const currentIndex = allEditables.indexOf(editableElement);
          
          // Map index to property based on class structure
          // Index 0 = resume (first editable in class)
          // Index 1+ = capacites (subsequent editables are class capabilities)
          if (currentIndex === 0) {
            classEditSection = 'resume';
          } else if (currentIndex >= 1) {
            classEditSection = 'capacites';
          }
        }
        
        return {
          contentType: 'class',
          itemIdentifier: className,
          categoryName: null,
          property: 'html',
          editType: 'html',
          editSection: classEditSection,
          config: window.ContentTypes.class,
          element: element.classList.contains('editable-section') ? element.querySelector('.editable') : element,
          container: element
        };
      }
      
      // Check if we're editing a page description (unified system)
      const pageDescSection = element.closest('.editable-section[data-section-type*="-category-description"], .editable-section[data-section-type="pageDescription"]');
      if (pageDescSection) {
        const sectionType = pageDescSection.dataset.sectionType;
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const editSection = editableElement ? editableElement.dataset.editSection : '';
        
        let contentType;
        
        // Handle different types of page descriptions
        if (sectionType === 'pageDescription') {
          // For generic page descriptions, get the content type from the editable element
          const pageType = editableElement?.dataset?.pageType;
          contentType = pageType || 'collections'; // fallback to collections
        } else {
          // Extract content type from section type (e.g., "objet-category-description" -> "objet")
          contentType = sectionType.replace('-category-description', '');
        }
        
        // Use unified page description system via ContentFactory
        return {
          contentType: 'pageDescription',
          pageType: contentType, // The actual content type (spell, don, objet, collections, etc.)
          itemIdentifier: contentType,
          categoryName: null,
          property: 'description',
          editType: 'html',
          editSection: editSection,
          element: editableElement,
          container: element,
          applyEdit: (content) => {
            const success = ContentFactory.updatePageDescription(contentType, content);
            if (!success) {
              console.error(`âŒ Failed to update page description for ${contentType}`);
            }
            return success;
          }
        };
      }
        
      // Check if we're editing a category description (spell/don category pages - fallback for old system)
      const categorySection = element.closest('.editable-section');
      if (categorySection && categorySection.dataset.sectionType && categorySection.dataset.sectionType.includes('category-description')) {
        const sectionType = categorySection.dataset.sectionType;
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const editSection = editableElement ? editableElement.dataset.editSection : '';
        
        // Extract content type from section type
        const contentType = sectionType.replace('-category-description', '');
        
        return {
          contentType: 'category',
          itemIdentifier: editSection, // This is the category name
          categoryName: editSection,
          property: 'description',
          editType: 'html',
          editSection: 'description',
          categoryType: contentType,
          config: window.ContentTypes[contentType],
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're editing campaign or sub-page content (specific handling before static page fallback)
      const campaignArticle = element.closest('article[data-static-page="true"]');
      if (campaignArticle && campaignArticle.dataset.page === 'campagne') {
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const editSection = editableElement?.dataset?.editSection || '';
        
        // Handle campaign-specific edit sections
        if (editSection.startsWith('campaign-')) {
          // Parse campaign edit section: campaign-{campaignName}-{property}
          const parts = editSection.split('-');
          if (parts.length >= 3) {
            const campaignName = parts.slice(1, -1).join('-'); // Handle campaign names with hyphens
            const property = parts[parts.length - 1]; // last part is the property
            
            return {
              contentType: 'campaign',
              itemIdentifier: campaignName,
              categoryName: null,
              property: 'html',
              editType: 'html',
              editSection: property, // 'name' or 'description'
              config: window.ContentTypes.campaign,
              element: editableElement,
              container: element,
              applyEdit: (content) => {
                return this.updateCampaignData('campaign', campaignName, property, content);
              }
            };
          }
        } else if (editSection.startsWith('subpage-')) {
          // Parse sub-page edit section: subpage-{campaignName}-{subPageName}-{property}
          const parts = editSection.split('-');
          if (parts.length >= 4) {
            const campaignName = parts[1];
            const subPageName = parts.slice(2, -1).join('-'); // Handle sub-page names with hyphens
            const property = parts[parts.length - 1]; // last part is the property
            
            return {
              contentType: 'campaignSubPage',
              itemIdentifier: `${campaignName}:${subPageName}`,
              categoryName: campaignName,
              property: 'html',
              editType: 'html',
              editSection: property, // 'title' or 'content'
              config: window.ContentTypes.campaignSubPage,
              element: editableElement,
              container: element,
              applyEdit: (content) => {
                return this.updateCampaignData('subpage', campaignName, property, content, subPageName);
              }
            };
          }
        }
      }
      
      // Check if we're in a static page (LAST, as fallback)
      // Now we include ALL static pages, regardless of data-page-title
      const staticPageArticle = element.closest('article[data-static-page="true"]');
      if (staticPageArticle) {
        const pageName = staticPageArticle.dataset.page;
        
        // Enhanced page detection with ID-based fallback
        let actualPageName = pageName;
        const elementEditSection = element.dataset?.editSection || 'none';
        
        // If the element's edit section contains a page prefix, use that instead
        if (elementEditSection !== 'none' && elementEditSection.includes('-')) {
          const possiblePageId = elementEditSection.split('-')[0];
          // Check if this matches a known static page
          if (window.STATIC_PAGES && window.STATIC_PAGES[possiblePageId]) {
            actualPageName = possiblePageId;
          }
        }
        
        // Use the corrected page name
        const finalPageName = actualPageName;
        
        // Use index-based detection for static page sections
        const allEditables = Array.from(staticPageArticle.querySelectorAll('.editable'));
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const currentIndex = allEditables.indexOf(editableElement);
        
        // For static pages, use the actual edit section from the element's data attribute
        const actualEditSection = elementEditSection !== 'none' ? elementEditSection : `section-${currentIndex}`;
        
        return {
          contentType: 'staticPage',
          itemIdentifier: finalPageName,  // Use corrected page name
          categoryName: null,
          property: 'html',
          editType: 'html',
          editSection: actualEditSection,  // Use actual edit section ID
          config: window.ContentTypes.staticPage,
          element: editableElement,
          container: element
        };
      }
      
      // Default fallback
      return {
        contentType: 'unknown',
        itemIdentifier: editSection || 'content',
        categoryName: null,
        property: 'html',
        editType: 'html',
        editSection,
        config: { fields: {} },
        element: element.classList.contains('editable-section') ? element.querySelector('.editable') : element,
        container: element
      };
    }

    parseTagsEditContext(element, editSection) {
      // Check if we're in an object card
      const objetCard = element.closest('.card[data-objet-name]');
      if (objetCard) {
        const objetName = objetCard.dataset.objetName;
        const categoryName = objetCard.dataset.categoryName;
        
        return {
          contentType: 'objet',
          itemIdentifier: objetName,
          categoryName: categoryName,
          property: 'tags',
          editType: 'tags',
          editSection: editSection,
          config: window.ContentTypes.objet,
          element: element.classList.contains('editable') ? element : element.querySelector('.editable'),
          container: element
        };
      }
      
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        return {
          contentType: 'monster',
          itemIdentifier: monsterName,
          categoryName: categoryName || 'monstres',
          property: 'tags',
          editType: 'tags',
          editSection: editSection,
          config: window.ContentTypes.monster,
          element: element.classList.contains('editable') ? element : element.querySelector('.editable'),
          container: element
        };
      }
      
      return null;
    }

    parseSelectEditContext(element, editSection) {
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        return {
          contentType: 'monster',
          itemIdentifier: monsterName,
          categoryName: categoryName || 'monstres',
          property: 'element',
          editType: 'select',
          editSection: editSection,
          config: window.ContentTypes.monster,
          element: element,
          container: element.closest('.monster-element-section')
        };
      }
      
      // Check if we're in a spell card
      const spellCard = element.closest('.card[data-spell-name]');
      if (spellCard) {
        const spellName = spellCard.dataset.spellName;
        const spellIndex = spellCard.dataset.spellIndex;
        const categoryName = spellCard.dataset.categoryName;
        
        return {
          contentType: 'spell',
          itemIdentifier: spellName,
          itemIndex: spellIndex,
          categoryName: categoryName,
          property: 'element',
          editType: 'select',
          editSection: editSection,
          config: window.ContentTypes.spell,
          element: element,
          container: element.closest('.spell-element-section')
        };
      }
      
      return null;
    }

    makeElementEditable(editableElement, container) {
      const originalHtml = editableElement.innerHTML;
      container.dataset.originalContent = originalHtml;
      container.dataset.editing = 'true';

      // Decode any encoded HTML before showing for editing
      const decodedHtml = this.decodeHtmlEntities(originalHtml);
      editableElement.innerHTML = decodedHtml;
      editableElement.contentEditable = true;
      editableElement.style.cssText += `
        background-color: rgba(255, 255, 0, 0.1);
        border: 1px dashed var(--bronze);
        border-radius: 4px;
        padding: 4px;
        font-family: monospace;
        white-space: pre-wrap;
      `;

      // Add editing controls toolbar
      this.addEditingControls(container, editableElement);

      editableElement.focus();

      const range = document.createRange();
      range.selectNodeContents(editableElement);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
    }

    makeTagsEditable(editableElement, container) {
      
      const originalHtml = editableElement.innerHTML;
      container.dataset.originalContent = originalHtml;
      container.dataset.editing = 'true';

      // Get current tags from the object
      const objetName = this.currentEditSession.itemIdentifier;
      
      const objet = window.OBJETS?.objets?.find(obj => obj.nom === objetName);
      
      const currentTags = objet?.tags || [];
      const availableTags = window.ContentTypes.objet.filterConfig.availableTags;

      // Create and show modal instead of inline editor
      this.showTagsModal(objetName, currentTags, availableTags);
    }

    showTagsModal(objetName, currentTags, availableTags) {
      // Remove any existing tags modal
      const existingModal = document.querySelector('#tagsEditModal');
      if (existingModal) {
        existingModal.remove();
      }

      // Use native HTML5 dialog element for proper z-index handling
      const modal = document.createElement('dialog');
      modal.id = 'tagsEditModal';
      modal.style.cssText = `
        max-width: 500px !important;
        width: 90% !important;
        padding: 0 !important;
        border: none !important;
        border-radius: 12px !important;
        background: transparent !important;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5) !important;
      `;

      const checkboxesHTML = availableTags.map(tag => `
        <div style="display: flex; align-items: center; gap: 0.5rem; margin: 0.5rem 0; padding: 0.5rem; background: #f5f5f5; border-radius: 8px;">
          <input 
            type="checkbox" 
            id="modal-tag-${tag}" 
            value="${tag}" 
            ${currentTags.includes(tag) ? 'checked' : ''}
            style="margin: 0;"
          >
          <label for="modal-tag-${tag}" style="flex: 1; cursor: pointer; font-weight: 500;">
            <span style="background: #8B4513; color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 0.5rem;">${tag}</span>
            ${tag}
          </label>
        </div>
      `).join('');

      modal.innerHTML = `
        <div style="
          background: white; 
          border-radius: 12px; 
          padding: 1.5rem; 
          border: 3px solid #8B4513;
          font-family: inherit;
          font-size: 16px;
          color: #333;
        ">
          <h3 style="margin: 0 0 1rem 0; color: #8B4513; font-size: 1.2em;">ğŸ·ï¸ Ã‰diter les tags de "${objetName}"</h3>
          <p style="margin: 0 0 1rem 0; color: #666; font-size: 0.9em;">SÃ©lectionnez les tags Ã  assigner Ã  cet objet :</p>
          
          <div id="tagsCheckboxes" style="margin: 1rem 0;">
            ${checkboxesHTML}
          </div>
          
          <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem;">
            <button type="button" class="btn-cancel-tags-modal" style="
              background: #666; 
              color: white; 
              border: none; 
              padding: 8px 16px; 
              border-radius: 6px; 
              cursor: pointer;
              font-weight: 500;
              font-size: 14px;
            ">
              âŒ Annuler
            </button>
            <button type="button" class="btn-save-tags-modal" style="
              background: #8B4513; 
              color: white; 
              border: none; 
              padding: 8px 16px; 
              border-radius: 6px; 
              cursor: pointer;
              font-weight: 500;
              font-size: 14px;
            ">
              ğŸ’¾ Sauvegarder
            </button>
          </div>
        </div>
      `;

      // Append to body and show modal using native dialog API
      document.body.appendChild(modal);

      // Use showModal() for proper top-level display
      try {
        modal.showModal();
      } catch (error) {
        console.error('Error calling showModal():', error);
      }

      // Set up event handlers
      modal.querySelector('.btn-save-tags-modal').addEventListener('click', () => {
        this.saveTagsFromModal(modal);
      });

      modal.querySelector('.btn-cancel-tags-modal').addEventListener('click', () => {
        this.cancelTagsModal(modal);
      });

      // Native dialog handles backdrop clicks and ESC automatically
      modal.addEventListener('cancel', (e) => {
        this.cancelTagsModal(modal);
      });

      // Close on backdrop click (for dialog elements)
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.cancelTagsModal(modal);
        }
      });
    }

    saveTagsFromModal(modal) {
      if (!this.currentEditSession) return false;

      const checkboxes = modal.querySelectorAll('input[type="checkbox"]:checked');
      const selectedTags = Array.from(checkboxes).map(cb => cb.value);

      if (selectedTags.length === 0) {
        alert('Veuillez sÃ©lectionner au moins un tag');
        return false;
      }

      // Update data based on content type
      const itemName = this.currentEditSession.itemIdentifier;
      let targetItem = null;
      
      if (this.currentEditSession.contentType === 'objet') {
        // Update the object data
        targetItem = window.OBJETS?.objets?.find(obj => obj.nom === itemName);
      } else if (this.currentEditSession.contentType === 'monster') {
        // Update the monster data
        targetItem = window.MONSTRES?.find(monster => monster.nom === itemName);
      } else if (this.currentEditSession.contentType === 'tableTresor') {
        // Update the table tresor data
        targetItem = window.TABLES_TRESORS?.tables?.find(table => table.nom === itemName);
      }
      
      if (targetItem) {
        targetItem.tags = selectedTags;
        
        // Update the display
        const tagsDisplay = selectedTags.map(tag => 
          `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`
        ).join('');
        
        // Restore the element and update its content
        this.resetEditingState(this.currentEditSession.container);
        this.restoreElementContent(this.currentEditSession, tagsDisplay);
        
        // Save to storage
        EventBus.emit(Events.STORAGE_SAVE);
        
        // Close modal and clear edit session
        modal.close();
        modal.remove();
        this.currentEditSession = null;
        
        // Show success notification
        JdrApp.modules.ui.showNotification(`ğŸ·ï¸ Tags mis Ã  jour : ${selectedTags.join(', ')}`, 'success');
        
        return true;
      }
      
      return false;
    }

    cancelTagsModal(modal) {
      // Close modal without saving
      modal.close();
      modal.remove();
      
      // Cancel the edit session
      this.cancelCurrentEdit();
    }

    // Save current editing session
    saveCurrentEdit() {
      if (!this.currentEditSession) return false;

      const session = this.currentEditSession;
      // Get the edited HTML content from innerHTML (user edited the rendered content)
      const newContent = session.element.innerHTML.trim();
      const normalizedContent = this.normalizeHTMLContent(newContent);

      // Reset editing state first to avoid interfering with content restoration
      this.resetEditingState(session.container);

      if (normalizedContent !== session.originalContent) {
        const success = this.saveContent(session, normalizedContent);
        if (success) {
          // Convert back from text to rendered HTML
          this.restoreElementContent(session, normalizedContent);
          
          EventBus.emit(Events.CONTENT_UPDATE, {
            contentType: session.contentType,
            itemIdentifier: session.itemIdentifier,
            property: session.property,
            value: normalizedContent
          });
        } else {
          // If save failed, restore original content
          this.restoreElementContent(session, session.originalContent);
        }
      } else {
        // Even if no changes, restore HTML rendering
        this.restoreElementContent(session, session.originalContent);
      }

      this.currentEditSession = null;
      return true;
    }

    // Update content in data structure - unified method for all content types
    updateContentInDataStructure(session, content) {
      try {
        switch (session.contentType) {
          case 'spell':
            return this.updateSpellData(session, content);
          case 'don':
            return this.updateDonData(session, content);
          case 'objet':
            return this.updateObjetData(session, content);
          case 'monster':
            return this.updateMonsterData(session, content);
          case 'category':
            return this.updateCategoryData(session, content);
          case 'subclass':
            return this.updateSubclassData(session, content);
          case 'class':
            return this.updateClassData(session, content);
          case 'staticPage':
            return this.updateStaticPageData(session, content);
          case 'tableTresor':
            return this.updateTableTresorData(session, content);
          case 'pageDescription':
            return this.updatePageDescriptionData(session, content);
          case 'campaign':
            return session.applyEdit(content);
          case 'campaignSubPage':
            return session.applyEdit(content);
          default:
            console.error('Unknown content type for update:', session.contentType);
            return false;
        }
      } catch (error) {
        console.error('Error updating content:', error, session);
        return false;
      }
    }

    // Update spell data
    updateSpellData(session, content) {
      const category = window.SORTS?.find(cat => cat.nom === session.categoryName);
      if (!category) return false;
      
      const spell = category.sorts?.find(s => s.nom === session.itemIdentifier);
      if (!spell) return false;
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.spell;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // If we're updating the name, we need to update the container's data-spell-name attribute
      if (propertyName === 'nom') {
        const oldName = spell.nom;
        spell[propertyName] = content;
        
        // Update the data-spell-name attribute on the card container
        const spellCard = session.container.closest('.card[data-spell-name]');
        if (spellCard && spellCard.dataset.spellName === oldName) {
          spellCard.dataset.spellName = content;
        }
      } else {
        spell[propertyName] = content;
      }
      
      return true;
    }

    // Update don data
    updateDonData(session, content) {
      const category = window.DONS?.find(cat => cat.nom === session.categoryName);
      if (!category) return false;
      
      const don = category.dons?.find(d => d.nom === session.itemIdentifier);
      if (!don) return false;
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.don;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // If we're updating the name, we need to update the container's data-don-name attribute
      if (propertyName === 'nom') {
        const oldName = don.nom;
        don[propertyName] = content;
        
        // Update the data-don-name attribute on the card container
        const donCard = session.container.closest('.card[data-don-name]');
        if (donCard && donCard.dataset.donName === oldName) {
          donCard.dataset.donName = content;
        }
      } else {
        don[propertyName] = content;
      }
      
      return true;
    }

    // Update objet data
    updateObjetData(session, content) {
      const objet = window.OBJETS?.objets?.find(o => o.nom === session.itemIdentifier);
      if (!objet) return false;
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.objet;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // If we're updating the name, we need to update the container's data-objet-name attribute
      if (propertyName === 'nom') {
        const oldName = objet.nom;
        objet[propertyName] = content;
        
        // Update the data-objet-name attribute on the card container
        const objetCard = session.container.closest('.card[data-objet-name]');
        if (objetCard && objetCard.dataset.objetName === oldName) {
          objetCard.dataset.objetName = content;
        }
      } else {
        objet[propertyName] = content;
      }
      
      return true;
    }

    // Update monster data
    updateMonsterData(session, content) {
      const monster = window.MONSTRES?.find(m => m.nom === session.itemIdentifier);
      if (!monster) {
        console.error('Monster not found:', session.itemIdentifier, 'Available monsters:', window.MONSTRES?.map(m => m.nom));
        return false;
      }
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.monster;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // Backup current value for rollback capability
      const originalValue = monster[propertyName];
      
      try {
        // If we're updating the name, we need to update the container's data-monster-name attribute
        if (propertyName === 'nom') {
          const oldName = monster.nom;
          monster[propertyName] = content;
          
          // Update the data-monster-name attribute on the card container
          const monsterCard = session.container.closest('.card[data-monster-name]');
          if (monsterCard && monsterCard.dataset.monsterName === oldName) {
            monsterCard.dataset.monsterName = content;
          }
        } else {
          // Update the monster property
          monster[propertyName] = content;
        }
        
        // Force synchronization using ContentFactory to prevent data reversion
        const contentFactory = window.ContentFactory?.getInstance ? window.ContentFactory.getInstance() : null;
        if (contentFactory && contentFactory.updateItem) {
          // Use ContentFactory to ensure proper data synchronization
          contentFactory.updateItem('monster', null, monster.nom, propertyName, content);
        }
        
        // Additional safety: ensure image mapping is maintained
        if (propertyName === 'image' && JdrApp.modules.images) {
          const imageKey = `monster:${monster.nom}`;
          JdrApp.modules.images.setImage(imageKey, content);
        }
        
        // Create backup for crash recovery
        this.createMonsterBackup(monster);
        
        return true;
        
      } catch (error) {
        // Rollback on error
        console.error('âŒ Error updating monster, rolling back:', error);
        monster[propertyName] = originalValue;
        return false;
      }
    }

    // Update table tresor data
    updateTableTresorData(session, content) {
      const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === session.itemIdentifier);
      if (!table) {
        console.error('Table tresor not found:', session.itemIdentifier, 'Available tables:', window.TABLES_TRESORS?.tables?.map(t => t.nom));
        return false;
      }
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.tableTresor;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // Backup current value for rollback capability
      const originalValue = table[propertyName];
      
      try {
        // If we're updating the name, we need to update the container's data-table-tresor-name attribute
        if (propertyName === 'nom') {
          const oldName = table.nom;
          table[propertyName] = content;
          
          // Update the data-table-tresor-name attribute on the card container
          const tableTresorCard = session.container.closest('.card[data-table-tresor-name]');
          if (tableTresorCard && tableTresorCard.dataset.tableTresorName === oldName) {
            tableTresorCard.dataset.tableTresorName = content;
            
            // Also update the button that uses the table name
            const addFourchetteBtn = tableTresorCard.querySelector('.table-tresor-add-fourchette');
            if (addFourchetteBtn && addFourchetteBtn.dataset.tableTresorName === oldName) {
              addFourchetteBtn.dataset.tableTresorName = content;
            }
          }
          
          // If we're updating the name, we need to update the session itemIdentifier
          // to prevent future saves from failing with the old name
          if (this.currentEditSession && this.currentEditSession.itemIdentifier === originalValue) {
            this.currentEditSession.itemIdentifier = content;
          }
        } else {
          // Update the table property
          table[propertyName] = content;
        }
        
        // Force synchronization using ContentFactory to prevent data reversion
        const contentFactory = window.ContentFactory?.getInstance ? window.ContentFactory.getInstance() : null;
        if (contentFactory && contentFactory.updateItem) {
          // Use ContentFactory to ensure proper data synchronization
          contentFactory.updateItem('tableTresor', 'tables', table.nom, propertyName, content);
        }
        
        return true;
        
      } catch (error) {
        // Rollback on error
        console.error('âŒ Error updating table tresor, rolling back:', error);
        table[propertyName] = originalValue;
        return false;
      }
    }

    // Update page description data (unified system)
    updatePageDescriptionData(session, content) {
      // Use the ContentFactory method that already handles the configuration
      const success = ContentFactory.updatePageDescription(session.pageType, content);
      
      if (success) {
        return true;
      } else {
        console.error(`âŒ Failed to update page description for ${session.pageType}`);
        return false;
      }
    }

    // Update category data (generic for all category types)
    updateCategoryData(session, content) {
      // Handle different category types generically
      if (session.categoryType === 'don') {
        const category = window.DONS?.find(cat => cat.nom === session.categoryName);
        if (category && session.editSection === 'description') {
          category.description = content;
          return true;
        }
      } else if (session.categoryType === 'spell') {
        const category = window.SORTS?.find(cat => cat.nom === session.categoryName);
        if (category && session.editSection === 'description') {
          category.description = content;
          return true;
        }
      }
      
      // Simple fallback - if we're editing description and nothing else matched, 
      // and we have OBJETS, assume it's the objects category
      if (session.editSection === 'description' && window.OBJETS) {
        window.OBJETS.description = content;
        return true;
      }
      
      return false;
    }

    // Update subclass data
    updateSubclassData(session, content) {
      const classe = window.CLASSES?.find(c => c.nom === session.categoryName);
      if (!classe) return false;
      
      const subclass = classe.sousClasses?.find(sc => sc.nom === session.itemIdentifier);
      if (!subclass) return false;
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.subclass;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // If we're updating the name, we need to update the container's data-subclass-name attribute
      if (propertyName === 'nom') {
        const oldName = subclass.nom;
        subclass[propertyName] = content;
        
        // Update the data-subclass-name attribute on the card container
        const subclassCard = session.container.closest('.card[data-subclass-name]');
        if (subclassCard && subclassCard.dataset.subclassName === oldName) {
          subclassCard.dataset.subclassName = content;
        }
      } else {
        subclass[propertyName] = content;
      }
      
      return true;
    }

    // Update class data
    updateClassData(session, content) {
      const classe = window.CLASSES?.find(c => c.nom === session.itemIdentifier);
      if (!classe) return false;
      
      classe[session.editSection] = content;
      return true;
    }

    // Update static page data
    updateStaticPageData(session, content) {
      const pageKey = session.itemIdentifier;
      const pageData = window.STATIC_PAGES?.[pageKey];
      
      if (!pageData) return false;
      
      // Handle page title
      if (session.editSection === 'page-title') {
        pageData.title = content;
        return true;
      }
      
      // Handle campaign data (special case for campaign page)
      if (pageKey === 'campagne') {
        return this.updateCampaignData(pageData, session, content);
      }
      
      // Handle sections
      return this.updateStaticPageSection(pageData, session, content);
    }

    // Update specific section in static page data
    updateStaticPageSection(pageData, session, content) {
      if (!pageData.sections) return false;
      
      const sections = pageData.sections;
      
      // Find section by ID or type
      for (let i = 0; i < sections.length; i++) {
        const section = sections[i];
        
        // Direct ID match
        if (section.id === session.editSection) {
          section.content = content;
          return true;
        }
        
        // Handle title updates (ID + "-title")
        if (session.editSection.endsWith('-title')) {
          const sectionId = session.editSection.replace('-title', '');
          if (section.id === sectionId) {
            section.title = content;
            return true;
          }
        }
        
        // Handle intro sections
        if (section.type === 'intro' && session.editSection.includes('intro')) {
          section.content = content;
          return true;
        }
        
        // Handle card sections
        if (section.type === 'card' && section.id === session.editSection) {
          section.content = content;
          return true;
        }
      }
      
      // If no existing section found, check if we need to create one for intro
      if (session.editSection === 'intro' || session.editSection.includes('intro')) {
        const introSection = sections.find(s => s.type === 'intro');
        if (introSection) {
          introSection.content = content;
          return true;
        }
      }
      
      return false;
    }

    // Update campaign and sub-page data
    updateCampaignData(pageData, session, content) {
      const editSection = session.editSection;
      
      // Initialize subPages if not exists
      if (!pageData.subPages) {
        pageData.subPages = {};
      }
      
      // Parse edit section: campaign-{campaignName}-{field} or subpage-{campaignName}-{subPageName}-{field}
      if (editSection.startsWith('campaign-')) {
        // Format: campaign-{campaignName}-{field}
        const parts = editSection.split('-');
        if (parts.length >= 3) {
          const campaignName = parts.slice(1, -1).join('-'); // Handle campaign names with dashes
          const field = parts[parts.length - 1];
          
          if (!pageData.subPages[campaignName]) {
            pageData.subPages[campaignName] = {
              name: campaignName,
              description: 'Description de la campagne',
              subPages: {}
            };
          }
          
          if (field === 'name') {
            // If renaming campaign, we need to move the entire campaign data
            if (campaignName !== content && !pageData.subPages[content]) {
              pageData.subPages[content] = pageData.subPages[campaignName];
              pageData.subPages[content].name = content;
              delete pageData.subPages[campaignName];
            }
          } else if (field === 'description') {
            pageData.subPages[campaignName].description = content;
          }
          
          return true;
        }
      } else if (editSection.startsWith('subpage-')) {
        // Format: subpage-{campaignName}-{subPageName}-{field}
        const parts = editSection.split('-');
        if (parts.length >= 4) {
          const campaignName = parts[1];
          const subPageName = parts.slice(2, -1).join('-'); // Handle sub-page names with dashes
          const field = parts[parts.length - 1];
          
          if (!pageData.subPages[campaignName]) {
            return false; // Campaign doesn't exist
          }
          
          if (!pageData.subPages[campaignName].subPages) {
            pageData.subPages[campaignName].subPages = {};
          }
          
          if (!pageData.subPages[campaignName].subPages[subPageName]) {
            pageData.subPages[campaignName].subPages[subPageName] = {
              title: subPageName,
              content: '<p>Contenu de la sous-page...</p>'
            };
          }
          
          if (field === 'title') {
            // If renaming sub-page, we need to move the entire sub-page data
            if (subPageName !== content && !pageData.subPages[campaignName].subPages[content]) {
              pageData.subPages[campaignName].subPages[content] = pageData.subPages[campaignName].subPages[subPageName];
              pageData.subPages[campaignName].subPages[content].title = content;
              delete pageData.subPages[campaignName].subPages[subPageName];
            }
          } else if (field === 'content') {
            pageData.subPages[campaignName].subPages[subPageName].content = content;
          }
          
          return true;
        }
      }
      
      return false;
    }

    // Save content using unified system
    saveContent(session, content) {
      try {
        // Determine which JSON category to save to
        let jsonCategory;
        
        switch (session.contentType) {
          case 'spell':
            jsonCategory = 'SORTS';
            break;
          case 'don':
            jsonCategory = 'DONS';
            break;
          case 'class':
            jsonCategory = 'CLASSES';
            break;
          case 'subclass':
            jsonCategory = 'CLASSES';  // Subclasses are stored within CLASSES
            break;
          case 'category':
            // Category descriptions can be in SORTS, DONS, or OBJETS
            if (session.categoryType === 'don') {
              jsonCategory = 'DONS';
            } else if (session.categoryType === 'spell') {
              jsonCategory = 'SORTS';
            } else {
              // Default to OBJETS for other category descriptions
              jsonCategory = 'OBJETS';
            }
            break;
          case 'objet':
            jsonCategory = 'OBJETS';
            break;
          case 'monster':
            jsonCategory = 'MONSTRES';
            break;
          case 'staticPage':
          case 'generic':
            jsonCategory = 'STATIC_PAGES';
            break;
          default:
            return false;
        }
        
        return this.saveToJson(session, content, jsonCategory);
      } catch (error) {
        console.error('Save error:', error);
        return false;
      }
    }

    // Unified save method that takes a JSON category parameter
    saveToJson(session, content, jsonCategory) {
      const jsonData = window[jsonCategory];
      if (!jsonData) {
        console.error(`JSON category ${jsonCategory} not found`);
        return false;
      }


      // Generic save - find the target object and save the content
      let targetObject = null;
      
      if (session.contentType === 'spell' || session.contentType === 'don') {
        // Find in category -> items structure
        for (const category of jsonData) {
          if (category.nom === session.categoryName) {
            const itemsKey = session.contentType === 'spell' ? 'sorts' : 'dons';
            // Use index-based identification if available, fallback to name-based
            if (session.itemIndex !== undefined && session.itemIndex !== null) {
              const index = parseInt(session.itemIndex, 10);
              targetObject = category[itemsKey]?.[index];
            } else {
              targetObject = category[itemsKey]?.find(item => item.nom === session.itemIdentifier);
            }
            break;
          }
        }
      } else if (session.contentType === 'class') {
        // Find class directly
        targetObject = jsonData.find(c => c.nom === session.itemIdentifier);
      } else if (session.contentType === 'subclass') {
        // Find subclass within a class
        const parentClass = jsonData.find(c => c.nom === session.categoryName);
        if (parentClass?.sousClasses) {
          targetObject = parentClass.sousClasses.find(sc => sc.nom === session.itemIdentifier);
        }
      } else if (session.contentType === 'objet') {
        // Find object directly in the objets array
        targetObject = jsonData.objets?.find(obj => obj.nom === session.itemIdentifier);
      } else if (session.contentType === 'monster') {
        // Find monster directly in the array
        targetObject = jsonData?.find(monster => monster.nom === session.itemIdentifier);
      } else if (session.contentType === 'tableTresor') {
        // Find table tresor directly in the array
        targetObject = jsonData?.tables?.find(table => table.nom === session.itemIdentifier);
      } else if (session.contentType === 'category') {
        // Find category by name and update its description
        targetObject = jsonData.find(category => category.nom === session.categoryName);
      } else if (session.contentType === 'staticPage' || session.contentType === 'generic') {
        return this.saveStaticPageToJson(jsonData, session, content);
      }
      
      if (targetObject) {
        targetObject[session.editSection] = content;
        return true;
      } else {
        return false;
      }
    }


    saveStaticPageToJson(jsonData, session, content) {
      const pageData = jsonData[session.itemIdentifier];
      if (!pageData?.sections) {
        console.error('Page data or sections not found for:', session.itemIdentifier);
        return false;
      }

      // Generic search by section ID or special cases
      const updateSection = (sections) => {
        for (const section of sections) {
          // Direct ID match for content
          if (section.id === session.editSection) {
            section.content = content;
            return true;
          }
          
          // Handle title updates (ID + "-title")
          if (session.editSection.endsWith('-title')) {
            const sectionId = session.editSection.replace('-title', '');
            if (section.id === sectionId) {
              section.title = content;
              return true;
            }
          }
          
          // Handle page title
          if (session.editSection === 'page-title') {
            // Page title is stored in the page data, not sections
            // This will be handled at page level
            return false;
          }
          
          // Handle intro sections
          if (section.type === 'intro' && session.editSection === 'intro') {
            section.content = content;
            return true;
          }

          // Handle nested content arrays (for grid sections)
          if (section.content && Array.isArray(section.content)) {
            if (updateSection(section.content)) {
              return true;
            }
          }
        }
        return false;
      };

      // Special handling for page title
      if (session.editSection === 'page-title') {
        pageData.title = content;
        return true;
      }

      if (updateSection(pageData.sections)) {
        return true;
      }

      console.error('Section not found for editSection:', session.editSection);
      return false;
    }

    // No special processing - everything is just HTML now
    processContentByType(content, fieldConfig) {
      return content;
    }

    // UNIFIED CONTENT RESTORATION - USE THIS FOR ALL CONTENT TYPES
    // This method ensures that HTML content is always properly rendered
    // and prevents HTML tags from being displayed as visible text
    restoreElementContent(session, content) {
      // IMPORTANT: Always use innerHTML to render HTML content properly
      // Never use textContent for edited content as it will show HTML tags
      session.element.innerHTML = content;
      
      // NOTE FOR DEVELOPERS: 
      // - For ANY new content type, use this method instead of direct innerHTML assignment
      // - This prevents the recurring issue of visible HTML tags after editing
      // - ALL content types (static pages, spells, classes, dons) go through this
    }

    resetEditingState(container) {
      const editableElement = container.querySelector('.editable') || container;
      
      // Standard editing cleanup (modal is handled separately)
      editableElement.contentEditable = false;
      // Simplified cleanup to prevent stack overflow
      editableElement.style.background = '';
      editableElement.style.border = '';
      editableElement.style.padding = '';
      editableElement.style.fontFamily = '';
      editableElement.style.whiteSpace = '';
      
      // Reset both container and editable element attributes
      container.dataset.editing = 'false';
      delete container.dataset.originalContent;
      
      // Also reset on the editable element itself in case it's the same
      if (editableElement !== container) {
        editableElement.dataset.editing = 'false';
        delete editableElement.dataset.originalContent;
      }
    }


    decodeHtmlEntities(html) {
      // Decode HTML entities step by step to prevent double-encoding
      let decoded = html
        .replace(/&amp;lt;/g, '<')  // &amp;lt; -> <
        .replace(/&amp;gt;/g, '>')  // &amp;gt; -> >
        .replace(/&lt;/g, '<')     // &lt; -> <
        .replace(/&gt;/g, '>')     // &gt; -> >
        .replace(/&quot;/g, '"')   // &quot; -> "
        .replace(/&#39;/g, "'")    // &#39; -> '
        .replace(/&amp;/g, '&');   // &amp; -> & (do this last)
      return decoded;
    }

    normalizeHTMLContent(html) {
      // SIMPLIFIED VERSION to prevent infinite loops
      // Just return the trimmed HTML without complex transformations
      if (!html || typeof html !== 'string') {
        return '';
      }
      
      // Basic cleanup only - avoid complex regex chains that can loop
      let cleaned = html.trim();
      
      // Only safe, non-recursive replacements
      cleaned = cleaned.replace(/&quot;/g, '"');
      cleaned = cleaned.replace(/&#39;/g, "'");
      cleaned = cleaned.replace(/<br\s*\/?>/gi, '<br>');
      
      return cleaned;
    }

    // Cancel current edit
    cancelCurrentEdit() {
      if (!this.currentEditSession) return false;

      const session = this.currentEditSession;
      // Reset editing state first to avoid interfering with content restoration
      this.resetEditingState(session.container);
      // Restore original content
      this.restoreElementContent(session, session.originalContent);
      this.currentEditSession = null;
      return true;
    }

    // Check if element is currently being edited
    isEditing(element) {
      return element.dataset.editing === 'true';
    }

    // Save all active edits
    saveAllEdits() {
      if (this.currentEditSession) {
        this.saveCurrentEdit();
      }

      // Handle any remaining editing elements
      document.querySelectorAll('[data-editing="true"]').forEach(element => {
        if (!this.isValidForEdit(element)) {
          this.resetEditingState(element);
        }
      });
    }

    isValidForEdit(element) {
      const context = this.parseEditContext(element);
      return context !== null;
    }

    // Handle tags editing context
    parseTagsEditContext(element, editSection) {
      // Check if we're in an objet card
      const objetCard = element.closest('.card[data-objet-name]');
      if (objetCard) {
        const objetName = objetCard.dataset.objetName;
        const categoryName = objetCard.dataset.categoryName;
        
        return {
          contentType: 'objet',
          itemIdentifier: objetName,
          categoryName: categoryName,
          property: 'tags',
          editType: 'tags',
          editSection: 'tags',
          config: window.ContentTypes.objet,
          element: element.classList.contains('editable-tags') ? element : element.querySelector('.editable-tags'),
          container: element
        };
      }
      
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        const editableElement = element.classList.contains('editable-tags') ? element : element.querySelector('.editable-tags');
        
        // Use data-item-identifier if available, otherwise fall back to monsterName
        const itemIdentifier = editableElement?.dataset?.itemIdentifier || monsterName;
        
        return {
          contentType: 'monster',
          itemIdentifier: itemIdentifier,
          categoryName: categoryName || 'monstres',
          property: 'tags',
          editType: 'tags',
          editSection: 'tags',
          config: window.ContentTypes.monster,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a table de trÃ©sor card
      const tableTresorCard = element.closest('.card[data-table-tresor-name]');
      if (tableTresorCard) {
        const tableTresorName = tableTresorCard.dataset.tableTresorName;
        const categoryName = tableTresorCard.dataset.categoryName || 'tables';
        
        const editableElement = element.classList.contains('editable-tags') ? element : element.querySelector('.editable-tags');
        
        // Use data-item-identifier if available, otherwise fall back to tableTresorName
        const itemIdentifier = editableElement?.dataset?.itemIdentifier || tableTresorName;
        
        return {
          contentType: 'tableTresor',
          itemIdentifier: itemIdentifier,
          categoryName: categoryName,
          property: 'tags',
          editType: 'tags',
          editSection: 'tags',
          config: window.ContentTypes.tableTresor,
          element: editableElement,
          container: element
        };
      }
      
      return null;
    }

    // Force reset of all elements that might be stuck in editing mode
    forceResetAllEditingElements() {
      // Reset any elements with contenteditable=true
      const editableElements = document.querySelectorAll('[contenteditable="true"]');
      editableElements.forEach(element => {
        element.contentEditable = false;
        element.style.background = '';
        element.style.border = '';
        element.style.padding = '';
        element.style.borderRadius = '';
        element.style.fontFamily = '';
        element.style.whiteSpace = '';
      });
      
      // Reset any containers with data-editing=true
      const editingContainers = document.querySelectorAll('[data-editing="true"]');
      editingContainers.forEach(container => {
        container.dataset.editing = 'false';
        delete container.dataset.originalContent;
      });
      
      // Clear any current edit session
      this.currentEditSession = null;
    }

    // Main entry point for starting edit
    startEdit(element) {
      // Force reset of any stuck editing elements first
      this.forceResetAllEditingElements();
      
      // Cancel any existing edit first
      if (this.currentEditSession) {
        this.saveCurrentEdit();
      }

      const context = this.parseEditContext(element);
      if (!context) {
        return false;
      }

      // Handle tags editing differently - show modal instead of inline editing
      if (context.editType === 'tags') {
        this.startTagsEdit(context);
        return true;
      }

      // Handle select editing differently - show dropdown instead of inline editing
      if (context.editType === 'select') {
        this.startSelectEdit(context);
        return true;
      }

      // Start normal inline editing
      return this.startInlineEdit(context);
    }

    // Start inline editing (for non-tags content)
    startInlineEdit(context) {
      const element = context.element;
      const container = context.container;

      // Store original content
      const originalContent = element.innerHTML;
      
      // Create edit session
      this.currentEditSession = {
        ...context,
        originalContent: originalContent
      };

      // Set up editing state
      container.dataset.editing = 'true';
      container.dataset.originalContent = originalContent;
      
      // Decode any encoded HTML before showing for editing
      const decodedHtml = this.decodeHtmlEntities(originalContent);
      element.innerHTML = decodedHtml;
      
      // Always use modal editing for consistency
      // Force modal editing for all content types to ensure uniform behavior
      this.showHTMLEditModal(element, decodedHtml);

      return true;
    }

    // Save current edit
    saveCurrentEdit() {
      if (!this.currentEditSession) return false;

      const session = this.currentEditSession;
      const element = session.element;
      const newContent = element.innerHTML.trim();
      
      // Normalize and clean HTML content
      const processedContent = this.normalizeHTMLContent(newContent);
      
      // Apply changes to data structure
      const success = this.updateContentInDataStructure(session, processedContent);
      
      if (success) {
        // Update display
        this.restoreElementContent(session, processedContent);
        
        // Note: Storage save is handled elsewhere to prevent loops
        // Show success notification
        if (JdrApp.modules.ui?.showNotification) {
          JdrApp.modules.ui.showNotification('ğŸ’¾ Modification sauvegardÃ©e', 'success');
        }
      } else {
        console.error('Failed to save edit:', session);
      }
      
      // Reset editing state
      this.resetEditingState(session.container);
      this.currentEditSession = null;
      
      return success;
    }

    // Show modal for editing HTML content
    showHTMLEditModal(element, htmlContent) {
      // Store the current edit session for later use
      const editSession = this.currentEditSession;
      
      const modal = document.createElement('dialog');
      modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 0;
        border: none;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        max-width: 80vw;
        max-height: 80vh;
        z-index: 1000000 !important;
        background: transparent;
      `;

      // CrÃ©er un backdrop manuel
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999999 !important;
        backdrop-filter: blur(4px);
      `;

      modal.innerHTML = `
        <div style="background: var(--paper); border-radius: 12px; padding: 1.5rem; border: 2px solid var(--rule); max-height: 80vh; overflow-y: auto; display: flex; flex-direction: column;">
          <h3 style="margin: 0 0 1rem 0; color: var(--accent-ink); flex-shrink: 0;">Ã‰dition du contenu</h3>
          
          <div style="margin-bottom: 1rem; flex-shrink: 0;">
            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">AperÃ§u du rendu:</label>
            <div id="preview" style="border: 1px solid var(--rule); padding: 1rem; border-radius: 6px; background: var(--card); min-height: 60px; max-height: 150px; overflow-y: auto;">
              ${htmlContent}
            </div>
          </div>
          
          <div style="margin-bottom: 1rem; flex: 1; min-height: 0; display: flex; flex-direction: column;">
            <label for="htmlEditor" style="display: block; margin-bottom: 0.5rem; font-weight: 600; flex-shrink: 0;">Code HTML:</label>
            <textarea 
              id="htmlEditor" 
              style="width: 100%; flex: 1; min-height: 200px; padding: 1rem; border: 1px solid var(--rule); border-radius: 6px; font-family: monospace; font-size: 14px; resize: vertical;"
              placeholder="Entrez le HTML ici..."
            >${htmlContent}</textarea>
          </div>
          
          <div style="margin-bottom: 1rem; flex-shrink: 0;">
            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 0.5rem;">
              <button id="editorElementsBtn" class="btn" style="background: #059669; color: white; font-size: 12px;">ğŸ”¥ Ã‰lÃ©ments</button>
              <button id="editorEtatsBtn" class="btn" style="background: #7c2d12; color: white; font-size: 12px;">âš¡ Ã‰tats</button>
              <button id="editorSpellLinksBtn" class="btn" style="background: #6b21a8; color: white; font-size: 12px;">ğŸ”— Liens Sorts</button>
              <button id="editorPageLinksBtn" class="btn" style="background: #1d4ed8; color: white; font-size: 12px;">ğŸ”— Liens Pages</button>
              <button id="editorMonsterLinksBtn" class="btn" style="background: #dc2626; color: white; font-size: 12px;">ğŸ² Liens Monstres</button>
              <button id="editorTreasureTablesBtn" class="btn" style="background: #b45309; color: white; font-size: 12px;">ğŸ² Tables TrÃ©sors</button>
            </div>
            <div style="font-size: 12px; color: var(--paper-muted); line-height: 1.4;">
              ğŸ’¡ <strong>Astuce:</strong> Utilisez ces boutons pour insÃ©rer rapidement des Ã©lÃ©ments, Ã©tats, liens vers les sorts, les pages, les monstres et les tables de trÃ©sors dans votre contenu HTML.
            </div>
          </div>
          
          <div style="display: flex; gap: 1rem; justify-content: flex-end; flex-shrink: 0;">
            <button id="cancelEdit" class="btn" style="background: #6b7280; color: white;">Annuler</button>
            <button id="saveEdit" class="btn" style="background: var(--accent); color: white;">ğŸ’¾ Sauvegarder</button>
          </div>
        </div>
      `;

      document.body.appendChild(backdrop);
      document.body.appendChild(modal);
      modal.show();

      const textarea = modal.querySelector('#htmlEditor');
      const preview = modal.querySelector('#preview');
      const saveBtn = modal.querySelector('#saveEdit');
      const cancelBtn = modal.querySelector('#cancelEdit');
      const elementsBtn = modal.querySelector('#editorElementsBtn');
      const etatsBtn = modal.querySelector('#editorEtatsBtn');
      const spellLinksBtn = modal.querySelector('#editorSpellLinksBtn');
      const pageLinksBtn = modal.querySelector('#editorPageLinksBtn');
      const monsterLinksBtn = modal.querySelector('#editorMonsterLinksBtn');
      const treasureTablesBtn = modal.querySelector('#editorTreasureTablesBtn');

      // Helper function to insert text at cursor position in textarea
      const insertTextAtCursor = (text) => {
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const currentValue = textarea.value;
        
        textarea.value = currentValue.substring(0, start) + text + currentValue.substring(end);
        textarea.selectionStart = textarea.selectionEnd = start + text.length;
        textarea.focus();
        
        // Update preview
        try {
          preview.innerHTML = textarea.value;
        } catch (e) {
          preview.textContent = 'AperÃ§u invalide: ' + e.message;
        }
      };

      // Store the insertTextAtCursor function globally so modals can access it
      window.editorInsertTextAtCursor = insertTextAtCursor;

      // Toolbox buttons handlers
      if (elementsBtn) {
        elementsBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showElementsModal) {
            JdrApp.modules.ui.showElementsModal();
          }
        });
      }

      if (etatsBtn) {
        etatsBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showEtatsModal) {
            JdrApp.modules.ui.showEtatsModal();
          }
        });
      }

      if (spellLinksBtn) {
        spellLinksBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showSpellLinksModal) {
            JdrApp.modules.ui.showSpellLinksModal();
          }
        });
      }

      if (pageLinksBtn) {
        pageLinksBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showPageLinksModal) {
            JdrApp.modules.ui.showPageLinksModal();
          }
        });
      }

      if (monsterLinksBtn) {
        monsterLinksBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showMonsterLinksModal) {
            JdrApp.modules.ui.showMonsterLinksModal();
          }
        });
      }

      // Live preview update with debounce to prevent performance issues
      let previewUpdateTimeout;
      textarea.addEventListener('input', () => {
        clearTimeout(previewUpdateTimeout);
        previewUpdateTimeout = setTimeout(() => {
          try {
            preview.innerHTML = textarea.value;
          } catch (e) {
            preview.textContent = 'AperÃ§u invalide: ' + e.message;
          }
        }, 300); // 300ms debounce
      });

      // Save handler
      saveBtn.addEventListener('click', () => {
        const newContent = textarea.value.trim();
        const normalizedContent = this.normalizeHTMLContent(newContent);
        
        // Update the element content
        element.innerHTML = normalizedContent;
        
        // Update in data structure using stored session
        const success = this.updateContentInDataStructure(editSession, normalizedContent);
        
        if (success) {
          EventBus.emit(Events.STORAGE_SAVE);
          if (JdrApp.modules.ui?.showNotification) {
            JdrApp.modules.ui.showNotification('ğŸ’¾ Modification sauvegardÃ©e', 'success');
          }
        }
        
        // Clean up
        this.resetEditingState(editSession.container);
        this.currentEditSession = null;
        window.editorInsertTextAtCursor = null;
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Cancel handler
      cancelBtn.addEventListener('click', () => {
        this.resetEditingState(editSession.container);
        this.currentEditSession = null;
        window.editorInsertTextAtCursor = null;
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Close on backdrop click
      backdrop.addEventListener('click', () => {
        this.resetEditingState(editSession.container);
        this.currentEditSession = null;
        window.editorInsertTextAtCursor = null;
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Treasure tables button handler
      if (treasureTablesBtn) {
        treasureTablesBtn.addEventListener('click', () => {
          this.showTreasureTablesModal(insertTextAtCursor);
        });
      }

      // Focus textarea
      textarea.focus();
      textarea.select();
    }

    // Handle select editing by toggling display/selector visibility
    startSelectEdit(context) {
      const element = context.element;
      const container = context.container;

      // Store the current edit session
      this.currentEditSession = {
        ...context,
        originalContent: element.value // For select, we store the value, not innerHTML
      };

      // Find the display and selector sections
      const sectionContainer = element.closest('.monster-element-section, .spell-element-section');
      if (!sectionContainer) {
        return false;
      }

      const displaySection = sectionContainer.querySelector('.monster-element-display, .spell-element-display');
      const selectorSection = sectionContainer.querySelector('.monster-element-selector, .spell-element-selector');
      
      if (!displaySection || !selectorSection) {
        return false;
      }

      // Toggle visibility
      displaySection.style.display = 'none';
      selectorSection.style.display = 'block';

      // Set up change listener for the select element
      const selectElement = selectorSection.querySelector('select');
      if (selectElement) {
        selectElement.focus();
        
        // Add event listener for changes
        const changeHandler = () => {
          this.saveSelectEdit(selectElement);
          selectElement.removeEventListener('change', changeHandler);
          selectElement.removeEventListener('blur', blurHandler);
        };

        const blurHandler = () => {
          this.cancelSelectEdit(sectionContainer);
          selectElement.removeEventListener('change', changeHandler);
          selectElement.removeEventListener('blur', blurHandler);
        };

        selectElement.addEventListener('change', changeHandler);
        selectElement.addEventListener('blur', blurHandler);
      }

      return true;
    }

    // Save select edit
    saveSelectEdit(selectElement) {
      if (!this.currentEditSession) return false;

      const newValue = selectElement.value;
      const session = this.currentEditSession;

      // Update the data structure
      const success = this.updateContentInDataStructure(session, newValue);

      if (success) {
        // Update the display immediately
        this.updateElementDisplay(session, newValue);
        
        // Emit storage save event
        EventBus.emit(Events.STORAGE_SAVE);
        
        // Show success notification
        if (JdrApp.modules.ui?.showNotification) {
          JdrApp.modules.ui.showNotification('ğŸ’¾ Ã‰lÃ©ment mis Ã  jour', 'success');
        }
      }

      // Hide selector and show display
      this.resetSelectEdit();
      this.currentEditSession = null;
      return success;
    }

    // Cancel select edit
    cancelSelectEdit(sectionContainer) {
      this.resetSelectEdit();
      this.currentEditSession = null;
    }

    // Reset select edit UI state
    resetSelectEdit() {
      if (!this.currentEditSession) return;

      const element = this.currentEditSession.element;
      const sectionContainer = element.closest('.monster-element-section, .spell-element-section');
      if (!sectionContainer) return;

      const displaySection = sectionContainer.querySelector('.monster-element-display, .spell-element-display');
      const selectorSection = sectionContainer.querySelector('.monster-element-selector, .spell-element-selector');
      
      if (displaySection && selectorSection) {
        displaySection.style.display = 'block';
        selectorSection.style.display = 'none';
      }
    }

    // Update element display after selection change
    updateElementDisplay(session, newValue) {
      const element = session.element;
      const sectionContainer = element.closest('.monster-element-section, .spell-element-section');
      if (!sectionContainer) return;

      const displaySection = sectionContainer.querySelector('.monster-element-display, .spell-element-display');
      const badge = displaySection?.querySelector('.element-badge');
      
      if (badge) {
        // Get element icon and color
        const icon = window.ElementIcons?.[newValue] || 'âš¡';
        const color = window.ElementColors?.[newValue]?.color || '#666';
        
        // Update the badge content and style
        if (session.contentType === 'monster') {
          // For monsters, we need to update the complete badge styling
          const iconSpan = badge.querySelector('span:first-child');
          const textSpan = badge.querySelector('span:last-child');
          if (iconSpan && textSpan) {
            iconSpan.textContent = icon;
            textSpan.textContent = newValue;
            textSpan.style.color = color;
            
            // Update the complete badge background and border
            const hexColor = color;
            const rgbMatch = hexColor.match(/^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
            if (rgbMatch) {
              const r = parseInt(rgbMatch[1], 16);
              const g = parseInt(rgbMatch[2], 16);
              const b = parseInt(rgbMatch[3], 16);
              badge.style.background = `rgba(${r}, ${g}, ${b}, 0.1)`;
              badge.style.border = `1px solid ${hexColor}`;
            }
          }
        } else if (session.contentType === 'spell') {
          // Update spell badge
          badge.innerHTML = `${icon} ${newValue}`;
        }
      }
    }

    // Handle tags editing by showing modal
    startTagsEdit(context) {
      // For tags, we don't do inline editing, we show a modal
      this.showTagsModal(context);
    }

    // Show tags editing modal
    showTagsModal(context) {
      // Find the target item (object or monster)
      let targetItem = null;
      let availableTags = [];
      
      if (context.contentType === 'objet') {
        const allObjects = window.OBJETS?.objets || [];
        targetItem = allObjects.find(o => o.nom === context.itemIdentifier);
        availableTags = window.ContentTypes.objet.filterConfig.availableTags || [];
      } else if (context.contentType === 'monster') {
        const allMonsters = window.MONSTRES || [];
        targetItem = allMonsters.find(m => m.nom === context.itemIdentifier);
        availableTags = window.ContentTypes.monster.filterConfig.availableTags || [];
      } else if (context.contentType === 'tableTresor') {
        const allTables = window.TABLES_TRESORS?.tables || [];
        targetItem = allTables.find(t => t.nom === context.itemIdentifier);
        // Use metadata as primary source, fallback to ContentTypes config
        availableTags = window.TABLES_TRESORS?._metadata?.availableTags || 
                       window.ContentTypes.tableTresor?.filterConfig?.availableTags || [];
      }
      
      if (!targetItem) {
        console.error('Item not found for tags editing:', context.itemIdentifier, 'Type:', context.contentType);
        return;
      }

      const itemTags = targetItem.tags || [];

      // Remove existing modal if any
      const existingModal = document.querySelector('#tagsEditModal');
      if (existingModal) {
        existingModal.remove();
      }

      // Create modal
      const modal = document.createElement('dialog');
      modal.id = 'tagsEditModal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        padding: 0;
        border: none;
        border-radius: 12px;
        background: transparent;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      `;
      
      const tagsCheckboxes = availableTags.map(tag => {
        const isSelected = itemTags.includes(tag);
        return `
          <div style="display: flex; align-items: center; gap: 0.5rem; margin: 0.5rem 0; padding: 0.5rem; background: var(--card); border-radius: 8px;">
            <input 
              type="checkbox" 
              id="tag-${tag}" 
              value="${tag}" 
              ${isSelected ? 'checked' : ''}
              style="margin: 0;"
            >
            <label for="tag-${tag}" style="flex: 1; cursor: pointer; font-weight: 500;">
              <span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 0.5rem;">${tag}</span>
              ${tag}
            </label>
          </div>
        `;
      }).join('');

      modal.innerHTML = `
        <div style="background: var(--paper); border-radius: 12px; padding: 1.5rem; border: 2px solid var(--rule);">
          <h3 style="margin: 0 0 1rem 0; color: var(--accent-ink);">Ã‰dition des tags - ${targetItem.nom}</h3>
          <p style="margin: 0 0 1rem 0; color: var(--paper-muted);">SÃ©lectionnez les tags pour cet objet :</p>
          <div id="tagsCheckboxes" style="margin: 1rem 0; max-height: 300px; overflow-y: auto;">
            ${tagsCheckboxes}
          </div>
          <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem;">
            <button class="btn" id="saveTagsBtn" style="background: var(--accent); color: white;">
              ğŸ’¾ Sauvegarder
            </button>
            <button class="btn modal-close" style="background: #666; color: white;">
              âŒ Annuler
            </button>
          </div>
        </div>
      `;

      // Add event listeners
      modal.addEventListener('click', (e) => {
        if (e.target.id === 'saveTagsBtn') {
          this.saveTagsFromModal(modal, targetItem, context);
        } else if (e.target.classList.contains('modal-close')) {
          modal.close();
          modal.remove();
        }
      });

      // Handle dialog close events
      modal.addEventListener('cancel', () => {
        modal.close();
        modal.remove();
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.close();
          modal.remove();
        }
      });

      document.body.appendChild(modal);
      modal.showModal();
    }

    // Save tags from modal
    saveTagsFromModal(modal, obj, context) {
      // Get selected tags
      const checkboxes = modal.querySelectorAll('input[type="checkbox"]:checked');
      const selectedTags = Array.from(checkboxes).map(cb => cb.value);

      if (selectedTags.length === 0) {
        JdrApp.modules.ui.showNotification('âŒ Veuillez sÃ©lectionner au moins un tag', 'error');
        return;
      }

      // Update tags for the target item (works for both objects and monsters)
      obj.tags = selectedTags;

      // Update the display immediately
      const tagDisplay = context.element;
      if (tagDisplay) {
        const tagsDisplayHTML = selectedTags.map(tag => 
          `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`
        ).join('');
        tagDisplay.innerHTML = tagsDisplayHTML;
      }

      // Trigger save to storage
      EventBus.emit(Events.STORAGE_SAVE);
      
      // Close modal
      modal.close();
      modal.remove();
      
      JdrApp.modules.ui.showNotification(`ğŸ’¾ Tags sauvegardÃ©s pour "${obj.nom}"`, 'success');
    }

    // Create backup of monster data for recovery
    createMonsterBackup(monster) {
      try {
        if (!window.MonsterBackups) {
          window.MonsterBackups = new Map();
        }
        
        // Keep only last MAX_MONSTER_BACKUPS backups per monster
        const backupKey = monster.nom;
        const currentBackups = window.MonsterBackups.get(backupKey) || [];
        
        const backup = {
          timestamp: Date.now(),
          data: JSON.parse(JSON.stringify(monster)) // Deep copy
        };
        
        currentBackups.push(backup);
        const maxBackups = window.DEFAULT_VALUES?.MAX_MONSTER_BACKUPS || 10;
        if (currentBackups.length > maxBackups) {
          currentBackups.shift(); // Remove oldest
        }
        
        window.MonsterBackups.set(backupKey, currentBackups);
        
      } catch (error) {
        // Ignore backup failures - not critical
      }
    }

    // Recover monster from backup
    recoverMonsterFromBackup(monsterName, backupIndex = 0) {
      try {
        if (!window.MonsterBackups || !window.MonsterBackups.has(monsterName)) {
          console.error('No backup found for monster:', monsterName);
          return false;
        }
        
        const backups = window.MonsterBackups.get(monsterName);
        const backup = backups[backups.length - 1 - backupIndex]; // Get latest by default
        
        if (!backup) {
          console.error('Backup index out of range for monster:', monsterName);
          return false;
        }
        
        // Find monster in current data
        const monster = window.MONSTRES?.find(m => m.nom === monsterName);
        if (!monster) {
          console.error('Monster not found in current data:', monsterName);
          return false;
        }
        
        // Restore data
        Object.assign(monster, backup.data);
        
        // Force sync
        const contentFactory = window.ContentFactory?.getInstance ? window.ContentFactory.getInstance() : null;
        if (contentFactory && contentFactory.refreshData) {
          contentFactory.refreshData();
        }
        
        return true;
        
      } catch (error) {
        console.error('Failed to recover monster from backup:', error);
        return false;
      }
    }

    // Global validation and repair of monster data
    validateAndRepairMonsterData() {
      if (!window.MONSTRES || !Array.isArray(window.MONSTRES)) {
        return 0;
      }
      
      let repairCount = 0;
      const contentTypes = window.ContentTypes?.monster;
      
      window.MONSTRES.forEach((monster, index) => {
        // Ensure required properties exist
        if (!monster.nom) {
          monster.nom = `Monstre ${index + 1}`;
          repairCount++;
        }
        
        // Validate numeric properties
        if (contentTypes && contentTypes.fields) {
          Object.entries(contentTypes.fields).forEach(([fieldName, fieldConfig]) => {
            if (fieldConfig.type === 'number') {
              if (typeof monster[fieldName] !== 'number' || isNaN(monster[fieldName])) {
                const defaultValue = contentTypes.defaultValues?.[fieldName] || 0;
                monster[fieldName] = defaultValue;
                repairCount++;
              }
            }
          });
        }
        
        // Ensure image path exists and is valid
        if (!monster.image || typeof monster.image !== 'string') {
          monster.image = `data/images/Monstres/foret/Monstre_ForÃªt_${monster.nom.replace(/[^a-zA-Z0-9]/g, '')}.png`;
          repairCount++;
        }
        
        // Validate image mapping exists
        if (JdrApp.modules.images) {
          const imageKey = `monster:${monster.nom}`;
          if (!JdrApp.modules.images.getImageUrl(imageKey)) {
            JdrApp.modules.images.setImage(imageKey, monster.image);
          }
        }
      });
      
      if (repairCount > 0) {
        // Save repaired data
        if (JdrApp.modules.storage && JdrApp.modules.storage.saveChanges) {
          JdrApp.modules.storage.saveChanges(true);
        }
      }
      
      return repairCount;
    }
    
    // Update static page data method
    updateStaticPageData(session, content) {
      try {
        const pageId = session.itemIdentifier;
        const editSection = session.editSection;
        
        // Get the static page data
        const staticPageData = window.STATIC_PAGES?.[pageId];
        if (!staticPageData) {
          console.error('Static page not found:', pageId);
          return false;
        }
        
        // Handle different edit section formats
        if (editSection.startsWith('intro-')) {
          // Editing intro section
          const sectionIndex = parseInt(editSection.split('-')[1]);
          if (staticPageData.sections && staticPageData.sections[sectionIndex] && staticPageData.sections[sectionIndex].type === 'intro') {
            staticPageData.sections[sectionIndex].content = content;
          }
        } else if (editSection === 'page-title') {
          // Editing page title
          staticPageData.title = content;
        } else if (editSection.endsWith('-title')) {
          // Editing card title (e.g., "dieux-new-2-1756899335313-title")
          const cardId = editSection.slice(0, -6); // Remove "-title"
          const cardSection = staticPageData.sections?.find(s => s.id === cardId);
          if (cardSection) {
            cardSection.title = content;
          }
        } else {
          // Editing card content (e.g., "dieux-new-2-1756899335313")
          const cardSection = staticPageData.sections?.find(s => s.id === editSection);
          if (cardSection) {
            cardSection.content = content;
          } else {
            console.warn('Unhandled static page edit section:', editSection);
            return false;
          }
        }
        
        return true;
        
      } catch (error) {
        console.error('Failed to update static page data:', error);
        return false;
      }
    }

    // Campaign and sub-page data update method
    updateCampaignData(type, campaignName, property, content, subPageName = null) {
      try {
        // Get the campaign data from the static pages
        const campagneData = window.STATIC_PAGES?.campagne;
        if (!campagneData || !campagneData.subPages) {
          return false;
        }
        
        if (type === 'campaign') {
          // Update campaign property (name or description)
          if (!campagneData.subPages[campaignName]) {
            return false;
          }
          
          if (property === 'name') {
            // Renaming a campaign requires more complex handling
            // For now, just update the description property
            return false;
          } else if (property === 'description') {
            campagneData.subPages[campaignName].description = content;
          }
        } else if (type === 'subpage') {
          // Update sub-page property (title or content)
          if (!campagneData.subPages[campaignName] || !campagneData.subPages[campaignName].subPages || !subPageName) {
            return false;
          }
          
          const subPage = campagneData.subPages[campaignName].subPages[subPageName];
          if (!subPage) {
            return false;
          }
          
          if (property === 'title') {
            subPage.title = content;
          } else if (property === 'content') {
            subPage.content = content;
          }
        }
        
        // Data updated in memory only - will be saved during export
        // No automatic save to prevent infinite loops
        
        return true;
        
      } catch (error) {
        console.error('Failed to update campaign data:', error);
        return false;
      }
    }

    addEditingControls(container, editableElement) {
      // Remove any existing editing controls
      const existingControls = container.querySelector('.editing-controls');
      if (existingControls) {
        existingControls.remove();
      }

      // Create editing controls toolbar
      const controlsDiv = document.createElement('div');
      controlsDiv.className = 'editing-controls';
      controlsDiv.style.cssText = `
        position: absolute;
        top: -40px;
        right: 0;
        background: var(--paper);
        border: 1px solid var(--bronze);
        border-radius: 6px;
        padding: 4px;
        display: flex;
        gap: 4px;
        z-index: 1000;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      `;

      // Get available treasure tables for the dropdown
      const availableTables = window.TABLES_TRESORS?.tables || [];
      let treasureControls = '';
      
      if (availableTables.length > 0) {
        const tableOptions = availableTables.map(table => 
          `<option value="${table.nom}">${table.nom}</option>`
        ).join('');

        treasureControls = `
          <div class="treasure-table-controls" style="display: flex; align-items: center; gap: 2px; border-right: 1px solid var(--rule); padding-right: 4px; margin-right: 4px;">
            <select class="treasure-table-select" style="font-size: 11px; padding: 2px; border: 1px solid var(--rule); border-radius: 3px;">
              <option value="">Choisir table</option>
              ${tableOptions}
            </select>
            <button type="button" class="copy-treasure-link-btn btn" style="
              background: var(--bronze); 
              color: white; 
              border: none; 
              padding: 2px 6px; 
              border-radius: 3px; 
              cursor: pointer; 
              font-size: 10px;
              white-space: nowrap;
            " title="Copier le lien HTML de la table sÃ©lectionnÃ©e">
              ğŸ“‹ Table
            </button>
          </div>
        `;
      }

      controlsDiv.innerHTML = `
        ${treasureControls}
        <button type="button" class="save-edit-btn btn" style="
          background: var(--accent); 
          color: white; 
          border: none; 
          padding: 2px 6px; 
          border-radius: 3px; 
          cursor: pointer; 
          font-size: 11px;
        ">
          âœ“ Sauver
        </button>
        <button type="button" class="cancel-edit-btn btn" style="
          background: #666; 
          color: white; 
          border: none; 
          padding: 2px 6px; 
          border-radius: 3px; 
          cursor: pointer; 
          font-size: 11px;
        ">
          âœ• Annuler
        </button>
      `;

      // Position the container relatively for absolute positioning of controls
      container.style.position = 'relative';
      container.appendChild(controlsDiv);

      // Set up event listeners
      this.setupEditingControlsListeners(controlsDiv, container, editableElement);
    }

    setupEditingControlsListeners(controlsDiv, container, editableElement) {
      // Save button
      const saveBtn = controlsDiv.querySelector('.save-edit-btn');
      if (saveBtn) {
        saveBtn.addEventListener('click', () => {
          // Get current content
          const newContent = editableElement.innerHTML.trim();
          const normalizedContent = this.normalizeHTMLContent(newContent);
          
          // Update in data structure using current session
          if (this.currentEditSession) {
            const success = this.updateContentInDataStructure(this.currentEditSession, normalizedContent);
            
            if (success) {
              EventBus.emit(Events.STORAGE_SAVE);
              if (JdrApp.modules.ui?.showNotification) {
                JdrApp.modules.ui.showNotification('ğŸ’¾ Modification sauvegardÃ©e', 'success');
              }
            }
            
            // Reset editing state
            this.resetEditingState(container);
            this.currentEditSession = null;
          }
          
          this.removeEditingControls(container);
        });
      }

      // Cancel button  
      const cancelBtn = controlsDiv.querySelector('.cancel-edit-btn');
      if (cancelBtn) {
        cancelBtn.addEventListener('click', () => {
          // Reset editing state without saving
          this.resetEditingState(container);
          if (this.currentEditSession) {
            this.currentEditSession = null;
          }
          this.removeEditingControls(container);
        });
      }

      // Copy treasure table link button
      const copyBtn = controlsDiv.querySelector('.copy-treasure-link-btn');
      const tableSelect = controlsDiv.querySelector('.treasure-table-select');
      
      if (copyBtn && tableSelect) {
        copyBtn.addEventListener('click', () => {
          const selectedTable = tableSelect.value;
          if (selectedTable && window.TablesTresorsManager) {
            const htmlLink = window.TablesTresorsManager.generateTreasureTableHtmlLink(selectedTable);
            
            // Insert the link at cursor position
            if (editableElement.contentEditable === 'true') {
              const selection = window.getSelection();
              if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                range.deleteContents();
                const linkNode = document.createTextNode(htmlLink);
                range.insertNode(linkNode);
                
                // Move cursor after the inserted text
                range.setStartAfter(linkNode);
                range.setEndAfter(linkNode);
                selection.removeAllRanges();
                selection.addRange(range);
              } else {
                // Fallback: append at the end
                editableElement.innerHTML += htmlLink;
              }
              
              // Show notification
              if (window.TablesTresorsManager.showNotification) {
                window.TablesTresorsManager.showNotification('âœ“ Lien de table insÃ©rÃ©!', 'success');
              }
            }
          }
        });
      }

      // Also handle Enter and Escape keys on the editable element
      editableElement.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          e.preventDefault();
          // Reset editing state without saving
          this.resetEditingState(container);
          if (this.currentEditSession) {
            this.currentEditSession = null;
          }
          this.removeEditingControls(container);
        } else if (e.key === 'Enter' && e.ctrlKey) {
          e.preventDefault();
          // Save with Ctrl+Enter
          const newContent = editableElement.innerHTML.trim();
          const normalizedContent = this.normalizeHTMLContent(newContent);
          
          if (this.currentEditSession) {
            const success = this.updateContentInDataStructure(this.currentEditSession, normalizedContent);
            
            if (success) {
              EventBus.emit(Events.STORAGE_SAVE);
              if (JdrApp.modules.ui?.showNotification) {
                JdrApp.modules.ui.showNotification('ğŸ’¾ Modification sauvegardÃ©e', 'success');
              }
            }
            
            this.resetEditingState(container);
            this.currentEditSession = null;
          }
          
          this.removeEditingControls(container);
        }
      });
    }

    removeEditingControls(container) {
      const controls = container.querySelector('.editing-controls');
      if (controls) {
        controls.remove();
      }
    }

    // Show treasure tables selection modal
    showTreasureTablesModal(insertTextAtCursor) {
      const availableTables = window.TABLES_TRESORS?.tables || [];
      
      if (availableTables.length === 0) {
        if (JdrApp.modules.ui?.showNotification) {
          JdrApp.modules.ui.showNotification('âŒ Aucune table de trÃ©sor disponible', 'error');
        }
        return;
      }

      // Create modal
      const modal = document.createElement('dialog');
      modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 0;
        border: none;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        max-width: 500px;
        width: 90%;
        z-index: 1000001 !important;
        background: transparent;
      `;

      // Create backdrop
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000000 !important;
        backdrop-filter: blur(4px);
      `;

      const tableOptions = availableTables.map(table => 
        `<option value="${table.nom}">${table.nom}${table.tags ? ` (${table.tags.join(', ')})` : ''}</option>`
      ).join('');

      modal.innerHTML = `
        <div style="background: var(--paper); border-radius: 12px; padding: 1.5rem; border: 2px solid var(--rule);">
          <h3 style="margin: 0 0 1rem 0; color: var(--accent-ink);">ğŸ² InsÃ©rer un lien de table de trÃ©sor</h3>
          
          <div style="margin-bottom: 1rem;">
            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Choisir une table:</label>
            <select id="treasureTableSelect" style="width: 100%; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px; font-size: 14px;">
              <option value="">-- SÃ©lectionner une table --</option>
              ${tableOptions}
            </select>
          </div>

          <div style="margin-bottom: 1rem;">
            <div id="tablePreview" style="border: 1px solid var(--rule); padding: 1rem; border-radius: 6px; background: var(--card); min-height: 50px; font-size: 12px; color: var(--paper-muted);">
              SÃ©lectionnez une table pour voir l'aperÃ§u
            </div>
          </div>
          
          <div style="display: flex; gap: 1rem; justify-content: flex-end;">
            <button id="cancelTreasureModal" class="btn" style="background: #6b7280; color: white;">Annuler</button>
            <button id="insertTreasureLink" class="btn" style="background: var(--accent); color: white;" disabled>ğŸ² InsÃ©rer le lien</button>
          </div>
        </div>
      `;

      document.body.appendChild(backdrop);
      document.body.appendChild(modal);
      modal.show();

      // Get elements
      const select = modal.querySelector('#treasureTableSelect');
      const preview = modal.querySelector('#tablePreview');
      const insertBtn = modal.querySelector('#insertTreasureLink');
      const cancelBtn = modal.querySelector('#cancelTreasureModal');

      // Handle table selection
      select.addEventListener('change', () => {
        const selectedTableName = select.value;
        if (selectedTableName) {
          insertBtn.disabled = false;
          
          const selectedTable = availableTables.find(t => t.nom === selectedTableName);
          if (selectedTable && window.TablesTresorsManager) {
            const previewHtml = window.TablesTresorsManager.generateTablePreviewHtml(selectedTable);
            preview.innerHTML = previewHtml;
          }
        } else {
          insertBtn.disabled = true;
          preview.innerHTML = 'SÃ©lectionnez une table pour voir l\'aperÃ§u';
        }
      });

      // Handle insert
      insertBtn.addEventListener('click', () => {
        const selectedTableName = select.value;
        if (selectedTableName && window.TablesTresorsManager) {
          const htmlLink = window.TablesTresorsManager.generateTreasureTableHtmlLink(selectedTableName);
          insertTextAtCursor(htmlLink);
          
          if (JdrApp.modules.ui?.showNotification) {
            JdrApp.modules.ui.showNotification('âœ“ Lien de table insÃ©rÃ©!', 'success');
          }
        }
        
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Handle cancel
      cancelBtn.addEventListener('click', () => {
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Handle backdrop click
      backdrop.addEventListener('click', () => {
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Focus select
      select.focus();
    }
  }

  window.UnifiedEditor = UnifiedEditor.getInstance();

})();
// ============================================================================
// JDR-BAB APPLICATION - EDITOR MODULE (REFACTORED)
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // EDITOR MODULE - Now uses UnifiedEditor
  // ========================================
  JdrApp.modules.editor = {
    editedData: {},
    isDevMode: false,

    init() {
      this.setupEventListeners();
      this.setupEditableHandlers();
      this.setupCreationHandlers();
      this.setupImageHandlers();
      this.updateDevModeState();
    },

    setupEventListeners() {
      JdrApp.utils.events.register('click', '#devToggle', () => this.toggleDevMode());

      EventBus.on(Events.EDITOR_TOGGLE, (payload) => {
        this.isDevMode = payload.enabled;
        this.updateDevModeState();
      });

      EventBus.on(Events.CONTENT_UPDATE, () => {
        this.saveChangesToStorage();
      });

    },

    toggleDevMode() {
      if (window.STANDALONE_VERSION) return;
      
      this.isDevMode = !this.isDevMode;
      EventBus.emit(Events.EDITOR_TOGGLE, { enabled: this.isDevMode });
    },

    updateDevModeState() {
      if (window.STANDALONE_VERSION) {
        document.body.className = 'dev-off';
        this.forceHideAllEditButtons();
        return;
      }
      
      document.body.classList.toggle('dev-on', this.isDevMode);
      document.body.classList.toggle('dev-off', !this.isDevMode);
      
      const devToggle = document.querySelector('#devToggle');
      const devToolbox = document.querySelector('#devToolbox');
      
      if (devToggle) {
        devToggle.textContent = `ğŸ›  Dev Mode: ${this.isDevMode ? 'ON' : 'OFF'}`;
      }
      
      if (devToolbox) {
        devToolbox.style.display = this.isDevMode ? 'block' : 'none';
        
        // Initialize toolbox content if empty or only has comments
        if (this.isDevMode) {
          const trimmedContent = devToolbox.innerHTML.trim();
          if (trimmedContent === '' || trimmedContent === '<!-- Dev toolbox content will be injected here -->' || !devToolbox.querySelector('.dev-toolbox-content')) {
            this.initializeDevToolbox(devToolbox);
          }
        }
      }
      
      // Update dev-only containers visibility - same approach as modal buttons
      const devOnlyElements = document.querySelectorAll('[data-dev-only]');
      devOnlyElements.forEach(element => {
        element.style.display = this.isDevMode ? 'block' : 'none';
      });
      
      if (this.isDevMode) {
        this.forceShowAllEditButtons();
      } else {
        this.forceHideAllEditButtons();
      }

      // Regenerate monsters page if currently viewing it
      const currentPage = window.location.hash.replace('#/', '');
      if (currentPage === 'monstres' && JdrApp.modules.renderer && JdrApp.modules.renderer.populateMonstersPage) {
        setTimeout(() => {
          JdrApp.modules.renderer.populateMonstersPage();
        }, 100);
      }
    },

    forceHideAllEditButtons() {
      if (this.isDevMode) {
        return;
      }
      
      const selectors = [
        '.edit-btn', '[class$="-add"]', '[class$="-delete"]', '[class*="-move-"]',
        '.section-delete', '.remove-section-btn', '.add-paragraph-btn', 
        '.add-subclass-btn', '.delete-subclass-btn',
        '.spell-delete', '.don-delete', // Explicit delete buttons
        '.illus .up', '.illus .rm', '.illus label', '.illus input[type="file"]',
        '.tags-manager-btn', '.filter-manager-btn' // Tags and filter manager buttons
      ];
      
      selectors.forEach(selector => {
        document.querySelectorAll(selector).forEach(element => {
          element.style.display = 'none';
          element.style.visibility = 'hidden';
          element.setAttribute('aria-hidden', 'true');
        });
      });
    },
    
    forceShowAllEditButtons() {
      if (!this.isDevMode) return;
      
      // Ensure body has the correct classes
      document.body.classList.add('dev-on');
      document.body.classList.remove('dev-off');
      
      // Force reset all CSS properties that might be causing 0x0 dimensions
      const selectors = [
        '.edit-btn', '[class$="-add"]', '[class$="-delete"]', '[class*="-move-"]',
        '.section-delete', '.remove-section-btn', '.add-paragraph-btn', 
        '.add-subclass-btn', '.delete-subclass-btn',
        '.spell-delete', '.don-delete', '.objet-delete',
        '.spell-add', '.don-add', '.objet-add',
        '.illus .up', '.illus .rm', '.illus label', '.illus input[type="file"]',
        '.tags-manager-btn', '.filter-manager-btn' // Tags and filter manager buttons
      ];
      
      selectors.forEach(selector => {
        document.querySelectorAll(selector).forEach(element => {
          // Force reset all dimension properties
          element.style.removeProperty('display');
          element.style.removeProperty('visibility');
          element.style.removeProperty('opacity');
          element.style.removeProperty('width');
          element.style.removeProperty('height');
          element.style.removeProperty('min-width');
          element.style.removeProperty('min-height');
          element.style.removeProperty('pointer-events');
          element.removeAttribute('aria-hidden');
          
          // Let CSS handle the styling
          element.style.display = '';
          element.style.visibility = '';
        });
      });
    },

    setupEditableHandlers() {
      // Unified edit button handler
      JdrApp.utils.events.register('click', '.edit-btn', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!this.isDevMode) return;
        
        // Prevent multiple edit sessions
        if (UnifiedEditor.currentEditSession) {
          console.warn('Another edit session is already active');
          return;
        }
        
        // Find the editable element near the button
        let editableElement = e.target.previousElementSibling;
        
        // If not found as previous sibling, look in parent
        if (!editableElement || !editableElement.classList.contains('editable')) {
          const parent = e.target.parentElement;
          editableElement = parent.querySelector('.editable');
        }
        
        // Fallback: look for closest editable element
        if (!editableElement || !editableElement.classList.contains('editable')) {
          editableElement = e.target.closest('.editable-section')?.querySelector('.editable') ||
                           e.target.closest('.card')?.querySelector('.editable');
        }
        
        if (editableElement && editableElement.classList.contains('editable')) {
          UnifiedEditor.startEdit(editableElement);
        } else {
          console.warn('No editable element found for edit button');
        }
      });

      // Handle select element changes directly
      JdrApp.utils.events.register('change', '.editable[data-edit-type="select"]', (e) => {
        if (!this.isDevMode) return;
        
        const selectElement = e.target;
        const newValue = selectElement.value;
        
        // Parse context and save immediately
        const context = UnifiedEditor.parseEditContext(selectElement);
        if (context) {
          // Update the data structure
          const success = UnifiedEditor.updateContentInDataStructure(context, newValue);
          if (success) {
            // Update display
            UnifiedEditor.updateElementDisplay(context, newValue);
            
            // Save to storage
            EventBus.emit(Events.STORAGE_SAVE);
            
            // Show notification
            if (JdrApp.modules.ui?.showNotification) {
              JdrApp.modules.ui.showNotification('ğŸ’¾ Ã‰lÃ©ment mis Ã  jour', 'success');
            }
          }
        }
      });

      // Click outside to save
      JdrApp.utils.events.register('click', 'body', (e) => {
        if (!e.target.closest('.editable') && !e.target.matches('.edit-btn')) {
          UnifiedEditor.saveAllEdits();
        }
      });

      // Keyboard shortcuts
      JdrApp.utils.events.register('keydown', '.editable', (e) => {
        if ((e.key === 'Enter' && !e.shiftKey) || e.key === 'Escape') {
          e.preventDefault();
          UnifiedEditor.saveCurrentEdit();
        }
      });

      // Prevent double-click editing (force button-only editing)
      JdrApp.utils.events.register('dblclick', '.editable', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      });
    },

    setupCreationHandlers() {
      // Unified subclass management
      JdrApp.utils.events.register('click', '.add-subclass-btn', (e) => {
        if (!this.isDevMode) return;
        this.addNewSubclass(e.target);
      });

      JdrApp.utils.events.register('click', '.delete-subclass-btn', (e) => {
        if (!this.isDevMode) return;
        this.deleteSubclass(e.target);
      });
    },

    addNewSubclass(button) {
      const article = button.closest('article');
      if (!article) return;
      
      let className = article.dataset.pageTitle;
      if (!className) {
        const hash = window.location.hash.match(/#\/([^\/]+)/);
        if (hash) {
          className = hash[1].charAt(0).toUpperCase() + hash[1].slice(1);
        }
      }
      
      
      if (!className || !window.CLASSES) {
        return;
      }
      
      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe) {
        return;
      }
      
      const config = window.ContentTypes.subclass;
      const newSubclass = { ...config.defaultValues };
      
      
      if (!classe.sousClasses) classe.sousClasses = [];
      classe.sousClasses.push(newSubclass);
      
      
      EventBus.emit(Events.CONTENT_ADD, {
        type: 'subclass',
        category: className,
        item: newSubclass
      });
      
      // Recharger juste le contenu de l'article au lieu de toute la page
      this.reloadClassPage(className);
    },

    deleteSubclass(button) {
      const className = button.dataset.className;
      const subclassName = button.dataset.subclassName;
      
      if (!className || !subclassName) return;
      if (!confirm(`ÃŠtes-vous sÃ»r de vouloir supprimer la sous-classe "${subclassName}" ?`)) return;

      const classe = window.CLASSES?.find(c => c.nom === className);
      if (!classe?.sousClasses) return;

      const index = classe.sousClasses.findIndex(sc => sc.nom === subclassName);
      if (index === -1) return;

      const deletedSubclass = classe.sousClasses.splice(index, 1)[0];
      
      EventBus.emit(Events.CONTENT_DELETE, {
        type: 'subclass',
        category: className,
        item: deletedSubclass
      });
      
      // Recharger juste le contenu de l'article au lieu de toute la page  
      this.reloadClassPage(className);
    },

    reloadClassPage(className) {
      // Trouver l'article de la classe
      const article = document.querySelector(`article[data-page-title="${className}"]`);
      if (!article) return;

      // RÃ©gÃ©nÃ©rer le contenu de la classe
      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe) return;

      // VÃ©rifier que PageBuilder existe
      if (!window.PageBuilder) {
        console.error('PageBuilder not available, falling back to page reload');
        window.location.reload();
        return;
      }

      // Utiliser PageBuilder pour rÃ©gÃ©nÃ©rer le contenu
      const newContent = window.PageBuilder.buildClassPage(classe);
      const parser = new DOMParser();
      const newDoc = parser.parseFromString(newContent, 'text/html');
      const newArticle = newDoc.querySelector('article');
      
      if (newArticle) {
        article.innerHTML = newArticle.innerHTML;
        
        // RÃ©appliquer les images et l'Ã©tat de dev mode
        setTimeout(() => {
          if (JdrApp.modules.renderer?.autoLoadImages) {
            JdrApp.modules.renderer.autoLoadImages();
          }
          // Apply dev mode state properly
          if (this.isDevMode) {
            this.forceShowAllEditButtons();
          } else {
            this.forceHideAllEditButtons();
          }
        }, 50);
      }
    },

    setupImageHandlers() {
      // Fonction pour attacher les Ã©vÃ©nements aux images existantes
      this.attachImageEvents();
      
      // Observer pour attacher les Ã©vÃ©nements aux nouvelles images crÃ©Ã©es dynamiquement
      if (typeof MutationObserver !== 'undefined') {
        const observer = new MutationObserver(() => {
          this.attachImageEvents();
        });
        observer.observe(document.body, { childList: true, subtree: true });
      }
      
      // Force l'attachement aprÃ¨s un dÃ©lai pour s'assurer que les images lazy sont chargÃ©es
      setTimeout(() => {
        this.attachImageEvents();
      }, 2000);
    },

    attachImageEvents() {
      // Attacher aux inputs de fichier
      document.querySelectorAll('.illus input[type="file"]').forEach(input => {
        if (!input.hasAttribute('data-events-attached')) {
          input.addEventListener('change', (e) => this.handleImageUpload(e));
          input.setAttribute('data-events-attached', 'true');
        }
      });

      // Attacher aux boutons de suppression
      document.querySelectorAll('.illus .rm').forEach(button => {
        if (!button.hasAttribute('data-events-attached')) {
          button.addEventListener('click', (e) => this.handleImageRemoval(e));
          button.setAttribute('data-events-attached', 'true');
        }
      });

      // Attacher aux images pour agrandissement - toutes les images, pas seulement celles dans .illus
      const images = document.querySelectorAll('img');
      
      images.forEach(img => {
        // Ã‰viter les images dans les Ã©diteurs ou les inputs
        if (!img.closest('.editor-content') && !img.hasAttribute('data-events-attached')) {
          
          // Ajouter support tactile pour mobile
          img.addEventListener('click', (e) => {
            this.toggleImageEnlargement(e.target);
          });
          img.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.toggleImageEnlargement(e.target);
          });
          
          // Attendre que l'image lazy soit chargÃ©e pour dÃ©finir le curseur
          img.addEventListener('load', () => {
            if (this.isImageEnlargeable(img)) {
              img.style.cursor = 'zoom-in';
            }
          });
          
          // Si l'image est dÃ©jÃ  chargÃ©e
          if (img.complete && img.naturalWidth > 0) {
            if (this.isImageEnlargeable(img)) {
              img.style.cursor = 'zoom-in';
            }
          }
          
          img.setAttribute('data-events-attached', 'true');
        }
      });
    },

    handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const illus = event.target.closest('.illus');
        const img = illus.querySelector('img');
        const rmButton = illus.querySelector('.rm');
        const illusKey = illus.dataset.illusKey;

        img.src = e.target.result;
        img.style.display = 'block';
        if (rmButton) rmButton.style.display = 'block';

        if (JdrApp.modules.images?.setImageUrl) {
          JdrApp.modules.images.setImageUrl(illusKey, e.target.result);
        }

        EventBus.emit(Events.IMAGE_UPLOAD, { 
          illusKey, 
          src: e.target.result 
        });
      };
      
      reader.readAsDataURL(file);
    },

    handleImageRemoval(event) {
      const illus = event.target.closest('.illus');
      const img = illus.querySelector('img');
      const rmButton = illus.querySelector('.rm');
      const illusKey = illus.dataset.illusKey;

      img.src = '';
      img.style.display = 'none';
      if (rmButton) rmButton.style.display = 'none';

      if (JdrApp.modules.images?.removeImage) {
        JdrApp.modules.images.removeImage(illusKey);
      }

      EventBus.emit(Events.IMAGE_DELETE, { illusKey });
    },

    toggleImageEnlargement(img) {
      // VÃ©rifier si l'image est valide pour l'agrandissement
      if (!this.isImageEnlargeable(img)) {
        return;
      }
      
      if (img.classList.contains('enlarged')) {
        this.closeEnlargedImage();
      } else {
        this.showEnlargedImage(img);
      }
    },

    // VÃ©rifier si une image peut Ãªtre agrandie
    isImageEnlargeable(img) {
      // Ne pas agrandir les placeholders SVG
      if (img.src && img.src.startsWith('data:image/svg+xml')) {
        return false;
      }
      
      // Ne pas agrandir si pas de source rÃ©elle
      if (!img.src && !img.getAttribute('data-src')) {
        return false;
      }
      
      // Ne pas agrandir les images trop petites (probablement des icÃ´nes)
      if (img.naturalWidth < 50 || img.naturalHeight < 50) {
        return false;
      }
      
      return true;
    },

    showEnlargedImage(img) {
      // Fermer toute image dÃ©jÃ  ouverte
      this.closeEnlargedImage();
      
      // CrÃ©er un conteneur modal complet
      const modal = document.createElement('div');
      modal.id = 'image-enlargement-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0,0,0,0.8);
        z-index: 2147483647;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: zoom-out;
      `;
      
      // CrÃ©er une copie de l'image
      const enlargedImg = img.cloneNode(true);
      
      // Extraire l'URL originale pour le chargement haute rÃ©solution
      let originalUrl = img.src;
      if (img.hasAttribute('data-src') && !enlargedImg.src) {
        originalUrl = img.getAttribute('data-src');
      }
      
      // Si l'image utilise le service weserv.nl, extraire l'URL originale haute rÃ©solution
      if (originalUrl.includes('images.weserv.nl')) {
        const urlParams = new URLSearchParams(originalUrl.split('?')[1]);
        const encodedOriginal = urlParams.get('url');
        if (encodedOriginal) {
          originalUrl = decodeURIComponent(encodedOriginal);
        }
      }
      
      // Charger l'image haute rÃ©solution SEULEMENT maintenant
      enlargedImg.src = originalUrl;
      enlargedImg.removeAttribute('data-src');
      
      // Supprimer les classes de lazy loading qui pourraient interfÃ©rer
      enlargedImg.classList.remove('lazy-load', 'lazy-loaded');
      
      enlargedImg.style.cssText = `
        max-width: 90vw;
        max-height: 90vh;
        width: auto;
        height: auto;
        object-fit: contain;
        border: 3px solid var(--gold);
        border-radius: 8px;
        background: white;
        box-shadow: 0 20px 60px rgba(0,0,0,.8), 0 0 20px rgba(212,175,55,.3);
        cursor: zoom-out;
        opacity: 1;
        transition: none;
      `;
      
      modal.appendChild(enlargedImg);
      document.body.appendChild(modal);
      
      // Fermer au clic et au touch pour mobile
      modal.onclick = () => this.closeEnlargedImage();
      modal.addEventListener('touchend', (e) => {
        if (e.target === modal) {
          e.preventDefault();
          this.closeEnlargedImage();
        }
      });
      
      // Fermer avec Ã‰chap
      const escapeHandler = (e) => {
        if (e.key === 'Escape') {
          this.closeEnlargedImage();
          document.removeEventListener('keydown', escapeHandler);
        }
      };
      document.addEventListener('keydown', escapeHandler);
      
      // Marquer l'image originale comme agrandie
      img.classList.add('enlarged');
    },

    closeEnlargedImage() {
      const modal = document.getElementById('image-enlargement-modal');
      if (modal) {
        modal.remove();
      }
      
      // Retirer la classe de toutes les images
      document.querySelectorAll('img.enlarged').forEach(img => {
        img.classList.remove('enlarged');
      });
      
      // Nettoyer les anciens backdrops
      const oldBackdrop = document.querySelector('.image-backdrop');
      if (oldBackdrop) {
        oldBackdrop.remove();
      }
    },


    saveChangesToStorage() {
      try {
        localStorage.setItem('jdr-bab-edits', JSON.stringify(this.editedData));
        localStorage.setItem('jdr-bab-last-modified', Date.now().toString());
        EventBus.emit(Events.STORAGE_SAVE);
      } catch (error) {
        // Failed to save changes
      }
    },

    forceCollectAllEdits() {
      // Collect page description edits before general edits
      this.collectPageDescriptionEdits();
      UnifiedEditor.saveAllEdits();
      return this.editedData;
    },

    collectPageDescriptionEdits() {
      // Check for edited table tresor page description
      const tablesTresorsDesc = document.querySelector('[data-section-type="table-tresor-category-description"] .editable');
      if (tablesTresorsDesc && tablesTresorsDesc.innerHTML) {
        const content = tablesTresorsDesc.innerHTML.trim();
        if (content && content !== "Tables de butin permettant de gÃ©nÃ©rer alÃ©atoirement des rÃ©compenses selon les fourchettes dÃ©finies. Lancez un dÃ© 20 et consultez la table correspondante pour dÃ©terminer l'objet obtenu.") {
          if (!window.TABLES_TRESORS_PAGE_DESC) {
            window.TABLES_TRESORS_PAGE_DESC = {};
          }
          window.TABLES_TRESORS_PAGE_DESC.description = content;
        }
      }

      // Check for edited monster page description
      const monstersDesc = document.querySelector('[data-section-type="monster-category-description"] .editable');
      if (monstersDesc && monstersDesc.innerHTML) {
        const content = monstersDesc.innerHTML.trim();
        if (content && content !== "CrÃ©atures, ennemis et adversaires que peuvent affronter les hÃ©ros dans leurs aventures.") {
          if (!window.MONSTRES_PAGE_DESC) {
            window.MONSTRES_PAGE_DESC = {};
          }
          window.MONSTRES_PAGE_DESC.description = content;
        }
      }
    },


    saveAllEdits() {
      return UnifiedEditor.saveAllEdits();
    },

    regenerateCurrentPage() {
      // Force regeneration of only the current page content (not all pages)
      if (JdrApp.modules.renderer && JdrApp.modules.renderer.regenerateCurrentPage) {
        JdrApp.modules.renderer.regenerateCurrentPage();
      }
    },

    initializeDevToolbox(devToolbox) {
      // Check if toolbox already has content and preserve it
      const existingContent = devToolbox.querySelector('.dev-toolbox-content');
      if (existingContent) {
        // Toolbox already initialized, don't override
        return;
      }

      // Store any existing content that might be there from other modules
      const existingHTML = devToolbox.innerHTML.trim();
      const hasExistingContent = existingHTML && 
        existingHTML !== '<!-- Dev toolbox content will be injected here -->' && 
        existingHTML !== '';

      // If there was existing content, preserve it without adding treasure tools
      if (hasExistingContent) {
        // Keep existing content as-is, don't add our tools
        return;
      } else {
        // Toolbox is empty, don't initialize anything for now
        // This keeps the toolbox clean as requested
        devToolbox.innerHTML = '<!-- Dev toolbox: tools removed as requested -->';
      }
    },

    setupDevToolboxEventListeners() {
      // No toolbox event listeners needed for now
      // Toolbox tools have been removed as requested
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - UI UTILITIES MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // UI UTILITIES - HELPER FUNCTIONS
  // ========================================
  window.UIUtilities = {
    /**
     * Remove HTML tags from text content
     */
    stripHtml(html) {
      const tmp = document.createElement('div');
      tmp.innerHTML = html || '';
      return tmp.textContent || tmp.innerText || '';
    },

    /**
     * Get optimized color for element type
     */
    getElementColor(element) {
      // Couleurs optimisÃ©es pour la lisibilitÃ© sur fond clair et foncÃ©
      const colorMap = {
        'Feu': '#e25822',        // Rouge-orange vif
        'Eau': '#2563eb',        // Bleu vif
        'Terre': '#92400e',      // Marron foncÃ©
        'Air': '#059669',        // Vert Ã©meraude
        'LumiÃ¨re': '#d97706',    // Orange dorÃ© (au lieu du jaune pÃ¢le)
        'Nuit': '#6b21a8',       // Violet foncÃ© (au lieu du noir)
        'Divin': '#7c2d12',      // Marron dorÃ© (au lieu du blanc)
        'MalÃ©fique': '#7c3aed'   // Violet intense
      };
      
      return colorMap[element] || '#666666';
    },

    /**
     * Get icon for element type
     */
    getElementIcon(element) {
      const icons = window.ElementIcons || {};
      return icons[element] || 'âš¡';
    },

    /**
     * Copy text to clipboard with notification
     */
    copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        this.showNotification('ğŸ“‹ CopiÃ© dans le presse-papiers', 'success');
      }).catch(() => {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        this.showNotification('ğŸ“‹ CopiÃ© dans le presse-papiers', 'success');
      });
    },

    /**
     * Show notification message
     */
    showNotification(message, type = 'info') {
      EventBus.emit(Events.NOTIFICATION_SHOW, { message, type });
      
      // Fallback notification if storage module is not available
      if (!JdrApp.modules.storage?.showNotification) {
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: ${type === 'success' ? '#10B981' : type === 'error' ? '#EF4444' : '#3B82F6'};
          color: white;
          padding: 12px 16px;
          border-radius: 8px;
          font-weight: 500;
          z-index: 10000;
          animation: slideIn 0.3s ease;
        `;
        
        notification.textContent = message;
        document.body.appendChild(notification);
        
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 3000);
      } else {
        JdrApp.modules.storage.showNotification(message, type);
      }
    },

    /**
     * Get current page ID from DOM
     */
    getCurrentPageId() {
      // Find the currently visible article (not hidden)
      const articles = document.querySelectorAll('article[data-static-page="true"]');
      let visibleArticle = null;
      
      for (const article of articles) {
        const style = window.getComputedStyle(article);
        if (style.display !== 'none' && style.visibility !== 'hidden') {
          visibleArticle = article;
          break;
        }
      }
      
      // Fallback: check if main content area exists and extract from URL or DOM
      if (!visibleArticle) {
        const hash = window.location.hash.substring(1);
        if (hash.startsWith('/')) {
          return hash.substring(1) || 'creation';
        }
        return 'creation';
      }
      
      return visibleArticle.id || 'creation';
    },

    /**
     * Force page refresh via router
     */
    forcePageRefresh() {
      // Trigger router to completely rebuild the page
      if (JdrApp.modules?.router?.handleRoute) {
        JdrApp.modules.router.handleRoute();
      } else {
        // Fallback: reload the page
        window.location.reload();
      }
    },

    /**
     * Trigger data save to localStorage/persistent storage
     */
    triggerDataSave() {
      EventBus.emit(Events.STORAGE_SAVE);
    },

    /**
     * Extract content type from CSS class name
     */
    extractTypeFromClass(className) {
      const matches = className.match(/(spell|don|objet|monster|tableTresor|class)-/);
      return matches ? matches[1] : null;
    },

    /**
     * Refresh specific page types
     */
    refreshObjectsPage() {
      if (window.location.hash === '#/objets') {
        this.forcePageRefresh();
      }
    },

    refreshMonstersPage() {
      if (window.location.hash === '#/monstres') {
        this.forcePageRefresh();
      }
    },

    refreshTablesPage() {
      if (window.location.hash === '#/tables-tresors') {
        this.forcePageRefresh();
      }
    },

    /**
     * Generate unique readable ID for new elements
     */
    generateUniqueId(prefix = 'element') {
      const timestamp = Date.now();
      const random = Math.random().toString(36).substring(2, 8);
      return `${prefix}-${timestamp}-${random}`;
    },

    /**
     * Slugify text for URL-safe IDs
     */
    slugify(text) {
      return text.toLowerCase()
        .replace(/[Ã Ã¡Ã¢Ã£Ã¤Ã¥]/g, 'a')
        .replace(/[Ã¨Ã©ÃªÃ«]/g, 'e')
        .replace(/[Ã¬Ã­Ã®Ã¯]/g, 'i')
        .replace(/[Ã²Ã³Ã´ÃµÃ¶]/g, 'o')
        .replace(/[Ã¹ÃºÃ»Ã¼]/g, 'u')
        .replace(/[Ã½Ã¿]/g, 'y')
        .replace(/[Ã±]/g, 'n')
        .replace(/[Ã§]/g, 'c')
        .replace(/[^a-z0-9]/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '');
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - BASE MODAL CLASS
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // BASE MODAL - GENERIC MODAL MANAGEMENT
  // ========================================
  window.BaseModal = {
    /**
     * Initialize modal system event listeners
     */
    init() {
      this.setupModalEventListeners();
    },

    /**
     * Setup global modal event listeners
     */
    setupModalEventListeners() {
      // Close modal on overlay click or close button
      JdrApp.utils.events.register('click', '.modal-overlay, .modal-close', (e) => {
        const modal = e.target.closest('.modal') || document.querySelector('.modal.visible');
        if (modal) {
          this.closeModal(modal);
        }
      });

      // Prevent modal content clicks from closing modal
      JdrApp.utils.events.register('click', '.modal-content', (e) => {
        e.stopPropagation();
      });

      // Close modal on Escape key
      JdrApp.utils.events.register('keydown', 'body', (e) => {
        if (e.key === 'Escape') {
          const openModal = document.querySelector('.modal.visible');
          if (openModal) {
            this.closeModal(openModal);
          }
        }
      });

      // EventBus integration
      EventBus.on(Events.MODAL_OPEN, (payload) => {
        this.openModal(payload.modalId);
      });

      EventBus.on(Events.MODAL_CLOSE, (payload) => {
        const modal = payload.modal || document.querySelector('.modal.visible');
        if (modal) {
          this.closeModal(modal);
        }
      });
    },

    /**
     * Create a generic modal with common structure
     */
    createModal(id, title, content, options = {}) {
      const modal = document.createElement('div');
      modal.id = id;
      modal.className = 'modal';
      modal.style.display = 'none';

      const isDialog = options.useDialog !== false;
      
      if (isDialog) {
        modal.innerHTML = `
          <div class="modal-overlay">
            <div class="modal-content">
              <div class="modal-header">
                <h3>${title}</h3>
                <button class="modal-close" type="button">âœ•</button>
              </div>
              <div class="modal-body">
                ${content}
              </div>
              ${options.footer ? `<div class="modal-footer">${options.footer}</div>` : ''}
            </div>
          </div>
        `;
      } else {
        // For dialog elements
        modal.innerHTML = `
          <div class="modal-header">
            <h3>${title}</h3>
            <button class="modal-close" type="button">âœ•</button>
          </div>
          <div class="modal-body">
            ${content}
          </div>
          ${options.footer ? `<div class="modal-footer">${options.footer}</div>` : ''}
        `;
      }

      return modal;
    },

    /**
     * Open modal by ID or element
     */
    openModal(modalId) {
      const modal = typeof modalId === 'string' 
        ? JdrApp.utils.dom.$(`#${modalId}`) 
        : modalId;
        
      if (modal) {
        if (modal.tagName === 'DIALOG') {
          modal.showModal();
        } else {
          modal.classList.add('visible');
          modal.style.display = 'flex';
        }
        
        // Focus first input element
        const firstInput = modal.querySelector('input, textarea, select');
        if (firstInput) {
          setTimeout(() => firstInput.focus(), 100);
        }

        // Emit event
        EventBus.emit(Events.MODAL_OPENED, { modal, modalId });
      }
    },

    /**
     * Close modal
     */
    closeModal(modal) {
      if (modal) {
        if (modal.tagName === 'DIALOG') {
          modal.close();
        } else {
          modal.classList.remove('visible');
          modal.style.display = 'none';
        }
        
        // Reset form if present
        const form = modal.querySelector('form');
        if (form) {
          form.reset();
        }

        // Emit event
        EventBus.emit(Events.MODAL_CLOSED, { modal });
      }
    },

    /**
     * Remove modal from DOM
     */
    destroyModal(modalId) {
      const modal = typeof modalId === 'string' 
        ? JdrApp.utils.dom.$(`#${modalId}`) 
        : modalId;
        
      if (modal) {
        this.closeModal(modal);
        if (modal.parentNode) {
          modal.parentNode.removeChild(modal);
        }
      }
    },

    /**
     * Show confirmation dialog
     */
    showConfirmation(message, title = 'Confirmation', onConfirm = null, onCancel = null) {
      const modalId = 'confirmationModal';
      
      // Remove existing confirmation modal
      this.destroyModal(modalId);

      const content = `
        <p style="margin-bottom: 20px;">${message}</p>
      `;

      const footer = `
        <button type="button" class="btn btn-secondary" id="cancelBtn">Annuler</button>
        <button type="button" class="btn btn-danger" id="confirmBtn">Confirmer</button>
      `;

      const modal = this.createModal(modalId, title, content, { footer });
      document.body.appendChild(modal);

      // Setup button handlers
      const confirmBtn = modal.querySelector('#confirmBtn');
      const cancelBtn = modal.querySelector('#cancelBtn');

      const handleConfirm = () => {
        if (onConfirm) onConfirm();
        this.closeModal(modal);
        this.destroyModal(modal);
      };

      const handleCancel = () => {
        if (onCancel) onCancel();
        this.closeModal(modal);
        this.destroyModal(modal);
      };

      confirmBtn.addEventListener('click', handleConfirm);
      cancelBtn.addEventListener('click', handleCancel);

      this.openModal(modalId);
      
      return modal;
    },

    /**
     * Show input dialog
     */
    showInput(message, title = 'Saisie', defaultValue = '', onSubmit = null, onCancel = null) {
      const modalId = 'inputModal';
      
      // Remove existing input modal
      this.destroyModal(modalId);

      const content = `
        <label style="display: block; margin-bottom: 10px;">${message}</label>
        <input type="text" id="inputValue" value="${defaultValue}" style="width: 100%; padding: 8px; margin-bottom: 20px;" />
      `;

      const footer = `
        <button type="button" class="btn btn-secondary" id="cancelBtn">Annuler</button>
        <button type="button" class="btn btn-primary" id="submitBtn">Valider</button>
      `;

      const modal = this.createModal(modalId, title, content, { footer });
      document.body.appendChild(modal);

      const inputElement = modal.querySelector('#inputValue');
      const submitBtn = modal.querySelector('#submitBtn');
      const cancelBtn = modal.querySelector('#cancelBtn');

      const handleSubmit = () => {
        const value = inputElement.value.trim();
        if (onSubmit) onSubmit(value);
        this.closeModal(modal);
        this.destroyModal(modal);
      };

      const handleCancel = () => {
        if (onCancel) onCancel();
        this.closeModal(modal);
        this.destroyModal(modal);
      };

      submitBtn.addEventListener('click', handleSubmit);
      cancelBtn.addEventListener('click', handleCancel);
      
      inputElement.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          handleSubmit();
        }
      });

      this.openModal(modalId);
      inputElement.focus();
      inputElement.select();
      
      return modal;
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - UI CORE MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // UI CORE - INITIALIZATION AND MAIN SETUP
  // ========================================
  window.UICore = {
    _initialized: false,

    /**
     * Initialize UI system - called once at startup
     */
    init() {
      // Prevent multiple initialization to avoid duplicate event listeners
      if (this._initialized) {
        return;
      }
      
      this.setupEventListeners();
      this.setupSearch();
      this.setupModals();
      this.setupResponsive();
      this.setupNewPageHandler();
      this._initialized = true;
      
    },

    /**
     * Setup main EventBus listeners
     */
    setupEventListeners() {
      // Content management via EventBus
      EventBus.on(Events.CONTENT_ADD, (payload) => {
        this.handleContentAdd(payload.type, payload.category, payload.item);
      });

      EventBus.on(Events.CONTENT_DELETE, (payload) => {
        this.handleContentDelete(payload.type, payload.category, payload.item);
      });

      EventBus.on(Events.CONTENT_MOVE, (payload) => {
        this.handleContentMove(payload.type, payload.category, payload.itemName, payload.direction);
      });

      // Delegate UI event handlers to specialized modules
      if (window.EventHandlers) {
        EventHandlers.setupContentHandlers();
        EventHandlers.setupTagsManagement();
      }
    },

    /**
     * Setup search functionality
     */
    setupSearch() {
      const searchInput = JdrApp.utils.dom.$('#search');
      const clearButton = JdrApp.utils.dom.$('#clear');
      
      if (searchInput) {
        // Only search on Enter key press
        JdrApp.utils.events.register('keydown', '#search', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            const query = e.target.value.trim();
            if (query.length > 0) {
              this.performSearch(query);
            } else {
              this.clearMainSearchResults();
            }
          } else if (e.key === 'Escape') {
            this.clearMainSearchResults();
            e.target.value = '';
            e.target.blur();
          }
        });
      }
      
      if (clearButton) {
        JdrApp.utils.events.register('click', '#clear', () => {
          if (searchInput) {
            searchInput.value = '';
            this.clearMainSearchResults();
          }
        });
      }
    },

    /**
     * Setup modal system
     */
    setupModals() {
      // Utilise BaseModal pour la gestion gÃ©nÃ©rique des modales
      BaseModal.init();

      // Resource tools
      JdrApp.utils.events.register('click', '#elementsBtn', () => {
        this.showElementsModal();
      });

      JdrApp.utils.events.register('click', '#etatsBtn', () => {
        this.showEtatsModal();
      });

      JdrApp.utils.events.register('click', '#spellLinksBtn', () => {
        this.showSpellLinksModal();
      });

      JdrApp.utils.events.register('click', '#pageLinksBtn', () => {
        this.showPageLinksModal();
      });

      JdrApp.utils.events.register('click', '#monsterLinksBtn', () => {
        this.showMonsterLinksModal();
      });

      // Gestionnaire pour les liens de sorts dans le contenu
      JdrApp.utils.events.register('click', '.spell-link', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const spellName = e.target.dataset.spell;
        const categoryName = e.target.dataset.category;
        this.showSpellPreview(spellName, categoryName, e.target);
      });

      // Gestionnaire pour les liens d'Ã©tats dans le contenu
      JdrApp.utils.events.register('click', '.etat-link', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const etatName = e.target.dataset.etat;
        
        // RÃ©cupÃ©rer dynamiquement la description depuis les donnÃ©es statiques
        let etatDescription = '';
        if (window.STATIC_PAGES?.etats?.sections) {
          const etatSection = window.STATIC_PAGES.etats.sections.find(section => 
            section.type === 'card' && section.title === etatName
          );
          if (etatSection) {
            // Convertir le HTML en texte propre
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = etatSection.content;
            tempDiv.innerHTML = tempDiv.innerHTML
              .replace(/<\/p>/gi, '\n')
              .replace(/<br\s*\/?>/gi, '\n')
              .replace(/<\/li>/gi, '\n')
              .replace(/<\/div>/gi, '\n');
            etatDescription = (tempDiv.textContent || tempDiv.innerText || etatSection.content)
              .replace(/\n\s*\n/g, '\n')
              .trim();
          }
        }
        
        this.showEtatPreview(etatName, etatDescription, e.target);
      });

      // Gestionnaire pour les liens de monstres dans le contenu
      JdrApp.utils.events.register('click', '.monster-link', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const monsterName = e.target.dataset.monster;
        this.showMonsterPreview(monsterName, e.target, e);
      });
    },

    /**
     * Setup responsive design
     */
    setupResponsive() {
      this.setupMobileNavigation();
      this.setupLegacyResponsive();
    },

    /**
     * Setup new page creation handler
     */
    setupNewPageHandler() {
      // Setup section selection modal for new page creation
      JdrApp.utils.events.register('click', '.new-page-button', (e) => {
        this.showSectionSelectionModal();
      });
    },

    /**
     * Content event handlers - delegated from EventBus
     */
    handleContentAdd(type, category, item) {
      // Additional handling after content is added
      setTimeout(() => {
        if (JdrApp.modules.renderer?.autoLoadImages) {
          JdrApp.modules.renderer.autoLoadImages();
        }
      }, 100);
    },

    handleContentDelete(type, category, item) {
      // Cleanup after content deletion
    },

    handleContentMove(type, category, itemName, direction) {
      // Additional handling after content is moved
    },

    /**
     * Delegate method calls to appropriate modules
     */
    performSearch(query) {
      if (window.SearchManager) {
        return SearchManager.performSearch(query);
      }
      // Fallback to ui.js method if SearchManager not available yet
      if (JdrApp.modules.ui?.performSearch) {
        return JdrApp.modules.ui.performSearch(query);
      }
    },

    clearMainSearchResults() {
      if (window.SearchManager) {
        return SearchManager.clearMainSearchResults();
      }
      // Fallback to ui.js method
      if (JdrApp.modules.ui?.clearMainSearchResults) {
        return JdrApp.modules.ui.clearMainSearchResults();
      }
    },

    // Modal methods - delegate to ModalManager
    showElementsModal() {
      if (window.ModalManager) {
        return ModalManager.showElementsModal();
      }
      if (JdrApp.modules.ui?.showElementsModal) {
        return JdrApp.modules.ui.showElementsModal();
      }
    },

    showEtatsModal() {
      if (window.ModalManager) {
        return ModalManager.showEtatsModal();
      }
      if (JdrApp.modules.ui?.showEtatsModal) {
        return JdrApp.modules.ui.showEtatsModal();
      }
    },

    showSpellLinksModal() {
      if (window.ModalManager) {
        return ModalManager.showSpellLinksModal();
      }
      if (JdrApp.modules.ui?.showSpellLinksModal) {
        return JdrApp.modules.ui.showSpellLinksModal();
      }
    },

    showPageLinksModal() {
      if (window.ModalManager) {
        return ModalManager.showPageLinksModal();
      }
      if (JdrApp.modules.ui?.showPageLinksModal) {
        return JdrApp.modules.ui.showPageLinksModal();
      }
    },

    showMonsterLinksModal() {
      if (window.ModalManager) {
        return ModalManager.showMonsterLinksModal();
      }
      if (JdrApp.modules.ui?.showMonsterLinksModal) {
        return JdrApp.modules.ui.showMonsterLinksModal();
      }
    },

    showSpellPreview(spellName, categoryName, triggerElement) {
      if (JdrApp.modules.ui?.showSpellPreview) {
        return JdrApp.modules.ui.showSpellPreview(spellName, categoryName, triggerElement);
      }
    },

    showEtatPreview(etatName, etatDescription, triggerElement) {
      if (JdrApp.modules.ui?.showEtatPreview) {
        return JdrApp.modules.ui.showEtatPreview(etatName, etatDescription, triggerElement);
      }
    },

    showMonsterPreview(monsterName, triggerElement, event) {
      if (JdrApp.modules.ui?.showMonsterPreview) {
        return JdrApp.modules.ui.showMonsterPreview(monsterName, triggerElement, event);
      }
    },

    setupMobileNavigation() {
      if (window.ResponsiveManager) {
        return ResponsiveManager.setupMobileNavigation();
      }
      if (JdrApp.modules.ui?.setupMobileNavigation) {
        return JdrApp.modules.ui.setupMobileNavigation();
      }
    },

    setupLegacyResponsive() {
      if (window.ResponsiveManager) {
        return ResponsiveManager.setupLegacyResponsive();
      }
      if (JdrApp.modules.ui?.setupLegacyResponsive) {
        return JdrApp.modules.ui.setupLegacyResponsive();
      }
    },

    showSectionSelectionModal() {
      if (window.PageManager) {
        return PageManager.showSectionSelectionModal();
      }
      if (JdrApp.modules.ui?.showSectionSelectionModal) {
        return JdrApp.modules.ui.showSectionSelectionModal();
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - EVENT HANDLERS MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // EVENT HANDLERS - UI EVENT DELEGATION
  // ========================================
  window.EventHandlers = {

    /**
     * Setup content-related event handlers
     */
    setupContentHandlers() {
      // Generic content addition
      JdrApp.utils.events.register('click', '[class$="-add"]', (e) => {
        const type = UIUtilities.extractTypeFromClass(e.target.className);
        const categoryName = e.target.dataset.categoryName;
        
        if (type && categoryName) {
          this.delegateToUI('addContent', type, categoryName);
        }
      });

      // Generic content deletion - using multiple specific selectors
      JdrApp.utils.events.register('click', '.spell-delete, .don-delete, .delete-subclass-btn, .objet-delete, .monster-delete, .tableTresor-delete', (e) => {
        const type = UIUtilities.extractTypeFromClass(e.target.className);
        const categoryName = e.target.dataset.categoryName;
        
        // Handle different dataset attribute naming patterns
        const itemName = this.extractItemName(e.target, type);
        
        if (type && categoryName && itemName) {
          this.delegateToUI('deleteContent', type, categoryName, itemName);
        }
      });

      // Generic content movement
      JdrApp.utils.events.register('click', '[class*="-move-"]', (e) => {
        const type = UIUtilities.extractTypeFromClass(e.target.className);
        const categoryName = e.target.dataset.categoryName;
        const itemName = this.extractItemName(e.target, type);
        const direction = e.target.className.includes('move-up') ? -1 : 1;
        
        if (type && categoryName && itemName) {
          this.delegateToUI('moveContent', type, categoryName, itemName, direction);
        }
      });

      // Filter manager button for objects
      JdrApp.utils.events.register('click', '.filter-manager-btn', () => {
        this.delegateToUI('showFilterManagementModal');
      });

      // Tags manager button for objects
      JdrApp.utils.events.register('click', '.tags-manager-btn', () => {
        this.delegateToUI('showTagsManagementModal');
      });

      // Filter chip toggle for objects - DISABLED (handled by core.js now)
      // JdrApp.utils.events.register('click', '.filter-chip', (e) => {
      //   e.preventDefault();
      //   e.stopPropagation();
      //   this.delegateToUI('toggleFilter', e.target);
      // });

      // Select all tags button
      JdrApp.utils.events.register('click', '#select-all-tags', () => {
        this.delegateToUI('selectAllTags');
      });

      // Select no tags button
      JdrApp.utils.events.register('click', '#select-no-tags', () => {
        this.delegateToUI('selectNoTags');
      });

      // ID search functionality (only on Enter key or button click)
      JdrApp.utils.events.register('keydown', '#id-search-input', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          this.delegateToUI('performIdSearch', e.target.value);
        } else if (e.key === 'Escape') {
          e.target.value = '';
          this.delegateToUI('clearIdSearch');
        }
      });

      JdrApp.utils.events.register('click', '#clear-id-search', () => {
        this.delegateToUI('clearIdSearch');
      });

      // Spell element change
      JdrApp.utils.events.register('change', '.spell-element-selector select', (e) => {
        this.delegateToUI('updateSpellElement', e.target);
      });

      // Paragraph addition
      JdrApp.utils.events.register('click', '.add-paragraph-btn', (e) => {
        const target = e.target.dataset.target;
        this.delegateToUI('addParagraph', target, e.target);
      });

      // Section deletion for static pages
      JdrApp.utils.events.register('click', '.section-delete', (e) => {
        const sectionName = e.target.dataset.sectionName;
        if (sectionName && confirm(`Supprimer la section "${sectionName}" ?`)) {
          this.delegateToUI('deleteSection', sectionName, e.target);
        }
      });

      // Dev toolbox category creation buttons
      JdrApp.utils.events.register('click', '#addSpellCategory', () => {
        this.delegateToUI('createNewCategory', 'spell');
      });

      JdrApp.utils.events.register('click', '#addDonCategory', () => {
        this.delegateToUI('createNewCategory', 'don');
      });

      // Category deletion buttons
      JdrApp.utils.events.register('click', '[class$="-category-delete"]', (e) => {
        const categoryName = e.target.dataset.categoryName;
        const categoryType = e.target.dataset.categoryType;
        
        if (categoryName && categoryType) {
          this.delegateToUI('deleteCategory', categoryType, categoryName);
        }
      });

      // Print button for states page
      JdrApp.utils.events.register('click', '#print-states', () => {
        window.print();
      });
    },

    /**
     * Setup tags management event handlers
     */
    setupTagsManagement() {
      // Tables de trÃ©sors - Edition des fourchettes
      JdrApp.utils.events.register('click', '.edit-fourchette-btn', (e) => {
        const tableName = e.target.dataset.tableName;
        const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
        
        if (tableName && fourchetteIndex >= 0) {
          this.delegateToUI('editFourchette', tableName, fourchetteIndex);
        }
      });

      // Tables de trÃ©sors - Suppression des fourchettes
      JdrApp.utils.events.register('click', '.delete-fourchette-btn', (e) => {
        const tableName = e.target.dataset.tableName;
        const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
        
        if (tableName && fourchetteIndex >= 0) {
          if (confirm('ÃŠtes-vous sÃ»r de vouloir supprimer cette fourchette ?')) {
            this.delegateToUI('deleteFourchette', tableName, fourchetteIndex);
          }
        }
      });

      // Tables de trÃ©sors - DÃ©placement des fourchettes vers le haut
      JdrApp.utils.events.register('click', '.move-fourchette-up-btn', (e) => {
        const tableName = e.target.dataset.tableName;
        const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
        
        if (tableName && fourchetteIndex > 0) {
          this.delegateToUI('moveFourchette', tableName, fourchetteIndex, fourchetteIndex - 1);
        }
      });

      // Tables de trÃ©sors - DÃ©placement des fourchettes vers le bas
      JdrApp.utils.events.register('click', '.move-fourchette-down-btn', (e) => {
        const tableName = e.target.dataset.tableName;
        const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
        
        if (tableName && fourchetteIndex >= 0) {
          this.delegateToUI('moveFourchette', tableName, fourchetteIndex, fourchetteIndex + 1);
        }
      });

      // Tables de trÃ©sors - Ajout de fourchettes
      JdrApp.utils.events.register('click', '.table-tresor-add-fourchette', (e) => {
        const tableName = e.target.dataset.tableTresorName;
        
        if (tableName) {
          this.delegateToUI('addFourchette', tableName);
        }
      });

      // Tables de trÃ©sors - PrÃ©visualisation des objets (gÃ©rÃ© par TablesTresorsManager)
      // Cette gestion est dÃ©jÃ  dans TablesTresorsManager, pas besoin de duplication
    },

    /**
     * Extract item name from element based on type
     */
    extractItemName(element, type) {
      if (type === 'spell') {
        return element.dataset.spellName;
      } else if (type === 'don') {
        return element.dataset.donName;
      } else if (type === 'objet') {
        return element.dataset.objetName;
      } else if (type === 'monster') {
        return element.dataset.monsterName;
      } else if (type === 'tableTresor') {
        return element.dataset.tableTresorName;
      } else if (type === 'class') {
        return element.dataset.className || element.dataset.subclassName;
      } else {
        return element.dataset[`${type}Name`];
      }
    },

    /**
     * Delegate method calls to UI module
     */
    delegateToUI(methodName, ...args) {
      if (JdrApp.modules.ui && typeof JdrApp.modules.ui[methodName] === 'function') {
        return JdrApp.modules.ui[methodName](...args);
      } else {
        console.warn(`UI method ${methodName} not found or not available yet`);
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - CONTENT MANAGER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // CONTENT MANAGER - CRUD OPERATIONS
  // ========================================
  window.ContentManager = {

    /**
     * Add new content item
     */
    addContent(type, categoryName) {
      const config = window.ContentTypes[type];
      if (!config) {
        UIUtilities.showNotification(`âŒ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Create new item with default values
      const defaultItem = ContentFactory.createDefaultItem(type);
      
      // Special handling for objects and monsters (add to single array)
      if (type === 'objet') {
        this.addObject(defaultItem);
      } else if (type === 'monster') {
        this.addMonster(defaultItem);
      } else {
        // Standard category-based addition
        this.addStandardContent(type, categoryName, defaultItem);
      }
      
      EventBus.emit(Events.STORAGE_SAVE);
      UIUtilities.showNotification(`${config.icons.add} Nouvel Ã©lÃ©ment ajoutÃ©`, 'success');
    },

    /**
     * Add object to objects array
     */
    addObject(defaultItem) {
      if (!window.OBJETS.objets) {
        window.OBJETS.objets = [];
      }
      
      // Get next number
      const existingNumbers = window.OBJETS.objets.map(obj => obj.numero || 0);
      const nextNumber = existingNumbers.length > 0 ? Math.max(...existingNumbers) + 1 : 1;
      defaultItem.numero = nextNumber;
      
      window.OBJETS.objets.push(defaultItem);
      UIUtilities.refreshObjectsPage();
    },

    /**
     * Add monster to monsters array
     */
    addMonster(defaultItem) {
      if (!window.MONSTRES) {
        window.MONSTRES = [];
      }
      
      window.MONSTRES.push(defaultItem);
      UIUtilities.refreshMonstersPage();
    },

    /**
     * Add content using standard category-based approach
     */
    addStandardContent(type, categoryName, defaultItem) {
      const success = ContentFactory.addItem(type, categoryName, defaultItem);
      if (success) {
        EventBus.emit(Events.CONTENT_ADD, {
          type: type,
          category: categoryName,
          item: defaultItem
        });
        
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: type,
          category: ContentFactory.getEntity(type).findCategory(categoryName)
        });
      }
    },

    /**
     * Delete content item
     */
    deleteContent(type, categoryName, itemName) {
      const config = window.ContentTypes[type];
      if (!config) {
        UIUtilities.showNotification(`âŒ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      if (!confirm(`Supprimer "${itemName}" ?`)) {
        return;
      }

      // Special handling for objects and monsters
      if (type === 'objet') {
        this.deleteObject(itemName);
      } else if (type === 'monster') {
        this.deleteMonster(itemName);
      } else {
        // Standard category-based deletion
        this.deleteStandardContent(type, categoryName, itemName);
      }
      
      EventBus.emit(Events.STORAGE_SAVE);
      UIUtilities.showNotification(`${config.icons.delete} "${itemName}" supprimÃ©`, 'success');
    },

    /**
     * Delete object from objects array
     */
    deleteObject(itemName) {
      if (window.OBJETS?.objets) {
        const itemIndex = window.OBJETS.objets.findIndex(obj => obj.nom === itemName);
        if (itemIndex >= 0) {
          window.OBJETS.objets.splice(itemIndex, 1);
          UIUtilities.refreshObjectsPage();
        }
      }
    },

    /**
     * Delete monster from monsters array
     */
    deleteMonster(itemName) {
      if (window.MONSTRES) {
        const itemIndex = window.MONSTRES.findIndex(monster => monster.nom === itemName);
        if (itemIndex >= 0) {
          window.MONSTRES.splice(itemIndex, 1);
          UIUtilities.refreshMonstersPage();
        }
      }
    },

    /**
     * Delete content using standard category-based approach
     */
    deleteStandardContent(type, categoryName, itemName) {
      const success = ContentFactory.deleteItem(type, categoryName, itemName);
      if (success) {
        EventBus.emit(Events.CONTENT_DELETE, {
          type: type,
          category: categoryName,
          item: itemName
        });
        
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: type,
          category: ContentFactory.getEntity(type).findCategory(categoryName)
        });
      }
    },

    /**
     * Move content item
     */
    moveContent(type, categoryName, itemName, direction) {
      const config = window.ContentTypes[type];
      if (!config) {
        UIUtilities.showNotification(`âŒ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Special handling for objects
      if (type === 'objet') {
        this.moveObject(itemName, direction);
      } else {
        // Standard category-based movement
        this.moveStandardContent(type, categoryName, itemName, direction);
      }
      
      EventBus.emit(Events.STORAGE_SAVE);
      const directionText = direction > 0 ? 'descendu' : 'montÃ©';
      UIUtilities.showNotification(`ğŸ”„ "${itemName}" ${directionText}`, 'success');
    },

    /**
     * Move object in objects array
     */
    moveObject(itemName, direction) {
      if (window.OBJETS?.objets) {
        const itemIndex = window.OBJETS.objets.findIndex(obj => obj.nom === itemName);
        if (itemIndex >= 0) {
          const newIndex = itemIndex + direction;
          if (newIndex >= 0 && newIndex < window.OBJETS.objets.length) {
            const item = window.OBJETS.objets.splice(itemIndex, 1)[0];
            window.OBJETS.objets.splice(newIndex, 0, item);
            UIUtilities.refreshObjectsPage();
          }
        }
      }
    },

    /**
     * Move content using standard category-based approach
     */
    moveStandardContent(type, categoryName, itemName, direction) {
      const success = ContentFactory.moveItem(type, categoryName, itemName, direction);
      if (success) {
        EventBus.emit(Events.CONTENT_MOVE, {
          type: type,
          category: categoryName,
          itemName: itemName,
          direction: direction
        });
        
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: type,
          category: ContentFactory.getEntity(type).findCategory(categoryName)
        });
      }
    },

    /**
     * Handle content addition post-processing
     */
    handleContentAdd(type, category, item) {
      // Additional handling after content is added
      setTimeout(() => {
        if (JdrApp.modules.renderer?.autoLoadImages) {
          JdrApp.modules.renderer.autoLoadImages();
        }
      }, 100);
    },

    /**
     * Handle content deletion post-processing
     */
    handleContentDelete(type, category, item) {
      // Cleanup after content deletion
    },

    /**
     * Handle content movement post-processing
     */
    handleContentMove(type, category, itemName, direction) {
      // Additional handling after content is moved
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - TAGS MANAGER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // TAGS MANAGER - TAG MANAGEMENT FOR MONSTERS AND TREASURES
  // ========================================
  window.TagsManager = {

    /**
     * Show tags management modal based on content type
     */
    showTagsManagementModal() {
      // DÃ©terminer le type de contenu basÃ© sur la page actuelle
      const currentPage = window.location.hash.replace('#/', '') || 'creation';
      let contentType = 'objet'; // par dÃ©faut
      
      if (currentPage === 'monstres') {
        contentType = 'monster';
      } else if (currentPage === 'tables-tresors') {
        contentType = 'tableTresor';
      }

      if (contentType === 'monster') {
        this.showMonsterTagsManagement();
      } else if (contentType === 'tableTresor') {
        this.showTableTresorTagsManagement();
      } else {
        // For objects (legacy support)
        this.showGeneralTagsManagement();
      }
    },

    /**
     * Show monster tags management modal
     */
    showMonsterTagsManagement() {
      const config = window.ContentTypes.monster;
      if (!config || !config.filterConfig) {
        UIUtilities.showNotification('Configuration des tags monstres non trouvÃ©e', 'error');
        return;
      }

      // Remove existing modal if any
      const existingModal = document.querySelector('#monsterTagsModal');
      if (existingModal) {
        existingModal.remove();
      }

      const availableTags = config.filterConfig.availableTags || [];
      const modal = this.createMonsterTagsModal(availableTags);
      document.body.appendChild(modal);
      
      // Use native dialog showModal for proper z-index
      modal.showModal();
    },

    /**
     * Show table tresor tags management modal
     */
    showTableTresorTagsManagement() {
      // Priority: Load tags from metadata, then config, then fallback
      let availableTags = [];
      
      if (window.TABLES_TRESORS?._metadata?.availableTags) {
        availableTags = window.TABLES_TRESORS._metadata.availableTags;
      } else {
        // Initialize metadata if missing
        availableTags = ['ForÃªt', 'Boss', 'Coffre'];
        if (window.TABLES_TRESORS) {
          if (!window.TABLES_TRESORS._metadata) {
            window.TABLES_TRESORS._metadata = {};
          }
          window.TABLES_TRESORS._metadata.availableTags = [...availableTags];
        }
      }

      // Remove existing modal if any
      const existingModal = document.querySelector('#tableTresorTagsModal');
      if (existingModal) {
        existingModal.remove();
      }
      
      const modal = this.createTableTresorTagsModal(availableTags);
      document.body.appendChild(modal);
      modal.showModal();
    },

    /**
     * Show general tags management for objects
     */
    showGeneralTagsManagement() {
      // Delegate to ui.js for now (will be extracted in Phase 4)
      if (JdrApp.modules.ui?.showTagsManagementModal) {
        return JdrApp.modules.ui.showTagsManagementModal();
      }
    },

    /**
     * Create monster tags modal
     */
    createMonsterTagsModal(availableTags) {
      const modal = document.createElement('dialog');
      modal.id = 'monsterTagsModal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        padding: 20px;
        border: none;
        border-radius: 12px;
        background: var(--background);
        color: var(--text);
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      `;

      modal.innerHTML = `
        <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
          <h3 style="margin: 0; color: var(--accent);">ğŸ·ï¸ Gestion des Tags - Monstres</h3>
          <button class="modal-close" style="background: none; border: none; font-size: 20px; cursor: pointer; color: var(--text);">âœ•</button>
        </div>
        
        <div class="modal-body">
          <div style="margin-bottom: 20px;">
            <h4>Tags Disponibles:</h4>
            <div id="availableTagsList" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px;">
              ${availableTags.map(tag => `
                <span class="tag-item" style="background: var(--accent-dark); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; display: flex; align-items: center; gap: 4px;">
                  ${tag}
                  <button class="delete-tag-btn" data-tag="${tag}" style="background: none; border: none; color: white; cursor: pointer; font-size: 14px;">ğŸ—‘ï¸</button>
                </span>
              `).join('')}
            </div>
            
            <div style="display: flex; gap: 8px; align-items: center;">
              <input type="text" id="newMonsterTag" placeholder="Nouveau tag..." style="flex: 1; padding: 8px; border: 1px solid var(--border); border-radius: 4px;">
              <button id="addMonsterTagBtn" style="background: var(--accent); color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Ajouter</button>
            </div>
          </div>
        </div>
      `;

      this.setupMonsterTagsModalEvents(modal, availableTags);
      return modal;
    },

    /**
     * Create table tresor tags modal
     */
    createTableTresorTagsModal(availableTags) {
      const modal = document.createElement('dialog');
      modal.id = 'tableTresorTagsModal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        padding: 20px;
        border: none;
        border-radius: 12px;
        background: var(--background);
        color: var(--text);
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      `;

      modal.innerHTML = `
        <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
          <h3 style="margin: 0; color: var(--accent);">ğŸ·ï¸ Gestion des Tags - Tables de TrÃ©sors</h3>
          <button class="modal-close-btn" style="background: none; border: none; font-size: 20px; cursor: pointer; color: var(--text);">âœ•</button>
        </div>
        
        <div class="modal-body">
          <div style="margin-bottom: 20px;">
            <h4>Tags Disponibles:</h4>
            <div id="availableTagsList" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px;">
              ${availableTags.map(tag => `
                <span class="tag-item" style="background: var(--accent-dark); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; display: flex; align-items: center; gap: 4px;">
                  ${tag}
                  <button class="delete-tag-btn" data-tag="${tag}" style="background: none; border: none; color: white; cursor: pointer; font-size: 14px;">ğŸ—‘ï¸</button>
                </span>
              `).join('')}
            </div>
            
            <div style="display: flex; gap: 8px; align-items: center;">
              <input type="text" id="newTableTresorTag" placeholder="Nouveau tag..." style="flex: 1; padding: 8px; border: 1px solid var(--border); border-radius: 4px;">
              <button id="addTableTresorTagBtn" style="background: var(--accent); color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Ajouter</button>
            </div>
          </div>
        </div>
      `;

      this.setupTableTresorTagsModalEvents(modal, availableTags);
      return modal;
    },

    /**
     * Setup monster tags modal events
     */
    setupMonsterTagsModalEvents(modal, availableTags) {
      // Close modal
      modal.querySelector('.modal-close').addEventListener('click', () => {
        modal.close();
      });

      // Add new tag
      const addTag = () => {
        const newTagInput = modal.querySelector('#newMonsterTag');
        const newTag = newTagInput.value.trim();
        
        if (newTag && !availableTags.includes(newTag)) {
          // Add to the current available tags
          availableTags.push(newTag);
          
          // Save to the config
          const config = window.ContentTypes.monster;
          config.filterConfig.availableTags = [...availableTags];
          
          // Save changes to storage
          EventBus.emit(Events.STORAGE_SAVE);
          
          modal.close();
          this.showMonsterTagsManagement(); // Refresh modal
          UIUtilities.showNotification(`Tag "${newTag}" ajoutÃ© avec succÃ¨s`, 'success');
        } else if (newTag && availableTags.includes(newTag)) {
          UIUtilities.showNotification('Ce tag existe dÃ©jÃ ', 'error');
        }
      };

      const addBtn = modal.querySelector('#addMonsterTagBtn');
      const newTagInput = modal.querySelector('#newMonsterTag');

      addBtn.addEventListener('click', addTag);
      newTagInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          addTag();
        }
      });

      // Delete tag buttons using event delegation
      modal.addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-tag-btn')) {
          const tagToDelete = e.target.dataset.tag;
          
          if (confirm(`Supprimer le tag "${tagToDelete}" ?`)) {
            const config = window.ContentTypes.monster;
            const index = config.filterConfig.availableTags.indexOf(tagToDelete);
            
            if (index > -1) {
              // Remove from available tags
              config.filterConfig.availableTags.splice(index, 1);
              
              // Remove the tag from all monsters
              if (window.MONSTRES) {
                window.MONSTRES.forEach(monster => {
                  if (monster.tags && monster.tags.includes(tagToDelete)) {
                    monster.tags = monster.tags.filter(tag => tag !== tagToDelete);
                    // Ensure monster has at least one tag if possible
                    if (monster.tags.length === 0 && config.filterConfig.availableTags.length > 0) {
                      monster.tags = [config.filterConfig.availableTags[0]];
                    }
                  }
                });
              }
              
              // Save changes
              EventBus.emit(Events.STORAGE_SAVE);
              
              // Refresh modal and monsters page
              modal.close();
              this.showMonsterTagsManagement();
              
              // Force complete page reload for monsters page
              if (window.location.hash === '#/monstres') {
                UIUtilities.forcePageRefresh();
              }
              
              UIUtilities.showNotification(`âœ… Tag "${tagToDelete}" supprimÃ© avec succÃ¨s`, 'success');
            }
          }
        }
      });
    },

    /**
     * Setup table tresor tags modal events
     */
    setupTableTresorTagsModalEvents(modal, availableTags) {
      // Close modal
      const closeButtons = modal.querySelectorAll('.modal-close-btn');
      closeButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          modal.close();
        });
      });

      // Add new tag
      const addTag = () => {
        const newTagInput = modal.querySelector('#newTableTresorTag');
        const newTag = newTagInput.value.trim();
        
        if (newTag && !availableTags.includes(newTag)) {
          // Add to available tags
          availableTags.push(newTag);
          
          // Save in TABLES_TRESORS metadata for persistence
          if (window.TABLES_TRESORS) {
            if (!window.TABLES_TRESORS._metadata) {
              window.TABLES_TRESORS._metadata = {};
            }
            window.TABLES_TRESORS._metadata.availableTags = [...availableTags];
          }
          
          // Save changes
          EventBus.emit(Events.STORAGE_SAVE);
          
          // Refresh modal and page
          modal.close();
          this.showTableTresorTagsManagement();
          
          // Force refresh of the tables-tresors page
          if (window.location.hash === '#/tables-tresors') {
            UIUtilities.forcePageRefresh();
          }
          
          UIUtilities.showNotification(`Tag "${newTag}" ajoutÃ© avec succÃ¨s`, 'success');
        } else if (newTag && availableTags.includes(newTag)) {
          UIUtilities.showNotification('Ce tag existe dÃ©jÃ ', 'error');
        }
      };

      const addBtn = modal.querySelector('#addTableTresorTagBtn');
      const newTagInput = modal.querySelector('#newTableTresorTag');

      addBtn.addEventListener('click', addTag);
      newTagInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          addTag();
        }
      });

      // Delete tag functionality
      modal.addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-tag-btn')) {
          const tagToDelete = e.target.dataset.tag;
          
          if (confirm(`Supprimer le tag "${tagToDelete}" ?`)) {
            // Remove from available tags
            const index = availableTags.indexOf(tagToDelete);
            if (index > -1) {
              availableTags.splice(index, 1);
              
              // Remove from all tables that use this tag
              if (window.TABLES_TRESORS?.categories) {
                window.TABLES_TRESORS.categories.forEach(category => {
                  category.tables.forEach(table => {
                    if (table.tags && table.tags.includes(tagToDelete)) {
                      table.tags = table.tags.filter(tag => tag !== tagToDelete);
                    }
                  });
                });
              }
              
              // Save in metadata
              if (window.TABLES_TRESORS) {
                if (!window.TABLES_TRESORS._metadata) {
                  window.TABLES_TRESORS._metadata = {};
                }
                window.TABLES_TRESORS._metadata.availableTags = [...availableTags];
              }
              
              // Save changes
              EventBus.emit(Events.STORAGE_SAVE);
              
              // Close and refresh
              modal.close();
              
              // Force page reload
              if (window.location.hash === '#/tables-tresors') {
                UIUtilities.forcePageRefresh();
              }
              
              setTimeout(() => {
                this.showTableTresorTagsManagement();
              }, 200);
              
              UIUtilities.showNotification(`âœ… Tag "${tagToDelete}" supprimÃ© avec succÃ¨s`, 'success');
            }
          }
        }
      });
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - SEARCH MANAGER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // SEARCH MANAGER - SEARCH FUNCTIONALITY
  // ========================================
  window.SearchManager = {

    /**
     * Perform search across all content types
     */
    performSearch(query) {
      const normalizedQuery = query.toLowerCase().trim();
      
      if (!normalizedQuery) {
        this.clearMainSearchResults();
        return;
      }

      const results = [];
      
      // Search in spells
      if (window.SORTS && Array.isArray(window.SORTS)) {
        window.SORTS.forEach(category => {
          if (category.sorts && Array.isArray(category.sorts)) {
            category.sorts.forEach(spell => {
              if (this.matchesSearch(spell, normalizedQuery)) {
                results.push({
                  type: 'spell',
                  category: category.nom,
                  data: spell,
                  summary: this.generateSpellSummary(spell)
                });
              }
            });
          }
        });
      }

      // Search in dons
      if (window.DONS && Array.isArray(window.DONS)) {
        window.DONS.forEach(category => {
          if (category.dons && Array.isArray(category.dons)) {
            category.dons.forEach(don => {
              if (this.matchesSearch(don, normalizedQuery)) {
                results.push({
                  type: 'don',
                  category: category.nom,
                  data: don,
                  summary: this.generateDonSummary(don)
                });
              }
            });
          }
        });
      }

      // Search in classes
      if (window.CLASSES && Array.isArray(window.CLASSES)) {
        window.CLASSES.forEach(classe => {
          if (this.matchesSearch(classe, normalizedQuery)) {
            results.push({
              type: 'class',
              category: 'Classes',
              data: classe,
              summary: this.generateClassSummary(classe)
            });
          }
          
          // Search in subclasses
          if (classe.sousClasses && Array.isArray(classe.sousClasses)) {
            classe.sousClasses.forEach(sousClasse => {
              if (this.matchesSearch(sousClasse, normalizedQuery)) {
                results.push({
                  type: 'subclass',
                  category: classe.nom,
                  data: sousClasse,
                  summary: this.generateSubclassSummary(sousClasse, classe.nom)
                });
              }
            });
          }
        });
      }

      // Search in objects
      if (window.OBJETS && window.OBJETS.objets && Array.isArray(window.OBJETS.objets)) {
        window.OBJETS.objets.forEach(objet => {
          if (this.matchesSearch(objet, normalizedQuery)) {
            results.push({
              type: 'objet',
              category: 'Objets',
              data: objet,
              summary: this.generateObjetSummary(objet)
            });
          }
        });
      }

      // Search in static pages
      if (window.STATIC_PAGES) {
        Object.entries(window.STATIC_PAGES).forEach(([pageId, pageData]) => {
          if (pageData && this.matchesSearch(pageData, normalizedQuery)) {
            results.push({
              type: 'static-page',
              category: 'Pages',
              data: pageData,
              pageId: pageId,
              summary: this.generateStaticPageSummary(pageData)
            });
          }
        });
      }

      this.displaySearchResults(results, query);
    },

    /**
     * Check if item matches search query
     */
    matchesSearch(item, query) {
      // Fonction pour nettoyer le HTML et extraire le texte
      const stripHtml = (text) => {
        if (!text) return '';
        if (typeof text !== 'string') text = String(text);
        return text.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
      };

      const processArray = (arr) => {
        if (!arr) return '';
        if (Array.isArray(arr)) {
          return arr.map(item => stripHtml(item)).join(' ');
        }
        return stripHtml(arr);
      };

      // Collecter TOUS les champs textuels possibles
      const searchFields = [
        // Champs communs
        item.nom, item.name, item.title, item.titre,
        item.description, item.resume, item.content,
        item.prerequis, item.coutMana, item.cout, item.temps,
        item.distance, item.duree, item.damage, item.effet,
        item.capacites, item.competences, item.avantages,
        item.inconvenients, item.cout_creation,
        
        // Champs spÃ©cifiques aux classes
        item.caracteristiques, item.competencesPrincipales,
        item.progression, item.equipementDeBase,
        
        // Champs des objets et monstres  
        item.type, item.tags, item.element, item.numero,
        item.pointsDeVie, item.armure, item.dommages,
        
        // Champs des sections de pages statiques
        processArray(item.sections),
        
        // Sous-classes
        processArray(item.sousClasses),
        
        // Meta-donnÃ©es
        item.author, item.source, item.version
      ];

      // Joindre tous les champs en un seul texte de recherche
      const searchText = searchFields
        .filter(field => field !== null && field !== undefined)
        .map(field => stripHtml(field))
        .join(' ')
        .toLowerCase();
      
      // Chercher chaque mot de la requÃªte
      const queryWords = query.toLowerCase().split(/\s+/).filter(word => word.length > 0);
      return queryWords.every(word => searchText.includes(word));
    },

    /**
     * Display search results
     */
    displaySearchResults(results, query) {
      if (results.length === 0) {
        this.showNoResults(query);
        return;
      }

      // Group results by type for better organization
      const groupedResults = {};
      results.forEach(result => {
        const type = result.type;
        if (!groupedResults[type]) {
          groupedResults[type] = [];
        }
        groupedResults[type].push(result);
      });

      // Generate HTML for results
      let resultsHTML = `
        <div class="search-results-header">
          <h2>ğŸ” RÃ©sultats de recherche pour "${query}"</h2>
          <p>${results.length} rÃ©sultat${results.length > 1 ? 's' : ''} trouvÃ©${results.length > 1 ? 's' : ''}</p>
          <button class="btn small" onclick="JdrApp.modules.ui.clearMainSearchResults()">
            â† Retour au sommaire
          </button>
        </div>
        <div class="search-results-content">
      `;

      // Add results by type
      Object.entries(groupedResults).forEach(([type, typeResults]) => {
        const typeLabel = this.getTypeLabel(type);
        resultsHTML += `
          <div class="search-results-section">
            <h3>${typeLabel} (${typeResults.length})</h3>
            <div class="search-results-grid">
        `;
        
        typeResults.forEach(result => {
          resultsHTML += this.generateResultCard(result);
        });
        
        resultsHTML += `
            </div>
          </div>
        `;
      });

      resultsHTML += `</div>`;
      
      // Replace main content with search results
      const main = document.querySelector('main .content');
      if (main) {
        main.innerHTML = resultsHTML;
      }
    },

    /**
     * Show no results message
     */
    showNoResults(query) {
      const noResultsHTML = `
        <div class="search-results-header">
          <h2>ğŸ” Aucun rÃ©sultat pour "${query}"</h2>
          <p>Essayez avec d'autres mots-clÃ©s ou vÃ©rifiez l'orthographe.</p>
          <button class="btn small" onclick="JdrApp.modules.ui.clearMainSearchResults()">
            â† Retour au sommaire
          </button>
        </div>
      `;
      
      const main = document.querySelector('main .content');
      if (main) {
        main.innerHTML = noResultsHTML;
      }
    },

    /**
     * Clear search results and return to normal view
     */
    clearMainSearchResults() {
      // Reload the current page or go back to homepage
      if (window.location.hash && window.location.hash !== '#/') {
        // Reload current page
        if (JdrApp.modules.router && JdrApp.modules.router.handleRoute) {
          JdrApp.modules.router.handleRoute();
        }
      } else {
        // Go to homepage
        window.location.hash = '#/creation';
      }
      
      // Clear search input
      const searchInput = document.querySelector('#search');
      if (searchInput) {
        searchInput.value = '';
      }
    },

    // Summary generators
    generateSpellSummary(spell) {
      return `ğŸ”® ${UIUtilities.stripHtml(spell.nom)} - ${UIUtilities.stripHtml(spell.prerequis || 'Aucun prÃ©requis')} | ${UIUtilities.stripHtml(spell.coutMana || 'CoÃ»t inconnu')}`;
    },

    generateDonSummary(don) {
      return `ğŸ† ${UIUtilities.stripHtml(don.nom)} - ${UIUtilities.stripHtml(don.prerequis || 'Aucun prÃ©requis')} | ${UIUtilities.stripHtml(don.cout || 'CoÃ»t inconnu')}`;
    },

    generateClassSummary(classe) {
      return `âš”ï¸ ${UIUtilities.stripHtml(classe.nom)} - ${UIUtilities.stripHtml(classe.resume || 'Classe de combat')}`;
    },

    generateSubclassSummary(sousClasse, parentClass) {
      return `âš¡ ${UIUtilities.stripHtml(sousClasse.nom)} (${UIUtilities.stripHtml(parentClass)}) - Sous-classe spÃ©cialisÃ©e`;
    },

    generateObjetSummary(objet) {
      const tags = objet.tags && Array.isArray(objet.tags) ? objet.tags.join(', ') : '';
      const numero = objet.numero ? `#${objet.numero}` : '';
      return `âš”ï¸ ${UIUtilities.stripHtml(objet.nom)} ${numero} - ${UIUtilities.stripHtml(tags)} | ${UIUtilities.stripHtml(objet.prix || 'Prix non dÃ©fini')}`;
    },

    generateStaticPageSummary(pageData) {
      return `ğŸ“„ ${UIUtilities.stripHtml(pageData.title)} - ${UIUtilities.stripHtml(pageData.description || 'Page d\'information du jeu')}`;
    },

    getTypeLabel(type) {
      const typeLabels = {
        'spell': 'ğŸ”® Sorts',
        'don': 'ğŸ† Dons',
        'class': 'âš”ï¸ Classes',
        'subclass': 'âš¡ Sous-classes',
        'objet': 'âš”ï¸ Objets',
        'static-page': 'ğŸ“„ Pages'
      };
      return typeLabels[type] || type;
    },

    generateResultCard(result) {
      const linkHash = this.generateLinkHash(result);
      
      return `
        <div class="search-result-card" onclick="window.location.hash='${linkHash}'">
          <div class="search-result-content">
            <div class="search-result-summary">${result.summary}</div>
            <div class="search-result-category">${result.category}</div>
          </div>
        </div>
      `;
    },

    generateLinkHash(result) {
      switch (result.type) {
        case 'spell':
          return `#/sorts-${UIUtilities.slugify(result.category)}`;
        case 'don':
          return `#/dons-${UIUtilities.slugify(result.category)}`;
        case 'class':
          return `#/${UIUtilities.slugify(result.data.nom)}`;
        case 'subclass':
          return `#/${UIUtilities.slugify(result.category)}`;
        case 'objet':
          return `#/objets`;
        case 'static-page':
          return `#/${result.pageId}`;
        default:
          return '#/creation';
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - MODAL MANAGER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // MODAL MANAGER - SPECIALIZED MODALS
  // ========================================
  window.ModalManager = {

    /**
     * Show elements modal for dev tools
     */
    showElementsModal() {
      let modal = JdrApp.utils.dom.$('#elementsModal');
      if (!modal) {
        modal = this.createElementsModal();
        document.body.appendChild(modal);
      }
      
      BaseModal.openModal('elementsModal');
    },

    /**
     * Create elements selection modal
     */
    createElementsModal() {
      const elements = Object.entries(window.ElementColors).map(([name, config]) => ({
        name,
        color: config.color,
        icon: UIUtilities.getElementIcon(name)
      }));

      const elementsHTML = elements.map(element => `
        <div class="element-item" data-element="${element.name}" data-color="${element.color}">
          <div class="element-icon" style="background: ${element.color};">${element.icon}</div>
          <div class="element-name">${element.name}</div>
          <div class="copy-indicator">CopiÃ©!</div>
        </div>
      `).join('');

      const modal = BaseModal.createModal('elementsModal', 'âš¡ Ã‰lÃ©ments', `
        <p>Cliquez sur un Ã©lÃ©ment pour copier son code HTML stylÃ© dans le presse-papiers :</p>
        <div class="elements-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px; margin: 20px 0;">
          ${elementsHTML}
        </div>
      `);

      // Add event listeners
      modal.addEventListener('click', (e) => {
        const elementItem = e.target.closest('.element-item');
        if (elementItem) {
          const elementName = elementItem.dataset.element;
          const elementColor = elementItem.dataset.color;
          
          // Get element configuration
          const elementConfig = window.ElementColors[elementName];
          if (elementConfig) {
            const styleString = `color: ${elementConfig.color}; font-weight: ${elementConfig.weight || 'bold'};`;
            
            const html = `<span style="${styleString}">${elementName}</span>`;
            UIUtilities.copyToClipboard(html);
          } else {
            // Fallback for elements not found
            const html = `<span style="color: ${elementColor}; font-weight: bold;">${elementName}</span>`;
            UIUtilities.copyToClipboard(html);
          }
          
          elementItem.classList.add('copied');
          
          // Fermer la modale aprÃ¨s un court dÃ©lai pour voir l'effet "CopiÃ©!"
          setTimeout(() => {
            BaseModal.closeModal(modal);
            elementItem.classList.remove('copied');
          }, 800);
        }
      });

      return modal;
    },

    /**
     * Show states modal
     */
    showEtatsModal() {
      let modal = JdrApp.utils.dom.$('#etatsModal');
      if (!modal) {
        modal = this.createEtatsModal();
        document.body.appendChild(modal);
      }
      
      BaseModal.openModal('etatsModal');
    },

    /**
     * Create states modal
     */
    createEtatsModal() {
      // Extract states from static pages
      let etats = [];
      if (window.STATIC_PAGES?.etats?.sections) {
        etats = window.STATIC_PAGES.etats.sections.filter(section => 
          section.type === 'card' && section.title
        );
      }

      const etatsHTML = etats.map(etat => `
        <div class="etat-item" data-etat-name="${etat.title}">
          <div class="etat-name">${etat.title}</div>
          <div class="copy-indicator">CopiÃ©!</div>
        </div>
      `).join('');

      const modal = BaseModal.createModal('etatsModal', 'ğŸ­ Ã‰tats', `
        <p>Cliquez sur un Ã©tat pour copier son lien HTML dans le presse-papiers :</p>
        <div class="etats-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 8px; margin: 20px 0;">
          ${etatsHTML}
        </div>
      `);

      // Add event listeners
      modal.addEventListener('click', (e) => {
        const etatItem = e.target.closest('.etat-item');
        if (etatItem) {
          const etatName = etatItem.dataset.etatName;
          
          // Create clickable link
          const etatLink = `<span class="etat-link" data-etat="${etatName}" style="color: var(--accent); cursor: pointer; text-decoration: underline;">${etatName}</span>`;
          
          // Toujours copier dans le presse-papiers
          UIUtilities.copyToClipboard(etatLink);
          
          etatItem.classList.add('copied');
          
          // Fermer la modale aprÃ¨s un court dÃ©lai pour voir l'effet "CopiÃ©!"
          setTimeout(() => {
            BaseModal.closeModal(modal);
            etatItem.classList.remove('copied');
          }, 800);
        }
      });

      return modal;
    },

    /**
     * Show spell links modal
     */
    showSpellLinksModal() {
      let modal = JdrApp.utils.dom.$('#spellLinksModal');
      if (!modal) {
        modal = this.createSpellLinksModal();
        document.body.appendChild(modal);
      }
      
      BaseModal.openModal('spellLinksModal');
    },

    /**
     * Create spell links modal
     */
    createSpellLinksModal() {
      // Extract spells from data
      let spells = [];
      if (window.SORTS && Array.isArray(window.SORTS)) {
        window.SORTS.forEach(category => {
          if (category.sorts && Array.isArray(category.sorts)) {
            category.sorts.forEach(spell => {
              spells.push({
                name: spell.nom,
                category: category.nom,
                element: spell.element || 'Neutre',
                description: spell.description || ''
              });
            });
          }
        });
      }

      const spellsHTML = spells.map(spell => `
        <div class="spell-item" data-spell-name="${spell.name}" data-spell-category="${spell.category}">
          <div class="spell-info">
            <div class="spell-name" style="color: ${UIUtilities.getElementColor(spell.element)}; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">${spell.name}</div>
            <span data-spell-meta style="color: ${UIUtilities.getElementColor(spell.element)} !important; font-size: 12px; margin-bottom: 6px; display: block;">${UIUtilities.getElementIcon(spell.element)} ${spell.element} â€¢ ${spell.category}</span>
            <div class="spell-description">${spell.description.length > 80 ? spell.description.substring(0, 80) + '...' : spell.description}</div>
          </div>
          <div class="copy-indicator">CopiÃ©!</div>
        </div>
      `).join('');

      const modal = BaseModal.createModal('spellLinksModal', 'ğŸ”® Liens de Sorts', `
        <p>Cliquez sur un sort pour copier son lien HTML dans le presse-papiers :</p>
        <div class="spells-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 12px; margin: 20px 0; max-height: 400px; overflow-y: auto;">
          ${spellsHTML}
        </div>
      `);

      // Add event listeners
      modal.addEventListener('click', (e) => {
        const spellItem = e.target.closest('.spell-item');
        if (spellItem) {
          const spellName = spellItem.dataset.spellName;
          const spellCategory = spellItem.dataset.spellCategory;
          
          // Create clickable spell link
          const spellLink = `<span class="spell-link" data-spell="${spellName}" data-category="${spellCategory}" style="color: var(--accent); cursor: pointer; text-decoration: underline;">${spellName}</span>`;
          
          UIUtilities.copyToClipboard(spellLink);
          
          spellItem.classList.add('copied');
          
          // Fermer la modale aprÃ¨s un court dÃ©lai pour voir l'effet "CopiÃ©!"
          setTimeout(() => {
            BaseModal.closeModal(modal);
            spellItem.classList.remove('copied');
          }, 800);
        }
      });

      return modal;
    },

    /**
     * Show monster links modal
     */
    showMonsterLinksModal() {
      let modal = JdrApp.utils.dom.$('#monsterLinksModal');
      if (!modal) {
        modal = this.createMonsterLinksModal();
        document.body.appendChild(modal);
      }
      
      BaseModal.openModal('monsterLinksModal');
    },

    /**
     * Create monster links modal
     */
    createMonsterLinksModal() {
      // Extract monsters from data
      let monsters = [];
      if (window.MONSTRES && Array.isArray(window.MONSTRES)) {
        monsters = window.MONSTRES.map(monster => ({
          name: monster.nom,
          element: monster.element || 'Neutre',
          pointsDeVie: monster.pointsDeVie || '?',
          tags: monster.tags || [],
          description: monster.description || ''
        }));
      }

      const monstersHTML = monsters.map(monster => `
        <div class="monster-item" data-monster-name="${monster.name}">
          <div class="monster-info">
            <div class="monster-name" style="color: ${UIUtilities.getElementColor(monster.element)}; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">${monster.name}</div>
            <span data-monster-meta style="color: ${UIUtilities.getElementColor(monster.element)} !important; font-size: 12px; margin-bottom: 6px; display: block;">${UIUtilities.getElementIcon(monster.element)} ${monster.element} â€¢ ${monster.pointsDeVie} PV â€¢ ${monster.tags.join(', ')}</span>
            <div class="monster-description">${UIUtilities.stripHtml(monster.description).length > 80 ? UIUtilities.stripHtml(monster.description).substring(0, 80) + '...' : UIUtilities.stripHtml(monster.description)}</div>
          </div>
          <div class="copy-indicator">CopiÃ©!</div>
        </div>
      `).join('');

      const modal = BaseModal.createModal('monsterLinksModal', 'ğŸ‘¹ Liens de Monstres', `
        <p>Cliquez sur un monstre pour copier son lien HTML dans le presse-papiers :</p>
        <div class="monsters-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 12px; margin: 20px 0; max-height: 400px; overflow-y: auto;">
          ${monstersHTML}
        </div>
      `);

      // Add event listeners
      modal.addEventListener('click', (e) => {
        const monsterItem = e.target.closest('.monster-item');
        if (monsterItem) {
          const monsterName = monsterItem.dataset.monsterName;
          
          // Create clickable monster link
          const monsterLink = `<span class="monster-link" data-monster="${monsterName}" style="color: var(--accent); cursor: pointer; text-decoration: underline;">${monsterName}</span>`;
          
          UIUtilities.copyToClipboard(monsterLink);
          
          monsterItem.classList.add('copied');
          
          // Fermer la modale aprÃ¨s un court dÃ©lai pour voir l'effet "CopiÃ©!"
          setTimeout(() => {
            BaseModal.closeModal(modal);
            monsterItem.classList.remove('copied');
          }, 800);
        }
      });

      return modal;
    },

    /**
     * Show page links modal
     */
    showPageLinksModal() {
      // Simple implementation - delegate to ui.js for now
      if (JdrApp.modules.ui?.showPageLinksModal) {
        return JdrApp.modules.ui.showPageLinksModal();
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - RESPONSIVE MANAGER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // RESPONSIVE MANAGER - MOBILE & RESPONSIVE DESIGN
  // ========================================
  window.ResponsiveManager = {

    /**
     * Setup responsive design features
     */
    setupResponsive() {
      this.setupMobileNavigation();
      this.setupLegacyResponsive();
    },

    /**
     * Setup mobile navigation
     */
    setupMobileNavigation() {
      this.createMobileNavToggle();
      this.setupResponsiveBreakpoints();
    },

    /**
     * Create mobile navigation toggle
     */
    createMobileNavToggle() {
      // Use existing toggle or create new one
      let menuToggle = document.querySelector('#menuToggle');
      let isExisting = !!menuToggle;

      if (!menuToggle) {
        menuToggle = document.createElement('button');
        menuToggle.id = 'menuToggle';
        menuToggle.className = 'menu-toggle';
        menuToggle.setAttribute('aria-controls', 'sidebar');
        menuToggle.setAttribute('aria-expanded', 'false');
        menuToggle.setAttribute('aria-label', 'Ouvrir le sommaire');
        
        // Insert at the beginning of the shell
        const shell = document.querySelector('.shell');
        if (shell) {
          shell.insertBefore(menuToggle, shell.firstChild);
        }
      }
      
      // Create prettier button with icon and text
      menuToggle.innerHTML = `
        <span class="menu-icon">â˜°</span>
        <span class="menu-text">Sommaire</span>
      `;
      
      // Add proper styling - fix width and position issues
      menuToggle.style.cssText = `
        position: fixed !important;
        top: 16px !important;
        left: 16px !important;
        z-index: 1000 !important;
        background: var(--primary-color, #8b4513) !important;
        color: white !important;
        border: none !important;
        border-radius: 8px !important;
        padding: 12px 16px !important;
        font-size: 14px !important;
        font-weight: 500 !important;
        cursor: pointer !important;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15) !important;
        transition: all 0.2s ease !important;
        display: flex !important;
        align-items: center !important;
        gap: 8px !important;
        width: auto !important;
        max-width: 140px !important;
        min-width: 120px !important;
      `;
      
      // Remove old event listeners to avoid conflicts
      const newMenuToggle = menuToggle.cloneNode(true);
      menuToggle.replaceWith(newMenuToggle);
      menuToggle = newMenuToggle;

      // Add hover effect
      if (menuToggle) {
        menuToggle.addEventListener('mouseenter', () => {
          menuToggle.style.transform = 'scale(1.05)';
          menuToggle.style.boxShadow = '0 4px 12px rgba(0,0,0,0.25)';
        });
        
        menuToggle.addEventListener('mouseleave', () => {
          menuToggle.style.transform = 'scale(1)';
          menuToggle.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
        });

        // Add toggle functionality
        menuToggle.addEventListener('click', () => {
          this.toggleMobileNav();
        });
      }

      // Create backdrop for mobile
      if (!document.querySelector('#backdrop')) {
        const backdrop = document.createElement('div');
        backdrop.id = 'backdrop';
        backdrop.className = 'backdrop';
        backdrop.style.display = 'none';
        backdrop.addEventListener('click', () => {
          this.toggleMobileNav();
        });
        const shell = document.querySelector('.shell');
        if (shell) {
          shell.appendChild(backdrop);
        } else {
          document.body.appendChild(backdrop);
        }
      }
    },

    /**
     * Toggle mobile navigation
     */
    toggleMobileNav() {
      const sidebar = document.querySelector('#sidebar');
      const menuToggle = document.querySelector('#menuToggle');
      const backdrop = document.querySelector('#backdrop');
      
      if (!sidebar || !menuToggle) return;

      const isExpanded = menuToggle.getAttribute('aria-expanded') === 'true';
      
      if (isExpanded) {
        // Close mobile nav
        sidebar.classList.remove('mobile-open');
        menuToggle.setAttribute('aria-expanded', 'false');
        if (backdrop) backdrop.style.display = 'none';
        document.body.style.overflow = '';
      } else {
        // Open mobile nav
        sidebar.classList.add('mobile-open');
        menuToggle.setAttribute('aria-expanded', 'true');
        if (backdrop) backdrop.style.display = 'block';
        document.body.style.overflow = 'hidden';
      }
    },

    /**
     * Setup responsive breakpoints
     */
    setupResponsiveBreakpoints() {
      // Handle window resize
      let resizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          this.handleResize();
        }, 100);
      });

      // Initial setup
      this.handleResize();
    },

    /**
     * Handle window resize
     */
    handleResize() {
      const width = window.innerWidth;
      const sidebar = document.querySelector('#sidebar');
      const menuToggle = document.querySelector('#menuToggle');
      const backdrop = document.querySelector('#backdrop');

      // Check if device is touch-capable
      const isTouchDevice = this.isTouchDevice();
      const isMobileSize = width <= window.UI_CONSTANTS.BREAKPOINTS.MOBILE;
      const isTabletSize = width > window.UI_CONSTANTS.BREAKPOINTS.MOBILE && width <= window.UI_CONSTANTS.BREAKPOINTS.TABLET_LANDSCAPE;
      
      // Show menu toggle on touch devices OR mobile size screens
      const shouldShowToggle = isTouchDevice || isMobileSize;

      if (shouldShowToggle) {
        // Mobile/Touch mode
        if (menuToggle) menuToggle.style.display = 'block';
        if (sidebar) {
          sidebar.classList.remove('desktop-open');
          // Close mobile nav on resize to mobile
          sidebar.classList.remove('mobile-open');
          if (menuToggle) menuToggle.setAttribute('aria-expanded', 'false');
        }
        if (backdrop) backdrop.style.display = 'none';
        document.body.style.overflow = '';
      } else {
        // Desktop mode (non-touch, large screen)
        if (menuToggle) menuToggle.style.display = 'none';
        if (sidebar) {
          sidebar.classList.remove('mobile-open');
          sidebar.classList.add('desktop-open');
        }
        if (backdrop) backdrop.style.display = 'none';
        document.body.style.overflow = '';
      }
    },

    /**
     * Check if device has touch capability
     */
    isTouchDevice() {
      return 'ontouchstart' in window || 
             navigator.maxTouchPoints > 0 || 
             navigator.msMaxTouchPoints > 0 ||
             window.matchMedia('(pointer: coarse)').matches;
    },

    /**
     * Setup legacy responsive features
     */
    setupLegacyResponsive() {
      // Handle orientation changes on mobile
      window.addEventListener('orientationchange', () => {
        setTimeout(() => {
          this.handleResize();
        }, 300);
      });

      // Handle touch events for better mobile experience
      this.setupTouchEvents();
    },

    /**
     * Setup touch events for mobile
     */
    setupTouchEvents() {
      let touchStartX = 0;
      let touchStartY = 0;

      // Handle touch start
      document.addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }, { passive: true });

      // Handle swipe gestures
      document.addEventListener('touchend', (e) => {
        if (!e.changedTouches[0]) return;

        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;

        // Only handle horizontal swipes
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
          const sidebar = document.querySelector('#sidebar');
          const menuToggle = document.querySelector('#menuToggle');
          
          if (!sidebar || !menuToggle) return;

          const isExpanded = menuToggle.getAttribute('aria-expanded') === 'true';
          const isMobile = window.innerWidth <= window.UI_CONSTANTS.BREAKPOINTS.MOBILE;

          if (isMobile) {
            // Swipe right from left edge to open
            if (deltaX > 0 && touchStartX < 50 && !isExpanded) {
              this.toggleMobileNav();
            }
            // Swipe left when sidebar is open to close
            else if (deltaX < 0 && isExpanded) {
              this.toggleMobileNav();
            }
          }
        }
      }, { passive: true });
    },

    /**
     * Check if device is mobile
     */
    isMobileDevice() {
      return window.innerWidth <= window.UI_CONSTANTS.BREAKPOINTS.MOBILE;
    },

    /**
     * Check if device is tablet
     */
    isTabletDevice() {
      const width = window.innerWidth;
      return width > window.UI_CONSTANTS.BREAKPOINTS.MOBILE && 
             width <= window.UI_CONSTANTS.BREAKPOINTS.TABLET;
    },

    /**
     * Get current device type
     */
    getDeviceType() {
      if (this.isMobileDevice()) return 'mobile';
      if (this.isTabletDevice()) return 'tablet';
      return 'desktop';
    },

    /**
     * Apply device-specific optimizations
     */
    applyDeviceOptimizations() {
      const deviceType = this.getDeviceType();
      document.body.setAttribute('data-device-type', deviceType);

      // Add device-specific CSS classes
      document.body.classList.remove('device-mobile', 'device-tablet', 'device-desktop');
      document.body.classList.add(`device-${deviceType}`);

      // Apply device-specific optimizations
      switch (deviceType) {
        case 'mobile':
          this.applyMobileOptimizations();
          break;
        case 'tablet':
          this.applyTabletOptimizations();
          break;
        case 'desktop':
          this.applyDesktopOptimizations();
          break;
      }
    },

    /**
     * Apply mobile-specific optimizations
     */
    applyMobileOptimizations() {
      // Reduce animations for better performance
      document.body.classList.add('reduced-motion');
      
      // Optimize scroll behavior
      if (window.ScrollOptimizer) {
        ScrollOptimizer.enableMobileOptimizations();
      }
    },

    /**
     * Apply tablet-specific optimizations
     */
    applyTabletOptimizations() {
      // Tablet-specific optimizations
      document.body.classList.remove('reduced-motion');
    },

    /**
     * Apply desktop-specific optimizations
     */
    applyDesktopOptimizations() {
      // Desktop-specific optimizations
      document.body.classList.remove('reduced-motion');
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - PAGE MANAGER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // PAGE MANAGER - STATIC PAGE MANAGEMENT
  // ========================================
  window.PageManager = {

    /**
     * Show section selection modal for new page creation
     */
    showSectionSelectionModal() {
      const modalId = 'sectionSelectionModal';
      
      // Remove existing modal
      BaseModal.destroyModal(modalId);

      const content = `
        <p>SÃ©lectionnez le type de contenu Ã  ajouter :</p>
        <div class="section-types" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin: 20px 0;">
          <button class="btn btn-primary section-type-btn" data-type="section">
            ğŸ“„ Nouvelle Section
          </button>
          <button class="btn btn-secondary section-type-btn" data-type="paragraph">
            ğŸ“ Nouveau Paragraphe
          </button>
        </div>
      `;

      const modal = BaseModal.createModal(modalId, 'â• Nouveau Contenu', content);
      document.body.appendChild(modal);

      // Setup event handlers
      modal.addEventListener('click', (e) => {
        if (e.target.classList.contains('section-type-btn')) {
          const type = e.target.dataset.type;
          BaseModal.closeModal(modal);
          BaseModal.destroyModal(modal);
          
          if (type === 'section') {
            this.createNewSection();
          } else if (type === 'paragraph') {
            this.createNewParagraph();
          }
        }
      });

      BaseModal.openModal(modalId);
    },

    /**
     * Create new section
     */
    createNewSection() {
      const sectionTitle = prompt('Titre de la nouvelle section :');
      if (!sectionTitle || !sectionTitle.trim()) return;

      const pageId = UIUtilities.getCurrentPageId();
      if (!pageId) {
        UIUtilities.showNotification('âŒ Impossible de dÃ©terminer la page courante', 'error');
        return;
      }

      // Generate unique ID
      const sectionId = UIUtilities.generateUniqueId('section');
      
      // Create section data
      const newSection = {
        id: sectionId,
        type: 'card',
        title: sectionTitle.trim(),
        content: '<p>Contenu de la nouvelle section...</p>'
      };

      // Add to page data
      if (!window.STATIC_PAGES[pageId]) {
        window.STATIC_PAGES[pageId] = { sections: [] };
      }
      if (!window.STATIC_PAGES[pageId].sections) {
        window.STATIC_PAGES[pageId].sections = [];
      }

      window.STATIC_PAGES[pageId].sections.push(newSection);

      // Save and refresh
      this.savePageData();
      this.refreshCurrentPage();
      
      UIUtilities.showNotification('â• Nouvelle section ajoutÃ©e et sauvegardÃ©e', 'success');
    },

    /**
     * Create new paragraph
     */
    createNewParagraph() {
      const paragraphContent = prompt('Contenu du nouveau paragraphe :');
      if (!paragraphContent || !paragraphContent.trim()) return;

      const pageId = UIUtilities.getCurrentPageId();
      if (!pageId) {
        UIUtilities.showNotification('âŒ Impossible de dÃ©terminer la page courante', 'error');
        return;
      }

      // Generate unique ID
      const paragraphId = UIUtilities.generateUniqueId('paragraph');
      
      // Create paragraph data
      const newParagraph = {
        id: paragraphId,
        type: 'text',
        content: `<p>${paragraphContent.trim()}</p>`
      };

      // Add to page data
      if (!window.STATIC_PAGES[pageId]) {
        window.STATIC_PAGES[pageId] = { sections: [] };
      }
      if (!window.STATIC_PAGES[pageId].sections) {
        window.STATIC_PAGES[pageId].sections = [];
      }

      window.STATIC_PAGES[pageId].sections.push(newParagraph);

      // Save and refresh
      this.savePageData();
      this.refreshCurrentPage();
      
      UIUtilities.showNotification('â• Paragraphe ajoutÃ© et sauvegardÃ©', 'success');
    },

    /**
     * Add paragraph to existing target
     */
    addParagraph(target, button) {
      if (!target || !button) {
        UIUtilities.showNotification('âŒ Target ou bouton manquant', 'error');
        return;
      }

      const paragraphContent = prompt('Contenu du nouveau paragraphe :');
      if (!paragraphContent || !paragraphContent.trim()) return;

      // Handle different types of additions based on target
      if (target === 'new-section') {
        this.createNewSection();
      } else {
        this.addParagraphToSection(target, button);
      }
    },

    /**
     * Add paragraph to specific section
     */
    addParagraphToSection(target, button) {
      const paragraphContent = prompt('Contenu du nouveau paragraphe :');
      if (!paragraphContent || !paragraphContent.trim()) return;

      // Generate unique ID
      const pageId = UIUtilities.getCurrentPageId();
      const paragraphId = UIUtilities.generateUniqueId('paragraph');
      
      // Create paragraph data
      const newParagraph = {
        id: paragraphId,
        type: 'text',
        content: `<p>${paragraphContent.trim()}</p>`
      };

      // Find target section and add paragraph
      if (window.STATIC_PAGES[pageId]?.sections) {
        const targetSection = window.STATIC_PAGES[pageId].sections.find(section => 
          section.id === target
        );
        
        if (targetSection) {
          if (!targetSection.paragraphs) {
            targetSection.paragraphs = [];
          }
          targetSection.paragraphs.push(newParagraph);
        } else {
          // Add as new section if target not found
          window.STATIC_PAGES[pageId].sections.push(newParagraph);
        }
      }

      // Save and refresh
      this.savePageData();
      this.refreshCurrentPage();
      
      UIUtilities.showNotification('â• Paragraphe ajoutÃ© et sauvegardÃ©', 'success');
    },

    /**
     * Delete section
     */
    deleteSection(sectionName, button) {
      if (!sectionName || !button) {
        UIUtilities.showNotification('âŒ Section ou bouton manquant', 'error');
        return;
      }

      if (!confirm(`Supprimer la section "${sectionName}" ?`)) {
        return;
      }

      const pageId = UIUtilities.getCurrentPageId();
      if (!pageId || !window.STATIC_PAGES[pageId]?.sections) {
        UIUtilities.showNotification('âŒ Page ou sections non trouvÃ©es', 'error');
        return;
      }

      // Find and remove the section
      const section = button.closest('.card');
      if (section) {
        // Extract the section ID from the editable elements
        const editableElements = section.querySelectorAll('[data-edit-type]');
        let sectionId = null;
        
        for (const element of editableElements) {
          const id = element.dataset.sectionId || element.id;
          if (id) {
            // Remove "-title" suffix if present to get base ID
            sectionId = id.replace(/-title$/, '');
            break;
          }
        }

        if (sectionId) {
          // Remove from data
          window.STATIC_PAGES[pageId].sections = window.STATIC_PAGES[pageId].sections.filter(
            s => s.id !== sectionId
          );

          // Save the deletion to JSON
          this.savePageData();

          // Recalculate all section indices after deletion
          this.recalculateSectionIndices(pageId);

          // Trigger persistent storage save
          UIUtilities.triggerDataSave();
          
          UIUtilities.showNotification(`ğŸ—‘ï¸ Section "${sectionName}" supprimÃ©e et mise Ã  jour JSON`, 'success');
          
          // Refresh page
          this.refreshCurrentPage();
        }
      }
    },

    /**
     * Save page data
     */
    savePageData() {
      // Trigger storage save event
      UIUtilities.triggerDataSave();
    },

    /**
     * Refresh current page
     */
    refreshCurrentPage() {
      UIUtilities.forcePageRefresh();
    },

    /**
     * Count existing sections for unique ID generation
     */
    countExistingSections() {
      const pageId = UIUtilities.getCurrentPageId();
      if (!pageId || !window.STATIC_PAGES || !window.STATIC_PAGES[pageId]) {
        return 0;
      }
      const pageData = window.STATIC_PAGES[pageId];
      return pageData.sections ? pageData.sections.length : 0;
    },

    /**
     * Save new section to JSON data
     */
    saveNewSectionToJSON(sectionId, title, content) {
      const pageId = UIUtilities.getCurrentPageId();
      
      if (!pageId || !window.STATIC_PAGES || !window.STATIC_PAGES[pageId]) {
        return false;
      }
      
      const pageData = window.STATIC_PAGES[pageId];
      if (!pageData.sections) {
        pageData.sections = [];
      }
      
      // Create new section object
      const newSection = {
        id: sectionId,
        type: 'card',
        title: title,
        content: content
      };
      
      // Add to sections array
      pageData.sections.push(newSection);
      
      return true;
    },

    /**
     * Recalculate section indices after changes
     */
    recalculateSectionIndices(pageId) {
      if (!window.STATIC_PAGES[pageId]?.sections) {
        return false;
      }
      
      const sections = window.STATIC_PAGES[pageId].sections;
      
      // Update indices for all sections
      sections.forEach((section, index) => {
        if (section.id) {
          section.index = index;
        }
      });
      
      console.log(`Recalculated indices for ${sections.length} sections in page ${pageId}`);
      return true;
    },

    /**
     * Create new category for content types
     */
    createNewCategory(type) {
      const config = window.ContentTypes[type];
      if (!config) {
        UIUtilities.showNotification(`âŒ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Demander le nom de la catÃ©gorie
      const categoryName = prompt(`Nom de la nouvelle catÃ©gorie ${config.container} :`);
      if (!categoryName || !categoryName.trim()) {
        return;
      }

      const trimmedName = categoryName.trim();
      
      // VÃ©rifier si la catÃ©gorie existe dÃ©jÃ 
      const entity = ContentFactory.getEntity(type);
      if (entity && entity.findCategory(trimmedName)) {
        UIUtilities.showNotification(`âŒ La catÃ©gorie "${trimmedName}" existe dÃ©jÃ `, 'error');
        return;
      }

      // CrÃ©er la nouvelle catÃ©gorie
      const success = ContentFactory.addCategory(type, {
        nom: trimmedName,
        [config.dataKey.toLowerCase()]: []
      });

      if (success) {
        // Sauvegarder les modifications
        EventBus.emit(Events.STORAGE_SAVE);

        // RafraÃ®chir ContentFactory
        ContentFactory.refreshData();

        // RafraÃ®chir le router TOC
        if (JdrApp.modules.router && JdrApp.modules.router.generateTOC) {
          JdrApp.modules.router.generateTOC();
        }

        // Naviguer vers la nouvelle catÃ©gorie
        const categoryRoute = `${config.container}-${JdrApp.utils.data.sanitizeId(trimmedName)}`;
        JdrApp.modules.router.navigate(categoryRoute);

        UIUtilities.showNotification(`${config.icons.category} CatÃ©gorie "${trimmedName}" crÃ©Ã©e avec succÃ¨s!`, 'success');
      }
    },

    /**
     * Delete category
     */
    deleteCategory(type, categoryName) {
      const config = window.ContentTypes[type];
      if (!config) {
        UIUtilities.showNotification(`âŒ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      if (!confirm(`Supprimer la catÃ©gorie "${categoryName}" et tout son contenu ?`)) {
        return;
      }

      const success = ContentFactory.deleteCategory(type, categoryName);

      if (success) {
        // Sauvegarder les modifications
        EventBus.emit(Events.STORAGE_SAVE);

        // RafraÃ®chir ContentFactory
        ContentFactory.refreshData();

        // RafraÃ®chir le router TOC
        if (JdrApp.modules.router && JdrApp.modules.router.generateTOC) {
          JdrApp.modules.router.generateTOC();
        }

        // Naviguer vers la page principale du type
        JdrApp.modules.router.navigate(config.container);

        UIUtilities.showNotification(`${config.icons.delete} CatÃ©gorie "${categoryName}" supprimÃ©e`, 'success');
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - UI MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // UI INTERACTIONS MODULE
  // ========================================
  JdrApp.modules.ui = {
    _initialized: false,
    
    init() {
      // Prevent multiple initialization to avoid duplicate event listeners
      if (this._initialized) {
        return;
      }
      
      // Use UICore for main initialization
      if (window.UICore) {
        UICore.init();
      } else {
        console.error('UICore not available - ensure ui/ modules are loaded');
        return;
      }
      
      this._initialized = true;
    },

    setupEventListeners() {
      // Delegate to UICore
      if (window.UICore) {
        return UICore.setupEventListeners();
      }
    },

    setupSearch() {
      // Delegate to UICore
      if (window.UICore) {
        return UICore.setupSearch();
      }
    },

    setupModals() {
      // Delegate to UICore
      if (window.UICore) {
        return UICore.setupModals();
      }
    },

    setupResponsive() {
      // Delegate to UICore
      if (window.UICore) {
        return UICore.setupResponsive();
      }
    },

    setupNewPageHandler() {
      // Delegate to UICore
      if (window.UICore) {
        return UICore.setupNewPageHandler();
      }
    },

    // Event handlers - delegate to modular components
    handleContentAdd(type, category, item) {
      if (window.ContentManager) {
        return ContentManager.handleContentAdd(type, category, item);
      }
    },

    handleContentDelete(type, category, item) {
      if (window.ContentManager) {
        return ContentManager.handleContentDelete(type, category, item);
      }
    },

    handleContentMove(type, category, itemName, direction) {
      if (window.ContentManager) {
        return ContentManager.handleContentMove(type, category, itemName, direction);
      }
    },

    // Search methods - delegate to SearchManager
    performSearch(query) {
      if (window.SearchManager) {
        return SearchManager.performSearch(query);
      }
    },

    clearMainSearchResults() {
      if (window.SearchManager) {
        return SearchManager.clearMainSearchResults();
      }
    },

    // Modal methods - delegate to ModalManager
    openModal(type, data = null) {
      if (window.ModalManager) {
        return ModalManager.openModal(type, data);
      }
    },

    closeModal() {
      if (window.ModalManager) {
        return ModalManager.closeModal();
      }
    },

    // Page management - delegate to PageManager
    showPage(pageId) {
      if (window.PageManager) {
        return PageManager.showPage(pageId);
      }
    },

    // Responsive methods - delegate to ResponsiveManager
    updateResponsiveLayout() {
      if (window.ResponsiveManager) {
        return ResponsiveManager.updateResponsiveLayout();
      }
    },

    // Tags methods - delegate to TagsManager
    updateTagsDisplay() {
      if (window.TagsManager) {
        return TagsManager.updateTagsDisplay();
      }
    },

    toggleTag(tagName, isActive) {
      if (window.TagsManager) {
        return TagsManager.toggleTag(tagName, isActive);
      }
    },

    // Event handling delegation
    setupDragAndDrop() {
      if (window.EventHandlers) {
        return EventHandlers.setupDragAndDrop();
      }
    },

    setupKeyboardShortcuts() {
      if (window.EventHandlers) {
        return EventHandlers.setupKeyboardShortcuts();
      }
    },

    // ID Search functionality (for objects page)
    performIdSearch(searchValue) {
      const searchId = searchValue.trim();
      const resultDiv = document.querySelector('#id-search-result');
      
      if (!searchId) {
        this.clearIdSearch();
        return;
      }

      const searchNumber = parseInt(searchId, 10);
      if (isNaN(searchNumber)) {
        if (resultDiv) {
          resultDiv.innerHTML = 'âŒ Veuillez saisir un numÃ©ro valide';
          resultDiv.style.color = '#dc2626';
        }
        return;
      }

      // Find object by number
      const allObjects = window.OBJETS?.objets || [];
      const foundObject = allObjects.find(obj => obj.numero === searchNumber);

      if (!foundObject) {
        if (resultDiv) {
          resultDiv.innerHTML = `âŒ Aucun objet trouvÃ© avec l'ID ${searchNumber}`;
          resultDiv.style.color = '#dc2626';
        }
        // Hide all objects
        this.hideAllObjects();
        return;
      }

      // Set global flag BEFORE regenerating page
      window.activeIdSearch = true;

      // Immediately hide the container to prevent flash
      const container = document.querySelector('#objets-container');
      if (container) {
        container.style.visibility = 'hidden';
      }

      // Show success message immediately
      if (resultDiv) {
        resultDiv.innerHTML = `âœ… Objet trouvÃ© : "${foundObject.nom}" (ID: ${searchNumber})`;
        resultDiv.style.color = '#16a34a';
      }

      // Force regenerate page with all objects AND visual feedback
      if (JdrApp.modules.renderer?.regenerateCurrentPage) {
        JdrApp.modules.renderer.regenerateCurrentPage();
      }

      // After regeneration, configure display and show only target object
      requestAnimationFrame(() => {
        const newContainer = document.querySelector('#objets-container');
        if (newContainer) {
          // Hide all objects first
          this.hideAllObjects();
          
          // Show only the target object and make container visible again
          setTimeout(() => {
            this.showOnlyObjectById(searchNumber);
            newContainer.style.visibility = 'visible';
            
            // Restore the search value in the input field
            const searchInput = document.querySelector('#id-search-input');
            if (searchInput) {
              searchInput.value = searchNumber;
            }
          }, 10);
        }
      });
    },

    clearIdSearch() {
      const input = document.querySelector('#id-search-input');
      const resultDiv = document.querySelector('#id-search-result');
      
      if (input) {
        input.value = '';
      }
      
      if (resultDiv) {
        resultDiv.innerHTML = '';
      }
      
      // Clear the global flag
      window.activeIdSearch = false;
      
      // Show all objects again
      this.showAllObjects();
    },

    hideAllObjects() {
      document.querySelectorAll('.card').forEach(card => {
        card.style.display = 'none';
      });
    },

    showAllObjects() {
      document.querySelectorAll('.card').forEach(card => {
        card.style.display = '';
      });
    },

    showOnlyObjectById(searchNumber) {
      this.hideAllObjects();
      
      // Show only the target object
      const targetCard = document.querySelector(`[data-object-id="${searchNumber}"]`);
      if (targetCard) {
        targetCard.style.display = '';
        targetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }
  };

  // Auto-initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      JdrApp.modules.ui.init();
    });
  } else {
    // DOM is already loaded
    JdrApp.modules.ui.init();
  }

})();
// ============================================================================
// JSPDF LOADER - Character Sheet PDF Generation Support
// ============================================================================

(() => {
  "use strict";

  // Check if jsPDF is already loaded
  if (window.jsPDF) {
    return;
  }

  // For standalone builds, we need to handle jsPDF loading
  const loadJsPDF = () => {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
      script.onload = () => {
        resolve();
      };
      script.onerror = () => {
        console.error('âŒ Failed to load jsPDF');
        reject();
      };
      document.head.appendChild(script);
    });
  };

  // Load jsPDF if not available
  if (typeof window.jsPDF === 'undefined') {
    loadJsPDF().catch(() => {
      // Silent fallback - PDF generation will not be available
    });
  }

})();

</script>

<!-- PWA Service Worker (Embedded) -->
<script>
// Create dynamic manifest for PWA - Protocol-aware
if (window.MANIFEST_DATA) {
  let manifest = JSON.parse(JSON.stringify(window.MANIFEST_DATA));
  
  // Only modify manifest for file:// protocol
  if (window.location.protocol === 'file:') {
    manifest.start_url = window.location.href;
    manifest.scope = window.location.href;
    
    // Create a simple SVG icon that works with file:// protocol
    const simpleIcon = 'data:image/svg+xml;base64,' + btoa('<svg xmlns="http://www.w3.org/2000/svg" width="144" height="144" viewBox="0 0 144 144"><rect width="144" height="144" fill="#f4f0e6" rx="16"/><rect x="24" y="30" width="96" height="84" fill="#fff" stroke="#8b4513" stroke-width="2" rx="4"/><line x1="36" y1="50" x2="108" y2="50" stroke="#8b4513" stroke-width="2"/><line x1="36" y1="70" x2="108" y2="70" stroke="#8b4513" stroke-width="2"/><line x1="36" y1="90" x2="90" y2="90" stroke="#8b4513" stroke-width="2"/><circle cx="120" cy="24" r="4" fill="#d4af37"/></svg>');
    
    manifest.icons = [
      {
        "src": simpleIcon,
        "sizes": "144x144",
        "type": "image/svg+xml",
        "purpose": "any"
      },
      {
        "src": simpleIcon,
        "sizes": "192x192", 
        "type": "image/svg+xml",
        "purpose": "any"
      },
      {
        "src": simpleIcon,
        "sizes": "512x512",
        "type": "image/svg+xml", 
        "purpose": "any"
      }
    ];
    
    // Remove problematic elements for file:// 
    manifest.shortcuts = [];
    delete manifest.screenshots;
    console.log('ğŸ“± PWA manifest adapted for file:// protocol');
  } else {
    // For HTTPS - use original manifest as-is
    console.log('ğŸ“± PWA using original manifest for HTTPS');
  }
  
  // Create manifest blob and URL
  const manifestBlob = new Blob([JSON.stringify(manifest)], { type: 'application/json' });
  const manifestUrl = URL.createObjectURL(manifestBlob);
  
  // Inject manifest link dynamically
  const manifestLink = document.createElement('link');
  manifestLink.rel = 'manifest';
  manifestLink.href = manifestUrl;
  document.head.appendChild(manifestLink);
  
  console.log('ğŸ“± PWA manifest injected');
}

// Service Worker only works on HTTPS or localhost
const canUseServiceWorker = 'serviceWorker' in navigator && 
  (window.location.protocol === 'https:' || 
   window.location.hostname === 'localhost' ||
   window.location.hostname === '127.0.0.1');

if (canUseServiceWorker) {
  // Service Worker Registration - use external file only
  const swUrl = '/sw.js';

  // Progressive Web App - Service Worker Registration
  window.addEventListener('load', () => {
    navigator.serviceWorker.register(swUrl)
      .then((registration) => {
        console.log('âœ… Service Worker registered successfully:', registration);
        
        // Check for updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          if (newWorker) {
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                // New content available, notify user
                if (window.JdrApp && JdrApp.modules && JdrApp.modules.ui) {
                  JdrApp.modules.ui.showNotification('ğŸ”„ Nouvelle version disponible ! Rechargez la page.', 'info');
                }
              }
            });
          }
        });
      })
      .catch((error) => {
        console.log('âŒ Service Worker registration failed:', error);
      });
  });

  // Listen for app install prompt
  let deferredPrompt;
  window.addEventListener('beforeinstallprompt', (e) => {
    console.log('ğŸ’¾ PWA install prompt available');
    e.preventDefault();
    deferredPrompt = e;
    
    // Show install button or notification
    if (window.JdrApp && JdrApp.modules && JdrApp.modules.ui) {
      JdrApp.modules.ui.showNotification('ğŸ“± Installer JDR-BAB sur votre appareil ?', 'info');
    }
  });

  // Track install success
  window.addEventListener('appinstalled', (e) => {
    console.log('âœ… PWA was installed successfully');
    if (window.JdrApp && JdrApp.modules && JdrApp.modules.ui) {
      JdrApp.modules.ui.showNotification('âœ… JDR-BAB installÃ© avec succÃ¨s !', 'success');
    }
    deferredPrompt = null;
  });
} else {
  console.log('âš ï¸ Service Worker not available (requires HTTPS)');
  console.log('ğŸ’¡ For full PWA features, serve via HTTPS server');
}

// PWA Display Mode Detection
if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone) {
  console.log('ğŸ“± Running as PWA');
  document.body.classList.add('pwa-mode');
}

// Basic PWA install prompt for non-HTTPS environments
if (!canUseServiceWorker && window.MANIFEST_DATA) {
  console.log('ğŸ’¡ Limited PWA support without Service Worker');
  console.log('ğŸ“± Try: Add to Home Screen (mobile) or Install App (desktop)');
}
</script>
</body>
</html>