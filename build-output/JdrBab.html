<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta name="referrer" content="no-referrer-when-downgrade">
<!-- Generated on 2025-09-12T15:49:04.406Z by JdrBab Build System -->
<title>JDR‑BAB — Livret de règles</title>
<meta content="Livret web multipages des règles JDR‑BAB, thème parchemin, illustrations par catégorie/classe/sous‑classe, export HTML autonome." name="description">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&amp;family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600&amp;display=swap" rel="stylesheet">

<!-- PWA Configuration - Manifest embedded as JSON -->
<script>
// Embed manifest for PWA functionality
window.MANIFEST_DATA = {
  "name": "JDR-BAB - Livret de règles",
  "short_name": "JDR-BAB",
  "description": "Livret web multipages des règles JDR-BAB, thème parchemin, illustrations par catégorie/classe/sous-classe",
  "version": "1.0.0",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#f4f0e6",
  "theme_color": "#8b4513",
  "orientation": "any",
  "scope": "/",
  "lang": "fr",
  "categories": ["games", "entertainment", "productivity"],
  "icons": [
    {
      "src": "../assets/pwa/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "../assets/pwa/icon-96x96.png",
      "sizes": "96x96",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "../assets/pwa/icon-144x144.png",
      "sizes": "144x144",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "../assets/pwa/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any"
    },
    {
      "src": "../assets/pwa/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any"
    }
  ],
  "shortcuts": [
    {
      "name": "Création de personnage",
      "short_name": "Création",
      "description": "Accéder directement à la création de personnage",
      "url": "/#/creation",
      "icons": [
        {
          "src": "../assets/pwa/icon-96x96.png",
          "sizes": "96x96",
          "type": "image/png"
        }
      ]
    },
    {
      "name": "Classes",
      "short_name": "Classes",
      "description": "Consulter les classes de personnage",
      "url": "/#/classes",
      "icons": [
        {
          "src": "../assets/pwa/icon-96x96.png",
          "sizes": "96x96",
          "type": "image/png"
        }
      ]
    },
    {
      "name": "Sorts",
      "short_name": "Sorts",
      "description": "Consulter la liste des sorts",
      "url": "/#/sorts",
      "icons": [
        {
          "src": "../assets/pwa/icon-96x96.png",
          "sizes": "96x96",
          "type": "image/png"
        }
      ]
    },
    {
      "name": "Dons",
      "short_name": "Dons",
      "description": "Consulter la liste des dons",
      "url": "/#/dons",
      "icons": [
        {
          "src": "../assets/pwa/icon-96x96.png",
          "sizes": "96x96",
          "type": "image/png"
        }
      ]
    }
  ]
};
</script>
<meta name="theme-color" content="#8b4513">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="default">
<meta name="apple-mobile-web-app-title" content="JDR-BAB">
<meta name="application-name" content="JDR-BAB">
<meta name="msapplication-TileColor" content="#8b4513">

<!-- Favicon (embedded SVG) -->
<link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgd2lkdGg9IjUxMi4wMDAwMDBwdCIgaGVpZ2h0PSI1MTIuMDAwMDAwcHQiIHZpZXdCb3g9IjAgMCA1MTIuMDAwMDAwIDUxMi4wMDAwMDAiIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaWRZTWlkIG1lZXQiPg0KPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMC4wMDAwMDAsNTEyLjAwMDAwMCkgc2NhbGUoMC4xMDAwMDAsLTAuMTAwMDAwKSIgZmlsbD0iIzhiNDUxMyIgc3Ryb2tlPSJub25lIj4NCjxwYXRoIGQ9Ik0yMTQwIDUxMTAgYy0yODYgLTI3IC01NzEgLTExMyAtODI1IC0yNDkgLTcyMSAtMzg3IC0xMTc3IC0xMDcyIC0xMjcyIC0xOTExIC0yNiAtMjMwIC0xNSAtNTE1IDI1IC03MTAgMTY1IC04MDEgNjgwIC0xNDQ2IDE0MjIgLTE3ODAgMjM4IC0xMDcgNDQ5IC0xNjQgNzIwIC0xOTUgMTM5IC0xNiA0ODEgLTYgNjIwIDE4IDcyNiAxMjcgMTM1NiA1NjMgMTczNSAxMjAyIDI0NCA0MTEgMzY0IDg1OCAzNjQgMTM1NSAwIDM0NyAtNTUgNjQ3IC0xNzkgOTc1IC0zMzkgOTAwIC0xMDg0IDE0ODkgLTIwMTUgMTU5NCAtMTE5IDEzIC00NzYgMTQgLTU5NSAxeiBtNTgwIC00NTkgYzY2MyAtMTAxIDEyMzUgLTUyMyAxNTMwIC0xMTI5IDExOSAtMjQ0IDE3OCAtNDc1IDE4NyAtNzMyIDIxIC01OTEgLTE4NiAtMTE1MSAtNTgyIC0xNTc1IC0zOTYgLTQyNCAtOTI0IC02NzUgLTE1MDUgLTcxNSAtMTQ4IC0xMCAtNDEwIC00IC01NDUgMTMgLTU5MSA3NCAtMTEyMyAzNzkgLTE0OTEgODU1IC0yNDQgMzE2IC0zOTggNjgyIC00NjQgMTEwMiAtMjIgMTQwIC0yNSA0MTAgLTYgNTQ1IDc0IDUzMCAyOTMgOTg2IDY1MSAxMzU1IDQyNCA0MzcgOTg1IDY5MCAxNjE1IDcyOCA4MyA1IDUyNyAtMyA2MTAgLTEyeiIvPg0KPHBhdGggZD0iTTIyOTggNDQ1NCBjLTUgLTQgLTggLTIxIC04IC0zOCAwIC0yNyAtNCAtMzEgLTMyIC0zNCAtNDMgLTUgLTY4IC0zNiAtNjggLTg1IDAgLTQ5IDI1IC04MCA2OCAtODUgMjggLTMgMzIgLTcgMzIgLTM0IDAgLTE3IDMgLTM0IDggLTM4IDExIC0xMSA2MiAtMTEgNzMgMCA1IDQgOCAyMSA4IDM4IDAgMjcgNCAzMSAzMiAzNCA0MyA1IDY4IDM2IDY4IDg1IDAgNDkgLTI1IDgwIC02OCA4NSAtMjggMyAtMzIgNyAtMzIgMzQgMCAxNyAtMyAzNCAtOCAzOCAtMTEgMTEgLTYyIDExIC03MyAweiIvPg0KPHBhdGggZD0iTTE4NzAgMzk4MCBjLTYwIC02MCAtNCAtMTYwIDgyIC0xNDggMzggNSA2OCAzNSA2OCA2OCAwIDMzIC0zMCA2MyAtNjggNjggLTE5IDIgLTQyIC0zIC01NyAtMTIgLTIwIC0xMiAtMjUgLTEyIC0yNSA0eiIvPg0KPHBhdGggZD0iTTI3MjAgMzk4MCBjLTE1IC0xNSAtMjAgLTMzIC0yMCAtNzAgMCAtNTAgMyAtNTQgMzUgLTY4IDQ5IC0yMiA5NSAtNSAxMTcgNDIgMzIgNjggLTIxIDEzNiAtOTQgMTIwIC0xOSAtNCAtMjggLTEgLTM4IDE0eiIvPg0KPC9nPg0KPC9zdmc+">
<style>
/* —— Thème Heroic Fantasy - Enhanced Parchment —— */
:root{
  --paper:#f4f0e6;        /* parchemin ancien */
  --paper-ink:#2c1810;    /* encre noire profonde */
  --paper-muted:#8b6f47;  /* bronze ancien */
  --accent:#d4af37;       /* accent doré pour backgrounds */
  --accent-ink:#4a2c17;   /* titres sombres */
  --rule:#d4c4a8;         /* bordures dorées */
  --card:#faf6ee;         /* cartes parchemin */
  --link:#8b4513;         /* liens cuivre */
  --gold:#d4af37;         /* or */
  --bronze:#cd7f32;       /* bronze */
  --shadow:0 8px 32px rgba(0,0,0,.15), 0 2px 8px rgba(139,69,19,.1);
  --card-shadow:0 6px 20px rgba(0,0,0,.1), 0 2px 6px rgba(139,69,19,.08);
  --image-border:3px solid #8b4513;
  --image-shadow:0 4px 12px rgba(0,0,0,.2), inset 0 1px 2px rgba(212,175,55,.3);
  
  /* Enhanced Parchment Textures */
  --parchment-texture: 
    radial-gradient(circle at 20% 80%, rgba(139,69,19,.03) 0%, transparent 50%),
    radial-gradient(circle at 80% 20%, rgba(212,175,55,.02) 0%, transparent 50%),
    radial-gradient(circle at 40% 40%, rgba(139,69,19,.01) 0%, transparent 30%),
    linear-gradient(45deg, rgba(139,69,19,.005) 25%, transparent 25%),
    linear-gradient(-45deg, rgba(212,175,55,.005) 25%, transparent 25%);
    
  --parchment-border:
    linear-gradient(45deg, 
      rgba(139,69,19,.8) 0%, 
      rgba(212,175,55,.6) 25%, 
      rgba(139,69,19,.4) 50%, 
      rgba(212,175,55,.6) 75%, 
      rgba(139,69,19,.8) 100%);
      
  --aged-paper: 
    radial-gradient(ellipse at top left, rgba(139,69,19,.04), transparent 60%),
    radial-gradient(ellipse at top right, rgba(212,175,55,.03), transparent 60%),
    radial-gradient(ellipse at bottom left, rgba(139,69,19,.02), transparent 60%),
    radial-gradient(ellipse at bottom right, rgba(212,175,55,.025), transparent 60%);
  
  /* Enhanced Element Colors System - Improved Contrast & Accessibility */
  --feu:#e63946; --feu-bg:rgba(230,57,70,.12); --feu-border:rgba(230,57,70,.4);
  --air:#457b9d; --air-bg:rgba(69,123,157,.12); --air-border:rgba(69,123,157,.4);
  --eau:#1d3557; --eau-bg:rgba(29,53,87,.12); --eau-border:rgba(29,53,87,.4);
  --terre:#6f4e37; --terre-bg:rgba(111,78,55,.12); --terre-border:rgba(111,78,55,.4);
  --divin:#f1c40f; --divin-bg:rgba(241,196,15,.12); --divin-border:rgba(241,196,15,.4);
  --malefique:#6a2c70; --malefique-bg:rgba(106,44,112,.12); --malefique-border:rgba(106,44,112,.4);
  
  /* Spacing system */
  --space-xs:4px; --space-sm:6px; --space-md:8px; --space-lg:12px; --space-xl:16px; --space-2xl:24px;
  
  /* Common transitions */
  --transition-fast:.2s ease; --transition-normal:.3s ease; --transition-slow:.5s ease;
}

/* Enhanced Accessibility & High Contrast Support */
@media (prefers-color-scheme: dark) { 
  :root{ 
    --paper:#f4f0e6; /* Keep light theme for fantasy aesthetic */
    --card:#faf6ee; 
    --paper-ink:#2c1810; 
  } 
}

@media (prefers-contrast: high) {
  :root {
    --paper-ink: #000000;
    --accent-ink: #1a0d08;
    --bronze: #8b4513;
    --gold: #b8860b;
    --rule: #8b4513;
  }
  
  .card, .card-base {
    border-width: 3px;
  }
  
  .btn-base {
    border-width: 3px;
  }
}

/* Base styles */
html,body{height:100%; overflow-x:hidden} /* Prevent horizontal scroll */
body{
  margin:0;
  background:
    radial-gradient(1600px 800px at 50% -10%, rgba(212,175,55,.08), transparent 45%),
    radial-gradient(1400px 700px at 120% 10%, rgba(139,69,19,.06), transparent 40%),
    radial-gradient(800px 400px at 20% 80%, rgba(205,127,50,.04), transparent 30%),
    repeating-linear-gradient(90deg, rgba(74,44,23,.02) 0 1px, transparent 1px 3px),
    repeating-linear-gradient(0deg, rgba(139,69,19,.015) 0 1px, transparent 1px 4px),
    var(--paper);
  color:var(--paper-ink); 
  font:17px/1.65 "Source Serif Pro", "Cinzel", ui-serif, Georgia, Cambria, "Times New Roman", Times, serif; 
  -webkit-font-smoothing:antialiased; 
  text-rendering:optimizeLegibility;
}

/* ═══════════════════════════════════════════════════════════════════════════════════════
   🎨 ENHANCED TYPOGRAPHY SYSTEM - Centered & Harmonized
   ═══════════════════════════════════════════════════════════════════════════════════════ */

/* Link Styling */
a {
  color: var(--link);
  text-decoration: none;
  transition: all var(--transition-fast);
  position: relative;
}

a:hover {
  text-decoration: underline;
  color: var(--gold);
  text-shadow: 0 1px 3px rgba(212,175,55,0.3);
}

/* Text Emphasis */
strong, b {
  font-weight: 700;
  font-family: "Source Serif Pro", serif;
  color: var(--accent-ink);
  text-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

em, i {
  font-style: italic;
  font-weight: 400;
  color: var(--bronze);
}

/* Enhanced Headings System */
h1, h2, h3, h4, h5, h6 {
  font-family: "Cinzel", "Trajan Pro", ui-serif, Georgia, Cambria, Times, serif;
  color: var(--accent-ink);
  text-shadow: 2px 2px 4px rgba(0,0,0,.1);
  text-align: center;
  margin: 1.5rem auto 1rem;
  position: relative;
  line-height: 1.2;
  letter-spacing: 0.02em;
}

/* Main Title */
h1 {
  font-size: clamp(28px, 4.5vw, 48px);
  letter-spacing: 0.05em;
  margin: 2rem auto 1.5rem;
  font-weight: 700;
  background: linear-gradient(135deg, var(--gold), var(--bronze), var(--gold));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-shadow: none;
  position: relative;
}

h1::before {
  content: '◆';
  position: absolute;
  left: -20px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--gold);
  font-size: 0.6em;
  opacity: 0.7;
}

h1::after {
  content: '◆';
  position: absolute;
  right: -20px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--gold);
  font-size: 0.6em;
  opacity: 0.7;
}

/* Section Headings */
h2 {
  font-size: clamp(22px, 3.2vw, 32px);
  margin: 1.8rem auto 1.2rem;
  font-weight: 600;
  color: var(--bronze);
  position: relative;
}

h2::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 80px;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--bronze), transparent);
  opacity: 0.8;
}

/* Subsection Headings */
h3 {
  font-size: clamp(18px, 2.4vw, 26px);
  margin: 1.5rem auto 1rem;
  font-weight: 500;
  color: var(--accent-ink);
  position: relative;
}

h3::before {
  content: '※';
  position: absolute;
  left: -15px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--bronze);
  font-size: 0.8em;
  opacity: 0.6;
}

h3::after {
  content: '※';
  position: absolute;
  right: -15px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--bronze);
  font-size: 0.8em;
  opacity: 0.6;
}

/* Smaller Headings */
h4 {
  font-size: clamp(16px, 2vw, 20px);
  margin: 1.2rem auto 0.8rem;
  font-weight: 500;
  color: var(--paper-muted);
}

h5, h6 {
  font-size: clamp(14px, 1.8vw, 18px);
  margin: 1rem auto 0.6rem;
  font-weight: 500;
  color: var(--paper-muted);
}

/* Text Utilities */
.muted {
  color: var(--paper-muted);
  font-style: italic;
}

.lead {
  font-size: 18px;
  line-height: 1.6;
  text-align: center;
  margin: 1.5rem auto;
  color: var(--accent-ink);
  font-weight: 400;
}

/* Enhanced Separator Rule */
.rule {
  height: 3px;
  background: linear-gradient(90deg, 
    transparent, 
    var(--bronze), 
    var(--gold), 
    var(--bronze), 
    transparent);
  margin: 2rem auto;
  border-radius: 2px;
  opacity: 0.8;
  position: relative;
}

.rule::before {
  content: '❋';
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  background: var(--paper);
  color: var(--gold);
  padding: 0 8px;
  font-size: 14px;
}

/* Decorative Separators */
.separator-ornate {
  text-align: center;
  margin: 2.5rem auto;
  font-size: 1.5em;
  color: var(--gold);
  opacity: 0.7;
}

.separator-ornate::before {
  content: '◆ ❋ ◆';
}

/* Centered Text Blocks */
.text-center {
  text-align: center;
}

.text-center-block {
  text-align: center;
  margin: 1.5rem auto;
  max-width: 800px;
}

/* Mobile Typography Adjustments */
@media (max-width: 480px) {
  h1::before, h1::after,
  h3::before, h3::after {
    display: none;
  }
  
  .rule::before {
    font-size: 12px;
    padding: 0 6px;
  }
  
  .lead {
    font-size: 16px;
    margin: 1rem auto;
  }
}
/* === UTILITY CLASSES === */

/* Spacing utilities */
.m-0{margin:0} .m-1{margin:var(--space-xs)} .m-2{margin:var(--space-md)} .m-3{margin:var(--space-lg)} .m-4{margin:var(--space-xl)}
.mt-0{margin-top:0} .mt-1{margin-top:var(--space-xs)} .mt-2{margin-top:var(--space-md)} .mt-3{margin-top:var(--space-lg)}
.mb-0{margin-bottom:0} .mb-1{margin-bottom:var(--space-xs)} .mb-2{margin-bottom:var(--space-md)} .mb-3{margin-bottom:var(--space-lg)}
.p-0{padding:0} .p-1{padding:var(--space-xs)} .p-2{padding:var(--space-md)} .p-3{padding:var(--space-lg)} .p-4{padding:var(--space-xl)}

/* Flex utilities */
.flex{display:flex} .flex-col{flex-direction:column} .flex-wrap{flex-wrap:wrap}
.items-center{align-items:center} .items-start{align-items:flex-start} .items-end{align-items:flex-end}
.justify-center{justify-content:center} .justify-start{justify-content:flex-start} .justify-end{justify-content:flex-end}
.gap-1{gap:var(--space-xs)} .gap-2{gap:var(--space-md)} .gap-3{gap:var(--space-lg)}

/* Element color utilities */
.text-feu{color:var(--feu)} .text-air{color:var(--air)} .text-eau{color:var(--eau)} .text-terre{color:var(--terre)} .text-divin{color:var(--divin)} .text-malefique{color:var(--malefique)}
.bg-feu{background:var(--feu-bg);border-color:var(--feu-border)} .bg-air{background:var(--air-bg);border-color:var(--air-border)}
.bg-eau{background:var(--eau-bg);border-color:var(--eau-border)} .bg-terre{background:var(--terre-bg);border-color:var(--terre-border)}
.bg-divin{background:var(--divin-bg);border-color:var(--divin-border)} .bg-malefique{background:var(--malefique-bg);border-color:var(--malefique-border)}

/* Grid utilities */
.grid{display:grid;gap:var(--space-lg)}
.cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}
.cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}
@media (max-width: 900px){ .cols-3{grid-template-columns:1fr} }
@media (max-width: 768px){ .cols-2{grid-template-columns:1fr !important} }

/* Misc utilities */
.subclass-stack{display:flex;flex-direction:column;gap:var(--space-lg)}
.chip{font-size:14px;border:2px solid var(--rule);border-radius:999px;padding:6px 12px;background:rgba(155,107,47,.12);font-weight:600;box-shadow:0 2px 6px rgba(0,0,0,.1)}
.chips{display:flex;flex-wrap:wrap;gap:8px;justify-content:center}

/* Mobile-specific utilities for Game Master pages */
@media (max-width: 480px) {
  .mobile-stack { flex-direction: column !important; }
  .mobile-center { text-align: center !important; }
  .mobile-hide { display: none !important; }
  .mobile-full-width { width: 100% !important; }
  .mobile-touch-target { min-height: 44px !important; min-width: 44px !important; }
  .mobile-no-margin { margin-left: 0 !important; margin-right: 0 !important; }
  .mobile-wrap { flex-wrap: wrap !important; }
  .mobile-break-word { word-break: break-word !important; }
}
/* ═══════════════════════════════════════════════════════════════════════════════════════
   🏗️ LAYOUT SYSTEM - Enhanced Responsive Design
   ═══════════════════════════════════════════════════════════════════════════════════════ */

/* Main Shell Layout */
.shell {
  display: grid;
  grid-template-rows: 1fr auto;
  min-height: 100svh;
  position: relative;
  overflow-x: hidden; /* Prevent horizontal scroll on mobile */
}

/* Main Content Area - Enhanced Parchment Background */
.page {
  position: relative;
  min-height: 100vh;
  padding: 18px; /* Equal padding all around */
  transition: padding var(--transition-normal);
  background: 
    var(--parchment-texture),
    var(--aged-paper),
    var(--paper);
}

/* Content Container - Dynamic Centering (handled by JavaScript) */
#views {
  max-width: 1400px;
  /* Fallback positioning - will be overridden by DynamicCentering.js */
  margin-left: 0; /* Reset to 0 - will be handled by responsive design */
  margin-right: 20px;
  padding: 0 var(--space-lg);
  animation: fadeInUp 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

/* Desktop layout with sidebar */
@media (min-width: 1025px) {
  #views {
    margin-left: 370px; /* Only apply sidebar margin on large screens */
  }
}

/* Mobile Responsiveness */
@media (max-width: 980px) { 
  .page {
    padding: 12px;
    background: var(--paper);
  }
  
  #views {
    margin-left: 0; /* Reset sidebar margin on mobile */
    margin-right: 0;
    padding: 0 var(--space-md);
    max-width: 100%;
  }
}

/* ─────────────────────────── Enhanced Sidebar Navigation ─────────────────────────── */
.sidebar {
  position: fixed;
  top: 0;
  left: 0;
  width: 350px;
  height: 100vh;
  overflow-y: auto;
  overflow-x: hidden;
  z-index: 100;
  background: 
    var(--parchment-texture),
    linear-gradient(180deg, var(--paper), rgba(244,240,230,0.95)),
    var(--aged-paper);
  backdrop-filter: blur(8px);
  border-right: 4px solid transparent;
  border-image: var(--parchment-border) 1;
  box-shadow: 
    4px 0 20px rgba(0,0,0,0.08),
    inset -1px 0 0 rgba(212,175,55,0.1);
  transition: transform var(--transition-normal);
}

.sidebar::before {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  width: 2px;
  height: 100%;
  background: linear-gradient(180deg, 
    var(--gold) 0%, 
    var(--bronze) 50%, 
    var(--gold) 100%);
  opacity: 0.6;
}

/* Mobile and Tablet Sidebar with Collapsible Navigation */
@media (max-width: 1024px) { 
  .sidebar {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100vh;
    height: 100dvh; /* Dynamic viewport height for better mobile support */
    min-height: 100vh;
    min-height: 100dvh;
    background: 
      linear-gradient(135deg, var(--card), rgba(244,240,230,0.98)),
      radial-gradient(circle at 50% 30%, rgba(212,175,55,0.05), transparent 70%);
    border-right: none;
    border-bottom: 3px solid var(--rule);
    backdrop-filter: blur(8px);
    box-shadow: 
      0 8px 32px rgba(0,0,0,0.15),
      inset 0 -1px 0 rgba(212,175,55,0.1);
    transform: translateY(-100%);
    transition: transform var(--transition-normal);
    z-index: 200;
    overflow: hidden; /* Prevent sidebar itself from scrolling */
  }
  
  .sidebar.mobile-open {
    transform: translateY(0);
  }
  
  /* Adjust page layout for mobile and tablet */
  .page {
    padding: 80px 12px 12px 12px; /* Top padding for mobile nav button */
  }
  
  /* Ensure content uses full width on tablet */
  #views {
    margin-left: 0 !important;
    margin-right: 0 !important;
    max-width: 100% !important;
    padding: 0 var(--space-md) !important;
  }
  
  .sidebar::before {
    display: none;
  }
  
  /* Mobile Navigation Toggle Button */
  .mobile-nav-toggle {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 300;
    background: linear-gradient(135deg, var(--gold), var(--bronze));
    color: white;
    border: 2px solid var(--rule);
    border-radius: 12px;
    padding: 12px 16px;
    cursor: pointer;
    box-shadow: 
      0 6px 20px rgba(0,0,0,.15),
      inset 0 1px 0 rgba(255,255,255,.2);
    transition: all var(--transition-fast);
    font-family: 'Cinzel', serif;
    font-weight: 600;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 44px;
    min-height: 44px;
    justify-content: center;
  }
  
  .mobile-nav-toggle:hover {
    transform: scale(1.05);
    box-shadow: 
      0 8px 25px rgba(0,0,0,.2),
      inset 0 1px 0 rgba(255,255,255,.3);
  }
  
  .mobile-nav-toggle:active {
    transform: scale(0.98);
  }
  
  .mobile-nav-toggle .icon {
    font-size: 16px;
    transition: transform var(--transition-fast);
  }
  
  .mobile-nav-toggle.open .icon {
    transform: rotate(180deg);
  }
  
  /* Hide toggle on desktop */
  @media (min-width: 1025px) {
    .mobile-nav-toggle {
      display: none;
    }
  }
}
/* ─────────────────────────── Enhanced Panel System ─────────────────────────── */
.panel {
  background: 
    linear-gradient(135deg, var(--card), rgba(250,246,238,0.9)),
    radial-gradient(circle at 20% 30%, rgba(212,175,55,0.03), transparent 70%);
  border: 2px solid var(--rule);
  border-radius: 18px;
  box-shadow: 
    var(--card-shadow),
    inset 0 1px 0 rgba(255,255,255,0.1);
  padding: 18px;
  position: relative;
  overflow: hidden;
  margin: 12px;
  transition: all var(--transition-normal);
  backdrop-filter: blur(2px);
}

.panel::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, 
    transparent, 
    var(--gold), 
    var(--bronze), 
    var(--gold), 
    transparent);
  opacity: .6;
}

.panel::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--bronze), transparent);
  opacity: .3;
}

.panel:hover {
  transform: translateY(-1px);
  box-shadow: 
    0 8px 32px rgba(0,0,0,.12),
    0 2px 8px rgba(139,69,19,.1),
    inset 0 1px 0 rgba(255,255,255,.15);
}

/* Table of Contents - Full height sidebar OVERRIDE */
.sidebar .panel {
  height: calc(100vh - 24px) !important; /* Full height minus margin - FORCE */
  margin: 12px !important;
  padding: 18px !important; /* Keep original panel padding */
  display: flex !important;
  flex-direction: column !important;
  overflow: hidden !important;
  box-sizing: border-box !important;
}

.sidebar .panel .searchbar {
  flex-shrink: 0 !important; /* Don't shrink searchbar */
  margin-bottom: 16px !important;
}

.sidebar .panel .tools {
  flex-shrink: 0 !important; /* Don't shrink tools */
  margin: 0 0 16px 0 !important;
}

.toc {
  flex: 1 !important; /* Take all remaining space - FORCE */
  overflow-y: auto !important;
  overflow-x: hidden !important;
  scrollbar-width: thin;
  scrollbar-color: var(--bronze) transparent;
  padding-right: 4px;
  min-height: 0 !important; /* Allow flex shrinking */
}

/* Tablet/Mobile TOC */
@media (max-width: 1024px) {
  .sidebar .panel {
    height: 100% !important; /* Use full sidebar height */
    min-height: 100% !important;
    margin: 0 !important; /* Remove margins for full coverage */
    border-radius: 0 !important; /* Remove rounded corners for edge-to-edge */
    display: flex !important;
    flex-direction: column !important;
    overflow: hidden !important;
    box-sizing: border-box !important;
  }
  
  .sidebar .panel .searchbar,
  .sidebar .panel .tools {
    flex-shrink: 0 !important; /* Keep fixed size for controls */
    margin: 12px !important; /* Add margin back to controls only */
  }
  
  .toc {
    flex: 1 !important; /* Take all remaining space */
    overflow-y: auto !important;
    overflow-x: hidden !important;
    min-height: 0 !important;
    margin: 0 12px 12px 12px !important; /* Add margin to TOC content only */
  }
}

.toc::-webkit-scrollbar {
  width: 6px;
}

.toc::-webkit-scrollbar-track {
  background: transparent;
}

.toc::-webkit-scrollbar-thumb {
  background: var(--bronze);
  border-radius: 3px;
}

.toc::-webkit-scrollbar-thumb:hover {
  background: var(--gold);
}

/* ─────────────────────────── Enhanced TOC Styling ─────────────────────────── */
.toc h4 {
  margin: 8px 10px 12px;
  color: var(--bronze);
  text-transform: uppercase;
  font-size: 13px;
  letter-spacing: 0.15em;
  font-weight: 700;
  font-family: 'Cinzel', serif;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
  position: relative;
  padding-bottom: 6px;
  text-align: center;
}

.toc h4::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 2px;
  background: linear-gradient(90deg, var(--bronze), transparent);
  border-radius: 1px;
}

/* Hierarchical TOC Sections */
.toc-section {
  margin-bottom: 8px;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid rgba(139,69,19,0.1);
  background: linear-gradient(135deg, 
    rgba(255,248,220,0.3) 0%, 
    rgba(212,175,55,0.05) 100%);
}

.toc-section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 12px;
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.15) 0%, 
    rgba(139,69,19,0.08) 100%);
  cursor: pointer;
  transition: all var(--transition-normal);
  border-bottom: 1px solid rgba(139,69,19,0.1);
}

.toc-section-header:hover {
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.25) 0%, 
    rgba(139,69,19,0.15) 100%);
  transform: translateY(-1px);
}

.toc-section-title {
  font-weight: 600;
  font-family: 'Cinzel', serif;
  color: var(--bronze);
  font-size: 14px;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
}

.toc-section-toggle {
  color: var(--bronze);
  font-size: 12px;
  transition: transform var(--transition-normal);
  opacity: 0.7;
}

.toc-section.collapsed .toc-section-toggle {
  transform: rotate(-90deg);
}

.toc-section-content {
  padding: 6px;
  max-height: none; /* Permettre l'expansion automatique par défaut */
  overflow: visible;
  transition: max-height var(--transition-normal), opacity var(--transition-normal);
}

.toc-section-content .toc-category {
  /* Remove scroll limits - let everything be visible naturally */
  max-height: none;
  overflow: visible;
}

.toc-section.collapsed .toc-section-content {
  max-height: 0 !important;
  opacity: 0 !important;
  padding-top: 0;
  padding-bottom: 0;
  overflow: hidden;
}
.toc a {
  display: flex;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 12px;
  color: inherit;
  border: 2px solid transparent;
  transition: all var(--transition-normal);
  position: relative;
  overflow: hidden;
  font-weight: 500;
  margin: 2px 0;
  backdrop-filter: blur(1px);
}
.toc a::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, 
    transparent, 
    rgba(212,175,55,.2), 
    rgba(139,69,19,.1), 
    transparent);
  transition: left 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  z-index: 0;
}
.toc a:hover {
  transform: translateX(6px) scale(1.02);
  background: 
    linear-gradient(135deg, rgba(212,175,55,.12), rgba(139,69,19,.08));
  border-color: rgba(139,69,19,.4);
  box-shadow: 
    0 6px 20px rgba(139,69,19,.2),
    inset 0 1px 3px rgba(212,175,55,.25),
    inset 0 -1px 1px rgba(139,69,19,.1);
  color: var(--accent-ink);
}

.toc a:hover::before {
  left: 100%;
}
.toc a > *{position:relative; z-index:1}
.toc a.active {
  background: linear-gradient(135deg, 
    rgba(212,175,55,.18), 
    rgba(139,69,19,.12));
  border-color: var(--gold);
  box-shadow: 
    inset 0 2px 6px rgba(212,175,55,.3),
    inset 0 -1px 2px rgba(139,69,19,.2),
    0 2px 8px rgba(139,69,19,.1);
  transform: translateX(4px) scale(1.01);
  color: var(--accent-ink);
  font-weight: 600;
}
.toc-category{margin:0}
.toc-category > a{position:relative; cursor:pointer}
.toc-category > a::after{content:'▼'; position:absolute; right:8px; top:50%; transform:translateY(-50%); 
                         font-size:10px; transition:transform .3s ease; color:var(--bronze)}
.toc-category.collapsed > a::after{transform:translateY(-50%) rotate(-90deg)}
.toc-sub{margin-left:24px;border-left:2px solid var(--rule);padding-left:8px; 
         overflow:hidden; transition:all .3s ease}
.toc-category.collapsed .toc-sub{max-height:0; opacity:0; padding-top:0; padding-bottom:0; margin-top:0; margin-bottom:0}
.toc-category:not(.collapsed) .toc-sub{max-height: none; opacity:1}
.toc-sub a{font-size:14px;padding:6px 8px; margin-left:4px}
.toc-sub a:hover{transform:translateX(6px); margin-left:0}

/* Outils latéraux */
.tools{display:flex;gap:var(--space-md);flex-wrap:wrap;margin:var(--space-md) 0}

/* Article and section layout */
article{display:none}
article.active{display:block}
section{background:var(--card);border:1px solid var(--rule);border-radius:14px;box-shadow:var(--shadow);padding:18px;margin:0 0 14px}

/* Footer */
footer{padding:24px;text-align:center;color:var(--paper-muted)}

/* Print styles */
@media print{ 
  .sidebar, .tools{display:none} 
  .page{grid-template-columns:1fr;padding:0} 
  section{break-inside:avoid;box-shadow:none} 
}

/* PWA Mode Styles */
.pwa-mode {
  /* Remove any browser chrome when running as PWA */
  -webkit-user-select: none;
  user-select: none;
}

.pwa-mode input, .pwa-mode textarea {
  -webkit-user-select: auto;
  user-select: auto;
}

/* PWA display mode detection */
@media (display-mode: standalone) {
  body {
    /* App-like appearance when installed */
    background: var(--paper);
  }
  
  /* Hide any web-specific elements in PWA mode */
  .web-only {
    display: none !important;
  }
  
  /* Enhance touch targets for PWA */
  button, .btn, .toc a {
    min-height: 44px;
    min-width: 44px;
  }
}

/* ========================================
   🎯 GAME MASTER PAGES - MOBILE FIXES
   ======================================== */

/* Monster Cards - Responsive Stats Grid */
@media (max-width: 480px) {
  .card[data-section-type="monster"] .monster-stats-grid,
  .monster-stats-grid {
    display: grid !important;
    grid-template-columns: 1fr !important;
    gap: 0.5rem !important;
    font-size: 0.85em !important;
  }
  
  .card[data-section-type="monster"] .monster-elemental-grid,
  .monster-elemental-grid {
    display: grid !important;
    grid-template-columns: 1fr 1fr !important;
    gap: 0.3rem !important;
    font-size: 0.75em !important;
  }
  
  .card[data-section-type="monster"] .tag-chip,
  .monster-card .tag-chip {
    display: inline-block !important;
    margin: 2px 4px 2px 0 !important;
    font-size: 0.75em !important;
    padding: 1px 4px !important;
  }
}

/* Treasure Tables - Responsive Fourchettes */
@media (max-width: 480px) {
  .fourchette-row,
  .responsive-fourchette {
    display: flex !important;
    flex-direction: column !important;
    align-items: flex-start !important;
    justify-content: flex-start !important;
    gap: 8px !important;
  }
  
  .fourchette-range {
    min-width: auto !important;
    margin-bottom: 4px !important;
  }
  
  .fourchette-objet {
    flex: none !important;
    margin-left: 0 !important;
    margin-bottom: 8px !important;
    word-break: break-word !important;
    width: 100% !important;
  }
  
  .fourchette-actions {
    margin-left: 0 !important;
    flex-wrap: wrap !important;
    gap: 6px !important;
    justify-content: flex-start !important;
    width: 100% !important;
  }
  
  .fourchette-actions button {
    font-size: 0.7em !important;
    padding: 4px 8px !important;
    min-height: 44px !important; /* Touch-friendly */
    min-width: 44px !important;
  }
}

/* Campaign Page - Responsive Selectors */
@media (max-width: 480px) {
  .campaign-selector > div,
  .campaign-controls {
    flex-direction: column !important;
    align-items: stretch !important;
    gap: 12px !important;
  }
  
  .campaign-selector select,
  .campaign-controls select {
    width: 100% !important;
    font-size: 16px !important; /* Prevents zoom on iOS */
    min-height: 44px !important;
    padding: 8px 12px !important;
  }
  
  .subpage-selector,
  .campaign-subpages {
    flex-direction: column !important;
    gap: 8px !important;
  }
  
  .subpage-selector button,
  .campaign-subpages button {
    width: 100% !important;
    min-height: 44px !important;
  }
}

/* Audio Page - Touch-Friendly Controls */
@media (max-width: 480px) {
  #audio-controls-page button,
  .audio-player button,
  .playlist-controls button {
    min-height: 44px !important;
    min-width: 44px !important;
    padding: 8px 12px !important;
    font-size: 14px !important;
  }
  
  .playlist-item,
  .audio-track {
    padding: 12px !important;
    margin: 8px 0 !important;
  }
  
  .audio-controls-grid {
    display: grid !important;
    grid-template-columns: 1fr !important;
    gap: 8px !important;
  }
}

/* General MJ Page Improvements */
@media (max-width: 768px) {
  /* Better button spacing for all MJ pages */
  .btn.danger,
  .btn.small,
  .edit-btn,
  .delete-btn {
    min-height: 44px;
    min-width: 44px;
    margin: 2px;
  }
  
  /* Responsive tables for all MJ content */
  .mj-table,
  .stats-table,
  .treasure-table {
    display: block;
    overflow-x: auto;
    white-space: nowrap;
  }
  
  .mj-table th,
  .mj-table td,
  .stats-table th,
  .stats-table td {
    min-width: 120px;
    padding: 8px 4px;
  }
}

/* ─────────────────────────── Enhanced Mobile & Tablet Responsiveness ─────────────────────────── */

/* Tablet Landscape (1024px and below) - Full width when TOC hidden */
@media (max-width: 1024px) {
  .sidebar {
    width: 320px;
  }
  
  .page {
    /* Remove fixed left padding - let content use full width when TOC is hidden */
    padding: 18px;
  }
  
  #views {
    margin-left: 0 !important; /* Always reset margin on tablet */
    margin-right: 0 !important;
    max-width: 100% !important;
    padding: 0 var(--space-md) !important;
  }
}

/* Tablet Portrait (768px and below) */
@media (max-width: 768px) {
  #views {
    margin-left: 0; /* Reset margins for tablet portrait */
    margin-right: 0;
  }
  
  .illus .thumb { 
    width: 100%; 
    max-width: 280px; 
    height: auto; 
  }
  
  .card, .card-base {
    margin: 1rem 0;
    padding: 16px;
  }
  
  .btn-base {
    padding: var(--space-sm) var(--space-md);
    font-size: 0.9em;
  }
  
  .filter-chips {
    gap: 0.5rem;
  }
  
  .filter-chip {
    padding: 6px 12px;
    font-size: 0.85em;
  }
}

/* Mobile (480px and below) - Standalone Version Optimized */
@media (max-width: 480px) {
  .page {
    padding: 8px;
  }
  
  #views {
    padding: 0 var(--space-sm);
  }
  
  .panel {
    margin: 8px;
    padding: 12px;
    border-radius: 12px;
  }
  
  .card, .card-base {
    padding: 12px;
    margin: 0.8rem 0;
    border-radius: 12px;
  }
  
  .spell-title {
    font-size: clamp(1rem, 3vw, 1.2rem) !important;
    margin: 0 0 0.8rem 0 !important;
  }
  
  .btn-base {
    padding: var(--space-sm);
    font-size: 0.85em;
    gap: var(--space-sm);
  }
  
  .filter-chips {
    gap: 0.4rem;
  }
  
  .filter-chip {
    padding: 4px 8px;
    font-size: 0.8em;
    border-radius: 16px;
  }
  
  /* Mobile-optimized images */
  .illus img {
    max-width: 100% !important;
    width: auto !important;
    height: auto !important;
  }
  
  .illus-spell img,
  .card .illus img {
    max-width: 240px !important;
    max-height: 180px !important;
  }
  
  /* Mobile TOC enhancements */
  .toc a {
    padding: 8px 10px;
    font-size: 0.9em;
  }
  
  .toc-sub a {
    padding: 6px 8px;
    font-size: 0.85em;
  }
  
  /* Mobile search optimizations */
  .searchbar {
    flex-direction: column;
    gap: var(--space-sm);
  }
  
  .searchbar input {
    width: 100%;
    font-size: 16px; /* Prevents zoom on iOS */
  }
  
  .search-results-grid {
    grid-template-columns: 1fr;
    gap: var(--space-md);
  }
  
  .search-result-card {
    min-height: 120px;
    padding: var(--space-md);
  }
}
/* ═══════════════════════════════════════════════════════════════════════════════════════
   🎨 COMPONENT SYSTEM - Modern Heroic Fantasy Design
   ═══════════════════════════════════════════════════════════════════════════════════════ */

/* ─────────────────────────── Typography Components ─────────────────────────── */
.spell-title {
  font-family: "Cinzel", serif !important;
  font-size: clamp(1.2rem, 2.5vw, 1.4rem) !important;
  background: linear-gradient(135deg, var(--gold), var(--bronze), var(--gold)) !important;
  -webkit-background-clip: text !important;
  -webkit-text-fill-color: transparent !important;
  background-clip: text !important;
  font-weight: 600 !important;
  text-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
  letter-spacing: 0.8px !important;
  text-transform: uppercase !important;
  text-align: center !important;
  margin: 0 0 1rem 0 !important;
  position: relative !important;
}

.spell-title::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 60px;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--gold), transparent);
  opacity: 0.7;
}

/* ─────────────────────────── Image Optimization Components ─────────────────────────── */
.lazy-load {
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
  background: #f0f0f0;
  min-height: 100px;
}

.lazy-loaded {
  opacity: 1;
}

/* Improve image rendering performance */
img {
  will-change: auto;
  transform: translateZ(0); /* Force GPU acceleration */
}

/* Placeholder for lazy loading */
.illus img[src*="data:image/svg+xml"] {
  background: linear-gradient(45deg, #f8f8f8 25%, transparent 25%), 
              linear-gradient(-45deg, #f8f8f8 25%, transparent 25%), 
              linear-gradient(45deg, transparent 75%, #f8f8f8 75%), 
              linear-gradient(-45deg, transparent 75%, #f8f8f8 75%);
  background-size: 20px 20px;
  background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
  animation: loading 2s infinite linear;
}

@keyframes loading {
  0% { background-position: 0 0, 0 10px, 10px -10px, -10px 0px; }
  100% { background-position: 20px 20px, 20px 30px, 30px 10px, 10px 20px; }
}

/* Loading Screen Components */
.loading-screen {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, #2c1810, #1a0f0a);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
  opacity: 1;
  transition: opacity 0.5s ease-out;
}

.loading-screen.fade-out {
  opacity: 0;
  pointer-events: none;
}

.loading-content {
  text-align: center;
  color: var(--gold);
  max-width: 300px;
  padding: 2rem;
}

.loading-content h2 {
  font-family: "Cinzel", serif;
  font-size: 2rem;
  margin: 1rem 0;
  color: var(--gold);
  text-shadow: 0 2px 4px rgba(0,0,0,0.5);
}

.loading-content p {
  color: var(--text-secondary);
  margin-bottom: 2rem;
}

.loading-spinner {
  width: 60px;
  height: 60px;
  border: 3px solid rgba(212, 175, 55, 0.3);
  border-top: 3px solid var(--gold);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 0 auto 1rem auto;
}

.loading-progress {
  width: 100%;
  height: 4px;
  background: rgba(212, 175, 55, 0.2);
  border-radius: 2px;
  overflow: hidden;
}

.loading-bar {
  height: 100%;
  background: linear-gradient(90deg, var(--gold), var(--bronze), var(--gold));
  width: 0%;
  border-radius: 2px;
  transition: width 0.3s ease-out;
  animation: loading-pulse 2s ease-in-out infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

@keyframes loading-pulse {
  0%, 100% { background: linear-gradient(90deg, var(--gold), var(--bronze), var(--gold)); }
  50% { background: linear-gradient(90deg, var(--bronze), var(--gold), var(--bronze)); }
}

/* ─────────────────────────── Page Header Components ─────────────────────────── */
.page-header {
  text-align: center;
  margin: 2rem auto;
  max-width: 1200px;
  padding: 0 var(--space-lg);
}

.page-header h1 {
  color: var(--gold);
  font-family: "Cinzel", serif;
  font-size: 2.5rem;
  margin-bottom: 1rem;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}

/* Content centering for all page types */
.page-content {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 var(--space-lg);
}

/* Fallback centering for collections and similar content without specific containers */
.editable-section {
  max-width: 1200px;
  margin-left: auto;
  margin-right: auto;
}

/* ─────────────────────────── Collections Page Components ─────────────────────────── */
.collections-search {
  margin: 2rem auto;
  text-align: center;
  max-width: 1200px;
  padding: 0 var(--space-lg);
}

.search-container {
  display: flex;
  gap: 1rem;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
}

.search-input {
  padding: 12px 16px;
  font-size: 1.1rem;
  border: 2px solid var(--bronze);
  border-radius: 8px;
  background: var(--card);
  color: var(--text);
  min-width: 300px;
  font-family: "Source Serif Pro", serif;
}

.search-input:focus {
  outline: none;
  border-color: var(--gold);
  box-shadow: 0 0 8px rgba(212, 175, 55, 0.3);
}

.search-button {
  padding: 12px 20px;
  background: linear-gradient(135deg, var(--gold), var(--bronze));
  color: var(--dark-text);
  border: none;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  font-size: 1rem;
  transition: all 0.3s ease;
}

.search-button:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(212, 175, 55, 0.4);
}

.collections-grid {
  display: grid;
  gap: 1.5rem; /* Balanced gap */
  margin: 2rem auto;
  max-width: 1400px; /* More space = more columns possible */
  justify-content: center;
  
  /* Use auto-fit with smaller minmax - collections can be smaller */
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
}

.collection-card {
  background: var(--card);
  border: 2px solid var(--bronze);
  border-radius: 12px;
  padding: 1.5rem;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  width: 100%; /* Take full column width */
  margin: 0; /* No margin, use grid gap */
  box-sizing: border-box; /* Include padding and border in width */
}

.collection-card:hover {
  transform: translateY(-2px);
  border-color: var(--gold);
  box-shadow: 0 8px 20px rgba(212, 175, 55, 0.2);
}

.collection-icon {
  font-size: 3rem;
  margin-bottom: 1rem;
}

.collection-card h3 {
  color: var(--gold);
  font-family: "Cinzel", serif;
  margin: 0.5rem 0;
  font-size: 1.3rem;
}

.collection-card p {
  color: var(--text-muted);
  font-size: 0.95rem;
  line-height: 1.4;
  margin: 0;
}

.collection-error {
  background: linear-gradient(135deg, #fee2e2 0%, #fef2f2 100%);
  border: 2px solid #f87171;
  border-radius: 12px;
  padding: 2rem;
  text-align: center;
  margin: 1rem 0;
  animation: fadeIn 0.5s ease;
}

.collection-error h2 {
  color: #dc2626;
  font-family: "Cinzel", serif;
  margin: 0 0 1rem 0;
  font-size: 1.5rem;
}

.collection-error p {
  color: #7f1d1d;
  font-size: 1rem;
  line-height: 1.6;
  margin: 0.5rem 0;
}

.collection-error strong {
  color: #b91c1c;
  font-weight: 600;
}

/* Collection Development Controls */
.collection-dev-controls {
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid var(--bronze);
  display: flex;
  gap: 0.5rem;
  justify-content: center;
}

.collection-dev-actions {
  text-align: center;
  margin: 1rem 0;
}

.edit-object-btn {
  background: var(--gold);
  color: var(--bg);
  border: none;
  padding: 0.4rem 0.8rem;
  border-radius: 6px;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.edit-object-btn:hover {
  background: #c9a96e;
  transform: translateY(-1px);
}

.delete-object-btn {
  background: #ef4444;
  color: white;
  border: none;
  padding: 0.4rem 0.8rem;
  border-radius: 6px;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.delete-object-btn:hover {
  background: #dc2626;
  transform: translateY(-1px);
}

.remove-from-collection-btn {
  background: #f59e0b;
  color: white;
  border: none;
  padding: 0.4rem 0.8rem;
  border-radius: 6px;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.remove-from-collection-btn:hover {
  background: #d97706;
  transform: translateY(-1px);
}

.add-object-btn {
  background: #10B981;
  color: white;
  border: none;
  padding: 0.6rem 1rem;
  border-radius: 8px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
  font-weight: 500;
}

.add-object-btn:hover {
  background: #059669;
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
}

/* New collection card styling */
.new-collection-card {
  border: 2px dashed var(--bronze) !important;
  background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%) !important;
}

.new-collection-card:hover {
  border-color: var(--gold) !important;
  background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%) !important;
}

.create-collection-btn {
  background: var(--gold);
  color: var(--bg);
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 6px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
  font-weight: 500;
  margin-top: 0.5rem;
}

.create-collection-btn:hover {
  background: #c9a96e;
  transform: translateY(-1px);
}

/* Hide dev controls in dev-off mode */
body.dev-off .collection-dev-controls,
body.dev-off .collection-dev-actions,
body.dev-off .new-collection-card {
  display: none !important;
}

.collection-results {
  margin: 2rem 0;
}

.collection-header {
  text-align: center;
  margin-bottom: 2rem;
  padding: 1.5rem;
  background: var(--accent-bg);
  border-radius: 12px;
  border: 2px solid var(--gold);
}

.collection-header h2 {
  color: var(--gold);
  font-family: "Cinzel", serif;
  margin: 0 0 0.5rem 0;
  font-size: 1.8rem;
}

.back-button {
  background: var(--secondary-bg);
  color: var(--text);
  border: 1px solid var(--bronze);
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.9rem;
  margin-top: 1rem;
  transition: all 0.3s ease;
}

.back-button:hover {
  background: var(--bronze);
  color: white;
}

.tag-filters {
  margin: 1.5rem 0;
  text-align: center;
}

.tag-filters h3 {
  color: var(--text);
  font-family: "Cinzel", serif;
  margin-bottom: 1rem;
  font-size: 1.2rem;
}

.tag-buttons {
  display: flex;
  gap: 0.5rem;
  justify-content: center;
  flex-wrap: wrap;
}

.tag-filter-btn {
  padding: 8px 16px;
  background: var(--secondary-bg);
  color: var(--text);
  border: 1px solid var(--bronze);
  border-radius: 20px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: all 0.3s ease;
}

.tag-filter-btn:hover,
.tag-filter-btn.active {
  background: var(--gold);
  color: var(--dark-text);
  border-color: var(--gold);
}

.collection-items {
  display: grid;
  gap: 1.5rem; /* Balanced gap */
  margin: 2rem auto;
  max-width: 1400px; /* More space = more columns possible */
  justify-content: center;
  
  /* Use auto-fit with smaller minmax to allow more columns */
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
}

/* Consistent sizing for object cards within collections */
.collection-items .card {
  width: 100%; /* Take full column width */
  margin: 0; /* Remove default margin, use grid gap instead */
  box-sizing: border-box; /* Include padding and border in width calculation */
}

/* Objects page container optimization for better space usage */
#objets-container {
  display: grid;
  gap: 1.5rem;
  justify-content: center;
  align-items: start;
  padding: 0;
  margin: 2rem auto;
  max-width: 1400px; /* Increase max width for better space usage */
  
  /* Responsive grid: 1 to 4 objects per row based on screen size */
  grid-template-columns: 1fr;
}

/* 2 objects per row on small tablets */
@media (min-width: 640px) {
  #objets-container {
    grid-template-columns: repeat(2, 1fr);
  }
}

/* 3 objects per row on tablets/small desktop */
@media (min-width: 960px) {
  #objets-container {
    grid-template-columns: repeat(3, 1fr);
  }
}

/* 4 objects per row on large desktop */
@media (min-width: 1280px) {
  #objets-container {
    grid-template-columns: repeat(4, 1fr);
  }
}

/* 5 objects per row on extra large desktop */
@media (min-width: 1600px) {
  #objets-container {
    grid-template-columns: repeat(5, 1fr);
    max-width: 1600px;
  }
}

/* Object cards sizing optimization */
#objets-container .card {
  min-width: 280px;
  max-width: 350px;
  width: 100%;
  margin: 0; /* Remove default margin, use grid gap instead */
}

/* Mobile optimization for objects page */
@media (max-width: 640px) {
  #objets-container {
    padding: 0 1rem;
    gap: 1rem;
  }
  
  #objets-container .card {
    min-width: auto;
    max-width: none;
  }
}

/* ─────────────────────────── Card System Enhanced - Authentic Parchment ─────────────────────────── */
.card,
.card-base {
  background: 
    var(--parchment-texture),
    var(--aged-paper),
    var(--card);
  border: 3px solid transparent;
  border-image: var(--parchment-border) 1;
  border-radius: 16px;
  box-shadow: 
    0 8px 32px rgba(139,69,19,.2),
    0 2px 8px rgba(139,69,19,.15),
    inset 0 1px 0 rgba(255,255,255,.2),
    inset 0 -1px 0 rgba(139,69,19,.08);
  padding: 20px;
  position: relative;
  overflow: hidden;
  transition: all var(--transition-normal);
  backdrop-filter: blur(1px);
}

.card::before,
.card-base::before {
  content: '';
  position: absolute;
  top: 2px;
  left: 2px;
  right: 2px;
  bottom: 2px;
  border: 1px solid rgba(139,69,19,.15);
  border-radius: 13px;
  pointer-events: none;
}

.card::after,
.card-base::after {
  content: '';
  position: absolute;
  top: 4px;
  left: 4px;
  right: 4px;
  height: 2px;
  background: 
    radial-gradient(ellipse at center, rgba(212,175,55,.3) 0%, transparent 60%),
    linear-gradient(90deg, transparent, rgba(139,69,19,.2), transparent);
  opacity: .6;
}

.card:hover,
.card-base:hover {
  transform: translate3d(0, -3px, 0) scale(1.01); /* Use 3D transform for better mobile performance */
  box-shadow: 
    0 16px 48px rgba(139,69,19,.25),
    0 6px 16px rgba(139,69,19,.18),
    inset 0 1px 0 rgba(255,255,255,.3),
    inset 0 -1px 0 rgba(139,69,19,.12);
}

/* Improve mobile performance with will-change on interactive elements */
.card,
.card-base,
.btn-base,
.toc a {
  will-change: transform;
}

/* ─────────────────────────── Button System Enhanced ─────────────────────────── */
.btn-base {
  display: inline-flex;
  gap: var(--space-md);
  align-items: center;
  background: linear-gradient(135deg, var(--card), rgba(244,240,230,0.8));
  border: 2px solid var(--rule);
  border-radius: 12px;
  padding: var(--space-md) var(--space-lg);
  min-height: 44px; /* Ensure minimum touch target size */
  box-shadow: 
    0 4px 16px rgba(0,0,0,.08),
    0 2px 4px rgba(139,69,19,.1),
    inset 0 1px 0 rgba(255,255,255,.2);
  cursor: pointer;
  transition: all var(--transition-fast);
  font-weight: 500;
  font-family: "Source Serif Pro", serif;
  text-transform: capitalize;
  position: relative;
  overflow: hidden;
}

.btn-base::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(212,175,55,.15), transparent);
  transition: left var(--transition-normal);
}

.btn-base:hover {
  transform: translate3d(0, -2px, 0) scale(1.02); /* Use 3D transform for better mobile performance */
  box-shadow: 
    0 8px 32px rgba(0,0,0,.15),
    0 4px 8px rgba(139,69,19,.12),
    inset 0 1px 0 rgba(255,255,255,.3);
  border-color: var(--bronze);
}

.btn-base:hover::before {
  left: 100%;
}

.btn-base:active {
  transform: translateY(-1px) scale(1.01);
  transition: all 0.1s ease;
}

.btn-small {
  padding: var(--space-sm) var(--space-md);
  font-size: 0.9em;
  min-height: 44px; /* Ensure minimum touch target size */
  min-width: 44px;
}

/* ─────────────────────────── Card Variants ─────────────────────────── */
.card-enhanced {
  margin: 1.5rem 0;
  animation: cardEntry 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.card.spell-card {
  border-left: 4px solid var(--feu);
  background: linear-gradient(135deg, var(--card), rgba(255,107,53,0.02));
}

.card.don-card {
  border-left: 4px solid var(--bronze);
  background: linear-gradient(135deg, var(--card), rgba(205,127,50,0.02));
}

.card.class-card {
  border-left: 4px solid var(--gold);
  background: linear-gradient(135deg, var(--card), rgba(212,175,55,0.02));
}

@keyframes cardEntry {
  0% {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* ─────────────────────────── Enhanced Tags & Filters ─────────────────────────── */
.tag-filters {
  margin: 1.5rem 0;
  padding: 1.5rem;
  background: 
    linear-gradient(135deg, var(--card), rgba(244,240,230,0.9)),
    radial-gradient(circle at 20% 50%, rgba(212,175,55,0.05), transparent),
    radial-gradient(circle at 80% 50%, rgba(139,69,19,0.03), transparent);
  border: 2px solid var(--rule);
  border-radius: 16px;
  box-shadow: 
    0 4px 20px rgba(0,0,0,.08),
    inset 0 1px 0 rgba(255,255,255,.1);
  position: relative;
  overflow: hidden;
}

.tag-filters::before {
  content: '🏷️ Filtres';
  position: absolute;
  top: -1px;
  left: 20px;
  background: var(--card);
  padding: 4px 12px;
  font-size: 0.85em;
  font-weight: 600;
  color: var(--bronze);
  border: 2px solid var(--rule);
  border-top: none;
  border-radius: 0 0 8px 8px;
  font-family: "Cinzel", serif;
}

.filter-chips {
  display: flex;
  gap: 0.75rem;
  flex-wrap: wrap;
  margin-top: 0.5rem;
}

.filter-chip {
  padding: 8px 16px;
  background: linear-gradient(135deg, var(--bronze), rgba(205,127,50,0.9));
  color: white;
  border-radius: 20px;
  font-size: 0.9em;
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition-fast);
  border: 2px solid transparent;
  box-shadow: 
    0 2px 8px rgba(0,0,0,.1),
    inset 0 1px 0 rgba(255,255,255,.2);
  position: relative;
  overflow: hidden;
}

.filter-chip::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,.2), transparent);
  transition: left var(--transition-fast);
}

.filter-chip:hover {
  background: linear-gradient(135deg, var(--gold), rgba(212,175,55,0.9));
  transform: translateY(-2px) scale(1.05);
  box-shadow: 
    0 6px 20px rgba(0,0,0,.15),
    inset 0 1px 0 rgba(255,255,255,.3);
}

.filter-chip:hover::before {
  left: 100%;
}

.filter-chip.active {
  background: linear-gradient(135deg, var(--accent-ink), rgba(74,44,23,0.9));
  border-color: var(--gold);
  transform: scale(1.02);
  box-shadow: 
    0 4px 16px rgba(0,0,0,.2),
    inset 0 1px 0 rgba(255,255,255,.1);
}

.tag-chip {
  display: inline-block;
  padding: 2px 8px;
  background: var(--bronze);
  color: white;
  border-radius: 8px;
  font-size: 0.8em;
  font-weight: 500;
  margin: 2px;
}

/* Gestionnaire de filtres */
.filter-manager-btn {
  background: var(--bronze) !important;
  color: white !important;
}

.filter-manager-btn:hover {
  background: var(--accent) !important;
}

.modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);z-index:999999;display:flex;align-items:center;justify-content:center}
.modal-base{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);z-index:99999;display:none;align-items:center;justify-content:center}
.modal-base.visible{display:flex}
.modal-content-base{background:var(--card);border:2px solid var(--rule);border-radius:16px;padding:var(--space-2xl);box-shadow:var(--shadow);position:relative}

/* Legacy Cards - Enhanced with Modern Styling */
.card{
  border:2px solid var(--rule);
  border-radius:16px;
  padding:20px;
  background:linear-gradient(145deg, #faf7f0, var(--card), #f8f4e8);
  box-shadow:
    0 8px 32px rgba(0,0,0,.12),
    0 2px 8px rgba(139,69,19,.08),
    inset 0 1px 0 rgba(255,255,255,.1);
  position:relative;
  overflow:hidden;
  transition: all var(--transition-normal);
  backdrop-filter: blur(1px);
}

.card::before{
  content:'';
  position:absolute;
  top:0;
  left:0;
  right:0;
  height:3px;
  background:linear-gradient(90deg, transparent, var(--gold), var(--bronze), var(--gold), transparent);
  opacity:.8;
}

.card::after{
  content:'';
  position:absolute;
  bottom:0;
  left:0;
  right:0;
  height:1px;
  background:linear-gradient(90deg, transparent, var(--bronze), transparent);
  opacity:.5;
}

.card:hover {
  transform: translateY(-2px);
  box-shadow: 
    0 12px 48px rgba(0,0,0,.15),
    0 4px 12px rgba(139,69,19,.12),
    inset 0 1px 0 rgba(255,255,255,.15);
  border-color: var(--gold);
}
.card ul, ul{padding-left:35px !important;margin-left:0 !important}

/* Buttons */
.btn{display:inline-flex;gap:var(--space-md);align-items:center;background:var(--card);border:2px solid var(--rule);border-radius:12px;padding:var(--space-md) var(--space-lg);box-shadow:var(--card-shadow);cursor:pointer;
     transition:var(--transition-fast); font-weight:500}
.btn:hover{transform:translateY(-1px); box-shadow:0 8px 25px rgba(0,0,0,.15); border-color:var(--bronze)}
.btn.small{padding:var(--space-sm) var(--space-md)}

/* Search bar */
.searchbar{display:flex;gap:var(--space-md);align-items:center}
.searchbar input{flex:1 1 auto;max-width:100%;height:38px;font-size:15px;padding:var(--space-md) 10px;border-radius:10px;border:1px solid var(--rule);background:#fff6e8;color:inherit}
.searchbar button{height:38px}

/* TOC Search bar - compact horizontal layout in table of contents */
.toc-search{
  display:flex;
  gap:8px;
  align-items:center;
  margin-bottom:16px;
  padding:12px;
  background:rgba(255,246,232,0.5);
  border-radius:12px;
  border:1px solid var(--rule);
}
.toc-search input{
  flex:1 1 auto;
  height:32px;
  font-size:14px;
  padding:6px 12px;
  border-radius:8px;
  border:1px solid var(--rule);
  background:#fff6e8;
  color:inherit;
}
.toc-search .btn-clear{
  display:flex;
  align-items:center;
  justify-content:center;
  width:32px;
  height:32px;
  background:#dc2626;
  color:white;
  border:none;
  border-radius:8px;
  cursor:pointer;
  font-size:14px;
  transition:var(--transition-fast);
  flex-shrink:0;
}
.toc-search .btn-clear:hover{
  background:#b91c1c;
  transform:scale(1.05);
}

/* Search results */
.search-results-container {
  font-size: 14px;
  line-height: 1.4;
}

.search-results-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: var(--gold);
  color: #4a4a4a;
  font-weight: 500;
  border-bottom: 1px solid var(--bronze);
}

.search-close {
  background: none;
  border: none;
  font-size: 16px;
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 4px;
  transition: background-color 0.2s;
}

.search-close:hover {
  background: rgba(0,0,0,0.1);
}

.search-results-list {
  max-height: 320px;
  overflow-y: auto;
}

.search-result-item {
  padding: 10px 12px;
  border-bottom: 1px solid #f0f0f0;
  cursor: pointer;
  transition: background-color 0.2s;
}

.search-result-item:hover {
  background: #f8f4e8;
}

.search-result-item:last-child {
  border-bottom: none;
}

.search-result-summary {
  font-weight: 500;
  color: #333;
  margin-bottom: 2px;
}

.search-result-category {
  font-size: 12px;
  color: #666;
  opacity: 0.8;
}

.search-no-results {
  padding: 20px;
  text-align: center;
  color: #666;
}

.search-no-results p {
  margin: 0;
  font-style: italic;
}

/* ─────────────────────────── Collections Grid System ─────────────────────────── */
.collections-grid {
  display: grid;
  gap: 1.5rem;
  margin: 2rem auto;
  max-width: 1400px;
  justify-content: center;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
}

.collection-card {
  background: 
    linear-gradient(135deg, var(--card), rgba(250,246,238,0.9)),
    radial-gradient(circle at 20% 30%, rgba(212,175,55,0.03), transparent 70%);
  border: 2px solid var(--bronze);
  border-radius: 16px;
  padding: 1.5rem;
  text-align: center;
  cursor: pointer;
  transition: all var(--transition-normal);
  box-shadow: 
    0 6px 20px rgba(0,0,0,.1),
    0 2px 6px rgba(139,69,19,.08),
    inset 0 1px 0 rgba(255,255,255,.1);
  width: 100%;
  margin: 0;
  box-sizing: border-box;
  position: relative;
  overflow: hidden;
}

.collection-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, 
    transparent, 
    var(--gold), 
    var(--bronze), 
    var(--gold), 
    transparent);
  opacity: 0.6;
}

.collection-card:hover {
  transform: translateY(-4px) scale(1.02);
  box-shadow: 
    0 12px 32px rgba(139,69,19,.2),
    0 4px 12px rgba(139,69,19,.15),
    inset 0 1px 0 rgba(255,255,255,.2);
  border-color: var(--gold);
}

.collection-icon {
  font-size: 3rem;
  margin-bottom: 1rem;
  display: block;
}

.collection-card h3 {
  color: var(--bronze);
  font-family: 'Cinzel', serif;
  font-size: 1.3rem;
  margin: 0.5rem 0 1rem 0;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
}

.collection-card p {
  margin: 0.5rem 0;
  color: var(--paper-muted);
  line-height: 1.4;
}

.collection-description {
  font-size: 0.9em;
  font-style: italic;
  color: var(--paper-ink);
  opacity: 0.8;
}

.collection-dev-controls {
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid var(--rule);
  display: flex;
  gap: 0.5rem;
  justify-content: center;
  flex-wrap: wrap;
}

.new-collection-card {
  border: 2px dashed var(--bronze);
  background: 
    linear-gradient(135deg, rgba(212,175,55,0.05), rgba(139,69,19,0.02)),
    var(--card);
  opacity: 0.8;
}

.new-collection-card:hover {
  opacity: 1;
  border-style: solid;
}

/* Collection items display */
.collection-items {
  display: grid;
  gap: 1.5rem;
  margin-top: 2rem;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
}

.collection-header {
  text-align: center;
  padding: 2rem 0;
  border-bottom: 2px solid var(--rule);
  margin-bottom: 1.5rem;
}

.collection-header h2 {
  color: var(--bronze);
  font-family: 'Cinzel', serif;
  margin: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 1rem;
}

.collection-results {
  margin-top: 2rem;
}

/* Collections search styles */
.collections-search {
  margin: 2rem 0;
  max-width: 600px;
  margin-left: auto;
  margin-right: auto;
}

.search-container {
  display: flex;
  gap: 0.5rem;
  align-items: stretch;
}

.search-input {
  flex: 1;
  padding: 0.75rem 1rem;
  border: 2px solid var(--rule);
  border-radius: 12px;
  font-size: 16px; /* Prevents zoom on iOS */
  background: var(--card);
  color: var(--paper-ink);
  font-family: inherit;
}

.search-button {
  background: linear-gradient(135deg, var(--gold), var(--bronze));
  color: white;
  border: 2px solid var(--bronze);
  border-radius: 12px;
  padding: 0.75rem 1.5rem;
  cursor: pointer;
  font-weight: 600;
  transition: all var(--transition-fast);
  white-space: nowrap;
  min-height: 44px; /* Touch target */
}

.search-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 20px rgba(139,69,19,.3);
}

/* Tag filters */
.tag-filters {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin: 1.5rem 0;
  justify-content: center;
}

.tag-filter-btn {
  background: var(--card);
  border: 2px solid var(--bronze);
  border-radius: 20px;
  padding: 0.4rem 1rem;
  cursor: pointer;
  transition: all var(--transition-fast);
  font-size: 0.9rem;
  font-weight: 500;
  color: var(--paper-ink);
  min-height: 44px; /* Touch target */
  display: flex;
  align-items: center;
}

.tag-filter-btn:hover {
  background: linear-gradient(135deg, var(--gold), rgba(212,175,55,0.8));
  color: white;
  transform: translateY(-1px);
}

.tag-filter-btn.active {
  background: var(--bronze);
  color: white;
  border-color: var(--gold);
}

/* Mobile Responsive Design for Collections */
@media (max-width: 768px) {
  .collections-grid {
    grid-template-columns: 1fr; /* Single column on mobile */
    gap: 1rem;
    margin: 1rem 0;
    max-width: 100%;
    padding: 0 1rem;
  }
  
  .collection-card {
    padding: 1rem;
    min-height: auto;
  }
  
  .collection-card h3 {
    font-size: 1.1rem;
  }
  
  .collection-icon {
    font-size: 2.5rem;
    margin-bottom: 0.8rem;
  }
  
  .collection-items {
    grid-template-columns: 1fr; /* Single column for items on mobile */
    gap: 1rem;
    margin-top: 1rem;
  }
  
  .collection-header {
    padding: 1rem 0;
  }
  
  .collection-header h2 {
    font-size: 1.3rem;
    flex-direction: column;
    gap: 0.5rem;
  }
  
  .collection-dev-controls {
    gap: 0.3rem;
  }
  
  .collection-dev-controls .btn.small {
    padding: 0.4rem 0.8rem;
    font-size: 0.8rem;
  }
  
  /* Mobile search improvements */
  .collections-search {
    margin: 1rem;
    max-width: 100%;
    padding: 0 0.5rem;
  }
  
  .search-container {
    flex-direction: column;
    gap: 0.75rem;
  }
  
  .search-input,
  .search-button {
    width: 100%;
    padding: 0.8rem 1rem;
  }
  
  .search-button {
    order: 2;
  }
  
  .tag-filters {
    gap: 0.4rem;
    margin: 1rem 0;
  }
  
  .tag-filter-btn {
    font-size: 0.85rem;
    padding: 0.5rem 0.8rem;
    min-height: 44px;
  }
}

/* Small tablets */
@media (min-width: 769px) and (max-width: 1024px) {
  .collections-grid {
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1.25rem;
    padding: 0 1rem;
  }
  
  .collection-card {
    padding: 1.25rem;
  }
  
  .collection-items {
    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  }
}

/* ─────────────────────────── Treasure Tables Components ─────────────────────────── */
.fourchette-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px;
  margin: 4px 0;
  background: rgba(139, 92, 23, 0.1);
  border-radius: 6px;
  border-left: 3px solid var(--bronze);
  transition: all var(--transition-fast);
}

.fourchette-row:hover {
  background: rgba(139, 92, 23, 0.15);
  transform: translateX(2px);
}

.fourchette-range {
  font-weight: bold;
  color: var(--bronze);
  min-width: 80px;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
}

.fourchette-objet {
  flex: 1;
  margin-left: 12px;
  color: var(--paper-ink);
}

.fourchette-objet a {
  color: var(--link);
  text-decoration: none;
  font-weight: 500;
}

.fourchette-objet a:hover {
  color: var(--bronze);
  text-decoration: underline;
}

.fourchette-actions {
  margin-left: 8px;
  display: flex;
  gap: 4px;
}

.fourchette-actions button {
  padding: 2px 6px;
  font-size: 0.7em;
  border-radius: 4px;
  transition: all var(--transition-fast);
  min-height: 32px;
  min-width: 32px;
}

/* Treasure table page layout */
.treasure-tables-page {
  max-width: 1200px;
  margin: 0 auto;
}

.treasure-filter-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin: 1rem 0;
  justify-content: center;
}

/* Mobile-specific treasure table improvements */
@media (max-width: 768px) {
  .treasure-tables-page {
    padding: 0 1rem;
  }
  
  .treasure-filter-tags {
    gap: 0.25rem;
    margin: 0.5rem 0;
  }
  
  .fourchette-actions button {
    min-height: 40px;
    min-width: 40px;
    padding: 4px 6px;
  }
}

/* Search results page */
.search-page {
  padding: var(--space-lg);
}

.search-page-header {
  margin-bottom: var(--space-xl);
  text-align: center;
  border-bottom: 2px solid var(--rule);
  padding-bottom: var(--space-lg);
}

.search-page-header h1 {
  color: var(--gold);
  margin-bottom: var(--space-md);
  font-family: var(--font-title);
}

.search-results-count {
  color: #666;
  margin-bottom: var(--space-lg);
  font-style: italic;
}

.search-results-grid {
  display: grid;
  gap: var(--space-lg);
  max-width: 800px;
  margin: 0 auto;
  grid-template-columns: 1fr;
}

.search-result-card {
  cursor: pointer;
  transition: all 0.2s ease;
  border: 2px solid var(--rule);
  background: var(--card);
  padding: var(--space-lg);
  border-radius: 14px;
  box-shadow: var(--card-shadow);
  /* Force visibility */
  display: block !important;
  visibility: visible !important;
  opacity: 1 !important;
  min-height: 150px;
}

.search-result-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(0,0,0,0.15);
  border-color: var(--bronze);
}

.search-result-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: var(--space-md);
}

.search-result-header h3 {
  margin: 0;
  color: var(--bronze);
  font-size: 1.2em;
  text-align: center;
}

.search-result-type {
  background: var(--gold);
  color: #4a4a4a;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 0.8em;
  font-weight: 500;
}

.search-result-content {
  margin-bottom: var(--space-lg);
}

.search-result-summary {
  font-weight: 500;
  margin-bottom: var(--space-md);
  color: #333;
  font-size: 1.05em;
  padding: var(--space-sm);
  background: linear-gradient(90deg, var(--gold), transparent);
  border-radius: 4px;
  opacity: 0.9;
}

.search-result-category {
  font-size: 0.9em;
  color: #666;
  margin-bottom: var(--space-md);
}

.search-result-preview {
  background: #f8f4e8;
  padding: var(--space-md);
  border-radius: 8px;
  border-left: 3px solid var(--bronze);
}

.preview-field {
  margin-bottom: var(--space-sm);
  line-height: 1.4;
  font-size: 0.9em;
  padding: var(--space-sm);
  background: rgba(0,0,0,0.02);
  border-left: 3px solid var(--gold);
  border-radius: 0 4px 4px 0;
}

.preview-field:last-child {
  margin-bottom: 0;
}

.preview-field strong {
  color: var(--bronze);
  font-weight: 600;
}

.search-result-footer {
  text-align: right;
  padding-top: var(--space-md);
  border-top: 1px solid #eee;
}

.search-result-btn {
  background: var(--bronze);
  color: white;
  border-color: var(--bronze);
}

.search-result-btn:hover {
  background: #b8860b;
  border-color: #b8860b;
}

/* Force search results visibility */
.search-page .search-results-grid .search-result-card {
  display: block !important;
  visibility: visible !important;
  opacity: 1 !important;
  height: auto !important;
  min-height: 150px !important;
  background: var(--card) !important;
  border: 2px solid var(--bronze) !important;
  margin-bottom: var(--space-lg) !important;
}

/* ─────────────────────────── Advanced Animations & Transitions ─────────────────────────── */

/* Page Transitions */
@keyframes pageSlideIn {
  0% {
    opacity: 0;
    transform: translateX(30px);
  }
  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes pageSlideInFromTop {
  0% {
    opacity: 0;
    transform: translateY(-20px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Content Animation */
article {
  animation: pageSlideIn 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

article.active {
  animation: pageSlideInFromTop 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

/* Staggered Entry Animation for Lists */
.staggered-entry > * {
  opacity: 0;
  animation: staggeredEntry 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}

.staggered-entry > *:nth-child(1) { animation-delay: 0.1s; }
.staggered-entry > *:nth-child(2) { animation-delay: 0.2s; }
.staggered-entry > *:nth-child(3) { animation-delay: 0.3s; }
.staggered-entry > *:nth-child(4) { animation-delay: 0.4s; }
.staggered-entry > *:nth-child(5) { animation-delay: 0.5s; }
.staggered-entry > *:nth-child(n+6) { animation-delay: 0.6s; }

@keyframes staggeredEntry {
  0% {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* Loading Animation */
@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.loading-shimmer {
  position: relative;
  overflow: hidden;
  background: linear-gradient(90deg, #f0f0f0, #e0e0e0, #f0f0f0);
  animation: shimmer 1.5s infinite linear;
}

.loading-shimmer::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
  animation: shimmer 1.5s infinite linear;
}

/* Floating Elements Animation */
@keyframes float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}

.floating {
  animation: float 3s ease-in-out infinite;
}

.floating:nth-child(2n) {
  animation-delay: 1s;
}

.floating:nth-child(3n) {
  animation-delay: 2s;
}

/* Pulse Animation for Important Elements */
@keyframes pulse {
  0%, 100% { 
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(212, 175, 55, 0.4);
  }
  50% { 
    transform: scale(1.02);
    box-shadow: 0 0 0 10px rgba(212, 175, 55, 0);
  }
}

.pulse-attention {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Text Glow Effect */
@keyframes textGlow {
  0%, 100% {
    text-shadow: 
      0 0 5px rgba(212, 175, 55, 0.2),
      0 0 10px rgba(212, 175, 55, 0.1);
  }
  50% {
    text-shadow: 
      0 0 10px rgba(212, 175, 55, 0.4),
      0 0 20px rgba(212, 175, 55, 0.2),
      0 0 30px rgba(212, 175, 55, 0.1);
  }
}

.text-glow {
  animation: textGlow 3s ease-in-out infinite;
}

/* Enhanced Hover Transitions */
.interactive-element {
  transition: 
    transform var(--transition-fast),
    box-shadow var(--transition-fast),
    background-color var(--transition-fast),
    border-color var(--transition-fast),
    color var(--transition-fast);
}

.interactive-element:hover {
  transform: translateY(-2px) scale(1.02);
}

/* Magical Sparkle Effect */
@keyframes sparkle {
  0%, 100% { opacity: 0; transform: scale(0); }
  50% { opacity: 1; transform: scale(1); }
}

.sparkle-effect::before {
  content: '✨';
  position: absolute;
  top: -5px;
  right: -5px;
  font-size: 0.8em;
  animation: sparkle 2s ease-in-out infinite;
  animation-delay: 0.5s;
}

.sparkle-effect::after {
  content: '⭐';
  position: absolute;
  bottom: -5px;
  left: -5px;
  font-size: 0.6em;
  animation: sparkle 2s ease-in-out infinite;
  animation-delay: 1.5s;
}

/* Smooth Content Transitions */
.content-transition {
  transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

.content-fade-in {
  animation: fadeInUp 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

@keyframes fadeInUp {
  0% {
    opacity: 0;
    transform: translateY(30px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Clean up card styling */

/* Illustrations */
.illus{display:flex;gap:12px;align-items:center;justify-content:center;flex-wrap:wrap;margin:.6rem 0}
.illus img{max-width:100%;height:auto;border-radius:12px; transition:all .3s ease}
.illus img.enlarged{transition:none !important}
.illus .thumb{max-width:500px;max-height:300px;width:auto;height:auto;object-fit:contain}

/* Images avec cadres - système unifié */
.illus-spell, .illus-class, .illus-subclass, .illus-don,
article[data-page="guerrier"] .illus,
article[data-page="mage"] .illus,
article[data-page="pretre"] .illus,
article[data-page="rodeur"] .illus,
article[data-page="enchanteur"] .illus,
.illus[data-illus-key^="class:"],
.illus[data-illus-key^="subclass:"],
.illus[data-illus-key^="spell:"],
.illus[data-illus-key^="sort:"],
.illus[data-illus-key^="spellcategory:"],
.illus[data-illus-key^="don:"] {
  display:flex !important; flex-direction:column !important; align-items:center !important;
  justify-content:center !important; margin:1rem auto !important;
}

.illus-spell img, .illus-class img, .illus-subclass img, .illus-don img,
article[data-page="guerrier"] .illus img,
article[data-page="mage"] .illus img,
article[data-page="pretre"] .illus img,
article[data-page="rodeur"] .illus img,
article[data-page="enchanteur"] .illus img,
.illus[data-illus-key^="class:"] img,
.illus[data-illus-key^="subclass:"] img,
.illus[data-illus-key^="spell:"] img,
.illus[data-illus-key^="sort:"] img,
.illus[data-illus-key^="spellcategory:"] img,
.illus[data-illus-key^="don:"] img {
  border:var(--image-border) !important; 
  box-shadow:var(--image-shadow) !important;
  padding:4px !important; 
  background:transparent !important;
  border-radius:16px !important; 
  max-width:fit-content !important;
  width:auto !important;
  cursor:pointer !important;
}

.illus-spell img:hover, .illus-class img:hover, .illus-subclass img:hover, .illus-don img:hover,
article[data-page="guerrier"] .illus img:hover,
article[data-page="mage"] .illus img:hover,
article[data-page="pretre"] .illus img:hover,
article[data-page="rodeur"] .illus img:hover,
article[data-page="enchanteur"] .illus img:hover,
.illus[data-illus-key^="class:"] img:hover,
.illus[data-illus-key^="subclass:"] img:hover,
.illus[data-illus-key^="spell:"] img:hover,
.illus[data-illus-key^="sort:"] img:hover,
.illus[data-illus-key^="spellcategory:"] img:hover,
.illus[data-illus-key^="don:"] img:hover {
  transform:scale(1.03) !important; 
  box-shadow:var(--image-shadow), 0 8px 25px rgba(139,69,19,.25) !important;
}

/* Variantes de taille d'images */
.illus-small img { max-width: 150px !important; }
.illus-large img { max-width: 400px !important; }

/* Style spécial pour les sorts - cadre doré et taille augmentée */
.illus-spell img,
.card .illus img {
  border: 3px solid var(--gold) !important;
  box-shadow: var(--image-shadow), 0 0 10px rgba(212,175,55,.3) !important;
  max-width: 350px !important;
  max-height: 250px !important;
  object-fit: contain !important;
}

/* Style spécial pour les sous-classes - 2 images centrées et collées */
.subclass-images {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0;
  margin: 0.6rem 0;
}

.subclass-images .illus {
  margin: 0;
  flex: 0 0 auto;
}

.subclass-images .illus img {
  max-width: 400px !important;
  max-height: 300px !important;
  object-fit: contain !important;
  border-radius: 12px 0 0 12px !important;
}

.subclass-images .illus:last-child img {
  border-radius: 0 12px 12px 0 !important;
}

/* Mobile: Stack subclass images vertically */
@media (max-width: 980px) {
  .subclass-images {
    flex-direction: column !important;
    gap: 8px !important;
  }
  
  .subclass-images .illus img {
    border-radius: 12px !important;
    max-width: 100% !important;
    width: 100% !important;
  }
  
  /* Réduire l'espace des cadres d'images sur mobile */
  .illus-spell img, .illus-class img, .illus-subclass img, .illus-don img,
  article[data-page="guerrier"] .illus img,
  article[data-page="mage"] .illus img,
  article[data-page="pretre"] .illus img,
  article[data-page="rodeur"] .illus img,
  article[data-page="enchanteur"] .illus img,
  .illus[data-illus-key^="class:"] img,
  .illus[data-illus-key^="subclass:"] img,
  .illus[data-illus-key^="spell:"] img,
  .illus[data-illus-key^="sort:"] img,
  .illus[data-illus-key^="spellcategory:"] img,
  .illus[data-illus-key^="don:"] img {
    padding: 2px !important; /* Réduire le padding de 4px à 2px */
    border-width: 2px !important; /* Réduire l'épaisseur des bordures */
    max-width: 100% !important;
    width: auto !important;
    height: auto !important;
    object-fit: contain !important;
  }
  
  /* Réduire l'espace entre les images de classe et sous-classe */
  .illus {
    gap: 4px !important; /* Réduire de 12px à 4px */
    margin: 0.3rem 0 !important; /* Réduire les marges */
  }
  
  /* Images de sorts plus compactes sur mobile */
  .illus-spell img,
  .card .illus img {
    max-width: 100% !important;
    max-height: 180px !important; /* Réduire de 250px à 180px */
    border-width: 2px !important; /* Bordure plus fine */
  }
  
  .subclass-images .illus:last-child img {
    border-radius: 12px !important;
  }
}

/* Style spécial pour les titres de sous-classes */
.subclass-title {
  font-size: 2.2rem !important;
  font-weight: 800 !important;
  text-align: center !important;
  margin: 0 0 1.5rem 0 !important;
  color: var(--accent-ink) !important;
  font-family: 'Cinzel', serif !important;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.2) !important;
  letter-spacing: 0.8px !important;
}

/* Style spécial pour les descriptions de sous-classes */
.card[data-section-type="subclass"] .editable[data-edit-section*="description"] {
  text-align: center !important;
  color: var(--paper-ink) !important;
}

.card[data-section-type="subclass"] .editable[data-edit-section*="description"] em,
.card[data-section-type="subclass"] .editable[data-edit-section*="description"] i {
  color: var(--paper-ink) !important;
}

/* ═══════════════════════════════════════════════════════════════════════════════════════
   📱 MOBILE & TOUCH OPTIMIZATION - Final Enhancements
   ═══════════════════════════════════════════════════════════════════════════════════════ */

/* Touch-friendly interactions for mobile devices */
@media (hover: none) and (pointer: coarse) {
  .btn-base, .filter-chip, .toc a, .card {
    min-height: 44px; /* iOS/Android minimum touch target */
    min-width: 44px;
  }
  
  .toc a {
    padding: 12px;
    margin: 4px 0;
  }
  
  .filter-chip {
    padding: 8px 16px;
    margin: 2px;
  }
  
  /* Disable hover effects on touch devices */
  .card:hover, .btn-base:hover, .filter-chip:hover, .toc a:hover {
    transform: none;
    box-shadow: initial;
    background: initial;
    border-color: initial;
  }
  
  /* Add tap feedback instead */
  .btn-base:active, .filter-chip:active, .toc a:active, .card:active {
    transform: scale(0.98);
    transition: transform 0.1s ease;
    opacity: 0.8;
  }
}

/* Reduce animation complexity on low-performance devices */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
  
  .floating, .pulse-attention, .text-glow, 
  .shimmer-effect, .sparkle-effect {
    animation: none !important;
  }
  
  .card, .btn-base, .filter-chip {
    transition: none !important;
  }
}

/* Mobile-specific improvements */
@media (max-width: 480px) {
  /* Improve text readability on small screens */
  body {
    font-size: 16px;
    line-height: 1.6;
    -webkit-text-size-adjust: 100%;
  }
  
  /* Ensure images don't break layout */
  img {
    max-width: 100% !important;
    height: auto !important;
  }
  
  /* Optimize cards for mobile */
  .card, .card-base {
    border-radius: 12px;
    box-shadow: 0 4px 16px rgba(0,0,0,.1);
  }
  
  /* Mobile-friendly buttons */
  .btn-base {
    border-radius: 8px;
    font-size: 16px; /* Prevent iOS zoom */
  }
  
  /* Improve modal sizing on mobile */
  .modal-content-base {
    margin: 10px;
    max-width: calc(100vw - 20px);
    max-height: calc(100vh - 20px);
    overflow-y: auto;
  }
  
  /* Mobile search optimization */
  .searchbar input {
    font-size: 16px; /* Prevents zoom on iOS */
    padding: 12px;
    border-radius: 8px;
  }
}

/* ═══════════════════════════════════════════════════════════════════════════════════════
   📄 SECTION SELECTION MODAL
   ═══════════════════════════════════════════════════════════════════════════════════════ */

.section-selection-modal {
  z-index: 999999 !important;
}

.section-selection-modal .modal-content {
  max-width: 500px;
  padding: 2rem;
}

.sections-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin: 1.5rem 0;
}

.section-option {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  border: 2px solid var(--rule);
  border-radius: 12px;
  cursor: pointer;
  transition: all var(--transition-normal);
  background: var(--card);
}

.section-option:hover {
  border-color: var(--bronze);
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.1) 0%, 
    rgba(139,69,19,0.05) 100%);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(139,69,19,0.15);
}

.section-option.selected {
  border-color: var(--gold);
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.2) 0%, 
    rgba(139,69,19,0.1) 100%);
  box-shadow: 
    0 0 0 2px rgba(212,175,55,0.3),
    0 4px 16px rgba(139,69,19,0.2);
}

.section-icon {
  font-size: 2rem;
  width: 60px;
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 12px;
  background: linear-gradient(135deg, var(--bronze), var(--gold));
  color: white;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
}

.section-info {
  flex: 1;
}

.section-title {
  font-weight: 600;
  font-size: 1.1em;
  color: var(--accent-ink);
  margin-bottom: 0.25rem;
  font-family: 'Cinzel', serif;
}

.section-description {
  color: var(--paper-muted);
  font-size: 0.9em;
  line-height: 1.4;
}

.page-details {
  padding: 1.5rem;
  background: var(--paper-soft);
  border: 1px solid var(--rule);
  border-radius: 12px;
  margin: 1rem 0;
}

.form-group {
  margin-bottom: 1rem;
}

.form-group:last-child {
  margin-bottom: 0;
}

.form-group label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 600;
  color: var(--accent-ink);
}

.form-group input {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid var(--rule);
  border-radius: 8px;
  font-size: 1em;
  background: var(--card);
  color: var(--paper-ink);
}

.form-group input:focus {
  outline: none;
  border-color: var(--bronze);
  box-shadow: 0 0 0 2px rgba(212,175,55,0.2);
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 1rem;
  margin-top: 1.5rem;
}

.btn-primary {
  background: var(--bronze) !important;
  color: white !important;
  border-color: var(--bronze) !important;
}

.btn-primary:hover {
  background: var(--gold) !important;
  border-color: var(--gold) !important;
}

/* ─────────────────────────── Favoris Components ─────────────────────────── */

/* Cartes avec favoris - permettre l'overflow pour les boutons étoile */
.card:has(.favoris-star) {
  overflow: visible !important;
}

/* Fallback pour navigateurs sans support :has() */
.spell-card,
.item-card {
  overflow: visible !important;
}

.favoris-star {
  position: absolute;
  top: 8px;
  right: 8px;
  background: rgba(0,0,0,0.1);
  border: none;
  border-radius: 50%;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 16px;
  cursor: pointer;
  transition: all 0.2s ease;
  z-index: 10;
  backdrop-filter: blur(4px);
}

.favoris-star:hover {
  background: rgba(0,0,0,0.2);
  transform: scale(1.1);
}

.favoris-star.favoris-active {
  background: rgba(255,215,0,0.2);
  color: #ffd700;
}

.favoris-star.favoris-active:hover {
  background: rgba(255,215,0,0.3);
  transform: scale(1.15);
}

/* Notification des favoris */
.favoris-notification {
  position: fixed;
  top: 20px;
  right: 20px;
  background: var(--surface-color, #f0f0f0);
  color: var(--text-color, #333);
  padding: 12px 16px;
  border-radius: 8px;
  border-left: 4px solid var(--accent-color, #d4af37);
  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  z-index: 10000;
  font-size: 14px;
  max-width: 300px;
}

.favoris-notification.favoris-success {
  border-left-color: #22c55e;
  background: rgba(34,197,94,0.1);
}

.favoris-notification.favoris-info {
  border-left-color: #3b82f6;
  background: rgba(59,130,246,0.1);
}

/* Animations pour les notifications */
@keyframes slideInRight {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOutRight {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
}

/* Page favoris */
.favoris-section {
  margin: 2rem 0;
}

.favoris-section h2 {
  color: var(--accent-ink);
  border-bottom: 2px solid var(--gold);
  padding-bottom: 0.5rem;
  margin-bottom: 1rem;
}

/* Sections pliables favoris */
.favoris-collapsible {
  border: 1px solid var(--rule);
  border-radius: 12px;
  background: var(--card);
  overflow: hidden;
  transition: all 0.3s ease;
}

.favoris-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.5rem;
  cursor: pointer;
  background: var(--surface-subtle);
  border-bottom: 1px solid var(--rule);
  transition: background 0.2s ease;
}

.favoris-header:hover {
  background: var(--surface-color);
}

.favoris-header h2 {
  margin: 0;
  border: none;
  padding: 0;
  font-size: 1.3em;
  color: var(--accent-ink);
}

.favoris-toggle {
  font-size: 1.2em;
  color: var(--accent-ink);
  transition: transform 0.3s ease;
  user-select: none;
}

.favoris-collapsible.collapsed .favoris-toggle {
  transform: rotate(-90deg);
}

.favoris-content {
  padding: 1.5rem;
  max-height: none;
  overflow: visible;
  transition: max-height 0.3s ease, padding 0.3s ease;
}

.favoris-collapsible.collapsed .favoris-content {
  max-height: 0;
  padding-top: 0;
  padding-bottom: 0;
  overflow: hidden;
}

.favoris-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 1rem;
  width: 100%;
  margin: 0.5rem 0;
}

@media (max-width: 768px) {
  .favoris-grid {
    grid-template-columns: 1fr;
    gap: 0.75rem;
  }
}

.favoris-empty {
  text-align: center;
  color: var(--muted-ink);
  font-style: italic;
  padding: 2rem;
  background: var(--surface-subtle);
  border-radius: 12px;
  border: 2px dashed var(--rule);
}

/* Mise en position relative pour les cartes avec étoiles */
.card.spell-card,
.card.item-card {
  position: relative;
}

/* Responsive */
@media (max-width: 768px) {
  .favoris-star {
    width: 28px;
    height: 28px;
    font-size: 14px;
    top: 6px;
    right: 6px;
  }
  
  .favoris-notification {
    right: 10px;
    top: 10px;
    max-width: calc(100vw - 20px);
  }
}

/* Mobile optimization for section selection modal */
@media (max-width: 480px) {
  .section-selection-modal .modal-content {
    padding: 1rem;
    margin: 1rem;
  }
  
  .section-option {
    padding: 0.75rem;
    gap: 0.75rem;
  }
  
  .section-icon {
    width: 48px;
    height: 48px;
    font-size: 1.5rem;
  }
  
  .modal-actions {
    flex-direction: column;
  }
  
  .modal-actions .btn {
    width: 100%;
  }
}

/* ═══════════════════════════════════════════════════════════════════════════════════════
   🖨️ PRINT STYLES - États imprimables
   ═══════════════════════════════════════════════════════════════════════════════════════ */

.print-button {
  background: var(--bronze) !important;
  color: white !important;
  border: 2px solid var(--gold) !important;
  border-radius: 8px;
  padding: 0.5rem 1rem;
  font-family: "Cinzel", serif;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.print-button:hover {
  background: var(--gold) !important;
  border-color: var(--bronze) !important;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

/* Styles pour la version imprimable */
@media print {
  @page {
    margin: 0 !important;
    size: A4 !important;
  }
  
  html, body {
    font-family: "Times New Roman", serif !important;
    background: white !important;
    color: black !important;
    margin: 0 !important;
    padding: 0 !important;
    height: auto !important;
    overflow: visible !important;
  }
  
  .printable-states {
    display: block !important;
    padding: 15mm !important;
    margin: 0 !important;
    background: white !important;
    color: black !important;
    font-size: 10pt !important;
    line-height: 1.2 !important;
    width: 100% !important;
    height: auto !important;
    position: relative !important;
    top: 0 !important;
    left: 0 !important;
  }
  
  .printable-states h1 {
    font-size: 16pt !important;
    font-weight: bold !important;
    text-align: center !important;
    margin-bottom: 5mm !important;
    color: black !important;
    text-shadow: none !important;
    background: none !important;
    -webkit-text-fill-color: initial !important;
  }
  
  .printable-states-grid {
    display: grid !important;
    grid-template-columns: 1fr 1fr !important;
    gap: 3mm !important;
    margin: 0 !important;
  }
  
  .printable-state-item {
    background: white !important;
    border: 1pt solid #ccc !important;
    border-radius: 2mm !important;
    padding: 2mm !important;
    margin: 0 !important;
    page-break-inside: avoid !important;
    font-size: 9pt !important;
    line-height: 1.1 !important;
  }
  
  .printable-state-item h3 {
    font-size: 11pt !important;
    font-weight: bold !important;
    margin: 0 0 1mm 0 !important;
    color: black !important;
    text-shadow: none !important;
    background: none !important;
    -webkit-text-fill-color: initial !important;
  }
  
  .printable-state-item p {
    margin: 0.5mm 0 !important;
    color: black !important;
    font-size: 9pt !important;
  }
  
  /* Masquer les éléments de l'interface lors de l'impression */
  #sidebar, #views, .print-button, nav, header, footer, .edit-btn, .btn {
    display: none !important;
  }
  
  /* Afficher uniquement le contenu imprimable */
  .printable-states {
    display: block !important;
  }
  
  .printable-states-grid {
    display: grid !important;
  }
  
  .printable-state-item {
    display: block !important;
  }
  
  .printable-state-item h3 {
    display: block !important;
  }
  
  .printable-state-item div {
    display: block !important;
  }
}

/* ═══════════════════════════════════════════════════════════════════════════════════════
   🎵 AUDIO CONTROLS - Lecteur audio flottant
   ═══════════════════════════════════════════════════════════════════════════════════════ */

.audio-controls {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 1000;
  background: var(--card);
  border: 2px solid var(--bronze);
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.3);
  backdrop-filter: blur(10px);
  min-width: 280px;
  font-family: "Cinzel", serif;
}

.audio-panel {
  padding: 1rem;
}

.audio-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 0.75rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--rule);
}

.audio-icon {
  font-size: 1.2rem;
}

.audio-title {
  font-weight: 600;
  color: var(--gold);
  font-size: 0.9rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.audio-toggle-btn {
  background: none;
  border: none;
  font-size: 1.1rem;
  cursor: pointer;
  padding: 0.25rem;
  border-radius: 4px;
  transition: background 0.2s ease;
}

.audio-toggle-btn:hover {
  background: var(--rule);
}

.audio-info {
  margin-bottom: 0.75rem;
  text-align: center;
}

.playlist-name {
  font-weight: 600;
  color: var(--accent-ink);
  font-size: 0.85rem;
  margin-bottom: 0.25rem;
}

.track-name {
  font-size: 0.75rem;
  color: var(--paper-muted);
  font-style: italic;
}

.audio-controls-row {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  margin-bottom: 0.75rem;
}

.audio-btn {
  background: var(--bronze);
  border: 1px solid var(--gold);
  border-radius: 6px;
  padding: 0.5rem;
  cursor: pointer;
  font-size: 0.9rem;
  color: white;
  transition: all 0.2s ease;
  min-width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.audio-btn:hover {
  background: var(--gold);
  transform: translateY(-1px);
}

.audio-btn:active {
  transform: translateY(0);
}

.audio-volume-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.8rem;
}

.volume-icon {
  font-size: 0.9rem;
  min-width: 20px;
}

.volume-slider {
  flex: 1;
  height: 4px;
  background: var(--rule);
  border-radius: 2px;
  outline: none;
  -webkit-appearance: none;
  appearance: none;
}

.volume-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--bronze);
  cursor: pointer;
  border: 2px solid var(--gold);
}

.volume-slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--bronze);
  cursor: pointer;
  border: 2px solid var(--gold);
}

.volume-value {
  min-width: 35px;
  text-align: right;
  font-weight: 600;
  color: var(--accent-ink);
}

/* Responsive pour mobile */
@media (max-width: 480px) {
  .audio-controls {
    bottom: 10px;
    right: 10px;
    left: 10px;
    min-width: auto;
  }
  
  .audio-panel {
    padding: 0.75rem;
  }
  
  .audio-title {
    font-size: 0.8rem;
  }
  
  .audio-controls-row {
    gap: 0.75rem;
  }
  
  .audio-btn {
    min-width: 40px;
    height: 40px;
    font-size: 1rem;
  }
}

/* Masquer lors de l'impression */
@media print {
  .audio-controls {
    display: none !important;
  }
}

/* ═══════════════════════════════════════════════════════════════════════════════════════
   🔧 AUDIO PAGE CONTROLS - Boutons stables pour la page audio
   ═══════════════════════════════════════════════════════════════════════════════════════ */

.audio-control-btn {
  background: var(--bronze) !important;
  color: white !important;
  border: none !important;
  padding: 1rem 2rem !important;
  border-radius: 8px !important;
  cursor: pointer !important;
  font-family: "Cinzel", serif !important;
  font-size: 1rem !important;
  font-weight: 600 !important;
  text-transform: uppercase !important;
  letter-spacing: 0.5px !important;
  transition: none !important;
  min-width: 160px !important;
  min-height: 50px !important;
  user-select: none !important;
  -webkit-user-select: none !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  text-align: center !important;
}

.audio-control-btn:hover {
  background: var(--gold) !important;
  transform: none !important;
  box-shadow: none !important;
}

.audio-control-btn:active {
  background: var(--bronze) !important;
  transform: scale(0.98) !important;
}

.playlist-select-btn {
  background: var(--bronze) !important;
  color: white !important;
  border: none !important;
  padding: 1rem 1.5rem !important;
  border-radius: 6px !important;
  cursor: pointer !important;
  font-family: "Cinzel", serif !important;
  font-size: 0.95rem !important;
  font-weight: 600 !important;
  transition: none !important;
  min-width: 120px !important;
  min-height: 45px !important;
  user-select: none !important;
  -webkit-user-select: none !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  text-align: center !important;
}

.playlist-select-btn:hover {
  background: var(--gold) !important;
  transform: none !important;
  box-shadow: none !important;
}

.playlist-select-btn:active {
  transform: scale(0.98) !important;
}

/* Slider de volume amélioré */
#master-volume {
  -webkit-appearance: none !important;
  appearance: none !important;
  height: 6px !important;
  background: var(--rule) !important;
  border-radius: 3px !important;
  outline: none !important;
  cursor: pointer !important;
  transition: none !important;
}

#master-volume::-webkit-slider-thumb {
  -webkit-appearance: none !important;
  appearance: none !important;
  width: 20px !important;
  height: 20px !important;
  border-radius: 50% !important;
  background: var(--bronze) !important;
  cursor: pointer !important;
  border: 2px solid var(--gold) !important;
  transition: none !important;
}

#master-volume::-webkit-slider-thumb:hover {
  background: var(--gold) !important;
  border-color: var(--bronze) !important;
}

/* ─────────────────────────── Notification Animations ─────────────────────────── */
@keyframes slideInRight {
  from {
    transform: translateX(100%);
    opacity: 0;
  }
  to {
    transform: translateX(0);
    opacity: 1;
  }
}

@keyframes slideOutRight {
  from {
    transform: translateX(0);
    opacity: 1;
  }
  to {
    transform: translateX(100%);
    opacity: 0;
  }
}

/* Notification positioning and styles */
.notification {
  position: fixed !important;
  top: 20px !important;
  right: 20px !important;
  padding: 12px 20px !important;
  border-radius: 8px !important;
  z-index: 1001 !important;
  font-size: 14px !important;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3) !important;
  font-family: inherit !important;
  font-weight: 500 !important;
}

#master-volume::-moz-range-thumb {
  width: 20px !important;
  height: 20px !important;
  border-radius: 50% !important;
  background: var(--bronze) !important;
  cursor: pointer !important;
  border: 2px solid var(--gold) !important;
  transition: none !important;
}

#master-volume::-moz-range-thumb:hover {
  background: var(--gold) !important;
  border-color: var(--bronze) !important;
}


/* Editor and Dev Mode styles */

/* === HIDE ALL EDITING ELEMENTS IN STANDALONE MODE === */
/* Hide all editing elements when dev mode is OFF */

/* ULTRA NUCLEAR OPTION - Hide ALL editing buttons when dev mode is OFF */
/* This rule will override ANY other CSS that might be showing edit buttons */
body.dev-off button[title*="✏️"],
body.dev-off *[class*="edit"],
body.dev-off *[class*="Edit"],

body.dev-off button[data-category-name],
body.dev-off button[data-spell-name], 
body.dev-off button[data-don-name],
body.dev-off button[data-section-name],
body.dev-off button[data-section-type],
body.dev-off .btn:is([class*="add"], [class*="delete"], [class*="remove"], [class*="move"], [class*="edit"]),
body.dev-off .add-paragraph-btn,
body.dev-off .section-delete,
body.dev-off .spell-delete,
body.dev-off .don-delete,
body.dev-off .objet-delete,
body.dev-off .spell-category-delete,
body.dev-off .don-category-delete,
body.dev-off .objet-category-delete,
body.dev-off .don-move-up,
body.dev-off .don-move-down,
body.dev-off .remove-section-btn,
body.dev-off .illus .up,
body.dev-off .illus .rm,
body.dev-off .illus label.up,
body.dev-off .illus button.rm,
body.dev-off .illus label,
body.dev-off .illus input[type="file"],
body.dev-off button[class*="add"]:not(.menu-toggle),
body.dev-off button[class*="delete"],
body.dev-off button[class*="remove"],
body.dev-off button[class*="move"],
body.dev-off button[class*="edit"],
body.dev-off .spell-add,
body.dev-off .don-add,
body.dev-off .objet-add,
body.dev-off .category-add,
body.dev-off .add-*,
body.dev-off [data-bound] .up,
body.dev-off [data-bound] .rm,
body.dev-off [data-bound] label,
body.dev-off [data-bound] button,
body.dev-off .illus[data-bound] .up,
body.dev-off .illus[data-bound] .rm,
body.dev-off .illus[data-bound] label,
body.dev-off .illus[data-bound] button,
body.dev-off .illus[data-bound] input[type="file"],
body.dev-off [data-dev-only],
body.dev-off div[data-dev-only],
body.dev-off .dev-mode-buttons,
body.dev-off .manage-tags-btn,
body.dev-off .add-monster-btn,
body.dev-off button[data-content-type],
body.dev-off .tags-manager-btn,
body.dev-off .filter-manager-btn,
body.dev-off button[class*="tags"],
body.dev-off button[class*="manage"],
/* Specific button selectors */
body.dev-off button[data-category-name],
body.dev-off button[data-spell-name],
body.dev-off button[data-don-name],
body.dev-off button[data-section-name],
body.dev-off button[data-section-type],
/* Input file upload elements */
body.dev-off input[type="file"],
body.dev-off label[for*="file"],
/* Additional specific selectors */
body.dev-off .add-subclass-btn,
body.dev-off .add-new-section,
/* COMPREHENSIVE EDIT BUTTON HIDING */
body.dev-off .edit-btn,
body.dev-off .edit-title-btn,
body.dev-off .edit-paragraph-btn,
body.dev-off .edit-list-btn,
body.dev-off .edit-field-btn,
body.dev-off .edit-effect-btn,
body.dev-off .edit-stats-btn,
body.dev-off .edit-section-btn,
body.dev-off button.edit-btn,
body.dev-off button.edit-title-btn,
body.dev-off button.edit-paragraph-btn,
body.dev-off button.edit-list-btn,
body.dev-off button.edit-field-btn,
body.dev-off button.edit-effect-btn,
body.dev-off button.edit-stats-btn,
body.dev-off button.edit-section-btn,
body.dev-off .editable-section .edit-btn,
body.dev-off .editable-section button[class*="edit"],
body.dev-off .card .edit-btn,
body.dev-off .card button[class*="edit"],
body.dev-off .editable-item .edit-btn,
body.dev-off .editable-item button[class*="edit"],
body.dev-off [data-section-type] .edit-btn,
body.dev-off [data-section-type] button[class*="edit"],
body.dev-off .add-*-btn,
/* Very specific selectors for inline styled buttons */
body.dev-off button[style*="background: #ff6b6b"],
body.dev-off button[style*="background: var(--bronze)"],
body.dev-off button[style*="background: #dc2626"],
body.dev-off button[style*="background: var(--accent)"],
/* Target buttons by text content patterns */
body.dev-off .btn.small[data-category-name],
body.dev-off .btn.small[data-spell-name],  
body.dev-off .btn.small[data-don-name],
body.dev-off .btn.small[data-section-name],
body.dev-off .btn.small[data-don-index],
/* ULTRA FORCÉ - Cacher TOUS les boutons de gestion des tags */
/* ULTRA-SPECIFIC RULES FOR IMAGE UPLOAD BUTTONS */
body.dev-off .illus label.up,
body.dev-off .illus button.rm,
body.dev-off label:contains("📷"),
body.dev-off label:contains("Ajouter"),
body.dev-off button:contains("🗑"),
body.dev-off button:contains("Retirer"),
body.dev-off .card .illus .up,
body.dev-off .card .illus .rm,
body.dev-off .card .illus label,
body.dev-off .card .illus button,
body.dev-off .card [data-bound] .up,
body.dev-off .card [data-bound] .rm,
/* ULTRA-SPECIFIC RULES FOR OBJECTS PAGE */
body.dev-off article[data-page="objets"] .illus label.up,
body.dev-off article[data-page="objets"] .illus button.rm,
body.dev-off article[data-page="objets"] .card .illus label,
body.dev-off article[data-page="objets"] .card .illus button,
body.dev-off #objets-container .illus label.up,
body.dev-off #objets-container .illus button.rm,
body.dev-off #objets-container .card .illus label,
body.dev-off #objets-container .card .illus button,
/* RULES WITH DATA ATTRIBUTES FOR OBJECTS */
body.dev-off .card[data-type="objet"] .illus label.up,
body.dev-off .card[data-type="objet"] .illus button.rm,
body.dev-off .card[data-type="objet"] .illus label,
body.dev-off .card[data-type="objet"] .illus button,
body.dev-off .card[data-category="objets"] .illus label.up,
body.dev-off .card[data-category="objets"] .illus button.rm,
body.dev-off .card[data-category="objets"] .illus label,
body.dev-off .card[data-category="objets"] .illus button,
/* Collections d'objets page specific rules */
body.dev-off article[data-page="collections-objets"] .illus label.up,
body.dev-off article[data-page="collections-objets"] .illus button.rm,
body.dev-off article[data-page="collections-objets"] .illus label,
body.dev-off article[data-page="collections-objets"] .illus button,
body.dev-off #collection-items .illus label.up,
body.dev-off #collection-items .illus button.rm,
body.dev-off #collection-items .illus label,
body.dev-off #collection-items .illus button,
/* ULTRA-SPECIFIC RULES FOR TAG MANAGER BUTTONS */
body.dev-off button.manage-tags-btn,
body.dev-off button.tags-manager-btn,
body.dev-off .btn.manage-tags-btn,
body.dev-off .btn.tags-manager-btn,
body.dev-off button[data-content-type="monster"],
body.dev-off button[data-content-type="objet"],
body.dev-off button[data-content-type="tableTresor"],
body.dev-off .dev-mode-buttons button,
body.dev-off div[data-dev-only] button,
body.dev-off div[data-dev-only],
body.dev-off .btn.btn-small.manage-tags-btn,
body.dev-off button.btn.btn-small.manage-tags-btn,
body.dev-off .dev-mode-buttons .manage-tags-btn,
body.dev-off [data-dev-only] .manage-tags-btn,
body.dev-off .tableTresor-add,
body.dev-off .add-monster-btn,
body.dev-off .btn.add-monster-btn,
body.dev-off .tags-manager-btn,
body.dev-off .filter-manager-btn,
body.dev-off button[title*="Gérer les tags"],
body.dev-off button[title*="gérer les tags"],
body.dev-off button[onclick*="showTagsManagementModal"],
body.dev-off button[onclick*="showMonsterTagsManagement"],
/* Additional super specific selectors for any possible generated button */
html body.dev-off button.manage-tags-btn,
html body.dev-off button.tags-manager-btn,
html body.dev-off .btn.manage-tags-btn,
html body.dev-off .btn.tags-manager-btn,
/* Text content matching */
body.dev-off button:contains("🏷️ Gérer les tags"),
body.dev-off button:contains("Gérer les tags") {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  position: absolute !important;
  left: -9999px !important;
  width: 0 !important;
  height: 0 !important;
  overflow: hidden !important;
  pointer-events: none !important;
}

/* Styles for dev buttons container */
.dev-buttons-container {
  display: flex;
  gap: 8px;
  margin-bottom: 1rem;
  flex-wrap: wrap;
}

/* Hide dev buttons container completely in dev-off mode */
body.dev-off .dev-buttons-container,
body.dev-off div[data-dev-only] {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
}

/* Element selectors for spells and monsters - Solution ultra-forcée */
.spell-element-selector,
.spell-element-selector *,
div.spell-element-selector,
.card .spell-element-selector,
.monster-element-selector,
.monster-element-selector *,
div.monster-element-selector,
.card .monster-element-selector {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  position: absolute !important;
  left: -9999px !important;
  width: 0 !important;
  height: 0 !important;
  overflow: hidden !important;
}

/* Modal buttons should always be visible */
dialog .delete-monster-tag-btn,
dialog .btn,
dialog button {
  display: inline-flex !important;
  visibility: visible !important;
  opacity: 1 !important;
  pointer-events: auto !important;
  position: static !important;
  left: auto !important;
  width: auto !important;
  height: auto !important;
  overflow: visible !important;
}

/* SEULEMENT visible en mode dev */
body.dev-on .spell-element-selector,
body.dev-on .spell-element-selector *,
body.dev-on div.spell-element-selector,
body.dev-on .card .spell-element-selector,
body.dev-on .monster-element-selector,
body.dev-on .monster-element-selector *,
body.dev-on div.monster-element-selector,
body.dev-on .card .monster-element-selector {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  position: static !important;
  left: auto !important;
  width: auto !important;
  height: auto !important;
  overflow: visible !important;
}

body.dev-off .spell-element-display,
body.dev-off .monster-element-display {
  display: block !important;
}

body.dev-on .spell-element-display,
body.dev-on .monster-element-display {
  display: none !important;
}

/* COMPREHENSIVE SHOW RULES FOR DEV MODE - High specificity to override dev-off hiding */
body.dev-on .edit-btn,
body.dev-on button.edit-btn,
body.dev-on button[class*="edit"],
body.dev-on button[class*="add"]:not(.menu-toggle),
body.dev-on button[class*="delete"],
body.dev-on button[class*="remove"],
body.dev-on button[class*="move"],
body.dev-on .section-delete,
body.dev-on .spell-delete,
body.dev-on .don-delete,
body.dev-on .add-subclass-btn,
body.dev-on .delete-subclass-btn,
body.dev-on .add-paragraph-btn,
body.dev-on .remove-section-btn,
body.dev-on .illus .up,
body.dev-on .illus .rm,
body.dev-on .illus label,
body.dev-on .illus input[type="file"],
body.dev-on button[data-category-name],
body.dev-on button[data-spell-name],
body.dev-on button[data-don-name],
body.dev-on button[data-section-name],
body.dev-on button[data-section-type],
/* Extra specific selectors to match the hiding rules exactly */
body.dev-on .spell-add,
body.dev-on .don-add,
body.dev-on .objet-add,
body.dev-on .category-add,
body.dev-on .spell-category-delete,
body.dev-on .don-category-delete,
body.dev-on .objet-category-delete,
body.dev-on .don-move-up,
body.dev-on .don-move-down,
body.dev-on button[title*="Éditer"],
body.dev-on button[title*="Edit"],
body.dev-on button[title*="Supprimer"],
body.dev-on button[title*="Ajouter"],
body.dev-on [data-dev-only],
body.dev-on .dev-mode-buttons,
body.dev-on .manage-tags-btn,
body.dev-on .add-monster-btn,
body.dev-on .tags-manager-btn {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  pointer-events: auto !important;
  position: relative !important;
}

/* Limit objects to max 4 per row in dev mode */
body.dev-on #objets-container {
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  max-width: 1300px; /* Ensures max 4 columns on most screens */
}

/* Force max 4 columns on larger screens in dev mode */
@media (min-width: 1600px) {
  body.dev-on #objets-container {
    grid-template-columns: repeat(4, 1fr);
    max-width: 1300px;
  }
}

/* ULTIMATE SOLUTION: Force dimensions to prevent 0x0 collapse */
html body.dev-on .edit-btn,
html body.dev-on button[class*="edit"],
html body.dev-on button[class*="add"],
html body.dev-on button[class*="delete"],
html body.dev-on .section-delete,
html body.dev-on .add-paragraph-btn {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  width: 28px !important;
  height: 28px !important;
  min-width: 28px !important;
  min-height: 28px !important;
  background: rgba(139,69,19,0.1) !important;
  border: 1px solid var(--bronze) !important;
  border-radius: 6px !important;
  color: var(--bronze) !important;
  font-size: 14px !important;
  padding: 4px !important;
  margin-left: 8px !important;
  box-sizing: border-box !important;
  line-height: 1 !important;
  cursor: pointer !important;
  position: relative !important;
  top: 0 !important;
  left: 0 !important;
  transform: none !important;
  z-index: 10 !important;
}
/* Target specific button classes from renderer */
body.dev-off .spell-add,
body.dev-off .don-add,
body.dev-off .objet-add,
body.dev-off .spell-delete,
body.dev-off .don-delete,
body.dev-off .objet-delete,
body.dev-off .spell-category-delete,
body.dev-off .don-category-delete,
body.dev-off .objet-category-delete,
body.dev-off .don-move-up,
body.dev-off .don-move-down,
body.dev-off .section-delete,
body.dev-off .remove-section-btn,
/* Universal button selectors with edit-related titles */
body.dev-off button[title*="diter"],
body.dev-off button[title*="Edit"],
body.dev-off button[title*="Supprimer"],
body.dev-off button[title*="Ajouter"],
body.dev-off button[title*="Haut"],
body.dev-off button[title*="Bas"],
/* AJOUT: Sélecteurs pour les boutons add/delete */
body.dev-off button[class*="add"],
body.dev-off button[class*="delete"],
body.dev-off button[class*="remove"],
body.dev-off button[class*="move"],
body.dev-off button[class*="upload"],
body.dev-off button[class*="edit"] {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  pointer-events: none !important;
}

/* Exception: les boutons favoris doivent TOUJOURS être visibles */
body.dev-off button.favoris-star,
body.dev-on button.favoris-star {
  display: flex !important;
  visibility: visible !important;
  opacity: 1 !important;
  pointer-events: auto !important;
}

/* SPÉCIFIQUE: Règles avec spécificité maximale pour forcer le masquage */
body.dev-off button.spell-add.btn,
body.dev-off button.don-add.btn,
body.dev-off button.objet-add.btn,
body.dev-off button.spell-category-delete.btn,
body.dev-off button.don-category-delete.btn,
body.dev-off button.objet-category-delete.btn,
/* ULTRA-SPÉCIFIQUE: Tags manager buttons */
body.dev-off button.tags-manager-btn.btn,
body.dev-off button.filter-manager-btn.btn,
html body.dev-off .tags-manager-btn,
html body.dev-off .filter-manager-btn,
html body.dev-off button.tags-manager-btn,
html body.dev-off button.filter-manager-btn {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  pointer-events: none !important;
}

/* Ancien système d'agrandissement - désactivé */
.illus img.enlarged {
  /* Plus de style ici - géré par JavaScript modal */
}

/* Forcer l'état stable sur hover pour les images agrandies */
.illus img.enlarged:hover,
article[data-page="guerrier"] .illus img.enlarged:hover,
article[data-page="mage"] .illus img.enlarged:hover,
article[data-page="pretre"] .illus img.enlarged:hover,
article[data-page="rodeur"] .illus img.enlarged:hover,
article[data-page="enchanteur"] .illus img.enlarged:hover,
.illus[data-illus-key^="class:"] img.enlarged:hover,
article[data-page="sorts-mage"] .illus img.enlarged:hover,
article[data-page="sorts-pretre"] .illus img.enlarged:hover,
article[data-page="sorts-enchanteur"] .illus img.enlarged:hover,
.illus[data-illus-key^="spellcategory:"] img.enlarged:hover {
  transform:translate(-50%, -50%) !important;
  transition:none !important;
}

/* Ancien backdrop - plus utilisé */
.image-backdrop {
  display: none !important;
}

/* Interactive buttons */
.btn-action{display:inline-flex;gap:var(--space-sm);align-items:center;padding:var(--space-sm) 10px;border-radius:10px;cursor:pointer;border:1px solid}
.btn-upload{border-color:rgba(0,0,0,.25);border-style:dashed;background:#fff8ee}
.btn-remove{border-color:rgba(120,0,0,.25);background:#fee2e2}
.btn-add{border-color:rgba(0,120,0,.25);background:#f0fff4;margin-bottom:10px}
.btn-delete{padding:var(--space-xs) var(--space-md);border-radius:6px;font-size:12px;margin-left:10px}
.illus .up{border-color:rgba(0,0,0,.25);border-style:dashed;background:#fff8ee}
.illus .rm, .spell-delete{border-color:rgba(120,0,0,.25);background:#fee2e2}
.spell-add{border-color:rgba(0,120,0,.25);background:#f0fff4;margin-bottom:10px}
.spell-delete{padding:var(--space-xs) var(--space-md);border-radius:6px;font-size:12px;margin-left:10px}

/* Bouton d'ajout de paragraphe - seulement dans les articles */
.add-paragraph-btn {
  display:none !important;
}
/* Masquer explicitement dans la sidebar et le sommaire */
.sidebar .add-paragraph-btn,
.toc .add-paragraph-btn,
#toc .add-paragraph-btn {
  display:none !important;
  visibility:hidden !important;
}
/* Afficher SEULEMENT dans les articles actifs en mode dev */
body.dev-on article.active .add-paragraph-btn {
  display:block !important; margin:10px 0; padding:8px 12px; background:var(--card); 
  border:2px dashed var(--bronze); border-radius:8px; cursor:pointer;
  color:var(--bronze); text-align:center; transition:all .2s ease;
}
body.dev-on article.active .add-paragraph-btn:hover {
  background:rgba(139,69,19,.08); border-color:var(--gold);
  color:var(--gold);
}

/* Bouton d'ajout de sous-classe */
.add-subclass-btn {
  display:none; margin:12px 0 4px 0; padding:8px 12px; background:var(--card);
  border:1px dashed var(--bronze); border-radius:8px; cursor:pointer;
  color:var(--bronze); text-align:center; font-size:13px;
  transition:all .2s ease; width:100%;
}
/* Afficher dans les pages de classes en mode dev */
body.dev-on article[data-page="guerrier"] .add-subclass-btn,
body.dev-on article[data-page="mage"] .add-subclass-btn,
body.dev-on article[data-page="pretre"] .add-subclass-btn,
body.dev-on article[data-page="rodeur"] .add-subclass-btn,
body.dev-on article[data-page="enchanteur"] .add-subclass-btn {
  display:block !important;
}
body.dev-on article[data-page="guerrier"] .add-subclass-btn:hover,
body.dev-on article[data-page="mage"] .add-subclass-btn:hover,
body.dev-on article[data-page="pretre"] .add-subclass-btn:hover,
body.dev-on article[data-page="rodeur"] .add-subclass-btn:hover,
body.dev-on article[data-page="enchanteur"] .add-subclass-btn:hover {
  background:rgba(139,69,19,.08); border-color:var(--gold);
  color:var(--gold); transform:translateY(-1px);
  box-shadow:0 4px 8px rgba(0,0,0,.1);
}

/* Modales */
.category-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.category-modal.visible {
  display:flex;
}
.category-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:500px; width:90%; box-shadow:var(--shadow);
  position:relative;
}

/* Modal pour les icônes */
.icons-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.icons-modal.visible {
  display:flex;
}
.icons-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:600px; width:90%; max-height:80vh; overflow-y:auto;
  box-shadow:var(--shadow); position:relative;
}
.icons-grid {
  display:grid; grid-template-columns:repeat(auto-fill, minmax(60px, 1fr));
  gap:var(--space-md); margin:var(--space-xl) 0; max-height:400px; overflow-y:auto;
  border:1px solid var(--rule); border-radius:var(--space-md); padding:var(--space-xl);
}
.icon-item {
  display:flex; align-items:center; justify-content:center;
  padding:var(--space-lg); border:1px solid var(--rule); border-radius:var(--space-md);
  cursor:pointer; transition:var(--transition-fast); font-size:24px;
  background:var(--paper);
}
.icon-item:hover {
  background:var(--bronze); color:white; transform:scale(1.1);
  box-shadow:0 4px 8px rgba(0,0,0,.2);
}
.icon-item.copied {
  background:var(--gold); color:white; animation:copyFlash .5s ease;
}
@keyframes copyFlash {
  0% { transform:scale(1.1); }
  50% { transform:scale(1.3); }
  100% { transform:scale(1.1); }
}

/* Modal pour les éléments */
.elements-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:2147483647; display:none; align-items:center; justify-content:center;
}
.elements-modal.visible {
  display:flex;
}
.elements-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:400px; width:90%; 
  box-shadow:var(--shadow); position:relative;
}
.elements-list {
  display:flex; flex-direction:column; gap:var(--space-md); margin:var(--space-xl) 0;
}
.element-item {
  display:flex; align-items:center; gap:var(--space-md); padding:var(--space-md);
  border:2px solid var(--rule); border-radius:var(--space-md); cursor:pointer;
  transition:var(--transition-fast); background:var(--card);
}
.element-item:hover {
  background:var(--paper); border-color:var(--bronze); transform:translateY(-2px);
  box-shadow:0 4px 12px rgba(0,0,0,.1);
}
.element-item:active {
  transform:translateY(0) scale(0.98);
}
.element-icon {
  width:24px; height:24px; border-radius:50%; flex-shrink:0;
}
.element-name {
  font-weight:600; flex-grow:1;
}
.copy-indicator {
  font-size:12px; color:var(--paper-muted); opacity:0;
  transition:opacity 0.3s ease;
}
.element-item.copied .copy-indicator {
  opacity:1;
}

/* États modal styles */
.etats-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:2147483647; display:none; align-items:center; justify-content:center;
}
.etats-modal.visible {
  display:flex;
}
.etats-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:500px; width:90%; 
  box-shadow:var(--shadow); position:relative; max-height:80vh; overflow-y:auto;
}
.etats-list {
  display:flex; flex-direction:column; gap:var(--space-md); margin:var(--space-xl) 0;
}
.etat-item {
  display:flex; align-items:flex-start; gap:var(--space-md); padding:var(--space-md);
  border:2px solid var(--rule); border-radius:var(--space-md); cursor:pointer;
  transition:var(--transition-fast); background:var(--card); position:relative;
}
.etat-content {
  flex:1; display:flex; flex-direction:column;
}
.etat-item:hover {
  background:var(--paper); border-color:var(--bronze); transform:translateY(-2px);
  box-shadow:0 4px 12px rgba(0,0,0,.1);
}
.etat-item:active {
  transform:translateY(0) scale(0.98);
}
.etat-icon {
  width:24px; height:24px; border-radius:50%; flex-shrink:0;
  background:var(--bronze); color:white; display:flex; align-items:center;
  justify-content:center; font-size:14px;
}
.etat-name {
  font-weight:600; color:var(--accent-ink); margin-bottom:4px;
}
.etat-description {
  font-size:12px; color:var(--paper-muted); line-height:1.4;
}
.etat-item .copy-indicator {
  position:absolute; top:50%; right:var(--space-md); transform:translateY(-50%);
  font-size:12px; color:var(--bronze); opacity:0; font-weight:600;
  transition:opacity 0.3s ease;
}
.etat-item.copied .copy-indicator {
  opacity:1;
}

/* Styles pour les tooltips d'états */
span[title] {
  cursor: help;
  border-bottom: 2px solid var(--bronze);
  position: relative;
  display: inline-block;
  background: linear-gradient(135deg, rgba(205,127,50,0.1), rgba(212,175,55,0.05));
  padding: 2px 4px;
  border-radius: 3px;
  font-weight: 700;
}

/* Styles pour les liens de sorts */
.spell-link {
  color: #ea7332 !important; /* Orange au lieu du jaune */
  cursor: pointer;
  text-decoration: underline;
  font-weight: 600;
  transition: color 0.2s ease;
}

.spell-link:hover {
  color: var(--bronze) !important;
}

/* Styles pour les liens d'états */
.etat-link {
  color: #ea7332 !important; /* Orange au lieu du jaune */
  cursor: pointer;
  text-decoration: underline;
  font-weight: 600;
  transition: color 0.2s ease;
}

.etat-link:hover {
  color: var(--bronze) !important;
}

/* Modal des liens de sorts */
.spell-links-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  z-index: 2147483647;
  display: none;
  align-items: center;
  justify-content: center;
}

.spell-links-modal.visible {
  display: flex;
}

.spell-links-modal-content {
  background: var(--card);
  border: 2px solid var(--rule);
  border-radius: 16px;
  padding: var(--space-2xl);
  max-width: 600px;
  width: 90%;
  box-shadow: var(--shadow);
  position: relative;
  max-height: 80vh;
  overflow-y: auto;
}

.spell-item {
  display: flex;
  align-items: flex-start;
  gap: var(--space-md);
  padding: var(--space-md);
  border: 2px solid var(--rule);
  border-radius: var(--space-md);
  cursor: pointer;
  transition: var(--transition-fast);
  background: var(--card);
  position: relative;
  margin-bottom: 8px;
}

.spell-item:hover {
  background: var(--paper);
  border-color: var(--bronze);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.spell-item:active {
  transform: translateY(0) scale(0.98);
}

.spell-info {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.spell-name {
  font-weight: 600;
  margin-bottom: 4px;
  font-size: 14px;
}

.spell-meta {
  font-size: 12px;
  color: var(--paper-muted);
  margin-bottom: 6px;
}

.spell-description {
  font-size: 14px;
  color: var(--paper-muted);
  line-height: 1.4;
}

.spell-item .copy-indicator {
  position: absolute;
  top: 50%;
  right: var(--space-md);
  transform: translateY(-50%);
  font-size: 12px;
  color: var(--bronze);
  opacity: 0;
  font-weight: 600;
  transition: opacity 0.3s ease;
}

.spell-item.copied .copy-indicator {
  opacity: 1;
}

/* Styles pour les monstres - identiques aux sorts */
.monster-item {
  display: flex;
  align-items: flex-start;
  gap: var(--space-md);
  padding: var(--space-md);
  border: 2px solid var(--rule);
  border-radius: var(--space-md);
  cursor: pointer;
  transition: var(--transition-fast);
  background: var(--card);
  position: relative;
  margin-bottom: 8px;
}

.monster-item:hover {
  background: var(--paper);
  border-color: var(--bronze);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.monster-item:active {
  transform: translateY(0) scale(0.98);
}

.monster-info {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.monster-name {
  font-weight: 600;
  margin-bottom: 4px;
  font-size: 14px;
}

.monster-meta {
  font-size: 12px;
  color: var(--paper-muted);
  margin-bottom: 6px;
}

.monster-description {
  font-size: 14px;
  color: var(--paper-muted);
  line-height: 1.4;
}

.monster-item .copy-indicator {
  position: absolute;
  top: 50%;
  right: var(--space-md);
  transform: translateY(-50%);
  font-size: 12px;
  color: var(--bronze);
  opacity: 0;
  font-weight: 600;
  transition: opacity 0.3s ease;
}

.monster-item.copied .copy-indicator {
  opacity: 1;
}

/* Popup de prévisualisation des monstres */
.monster-preview-popup {
  position: fixed;
  z-index: 10001;
  background: var(--card);
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  max-width: 450px;
  max-height: 600px;
  overflow-y: auto;
  font-family: 'Roboto', sans-serif;
  line-height: 1.4;
}

.monster-preview-popup .monster-preview-header {
  background: linear-gradient(135deg, var(--bronze), var(--accent));
  color: white;
  padding: var(--space-lg);
  border-radius: 8px 8px 0 0;
  font-weight: bold;
  font-size: 16px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.monster-preview-popup .monster-preview-content {
  padding: var(--space-lg);
}

.monster-preview-popup .monster-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
  gap: 8px;
  margin: var(--space-md) 0;
}

.monster-preview-popup .monster-stat {
  background: var(--paper);
  padding: 8px;
  border-radius: 4px;
  text-align: center;
  font-size: 12px;
}

.monster-preview-popup .monster-stat-label {
  font-weight: 600;
  color: var(--paper-muted);
  margin-bottom: 2px;
}

.monster-preview-popup .monster-stat-value {
  font-weight: bold;
  font-size: 14px;
}

/* Popup de prévisualisation des sorts */
.spell-preview-popup {
  position: fixed;
  z-index: 10001;
  background: var(--card);
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  max-width: 400px;
  max-height: 500px;
  overflow-y: auto;
  font-family: 'Roboto', sans-serif;
  line-height: 1.4;
}

.spell-preview-content {
  padding: 0;
}

.spell-preview-header {
  padding: 16px;
  background: var(--paper);
  border-radius: 8px 8px 0 0;
  position: relative;
  border-left: 4px solid var(--accent);
}

.spell-title {
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 4px;
  font-family: 'Cinzel', serif;
}

/* Règle générale pour spell-element dans les cartes */
.card .spell-element {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  /* Pas de couleur par défaut - utilise les couleurs inline des éléments */
}

/* Couleur de fallback uniquement si aucune couleur inline n'est définie */
.card .spell-element:not([style*="color"]) {
  color: var(--paper-muted);
}

/* Badge d'élément avec texte noir pour lisibilité */
.element-badge {
  color: var(--paper-ink) !important;
  text-shadow: none !important;
}

/* S'assurer que la toolbox dev reste cliquable même avec modale ouverte */
#devToggle,
#devToolbox,
.tools,
.dev-toolbox {
  position: relative;
  z-index: 999999 !important;
}

/* Boutons de la toolbox dev toujours cliquables */
body.dev-on #devToggle,
body.dev-on #devToolbox *,
body.dev-on .tools *,
body.dev-on .dev-toolbox * {
  z-index: 999999 !important;
  pointer-events: auto !important;
}

/* Z-index maximum pour l'interface dev au-dessus des modales et dialogues */
.tools button,
.dev-toolbox button,
#devToggle,
#devToolbox button {
  z-index: 9999999 !important;
  position: relative;
}

/* Conteneur principal des outils dev */
.tools,
.dev-toolbox {
  z-index: 9999999 !important;
  position: relative;
}

/* Forcer les modales toolbox à apparaître devant les dialogues d'édition HTML */
.elements-modal,
.etats-modal, 
.spell-links-modal,
.monster-links-modal {
  z-index: 2147483647 !important; /* Maximum z-index possible */
}

.elements-modal-content,
.etats-modal-content,
.spell-links-modal-content,
.monster-links-modal-content {
  z-index: 2147483647 !important;
  position: relative;
}

/* Règle spécifique pour spell-element dans les popups de prévisualisation */
.spell-preview-popup .spell-element {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  /* Pas de couleur définie ici - elle sera définie en inline */
}

/* Force les couleurs des éléments - spécificité maximale */
.spell-links-modal .spell-meta[style*="color"],
.spell-preview-popup .spell-element[style*="color"] {
  color: var(--accent-ink) !important;
}

/* Règles pour les nouveaux attributs de données */
[data-element-display],
[data-spell-meta] {
  color: inherit !important;
  font-weight: 600;
}

/* Alternative: couleurs directes par élément */
.spell-preview-popup .spell-element[style*="#e25822"] { color: #e25822 !important; }
.spell-preview-popup .spell-element[style*="#2563eb"] { color: #2563eb !important; }
.spell-preview-popup .spell-element[style*="#92400e"] { color: #92400e !important; }
.spell-preview-popup .spell-element[style*="#059669"] { color: #059669 !important; }
.spell-preview-popup .spell-element[style*="#d97706"] { color: #d97706 !important; }
.spell-preview-popup .spell-element[style*="#6b21a8"] { color: #6b21a8 !important; }
.spell-preview-popup .spell-element[style*="#7c2d12"] { color: #7c2d12 !important; }
.spell-preview-popup .spell-element[style*="#7c3aed"] { color: #7c3aed !important; }

.spell-links-modal .spell-meta[style*="#e25822"] { color: #e25822 !important; }
.spell-links-modal .spell-meta[style*="#2563eb"] { color: #2563eb !important; }
.spell-links-modal .spell-meta[style*="#92400e"] { color: #92400e !important; }
.spell-links-modal .spell-meta[style*="#059669"] { color: #059669 !important; }
.spell-links-modal .spell-meta[style*="#d97706"] { color: #d97706 !important; }
.spell-links-modal .spell-meta[style*="#6b21a8"] { color: #6b21a8 !important; }
.spell-links-modal .spell-meta[style*="#7c2d12"] { color: #7c2d12 !important; }
.spell-links-modal .spell-meta[style*="#7c3aed"] { color: #7c3aed !important; }

/* Page Links Modal */
.page-links-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  z-index: 2147483647;
  display: none;
  align-items: center;
  justify-content: center;
}

.page-links-modal.visible {
  display: flex;
}

.page-links-modal-content {
  background: var(--card);
  border: 2px solid var(--rule);
  border-radius: 16px;
  padding: var(--space-2xl);
  max-width: 600px;
  width: 90%;
  box-shadow: var(--shadow);
  position: relative;
  max-height: 80vh;
  overflow-y: auto;
}

.page-item {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  padding: 12px;
  margin-bottom: 8px;
  border: 1px solid var(--rule);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  background: var(--surface);
}

.page-item:hover {
  background: var(--accent-bg);
  border-color: var(--accent);
  transform: translateX(4px);
}

.page-item.copied {
  background: rgba(34, 197, 94, 0.1);
  border-color: #22c55e;
}

.page-info {
  flex: 1;
}

.page-name {
  font-weight: 600;
  color: var(--accent-ink);
  margin-bottom: 4px;
  font-size: 14px;
}

.page-section {
  font-size: 12px;
  color: var(--paper-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.copy-indicator {
  position: absolute;
  top: 50%;
  right: 12px;
  transform: translateY(-50%);
  background: #22c55e;
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.page-item.copied .copy-indicator {
  opacity: 1;
}

@media (max-width: 768px) {
  .page-links-modal-content {
    max-width: calc(100vw - 16px);
    padding: 16px;
  }
}

.spell-preview-close {
  position: absolute;
  top: 12px;
  right: 12px;
  background: none;
  border: none;
  font-size: 16px;
  cursor: pointer;
  color: var(--paper-muted);
  padding: 4px;
  border-radius: 4px;
  transition: all 0.2s ease;
}

.spell-preview-close:hover {
  background: var(--rule);
  color: var(--accent-ink);
}

.spell-preview-body {
  padding: 16px;
}

/* États preview popup */
.etat-preview-popup {
  position: fixed;
  z-index: 10001;
  background: var(--card);
  border: 2px solid #7c2d12;
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.3);
  max-width: 300px;
  padding: 1rem;
  font-size: 14px;
  line-height: 1.4;
  color: var(--paper-ink);
  pointer-events: auto;
}

.etat-preview-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--rule);
}

.etat-title {
  font-weight: 600;
  font-size: 16px;
  color: #7c2d12;
}

.etat-preview-close {
  background: none;
  border: none;
  font-size: 16px;
  cursor: pointer;
  color: var(--paper-muted);
  padding: 4px;
  border-radius: 4px;
  transition: all 0.2s ease;
}

.etat-preview-close:hover {
  background: var(--rule);
  color: var(--accent-ink);
}

.etat-preview-body {
  margin-top: 0.5rem;
}

.etat-description {
  white-space: pre-line;
}

.spell-field {
  margin-bottom: 12px;
  font-size: 14px;
  line-height: 1.5;
}

.spell-field:last-child {
  margin-bottom: 0;
}

.spell-description {
  margin-bottom: 16px;
  font-style: italic;
  color: var(--paper-muted);
  font-size: 14px;
}

/* Responsive pour mobile */
@media (max-width: 768px) {
  .spell-preview-popup {
    max-width: calc(100vw - 16px);
    max-height: calc(100vh - 32px);
    left: 8px !important;
    top: 16px !important;
  }
  
  .spell-links-modal-content {
    max-width: calc(100vw - 16px);
    padding: 16px;
  }
}

span[title]:hover {
  border-bottom-color: var(--gold);
  border-bottom-width: 3px;
  background: linear-gradient(135deg, rgba(212,175,55,0.2), rgba(205,127,50,0.1));
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* Tooltip personnalisé pour une meilleure visibilité */
span[title]:hover::after {
  content: attr(title);
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: var(--accent-ink);
  color: white;
  padding: 10px 15px;
  border-radius: 8px;
  font-size: 13px;
  white-space: pre-line;
  z-index: 999999;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  pointer-events: none;
  min-width: 200px;
  max-width: 320px;
  text-align: center;
  line-height: 1.5;
  animation: tooltipFadeIn 0.3s ease;
  border: 2px solid var(--gold);
  word-wrap: break-word;
}

span[title]:hover::before {
  content: '';
  position: absolute;
  bottom: calc(100% + 2px);
  left: 50%;
  transform: translateX(-50%);
  border: 6px solid transparent;
  border-top-color: var(--accent-ink);
  z-index: 999999;
  pointer-events: none;
}

/* Forcer l'overflow visible pour les tooltips */
.card:has(span[title]:hover),
.editable:has(span[title]:hover),
article:has(span[title]:hover) {
  overflow: visible !important;
}

/* Fallback pour navigateurs sans :has() */
.card,
.editable,
article {
  position: relative;
}

.card span[title]:hover::after,
.editable span[title]:hover::after,
article span[title]:hover::after {
  z-index: 99999 !important;
}

@keyframes tooltipFadeIn {
  from { opacity: 0; transform: translateX(-50%) translateY(5px); }
  to { opacity: 1; transform: translateX(-50%) translateY(0); }
}

/* === UNIFIED EDIT BUTTONS FOR ALL SECTIONS === */
.editable-section {
  position: relative;
  margin: 8px 0;
}

.edit-btn {
  background: var(--bronze);
  color: white;
  border: none;
  border-radius: 6px;
  padding: 4px 8px;
  cursor: pointer;
  font-size: 12px;
  opacity: 0.7;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.edit-btn:hover {
  opacity: 1;
  transform: scale(1.05);
  background: var(--gold);
}

/* Inline edit buttons (titles, etc.) */
.edit-btn.edit-title-btn,
.edit-btn.edit-paragraph-btn {
  position: relative;
  margin-left: 8px;
}

/* Section edit buttons (absolute positioning) */
.editable-section .edit-btn.edit-section-btn,
[style*="position:relative"] .edit-btn.edit-section-btn {
  position: absolute;
  right: 8px;
  top: 8px;
  z-index: 10;
}

.editable-section:hover .edit-btn {
  opacity: 1;
  transform: scale(1.05);
  background: var(--gold);
}

.editable-section .edit-btn:hover {
  background: var(--gold) !important;
  transform: scale(1.1) !important;
  box-shadow: 0 3px 8px rgba(0,0,0,0.2);
}

.editable-section .edit-btn:active {
  transform: scale(0.95) !important;
}

/* Special positioning for different types */
.editable-list-container .edit-btn {
  right: 16px;
  top: 16px;
}

.editable-section[data-section-type="intro"] .edit-btn {
  right: 12px;
  top: 12px;
}

/* Title edit buttons */
.edit-title-btn {
  position: relative !important;
  right: auto !important;
  top: auto !important;
  margin-left: 12px;
  transform: none !important;
}

.edit-title-btn:hover {
  transform: scale(1.1) !important;
}

/* When editing, hide the button and expand content */
.editable-section[data-editing="true"] .edit-btn {
  display: none;
}

/* Visual feedback for editable sections */
.editable-section:hover {
  background: rgba(184, 134, 11, 0.05);
  border-radius: 8px;
  transition: background 0.2s ease;
}

.editable-section[data-editing="true"] {
  background: rgba(255, 255, 0, 0.1);
  border: 1px dashed var(--bronze);
  border-radius: 8px;
  padding: 8px;
}

/* Legacy support for old list items */
.editable-item {
  position: relative;
  padding-right: 40px;
}

.editable-content {
  display: block;
  margin-right: 35px;
}

/* === MJ-ONLY VISIBILITY CONTROLS === */
/* Show MJ-only elements when MJ state is active */
body.mj-on .mj-only {
  display: block !important;
}

/* Hide MJ-only elements by default and when MJ is off */
.mj-only,
body.mj-off .mj-only {
  display: none !important;
}

/* Show non-MJ elements by default and when MJ is off */
.non-mj-only,
body.mj-off .non-mj-only {
  display: block !important;
}

/* Hide non-MJ elements when MJ is on */
body.mj-on .non-mj-only {
  display: none !important;
}

/* For flex and inline-flex elements */
body.mj-on .mj-only[style*="display: flex"] {
  display: flex !important;
}

body.mj-on .mj-only[style*="display: inline-flex"] {
  display: inline-flex !important;
}

/* === DEV-ONLY VISIBILITY CONTROLS === */
/* Show dev-only elements when dev mode is active */
body.dev-on .dev-only {
  display: block !important;
}

/* Hide dev-only elements by default and when dev is off */
.dev-only,
body.dev-off .dev-only {
  display: none !important;
}

/* Show non-dev elements by default and when dev is off */
.non-dev-only,
body.dev-off .non-dev-only {
  display: block !important;
}

/* Hide non-dev elements when dev is on */
body.dev-on .non-dev-only {
  display: none !important;
}

/* For flex and inline-flex elements in dev mode */
body.dev-on .dev-only[style*="display: flex"] {
  display: flex !important;
}

body.dev-on .dev-only[style*="display: inline-flex"] {
  display: inline-flex !important;
}
/* ═══════════════════════════════════════════════════════════════════════════════════════
   🚀 SCROLL PERFORMANCE OPTIMIZATIONS
   ═══════════════════════════════════════════════════════════════════════════════════════ */

/* Smooth scrolling behavior */
html {
  scroll-behavior: smooth;
}

/* Optimize scroll performance during scrolling */
.scrolling * {
  pointer-events: none !important;
}

.scrolling .card,
.scrolling .spell-card,
.scrolling .item-card {
  transition: none !important;
  animation: none !important;
}

/* Content visibility optimizations for modern browsers - ONLY for visible articles */
/* EXCLUDE collections and filtered content to avoid display conflicts */
article.active .card:not([style*="display: none"]),
article.active .spell-card:not([style*="display: none"]), 
article.active .item-card:not([style*="display: none"]) {
  content-visibility: auto;
  contain-intrinsic-size: 0 250px;
  /* Lighter containment for better compatibility */
  contain: layout style;
}

/* Ensure hidden elements stay hidden */
article.active .card[style*="display: none"],
article.active .spell-card[style*="display: none"],
article.active .item-card[style*="display: none"] {
  display: none !important;
  content-visibility: hidden;
}

/* GPU acceleration for visible cards - ONLY in active articles */
article.active .card.visible,
article.active .spell-card.visible,
article.active .item-card.visible {
  transform: translateZ(0);
  backface-visibility: hidden;
  perspective: 1000px;
}

/* Virtualized viewport styling */
.virtualized-viewport {
  will-change: scroll-position;
  -webkit-overflow-scrolling: touch;
  scrollbar-width: thin;
  scrollbar-color: var(--bronze) transparent;
}

.virtualized-viewport::-webkit-scrollbar {
  width: 8px;
}

.virtualized-viewport::-webkit-scrollbar-track {
  background: rgba(212, 175, 55, 0.1);
  border-radius: 4px;
}

.virtualized-viewport::-webkit-scrollbar-thumb {
  background: var(--bronze);
  border-radius: 4px;
  border: 1px solid rgba(255, 255, 255, 0.2);
}

.virtualized-viewport::-webkit-scrollbar-thumb:hover {
  background: var(--gold);
}

.virtualized-content {
  overflow: hidden;
}

/* Lazy loading image optimizations */
img[loading="lazy"] {
  filter: blur(0.5px);
  transition: filter 0.3s ease;
}

img.lazy-loaded {
  filter: none;
}

img.lazy-load {
  background: linear-gradient(135deg, 
    rgba(212, 175, 55, 0.1) 0%, 
    rgba(139, 69, 19, 0.05) 100%);
  min-height: 120px;
  border-radius: 8px;
}

/* Class page specific optimizations - ONLY in active articles */
article.active .editable-section[data-section-type="subclass"] {
  contain: layout style;
}

.editable-section[data-loading-state="deferred"] {
  background: rgba(212, 175, 55, 0.02);
  border: 1px dashed rgba(139, 69, 19, 0.1);
}

.editable-section[data-loading-state="loaded"] {
  border: 1px solid var(--rule);
}

/* Optimize subclass images specifically */
.editable-section[data-section-type="subclass"] img {
  object-fit: contain;
  max-width: 100%;
  height: auto;
  image-rendering: -webkit-optimize-contrast;
}

/* Spell cards specific optimizations - ONLY if not filtered */
article.active .spell-card:not([style*="display: none"]) {
  /* More aggressive containment for complex spell cards */
  contain: layout style paint;
}

.spell-card[data-loading-state="deferred-spell"] {
  background: rgba(255, 107, 53, 0.03); /* Subtle fire color */
  border: 1px dashed rgba(226, 88, 34, 0.2);
}

.spell-card[data-loading-state="loaded"] {
  border: 1px solid var(--rule);
}

/* Optimize spell card internal elements */
article.active .spell-card hr {
  contain: layout paint;
  will-change: auto;
}

article.active .spell-card [data-edit-type="generic"] {
  /* Optimize complex text content in spells */
  contain: layout style;
}

/* Spell element badges optimization */
article.active .spell-card .spell-element {
  transform: translateZ(0);
  contain: layout paint;
}

/* Reduce reflow on spell cards during scroll */
.scrolling .spell-card * {
  pointer-events: none !important;
  will-change: auto !important;
}

/* Spell cards get priority GPU layers when visible */
article.active .spell-card:nth-child(-n+7) {
  transform: translateZ(0);
  backface-visibility: hidden;
}

/* Optimize animation performance during scroll */
@media (prefers-reduced-motion: no-preference) {
  article.active .card:not(.scrolling *) {
    transition: transform 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }
  
  article.active .card:not(.scrolling *):hover {
    transform: translateY(-1px) scale(1.005);
  }
}

/* Force hardware acceleration for smooth scrolling */
article.active {
  transform: translateZ(0);
  will-change: scroll-position;
}

article.active #views,
article.active .grid {
  transform: translateZ(0);
  backface-visibility: hidden;
}

/* Critical: Override any optimization for filtered/hidden content */
.card[style*="display: none"],
.card[style*="display:none"],
.spell-card[style*="display: none"],
.spell-card[style*="display:none"],
.item-card[style*="display: none"],
.item-card[style*="display:none"],
#collection-results[style*="display: none"],
#available-collections[style*="display: none"] {
  display: none !important;
  content-visibility: hidden !important;
  contain: none !important;
  opacity: 0 !important;
  pointer-events: none !important;
  position: absolute !important;
  left: -9999px !important;
  visibility: hidden !important;
  width: 0 !important;
  height: 0 !important;
  margin: 0 !important;
  padding: 0 !important;
  transform: none !important;
}

/* Ensure ID search works properly */
#objets-container .card[style*="display: none"] {
  display: none !important;
}

/* Reduce motion for accessibility */
@media (prefers-reduced-motion: reduce) {
  html {
    scroll-behavior: auto;
  }
  
  .card,
  .spell-card,
  .item-card {
    transition: none !important;
    animation: none !important;
    transform: none !important;
  }
}

/* Mobile scroll optimizations */
@media (max-width: 768px) {
  .card,
  .spell-card,
  .item-card {
    contain-intrinsic-size: 0 200px;
  }
  
  .virtualized-viewport {
    height: 60vh !important;
  }
  
  /* Prevent scroll bounce on iOS */
  body {
    overscroll-behavior-y: contain;
    -webkit-overflow-scrolling: touch;
  }
}

/* High DPI display optimizations */
@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 2dppx) {
  .card,
  .spell-card,
  .item-card {
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
  }
}

/* Container query optimizations for modern browsers */
@supports (container-type: inline-size) {
  #views {
    container-type: inline-size;
  }
  
  @container (max-width: 600px) {
    .card,
    .spell-card,
    .item-card {
      contain-intrinsic-size: 0 180px;
    }
  }
}

/* Focus management during scroll */
.scrolling :focus {
  outline: none;
}

/* Intersection Observer loading states */
.card[data-loading="true"] {
  background: linear-gradient(135deg, 
    rgba(212, 175, 55, 0.05) 0%, 
    rgba(139, 69, 19, 0.02) 100%);
  opacity: 0.7;
}

.card[data-loading="false"] {
  opacity: 1;
  transition: opacity 0.3s ease;
}

/* Performance hints for browsers */
.card,
.spell-card,
.item-card {
  /* Hint that this element will change */
  will-change: auto;
}

.card:hover,
.spell-card:hover,
.item-card:hover {
  will-change: transform;
}

/* Print optimizations */
@media print {
  .virtualized-viewport {
    height: auto !important;
    overflow: visible !important;
  }
  
  .virtualized-content {
    position: static !important;
    height: auto !important;
  }
  
  .card,
  .spell-card,
  .item-card {
    content-visibility: visible;
    contain: none;
    transform: none !important;
    position: static !important;
  }
}
</style>
</head>
<body class="dev-off">

<div class="shell">
  <button aria-controls="sidebar" aria-expanded="false" aria-label="Ouvrir le sommaire" class="menu-toggle" id="menuToggle" style="display:none">☰ Sommaire</button>
  <div class="backdrop" hidden="" id="backdrop"></div>
  
  <main class="page">
    <aside class="sidebar" id="sidebar">
      <div class="panel">
        <div class="tools">
          <!-- Dev mode disabled in standalone version -->
        </div>
        <div class="toc" id="toc">
          <!-- Table of contents will be generated by JavaScript -->
        </div>
      </div>
    </aside>
    
    <div id="views">
      <!-- Main content will be generated by JavaScript -->
      <div id="app-loading">Chargement...</div>
    </div>
  </main>
  
  <footer></footer>
</div>

<script>

    // Ensure window object exists
    window = window || {};
    
    // Global data from modular files
    window.SORTS = [
  {
    "nom": "Sorts de Mage",
    "description": "Sorts de destruction.",
    "sorts": [
      {
        "nom": "Boule de Feu",
        "element": "Feu",
        "description": "Lance une boule de feu sur un adversaire, qui peut s'enflammer.",
        "categorie": "Mage",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> 15m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 4",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige 5 dégats de <span style=\"color: #e25822; font-weight: bold;\">Feu</span> à la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Les dégats passent à 7 et la cible s'enflamme, infligeant 5 dégats de feu au prochain tour du lanceur."
      },
      {
        "nom": "Éclair",
        "element": "Air",
        "description": "Le lanceur concentre une sphère crépitante d’énergie instable qui fuse vers sa cible et explose dans un éclair.",
        "categorie": "Mage",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> 12m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 4",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> Esquive.",
        "effetNormal": "<strong>Effet:</strong>  Inflige 5 dégats d'<span style=\"color: #22c55e; font-weight: bold;\">Air</span> à la cible.<br> Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique: </strong> Les dégâts passent à 7 et ils sont aussi infligé à un ennemi à moins de 3m de la cible."
      },
      {
        "nom": "Vague déferlante",
        "element": "Eau",
        "description": "Une puissante vague d'eau s'abat sur vos ennemis et les repousse.",
        "categorie": "Sorts de Mage",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 2",
        "portee": "🎯 <strong>Portée:</strong> 6m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 8",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> Volant.",
        "effetNormal": "<strong>Effet:</strong> &nbsp;Inflige 7 dégats d'<span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span> aux créatures devant le lanceur (largeur 3m distance 6m) et les repousse jusqu'à 6m.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique: </strong> les dégats passent à 12 et les enemis sont touchés/repoussés à 12m."
      },
      {
        "nom": "Volée de pierres",
        "element": "Terre",
        "description": "Invoque une volée de pierres qui tournoient autour du lanceur, puis qui sont éjectées devant lui.",
        "categorie": "Sorts de Mage",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 2",
        "portee": "🎯 <strong>Portée:</strong> 6m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 8",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Inflige 7 dégats de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> aux créatures autour du lanceur (3m). <br>Puis inflige le même montant aux créatures devant le lanceur sur 6m.<br><br> Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Les dégats passent à 12. Les cibles non volantes et de taille moyennes sont <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span> pendant 1 tour."
      },
      {
        "nom": "Faisceau lumineux",
        "element": "Lumière",
        "description": "Un faisceau lumineux canalisé jaillit des mains du lanceur, transperçant les ennemis d’une énergie pure.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 3",
        "portee": "🎯 <strong>Portée:</strong> 9m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 10",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Inflige 10 points de dégats de <span style=\"color: #ffd700; font-weight: bold;\">Lumière</span>  aux créatures devant le lanceur (9m).\n<br><br>Le lanceur peut continuer de <b>canaliser</b> le sort (ne pouvant plus esquiver ou faire d'actions). S'il le fait, n'importe créature qui rendre dans la zone subit les dégats, et toutes les creatures encore dans la zone au prochain tour du lanceur subiront les dégats. A chaque début de tour, le lanceur consomme alors <b>la moitié du coût en mana</b> du sort.\n\n\n<br><br>Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique: </strong> Les dégats passent à 15, et les créatures ayant une Resistance alération inférieure à l'Intelligence du lanceur sont <span class=\"etat-link\" data-etat=\"Aveuglé\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Aveuglé</span> pendant 2 tours."
      },
      {
        "nom": "Vague sombre",
        "element": "Nuit",
        "description": "Une onde de ténèbres mouvantes se déploie, repoussant violemment les adversaires alentours.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 4",
        "portee": "🎯 <strong>Portée:</strong> 9m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 15",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong>  Inflige 13 dégats de <span style=\"color: #1a1a1a; font-weight: bold;\">Nuit</span> aux créatures dans un cone devant le lanceur (largeur 9m, distance 9m) et les repousse chacune de 3m.<br> Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique: </strong> Les dégats passent à 20 et les cibles sont repoussées de 6m."
      },
      {
        "nom": "Missile magique",
        "element": "Lumière",
        "description": "Un projectile d’énergie condensée file à longue portée, frappant la cible avec la force d’un impact physique.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 5",
        "portee": "🎯 <strong>Portée:</strong> 30m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 10",
        "resistance": "<strong>Sans effet si:</strong> Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige 15 dégats physiques à la cible. Ces dégats sont réduits par l'armure.\n<br>Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique: </strong> Les dégats passent à 25 et la cible (si elle est de taille Moyenne ou moins) subit l'état <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span>."
      },
      {
        "nom": "Nuage toxique",
        "element": "Terre",
        "description": "Une brume opaque se déploie à l’endroit choisi, persistant plusieurs tours et infligeant son toxique insidieux.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 6",
        "portee": "🎯 <strong>Portée:</strong> 18m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 20",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Crée à la position d'une cible à portée, un nuage toxique qui inflige 15 points de dégats de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span>.\n\n<br>Chaque début de tour, le lanceur peut choisir de dépenser une action principale et 5 points de mana pour que le nuage se déplace inflige ses dégats à une cible à portée du lanceur. Sinon, le nuage disparait.\n\n<br><br> Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique: </strong> Les dégats sont de 25 et la cible est <span class=\"etat-link\" data-etat=\"Ralenti\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Ralenti</span> pendant 1 tour."
      }
    ]
  },
  {
    "nom": "Sorts de Prêtre",
    "description": "Sorts de soutiens et anti mort-vivants.",
    "sorts": [
      {
        "nom": "Châtiment",
        "element": "Divin",
        "description": "Invoque un magie divine qui blesse les morts-vivants",
        "categorie": "Anti-mort-vivant",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 3",
        "portee": "🎯 <strong>Portée:</strong> 18m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 6",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> &nbsp;<br>- Non mort-vivant <br>- Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige *Intelligence* dégâts <span style=\"color: #d0d0d0; font-weight: bold; background: rgba(0, 0, 0, 0.4); padding: 2px 4px; border-radius: 3px;\">Divin</span> à la cible.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>Double dégâts."
      },
      {
        "nom": "Refermer les blessures",
        "element": "Divin",
        "description": "Une magie divine soigne les blessures récentes du héros ou d'un allié proche.",
        "categorie": "Sorts de Prêtre",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> 3m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 5",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong>  \n<br>- Hors combat.",
        "effetNormal": "<strong>Effet:</strong> Soigne la cible de 5 points de vie. Tous les 5 points d'intelligence, augmente le soin de 1.",
        "effetCritique": "<strong>Coup Critique: </strong>Le soin passe à 10."
      },
      {
        "nom": "Protection",
        "element": "Lumière",
        "description": "Protège le lanceur ou un allié.",
        "categorie": "Sorts de Prêtre",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 2",
        "portee": "🎯 <strong>Portée:</strong> 3m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 5",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Augmente l'armure de 2 pendant 5 tours.<br> Tous les 5 d'Intelligence, augmente l'armure de 1 supplémentaire.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> L'armure est augmentée de 4."
      },
      {
        "nom": "Arme de lumière",
        "element": "Lumière",
        "description": "Une lumière destructrice s'imprègne de l'arme du prêtre.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> -",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 5",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> L'arme du prêtre infligera 2 dégats de lumière à chaque coup, pendant 4 tours.<br> Tous les 5 d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Les dégats passent à 4."
      },
      {
        "nom": "Révélation mineure",
        "element": "Lumière",
        "description": "Un éclat de lumière se pose sur la cible, dévoilant son nom et son élément d’affiliation.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 2",
        "portee": "🎯 <strong>Portée:</strong> 18m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 5",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Révèle le nom et l'élément d’affiliation d'une cible.",
        "effetCritique": "<strong>Coup Critique: </strong> Révèle également son armure physique et élémentaire."
      },
      {
        "nom": "Resistance",
        "element": "Divin",
        "description": "Enveloppe le porteur d’une aura protectrice qui le rend moins vulnérable aux altérations d’état.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 3",
        "portee": "🎯 <strong>Portée:</strong> 3m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 8",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong>  Augmente la Résistance altération de 3 pendant 5 tours.<br> Tous les 5 d'Intelligence, l'augmente de 1 supplémentaire.",
        "effetCritique": "<strong>Coup Critique: </strong>  La Résistance altération est augmentée de 5."
      },
      {
        "nom": "Guérison du poison",
        "element": "Terre",
        "description": "Dissipe le poison du corps de la cible, purifiant instantanément son sang.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 4",
        "portee": "🎯 <strong>Portée:</strong> 3m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 10",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Enlève l'état <span class=\"etat-link\" data-etat=\"Empoisonné\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Empoisonné</span> de la cible.",
        "effetCritique": "<strong>Coup Critique: </strong> La cible est également soignée de 5 points de vie."
      },
      {
        "nom": "Nova lumineuse",
        "element": "Lumière",
        "description": "Crée une zone de lumière brûlante autour du lanceur.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 4",
        "portee": "🎯 <strong>Portée:</strong> 6m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 10",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Inflige 5 dégats de <span style=\"color: #ffd700; font-weight: bold;\">Lumière</span> à toutes les créatures à moins de 6m du lanceur.<br> Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique: </strong> Les dégats passent à 8, et les créatures ayant une Resistance alération inférieure à l'Intelligence du lanceur sont <span class=\"etat-link\" data-etat=\"Aveuglé\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Aveuglé</span> pendant 2 tours."
      },
      {
        "nom": "Toucher Lointain",
        "element": "Divin",
        "description": "Projette une onde de guérison à distance qui restaure superficiellement les blessures d’un allié.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 5",
        "portee": "🎯 <strong>Portée:</strong> 12m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 10",
        "resistance": "<strong>Sans effet si:</strong>  \n<br>- Hors combat.",
        "effetNormal": "<strong>Effet:</strong> Soigne la cible de 5 points de vie. Tous les 5 points d'intelligence, augmente le soin de 1.",
        "effetCritique": "<strong>Coup Critique: </strong>Le soin passe à 10."
      },
      {
        "nom": "Révélation majeure",
        "element": "Lumière",
        "description": "Le halo lumineux perce le secret des défenses de la cible.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 5",
        "portee": "🎯 <strong>Portée:</strong> 18m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 10",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong>  Révèle le nom et l'élément d’affiliation d'une cible, ainsi que son armure physique et élémentaire et ses points de vie.",
        "effetCritique": "<strong>Coup Critique: </strong> Révèle également son Esquive, et sa resistance altération."
      },
      {
        "nom": "Révélation ultime",
        "element": "Lumière",
        "description": "Un faisceau éclatant dévoile toute l’essence de l’adversaire.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 10",
        "portee": "🎯 <strong>Portée:</strong> 18m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 20",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Révèle le nom et l'élément d’affiliation d'une cible, ainsi que son armure physique et élémentaire, et ses points de vie. Révèle également son Esquive, sa resistance altération, ses chances de coup critiques physiques et magiques.",
        "effetCritique": "<strong>Coup Critique: </strong> Révèle une capacité de la cible."
      }
    ]
  },
  {
    "nom": "Sorts d'Enchanteur",
    "description": "Sorts d'amélioration et d'affaiblissement.",
    "sorts": [
      {
        "nom": "Accroche terrestre",
        "element": "Terre",
        "description": "Le sol se soulève et s'agrippe aux jambes de la cible, alourdissant ses pas d'une étreinte de pierre vivante.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> 30m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 3",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> <br>- Résistance altérations >= Intelligence du lanceur<br>- Lévitation ou Volant.",
        "effetNormal": "<strong>Effet:</strong>&nbsp;La cible contracte l'état <span class=\"etat-link\" data-etat=\"Ralenti\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Ralenti</span> pendant 5 tours.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>La cible ne peut plus effectuer de déplacement pendant la durée du sort."
      },
      {
        "nom": "Accélération",
        "element": "Air",
        "description": "Une magie des vents accélère un allié ou le lanceur.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> 6m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 4",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> Aucune",
        "effetNormal": "<strong>Effet:</strong> &nbsp;La vitesse de déplacement de la cible est augmentée de 3m pendant 5 tours. Non Cumulable.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> La vitesse est augmentée de 6m."
      },
      {
        "nom": "Sommeil",
        "element": "Nuit",
        "description": "Un voile d'ombre caresse la cible, l'enveloppant dans un sommeil surnaturel.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 2",
        "portee": "🎯 <strong>Portée:</strong> 3m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 8",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> <br>- Résistance altérations &gt;= Intelligence du lanceur<br>- Element <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span>",
        "effetNormal": "<strong>Effet:</strong> La cible passe dans l'état <span class=\"etat-link\" data-etat=\"Endormi/assomé/Effrayé\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Endormi</span> pendant ses 2 prochains tours.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> L'effet dure 4 tours."
      },
      {
        "nom": "Lévitation",
        "element": "Air",
        "description": "Une bourrasque ascendante enveloppe la cible, lui permettant de s’élever légèrement dans les airs et d’échapper aux entraves du sol.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 2",
        "portee": "🎯 <strong>Portée:</strong> 3m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 6",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> La cible lévite pendant 5 tours. Elle ignore les dégâts/ralentissements venant du sol, ainsi que l'état <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span>.",
        "effetCritique": "<strong>Coup Critique: </strong> La cible a également sa vitesse de déplacement augmentée de 3m."
      },
      {
        "nom": "Imprégnation élémentaire feu terre nuit",
        "element": "Feu",
        "description": "Imprègne une arme de la puissance d'un élément.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 3",
        "portee": "🎯 <strong>Portée:</strong> 3m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 14",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Le lanceur choisi un élément au choix entre <span style=\"color: #ff6b35; font-weight: bold;\">Feu</span>, <span style=\"color: #8b4513; font-weight: bold;\">Terre</span>, et <span style=\"color: #1a1a1a; font-weight: bold;\">Nuit</span>. \n<br>La cible voit son arme imprégnée de cet élement, qui infligera 4 points de degats de cet élément à chaque coup. <br>Dure 5 tours. Non cumulable.\n<br><br> Chaque 5 points d'Intelligence, les dégats élémentaires sont augmentés de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Le coup en mana est réduit de moitié."
      },
      {
        "nom": "Imprégnation élémentaire eau air lumière",
        "element": "Eau",
        "description": "Imprègne une arme de la puissance d'un élément.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 3",
        "portee": "🎯 <strong>Portée:</strong> 3m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 14",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Le lanceur choisi un élément au choix entre <span style=\"color: #4682b4; font-weight: bold;\">Eau</span>, <span style=\"color: #22c55e; font-weight: bold;\">Air</span>, et <span style=\"color: #ffd700; font-weight: bold;\">Lumière</span>.\n<br>La cible voit son arme imprégnée de cet élement, qui infligera 4 points de degats de cet élément à chaque coup. <br>Dure 5 tours. Non cumulable.\n<br><br> Chaque 5 points d'Intelligence, les dégats élémentaires sont augmentés de 1.",
        "effetCritique": "<strong>Coup Critique: </strong> Le coup en mana est réduit de moitié."
      },
      {
        "nom": "Silence",
        "element": "Nuit",
        "description": "Une aura muette se referme sur la cible, étouffant toute incantation.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 4",
        "portee": "🎯 <strong>Portée:</strong> 12m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 10",
        "resistance": "<strong>Sans effet si:</strong> <br>- Résistance altérations &gt;= Intelligence du lanceur.",
        "effetNormal": "<strong>Effet:</strong> La cible est incapable de lancer des sorts pendant 3 tours.",
        "effetCritique": "<strong>Coup Critique: </strong> L'effet dure 5 tours."
      },
      {
        "nom": "Puissance magique",
        "element": "Feu",
        "description": "Le corps de la cible s’illumine d’arcanes, décuplant la force de ses sorts.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 5",
        "portee": "🎯 <strong>Portée:</strong> 3m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 14",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "Inutilisable Hors combat.           \n<br> <strong>Effet:</strong> Augmente les dégats élémentaires effectués par les sorts de la cible de 3. <br>Dure jusqu'au retour hors combat.<br><br> Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique: </strong> Les dégats sont augmentés de 5."
      },
      {
        "nom": "Puissance physique",
        "element": "Terre",
        "description": "Une vigueur surnaturelle envahit les muscles, augmentant chaque coup porté.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 6",
        "portee": "🎯 <strong>Portée:</strong> 3m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 14",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "Inutilisable Hors combat.           \n<br> <strong>Effet:</strong> Augmente la force de la cible de 5. <br>Dure jusqu'au retour hors combat.<br><br> Tous les 5 points d'intelligence, augmente la force prodiguée de 1.",
        "effetCritique": "<strong>Coup Critique: </strong> La force prodiguée passe à 8."
      },
      {
        "nom": "Confusion",
        "element": "Maléfique",
        "description": "Un voile d’illusions trouble l’esprit de la cible, la rendant incapable de distinguer alliés et ennemis.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 7",
        "portee": "🎯 <strong>Portée:</strong> 12m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 15",
        "resistance": "<strong>Sans effet si:</strong> <br>- Résistance altérations >= Intelligence du lanceur<br>- Element <span style=\"color: #8b5cf6; font-weight: bold;\">Maléfique</span>",
        "effetNormal": "<strong>Effet:</strong> La cible passe dans l'état <span class=\"etat-link\" data-etat=\"Confus\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Confus</span>, pendant 4 tours.",
        "effetCritique": "<strong>Coup Critique: </strong> L'effet dure 6 tours."
      },
      {
        "nom": "Armure élémentaire Feu Terre Nuit",
        "element": "Feu",
        "description": "Un voile protecteur d’énergie enveloppe la cible, renforçant son armure élémentaire.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 8",
        "portee": "🎯 <strong>Portée:</strong> 3m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 14",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Le lanceur choisi un élément au choix entre <span style=\"color: #ff6b35; font-weight: bold;\">Feu</span>, <span style=\"color: #8b4513; font-weight: bold;\">Terre</span>, et <span style=\"color: #1a1a1a; font-weight: bold;\">Nuit</span>. \n<br>La cible voit son armure de cet élement, augmentant l'armure élémentaire de cet élément de 5. <br>Dure 5 tours. Non cumulable.\n<br><br> Chaque 5 points d'Intelligence, les dégats élémentaires sont augmentés de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Le coup en mana est réduit de moitié."
      },
      {
        "nom": "Armure élémentaire Eau Air Lumière",
        "element": "Eau",
        "description": "Un voile protecteur d’énergie enveloppe la cible, renforçant son armure élémentaire.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 8",
        "portee": "🎯 <strong>Portée:</strong> 3m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 14",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Le lanceur choisi un élément au choix entre <span style=\"color: #4682b4; font-weight: bold;\">Eau</span>, <span style=\"color: #22c55e; font-weight: bold;\">Air</span>, et <span style=\"color: #ffd700; font-weight: bold;\">Lumière</span>.\n<br>La cible voit son armure de cet élement, augmentant l'armure élémentaire de cet élément de 5. <br>Dure 5 tours. Non cumulable.\n<br><br> Chaque 5 points d'Intelligence, les dégats élémentaires sont augmentés de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Le coup en mana est réduit de moitié."
      }
    ]
  }
];
    window.CLASSES = [
  {
    "nom": "Guerrier",
    "resume": "Héros sans égal au combat au corp à corp.",
    "capacites": "<ul><li><em>Expert de l'équipement</em> : Capable d'utiliser toutes les armes (épées, arcs, batons, dagues, exotiques, une main et deux mains), armures (robes, légères, lourdes), et boucliers.</li><li><em>Hardiesse</em> : Gagne la compétence Hardiesse rang 1.</li></ul>",
    "sousClasses": [
      {
        "nom": "Nain des montagnes",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>5</strong></span><span class=\"chip\">🏃 Agilité: <strong>1</strong></span><span class=\"chip\">🛡️ Endurance: <strong>10</strong></span><span class=\"chip\">🧠 Intelligence: <strong>1</strong></span><span class=\"chip\">⚡ Volonté: <strong>5</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Force 💪, +3 Endurance 🛡️, +1 Volonté⚡   <strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Brise rocher : </em> Gagne 1 de compétence sur les tests de compétence Hardiesse pour une destruction d'objet.</li><li><em>Volonté inflexible :</em> Les nains possèdent une volonté inflexible qui les rendent résistants aux sortilèges (caractéristique Volonté élevée).</li></ul>",
        "description": "<i>Race robuste et inflexible, dotée d’une endurance exceptionnelle. Forgés par la roche et les sommets, ils résistent aux épreuves et possèdent une force colossale capable de briser murs, armures et créatures cuirassées.</i>"
      },
      {
        "nom": "Berserker",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>5</strong></span><span class=\"chip\">🏃 Agilité: <strong>4</strong></span><span class=\"chip\">🛡️ Endurance: <strong>8</strong></span><span class=\"chip\">🧠 Intelligence: <strong>1</strong></span><span class=\"chip\">⚡ Volonté: <strong>1</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +3 Force 💪, +1 Agilité 🏃, +1 Endurance 🛡️<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Tourbillon de rage :</em> Sur un critique au corps à corps, touche aussi tous les adversaires à moins de 3m.</li><li><em>Risque sauvage :</em> +1 chance de critique physique s'il ne porte pas de bouclier.</li></ul>",
        "description": "<i>Combattant sauvage, maître des armes à deux mains. Sa rage décuple sa force, lui permettant d’abattre ses ennemis dans un déchaînement de puissance brute et de coups imparables.</i>"
      },
      {
        "nom": "Aventurier",
        "description": "<i>Héros polyvalent et ingénieux, il affronte l’inconnu avec courage, et manie tous les outils à sa portée pour triompher.</i>",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>5</strong></span><span class=\"chip\">🏃 Agilité: <strong>2</strong></span><span class=\"chip\">🛡️ Endurance: <strong>8</strong></span><span class=\"chip\">🧠 Intelligence: <strong>1</strong></span><span class=\"chip\">⚡ Volonté: <strong>1</strong></span><span class=\"chip\">🍀 Chance: <strong>5</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Force 💪, +2 Endurance 🛡️, +1 Chance 🍀, <strong> +2 Au choix</strong>",
        "capacites": "<ul><em>Passé glorieux : </em>  Gagne la compétence Eloquence rang 1.<br><em>Sans failles :</em>  Dispose d'un Effort maximum supplémentaire .<br><em>Polyvalent : </em> Dispose d'un point de Don supplémentaire.</ul>"
      },
      {
        "nom": "Maître d’armes",
        "description": "<i>Guerrier érudit et redoutable, il manie avec aisance toutes les armes, des plus communes aux plus exotiques, transformant chaque outil de guerre en prolongement de son bras.</i>",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>5</strong></span><span class=\"chip\">🏃 Agilité: <strong>2</strong></span><span class=\"chip\">🛡️ Endurance: <strong>8</strong></span><span class=\"chip\">🧠 Intelligence: <strong>1</strong></span><span class=\"chip\">⚡ Volonté: <strong>3</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +3 Force 💪, +2 Endurance 🛡️<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Volte d’armes :</em> Peut changer d'arme sans utiliser d'action secondaire.\n</li>\n               <li><em>Expert martial :</em> Lorsqu'il utilise une arme exotique, relance le dé en cas d'echec critique.\n</li>\n   <li><em>Erudit des lames :</em> Gagne 1 de compétence sur les tests de compétence Réflexion sur l'effet ou la provenance d'une arme.\n</li>\n\n</ul>"
      }
    ]
  },
  {
    "nom": "Mage",
    "resume": "Spécialiste de la magie destructrice.",
    "capacites": "<ul><li><em>Équipement de mage</em> : bâtons (une et deux mains), robes.</li><li><em>Sorts de mage</em> : Apprend et lance des sorts de mage.</li></ul>",
    "sousClasses": [
      {
        "nom": "Érudit",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>1</strong></span><span class=\"chip\">🏃 Agilité: <strong>1</strong></span><span class=\"chip\">🛡️ Endurance: <strong>4</strong></span><span class=\"chip\">🧠 Intelligence: <strong>6</strong></span><span class=\"chip\">⚡ Volonté: <strong>3</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +3 Intelligence 🧠, +2 Volonté ⚡<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Instruit</em> : Gagne la compétence Réflexion rang 1.</li><li><em>Apprentissage accéléré</em> : Le niveau de l'érudit est considéré plus élevé d'un niveau pour les prérequis d'apprentissage de sorts.</li>\n<li><em>Mana inépuisable</em> : Chaque point de volonté augmente le mana de 3 au lieu de 2.</li>\n<li><em>Magie interdite</em> : Capable d'utiliser ses lectures (s'il les comprends) pour apprendre de nouveaux sorts.</li></ul>",
        "description": "<i>Mage avide de savoir, doté d’une mémoire prodigieuse. Il assimile les arcanes avec une rapidité fulgurante et maîtrise de nouveaux sorts bien plus vite que ses pairs.</i>"
      },
      {
        "nom": "Elfe",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>2</strong></span><span class=\"chip\">🏃 Agilité: <strong>2</strong></span><span class=\"chip\">🛡️ Endurance: <strong>6</strong></span><span class=\"chip\">🧠 Intelligence: <strong>3</strong></span><span class=\"chip\">⚡ Volonté: <strong>2</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +1 Force 💪, +1 Agilité 🏃, +1 Endurance 🛡️, +1 Intelligence 🧠, +1 Volonté ⚡<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Instinct elfique</em> : Gagne la compétence Coordination rang 1.</li><li><em>Équipement d'elfe</em> : Epées à une main, armures légères.</li><li><em>Briseur de sceaux</em> : Gagne 1 de compétence sur les tests de compétence pour comprendre ou ouvrir une porte scellée magiquement</li></ul>",
        "description": "<i>Guerrier-mage polyvalent, aussi agile qu’élégant. Maître des arcanes comme du combat rapproché, il allie puissance magique et adresse martiale avec une grâce inégalée.</i>"
      }
    ]
  },
  {
    "nom": "Prêtre",
    "resume": "Spécialiste de la magie de soutien et anti morts-vivants.",
    "capacites": "<ul><li><em>Équipement de prêtre</em> : bâtons (une et deux mains), robes.</li><li><em>Sorts de prêtre</em> : Apprend et lance des sorts de Prêtre.</li><li><em>Eloquence</em> : Gagne la compétence Eloquence rang 1.</li></ul>",
    "sousClasses": [
      {
        "nom": "Inquisiteur",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>3</strong></span><span class=\"chip\">🏃 Agilité: <strong>1</strong></span><span class=\"chip\">🛡️ Endurance: <strong>7</strong></span><span class=\"chip\">🧠 Intelligence: <strong>3</strong></span><span class=\"chip\">⚡ Volonté: <strong>5</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +1 Force 💪, +1 Intelligence 🧠, +2 Volonté ⚡, +1 Endurance 🛡️<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Equipement d'inquisiteur</em> : Peut s'équiper d'armures légères et de boucliers.</li><li><em>Fléau des morts-vivants</em> : Les attaques physiques contre les morts-vivants ne ratent jamais.</li><li><em>Lumière purificatrice</em> : Double l'effet de l'intelligence sur les dégats des sorts d'élément <span style=\"color: #ffd700; font-weight: bold;\">Lumière</span> ou <span style=\"color: #f5f5f5; font-weight: bold; background: rgba(100, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;\">Divin</span>.</li></ul>",
        "description": "<i>Champion de la foi, il renforce ses alliés par la magie sacrée et traque sans relâche les morts-vivants. Quand la lumière seule ne suffit plus, il n’hésite pas à prendre les armes et combattre en première ligne.</i>"
      },
      {
        "nom": "Clerc Divin",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>1</strong></span><span class=\"chip\">🏃 Agilité: <strong>1</strong></span><span class=\"chip\">🛡️ Endurance: <strong>5</strong></span><span class=\"chip\">🧠 Intelligence: <strong>3</strong></span><span class=\"chip\">⚡ Volonté: <strong>5</strong></span><span class=\"chip\">🍀 Chance: <strong>5</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Intelligence 🧠, +2 Volonté ⚡, +1 Chance 🍀<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Maître des soins</em> : Double l'effet de l'intelligence sur les sorts de soins.</li><li><em> Pieu </em>:  Gagne 1 de compétence sur les tests de compétence Reflexion sur un dieu ou une religion.</li><li><em> Protection divine </em>:  Dispose d'une armure élementaire <span style=\"color: #f5f5f5; font-weight: bold; background: rgba(100, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;\">Divin</span> et <span style=\"color: #ffd700; font-weight: bold;\">Lumière</span> de 10.</li></ul>",
        "description": "<i>Serviteur sacré, maître des arts de guérison. Sa puissante magie de soins protège ses alliés et les relève même aux portes de la mort.</i>"
      }
    ]
  },
  {
    "nom": "Rôdeur",
    "resume": "Héros très agile.",
    "capacites": "<ul><li><em>Équipement de rôdeur</em> : Dagues, robes, armures légères.</li><li><em>Coordination</em> : Gagne la compétence Coordination rang 1.</li></ul>",
    "sousClasses": [
      {
        "nom": "Voleur",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>3</strong></span><span class=\"chip\">🏃 Agilité: <strong>5</strong></span><span class=\"chip\">🛡️ Endurance: <strong>5</strong></span><span class=\"chip\">🧠 Intelligence: <strong>2</strong></span><span class=\"chip\">⚡ Volonté: <strong>2</strong></span><span class=\"chip\">🍀 Chance: <strong>5</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Agilité 🏃, +2 Force 💪, +1 Endurance 🛡️<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Mains expertes :</em> Gagne la compétence Finesse rang 1.</li><li><em>Sprint :</em> Peut utiliser une action secondaire pour doubler sa vitesse de déplacement.</li><li><em>Vicieux :</em> Double les chances de critiques physiques au corps à corps sur les cibles subissant un état qui les empeche d'esquiver.</li></ul>",
        "description": "<i>Maître de la finesse et de l’agilité, il se déplace avec rapidité fulgurante et frappe là où ça fait le plus mal. </i>"
      },
      {
        "nom": "Chasseur",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>3</strong></span><span class=\"chip\">🏃 Agilité: <strong>5</strong></span><span class=\"chip\">🛡️ Endurance: <strong>5</strong></span><span class=\"chip\">🧠 Intelligence: <strong>4</strong></span><span class=\"chip\">⚡ Volonté: <strong>2</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Agilité 🏃, +1 Force 💪, +1 Endurance 🛡️, +1 Intelligence 🧠<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Armes du Chasseur</em> : Peut utiliser les arcs.</li><li><em>Cueillette</em> : Une fois par jour, lors d’un repos, le personnage peut récolter 5 plantes locales (au choix du MJ). Leur efficacité dépend de l’Intelligence de l’utilisateur.</li><li><em>Connaissance du milieu naturel</em> : Gagne 1 de compétence sur les tests de Réflexion lié à animal, un monstre, une plante, ou la découverte de passages dérobés en milieu naturel.</li></ul>",
        "description": "<i>Précis et agile, il complète son art de l’arc par la science des herbes anciennes.</i>"
      }
    ]
  },
  {
    "nom": "Enchanteur",
    "resume": "Détenteur d'une magie singulière, qui fait de lui un allié précieux.",
    "capacites": "<ul><li><em>Équipement d'enchanteur</em> : bâtons (une et deux mains), dagues, Robes.</li><li><em>Sorts d'enchanteur</em> : Apprend et lance des sorts d'Enchanteur.</li></ul>",
    "sousClasses": [
      {
        "nom": "Esprit de la grande Fée",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>1</strong></span><span class=\"chip\">🏃 Agilité: <strong>5</strong></span><span class=\"chip\">🛡️ Endurance: <strong>5</strong></span><span class=\"chip\">🧠 Intelligence: <strong>5</strong></span><span class=\"chip\">⚡ Volonté: <strong>2</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +1 Agilité 🏃, +1 Intelligence 🧠, +1 Endurance 🛡️, +1 Volonté ⚡, +1 Chance 🍀<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Tatillon</em> : Gagne la compétence Finesse rang 1.</li><li><em>Lévitation</em> : Ignore dégâts/ralentissements venant du sol, ainsi que l'état <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span>.</li><li><em>Rayon de l'Amitié</em> : Par une action secondaire, peut répéter sur une autre cible à portée un sort bénéfique qui a ciblé un allié se tour ci, sans coût en mana supplémentaire.</li></ul>",
        "description": "<i>Être mystique qui flotte au-dessus du sol, il invoque des sorts imprévisibles pour soutenir ses alliés.</i>"
      },
      {
        "nom": "Lutin",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>1</strong></span><span class=\"chip\">🏃 Agilité: <strong>1</strong></span><span class=\"chip\">🛡️ Endurance: <strong>4</strong></span><span class=\"chip\">🧠 Intelligence: <strong>5</strong></span><span class=\"chip\">⚡ Volonté: <strong>2</strong></span><span class=\"chip\">🍀 Chance: <strong>5</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +1 Intelligence 🧠, +2 Volonté ⚡, +2 Chance 🍀<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Secrets bien gardés</em> : Gagne la compétence Reflexion rang 1.</li><li><em>Expert des baguettes</em> : Sur un critique à la baguette, la charge n'est pas consommée.</li><li><em>Rire malicieux</em> : Par une action secondaire, peut répéter sur une autre cible à portée un sort d'altération qui a ciblé un enemi ce tour ci, sans coût en mana supplémentaire.</li></ul>",
        "description": "<i>Esprit espiègle et rusé, passé maître dans l’art des altérations magiques. </i>"
      }
    ]
  }
];
    window.DONS = [
  {
    "nom": "Generaux",
    "description": "Dons accessibles à toutes les classes.",
    "dons": [
      {
        "nom": "Doué",
        "description": "Gagne une compétence rang 1.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 points de don"
      },
      {
        "nom": "Toujours pret",
        "description": "Le maximum d'efforts maximum augmente de 1.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Brillant",
        "description": "Gagne une compétence rang 2.",
        "prerequis": "<strong> Prérequis :</strong> La compétence rang 1.",
        "cout": "2 points de don"
      },
      {
        "nom": "Prodigieux",
        "description": "Gagne une compétence rang 3.",
        "prerequis": "<strong> Prérequis :</strong> La compétence rang 2.",
        "cout": "3 point de don"
      },
      {
        "nom": "Hyperactif",
        "description": "Le héros dispose maintenant de deux actions secondaires par tour.",
        "prerequis": "<strong> Prérequis :</strong> Niveau 3",
        "cout": "2 points de don"
      },
      {
        "nom": "Equitation",
        "description": "Permet de monter à cheval ou équivalent.",
        "prerequis": "<strong> Prérequis :</strong> Niveau 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Gros mangeur",
        "description": "Les points de vie rendus en mangeant de la nourriture sont doublés. De plus, il est possible de consommer 4 rations de nourriture par jour au lieu de 2.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Grand sacs",
        "description": "Augmente le poid maximum transportable de 3, et le nombre de consommables transportables de 3.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Maitrise de la dague",
        "description": "Le héros est capable d'équiper et d'utiliser des Dagues.",
        "prerequis": "<strong> Prérequis :</strong> 🏃 Agilité 5.",
        "cout": "1 point de don"
      },
      {
        "nom": "Maitrise de l'arc",
        "description": "Le héros est capable d'équiper et d'utiliser des Arcs.",
        "prerequis": "<strong> Prérequis :</strong> 🏃 Agilité 10.",
        "cout": "1 point de don"
      },
      {
        "nom": "Sommeil léger",
        "description": "Pendant qu'il dort, le héros est aussi alerte que s'il effectuait un tour de garde.\nDe plus, le héros ne necessite que 4 heures par nuit pour éviter l'état <span class=\"etat-link\" data-etat=\"Fatigué\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Fatigué</span>.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Guerrier",
    "description": "Dons accessibles aux guerriers.",
    "dons": [
      {
        "nom": "Expertise du bouclier",
        "description": "Si le héros a un bouclier équipé, il peut utiliser une action secondaire pour doubler l'armure physique du bouclier jusqu'au prochain tour.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Charge",
        "description": "Une fois par combat, peut utiliser une action secondaire pour doubler sa vitesse de déplacement et forcer un coup critique sur la prochaine attaque physique de ce tour (si elle réussie).",
        "prerequis": "<strong> Prérequis :</strong> 🏃Agilité 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Volonté de fer",
        "description": "Une fois par jour, le héros peut utiliser une action secondaire pour se débarasser de toutes ses alterations magiques.",
        "prerequis": "<strong> Prérequis :</strong> ⚡Volonté 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Coup de bouclier",
        "description": "Si le héros a un bouclier équipé, lorsque le héros subit des dégats aux corps à corps, il peut choisir d'utiliser une action secondaire pour infliger à l'attaquant des dégats équivalents à l'armure du bouclier.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Coup de pommeau",
        "description": "Description du don.",
        "prerequis": "Aucun prérequis",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Rôdeur",
    "description": "Dons accessibles aux rodeurs.",
    "dons": [
      {
        "nom": "Croche-patte",
        "description": "Peut utiliser une action principale pour effectuer un croche- patte :\n\n\n<br><br><b>Sans effet si :</b> \n<br>- Esquive.\n<br>- Volant ou lévitant.\n<br>- Taille supérieure à Moyen.\n\n<br><br><b>Effet :</b> Inflige (Force) dégats Physiques à la cible. Met la cible dans l'état <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span>.\n✏️\n<br><br><b>Coup Critique :</b>  Les dégats sont doublés et la cible est <span class=\"etat-link\" data-etat=\"Endormi/assomé/Effrayé\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Assomé</span> 1 tour.\n\n<br><br><hr>",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Chasse et pêche",
        "description": "Le héros n'as plus besoin de sa ration de nourriture quotidienne.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Attaque d'opportunité",
        "description": "Description du don.",
        "prerequis": "Aucun prérequis",
        "cout": "1 point de don"
      },
      {
        "nom": "D",
        "description": "Description du don.",
        "prerequis": "Aucun prérequis",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Mage",
    "description": "Description de cette catégorie de dons.",
    "dons": [
      {
        "nom": "Gemme de mana",
        "description": "Une fois par jour, le héros peut récupérer l'intégralité de son Mana en utilisant une action secondaire.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Resistance élémentaire 1",
        "description": "Le héros gagne 5 d'armure élémentaire de <span style=\"color: #e25822; font-weight: bold;\">Feu</span>, <span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span>, <span style=\"color: #8b5e34; font-weight: bold;\">Terre</span>, <span style=\"color: #22c55e; font-weight: bold;\">Air</span>.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Resistance magique 1",
        "description": "Le héros gagne 5 d'armure élémentaire de <span style=\"color: #ffd700; font-weight: bold;\">Lumière</span>, <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span>, <span style=\"color: #d0d0d0; font-weight: bold; background: rgba(0, 0, 0, 0.4); padding: 2px 4px; border-radius: 3px;\">Divin</span>, <span style=\"color: #a855f7; font-weight: bold;\">Maléfique</span>.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Spécialisation élémentaire 1",
        "description": "Le héros peut choisir un élément et augmenter de 5 les dégats infligés avec les sorts de cet élément.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Infusion élémentaire",
        "description": "Aprés avoir lancé un sort, le héros peut, en utilisant une action secondaire, imprégner son arme de l'élément du sort. Elle infligera à sa prochaine attaque physique des dégats de cet élément équivalents au niveau du sort.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Polyglotte",
        "description": "Peut lire et parler toutes les langues.",
        "prerequis": "<strong> Prérequis :</strong> Reflexion rang 2.",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Pretre",
    "description": "Description de cette catégorie de dons.",
    "dons": [
      {
        "nom": "Mécréants",
        "description": "Les dégats physiques infligés aux créatures de l'élément <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span> ou <span style=\"color: #a855f7; font-weight: bold;\">Maléfique</span> sont doublés.",
        "prerequis": "<strong> Prérequis :</strong>-",
        "cout": "1 point de don"
      },
      {
        "nom": "Au milieu du combat",
        "description": "Permet d'utiliser s'équiper de dagues.",
        "prerequis": "<strong> Prérequis :</strong>🏃Agilité 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Jugement éclair",
        "description": "Si le Prêtre a effectué un sort ce tour ci, il peut effectuer une attaque au corp à corp avec une action secondaire.",
        "prerequis": "<strong> Prérequis :</strong>💪Force 3",
        "cout": "1 point de don"
      },
      {
        "nom": "Musique",
        "description": "Permet d'apprendre un instrument de musique (ou de savoir chanter) au choix, gagnant 2 de compétences sur les tests de compétence éloquence le nécéssitant.",
        "prerequis": "<strong> Prérequis :</strong>-",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Enchanteur",
    "description": "Dons accessibles aux enchanteurs.",
    "dons": [
      {
        "nom": "Réparateur de baguettes",
        "description": "Permet de regagner une charge de baguette, une fois par jour.",
        "prerequis": "<strong> Prérequis :</strong>-",
        "cout": "1 point de don"
      },
      {
        "nom": "Magie aléatoire destructrice",
        "description": "Permet de choisir et d'apprendre un sort de mage et de pouvoir le lancer à volonté. Le sort ne peut pas être changé par la suite.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Magie aléatoire de soutien",
        "description": "Permet de choisir et d'apprendre un sort de prêtre et de pouvoir le lancer à volonté. Le sort ne peut pas être changé par la suite.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Alteration risquée",
        "description": "Lorsque un sort d'alteration magique est effectué alors que la cible est au corps à corps, ses chances de critiques sont doublées.",
        "prerequis": "<strong> Prérequis :</strong>-",
        "cout": "1 point de don"
      }
    ]
  }
];
    window.OBJETS = {
  "objets": [
    {
      "nom": "Espadon",
      "numero": 1,
      "image": "https://i.ibb.co/35rpP6ZS/Epee2M1.png",
      "description": "<i>Longue épée à deux mains, lourde mais puissante.</i>",
      "tags": [
        "Arme",
        "Épée",
        "Deux mains"
      ],
      "effet": "<strong>Dégâts: </strong> Inflige (4  + Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 35",
      "poids": "⚖️ <strong>Poids:</strong> 2"
    },
    {
      "nom": "Simple épée",
      "numero": 2,
      "image": "https://i.ibb.co/PsSXvSXx/Epee1.png",
      "description": "<i>Arme droite et équilibrée, conçue pour être maniée d’une seule main</i>",
      "tags": [
        "Arme",
        "Épée",
        "Une main"
      ],
      "effet": "<span style=\"font-weight: 700; font-family: \" source=\"\" serif=\"\" pro\",=\"\" serif;=\"\" color:=\"\" rgb(74,=\"\" 44,=\"\" 23);=\"\" text-shadow:=\"\" rgba(0,=\"\" 0,=\"\" 0.05)=\"\" 0px=\"\" 1px=\"\" 2px;\"=\"\">Dégâts: </span> Inflige (2  + Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 20",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Dague en fer",
      "numero": 3,
      "image": "https://i.ibb.co/1fCwy6cR/Dague1.png",
      "description": "<i>Petite lame simple, légère et maniable.</i>",
      "tags": [
        "Arme",
        "Une main",
        "Dague"
      ],
      "effet": "<strong>Dégâts: </strong> Inflige (1  + Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Bâton en bois",
      "numero": 4,
      "image": "https://i.ibb.co/PsyCNw86/Baton1.png",
      "description": "<i>Long bâton solide, utilisé comme arme et appui.</i>",
      "tags": [
        "Arme",
        "Deux mains",
        "Baton"
      ],
      "effet": "<strong>Dégâts: </strong> Inflige (2  + Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 5",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Gourdin",
      "numero": 5,
      "image": "https://i.ibb.co/whZCKww0/Baton2.png",
      "description": "<i>Arme rudimentaire faite de bois dur. </i>",
      "tags": [
        "Arme",
        "Une main",
        "Baton"
      ],
      "effet": "<strong>Dégâts: </strong> Inflige (1  + Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Arc simple",
      "numero": 6,
      "image": "https://i.ibb.co/cKb1JKZQ/Arc1.png",
      "description": "<i>Arc basique en bois, sans ornement.</i>",
      "tags": [
        "Arme",
        "Deux mains",
        "Arc"
      ],
      "effet": "<strong>Portée: </strong> 12m.<br>\n<strong>Dégâts: </strong> Inflige (Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 30",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Bouclier en bois",
      "numero": 7,
      "image": "https://i.ibb.co/67bK4Bw8/Bouclier1.png",
      "description": "<i>Un bouclier grossier taillé dans des planches épaisses, marqué de cicatrices de bataille.</i>",
      "tags": [
        "Bouclier"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 2.",
      "prix": "🔷 <strong>Prix:</strong> 15",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Robe simple",
      "numero": 8,
      "image": "https://i.ibb.co/VYFpnz8h/Robe1.png",
      "description": "<i>Une robe de toile modeste, aux plis fatigués mais encore emplis de dignité.</i>",
      "tags": [
        "Armure",
        "Robe"
      ],
      "effet": "<strong>Effet:</strong> Augmente la Volonté de 1.",
      "prix": "🔷 <strong>Prix:</strong> 20",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Armure de cuir",
      "numero": 9,
      "image": "https://i.ibb.co/9Hkw2VFb/Armure-Cuir1.png",
      "description": "<i>Une armure souple en cuir tanné, taillée pour offrir une protection rudimentaire.</i>",
      "tags": [
        "Armure",
        "Armure légère"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 1.",
      "prix": "🔷 <strong>Prix:</strong> 30",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Armure en maille",
      "numero": 10,
      "image": "https://i.ibb.co/cXtwzw5b/Armure-Lourde1.png",
      "description": "<i>Une cotte de mailles dont chaque anneau forgé promet résistance et endurance au combat.</i>",
      "tags": [
        "Armure",
        "Armure lourde"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 3.",
      "prix": "🔷 <strong>Prix:</strong> 65",
      "poids": "⚖️ <strong>Poids:</strong> 2"
    },
    {
      "nom": "Armure de plaque",
      "numero": 11,
      "image": "https://i.ibb.co/fVg5Fp6h/Armure-Lourde2.png",
      "description": "<i>Une imposante armure de métal poli, dont les plaques luisantes forment une carapace presque impénétrable.</i>",
      "tags": [
        "Armure",
        "Armure lourde"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 6.",
      "prix": "🔷 <strong>Prix:</strong> 200",
      "poids": "⚖️ <strong>Poids:</strong> 2"
    },
    {
      "nom": "Petite potion de vie",
      "numero": 12,
      "image": "https://i.ibb.co/Mw2Qb8Y/LifePot1.png",
      "description": "<i>Une fiole écarlate dont le liquide vif régénère les blessures et ranime les forces vitales.</i>",
      "tags": [
        "Consommable"
      ],
      "effet": "<strong>Effet:</strong> Rend 15 (critique : 25) points de vie au héros.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Petite potion de mana",
      "numero": 13,
      "image": "https://i.ibb.co/MkwzbQ3S/Potion-Mana1.png",
      "description": "<i>Une essence azur miroitante qui restaure l’énergie magique et ravive le flux des arcanes.</i>",
      "tags": [
        "Consommable"
      ],
      "effet": "<strong>Effet:</strong> Rend 20 (critique : 35) points de mana au héros.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Baguette de boule de feu",
      "numero": 14,
      "image": "https://i.ibb.co/JwXs3k2V/Baguette-Feu.png",
      "description": "<i>Une fine tige runique qui libère des flammes brûlantes au commandement de son porteur.</i>",
      "tags": [
        "Consommable",
        "Catalyseur"
      ],
      "effet": "<strong>Effet:</strong> Remplace votre prochaine action principale par le sort de mage <span class=\"spell-link\" data-spell=\"Boule de Feu\" data-category=\"Sorts de Mage\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Boule de Feu</span>. <br><i>Les prérequis pour le sort ne sont pas requis mais le mana et les statistiques du héros sont utilisés.</i>\n    <br><br><strong>Charges :</strong> 3",
      "prix": "🔷 <strong>Prix:</strong> 25",
      "poids": ""
    },
    {
      "nom": "Feuilleclaire",
      "numero": 15,
      "image": "https://i.ibb.co/bMDstDVV/Herb1.png",
      "description": "<i>Herbe des forêts profondes, aux feuilles luisantes et aux petites fleurs rosées. Appliquée directement sur la peau, elle referme les plaies et apaise la douleur presque instantanément.</i>",
      "tags": [
        "Consommable",
        "Plante"
      ],
      "effet": "<strong>Effet:</strong> Rend 10 (critique : 20) points de vie au héros ou à une cible proche.\n<br>Tous les 5 points d'intelligence, augmente les soins de 1.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Nocteline",
      "numero": 16,
      "image": "https://i.ibb.co/7JpQ7Kr7/Herb2.png",
      "description": "<i>une plante sombre aux fleurs violettes dont l’essence neutralise les venins et purifie le sang.</i>",
      "tags": [
        "Consommable",
        "Plante"
      ],
      "effet": "<strong>Prérequis:</strong> Intelligence 5.<br>\n<strong>Effet:</strong> Soigne le héros ou une cible proche du poison. \n<br><b>Critique</b> : Rend également 5 points de vie.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Baguette de d'accélération",
      "numero": 17,
      "image": "https://i.ibb.co/zT29mKBd/Baguette-Lumiere.png",
      "description": "<i>Une fine tige de cristal rayonnant, dont l’éclat sacré nimbe son porteur d’une aura éclatante, lui conférant une vitesse surnaturelle et des réflexes fulgurants.</i>",
      "tags": [
        "Consommable",
        "Catalyseur"
      ],
      "effet": "<strong>Effet:</strong> Remplace votre prochaine action principale par le sort d'enchanteur <span class=\"spell-link\" data-spell=\"Accélération\" data-category=\"Sorts d'Enchanteur\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Accélération</span>. <br><i>Les prérequis pour le sort ne sont pas requis mais le mana et les statistiques du héros sont utilisés.</i>\n    <br><br><strong>Charges :</strong> 3",
      "prix": "🔷 <strong>Prix:</strong> 30",
      "poids": ""
    },
    {
      "nom": "Baguette de sommeil",
      "numero": 18,
      "image": "https://i.ibb.co/bMXNS4gy/Baguette-Nuit.png",
      "description": "<i>Une tige sombre incrustée de gemmes lunaires, qui libère une aura ténébreuse plongeant ses cibles dans un profond sommeil enchanté.</i>",
      "tags": [
        "Consommable",
        "Catalyseur"
      ],
      "effet": "<strong>Effet:</strong> Remplace votre prochaine action principale par le sort d'enchanteur <span class=\"spell-link\" data-spell=\"Sommeil\" data-category=\"Sorts d'Enchanteur\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Sommeil</span>. <br><i>Les prérequis pour le sort ne sont pas requis mais le mana et les statistiques du héros sont utilisés.</i>\n    <br><br><strong>Charges :</strong> 3",
      "prix": "🔷 <strong>Prix:</strong> 30",
      "poids": ""
    },
    {
      "nom": "Ration de nourriture",
      "numero": 19,
      "image": "https://i.ibb.co/tT6gW6p0/Food1.png",
      "description": "<i>Un paquet frugal de pain sec et de viande salée.</i>",
      "tags": [
        "Nourriture"
      ],
      "effet": "Inutilisable en combat.\n<br><strong>Effet:</strong> Restore 5 points de vie. <br>Couplé à un sommeil de 8h, permet d'éviter l'etat <span class=\"etat-link\" data-etat=\"Fatigué\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Fatigué</span>.",
      "prix": "🔷 <strong>Prix:</strong> 5",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Ration copieuse de nourriture",
      "numero": 20,
      "image": "https://i.ibb.co/7JZW2ZZT/Food2.png",
      "description": "<i>Un coffret garni de mets fins et de vin épicé, offrant réconfort et vigueur bien au-delà de la simple survie</i>",
      "tags": [
        "Nourriture"
      ],
      "effet": "Inutilisable en combat.\n<br><strong>Effet:</strong> Restore 8 points de vie. <br>Couplé à un sommeil de 8h, permet d'éviter l'etat <span class=\"etat-link\" data-etat=\"Fatigué\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Fatigué</span>.\n<br><b>Charges :</b> 3",
      "prix": "🔷 <strong>Prix:</strong> 15",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Fruits de la forêt",
      "numero": 21,
      "image": "https://i.ibb.co/svC0cDH6/food3.png",
      "description": "<i>Des baies juteuses et sucrées, cueillies à l’ombre des grands arbres, qui redonnent fraîcheur et énergie.</i>",
      "tags": [
        "Nourriture"
      ],
      "effet": "Inutilisable en combat.\n<br><strong>Effet:</strong> Restore 5 points de vie. <br>Couplé à un sommeil, permet d'éviter l'etat <span class=\"etat-link\" data-etat=\"Fatigué\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Fatigué</span>. <br>De plus, lorsque consommé, le mangeur ne neccessite plus que 4 heures de sommeil ce jour-ci.\n<br><br><b>Charges :</b> 3",
      "prix": "🔷 <strong>Prix:</strong> 20",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Ration de survie",
      "numero": 22,
      "image": "https://i.ibb.co/Py57FHy/Food0.png",
      "description": "<i>Un maigre assemblage de galettes sèches, de viande fumée et d’eau amère, conçu pour soutenir la flamme vitale dans les heures les plus sombres.</i>",
      "tags": [
        "Nourriture"
      ],
      "effet": "Inutilisable en combat. Maximum deux nourritures consommées par jour.\n<br>\n<br><strong>Effet:</strong> Couplé à un sommeil de 8h, permet d'éviter l'etat <span class=\"etat-link\" data-etat=\"Fatigué\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Fatigué</span>.",
      "prix": "",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Flèche aiguisée",
      "numero": 23,
      "image": "https://i.ibb.co/4Z7qKXCx/Fleche-Aiguis-e.png",
      "description": "<i>Un trait finement taillé, dont la pointe acérée perce l’armure avec une précision mortelle.</i>",
      "tags": [
        "Consommable",
        "Flèche"
      ],
      "effet": "<b>Effet :</b> Renforce la prochaine attaque à l'arc et lui rajoute +3 (critique : +5) points de dégats physiques en cas de réussite de l'attaque.\n\n<br><br><b>Charges :</b> 3",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Flèche de la terre",
      "numero": 24,
      "image": "https://i.ibb.co/ZpScRTwS/Fleche-Terre.png",
      "description": "<i>Une flèche alourdie de pierres runiques, qui libère la force brutale de l’élément Terre à l’impact.</i>",
      "tags": [
        "Consommable",
        "Flèche"
      ],
      "effet": "<b>Effet :</b> Renforce la prochaine attaque à l'arc et lui rajoute +5 (critique : +10) points de dégats élémentaire de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> en cas de réussite de l'attaque.\n\n<br><br><b>Charges :</b> 3",
      "prix": "🔷 <strong>Prix:</strong> 20",
      "poids": ""
    },
    {
      "nom": "Bandage d'urgence",
      "numero": 25,
      "image": "https://i.ibb.co/4ZPsSM3p/Bandages.png",
      "description": "<i>Liens grossiers appliqués à la hâte en plein combat, permettant de maintenir un héros en vie quelques instants de plus</i>",
      "tags": [
        "Consommable"
      ],
      "effet": "Inutilisable hors combat.      \n<br><strong>Portée :</strong>   3m.\n<br><strong>Effet:</strong> Rend 5 (critique : 10) points de vie à la cible.\n<br><strong>Charges:</strong> 3.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Bracelet médicinal de la forêt",
      "numero": 26,
      "image": "https://i.ibb.co/k2h292gV/Bracelet-Foret.png",
      "description": "<i>Tressé de plantes médicinales, il purifie le sang de son porteur et dissipe les poisons.</i>",
      "tags": [
        "Accessoire"
      ],
      "effet": "<strong>Effet:</strong> Soigne son porteur du poison. Utilisable une fois par jour maximum.",
      "prix": "🔷 <strong>Prix:</strong> ?",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Dent de Grouink",
      "numero": 27,
      "image": "https://i.ibb.co/whc5dwnw/Dent-Grouik.png",
      "description": "<i>Portée en collier, cette énorme canine de bête sauvage insuffle à son porteur une force brute et indomptée.</i>",
      "tags": [
        "Accessoire"
      ],
      "effet": "<strong>Effet:</strong> Augmente la Force du porteur de 3.",
      "prix": "🔷 <strong>Prix:</strong> ?",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Echarpe de chaman Groink",
      "numero": 28,
      "image": "https://i.ibb.co/W4tfpFcH/Echarpe-Chaman.png",
      "description": "<i>Tissée de symboles anciens et imprégnée de sagesse mystique.</i>",
      "tags": [
        "Accessoire"
      ],
      "effet": "<strong>Effet:</strong> Augmente de 3m la portée des sorts d'alterations magiques et d'améliorations temporaires.",
      "prix": "🔷 <strong>Prix:</strong> ?",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Fourrure d'ours",
      "numero": 29,
      "image": "https://i.ibb.co/9HhVCqvk/Fourrure-Ours.png",
      "description": "<i>Épaisse et robuste, cette peau intacte pourrait aisément être taillée en une armure protectrice.</i>",
      "tags": [
        "Composant"
      ],
      "effet": "",
      "prix": "🔷 <strong>Prix:</strong> 100",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Pierre à aiguiser",
      "numero": 30,
      "image": "https://i.ibb.co/SX10mS2q/Buff01.png",
      "description": "<i>Outil simple mais efficace, elle redonne du tranchant aux lames et prépare les armes pour le combat.</i>",
      "tags": [
        "Consommable"
      ],
      "effet": "<strong>Effet:</strong> Augmente les dégats de la prochaine attaque physique de 3.\n  <br><strong>Charges:</strong> 3.",
      "prix": "🔷 <strong>Prix:</strong> 20",
      "poids": ""
    },
    {
      "nom": "Cristal d'effort",
      "numero": 31,
      "image": "https://i.ibb.co/k2MHGqhx/Cristal-Effort.png",
      "description": "<i>Fragment lumineux empli d’énergie, il ravive la volonté du porteur et lui rend la force d’accomplir un nouvel effort. </i>",
      "tags": [
        "Consommable"
      ],
      "effet": "<strong>Effet:</strong> Recharge un effort utilisable par le héros.<br><strong>Charges:</strong> 3.",
      "prix": "🔷 <strong>Prix:</strong> 50",
      "poids": ""
    },
    {
      "nom": "Pince de crabe géant des forêts",
      "numero": 32,
      "image": "https://i.ibb.co/VWKF2ysm/Masse-Foret1.png",
      "description": "<i>Massive et bleutée, vestige d’une créature des forêts profondes, elle témoigne d’une puissance brute capable de broyer la pierre.</i>",
      "tags": [
        "Arme",
        "Une main",
        "Baton"
      ],
      "effet": "<strong>Dégâts: </strong> Inflige (3  + Force) points de dégats physiques.\n<br> L'arme est imprégnée de 5 points de dégats d'élément <span style=\"color: #4682b4; font-weight: bold;\">Eau</span>.",
      "prix": "🔷 <strong>Prix:</strong> ?",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Clairgivre",
      "numero": 33,
      "image": "https://i.ibb.co/s9CJtsPr/Herb5.png",
      "description": "<i>Une herbe bleu clair, semblant givrée en permanence, même au soleil.</i>",
      "tags": [
        "Consommable",
        "Plante",
        "Non identifié"
      ],
      "effet": "<strong>Prérequis:</strong> Intelligence 10.     \n<br><strong>Effet:</strong> Le héros ou la cible proche dispose de deux actions principales au lieu d'une (non cumulable). \n<br><strong>Durée:</strong> 2 tours (Critique : 3).",
      "prix": "🔷 <strong>Prix:</strong> 65",
      "poids": ""
    },
    {
      "nom": "Auréline des Roches",
      "numero": 34,
      "image": "https://i.ibb.co/My3mcc60/Herb3.png",
      "description": "<i>une fleur jaune éclatante aux pétales veinés de brun, poussant sur les falaises et près des rivières.</i>",
      "tags": [
        "Consommable",
        "Plante",
        "Non identifié"
      ],
      "effet": "<strong>Effet:</strong> Augmente la protection élémentaire de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> et d'<span style=\"color: #4682b4; font-weight: bold;\">Eau</span>  du héros ou d'une cible proche du niveau d'Intelligence du héros. <br><b>Critique :</b> le bonus d'armure est amélioré de 5.\n<br><strong>Durée:</strong> 5 tours.",
      "prix": "🔷 <strong>Prix:</strong> 25",
      "poids": ""
    },
    {
      "nom": "Nébrelle d’Azur",
      "numero": 35,
      "image": "https://i.ibb.co/bMn4mMyK/Herb4.png",
      "description": "<i>Une herbe fine, aux brins violets et bleus luminescents, qui pousse dans les clairières baignées de lune.</i>",
      "tags": [
        "Consommable",
        "Plante",
        "Non identifié"
      ],
      "effet": "<b>Effet:</b> Rend au héros à une cible proche une quantitée de mana équilavent au niveau d'Intelligence du héros.\n<br><b>Ciritique :</b> Mana rendu augmenté de 5.",
      "prix": "🔷 <strong>Prix:</strong> 25",
      "poids": ""
    },
    {
      "nom": "Aile de scarabée géant",
      "numero": 36,
      "image": "https://i.ibb.co/RGZM6Tfx/Cape-Scarab.png",
      "description": "<i>Cape faite d’une aile translucide arrachée à un scarabée géant. Elle bruisse à chaque mouvement.</i>",
      "tags": [
        "Accessoire"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'initiative de 4 et l'armure élémentaire d'<span style=\"color: #22c55e; font-weight: bold;\">Air</span> de 5.",
      "prix": "🔷 <strong>Prix:</strong> ?",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Bottes en cuir de guêpe géante",
      "numero": 37,
      "image": "https://i.ibb.co/k2V6Df2z/Botte-Guepe.png",
      "description": "<i>Bottes souples taillées dans le cuir chitineux d’une guêpe géante. Leur légèreté accroît la rapidité.</i>",
      "tags": [
        "Accessoire"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'Esquive de 1.",
      "prix": "🔷 <strong>Prix:</strong> ?",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Gants patte d'ours",
      "numero": 38,
      "image": "https://i.ibb.co/KzrZRGcd/Gants-Patte-Ours.png",
      "description": "<i>De véritables pattes d’ours, évidées et enfilées comme des gants. Bruts et redoutables, elles permettent d’abattre des coups capables de faire chuter un adversaire.</i>",
      "tags": [
        "Accessoire"
      ],
      "effet": "<strong>Effet:</strong> En cas de coup critique physique sur une attaque au corp à corp, l'adversaire sera mis dans l'état <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span>.\n<br><strong>Sans effet si :</strong> <br>- Adversaire de taille Grand ou supérieur <br>- Adversaire volant ou lévitant.",
      "prix": "🔷 <strong>Prix:</strong> ?",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Bouclier de la forêt",
      "numero": 39,
      "image": "https://i.ibb.co/Zpkw8qVL/Bouclier-Foret.png",
      "description": "<i>Bouclier rond taillé dans un bois ancien et orné d’un arbre majestueux dont les racines et les branches s’entrelacent en relief.</i>",
      "tags": [
        "Bouclier"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 4. Augmente l'armure élémentaire de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> de 5.",
      "prix": "🔷 <strong>Prix:</strong> ?",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Couronne d'épines",
      "numero": 40,
      "image": "https://i.ibb.co/d09YYyy8/Couronne-Epines.png",
      "description": "<i>Diadème tressé de ronces encore vivantes, dont les pointes s’enfoncent légèrement dans la peau. La douleur qu’elle inflige endurcit le porteur.</i>",
      "tags": [
        "Accessoire"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'endurance de 3.",
      "prix": "🔷 <strong>Prix:</strong> ?",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Collier terrestre",
      "numero": 41,
      "image": "https://i.ibb.co/ksxCppN8/Collier-Terrestre.png",
      "description": "<i>Un pendentif massif orné d’une gemme verte veinée, sertie dans un motif doré évoquant les racines et la roche. Il pulse d’une force tellurique.</i>",
      "tags": [
        "Non identifié",
        "Accessoire"
      ],
      "effet": "<strong>Effet:</strong> Les attaques physiques sont imprégnés d'une force élémentaire, qui inflige 4 dégats de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span>.",
      "prix": "🔷 <strong>Prix:</strong> ?",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Dard de guêpe géante",
      "numero": 42,
      "image": "https://i.ibb.co/mjcDdck/Dague2.png",
      "description": "<i>Un dard chitineux acéré, arraché à une guêpe géante, utilisé comme une dague imprégnée de venin.</i>",
      "tags": [
        "Arme",
        "Une main",
        "Dague"
      ],
      "effet": "<strong>Dégâts: </strong> Inflige (4  + Force) points de dégats physiques.\n<br> Si la cible a une résistance alteration inférieure à 5, elle subit l'état <span class=\"etat-link\" data-etat=\"Empoisonné\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Empoisonné</span> 2, pendant 5 tours.",
      "prix": "🔷 <strong>Prix:</strong> ?",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Arc de chasseur",
      "numero": 43,
      "image": "https://i.ibb.co/bRXH0Vwj/Arc2.png",
      "description": "<i>Un arc de chasseur finement façonné, dont la courbure élégante et la corde tendue promettent des tirs précis et implacables.</i>",
      "tags": [
        "Arme",
        "Deux mains",
        "Arc"
      ],
      "effet": "<strong>Portée: </strong> 15m.<br>\n<strong>Dégâts: </strong> Inflige (Force) points de dégats physiques.\n<br> En cas de coup critique, si une charge de consomable flèche avait été utilisée, elle est récupérée.",
      "prix": "🔷 <strong>Prix:</strong> 100",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Grande hache de bûcheron",
      "numero": 44,
      "image": "https://i.ibb.co/gMbq4QZD/Hache-Bucheron.png",
      "description": "<i>Une lourde hache à long manche de bois renforcé, dont la large lame d’acier est faite pour fendre les troncs les plus épais.</i>",
      "tags": [
        "Arme",
        "Arme exotique",
        "Deux mains"
      ],
      "effet": "<strong>Dégâts: </strong> Inflige (7  + Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 100",
      "poids": "⚖️ <strong>Poids:</strong> 2"
    },
    {
      "nom": "Tunique d'explorateur",
      "numero": 45,
      "image": "https://i.ibb.co/Kj070KVw/Robe2.png",
      "description": "<i>Légère et pratique, elle est garnie de poches et de lanières pour affronter de longues marches et résister aux intempéries.</i>",
      "tags": [
        "Armure",
        "Robe"
      ],
      "effet": "<strong>Effet:</strong> Augmente la Chance de 3.\n<br> Permet de stocker 2 consommables supplémentaires dans le sac.",
      "prix": "🔷 <strong>Prix:</strong> 130",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Robe de la forêt",
      "numero": 46,
      "image": "https://i.ibb.co/Kj070KVw/Robe2.png",
      "description": "<i>Tissée de fibres vertes et ornée de feuillage vivant, elle se fond dans la végétation et améliore son porteur par la magie sylvestre.</i>",
      "tags": [
        "Armure",
        "Robe",
        "Non identifié"
      ],
      "effet": "<strong>Effet:</strong> Augmente les dégats élémentaires de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> et d'<span style=\"color: #4682b4; font-weight: bold;\">Eau</span> infligés par les sorts de 5.",
      "prix": "🔷 <strong>Prix:</strong> ?",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Armure en cuir d'ours",
      "numero": 47,
      "image": "https://i.ibb.co/C3bVcQkV/Armure-Ours.png",
      "description": "<i>Massive et chaude, faite d’une épaisse fourrure brune et de cuir tanné, elle confère force et résistance sauvage.</i>",
      "tags": [
        "Armure",
        "Armure légère"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 3.\n<br>Augmente l'armure élémentaire <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> et <span style=\"color: #22c55e; font-weight: bold;\">Air</span> de 5.",
      "prix": "🔷 <strong>Prix:</strong> 200",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Rapière elfique",
      "numero": 48,
      "image": "https://i.ibb.co/Z1FnQ4TH/Rapi-re-Elfique.png",
      "description": "<i>Fine et élégante, gravée de runes lumineuses, elle canalise l’énergie des anciens bois pour renforcer la magie de son porteur.</i>",
      "tags": [
        "Arme",
        "Épée",
        "Une main",
        "Non identifié"
      ],
      "effet": "<strong>Dégats:</strong> Inflige (4 + Force) points de dégats physiques.\n<br><strong>Effet:</strong> Augmente l'intelligence de 5.",
      "prix": "🔷 <strong>Prix:</strong> ?",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Armure de cuir de monstre",
      "numero": 49,
      "image": "https://i.ibb.co/MyZR8SYt/Armure-Cuir-Monstre.png",
      "description": "<i>Une armure légère tannée dans la peau rugueuse d’une bête abattue, souple mais marquée de cicatrices naturelles qui témoignent de la sauvagerie de la créature.</i>",
      "tags": [
        "Armure",
        "Armure légère"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'Armure physique de 2.<br> Augmente l'Endurance de 2.",
      "prix": "🔷 <strong>Prix:</strong> 120",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Cristal de Sel",
      "numero": 50,
      "image": "",
      "description": "<i>Sel raffiné qui sublime le goût de chaque plat.</i>",
      "tags": [
        "Nourriture"
      ],
      "effet": "<strong>Effet:</strong> Double les soins prodigués par une nourriture.\n\n<br>          <strong>Charges:</strong> 5.",
      "prix": "🔷 <strong>Prix:</strong> 50",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    }
  ],
  "filterSettings": {
    "visibleTags": [
      "Consommable"
    ],
    "displayedFilterButtons": [
      "Arme",
      "Armure",
      "Consommable",
      "Bouclier"
    ]
  },
  "categoryDescription": "Équipements, armes, armures et objets divers que peuvent posséder les personnages.",
  "description": "Fortune + d20"
};
    window.MONSTRES = [
  {
    "nom": "Araignée Géante",
    "tags": [
      "Forêt"
    ],
    "image": "data/images/Monstres/foret/Monstre_Forêt_AraignéeGéante.png",
    "element": "Nuit",
    "pointsDeVie": 15,
    "armurePhysique": "0",
    "esquive": "2",
    "initiative": "3",
    "coupCritique": "1",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "3",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": "2",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": "5",
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Morsure venimeuse:</strong> Inflige 5 dégâts Physiques. <br> Si (resistance altérations &lt; 3)  + <span class=\"etat-link\" data-etat=\"Empoisonné\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Empoisonné</span> 1 pendant 5 tours.<br><br><strong>Toile:</strong> Portée 9m, equivable, <span class=\"etat-link\" data-etat=\"Entravé/Entoilé/Embourbé\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Entoile</span> la cible pendant 2 tour.",
    "butin": "<strong>Butin:</strong>",
    "monster-abilites": "AAAAAAAA",
    "monster-armurephysique": "0",
    "monster-coupcritique": "1",
    "monster-esquive": "2",
    "monster-resistancealterations": "3",
    "monster-coupcritiquesorts": "0",
    "monster-armureterre": "2",
    "monster-armureobscurite": "5",
    "monster-initiative": "3"
  },
  {
    "nom": "Crabe des Bois",
    "tags": [
      "Forêt"
    ],
    "image": "data/images/Monstres/foret/Monstre_Forêt_CrabedesBois.png",
    "element": "Eau",
    "pointsDeVie": "30",
    "armurePhysique": "5",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "1",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "5",
    "armureFeu": 0,
    "armureEau": "5",
    "armureTerre": "2",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "Attaque deux fois<br>  <strong>Pinces acérées:</strong> Inflige 7 dégâts",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "Groink",
    "tags": [
      "Forêt"
    ],
    "image": "data/images/Monstres/foret/Monstre_Forêt_Groink.png",
    "element": "Terre",
    "pointsDeVie": "15",
    "armurePhysique": "0",
    "esquive": "1",
    "initiative": 1,
    "coupCritique": "0",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": 3,
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": "3",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": "2",
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Charge brutale:</strong> Fonce et Inflige 5 dégâts. Critique : <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span><br><strong>Lance rocher:</strong> Portée 15m,  4 dégats physiques.",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "Groinka",
    "tags": [
      "Forêt"
    ],
    "image": "data/images/Monstres/foret/Monstre_Forêt_Groinka.png",
    "element": "Terre",
    "pointsDeVie": "15",
    "armurePhysique": "0",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "0",
    "coupCritiqueSorts": "1",
    "resistanceAlterations": "4",
    "armureFeu": "0",
    "armureEau": "0",
    "armureTerre": "3",
    "armureAir": "0",
    "armureLumiere": 0,
    "armureObscurite": 2,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "Attaque : <span class=\"spell-link\" data-spell=\"Volée de pierres\" data-category=\"Sorts de Mage\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Volée de pierres</span>  <br>Soin : <span class=\"spell-link\" data-spell=\"Soin mineur\" data-category=\"Sorts de Prêtre\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Soin mineur</span> <br> Alteration: \n<span class=\"spell-link\" data-spell=\"Accroche terrestre\" data-category=\"Sorts d'Enchanteur\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Accroche terrestre</span>",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "Guêpe Géante",
    "tags": [
      "Forêt"
    ],
    "image": "data/images/Monstres/foret/Monstre_Forêt_GuêpeGéante.png",
    "element": "Air",
    "pointsDeVie": "15",
    "armurePhysique": 0,
    "esquive": "5",
    "initiative": 1,
    "coupCritique": "3",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "3",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": 0,
    "armureAir": "5",
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Volant</strong>: Necessite de sauter pour attaque au corps à corps.<br><strong>Dard: </strong> Inflige 5 degats physiques + 3 <span style=\"color: #22c55e; font-weight: bold;\">Air</span>. Critique : <span class=\"etat-link\" data-etat=\"Empoisonné\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Empoisonné</span> 1 , 5 tours",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "5"
  },
  {
    "nom": "Ours des Bois",
    "tags": [
      "Forêt"
    ],
    "image": "data/images/Monstres/foret/Monstre_Forêt_OursdesBois.png",
    "element": "Terre",
    "pointsDeVie": "40",
    "armurePhysique": 4,
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "1",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "4",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": 2,
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 1,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Griffes dévastatrices:</strong> Inflige 7 dégâts physiques à une cible.<br><strong>Rugissement:</strong> Cible à 9m  <span class=\"etat-link\" data-etat=\"Affaibli\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Affaibli</span> , si  (resistance altérations &lt; 4)",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "1"
  },
  {
    "nom": "Pouple de la forêt",
    "tags": [
      "Forêt"
    ],
    "image": "",
    "element": "Eau",
    "pointsDeVie": "10",
    "armurePhysique": "0",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "0",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "0",
    "armureFeu": 0,
    "armureEau": "5",
    "armureTerre": 0,
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Accroche:</strong> Inflige 4 dégâts physiques. S'attache à la cible, qui devient <span class=\"etat-link\" data-etat=\"Ralenti\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Ralenti</span>.",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "2"
  },
  {
    "nom": "Serpent de la forêt",
    "tags": [
      "Forêt"
    ],
    "image": "",
    "element": "Terre",
    "pointsDeVie": 20,
    "armurePhysique": "0",
    "esquive": 5,
    "initiative": 1,
    "coupCritique": "2",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": 3,
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": "5",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Morsure venimeuse:</strong> Inflige 5 dégâts Physiques. <br> Si (resistance altérations &lt; 4)  + <span title=\"Des dégats sont appliqués à chaque début de tour du lanceur, réduits ni par l'armure physique ni par l'armure élémentaire.\">Empoisonné</span>2 pendant 5 tours.<br><br>",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "4"
  },
  {
    "nom": "Scarabée géant",
    "tags": [
      "Forêt"
    ],
    "image": "",
    "element": "Air",
    "pointsDeVie": 20,
    "armurePhysique": "3",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "0",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "5",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": 0,
    "armureAir": "5",
    "armureLumiere": 0,
    "armureObscurite": "5",
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Volant</strong>: Necessite de sauter pour attaque au corps à corps.<br><strong>Morsure: </strong> inflige 5 physique.\n<br><strong>Vent aveuglant: </strong> Portée 6m, esquivable, inflige 5 <span style=\"color: #22c55e; font-weight: bold;\">Air</span>. Si (Res Alt &lt; 4) <span class=\"etat-link\" data-etat=\"Aveuglé\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Aveuglé</span>",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "5"
  },
  {
    "nom": "Boss Forêt",
    "tags": [
      "Forêt",
      "Boss"
    ],
    "image": "",
    "element": "Terre",
    "pointsDeVie": "200",
    "armurePhysique": "3",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "2",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "10",
    "armureFeu": 0,
    "armureEau": "0",
    "armureTerre": "10",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": "5",
    "armureDivin": 0,
    "armureMalefique": "5",
    "abilites": "Double attaque.<br><strong>Attaque basique:</strong> Inflige 10 dégâts physiques. <br><strong>Hurlement:</strong> Tous les adversaires à 15m, avec Resistance altération &lt; 6, sont <span class=\"etat-link\" data-etat=\"Affaibli\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Affaibli</span>.  \n<br><b>Repoussoir</b>: Repousse une une cible à 9m. Inflige 5 dégats.\n<br><b>Appel </b>: Hurle et fait venir 2 Groinkas.\n<br><b>Tremblement de terre </b>: Tous les adversaires à 15m, 7 dégats <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> , critique 12.",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "3"
  }
];
    window.TABLES_TRESORS = {
  "tables": [
    {
      "nom": "Monstre forêt commun",
      "description": "feffez",
      "tags": [
        "Forêt"
      ],
      "fourchettes": [
        {
          "min": 1,
          "max": 3,
          "objet": {
            "type": "reference",
            "numero": 15,
            "nom": "Feuilleclaire"
          }
        },
        {
          "min": 4,
          "max": 6,
          "objet": {
            "type": "reference",
            "numero": 16,
            "nom": "Nocteline"
          }
        },
        {
          "min": 7,
          "max": 9,
          "objet": {
            "type": "reference",
            "numero": 13,
            "nom": "Petite potion de mana"
          }
        },
        {
          "min": 10,
          "max": 12,
          "objet": {
            "type": "reference",
            "numero": 12,
            "nom": "Petite potion de vie"
          }
        },
        {
          "min": 13,
          "max": 15,
          "objet": {
            "type": "reference",
            "numero": 21,
            "nom": "Fruits de la forêt"
          }
        },
        {
          "min": 16,
          "max": 19,
          "objet": {
            "type": "reference",
            "numero": 17,
            "nom": "Baguette de d'accélération"
          }
        }
      ]
    },
    {
      "nom": "Boss forêt",
      "description": "BBB",
      "tags": [
        "Forêt",
        "Boss"
      ],
      "fourchettes": [
        {
          "min": 1,
          "max": 3,
          "objet": {
            "type": "reference",
            "numero": 21,
            "nom": "Fruits de la forêt"
          }
        },
        {
          "min": 4,
          "max": 8,
          "objet": {
            "type": "reference",
            "numero": 11,
            "nom": "Armure de plaque"
          }
        },
        {
          "min": 9,
          "max": 12,
          "objet": {
            "type": "reference",
            "numero": 18,
            "nom": "Baguette de sommeil"
          }
        },
        {
          "min": 13,
          "max": 16,
          "objet": {
            "type": "reference",
            "numero": 8,
            "nom": "Robe simple"
          }
        },
        {
          "min": 17,
          "max": 20,
          "objet": {
            "type": "reference",
            "numero": 4,
            "nom": "Bâton en bois"
          }
        }
      ]
    },
    {
      "nom": "ProvisionAuberge",
      "description": "Table de butin pour une situation spécifique.",
      "tags": [
        "Auberge"
      ],
      "fourchettes": [
        {
          "min": 1,
          "max": 5,
          "objet": {
            "type": "reference",
            "numero": 22,
            "nom": "Ration de survie"
          }
        },
        {
          "min": 5,
          "max": 8,
          "objet": {
            "type": "reference",
            "numero": 19,
            "nom": "Ration de nourriture"
          }
        },
        {
          "min": 9,
          "max": 12,
          "objet": {
            "type": "reference",
            "numero": 15,
            "nom": "Feuilleclaire"
          }
        },
        {
          "min": 13,
          "max": 17,
          "objet": {
            "type": "reference",
            "numero": 25,
            "nom": "Bandage d'urgence"
          }
        },
        {
          "min": 18,
          "max": 21,
          "objet": {
            "type": "reference",
            "numero": 12,
            "nom": "Petite potion de vie"
          }
        },
        {
          "min": 22,
          "max": 30,
          "objet": {
            "type": "reference",
            "numero": 20,
            "nom": "Ration copieuse de nourriture"
          }
        },
        {
          "min": 31,
          "max": 35,
          "objet": {
            "type": "reference",
            "numero": 1,
            "nom": "Nouvel objet"
          }
        }
      ]
    }
  ],
  "_metadata": {
    "availableTags": [
      "Forêt",
      "Boss",
      "Coffre",
      "Auberge"
    ]
  }
};
    window.COLLECTIONS = {
  "collections": [
    {
      "id": "d-part",
      "nom": "Départ",
      "description": "Objets disponibles à la création du personnage.",
      "icon": "📦",
      "objets": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        12,
        16,
        15,
        14,
        13,
        19,
        20,
        23,
        25
      ]
    }
  ]
};
    window.IMAGES = {
  "images": {
    "subclass:Guerrier:Nain des montagnes": "https://i.ibb.co/Zpv02X9p/e8c10c36dc90.jpg",
    "subclass:Guerrier:Berserker": "https://i.ibb.co/DPYjyGVd/b85000c2afa4.jpg",
    "subclass:Mage:Érudit": "https://i.ibb.co/M5pcNmF9/05fa4e535010.jpg",
    "subclass:Mage:Elfe": "https://i.ibb.co/K1SMkgb/d738588e0528.jpg",
    "subclass:Prêtre:Inquisiteur": "https://i.ibb.co/dJ02RNMc/c9cd3553df7e.jpg",
    "subclass:Prêtre:Clerc Divin": "https://i.ibb.co/8gFGZYqJ/698304cc75ee.jpg",
    "subclass:Rôdeur:Voleur": "https://i.ibb.co/q3jSxDnQ/90e89c692b47.jpg",
    "subclass:Rôdeur:Chasseur": "https://i.ibb.co/70wP75z/53de7da9e55c.jpg",
    "subclass:Enchanteur:Esprit de la grande Fée": "https://i.ibb.co/Cswfsyzz/9920a4e75242.jpg",
    "subclass:Enchanteur:Lutin": "https://i.ibb.co/Fbspq9hP/dd5e7b366e0f.jpg",
    "sort:Sorts de Mage:Boule de Feu": "https://i.ibb.co/vCWmgrQ5/Boule-De-Feu.png",
    "sort:Sorts de Mage:Éclair": "https://i.ibb.co/VYCTyMdH/Eclair.png",
    "sort:Sorts de Mage:Vague déferlante": "https://i.ibb.co/BSHtL8K/Vague.png",
    "sort:Sorts de Prêtre:Châtiment": "https://i.ibb.co/JRPyXx1L/Chatiment-Sacr.png",
    "sort:Sorts de Prêtre:Soin mineur": "https://i.ibb.co/YBC2HSnK/Soin-Mineur.png",
    "sort:Sorts d'Enchanteur:Accroche terrestre": "https://i.ibb.co/27W4NtSQ/Accroche-Terre.png",
    "sort:Sorts d'Enchanteur:Accélération": "https://i.ibb.co/Vc072qQB/Acceleration.png",
    "sort:Sorts d'Enchanteur:Sommeil": "https://i.ibb.co/rKyTh27C/Sleep.png",
    "sort:Sorts de Prêtre:Nouveau Sort": "https://i.ibb.co/7d1L9BCj/Nova-Lumineuse.png",
    "sort:Sorts de Prêtre:Protection": "https://i.ibb.co/QvK52kxH/Protection.png",
    "subclass:Guerrier:Nain des montagnes:1": "https://i.ibb.co/FL9m5HJn/Nain.png",
    "subclass:Guerrier:Nain des montagnes:2": "https://i.ibb.co/wNnJxSbj/NaineF.png",
    "subclass:Guerrier:Berserker:1": "https://i.ibb.co/YBWFbTKv/berseker.png",
    "subclass:Guerrier:Berserker:2": "https://i.ibb.co/20b74x2R/Berseker-F.png",
    "subclass:Mage:Érudit:1": "https://i.ibb.co/N8qT2Hf/Mage.png",
    "subclass:Mage:Érudit:2": "https://i.ibb.co/LdcPDSJQ/MageF.png",
    "subclass:Mage:Elfe:2": "https://i.ibb.co/VWDTjY8H/ElfeF.png",
    "subclass:Mage:Elfe:1": "https://i.ibb.co/gFVKrTcV/Elfe.png",
    "subclass:Prêtre:Inquisiteur:1": "https://i.ibb.co/tMcsCB8s/Inquisiteur.png",
    "subclass:Prêtre:Clerc Divin:1": "https://i.ibb.co/209W4ZHW/Pr-tre.png",
    "subclass:Rôdeur:Voleur:1": "https://i.ibb.co/NghMq11n/Voleur-min.png",
    "subclass:Rôdeur:Voleur:2": "https://i.ibb.co/h1BtkGMX/VoleurF.png",
    "subclass:Rôdeur:Chasseur:1": "https://i.ibb.co/yF8jrJYr/Chasseur-min.png",
    "subclass:Rôdeur:Chasseur:2": "https://i.ibb.co/3mQjLJbp/Chasseur-F.png",
    "subclass:Enchanteur:Esprit de la grande Fée:1": "https://i.ibb.co/VY9cQHNh/F-eM.png",
    "subclass:Enchanteur:Esprit de la grande Fée:2": "https://i.ibb.co/pjxDfXBC/F-e.png",
    "subclass:Enchanteur:Lutin:1": "https://i.ibb.co/6cxkMW1d/Lutin.png",
    "subclass:Enchanteur:Lutin:2": "https://i.ibb.co/qLbjJhxw/LutinF.png",
    "subclass:Prêtre:Inquisiteur:2": "https://i.ibb.co/LXwmWYR3/Inquisiteur-F.png",
    "subclass:Prêtre:Clerc Divin:2": "https://i.ibb.co/HfBVNLM3/PretreF.png",
    "sort:Sorts de Prêtre:Arme de lumière": "https://i.ibb.co/cXh57Pdn/ArmeLum.png",
    "objet:Épée Longue": "https://i.ibb.co/35rpP6ZS/Epee2M1.png",
    "objet:Espadon": "https://i.ibb.co/35rpP6ZS/Epee2M1.png",
    "objet:Simple épée": "https://i.ibb.co/PsSXvSXx/Epee1.png",
    "objet:Dague en fer": "https://i.ibb.co/1fCwy6cR/Dague1.png",
    "objet:Bâton en bois": "https://i.ibb.co/PsyCNw86/Baton1.png",
    "objet:Gourdin": "https://i.ibb.co/whZCKww0/Baton2.png",
    "objet:Arc simple": "https://i.ibb.co/cKb1JKZQ/Arc1.png",
    "objet:Bouclier en bois": "https://i.ibb.co/67bK4Bw8/Bouclier1.png",
    "objet:Robe simple": "https://i.ibb.co/VYFpnz8h/Robe1.png",
    "objet:Armure de cuir": "https://i.ibb.co/9Hkw2VFb/Armure-Cuir1.png",
    "objet:Armure en maille": "https://i.ibb.co/cXtwzw5b/Armure-Lourde1.png",
    "objet:Armure de plaque": "https://i.ibb.co/fVg5Fp6h/Armure-Lourde2.png",
    "subclass:Guerrier:Aventurier:1": "https://i.ibb.co/9HcQkbb2/Aventurier.png",
    "subclass:Guerrier:Aventurier:2": "https://i.ibb.co/nH8Yj3h/Aventurier-F.png",
    "objet:Petite potion de vie": "https://i.ibb.co/Mw2Qb8Y/LifePot1.png",
    "objet:Petite potion de mana": "https://i.ibb.co/MkwzbQ3S/Potion-Mana1.png",
    "objet:Baguette de boule de feu": "https://i.ibb.co/JwXs3k2V/Baguette-Feu.png",
    "objet:Feuilleclaire": "https://i.ibb.co/bMDstDVV/Herb1.png",
    "objet:Nocteline": "https://i.ibb.co/7JpQ7Kr7/Herb2.png",
    "objet:Nouvel Objet": "https://i.ibb.co/3Y0fvrCG/Sel.png",
    "objet:Baguette de sommeil": "https://i.ibb.co/bMXNS4gy/Baguette-Nuit.png",
    "monster:Araignée Géante": "https://i.ibb.co/b0XHjQJ/Monstre-For-t-Araign-e.png",
    "monster:Crabe des Bois": "https://i.ibb.co/7dY3GgJS/Monstre-For-t-Crab.png",
    "monster:Groink": "https://i.ibb.co/MDngQGcS/Monstre-For-t-Groink.png",
    "monster:Groinka": "https://i.ibb.co/YThB7Q29/Monstre-For-t-Groink-Chaman.png",
    "monster:Guêpe Géante": "https://i.ibb.co/bjSq3pPj/Monstre-For-t-Guepe-Geante.png",
    "monster:Ours des Bois": "https://i.ibb.co/N2NcD6n2/Monstre-For-t-Ours.png",
    "monster:Pouple de la forêt": "https://i.ibb.co/0jG2WLsv/Monstre-For-t-Poulpe.png",
    "monster:Serpent de la forêt": "https://i.ibb.co/svhHLvKZ/Monstre-For-t-Serpent.png",
    "monster:Scarabée géant": "https://i.ibb.co/wF5bRvts/Monstre-For-t-Scarabe-Geant.png",
    "monster:Boss Forêt": "https://i.ibb.co/1JR11CC7/Monstre-For-t-Boss.png",
    "sort:Sorts de Mage:Volée de pierres": "https://i.ibb.co/GfPFdZPG/Volee-Pierre.png",
    "objet:Baguette de d'accélération": "https://i.ibb.co/zT29mKBd/Baguette-Lumiere.png",
    "objet:Ration de nourriture": "https://i.ibb.co/tT6gW6p0/Food1.png",
    "objet:Ration copieuse de nourriture": "https://i.ibb.co/7JZW2ZZT/Food2.png",
    "objet:Fruits de la forêt": "https://i.ibb.co/svC0cDH6/food3.png",
    "sort:Sorts de Prêtre:Refermer les blessures": "https://i.ibb.co/zV1rzFkd/Soin-Mineur.png",
    "objet:Ration de survie": "https://i.ibb.co/Py57FHy/Food0.png",
    "subclass:Guerrier:Nouvelle sous-classe:1": "https://i.ibb.co/dsPhMWkY/Ma-tre-d-armes.png",
    "subclass:Guerrier:Maître d’armes:1": "https://i.ibb.co/dsPhMWkY/Ma-tre-d-armes.png",
    "subclass:Guerrier:Maître d’armes:2": "https://i.ibb.co/BVD015MF/Ma-tre-d-armes-F.png",
    "objet:Flèche aiguisée": "https://i.ibb.co/4Z7qKXCx/Fleche-Aiguis-e.png",
    "objet:Flèche de la terre": "https://i.ibb.co/ZpScRTwS/Fleche-Terre.png",
    "page:geographie": "https://i.ibb.co/svmYXJbN/Carte-fantastique-d-taill-e-et-color-e.png",
    "sort:Sorts de Prêtre:Révélation mineure": "https://i.ibb.co/DP5md5sT/Revelation-Mineure.png",
    "sort:Sorts de Prêtre:Révélation majeure": "https://i.ibb.co/hRhqmPCK/Revelation-Majeure.png",
    "sort:Sorts de Prêtre:Révélation ultime": "https://i.ibb.co/7xY0wvNK/Revelation-Ultime.png",
    "objet:Bandage d'urgence": "https://i.ibb.co/4ZPsSM3p/Bandages.png",
    "objet:Bracelet médicinal de la forêt": "https://i.ibb.co/k2h292gV/Bracelet-Foret.png",
    "objet:Dent de Grouink": "https://i.ibb.co/whc5dwnw/Dent-Grouik.png",
    "objet:Echarpe de chaman Groink": "https://i.ibb.co/W4tfpFcH/Echarpe-Chaman.png",
    "objet:Fourrure d'ours": "https://i.ibb.co/9HhVCqvk/Fourrure-Ours.png",
    "objet:Pierre à aiguiser": "https://i.ibb.co/SX10mS2q/Buff01.png",
    "objet:Cristal d'effort": "https://i.ibb.co/k2MHGqhx/Cristal-Effort.png",
    "objet:Pince de crabe géant des forêts": "https://i.ibb.co/VWKF2ysm/Masse-Foret1.png",
    "objet:Clairgivre": "https://i.ibb.co/s9CJtsPr/Herb5.png",
    "objet:Auréline des Roches": "https://i.ibb.co/My3mcc60/Herb3.png",
    "objet:Nébrelle d’Azur": "https://i.ibb.co/bMn4mMyK/Herb4.png",
    "objet:Aile de scarabée géant": "https://i.ibb.co/RGZM6Tfx/Cape-Scarab.png",
    "objet:Bottes en cuir de guêpe géante": "https://i.ibb.co/k2V6Df2z/Botte-Guepe.png",
    "objet:Gants patte d'ours": "https://i.ibb.co/KzrZRGcd/Gants-Patte-Ours.png",
    "objet:Bouclier de la forêt": "https://i.ibb.co/Zpkw8qVL/Bouclier-Foret.png",
    "objet:Couronne d'épines": "https://i.ibb.co/d09YYyy8/Couronne-Epines.png",
    "objet:Collier terrestre": "https://i.ibb.co/ksxCppN8/Collier-Terrestre.png",
    "objet:Arc de chasseur": "https://i.ibb.co/bRXH0Vwj/Arc2.png",
    "objet:Dard de guêpe géante": "https://i.ibb.co/mjcDdck/Dague2.png",
    "objet:Grande hache de bûcheron": "https://i.ibb.co/gMbq4QZD/Hache-Bucheron.png",
    "objet:Tunique d'explorateur": "https://i.ibb.co/Kj070KVw/Robe2.png",
    "objet:Robe de la forêt": "https://i.ibb.co/Zp7bLygX/Robe3.png",
    "objet:Armure en cuir d'ours": "https://i.ibb.co/C3bVcQkV/Armure-Ours.png",
    "objet:Rapière elfique": "https://i.ibb.co/Z1FnQ4TH/Rapi-re-Elfique.png",
    "sort:Sorts de Prêtre:Resistance": "https://i.ibb.co/TxWg9bns/Resistance.png",
    "sort:Sorts de Prêtre:Guérison du poison": "https://i.ibb.co/4nhGwkjX/Anti-Poison.png",
    "sort:Sorts de Prêtre:Nova lumineuse": "https://i.ibb.co/7d1L9BCj/Nova-Lumineuse.png",
    "sort:Sorts de Prêtre:Toucher Lointain": "https://i.ibb.co/k2Z2WrP4/Soin-Distance.png",
    "sort:Sorts de Mage:Faisceau lumineux": "https://i.ibb.co/KpXwSx6V/Faiseau-Lum.png",
    "sort:Sorts de Mage:Vague sombre": "https://i.ibb.co/0yRTFkqy/Vague-sombre.png",
    "sort:Sorts de Mage:Missile magique": "https://i.ibb.co/bM9VS8GB/Missile-Magique.png",
    "sort:Sorts de Mage:Nuage toxique": "https://i.ibb.co/35C4DgdS/Nuage-Toxique.png",
    "sort:Sorts d'Enchanteur:Nouveau Sort": "https://i.ibb.co/FLbCrnKQ/L-vitation.png",
    "sort:Sorts d'Enchanteur:Lévitation": "https://i.ibb.co/FLbCrnKQ/L-vitation.png",
    "sort:Sorts d'Enchanteur:Imprégnation élémentaire feu terre nuit": "https://i.ibb.co/RkrW8CRC/Enchant-Element.png",
    "sort:Sorts d'Enchanteur:Imprégnation élémentaire eau air lumière": "https://i.ibb.co/WNWfc1jC/Enchant-Element2.png",
    "sort:Sorts d'Enchanteur:Silence": "https://i.ibb.co/7JRKfdMw/Silence.png",
    "sort:Sorts d'Enchanteur:Puissance magique": "https://i.ibb.co/FbtF1PjX/Puissance-Sort.png",
    "sort:Sorts d'Enchanteur:Puissance physique": "https://i.ibb.co/VckPSx1C/Puissance-Physique.png",
    "sort:Sorts d'Enchanteur:Confusion": "https://i.ibb.co/vCwsVnR5/Confusion.png",
    "sort:Sorts d'Enchanteur:Armure élémentaire Feu Terre Nuit": "https://i.ibb.co/SH5jcyv/Armure-El-mentaire1.png",
    "sort:Sorts d'Enchanteur:Armure élémentaire Eau Air Lumière": "https://i.ibb.co/jP9RKzdq/Armure-El-mentaire2.png",
    "objet:Armure de cuir de monstre": "https://i.ibb.co/MyZR8SYt/Armure-Cuir-Monstre.png"
  },
  "meta": {
    "total_images": 131,
    "exported_date": "2025-09-11",
    "note": "Ces images incluent les nouvelles images uploadées"
  }
};
    
    // Page descriptions
    window.MONSTRES_PAGE_DESC = {
  "description": "Créatures, ennemis et adversaires que peuvent affronter les héros dans leurs aventures."
};
    window.TABLES_TRESORS_PAGE_DESC = {
  "description": "Fortune + d20"
};
    
    // Custom page descriptions for collections and other dynamic pages
    window.CUSTOM_PAGE_DESCRIPTIONS = {
  "collections-objets": "Recherchez et explorez des collections d'objets.\n<br>Par exemple, tapez <b>Départ</b> pour voir les objets disponnibles lors de la création du personnage.\n<br>Les collections sont cachées de base pour éviter le <b>spoil</b>."
};
    
    // TOC Structure for advanced navigation
    window.TOC_STRUCTURE = {
  "directPages": [
    {
      "type": "page",
      "id": "favoris",
      "title": "⭐ Favoris",
      "icon": "⭐"
    }
  ],
  "sections": [
    {
      "id": "heros",
      "title": "🦸 Héros",
      "icon": "🦸",
      "description": "Création et développement des personnages",
      "collapsed": false,
      "items": [
        {
          "type": "page",
          "id": "creation",
          "title": "Création d'un personnage",
          "icon": "🎭"
        },
        {
          "type": "category",
          "id": "classes",
          "title": "Classes",
          "icon": "⚔️",
          "items": "CLASSES"
        },
        {
          "type": "category",
          "id": "dons",
          "title": "Dons",
          "icon": "🎖️",
          "items": "DONS"
        },
        {
          "type": "page",
          "id": "feuille-personnage",
          "title": "Feuille de personnage",
          "icon": "📋"
        }
      ]
    },
    {
      "id": "arsenal",
      "title": "⚔️ Arsenal",
      "icon": "⚔️",
      "description": "Sorts, objets et équipements",
      "collapsed": false,
      "items": [
        {
          "type": "category",
          "id": "sorts",
          "title": "Sorts",
          "icon": "🔮",
          "items": "SORTS"
        },
        {
          "type": "page",
          "id": "objets",
          "title": "Objets",
          "icon": "📦"
        },
        {
          "type": "page",
          "id": "collections-objets",
          "title": "Collections d'Objets",
          "icon": "📚"
        }
      ]
    },
    {
      "id": "regles",
      "title": "📚 Règles",
      "icon": "📚",
      "description": "Mécaniques de jeu et références",
      "collapsed": false,
      "items": [
        {
          "type": "page",
          "id": "elements",
          "title": "Éléments",
          "icon": "🌟"
        },
        {
          "type": "page",
          "id": "stats",
          "title": "Statistiques",
          "icon": "📊"
        },
        {
          "type": "page",
          "id": "competences-tests",
          "title": "Compétences & Tests",
          "icon": "🎯"
        },
        {
          "type": "page",
          "id": "etats",
          "title": "États",
          "icon": "⚡"
        },
        {
          "type": "page",
          "id": "combat",
          "title": "Combat",
          "icon": "⚔️"
        },
        {
          "type": "page",
          "id": "gestion-des-ressources",
          "title": "Gestion des ressources",
          "icon": "💎"
        }
      ]
    },
    {
      "id": "maitre-de-jeu",
      "title": "🎭 Maître de jeu",
      "icon": "🎭",
      "description": "Outils et ressources pour le Maître de jeu",
      "collapsed": false,
      "requiresMJ": true,
      "items": [
        {
          "type": "page",
          "id": "monstres",
          "title": "Monstres",
          "icon": "👹"
        },
        {
          "type": "page",
          "id": "tables-tresors",
          "title": "Tables de trésors",
          "icon": "💎"
        },
        {
          "type": "page",
          "id": "audio",
          "title": "Musiques d'ambiance",
          "icon": "🎵"
        },
        {
          "type": "page",
          "id": "traumas",
          "title": "Traumas",
          "icon": "🩹"
        },
        {
          "type": "page",
          "id": "campagne",
          "title": "Campagne",
          "icon": "📖"
        },
        {
          "type": "page",
          "id": "gestion-objets",
          "title": "Gestion des Objets",
          "icon": "⚔️"
        }
      ]
    },
    {
      "id": "monde",
      "title": "🌍 Monde",
      "icon": "🌍",
      "description": "Univers et connaissances du monde",
      "collapsed": false,
      "items": [
        {
          "type": "page",
          "id": "histoire",
          "title": "Histoire",
          "icon": "📜"
        },
        {
          "type": "page",
          "id": "dieux",
          "title": "Dieux",
          "icon": "🏛️"
        },
        {
          "type": "page",
          "id": "geographie",
          "title": "Geographie",
          "icon": "📜"
        }
      ]
    }
  ]
};
    
    // Build STATIC_PAGES dynamically from all loaded page data
    window.STATIC_PAGES = {
      'creation': {
  "page": "creation",
  "title": "Création d'un personnage",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "",
      "id": "section-0"
    },
    {
      "type": "card",
      "id": "etapes-creation",
      "title": "Étapes de création",
      "content": "<ol><li>Choisir une <strong>classe</strong> puis une <strong>sous‑classe</strong> : <a href=\"#/guerrier\" style=\"color: var(--accent); text-decoration: underline;\">Guerrier</a>.</li><li>Choisir un <strong>élément</strong> d'affiliation : <a href=\"#/elements\" style=\"color: var(--accent); text-decoration: underline;\">Éléments</a>.</li><li>Choisir les <strong>dons</strong> (avec 2 points de dons) : <a href=\"#/dons-generaux\" style=\"color: var(--accent); text-decoration: underline;\">Generaux (dons)</a>.</li><li>Choisir l'<strong>équipement</strong> de départ (avec 100 éclats) : <a href=\"#/collections-objets\" style=\"color: var(--accent); text-decoration: underline;\">Collections d'Objets</a>.</li><li>Définir le <strong>nom</strong>, l'<strong>histoire</strong> et l'<strong>apparence</strong>.</li><li>Remplir sa feuille de personnage : <a href=\"#/feuille-personnage\" style=\"color: var(--accent); text-decoration: underline;\">Feuille de personnage</a>.</li></ol>",
      "deletable": true,
      "sectionName": "Étapes de création"
    }
  ]
},
      'elements': {
  "page": "elements",
  "title": "Elements",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "elements-system",
      "title": "Système d'éléments",
      "content": "<p>Il existe huit éléments, chacun ayant un opposé. Chaqué Héros où monstre possède un élément d'affiliation.<br><br> Une créature affiliée à un élément :<br> - Reçoit <strong>deux fois moins </strong> (arrondi inférieur) de dégats venant des sorts et attaques de cet élément, et ne peut pas recevoir d'effet critique d'une alteration magique de cet élément.<br>- Recevra systématiquement des <strong>effets critiques</strong> venant des sorts et altérations de l'élément opposé. Les dégats élémentaires rattachés à une attaque physique (venant d'un objet ou sort) voit ses dégats doublés s'il est d'un élément opposé.</p>"
    },
    {
      "type": "card",
      "id": "element-pairs",
      "title": "Paires opposées",
      "content": "<div class=\"element-pairs\"><div class=\"pair\">🔥 <span style=\"color: #ff6b35; font-weight: bold;\">Feu</span> ⟷ 💧 <span style=\"color: #4682b4; font-weight: bold;\">Eau</span></div><div class=\"pair\">🤎 <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> ⟷ 🟢 <span style=\"color: #22c55e; font-weight: bold;\">Air</span></div><div class=\"pair\">☀️ <span style=\"color: #ffd700; font-weight: bold;\">Lumière</span> ⟷ ⚫ <span style=\"color: #1a1a1a; font-weight: bold;\">Nuit</span></div><div class=\"pair\">⚪ <span style=\"color: #f5f5f5; font-weight: bold; background: rgba(100, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;\">Divin</span> ⟷ 🟣 <span style=\"color: #8b5cf6; font-weight: bold;\">Maléfique</span></div></div>"
    },
    {
      "type": "card",
      "id": "element-defense",
      "title": "Défense",
      "content": "<p>Certaines armures/objets/bonus peuvent procurer une armure spécifique à un élément. Il faudra alors déduire au resultat final. Le calcul de dégats se fait dans cet ordre :</p><div><strong>Dégats → critique → ×0.5 si affiliation élément → réduction de l'armure</strong></div>",
      "deletable": true,
      "sectionName": "Défense"
    },
    {
      "type": "card",
      "id": "element-attack",
      "title": "Attaque",
      "content": "<p>Une attaque ne peut avoir qu'<strong>un seul élément</strong> (en plus d'éventuels dégats physiques). Si plusieurs sorts/équipements/bonus donnent un élément à l'attaque, le héros devra choisir quel est l'élément utilisé.</p> Plusieurs bonus d'un même élément peuvent se cumuler.\n<br><br> Si l'élément rattaché à une attaque physiques est opposé à l'élément d'affiliation de la cible, alors les dégats élémentaires sont doublés.",
      "deletable": true,
      "sectionName": "Attaque"
    }
  ]
},
      'stats': {
  "page": "stats",
  "title": "Statistiques",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "stats-base",
      "title": "Statistiques de base",
      "content": "<hr><div class=\"stats-grid\"><div class=\"stat-card\"><h4>💪 Force</h4><p>Améliore les dégâts physiques.</p></div><hr>\n\n<div class=\"stat-card\"><h4>🛡️ Endurance</h4><p>Les points de vie maximum sont de : <strong>(2 x Endurance)</strong></p><p></div>\n\n<hr><div class=\"stat-card\">\n<h4>🏃 Agilité</h4><p>Chaque 5 points ajoutent <strong>+1</strong> aux jets d'esquive et de critique physique.\n<br><br>Augmente l'initiative d'autant.</p></div><hr>\n\n<div class=\"stat-card\"><h4>🧠 Intelligence</h4><p>Détermine la puissance des sorts.</p></div><hr><div class=\"stat-card\"><h4>⚡ Volonté</h4><p>Le mana maximum est de : <strong>(10 + 2 x Volonté)</strong></p><p>Augmente la Résistance altérations.</p>\n\n</div><hr><div class=\"stat-card\"><h4>🍀 Chance</h4><p>Améliore la Fortune d'autant.</p><p>De plus, chaque 5 points ajoutent <strong>+1</strong> aux chances de coup critique avec les sorts et les consommables.</p></div></div>",
      "deletable": true,
      "sectionName": "Statistiques de base"
    },
    {
      "type": "card",
      "id": "stats-new-3-1755784997112",
      "title": "Statistiques secondaires",
      "content": "<hr><br><br><strong>Chance de coup critique (physique) </strong> : Lors d'une attaque physique, le lanceur de l'attaque lance un d20. S'il fait 20, alors les dégats physiques (et seulement physiques) sont doublés.<br> Augmenter les chances de coup critique réduit la valeur du dé nécéssaire pour faire un critique. Par exemple, avec 3 de chance de coup critique, si le dé fait de 17 à 20, l'attaque est critique.\n\n<br><br><hr><br><strong>Chance de coup critique (sorts et consommables)</strong> : Lorsque un héros ou un monstre lance un sort ou utilise un consommable, il lance un d20. S'il fait 20, alors le sort est critique, chaque sort/consommable ayant un effet critique différent (indiqué dans sa description).<br> Augmenter les chances de coup critique des sorts et consommables réduit la valeur du dé nécéssaire pour faire un critique. Par exemple, avec 3 de chance de coup critique, si le dé fait de 17 à 20, le resultat est critique. \n\n<br><br><hr><br><strong>Esquive </strong> : Lors d'une attaque physique, ou d'un sort sans effet si esquive (indiqué dans la fiche du sort), lorsque le lanceur lance son d20, si le resultat est 1, l'attaque est sans effet. Avoir de l'esquive pour la cible de l'attaque augmente la valeur du dé jusqu'a laquelle l'attaque échoue. Par exemple, avec 3 d'esquive, si le dé fait 4 ou moins, l'attaque échoue. La valeur d'esquive ne peut jamais dépasser 9, quel que soit l'equipement ou bonus d'un joueur ou monstre.\n\n\n<br><br><hr><br><strong>Résistance altérations </strong> : Lorsqu'un lanceur de sort tente d'infliger une alteration magique à une cible, on compare la valeur de l'intelligence du lanceur à la Résistance altérations de la cible. Si l'intelligence est strictement supérieure, alors l'ateration réussit, sinon elle est sans effet.\n\n\n<br><br><hr><br><strong>Armure physique </strong> : Lorsqu'un héros ou monstre reçoit des dégats physiques, ils sont alors réduit de la valeur de l'armure physique pour savoir combien de points de vies sont retirés à la cible. Cette valeur est retiré en dernier sur les degats (aprés avoir éventuellement doublé les dégats si critique etc...)\n\n<br><br><hr><br><strong>Armure élémentaire </strong> : L'armure élémentaire est spécifique pour chaque élément, il y a donc 8 types d'armure élémentaire. Lorsqu'un héros ou monstre subit des dégats élémentaire correspondant à l'armure élémentaire, ils sont alors réduit de la valeur de l'armure pour savoir combien de points de vies sont retirés à la cible. Cette valeur est retiré en dernier sur les degats (aprés avoir éventuellement doublé les dégats si critique etc...).\n\n<br><br><hr><br><strong>Mana </strong> : Il s'agit de la ressource utilisée pour lancer des sorts. Hors combat, il revient automatiquement au maximum aprés plus d'une heure sans être en combat. En combat, il est consommé aprés le lancement de chaque sort (le coût en mana étant indiqué dans la description de chaque sort). Si un sort devait faire passer le mana d'un héros en dessous de 0, alors le sort n'est pas effectif et le héros devient <span class=\"etat-link\" data-etat=\"Endormi/assomé/Effrayé\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">paralysé</span> pendant 2 tours.\n\n<br><br><hr><br><strong>Vie </strong> : Les points de vie représentent la vitalité d’un héros ou d’un monstre, la mesure de son endurance face aux blessures. Tant qu’il lui reste des PV, le personnage peut continuer à se battre, à courir et à agir. Quand ses PV tombent à zéro, il s’effondre, mourant. Voir la page <a href=\"#/combat\" style=\"color: var(--accent); text-decoration: underline;\">Combat</a>.\nUn personnage qui effectue un repos régénère un nombre de points de vie égal à sa valeur d’Endurance.<br>\n\n<hr><br><strong>Fortune</strong> : Lorsqu’un événement fait appel à la Fortune (par exemple ouvrir un coffre et espérer y trouver un objet rare), le joueur lance un d20 et ajoute sa valeur de Fortune. Plus le total est élevé, meilleur sera le butin obtenu. \n\n<br><hr><br> <strong>Initiative</strong> : Cette valeur est comparée au début du combat avec tous les héros/monstres pour determiner l'ordre des tours de combat. Plus la valeur est élevée, plus le héros commence en premier.\n\n\n<br><hr><br> <strong>Taille </strong> : Détermine la taille d’une créature. Certains effets ne fonctionnent que sur certaines tailles :\n<ul>\n  <li><b>Petit</b> : 1 mètre ou moins</li>\n  <li><b>Moyen</b> : moins de 2 mètres</li>\n  <li><b>Grand</b> : moins de 3,5 mètres</li>\n  <li><b>Géant</b> : plus de 3,5 mètres</li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'competences-tests': {
  "page": "competences-tests",
  "title": "Compétences & Tests",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "grid",
      "cols": 2,
      "content": [
        {
          "type": "card",
          "id": "efforts",
          "title": "Efforts",
          "content": "<ul><li>Chaque héros dispose de 3 Efforts maximum.</li><li>Les héros récupèrent des efforts lors de repos courts ou longs.</li><li>Les Efforts peuvent être dépensés pour améliorer un test de compétence.</li></ul>",
          "deletable": true,
          "sectionName": "Efforts"
        },
        {
          "type": "card",
          "id": "competences-list",
          "title": "Compétences",
          "content": "<ul><li><em>Hardiesse</em>: Pousser, casser, sauter…</li><li><em>Finesse</em>: Crocheter, fabriquer, être discret…</li><li><em>Coordination</em>: Percevoir, équilibre, piloter…</li><li><em>Réflexion</em>: Savoir, comprendre, deviner…</li><li><em>Éloquence</em>: Persuader, mentir, intimider…</li></ul>",
          "deletable": true,
          "sectionName": "Compétences"
        }
      ]
    },
    {
      "type": "card",
      "id": "tests",
      "title": "Tests de compétences",
      "content": "<p>Quand un MJ annonce un test de compétence, un héros peut choisir de dépenser des efforts pour booster sa compétence. La difficulté d'un test est seule connue du MJ, et est entre 1 et 5 (Exigeant, Complexe , Éprouvant, Prodigieux , <strong>Impossible</strong>).</p><p>Une fois le test résolu, le Maître de Jeu annonce le résultat. Si le joueur a dépensé plus d'Efforts que nécessaire, l'excédent est perdu.</p><br> A noter que certaines actions sont impossibles à réaliser et un héros peut alors s'épuiser pour rien, s'il n'a pas bien évalué la difficulté de la tâche. A l'inverse, les tâches simples ne demandent pas de test de compétences.",
      "deletable": true,
      "sectionName": "Tests de compétences"
    }
  ]
},
      'etats': {
  "page": "etats",
  "title": "Etats",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "Lorsque un joueur subit un état, vous pouvez prendre une carte ou note pour avoir un rappel de l'effet. De plus, si c'est un état à durée limité, vous pouvez prendre un dé et le placer face au nombre de tour restant (en oubliant pas de changer sa valeur chaque début de tour).<br> Quand vous infligez des effets/alterations à un monstre, vous pouvez également utiliser un dé pour rappel (potentiellement d'une autre couleur, pour aider).\n<br>"
    },
    {
      "type": "card",
      "id": "a-terre",
      "title": "A terre",
      "content": "<p>Ne peut plus faire d'actions.</p><p> Ne peut plus esquiver.</p><p> Doit dépenser une action secondaire pour se relever.</p>",
      "deletable": true,
      "sectionName": "A terre"
    },
    {
      "type": "card",
      "id": "endormi-effraye",
      "title": "Endormi/assomé/Effrayé",
      "content": "<p>Ne peut plus faire d'actions.</p><p> Ne peut plus esquiver.</p><p> Des dégats infligés à la créature la sort de son état.</p>",
      "deletable": true,
      "sectionName": "Endormi/assomé/Effrayé"
    },
    {
      "type": "card",
      "id": "etats-new-4-1755725440741",
      "title": "Ralenti",
      "content": "Vitesse de déplacement réduite de 6m.<br> Impossible de sauter ou d'esquiver.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-5-1755762657383",
      "title": "Empoisonné",
      "content": "Des dégats sont appliqués à chaque début de tour, réduits ni par l'armure physique ni par l'armure élémentaire.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-6-1755762796465",
      "title": "Entravé/Entoilé/Embourbé",
      "content": "<p>Ne peut plus faire d'actions.</p><p>Ne peut plus esquiver.</p> Le héros ou un allié peut sortir le héros de l'état via un test de compétence hardiesse.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-7-1755762977439",
      "title": "Affaibli",
      "content": "Les dégats physiques effectués sont réduits de moitiés. Les tests de hardiesse ont une difficulté de 2 plus élevés.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-para-8-1755891140510",
      "title": "Silence",
      "content": "Incapable de lancer des sorts.",
      "deletable": true,
      "sectionName": "Nouveau paragraphe"
    },
    {
      "type": "card",
      "id": "etats-new-9-1756400691334",
      "title": "Vulnérable",
      "content": "Plus aucune protection apporté par l'armure physique ou élémentaire.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-10-1756400890785",
      "title": "Confus",
      "content": "A chaque début de tour, lancez un d20. si le resultat est de 10 ou moins, passe sont tour à se déplacer et attaquer au corp à corp la cible la plus proche.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-11-1756401053782",
      "title": "Maudit",
      "content": "Impossible d'effectuer des coups critiques (physiques ou magiques), et la resistance altération est divisé par 2.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-12-1756401063266",
      "title": "Débilité",
      "content": "La cible est incpable d'effectuer la moindre action ou d'esquiver. A chaque début de tour, elle perd des points de vie, réduits ni par l'armure physique ni par l'armure élémentaire.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-13-1756408622987",
      "title": "Fatigué",
      "content": "Incapable d'utiliser des efforts. Coût en mana des sorts doublés. Dégats physiques infligés réduits de moitié.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-14-1756637917339",
      "title": "Aveuglé",
      "content": "Toutes les attaques et sorts ont une portée maximum de 3m. Incapable d'esquiver.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'combat': {
  "page": "combat",
  "title": "Combat",
  "sections": [
    {
      "type": "intro",
      "content": "Lorsqu'un combat commence, on compare l'Initiative de tous les participants (héros et monstres), et on détermine alors un ordre de tour. Celui qui a la plus grande initiative commence, puis c'est au tour du second avec la plus grande initiative , etc...\n\n<br><br>Chaque participant joue son tour (déplacement et actions), puis on passe au suivant. Lorsque tous les monstres ou tous les héros sont morts ou hors d'état de se battre, le combat s'arrète."
    },
    {
      "type": "card",
      "id": "combat-new-2-1756401371776",
      "title": "Déplacement",
      "content": "À chaque tour, un héros peut se déplacer de 9 mètres (plus s’il bénéficie de bonus), en plus de ses actions.\n<br><br>Certains terrains, comme la boue ou le sable, sont considérés comme des terrains difficiles : la vitesse y est alors réduite de moitié.\n<br><br>Un héros ou un monstre ne peut pas traverser un adversaire occupant une largeur de 3 mètres. Si plusieurs ennemis se tiennent côte à côte, ils forment un véritable mur infranchissable.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-3-1756401384086",
      "title": "Actions",
      "content": "Chaque tour, un héros dispose d'une <b>action principale</b>, pour effectuer une attaque physique ou un sort.\nElle est perdue si elle n'est pas utilisé pendant son tour. Elle permet également de faire toute action qui nécéssite un test de compétence (ouvrir une porte, casser un rocher...).\n\n<br><br>Il dispose également d'une <b>action secondaire</b>, qui permet de faire un certains nombre de choses :\n<br>- Sauter.\n<br>- Utiliser un objet.\n<br>- Changer d'arme.\n<br>Certains dons ou abilités permettent également d'effectuer d'autres choses en utilisant l'action secondaire.\n\n<br><br> Les héros peuvent effectuer leur déplacement, action principale et secondaire dans l'ordre qui leur plait.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-4-1756401409186",
      "title": "Attaques, sorts, armure",
      "content": "<b>Attaque physique</b>\n\n<ul>\n  <li>Il faut être à bonne portée (1,5 m pour une arme de mêlée, ou selon la portée indiquée sur l’arme).</li>\n  <li>Il faut effectuer un saut pour toucher un monstre volant.</li>\n</ul>\n\n<p>\nEnsuite l’attaquant lance un <b>d20</b> :\n</p>\n\n<ul>\n  <li>Si le résultat est ≤ <b>(1 + Esquive)</b> du défenseur, l’attaque rate.</li>\n  <li>Si le résultat est ≥ <b>(20 - Chance de Critique)</b> de l’attaquant, l’attaque est un <b>coup critique</b> et les dégâts physiques sont doublés.</li>\n</ul>\n\n<p>\nSi des <b>dégâts élémentaires</b> sont rattachés à l’arme (via sort, objet ou autre), ils ne sont critiques que si l’élément de l’attaque est opposé à l’élément d’affiliation de la cible.\n</p>\n\n<p>\nSi l’attaque réussit :\n</p>\n<ul>\n  <li>On soustrait l’armure physique aux dégâts physiques, puis on retire ce total aux points de vie du défenseur.</li>\n  <li>On fait de même avec les dégâts élémentaires en utilisant l’armure élémentaire correspondante.</li>\n</ul>\n\n<hr>\n\n<br><b>Lancer un sort</b>\n\n<ul>\n  <li>Le lanceur doit être à portée de la cible.</li>\n  <li>Le lanceur dépense le mana en fonction du coût du sort. S'il passe en dessous de 0, le sort échoue et le lanceur devient <span class=\"etat-link\" data-etat=\"Endormi/assomé/Effrayé\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Paralysé</span> pendant 2 tours.</li>\n</ul>\n\n<p>\nEnsuite le lanceur lance un <b>d20</b> :\n</p>\n\n<ul>\n  <li>Si le résultat est ≤ 1, le sort échoue.</li>\n  <li>Si le résultat est ≥ <b>(20 - Chance de Critique des sorts)</b> du lanceur, l’effet du sort sera <b>critique</b> (s’il réussit).</li>\n</ul>\n\n<b>Cas « Sans effet si » :</b>\n<br>Chaque sort indique sans sa decription dans quels cas le sort peut échouer.\n<ul>\n  <li>S’il est annulé en cas d’esquive, on vérifie si le résultat du dé est ≤ <b>(1 + Esquive)</b> du défenseur.</li>\n  <li>S’il n’affecte pas certaines créatures en fonction de leur élément d’assignation, le MJ indiquera si le sort est sans effet.</li>\n  <li>S’il s’agit d’un sort d’altération magique, on compare l’<b>Intelligence</b> du lanceur avec la <b>Résistance à l’altération</b> du défenseur : si elle n’est pas strictement supérieure, le sort est sans effet.</li>\n</ul>\n\n<p>\nSi aucun des cas « Sans effet si » ne s’applique, on résout le sort :\n</p>\n\n<ul>\n  <li>Si l’élément du sort est opposé à l’affiliation de la cible, l’effet est <b>forcément critique</b>.</li>\n  <li>Son effet est appliqué (en cas d'effet critique, la description du sort indique les effets).</li>\n  <li>Si le sort inflige des dégâts élémentaires, on soustrait l’armure élémentaire correspondante.</li>\n  <li>Si le sort inflige une altération, on place un dé indiquant le nombre de tours restants.</li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-5-1756401438556",
      "title": "Coup critique et esquive",
      "content": "<hr><br><br><strong>Chance de coup critique (physique) </strong> : Lors d'une attaque physique, le lanceur de l'attaque lance un d20. S'il fait 20, alors les dégats physiques (et seulement physiques) sont doublés.<br> Augmenter les chances de coup critique réduit la valeur du dé nécéssaire pour faire un critique. Par exemple, avec 3 de chance de coup critique, si le dé fait de 17 à 20, l'attaque est critique.\n\n<br><br><hr><br><strong>Chance de coup critique (sorts et consommables)</strong> : Lorsque un héros ou un monstre lance un sort ou utilise un consommable, il lance un d20. S'il fait 20, alors le sort est critique, chaque sort/consommable ayant un effet critique différent (indiqué dans sa description).<br> Augmenter les chances de coup critique des sorts et consommables réduit la valeur du dé nécéssaire pour faire un critique. Par exemple, avec 3 de chance de coup critique, si le dé fait de 17 à 20, le resultat est critique. \n\n<br><br><hr><br><strong>Esquive </strong> : Lors d'une attaque physique, ou d'un sort sans effet si esquive (indiqué dans la fiche du sort), lorsque le lanceur lance son d20, si le resultat est 1, l'attaque est sans effet. Avoir de l'esquive pour la cible de l'attaque augmente la valeur du dé jusqu'a laquelle l'attaque échoue. Par exemple, avec 3 d'esquive, si le dé fait 4 ou moins, l'attaque échoue. La valeur d'esquive ne peut jamais dépasser 9, quel que soit l'equipement ou bonus d'un joueur ou monstre.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-6-1756401461053",
      "title": "Mort",
      "content": "<p>\nLorsque les <b>points de vie</b> d’un héros passent sous la barre des 0, il devient <b>inconscient</b> jusqu’à la fin du combat. \nAprès le combat, si un allié le soigne (via objet ou sort), il redevient capable d’agir. \nCependant, il gagne <b>un trauma</b>, représentant un handicap définitif en fonction de ce qui l’a abattu. \nAu bout du <b>troisième trauma</b>, le héros <b>meurt définitivement</b>.\n</p>\n\n<p>\nLe joueur devra alors créer un nouveau personnage.  \nIl se murmure que certaines <b>magies très puissantes</b> sont capables de ressusciter un héros mort, à condition qu’elles soient pratiquées rapidement après le décès.\n</p>\n\n<p>\n<b>Exemples de traumas</b>\n</p>\n<ul>\n  <li><b>Cicatrice profonde</b> : –1 en compétence Éloquence.</li>\n  <li><b>Amnésie partielle</b> : Oubli d’un sort, d’une langue ou d’une compétence.</li>\n  <li><b>Claudication</b> : Vitesse de déplacement réduite de 3 m.</li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-7-1756407955417",
      "title": "Incantation sur plusieurs tours",
      "content": "Certains sorts ont un effet qui dure plusieurs tours.\n<br> Dans ce cas, le dé qui determine si l'effet est critique doit être relancé à chaque tour (l'effet \"critique\" d'un sort ne dure qu'un seul tour).<br>  <br>\n\n<hr>\n\n<br>Certains sorts puissants nécéssitent plusieurs tours d'incantation.\n\n<br><br>Aprés avoir commencé une incantation, aucun déplacement/action n'est possible. Les effets du sort sont effectués au dernier tour de l'incantation, tour où la créature pourra de nouveau effectuer des actions/déplacement.\n<br> Les dégâts subis n’interrompent pas l’incantation, sauf en cas de mort ou d’effet empechant d'effectuer des actions (exemple : <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span>).\n<br><hr>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-8-1756926911533",
      "title": "Combat - Hors combat",
      "content": "<p><b>Hors combat</b></p>\n<p>Par défaut, les héros sont hors combat. Ils agissent librement : discuter, se déplacer, manger des rations, changer d’équipement, etc.</p>\n\n<p><b>Déclenchement d’un combat</b></p>\n<p>Quand un affrontement commence, on passe en mode <b>tour par tour</b>. Certaines actions deviennent alors interdites :</p>\n<ul>\n  <li>Changer d’équipement (armures, accessoires).</li>\n  <li>Utiliser des objets <i>non consommables</i> comme de la nourriture.</li>\n  <li>Effectuer des actions longues (à l’appréciation du MJ).</li>\n</ul>\n<p>Le mode tour par tour s’arrête lorsque le dernier adversaire est neutralisé.</p>\n\n<p><b>Après-combat (10 minutes)</b></p>\n<p>À la fin d’un combat, les héros restent sous tension pendant <b>10 minutes</b> : ils ne sont pas encore considérés comme hors combat.</p>\n<ul>\n  <li>Ils ne regagnent pas encore leur mana.</li>\n  <li>Manger, dormir ou entreprendre des activités longues reste impossible.</li>\n  <li>Les effets « en combat » s’estompent selon leur durée.</li>\n  <li>Les héros peuvent parler librement, utiliser leur mana restant et faire toute autre activité rapide.</li>\n</ul>\n\n<p><b>Retour hors combat</b></p>\n<p>Une fois ces 10 minutes écoulées, les héros redeviennent hors combat : ils <b>récupèrent tout leur mana</b>, peuvent manger et dormir. Les <b>sorts/effets réservés au combat</b> deviennent alors indisponibles (notamment certains sorts de soins).</p>\n\n<p><b>Note sur les soins</b></p>\n<p>La plupart des blessures se soignent plus difficilement une fois l’adrénaline retombée : de nombreux effets de soin ne sont donc plus utilisables hors combat.</p>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'gestion-des-ressources': {
  "page": "gestion-des-ressources",
  "title": "Gestion des ressources",
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-2-1756401478745",
      "title": "Inventaire",
      "content": "<p>Chaque héros dispose de <b>quatre inventaires</b> :</p>\n\n<ul>\n  <li>\n    <b>Équipement</b> : Toujours porté et actif, il est constitué d’une arme, d’une armure, \n    d’un éventuel bouclier et de <b>3 accessoires</b>.\n  </li>\n  <li>\n    <b>Sac de consommables</b> : Peut contenir jusqu’à <b>10 consommables</b>. Même si un héro possède plusieur fois le même consommable, ils prendront chacun une place.\n  </li>\n  <li>\n    <b>Sac général</b> : Dispose d’une capacité maximale de <b>10 points de poids</b>. \n    Chaque objet entreposé y possède une valeur de poids indiquée dans sa description.\n  </li>\n <li>\n    <b>Objets de quête</b> : Aucune limite pour ces objets, utiles pour l'aventure (clés, cartes...).\n  </li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-3-1756401493443",
      "title": "Mana",
      "content": "Il s'agit de la ressource utilisée pour lancer des sorts. Hors combat, il revient automatiquement quand le héros passe hors combat (c'est à dire aprés 10 minutes sans être en combat). En combat, il est consommé aprés le lancement de chaque sort (le coût en mana étant indiqué dans la description de chaque sort). Si un sort devait faire passer le mana d'un héros en dessous de 0, alors le sort n'est pas effectif et le héros devient <span class=\"etat-link\" data-etat=\"Endormi/assomé/Effrayé\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">paralysé</span> pendant 2 tours.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-4-1756401498518",
      "title": "Vie",
      "content": "Les points de vie représentent la vitalité d’un héros ou d’un monstre, la mesure de son endurance face aux blessures. Tant qu’il lui reste des PV, le personnage peut continuer à se battre, à courir et à agir. Quand ses PV tombent à zéro, il s’effondre, mourant. Voir la page <a href=\"#/combat\" style=\"color: var(--accent); text-decoration: underline;\">Combat</a>.\nUn personnage qui effectue un repos régénère un nombre de points de vie égal à sa valeur d’Endurance.<br>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-5-1756401504961",
      "title": "Fortune",
      "content": "Lorsqu’un événement fait appel à la Fortune (par exemple ouvrir un coffre et espérer y trouver un objet rare), le joueur lance un d20 et ajoute sa valeur de Fortune. Plus le total est élevé, meilleur sera le butin obtenu.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-7-1756408519770",
      "title": "Sommeil et repas",
      "content": "Chaque jour, un héros doit manger une ration et dormir au moins 8 heures sous peine d'être dans l'état <span class=\"etat-link\" data-etat=\"Fatigué\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Fatigué</span>.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-7-1756634178476",
      "title": "Experience et niveau",
      "content": "<p>Lorsqu’un groupe trouve et utilise un <b>cristal d’expérience</b>, tous les membres du groupe <b>gagnent</b> des points d’expérience.</p>\n<p>Les <b>cristaux d’expérience</b> provenant d’un même type de monstre sont de moins en moins efficaces, car la magie qu’ils renferment a déjà été assimilée.</p>\n\n\n<p>Lorsqu’un héros atteint <b>10 points d’expérience</b>, il gagne un niveau et son expérience revient à <b>0</b>. Il obtient alors :</p>\n<ul>\n  <li><b>1 point de don</b> (qu’il peut dépenser ou cumuler).</li>\n  <li>Des <b>statistiques fixes</b> (selon la sous-classe).</li>\n  <li><b>2 points de statistiques</b> à répartir.</li>\n  <li>L’<b>accès à de nouveaux sorts</b> (pour les classes qui le peuvent).</li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-8-1756658008017",
      "title": "Equipements",
      "content": "<li>Que l'on porte une arme à une main ou à deux mains, il est uniquement possible d'être équipé d'une seule arme.\n</li><li>Lorsque on porte une arme à deux mains, il est impossible de porter un bouclier.\n</li><li>Il est possible via une action secondaire de changer l'arme active en plein combat, mais pas l'armure ou les accessoires, qui ne peuvent être changés que hors combat.</li>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'histoire': {
  "page": "histoire",
  "title": "Histoire",
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "ere-legendaire",
      "title": "",
      "content": "<b>Foresia, royaume ancien aux mille visages</b><br>\nDans les terres de <b>Foresia</b>, un royaume ancien aux mille visages, la <b>magie</b> imprègne chaque pierre et chaque souffle de vent. \nForêts luminescentes, volcans grondants, temples enfouis et ruines cyclopéennes rappellent que les dieux et les anciens peuples ont marqué cette terre de leur puissance.\n\n<br><br><b>La région de Mabresia</b><br>\nAu cœur de ce royaume s’étend la région de <b>Mabresia</b>, autrefois fertile et paisible, où se dressaient des cités marchandes prospères et des villages agricoles nourris par des rivières cristallines.\n\n<br><br><b>La malédiction des cristaux</b><br>\nMais depuis quelques décennies, un mal mystérieux s’est abattu sur la contrée. \nDes <b>cristaux magiques</b> surgis des profondeurs de la terre altèrent la nature et les êtres vivants : animaux, monstres, et même parfois les races intelligentes. \nCes cristaux provoquent des <b>mutations</b> et une <b>soif de violence</b> incontrôlable.\n\n<br><br><b>Peuples et tensions</b><br>\nLes habitants de Foresia — <b>humains</b>, <b>elfes</b>, <b>nains</b>, mais aussi des créatures plus sombres comme <b>démons</b> et <b>morts-vivants</b> — vivent désormais dans une tension permanente, oscillant entre alliances fragiles et guerres ouvertes. \nChacun cherche à <b>exploiter</b> ou <b>détruire</b> ces cristaux, selon ses croyances et ambitions.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "chronologie",
      "title": "📅 Chronologie",
      "content": "<b>Il y a 300 ans</b> – L’Empire des Anciens, peuple oublié, érige d’immenses temples et scelle dans leurs fondations des secrets de magie que nul ne comprendra jamais entièrement.<br><br>\n\n<b>Il y a 200 ans</b> – Chute de l’Empire : guerres entre dieux mineurs et rois mortels. Les temples sont abandonnés, et les ruines se couvrent de végétation.<br><br>\n\n<b>Il y a 80 ans</b> – Premiers récits d’étranges cristaux luminescents découverts dans les montagnes de Mabresia. Au début considérés comme bénédictions, certains se révèlent instables.<br><br>\n\n<b>Il y a 50 ans</b> – Des bêtes sauvages commencent à muter et deviennent plus féroces. Les premiers villages sont détruits par des créatures altérées.<br><br>\n\n<b>Il y a 30 ans</b> – Les cristaux se répandent : on les retrouve dans les forêts, les marécages et même les ruines anciennes. De plus en plus de créatures sont transformées.<br><br>\n\n<b>Il y a 20 ans</b> – Les premières guerres éclatent entre royaumes frontaliers : certains veulent s’emparer des cristaux comme armes, d’autres cherchent à les détruire.<br><br>\n\n<b>Aujourd’hui</b> – La région de Mabresia est devenue une terre sauvage, où nul n’est à l’abri : les routes sont envahies de créatures mutées, les villages se fortifient, et des aventuriers de tous horizons s’y aventurent à la recherche de gloire, de savoir… ou de pouvoir.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'dieux': {
  "page": "dieux",
  "title": "Dieux",
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "dieux-new-2-1756899335313",
      "title": "Dieu des Humains – Aedor, le Forgeron-Soleil",
      "content": "Symbole : un marteau auréolé d’un disque solaire.<br>\nDomaine : courage, guerre juste, travail artisanal.<br>\nCroyances : les humains voient en lui celui qui éclaire leur chemin et leur donne la force de bâtir des cités.<br>\nParticularité : ses prêtres prônent la discipline et la reconstruction, mais certains royaumes l’utilisent aussi pour justifier leurs conquêtes.<br><br>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "dieux-para-3-1756899336921",
      "title": "Dieu des Nains – Durnak, le Cœur-de-Pierre",
      "content": "Symbole : une enclume fissurée d’où s’écoule une lueur rouge.<br>\nDomaine : terre, montagne, persévérance, serments.<br>\nCroyances : gardien des mines et des profondeurs, il protège les clans nains et punit sévèrement ceux qui trahissent leur parole.<br>\nParticularité : les nains affirment que ses battements résonnent dans les montagnes, guidant les mineurs vers les métaux rares.<br><br>",
      "deletable": true,
      "sectionName": "Nouveau paragraphe"
    },
    {
      "type": "card",
      "id": "dieux-new-4-1756899338873",
      "title": "Déesse des Elfes – Liryel, la Dame des Brumes",
      "content": "Symbole : une feuille argentée flottant sur l’eau.<br>\nDomaine : forêts, magie ancienne, mémoire.<br>\nCroyances : les elfes la vénèrent comme gardienne du cycle de la vie et de la magie pure.<br>\nParticularité : ses temples sont souvent des clairières protégées par des enchantements, où les brumes recouvrent les intrus.<br><br>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "dieux-new-5-1756899431837",
      "title": "Dieu des Fées et des Lutins – Myrin, l’Éclat-Changeant",
      "content": "Symbole : une luciole ou une étoile facétieuse à cinq branches.<br>\nDomaine : illusions, rêves, joie, malice.<br>\nCroyances : les fées et lutins croient qu’il danse entre les mondes, semant à la fois la protection et la farce.<br>\nParticularité : ses fidèles accordent beaucoup d’importance aux fêtes, à la musique et aux pactes imprévisibles.<br><br>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'geographie': {
  "page": "geographie",
  "title": "Geographie",
  "sections": [
    {
      "type": "intro",
      "content": "Voici la carte de la région de Mabresia, dans le Royaume de Foresia"
    }
  ]
},
      'campagne': {
  "id": "campagne",
  "title": "Campagne",
  "icon": "📖",
  "sections": [
    {
      "type": "intro",
      "content": "<strong>🎭 Espace Campagne</strong><br>Créez et gérez vos campagnes avec leurs sous-pages personnalisées. Cette section est uniquement visible en mode Maître de Jeu."
    },
    {
      "type": "campaign-manager",
      "content": {
        "title": "Gestionnaire de Campagnes",
        "campaigns": {}
      }
    }
  ],
  "subPages": {
    "Classique": {
      "name": "Classique",
      "description": "",
      "subPages": {
        "Long terme": {
          "title": "Long terme",
          "content": "<b> Le Dieu Maléfique</b>\n\n<br><br>Nerhaz, le Sépulcral (Symbole : un cristal noir fendu, entouré de chaînes)\n\n\n<br><br> Histoire : banni par l’Empire des Anciens, il fut scellé dans leurs temples. Mais les cristaux magiques, instables, ont servi de réceptacles à ses murmures.\n\n<br><br>Particularité : Nerhaz attire les ambitieux et les désespérés, promettant pouvoir en échange de sacrifices. Son retour progressif est lié à l’altération des créatures par les cristaux."
        },
        "Auberge": {
          "title": "Auberge",
          "content": "<hr>\nAvant de partir la femme de l'aubergiste qui a entendu les héros, leur propose de piocher dans le sac a provision, mais leur demande de n'en prendre que un par personne maximum. Table de loot <i>ProvisionAuberge</i> <a href=\"#/tables-tresors\" style=\"color: var(--accent); text-decoration: underline;\">Tables de trésors</a>."
        },
        "Forêt": {
          "title": "Forêt",
          "content": "combat <span class=\"monster-link\" data-monster=\"Groink\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Groink</span>  <span class=\"monster-link\" data-monster=\"Groinka\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Groinka</span>\n<hr>\npierre a pousser pour reveler TP\nchemins différents avec un qui mene a pierre qui revele la puissance de chacun\n<hr>\nautre chemins avec platforme/pieges/ passage secret\nCombat groinks énervés + porte en metal\n<hr>\nport avec bateau pas dispo\nCombat <span class=\"monster-link\" data-monster=\"Crabe des Bois\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Crabe des Bois</span>   <span class=\"monster-link\" data-monster=\"Pouple de la forêt\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Pouple de la forêt</span>\n<hr>\n\nnuit attaque de  <span class=\"monster-link\" data-monster=\"Araignée Géante\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Araignée Géante</span>\n<hr>\nriviere avec tronc , pont qui casse...\ncombat  <span class=\"monster-link\" data-monster=\"Serpent de la forêt\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Serpent de la forêt</span>  <span class=\"monster-link\" data-monster=\"Scarabée géant\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Scarabée géant</span>  \n<hr>\nmaison bucheron avec jeu du tonneau, portes fermés mais loot bucheron \n<span class=\"monster-link\" data-monster=\"Ours des Bois\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Ours des Bois</span>   + <span class=\"monster-link\" data-monster=\"Guêpe Géante\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Guêpe Géante</span>\n<hr>\nDialogue bucheron\ncombat  <span class=\"monster-link\" data-monster=\"Boss Forêt\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Boss Forêt</span>\n<hr>\nretourner camp bucheron, reveler tablette\nTP"
        }
      }
    }
  },
  "meta": {
    "requiresMJ": true,
    "allowSubPages": true,
    "lastModified": "2025-01-01T00:00:00.000Z"
  }
}
    };
    
    // Static pages configuration
    window.STATIC_PAGES_CONFIG = {
  "pages": [
    {
      "id": "favoris",
      "title": "Favoris",
      "file": "favoris.json",
      "active": true,
      "order": 0
    },
    {
      "id": "creation",
      "title": "Création d'un personnage",
      "file": "creation.json",
      "active": true,
      "order": 1
    },
    {
      "id": "elements",
      "title": "Elements",
      "file": "elements.json",
      "active": true,
      "order": 2
    },
    {
      "id": "stats",
      "title": "Statistiques",
      "file": "stats.json",
      "active": true,
      "order": 3
    },
    {
      "id": "competences-tests",
      "title": "Compétences & Tests",
      "file": "competences-tests.json",
      "active": true,
      "order": 4
    },
    {
      "id": "etats",
      "title": "Etats",
      "file": "etats.json",
      "active": true,
      "order": 5
    },
    {
      "id": "histoire",
      "title": "Histoire",
      "file": "histoire.json",
      "active": true,
      "order": 6
    },
    {
      "id": "combat",
      "title": "Combat",
      "file": "combat.json",
      "active": true,
      "order": 7
    },
    {
      "id": "gestion-des-ressources",
      "title": "Gestion des ressources",
      "file": "gestion-des-ressources.json",
      "active": true,
      "order": 8
    },
    {
      "id": "dieux",
      "title": "Dieux",
      "file": "dieux.json",
      "active": true,
      "order": 9
    },
    {
      "id": "geographie",
      "title": "Geographie",
      "file": "geographie.json",
      "active": true,
      "order": 10
    },
    {
      "id": "audio",
      "title": "Musiques d'ambiance",
      "file": "audio.json",
      "active": true,
      "order": 11
    },
    {
      "id": "traumas",
      "title": "Traumas",
      "file": "traumas.json",
      "active": true,
      "order": 12
    },
    {
      "id": "campagne",
      "title": "Campagne",
      "file": "campagne.json",
      "active": true,
      "order": 13,
      "requiresMJ": true
    }
  ],
  "template": {
    "page": "new-page",
    "title": "Nouvelle page",
    "static": true,
    "sections": [
      {
        "type": "intro",
        "content": "Contenu de la nouvelle page."
      }
    ]
  }
};
    
    // Mark as standalone version for renderer
    window.STANDALONE_VERSION = true;
    
    // Initialize app when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      // Ensure dev mode is off
      document.body.className = 'dev-off';
      
      // Initialize in standalone mode with embedded data
      
      // Wait a bit to ensure all modules are loaded
      setTimeout(function() {
        // Initialize JdrApp if it exists
        if (window.JdrApp && window.JdrApp.init) {
          window.JdrApp.init();
        } else {
          console.error('JdrApp not found!', window.JdrApp);
        }
      }, 100);
    });
  
// ============================================================================
// JDR-BAB APPLICATION - CORE MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // MAIN APPLICATION NAMESPACE
  // ========================================
  window.JdrApp = {
    // Core data
    data: {
      SORTS: null,
      CLASSES: null,
      DONS: null,
      OBJETS: null,
      MONSTRES: null,
      STATIC_PAGES: {},
      editedData: {},
      customPageDescriptions: {
        'collections-objets': 'Recherchez et explorez des collections d\'objets organisées par thème'
      }
    },
    
    // Application state
    state: {
      isMJ: false // Boolean pour contrôler l'accès MJ
    },
    
    // Core modules
    modules: {
      router: {},
      renderer: {},
      editor: {},
      storage: {},
      images: {}
    },
    
    // Utilities
    utils: {
      dom: {},
      events: {},
      data: {}
    },

    // Initialization
    async init() {
      try {
        this.updateLoadingProgress(10);
        await this.loadData();
        
        this.updateLoadingProgress(40);
        await this.loadContent();
        
        this.updateLoadingProgress(70);
        this.initializeModules();
        
        this.updateLoadingProgress(90);
        
        // Execute data validation after all modules are loaded
        setTimeout(() => {
          this.validateDataIntegrity();
          this.updateLoadingProgress(100);
          this.hideLoadingScreen();
        }, 500);
        
        // Auto-enable MJ mode with additional delay to ensure router is ready
        setTimeout(() => {
          this.autoEnableMJModeInDevelopment();
        }, 800);
      } catch (error) {
        this.hideLoadingScreen();
        // Silent error handling for initialization
      }
    },

    // Update loading progress
    updateLoadingProgress(percentage) {
      const progressBar = document.querySelector('.loading-bar');
      if (progressBar) {
        progressBar.style.width = `${percentage}%`;
      }
    },

    // Hide loading screen with animation
    hideLoadingScreen() {
      const loadingScreen = document.getElementById('app-loading');
      if (loadingScreen) {
        loadingScreen.classList.add('fade-out');
        setTimeout(() => {
          if (loadingScreen.parentNode) {
            loadingScreen.parentNode.removeChild(loadingScreen);
          }
        }, 500);
      }
    },

    async loadData() {
      try {
        // Check if we're in standalone mode (data already injected)
        if (window.SORTS && window.CLASSES && window.DONS && window.OBJETS && window.STATIC_PAGES) {
          const sorts = window.SORTS;
          const classes = window.CLASSES;
          const dons = window.DONS;
          const objets = window.OBJETS;
          let monstres = window.MONSTRES || [];
          let tablesTresors = window.TABLES_TRESORS || { tables: [] };
          let collections = window.COLLECTIONS || { collections: [] };
          
          // Safety check - if MONSTRES is not an array, it might be page config
          if (!Array.isArray(monstres)) {
            this.clearCorruptedMonsterData();
            monstres = [];
          }
          
          const staticPagesData = window.STATIC_PAGES;
          const staticPagesConfig = window.STATIC_PAGES_CONFIG || {};
          
          // Ensure custom page descriptions are available in standalone mode
          // In standalone mode, CUSTOM_PAGE_DESCRIPTIONS might be injected, sync with JdrApp.data
          if (window.CUSTOM_PAGE_DESCRIPTIONS) {
            this.data.customPageDescriptions = { ...this.data.customPageDescriptions, ...window.CUSTOM_PAGE_DESCRIPTIONS };
          } else {
            window.CUSTOM_PAGE_DESCRIPTIONS = { ...this.data.customPageDescriptions };
          }
          
          this.data.SORTS = sorts;
          this.data.CLASSES = classes;
          this.data.DONS = dons;
          this.data.OBJETS = objets;
          this.data.MONSTRES = monstres;
          this.data.TABLES_TRESORS = tablesTresors;
          this.data.COLLECTIONS = collections;
          this.data.STATIC_PAGES = staticPagesData;
          this.data.STATIC_PAGES_CONFIG = staticPagesConfig;
          
          window.SORTS = sorts;
          window.CLASSES = classes;
          window.DONS = dons;
          window.OBJETS = objets;
          window.MONSTRES = monstres;
          window.TABLES_TRESORS = tablesTresors;
          window.COLLECTIONS = collections;
          window.STATIC_PAGES = staticPagesData;
          window.STATIC_PAGES_CONFIG = staticPagesConfig;
          
          // Load stored edits AFTER setting up the data structure
          this.loadStoredEditsEarly();
          
          // Initialize default filters for objects
          this.initializeDefaultFilters();
          return;
        }
        
        // Development mode - fetch files
        const [sorts, classes, dons, objets, monstres, tablesTresors, collections, staticPagesConfig, tocStructure, audioConfig] = await Promise.all([
          fetch('data/sorts.json').then(r => r.json()),
          fetch('data/classes.json').then(r => r.json()),
          fetch('data/dons.json').then(r => r.json()),
          fetch('data/objets.json').then(r => r.json()),
          fetch('data/monstres.json').then(r => r.json()),
          fetch('data/tables-tresors.json').then(r => r.json()),
          fetch('data/collections.json').then(r => r.json()),
          fetch('data/static-pages-config.json').then(r => r.json()),
          fetch('data/toc-structure.json').then(r => r.json()),
          fetch('data/audio-config.json').then(r => r.json()).catch(() => null)
        ]);

        // Load page descriptions (optional, with fallbacks)
        try {
          window.MONSTRES_PAGE_DESC = await fetch('data/monstres-page-desc.json').then(r => r.json());
        } catch (error) {
          // Fallback if file doesn't exist
          window.MONSTRES_PAGE_DESC = {
            description: "Créatures, ennemis et adversaires que peuvent affronter les héros dans leurs aventures."
          };
        }

        try {
          window.TABLES_TRESORS_PAGE_DESC = await fetch('data/tables-tresors-page-desc.json').then(r => r.json());
        } catch (error) {
          // Fallback if file doesn't exist
          window.TABLES_TRESORS_PAGE_DESC = {
            description: "Tables de butin permettant de générer aléatoirement des récompenses selon les fourchettes définies. Lancez un dé 20 et consultez la table correspondante pour déterminer l'objet obtenu."
          };
        }

        // Load custom page descriptions (collections, etc.)
        try {
          const customDescriptions = await fetch('data/custom-page-descriptions.json').then(r => r.json());
          this.data.customPageDescriptions = { ...this.data.customPageDescriptions, ...customDescriptions };
          // Make it available globally for ContentFactory (keep in sync)
          window.CUSTOM_PAGE_DESCRIPTIONS = { ...this.data.customPageDescriptions };
        } catch (error) {
          // Keep default values if file doesn't exist
          window.CUSTOM_PAGE_DESCRIPTIONS = { ...this.data.customPageDescriptions };
        }

        const staticPagesData = {};
        const activePages = staticPagesConfig.pages.filter(page => page.active);
        
        for (const pageConfig of activePages) {
          try {
            const pageData = await fetch(`data/${pageConfig.file}`).then(r => r.json());
            staticPagesData[pageConfig.id] = pageData;
          } catch (error) {
            // Silent handling for missing static pages
          }
        }

        this.data.SORTS = sorts;
        this.data.CLASSES = classes;
        this.data.DONS = dons;
        this.data.OBJETS = objets;
        this.data.MONSTRES = monstres;
        this.data.TABLES_TRESORS = tablesTresors;
        this.data.COLLECTIONS = collections;
        this.data.STATIC_PAGES = staticPagesData;
        this.data.STATIC_PAGES_CONFIG = staticPagesConfig;
        this.data.AUDIO_CONFIG = audioConfig;
        this.data.TOC_STRUCTURE = tocStructure;

        window.SORTS = sorts;
        window.CLASSES = classes;
        window.DONS = dons;
        window.OBJETS = objets;
        window.MONSTRES = monstres;
        window.TABLES_TRESORS = tablesTresors;
        window.COLLECTIONS = collections;
        window.STATIC_PAGES = this.data.STATIC_PAGES;
        window.STATIC_PAGES_CONFIG = this.data.STATIC_PAGES_CONFIG;
        window.TOC_STRUCTURE = this.data.TOC_STRUCTURE;
        window.AUDIO_CONFIG = audioConfig;
        
        // Load stored edits in development mode (after data is loaded)
        this.loadStoredEditsEarly();
        
        // Initialize default filters for objects
        this.initializeDefaultFilters();
      } catch (error) {
        throw error;
      }
    },

    async loadContent() {
      try {
        // Check if we're in standalone mode (already has HTML structure)
        const viewsDiv = document.getElementById('views');
        const loadingDiv = document.getElementById('app-loading');
        
        if (viewsDiv) {
          // Standalone mode - HTML structure already exists
          if (loadingDiv) {
            loadingDiv.innerHTML = '<!-- Content will be generated by renderer -->';
          }
        } else if (loadingDiv) {
          // Development mode - need to inject HTML structure
          const contentHTML = await this.getContentHTML();
          loadingDiv.outerHTML = contentHTML;
        }
      } catch (error) {
        throw error;
      }
    },

    async getContentHTML() {
      // This would ideally load from a separate HTML file
      // For now, we'll return the content structure
      return `
        <div class="shell">
          <button aria-controls="sidebar" aria-expanded="false" aria-label="Ouvrir le sommaire" class="menu-toggle" id="menuToggle" style="display:none">☰ Sommaire</button>
          <div class="backdrop" hidden="" id="backdrop"></div>
          <main class="page">
            <aside class="sidebar" id="sidebar">
              <div class="panel">
                <div class="tools">
                  <button class="btn small" id="devToggle" title="Activer/désactiver le mode développeur">🛠 Dev Mode: OFF</button>
                </div>
                <div class="dev-toolbox" id="devToolbox" style="display: none;">
                  <!-- Dev toolbox content will be injected here -->
                </div>
                <div class="toc" id="toc">
                  <div class="toc-search">
                    <input autocomplete="off" id="search" placeholder="Rechercher une règle, une classe…">
                    <button class="btn-clear" id="clear" title="Effacer">✖</button>
                  </div>
                  <!-- Table of contents will be injected here -->
                </div>
              </div>
            </aside>
            <div id="views">
              <!-- Dynamic content will be injected here -->
            </div>
          </main>
          <footer></footer>
        </div>
      `;
    },

    // Load stored edits early in the loading process (before rendering)
    loadStoredEditsEarly() {
      // Ne plus charger automatiquement le localStorage
      // Laisser les JSON files être la source de vérité
    },

    initializeModules() {
      if (this.utils.events && this.utils.events.init) this.utils.events.init();
      if (this.utils.dom && this.utils.dom.init) this.utils.dom.init();
      if (this.modules.images && this.modules.images.init) this.modules.images.init();
      if (this.modules.audio && this.modules.audio.init) this.modules.audio.init();
      if (this.modules.renderer && this.modules.renderer.init) this.modules.renderer.init();
      if (this.modules.router && this.modules.router.init) this.modules.router.init();
      if (this.modules.editor && this.modules.editor.init) this.modules.editor.init();
      if (this.modules.storage && this.modules.storage.init) this.modules.storage.init();
      if (this.modules.ui && this.modules.ui.init) this.modules.ui.init();
      
      // Initialize performance optimizations after all modules are loaded
      if (window.ScrollOptimizer && window.ScrollOptimizer.init) {
        window.ScrollOptimizer.init();
      }
      
      // Re-enable filter event handlers with fixed implementation
      this.initializeFilterEventHandlers();
    },

    initializeFilterEventHandlers() {
      // Store reference to this for use in event handlers
      const self = this;
      
      // Use event delegation for ALL filter chips (both regular and GM)
      document.addEventListener('click', (e) => {
        
        // Handle regular filter chips (monstres, tables, etc.)
        if (e.target.classList.contains('filter-chip')) {
          e.preventDefault();
          e.stopPropagation();
          
          const tag = e.target.dataset.tag;
          if (!tag) return;
          
          // Determine which page we're on based on current route
          const currentPage = window.location.hash.replace('#/', '') || 'creation';
          
          if (currentPage === 'monstres') {
            this.handleMonsterFilter(tag);
          } else if (currentPage === 'tables-tresors') {
            this.handleTableTresorFilter(tag);
          } else {
            console.log('Filter not supported on this page:', currentPage);
          }
          
          return;
        }
        
        // Handle GM filter chips (objets page GM)
        if (e.target.classList.contains('gm-filter-chip')) {
          e.preventDefault();
          e.stopPropagation();
          
          const tag = e.target.dataset.tag;
          if (!tag) return;
          
          // Only proceed if we're actually on the GM objects page
          const currentPage = window.location.hash.replace('#/', '') || 'creation';
          if (currentPage !== 'gestion-objets') {
            console.log('GM filter clicked but not on gestion-objets page, ignoring');
            return;
          }
          
          // Initialize GM tags if needed
          if (!window.ACTIVE_GM_OBJECT_TAGS) {
            window.ACTIVE_GM_OBJECT_TAGS = [];
          }
          
          // Toggle the tag
          const index = window.ACTIVE_GM_OBJECT_TAGS.indexOf(tag);
          if (index > -1) {
            // Remove tag
            window.ACTIVE_GM_OBJECT_TAGS.splice(index, 1);
          } else {
            // Add tag
            window.ACTIVE_GM_OBJECT_TAGS.push(tag);
          }
          
          // For GM filters, reload the page via router
          try {
            if (window.JdrApp && window.JdrApp.modules && window.JdrApp.modules.router) {
              window.JdrApp.modules.router.renderGMObjectsPage();
            }
          } catch (error) {
            console.error('Error reloading GM objects page:', error);
          }
        }
      });
    },

    handleMonsterFilter(tag) {
      // Initialize filter state if needed
      if (!window.MONSTRES_FILTER_STATE) {
        const config = window.ContentTypes?.monster?.filterConfig;
        window.MONSTRES_FILTER_STATE = {
          visibleTags: config?.defaultVisibleTags || ['Forêt']
        };
      }
      
      const state = window.MONSTRES_FILTER_STATE;
      const index = state.visibleTags.indexOf(tag);
      
      if (index > -1) {
        // Remove tag
        state.visibleTags.splice(index, 1);
      } else {
        // Add tag
        state.visibleTags.push(tag);
      }
      
      // Reload monsters page to apply filter
      try {
        if (window.JdrApp && window.JdrApp.modules && window.JdrApp.modules.router) {
          window.JdrApp.modules.router.renderMonstersPage();
        }
      } catch (error) {
        console.error('Error reloading monsters page:', error);
      }
    },

    handleTableTresorFilter(tag) {
      // Initialize filter state if needed
      if (!window.TABLES_TRESORS_FILTER_STATE) {
        const config = window.ContentTypes?.tableTresor?.filterConfig;
        window.TABLES_TRESORS_FILTER_STATE = {
          visibleTags: config?.defaultVisibleTags || ['Commun']
        };
      }
      
      const state = window.TABLES_TRESORS_FILTER_STATE;
      const index = state.visibleTags.indexOf(tag);
      
      if (index > -1) {
        // Remove tag
        state.visibleTags.splice(index, 1);
      } else {
        // Add tag
        state.visibleTags.push(tag);
      }
      
      // Reload tables page to apply filter
      try {
        if (window.JdrApp && window.JdrApp.modules && window.JdrApp.modules.router) {
          window.JdrApp.modules.router.renderTablesTresorsPage();
        }
      } catch (error) {
        console.error('Error reloading tables page:', error);
      }
    },

    updateGMObjectsDisplay() {
      console.log('Updating GM objects display...');
      
      if (!window.OBJETS || !window.ACTIVE_GM_OBJECT_TAGS) {
        console.error('Missing dependencies for GM display update');
        return;
      }
      
      // Only proceed if we're actually on the GM objects page
      const gmArticle = document.querySelector('article[data-page="gestion-objets"]');
      if (!gmArticle) {
        console.log('Not on GM objects page, skipping update');
        return;
      }
      
      try {
        const allObjects = window.OBJETS.objets || [];
        const activeTags = window.ACTIVE_GM_OBJECT_TAGS;
        
        console.log('Applying filters:', activeTags);
        
        // Filter objects based on active tags
        const filteredObjects = activeTags.length === 0 
          ? allObjects
          : allObjects.filter(obj => {
              if (!obj.tags || obj.tags.length === 0) return false;
              return activeTags.every(activeTag => obj.tags.includes(activeTag));
            });
        
        console.log(`Showing ${filteredObjects.length}/${allObjects.length} objects`);
        
        // Update ONLY the objects container
        const objectsContainer = document.getElementById('gestion-objets-container');
        if (objectsContainer && CardBuilder) {
          objectsContainer.innerHTML = filteredObjects.map((item, index) => 
            CardBuilder.create('objet', item, 'objets', index).build()
          ).join('');
          
          console.log('Objects container updated successfully');
        } else {
          console.error('Objects container or CardBuilder not found');
        }
        
        // Update ONLY the filter chips visual state
        const filterChips = document.querySelectorAll('.gm-filter-chip');
        filterChips.forEach(chip => {
          const tag = chip.dataset.tag;
          const isActive = activeTags.includes(tag);
          
          if (isActive) {
            chip.style.background = '#16a34a';
            chip.style.opacity = '1';
            chip.textContent = `✓ ${tag}`;
            chip.classList.add('active');
            chip.classList.remove('inactive');
          } else {
            chip.style.background = '#6b7280';
            chip.style.opacity = '0.6';
            chip.textContent = tag;
            chip.classList.add('inactive');
            chip.classList.remove('active');
          }
        });
        
        console.log('Filter chips updated successfully');
        
        // Auto-load images if available
        if (this.modules.renderer && this.modules.renderer.autoLoadImages) {
          this.modules.renderer.autoLoadImages();
        }
        
      } catch (error) {
        console.error('Error updating GM objects display:', error);
      }
    },

    // Force reload JSON data (clear localStorage cache)
    forceReloadData() {
      // Effacer seulement les éditions temporaires
      localStorage.removeItem('jdr-bab-edits');
      localStorage.removeItem('jdr-bab-last-modified');
      window.location.reload();
    },

    // Clear corrupted localStorage data specifically for monsters
    clearCorruptedMonsterData() {
      const edits = JSON.parse(localStorage.getItem('jdr-bab-edits') || '{}');
      
      // Remove any MONSTRES data that might be corrupted
      if (edits.MONSTRES) {
        delete edits.MONSTRES;
        localStorage.setItem('jdr-bab-edits', JSON.stringify(edits));
      }
      
      // Also clear any other monster-related storage
      if (edits.monster) {
        delete edits.monster;
        localStorage.setItem('jdr-bab-edits', JSON.stringify(edits));
      }
    },

    // Public method to manually clear storage via console
    clearMonsterStorage() {
      this.clearCorruptedMonsterData();
      this.forceReloadData();
    },

    // Initialize default filters for objects on page load
    initializeDefaultFilters() {
      try {
        // Only initialize if OBJETS exists and ContentTypes is available
        if (window.OBJETS && window.ContentTypes?.objet?.filterConfig) {
          const defaultTags = window.ContentTypes.objet.filterConfig.defaultVisibleTags || [];
          
          // Initialize filterSettings only if it doesn't exist or is empty
          if (!window.OBJETS.filterSettings || !window.OBJETS.filterSettings.visibleTags) {
            window.OBJETS.filterSettings = {
              visibleTags: [...defaultTags], // Active filters (defaults only)
              displayedFilterButtons: [...defaultTags] // Displayed filter buttons (defaults initially)
            };
          }
          
          // Ensure displayedFilterButtons exists even if visibleTags already existed
          if (!window.OBJETS.filterSettings.displayedFilterButtons) {
            window.OBJETS.filterSettings.displayedFilterButtons = [...defaultTags];
          }
          
        }
      } catch (error) {
        // Silent error handling for filter initialization
      }
    },

    // Validate data integrity on application startup
    validateDataIntegrity() {
      try {
        // Validate monster data if available
        if (window.MONSTRES && Array.isArray(window.MONSTRES) && JdrApp.modules.images) {
          // Force sync monster images and paths
          JdrApp.modules.images.forceSyncMonsterImages();
        }
        
        // Validate UnifiedEditor if available
        if (JdrApp.modules.editor && JdrApp.modules.editor.validateAndRepairMonsterData) {
          JdrApp.modules.editor.validateAndRepairMonsterData();
        }
        
      } catch (error) {
        // Silent error handling for data validation
      }
    },

    autoEnableMJModeInDevelopment() {
      try {
        // Better detection: Check if we're in standalone mode
        // Standalone mode sets window.STANDALONE_VERSION = true in the build
        const isStandalone = window.STANDALONE_VERSION === true;
        
        
        if (!isStandalone) {
          
          // Enable MJ mode (not dev mode!) automatically in development
          if (!this.state.isMJ) {
            this.state.isMJ = true;
            
            // Update MJ button visual if available and regenerate TOC
            if (JdrApp.modules.router && JdrApp.modules.router.updateMJButtonVisual) {
              JdrApp.modules.router.updateMJButtonVisual();
              JdrApp.modules.router.generateTOC();
              
              // Refresh current page if it's tables-tresors to show edit buttons
              const currentHash = window.location.hash;
              if (currentHash === '#/tables-tresors') {
                setTimeout(() => {
                  if (JdrApp.modules.router && JdrApp.modules.router.renderTablesTresorsPage) {
                    JdrApp.modules.router.renderTablesTresorsPage();
                  }
                }, 200);
              }
              
            } else {
              // Router not ready yet, retry
              setTimeout(() => this.autoEnableMJModeInDevelopment(), 1000);
              return;
            }
            
          }
        }
      } catch (error) {
        // Retry once more after error
        setTimeout(() => this.autoEnableMJModeInDevelopment(), 2000);
      }
    }
  };

  // Auto-initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => window.JdrApp.init());
  } else {
    window.JdrApp.init();
  }

})();
// ============================================================================
// JDR-BAB APPLICATION - CONSTANTS
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // UI CONSTANTS
  // ========================================
  window.UI_CONSTANTS = {
    // Layout dimensions
    SIDEBAR_WIDTH: 350,
    SIDEBAR_WIDTH_TABLET: 320,
    
    // Image processing defaults
    IMAGE_MAX_WIDTH: 800,
    IMAGE_QUALITY: 0.85,
    
    // Timing constants (milliseconds)
    TIMEOUTS: {
      VALIDATION_DELAY: 500,
      AUTO_MJ_DELAY: 800,
      RENDER_DELAY: 100,
      ROUTER_RETRY_DELAY: 1000,
      ERROR_RETRY_DELAY: 2000,
      DYNAMIC_CENTERING_DELAY: 50
    },
    
    // Breakpoints (aligned with CSS media queries)
    BREAKPOINTS: {
      MOBILE: 768,  // Updated to match CSS @media (max-width: 768px)
      TABLET_PORTRAIT: 768,
      TABLET_LANDSCAPE: 1024,
      DESKTOP: 980
    }
  };

  // ========================================
  // ELEMENT COLORS
  // ========================================
  window.ELEMENT_COLORS = {
    FEU: { color: '#ff6b35', weight: 'bold' },
    EAU: { color: '#4682b4', weight: 'bold' },
    TERRE: { color: '#8b4513', weight: 'bold' },
    AIR: { color: '#87ceeb', weight: 'bold' },
    DIVIN: { color: '#ffd700', weight: 'bold' },
    MALEFIQUE: { color: '#8b008b', weight: 'bold' },
    NEUTRE: { color: '#696969', weight: 'normal' }
  };

  // ========================================
  // STORAGE KEYS
  // ========================================
  window.STORAGE_KEYS = {
    EDITS: 'jdr-bab-edits',
    LAST_MODIFIED: 'jdr-bab-last-modified',
    MONSTER_BACKUPS: 'jdr-bab-monster-backups',
    FILTER_SETTINGS: 'jdr-bab-filter-settings',
    FAVORIS: 'jdr-bab-favoris'
  };

  // ========================================
  // EVENT CONSTANTS
  // ========================================
  window.Events = {
    STORAGE_SAVE: 'storage:save',
    PAGE_RENDER: 'page:render',
    CONTENT_UPDATE: 'content:update',
    FAVORIS_ADD: 'favoris:add',
    FAVORIS_REMOVE: 'favoris:remove',
    FAVORIS_UPDATE: 'favoris:update'
  };

  // ========================================
  // DEFAULT VALUES
  // ========================================
  window.DEFAULT_VALUES = {
    // Monster backup retention
    MAX_MONSTER_BACKUPS: 10,
    
    // Filter defaults
    DEFAULT_VISIBLE_TAGS: ['Arme', 'Armure', 'Bouclier', 'Consommable'],
    
    // Image defaults
    DEFAULT_MONSTER_IMAGE: 'data/images/Monstres/foret/default-monster.png',
    DEFAULT_SPELL_IMAGE: 'data/images/Sorts/default-spell.png',
    DEFAULT_CLASS_IMAGE: 'data/images/Classes/default-class.png'
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - CONTENT TYPES CONFIGURATION
// ============================================================================

(() => {
  "use strict";

  window.ContentTypes = {
    spell: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        element: { type: 'select', label: 'Élément', required: true, options: ['Feu', 'Eau', 'Terre', 'Air', 'Lumière', 'Nuit', 'Divin', 'Maléfique'] },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'Prérequis', required: true },
        portee: { type: 'richtext', label: 'Portée', required: true },
        tempsIncantation: { type: 'richtext', label: "Temps d'incantation", required: true },
        coutMana: { type: 'richtext', label: 'Coût mana', required: true },
        resistance: { type: 'richtext', label: 'Résistance', required: true },
        effetNormal: { type: 'richtext', label: 'Effet normal', required: true },
        effetCritique: { type: 'richtext', label: 'Effet critique', required: false }
      },
      editMapping: {
        'spell-name': 'nom',
        'spell-element': 'element',
        'spell-description': 'description',
        'spell-prerequis': 'prerequis',
        'spell-portee': 'portee',
        'spell-mana': 'coutMana',
        'spell-temps-incantation': 'tempsIncantation',
        'spell-resistance': 'resistance',
        'spell-effect-normal': 'effetNormal',
        'spell-effect-critical': 'effetCritique'
      },
      identifiers: {
        name: 'nom',
        category: 'sorts'
      },
      template: 'spell-card',
      container: 'sorts',
      dataKey: 'SORTS',
      icons: { 
        category: '🔮', 
        item: '✨',
        add: '➕',
        delete: '🗑️'
      },
      defaultValues: {
        nom: "Nouveau Sort",
        element: "Feu",
        description: "Lance une boule de Feu sur un adversaire.",
        prerequis: "📋 <strong>Prérequis:</strong> Niveau 1",
        portee: "🎯 <strong>Portée:</strong> 20m",
        tempsIncantation: "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        coutMana: "🔵 <strong>Coût mana:</strong> 3",
        resistance: "<strong>Sans effet si:</strong> Esquive.",
        effetNormal: "<strong>Effet:</strong> Inflige 5 dégats de <span style='color: #e25822; font-weight: bold;'>Feu</span> à la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        effetCritique: "<strong>Coup Critique:&nbsp;</strong>&nbsp;Double les dégâts et enflamme la cible."
      }
    },

    don: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'Prérequis', required: true },
        cout: { type: 'richtext', label: 'Coût', required: true }
      },
      editMapping: {
        'don-name': 'nom',
        'don-description': 'description',
        'don-prerequis': 'prerequis',
        'don-cout': 'cout'
      },
      identifiers: {
        name: 'nom',
        category: 'dons'
      },
      template: 'don-card',
      container: 'dons',
      dataKey: 'DONS',
      icons: { 
        category: '🎖️', 
        item: '🏆',
        add: '➕',
        delete: '🗑️'
      },
      defaultValues: {
        nom: "Nouveau Don",
        description: "Description du don.",
        prerequis: "Aucun prérequis",
        cout: "1 point de don"
      }
    },

    class: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        resume: { type: 'textarea', label: 'Résumé', required: true },
        capacites: { type: 'list', label: 'Capacités', required: true }
      },
      editMapping: {
        'class-name': 'nom',
        'class-resume': 'resume',
        'class-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: null
      },
      template: 'class-page',
      container: 'classes',
      dataKey: 'CLASSES',
      icons: { 
        category: '⚔️', 
        item: '🛡️',
        add: '➕',
        delete: '🗑️'
      }
    },

    subclass: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        base: { type: 'stats', label: 'Statistiques de base', required: true },
        progression: { type: 'richtext', label: 'Progression', required: true },
        capacites: { type: 'list', label: 'Capacités', required: true }
      },
      editMapping: {
        'subclass-name': 'nom',
        'subclass-description': 'description',
        'subclass-stats': 'base',
        'subclass-progression': 'progression',
        'subclass-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: 'sousClasses',
        parent: 'class'
      },
      template: 'subclass-card',
      icons: { 
        item: '⚡',
        add: '➕',
        delete: '🗑️'
      },
      defaultValues: {
        nom: "Nouvelle sous-classe",
        description: "Description de la sous-classe",
        base: {
          Force: 3,
          Agilité: 3,
          Endurance: 3,
          Intelligence: 3,
          Volonté: 3,
          Chance: 3
        },
        progression: "<strong>📈 Progression par niveau:</strong> +1 Force 💪, +1 Agilité 🏃",
        capacites: [
          "<em>Capacité unique</em>: Description de la capacité spéciale de cette sous-classe."
        ]
      }
    },

    objet: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        numero: { type: 'number', label: 'Numéro', required: true },
        image: { type: 'text', label: 'Image', required: false },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        effet: { type: 'richtext', label: 'Effet', required: true },
        prix: { type: 'richtext', label: 'Prix', required: true },
        poids: { type: 'richtext', label: 'Poids', required: true }
      },
      editMapping: {
        'objet-name': 'nom',
        'objet-numero': 'numero',
        'objet-image': 'image',
        'objet-description': 'description',
        'objet-tags': 'tags',
        'objet-effet': 'effet',
        'objet-prix': 'prix',
        'objet-poids': 'poids'
      },
      identifiers: {
        name: 'nom',
        category: 'objets'
      },
      template: 'objet-card',
      container: 'objets',
      dataKey: 'OBJETS',
      pageType: 'single', // Page unique avec filtres
      icons: { 
        category: '📦', 
        item: '🎒',
        add: '➕',
        delete: '🗑️'
      },
      // Configuration des filtres disponibles (MISE À JOUR AUTOMATIQUE)
      filterConfig: {
        availableTags: [
          "Arme",
          "Armure",
          "Consommable",
          "Bouclier",
          "Épée",
          "Arme exotique",
          "Une main",
          "Deux mains",
          "Baton",
          "Dague",
          "Arc",
          "Armure lourde",
          "Armure légère",
          "Robe",
          "Plante",
          "Catalyseur",
          "Nouvel objet",
          "Nourriture",
          "Non identifié",
          "Flèche",
          "Accessoire",
          "Composant"
],
        defaultVisibleTags: [
          "Arme"
] // Filtres affichés par défaut
      },
      defaultValues: {
        nom: "Nouvel Objet",
        numero: 1,
        image: "",
        description: "Description de l'objet.",
        tags: ["Nouvel objet"],
        effet: "<strong>Effet:</strong> Description de l'effet de l'objet.",
        prix: "🔷 <strong>Prix:</strong> 10",
        poids: "⚖️ <strong>Poids:</strong> 1"
      }
    },

    monster: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        image: { type: 'text', label: 'Image', required: false },
        element: { 
          type: 'select', 
          label: "Élément d'affiliation", 
          required: true,
          options: [
            { value: 'Feu', label: '🔥 Feu' },
            { value: 'Eau', label: '💧 Eau' },
            { value: 'Terre', label: '🤎 Terre' },
            { value: 'Air', label: '🟢 Air' },
            { value: 'Lumiere', label: '☀️ Lumière' },
            { value: 'Nuit', label: '⚫ Nuit' },
            { value: 'Divin', label: '⚪ Divin' },
            { value: 'Malefique', label: '🟣 Maléfique' }
          ]
        },
        pointsDeVie: { type: 'number', label: 'Points de vie', required: true },
        armurePhysique: { type: 'number', label: 'Armure physique', required: true },
        esquive: { type: 'number', label: 'Esquive', required: true },
        coupCritique: { type: 'number', label: 'Coup critique', required: true },
        coupCritiqueSorts: { type: 'number', label: 'Critique sorts', required: true },
        resistanceAlterations: { type: 'number', label: 'Résistance altérations', required: true },
        armureFeu: { type: 'number', label: 'Armure Feu', required: true },
        armureEau: { type: 'number', label: 'Armure Eau', required: true },
        armureTerre: { type: 'number', label: 'Armure Terre', required: true },
        armureAir: { type: 'number', label: 'Armure Air', required: true },
        armureLumiere: { type: 'number', label: 'Armure Lumière', required: true },
        armureObscurite: { type: 'number', label: 'Armure Obscurité', required: true },
        armureDivin: { type: 'number', label: 'Armure Divin', required: true },
        armureMalefique: { type: 'number', label: 'Armure Maléfique', required: true },
        abilites: { type: 'richtext', label: 'Abilités', required: false },
        butin: { type: 'richtext', label: 'Butin', required: false }
      },
      editMapping: {
        'monster-name': 'nom',
        'monster-tags': 'tags',
        'monster-image': 'image',
        'monster-element': 'element',
        // Stats principaux
        'monster-pointsdevie': 'pointsDeVie',
        'monster-armurephysique': 'armurePhysique', 
        'monster-esquive': 'esquive',
        'monster-coupcritique': 'coupCritique',
        'monster-coupcritiquesorts': 'coupCritiqueSorts',
        'monster-resistancealterations': 'resistanceAlterations',
        // Armures élémentaires
        'monster-armurefeu': 'armureFeu',
        'monster-armureeau': 'armureEau',
        'monster-armureterre': 'armureTerre',
        'monster-armureair': 'armureAir',
        'monster-armurelumiere': 'armureLumiere',
        'monster-armureobscurite': 'armureObscurite',
        'monster-armuredivin': 'armureDivin',
        'monster-armuremalefique': 'armureMalefique',
        // Contenu narratif
        'monster-abilites': 'abilites',
        'monster-butin': 'butin'
      },
      identifiers: {
        name: 'nom',
        category: 'monstres'
      },
      template: 'monster-card',
      container: 'monstres',
      dataKey: 'MONSTRES',
      pageType: 'single',
      filterMode: 'AND',
      icons: { 
        category: '🐲', 
        item: '👾',
        add: '➕',
        delete: '🗑️'
      },
      filterConfig: {
        availableTags: [
          "Forêt",
          "Boss"
],
        defaultVisibleTags: [
          "Forêt"
]
      },
      defaultValues: {
        nom: "Nouveau Monstre",
        tags: ["Forêt"],
        image: "",
        element: "Feu",
        pointsDeVie: 20,
        armurePhysique: 2,
        esquive: 5,
        coupCritique: 10,
        coupCritiqueSorts: 8,
        resistanceAlterations: 3,
        armureFeu: 0,
        armureEau: 0,
        armureTerre: 0,
        armureAir: 0,
        armureLumiere: 0,
        armureObscurite: 0,
        armureDivin: 0,
        armureMalefique: 0,
        abilites: "<strong>Attaque basique:</strong> Inflige 5 dégâts physiques.",
        butin: "<strong>Butin:</strong> 10-50 pièces d'or."
      }
    },

    tableTresor: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        fourchettes: { type: 'list', label: 'Fourchettes', required: true }
      },
      editMapping: {
        'table-tresor-name': 'nom',
        'table-tresor-description': 'description',
        'table-tresor-tags': 'tags'
      },
      identifiers: {
        name: 'nom',
        category: 'tables'
      },
      template: 'table-tresor-card',
      container: 'tables-tresors',
      dataKey: 'TABLES_TRESORS',
      pageType: 'single',
      filterMode: 'OR',
      icons: { 
        category: '💎', 
        item: '📦',
        add: '➕',
        delete: '🗑️'
      },
      filterConfig: {
        // availableTags managed dynamically via window.TABLES_TRESORS._metadata.availableTags
        defaultVisibleTags: [
          "Forêt",
          "Boss"
        ]
      },
      defaultValues: {
        nom: "Nouvelle Table de Trésor",
        description: "Table de butin pour une situation spécifique.",
        tags: ["Forêt"],
        fourchettes: [
          {
            min: 1,
            max: 10,
            objet: {
              type: "reference",
              numero: 1,
              nom: "Objet par défaut"
            }
          }
        ]
      }
    },

    staticPage: {
      fields: {
        title: { type: 'text', label: 'Titre', required: true },
        sections: { type: 'sections', label: 'Sections', required: true }
      },
      template: 'static-page',
      icons: { 
        category: '📄', 
        item: '📝'
      }
    }
  };

  window.StatIcons = {
    'Force': '💪',
    'Agilité': '🏃',
    'Endurance': '🛡️',
    'Intelligence': '🧠',
    'Volonté': '⚡',
    'Chance': '🍀'
  };

  window.ElementColors = {
    'Feu': { color: '#ff6b35', weight: 'bold' },
    'Eau': { color: '#4682b4', weight: 'bold' },
    'Terre': { color: '#8b4513', weight: 'bold' },
    'Air': { color: '#22c55e', weight: 'bold' },
    'Lumière': { color: '#ffd700', weight: 'bold' },
    'Nuit': { color: '#1a1a1a', weight: 'bold' },
    'Divin': { color: '#f5f5f5', weight: 'bold', background: 'rgba(100, 100, 100, 0.3)', padding: '2px 4px', borderRadius: '3px' },
    'Maléfique': { color: '#8b5cf6', weight: 'bold' }
  };

  window.ElementIcons = {
    'Feu': '🔥',
    'Eau': '💧',
    'Terre': '🤎',
    'Air': '🟢',
    'Lumière': '☀️',
    'Nuit': '⚫',
    'Divin': '⚪',
    'Maléfique': '🟣'
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - EVENT BUS
// ============================================================================

(() => {
  "use strict";

  class EventBus {
    constructor() {
      this.listeners = new Map();
    }

    static getInstance() {
      if (!EventBus.instance) {
        EventBus.instance = new EventBus();
      }
      return EventBus.instance;
    }

    on(eventType, callback) {
      if (!this.listeners.has(eventType)) {
        this.listeners.set(eventType, []);
      }
      this.listeners.get(eventType).push(callback);
      return () => this.off(eventType, callback);
    }

    off(eventType, callback) {
      const callbacks = this.listeners.get(eventType);
      if (callbacks) {
        const index = callbacks.indexOf(callback);
        if (index > -1) {
          callbacks.splice(index, 1);
        }
      }
    }

    emit(eventType, payload = {}) {
      const callbacks = this.listeners.get(eventType);
      if (callbacks) {
        callbacks.forEach(callback => {
          try {
            callback(payload);
          } catch (error) {
            console.error(`Error in event callback for ${eventType}:`, error);
          }
        });
      }
    }

    once(eventType, callback) {
      const unsubscribe = this.on(eventType, (payload) => {
        callback(payload);
        unsubscribe();
      });
      return unsubscribe;
    }
  }

  window.EventBus = EventBus.getInstance();

  window.Events = {
    CONTENT_ADD: 'content:add',
    CONTENT_DELETE: 'content:delete',
    CONTENT_UPDATE: 'content:update',
    CONTENT_MOVE: 'content:move',
    PAGE_RENDER: 'page:render',
    EDITOR_TOGGLE: 'editor:toggle',
    IMAGE_UPLOAD: 'image:upload',
    IMAGE_DELETE: 'image:delete',
    STORAGE_SAVE: 'storage:save',
    SEARCH_PERFORM: 'search:perform',
    MODAL_OPEN: 'modal:open',
    MODAL_CLOSE: 'modal:close',
    NOTIFICATION_SHOW: 'notification:show'
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - BASE ENTITY
// ============================================================================

(() => {
  "use strict";

  class BaseEntity {
    constructor(type, dataArray) {
      this.type = type;
      this.data = dataArray || [];
      this.config = window.ContentTypes[type];
      
      // Handle special case for objects with new structure
      if (type === 'objet' && this.data && !Array.isArray(this.data) && this.data.objets) {
        // Convert to pseudo-category structure for compatibility
        this.objectsData = this.data; // Keep reference to original structure
        this.data = [{ nom: 'objets', objets: this.data.objets }]; // Wrap in array format
      }
      
      // Handle special case for treasure tables with structure: { tables: [...], _metadata: {...} }
      if (type === 'tableTresor' && this.data && !Array.isArray(this.data) && this.data.tables) {
        // Convert to pseudo-category structure for compatibility
        this.tablesData = this.data; // Keep reference to original structure
        this.data = [{ nom: 'tables', tables: this.data.tables }]; // Wrap in array format
      }
    }

    getAll() {
      return this.data;
    }

    findCategory(categoryName) {
      return this.data.find(category => category.nom === categoryName);
    }

    findItem(itemName, categoryName = null) {
      if (categoryName) {
        const category = this.findCategory(categoryName);
        if (!category || !category[this.getItemsProperty()]) return null;
        
        const item = category[this.getItemsProperty()].find(item => item.nom === itemName);
        return item ? { item, category: category.nom } : null;
      }

      for (const category of this.data) {
        if (!category[this.getItemsProperty()]) continue;
        const item = category[this.getItemsProperty()].find(item => item.nom === itemName);
        if (item) {
          return { item, category: category.nom };
        }
      }
      return null;
    }

    addItem(categoryName, itemData) {
      const category = this.findCategory(categoryName);
      if (!category) return false;

      const itemsProperty = this.getItemsProperty();
      if (!category[itemsProperty]) {
        category[itemsProperty] = [];
      }

      const defaultValues = this.config?.defaultValues || {};
      const newItem = { ...defaultValues, ...itemData };
      category[itemsProperty].push(newItem);

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_ADD, {
        type: this.type,
        category: categoryName,
        item: newItem
      });

      return newItem;
    }

    deleteItem(categoryName, itemName) {
      const category = this.findCategory(categoryName);
      if (!category) return false;

      const itemsProperty = this.getItemsProperty();
      const items = category[itemsProperty];
      if (!items) return false;

      const index = items.findIndex(item => item.nom === itemName);
      if (index === -1) return false;

      const deletedItem = items.splice(index, 1)[0];

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_DELETE, {
        type: this.type,
        category: categoryName,
        item: deletedItem
      });

      return true;
    }

    updateItem(categoryName, itemName, property, value) {
      const result = this.findItem(itemName, categoryName);
      if (!result) return false;

      const { item } = result;
      
      if (property === 'capacites' && Array.isArray(value)) {
        item[property] = value;
      } else if (property === 'base' && typeof value === 'object') {
        item[property] = { ...item[property], ...value };
      } else {
        item[property] = value;
      }

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_UPDATE, {
        type: this.type,
        category: categoryName,
        item: item,
        property: property,
        value: value
      });

      return true;
    }

    moveItem(categoryName, itemName, direction) {
      const category = this.findCategory(categoryName);
      if (!category) return false;

      const itemsProperty = this.getItemsProperty();
      const items = category[itemsProperty];
      if (!items) return false;

      const currentIndex = items.findIndex(item => item.nom === itemName);
      if (currentIndex === -1) return false;

      const newIndex = currentIndex + direction;
      if (newIndex < 0 || newIndex >= items.length) return false;

      [items[currentIndex], items[newIndex]] = [items[newIndex], items[currentIndex]];

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_MOVE, {
        type: this.type,
        category: categoryName,
        itemName: itemName,
        direction: direction
      });

      return true;
    }

    getItemsProperty() {
      switch (this.type) {
        case 'spell': return 'sorts';
        case 'don': return 'dons';
        case 'objet': return 'objets';
        case 'class': return 'sousClasses';
        case 'tableTresor': return 'tables';
        default: return 'items';
      }
    }

    search(query) {
      const results = [];
      const normalizedQuery = query.toLowerCase().trim();

      this.data.forEach(category => {
        const itemsProperty = this.getItemsProperty();
        if (!category[itemsProperty]) return;

        category[itemsProperty].forEach(item => {
          const searchableText = Object.values(item).join(' ').toLowerCase();
          if (searchableText.includes(normalizedQuery)) {
            results.push({
              item,
              category: category.nom,
              type: this.type
            });
          }
        });
      });

      return results;
    }

    // Sync changes back to original objects data structure
    syncObjectsData() {
      // Sync objects data
      if (this.type === 'objet' && this.objectsData && this.data.length > 0) {
        const objectsCategory = this.data[0];
        if (objectsCategory && objectsCategory.objets) {
          this.objectsData.objets = objectsCategory.objets;
        }
      }
      
      // Sync treasure tables data
      if (this.type === 'tableTresor' && this.tablesData && this.data.length > 0) {
        const tablesCategory = this.data[0];
        if (tablesCategory && tablesCategory.tables) {
          this.tablesData.tables = tablesCategory.tables;
        }
      }
      
      // Sync monsters data - CRITICAL for preventing data reversion
      if (this.type === 'monster' && window.MONSTRES && Array.isArray(this.data)) {
        // Ensure window.MONSTRES stays synchronized with our internal data
        window.MONSTRES.length = 0; // Clear array
        window.MONSTRES.push(...this.data); // Replace with current data
        
        // Also sync image mappings
        if (JdrApp.modules.images && typeof JdrApp.modules.images.ensureMonsterImageMappings === 'function') {
          JdrApp.modules.images.ensureMonsterImageMappings();
        }
      }
    }
  }

  window.BaseEntity = BaseEntity;

})();
// ============================================================================
// JDR-BAB APPLICATION - CONTENT FACTORY
// ============================================================================

(() => {
  "use strict";

  class ContentFactory {
    constructor() {
      this.entities = new Map();
      this.initialize();
    }

    static getInstance() {
      if (!ContentFactory.instance) {
        ContentFactory.instance = new ContentFactory();
      }
      return ContentFactory.instance;
    }

    initialize() {
      // Lazy initialization - only create entities when data is available
      if (window.SORTS) {
        this.entities.set('spell', new BaseEntity('spell', window.SORTS));
      }
      if (window.DONS) {
        this.entities.set('don', new BaseEntity('don', window.DONS));
      }
      if (window.CLASSES) {
        this.entities.set('class', new BaseEntity('class', window.CLASSES));
      }
      if (window.OBJETS) {
        this.entities.set('objet', new BaseEntity('objet', window.OBJETS));
      }
      if (window.MONSTRES) {
        this.entities.set('monster', new BaseEntity('monster', window.MONSTRES));
      }
      if (window.TABLES_TRESORS) {
        this.entities.set('tableTresor', new BaseEntity('tableTresor', window.TABLES_TRESORS));
      }
    }

    getEntity(type) {
      // Ensure entity exists, create if data is available but entity is missing
      if (!this.entities.has(type)) {
        this.initializeEntity(type);
      }
      return this.entities.get(type);
    }

    initializeEntity(type) {
      switch (type) {
        case 'spell':
          if (window.SORTS) {
            this.entities.set('spell', new BaseEntity('spell', window.SORTS));
          }
          break;
        case 'don':
          if (window.DONS) {
            this.entities.set('don', new BaseEntity('don', window.DONS));
          }
          break;
        case 'class':
          if (window.CLASSES) {
            this.entities.set('class', new BaseEntity('class', window.CLASSES));
          }
          break;
        case 'objet':
          if (window.OBJETS) {
            this.entities.set('objet', new BaseEntity('objet', window.OBJETS));
          }
          break;
        case 'monster':
          if (window.MONSTRES) {
            this.entities.set('monster', new BaseEntity('monster', window.MONSTRES));
          }
          break;
        case 'tableTresor':
          if (window.TABLES_TRESORS) {
            this.entities.set('tableTresor', new BaseEntity('tableTresor', window.TABLES_TRESORS));
          }
          break;
      }
    }

    getSpells() {
      return this.getEntity('spell');
    }

    getDons() {
      return this.getEntity('don');
    }

    getClasses() {
      return this.getEntity('class');
    }

    getObjets() {
      return this.getEntity('objet');
    }

    getMonsters() {
      return this.getEntity('monster');
    }

    getTablesTresors() {
      return this.getEntity('tableTresor');
    }

    findItem(type, itemName, categoryName = null) {
      const entity = this.getEntity(type);
      return entity ? entity.findItem(itemName, categoryName) : null;
    }

    addItem(type, categoryName, itemData) {
      const entity = this.getEntity(type);
      return entity ? entity.addItem(categoryName, itemData) : false;
    }

    deleteItem(type, categoryName, itemName) {
      const entity = this.getEntity(type);
      return entity ? entity.deleteItem(categoryName, itemName) : false;
    }

    updateItem(type, categoryName, itemName, property, value) {
      const entity = this.getEntity(type);
      return entity ? entity.updateItem(categoryName, itemName, property, value) : false;
    }

    moveItem(type, categoryName, itemName, direction) {
      const entity = this.getEntity(type);
      return entity ? entity.moveItem(categoryName, itemName, direction) : false;
    }

    searchAll(query) {
      const allResults = [];
      
      this.entities.forEach((entity, type) => {
        const results = entity.search(query);
        allResults.push(...results);
      });

      return allResults;
    }

    refreshData() {
      this.entities.clear();
      this.initialize();
    }

    // ============================================================================
    // UNIFIED PAGE DESCRIPTION SYSTEM
    // ============================================================================

    getPageDescription(type) {
      const config = window.ContentTypes[type];
      
      if (!config || !config.pageDescription) {
        return '';
      }
      
      const pageDesc = config.pageDescription;
      
      if (pageDesc.dataSource === 'external') {
        // Utilisation d'un fichier externe via dataKey
        const dataObj = window[pageDesc.dataKey];
        if (!dataObj) {
          // Créer l'objet externe s'il n'existe pas
          window[pageDesc.dataKey] = { [pageDesc.storageKey]: pageDesc.defaultValue };
          return pageDesc.defaultValue;
        }
        return dataObj[pageDesc.storageKey] || pageDesc.defaultValue;
      } else {
        // Source de données intégrée dans le dataKey principal
        const mainDataKey = config.dataKey;
        const mainData = window[mainDataKey];
        
        if (!mainData) {
          return pageDesc.defaultValue;
        }
        
        // Initialiser la description si elle n'existe pas
        if (!mainData[pageDesc.storageKey]) {
          mainData[pageDesc.storageKey] = pageDesc.defaultValue;
        }
        
        return mainData[pageDesc.storageKey];
      }
    }

    updatePageDescription(type, newDescription) {
      
      // Ensure collections type exists (fallback injection)
      if (type === 'collections' && (!window.ContentTypes || !window.ContentTypes.collections)) {
        this.ensureCollectionsType();
      }
      
      const config = window.ContentTypes[type];
      
      if (!config || !config.pageDescription) {
        // No page description config found for type
        return false;
      }
      
      const pageDesc = config.pageDescription;
      
      try {
        if (pageDesc.dataSource === 'external') {
          // Mise à jour d'un fichier externe via dataKey
          const dataObj = window[pageDesc.dataKey];
          if (!dataObj) {
            window[pageDesc.dataKey] = {};
          }
          window[pageDesc.dataKey][pageDesc.storageKey] = newDescription;
          
          // Also update JdrApp.data.customPageDescriptions for consistency with router and storage
          if (!JdrApp.data.customPageDescriptions) {
            JdrApp.data.customPageDescriptions = {};
          }
          JdrApp.data.customPageDescriptions[pageDesc.storageKey] = newDescription;
        } else {
          // Mise à jour dans le dataKey principal
          const mainDataKey = config.dataKey;
          const mainData = window[mainDataKey];
          
          if (!mainData) {
            return false;
          }
          
          mainData[pageDesc.storageKey] = newDescription;
        }
        
        // Émettre un événement pour notifier le changement
        if (window.EventBus) {
          window.EventBus.emit('pageDescriptionUpdated', { type, description: newDescription });
        }
        
        return true;
      } catch (error) {
        return false;
      }
    }

    getConfig(type) {
      return window.ContentTypes[type];
    }

    createDefaultItem(type, overrides = {}) {
      const config = this.getConfig(type);
      if (!config?.defaultValues) return {};

      return { ...config.defaultValues, ...overrides };
    }

    ensureCollectionsType() {
      if (!window.ContentTypes) {
        window.ContentTypes = {};
      }
      
      // Inject collections type if missing
      window.ContentTypes.collections = {
        fields: {
          description: { type: 'richtext', label: 'Description', required: true }
        },
        template: 'collections-page',
        container: 'collections',
        icons: { 
          category: '📚', 
          item: '📦'
        },
        pageDescription: {
          dataSource: 'external',
          dataKey: 'CUSTOM_PAGE_DESCRIPTIONS',
          storageKey: 'collections-objets',
          defaultValue: "Recherchez et explorez des collections d'objets organisées par thème"
        },
        defaultValues: {
          description: "Recherchez et explorez des collections d'objets organisées par thème"
        }
      };
      
      // Collections type injected into ContentTypes
    }
  }

  window.ContentFactory = ContentFactory.getInstance();

})();
// ============================================================================
// JDR-BAB APPLICATION - CARD BUILDER
// ============================================================================

(() => {
  "use strict";

  class CardBuilder {
    constructor(type, data, categoryName = null, index = null) {
      this.type = type;
      this.data = data;
      this.categoryName = categoryName;
      this.index = index;
      this.config = window.ContentTypes[type];
      this.isPreview = categoryName === 'preview'; // Mode preview si categoryName est 'preview'
    }

    static create(type, data, categoryName = null, index = null) {
      return new CardBuilder(type, data, categoryName, index);
    }

    // Simple unified dev mode check
    get shouldShowEditButtons() {
      return JdrApp.utils.isDevMode() && !this.isPreview;
    }

    build() {
      let html = '';
      
      switch (this.type) {
        case 'spell':
          html = this.buildSpellCard();
          break;
        case 'don':
          html = this.buildDonCard();
          break;
        case 'subclass':
          html = this.buildSubclassCard();
          break;
        case 'objet':
          html = this.buildObjetCard();
          break;
        case 'monster':
          html = this.buildMonsterCard();
          break;
        case 'tableTresor':
          html = this.buildTableTresorCard();
          break;
        default:
          html = this.buildGenericCard();
          break;
      }
      
      // Apply HTML minification for performance optimization in standalone mode
      if (window.STANDALONE_VERSION && JdrApp.utils && JdrApp.utils.minifyHTML) {
        html = JdrApp.utils.minifyHTML(html);
      }
      
      return html;
    }

    buildSpellCard() {
      const favorisButtonHTML = this.buildFavorisButton('sorts', this.data.nom);
      
      const result = `
        <div class="card editable-section spell-card" data-section-type="spell" data-spell-name="${this.data.nom}" data-spell-index="${this.index}" data-category-name="${this.categoryName}">
          ${favorisButtonHTML}
          ${this.buildEditableTitle(this.data.nom, 'spell-name')}
          ${this.buildSpellElement()}
          ${this.buildIllustration(`sort:${this.categoryName}:${this.data.nom}`, this.data.nom)}
          ${this.buildEditableField(this.data.description, 'spell-description', 'Description', { style: 'text-align: center; font-style: italic; margin: 1rem 0;' })}
          <hr style="margin: 1rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.6;">
          ${this.buildEditableField(this.data.prerequis, 'spell-prerequis', 'Prérequis')}
          ${this.buildEditableField(this.data.portee, 'spell-portee', 'Portée')}
          ${this.buildEditableField(this.data.coutMana, 'spell-mana', 'Coût mana')}
          ${this.buildEditableField(this.data.tempsIncantation, 'spell-temps-incantation', 'Temps d\'incantation')}
          <hr style="margin: 0.5rem 0; border: none; border-top: 1px solid var(--rule);">
          ${this.buildEditableField(this.data.resistance, 'spell-resistance', 'Résistance')}
          ${this.buildEditableEffect(this.data.effetNormal, 'spell-effect-normal', 'Effet normal')}
          <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
          ${this.data.effetCritique ? this.buildEditableEffect(this.data.effetCritique, 'spell-effect-critical', 'Effet critique') : ''}
          ${this.buildDeleteButton('spell')}
        </div>
      `;
      
      return result;
    }

    buildDonCard() {
      const index = this.index !== null ? this.index : (this.categoryName ? this.getCategoryData().dons?.indexOf(this.data) || 0 : 0);
      const totalItems = this.categoryName ? this.getCategoryData().dons?.length || 1 : 1;

      return `
        <div class="card editable-section" data-section-type="don" data-don-name="${this.data.nom}" data-don-index="${this.index}" data-category-name="${this.categoryName}">
          ${this.buildEditableTitle(this.data.nom, 'don-name')}
          ${this.buildIllustration(`don:${this.data.nom}`, this.data.nom)}
          ${this.buildEditableField(this.data.description, 'don-description', 'Description')}
          ${this.buildEditableField(this.data.prerequis, 'don-prerequis', 'Prérequis')}
          ${this.buildEditableField(this.data.cout, 'don-cout', 'Coût', { style: 'color: var(--bronze); font-weight: 600;' })}
          ${this.buildMoveButtons('don', index, totalItems)}
        </div>
      `;
    }

    buildSubclassCard() {
      return `
        <div class="card editable-section" data-section-type="subclass" data-class-name="${this.categoryName}" data-subclass-name="${this.data.nom}">
          ${this.buildEditableTitle(this.data.nom, 'subclass-name')}
          ${this.buildEditableField(this.data.description || 'Description de la sous-classe', 'subclass-description', 'Description', { style: 'text-align: center; color: inherit;' })}
          ${this.buildSubclassImages()}
          <div style="margin-bottom: 1rem;">
            ${this.buildStatsSection()}
          </div>
          ${this.buildEditableField(this.data.progression, 'subclass-progression', 'Progression')}
          <div class="rule" style="margin: 1.5rem auto; height: 2px; background: linear-gradient(90deg, transparent, var(--bronze), transparent); opacity: 0.6;"></div>
          ${this.buildEditableList(this.data.capacites, 'subclass-capacites', 'Capacités')}
          ${this.buildDeleteButton('subclass')}
        </div>
      `;
    }

    buildObjetCard() {
      // Pour les objets en page unique, l'index est basé sur tous les objets
      const allObjects = window.OBJETS?.objets || [];
      const index = allObjects.indexOf(this.data) || 0;
      const totalItems = allObjects.length;
      
      // Construire l'affichage des tags
      const tagsDisplay = this.data.tags && this.data.tags.length > 0 
        ? this.data.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';

      return `
        <div class="card editable-section item-card" data-section-type="objet" data-objet-name="${this.data.nom}" data-category-name="${this.categoryName}">
          ${this.buildFavorisButton('objets', this.data.nom)}
          ${this.buildEditableTitle(this.data.nom, 'objet-name')}
          ${this.buildIllustration(`objet:${this.data.nom}`, this.data.nom)}
          <div style="display: flex; justify-content: space-between; align-items: center; margin: 0.5rem 0; font-size: 0.9em; color: var(--bronze);">
            ${this.buildEditableField(`N°${this.data.numero}`, 'objet-numero', 'Numéro', { style: 'font-weight: bold;' })}
            <div style="flex: 1; text-align: right;">
              <div style="margin: 2px 0;">
                ${this.buildEditableTagsField(tagsDisplay, 'objet-tags', 'Tags')}
              </div>
            </div>
          </div>
          ${this.buildEditableField(this.data.description, 'objet-description', 'Description')}
          <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
          ${this.buildEditableField(this.data.effet, 'objet-effet', 'Effet')}
          <div style="display: flex; justify-content: space-between; gap: 1rem; margin: 0.5rem 0;">
            <div style="flex: 1;">${this.buildEditableField(this.data.prix, 'objet-prix', 'Prix')}</div>
            <div style="flex: 1;">${this.buildEditableField(this.data.poids, 'objet-poids', 'Poids')}</div>
          </div>
        </div>
      `;
    }

    buildMonsterCard() {
      const allMonsters = window.MONSTRES || [];
      const index = allMonsters.indexOf(this.data) || 0;
      const totalItems = allMonsters.length;
      
      // Construire l'affichage des tags
      const tagsDisplay = this.data.tags && this.data.tags.length > 0 
        ? this.data.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';

      return `
        <div class="card editable-section" data-section-type="monster" data-monster-name="${this.data.nom}">
          ${this.buildEditableTitle(this.data.nom, 'monster-name')}
          ${this.buildIllustration(`monster:${this.data.nom}`, this.data.nom)}
          
          <div style="display: flex; justify-content: space-between; align-items: flex-start; margin: 0.5rem 0; gap: 1rem;">
            <div style="flex: 1;">
              ${this.buildEditableTagsField(tagsDisplay, 'monster-tags', 'Tags')}
            </div>
            <div style="flex-shrink: 0;">
              ${this.buildMonsterElement()}
            </div>
          </div>
          
          <!-- Séparation avant les stats principales -->
          <hr style="margin: 1.5rem 0 1rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.3;">
          
          <div class="monster-stats-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin: 1rem 0; font-size: 0.9em;">
            <div>${this.buildEditableStatField('🎯 Initiative', this.data.initiative, 'monster-initiative', 'Initiative')}</div>
            <div>${this.buildEditableStatField('❤️ PV', this.data.pointsDeVie, 'monster-pointsdevie', 'Points de vie')}</div>
            <div>${this.buildEditableStatField('⚡ Critique', this.data.coupCritique, 'monster-coupcritique', 'Coup critique')}</div>
            <div>${this.buildEditableStatField('🛡️ Armure', this.data.armurePhysique, 'monster-armurephysique', 'Armure physique')}</div>
            <div>${this.buildEditableStatField('🔮 Crit. Sorts', this.data.coupCritiqueSorts, 'monster-coupcritiquesorts', 'Critique sorts')}</div>
            <div>${this.buildEditableStatField('🏃 Esquive', this.data.esquive, 'monster-esquive', 'Esquive')}</div>
            <div></div>
            <div>${this.buildEditableStatField('✨ Rés. Alt.', this.data.resistanceAlterations, 'monster-resistancealterations', 'Résistance altérations')}</div>
          </div>

          <!-- Séparation après les stats principales -->
          <hr style="margin: 1rem 0 1.5rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.3;">

          <div style="margin: 1rem 0;">
            <strong>🌟 Armures Élémentaires:</strong>
            <div class="monster-elemental-grid" style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 0.25rem; font-size: 0.8em; margin-top: 0.5rem;">
              <div>${this.buildEditableStatField(this.getElementIcon('Feu'), this.data.armureFeu, 'monster-armurefeu', 'Armure Feu')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Eau'), this.data.armureEau, 'monster-armureeau', 'Armure Eau')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Terre'), this.data.armureTerre, 'monster-armureterre', 'Armure Terre')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Air'), this.data.armureAir, 'monster-armureair', 'Armure Air')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Lumière'), this.data.armureLumiere, 'monster-armurelumiere', 'Armure Lumière')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Nuit'), this.data.armureObscurite, 'monster-armureobscurite', 'Armure Obscurité')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Divin'), this.data.armureDivin, 'monster-armuredivin', 'Armure Divin')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Maléfique'), this.data.armureMalefique, 'monster-armuremalefique', 'Armure Maléfique')}</div>
            </div>
          </div>

          ${this.data.abilites ? `
            <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
            ${this.buildEditableField(this.data.abilites, 'monster-abilites', 'Abilités', { style: 'margin-top: 0.5rem;' })}
          ` : ''}

          ${this.data.butin ? `
            <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
            ${this.buildEditableField(this.data.butin, 'monster-butin', 'Butin', { style: 'margin-top: 0.5rem;' })}
          ` : ''}

          ${this.buildDeleteButton('monster')}
        </div>
      `;
    }

    buildEditableTitle(content, editType, centerAlign = true) {
      const style = centerAlign ? 'margin: 0 0 1rem 0; text-align: center;' : '';
      const spellTitleClass = this.type === 'spell' ? ' spell-title' : '';
      const subclassTitleClass = this.type === 'subclass' ? ' subclass-title' : '';
      const editTypeClass = editType ? ` ${editType}` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <h4 style="${style}" class="editable editable-title${spellTitleClass}${subclassTitleClass}${editTypeClass}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}">${content}</h4>
          ${this.buildEditButton('title')}
        </div>
      `;
    }

    buildEditableField(content, editType, label, options = {}) {
      const style = options.style ? `style="${options.style}"` : '';
      const className = options.className || 'editable-field';
      
      // Add the editType as a class for reliable detection
      const editTypeClass = editType ? ` ${editType}` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable ${className}${editTypeClass}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" ${style}>
            ${content}
          </div>
          ${this.buildEditButton('field')}
        </div>
      `;
    }

    buildEditableStatField(title, value, editType, label, options = {}) {
      const style = options.style ? `style="${options.style}"` : '';
      const className = options.className || 'editable-stat';
      
      // Display the value only as editable, but show title + value visually
      return `
        <div class="editable-section" data-section-type="html">
          <div style="display: flex; align-items: center;">
            <strong style="margin-right: 0.25rem;">${title}:</strong>
            <div class="editable ${className}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" ${style}>
              ${value}
            </div>
          </div>
          ${this.buildEditButton('field')}
        </div>
      `;
    }
    
    buildEditableTagsField(content, editType, label, options = {}) {
      const style = options.style ? `style="${options.style}"` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable editable-tags" data-edit-type="tags" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" ${style}>
            ${content}
          </div>
          ${this.buildEditButton('field')}
        </div>
      `;
    }

    buildEditableEffect(content, editType, label) {
      const editTypeClass = editType ? ` ${editType}` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable editable-effect${editTypeClass}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" style="margin: 1rem 0;">
            ${content}
          </div>
          ${this.buildEditButton('effect')}
        </div>
      `;
    }

    buildEditableList(items, editType, label) {
      // Everything should be HTML format only
      let listHTML;
      if (typeof items === 'string') {
        // HTML string format
        listHTML = items;
      } else {
        // Fallback if somehow still array format - convert once
        if (Array.isArray(items)) {
          listHTML = '<ul>' + items.map(item => '<li>' + item + '</li>').join('') + '</ul>';
        } else {
          listHTML = '<ul><li>Aucune capacité définie</li></ul>';
        }
      }
      
      // Use the editType directly instead of creating compound identifier
      return `
        <h5>${label}</h5>
        <div class="editable-section" data-section-type="html">
          <div class="editable" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}">
            ${listHTML}
          </div>
          ${this.buildEditButton('list')}
        </div>
      `;
    }

    buildStatsSection() {
      // Stats are special - they remain as objects since they're structured data
      // But check if they were converted to HTML string by editing
      let statsHTML;
      
      if (typeof this.data.base === 'string') {
        // Already converted to HTML by editing
        statsHTML = this.data.base;
      } else if (typeof this.data.base === 'object') {
        // Original object format - convert to HTML
        statsHTML = '<div class="chips">' + 
          Object.entries(this.data.base).map(([stat, value]) => {
            const icon = window.StatIcons[stat] || '⚡';
            return '<span class="chip">' + icon + ' ' + stat + ': <strong>' + value + '</strong></span>';
          }).join('') + 
          '</div>';
      } else {
        statsHTML = '<div>Aucune statistique définie</div>';
      }
      
      // Use subclass-stats directly
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable editable-stats" data-edit-type="generic" data-edit-section="subclass-stats" data-item-identifier="${this.data.nom}">
            ${statsHTML}
          </div>
          ${this.buildEditButton('stats')}
        </div>
      `;
    }

    buildSubclassImages() {
      const illusKey1 = `subclass:${this.categoryName}:${this.data.nom}:1`;
      const illusKey2 = `subclass:${this.categoryName}:${this.data.nom}:2`;
      
      return `
        <div class="subclass-images">
          ${this.buildIllustration(illusKey1, `${this.data.nom} (Image 1)`, 'subclass')}
          ${this.buildIllustration(illusKey2, `${this.data.nom} (Image 2)`, 'subclass')}
        </div>
      `;
    }

    buildIllustration(illusKey, altText = '', styleType = 'default') {
      let imageUrl = '';
      let imageStyle = 'display: none;';
      let removeStyle = 'display: none;';
      
      if (window.JdrApp?.modules?.images?.getImageUrl) {
        imageUrl = window.JdrApp.modules.images.getImageUrl(illusKey);
        if (imageUrl) {
          imageUrl = window.JdrApp.modules.images.processImageUrl(imageUrl);
          imageStyle = 'display: inline-block;';
          removeStyle = 'display: inline-flex;';
        }
      }

      let containerClasses = 'illus';
      if (['spell', 'class', 'subclass', 'don', 'objet', 'monster'].includes(styleType)) {
        containerClasses += ` illus-${styleType}`;
      }

      // HYBRID APPROACH: Never generate buttons in standalone, always generate in dev mode
      const isStandalone = window.STANDALONE_VERSION === true;
      
      if (isStandalone) {
        // STANDALONE: Never generate image buttons at all
        return `
          <div class="${containerClasses}" data-illus-key="${illusKey}" data-style-type="${styleType}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb lazy-load" loading="lazy" style="${imageStyle}"${imageUrl ? ` data-src="${imageUrl}"` : ''} src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjE1MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjBmMGYwIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgZmlsbD0iIzk5OSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPkNoYXJnZW1lbnQuLi48L3RleHQ+PC9zdmc+">
          </div>
        `;
      } else {
        // DEV MODE: Always generate buttons, let CSS handle visibility
        return `
          <div class="${containerClasses}" data-illus-key="${illusKey}" data-style-type="${styleType}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
            <label class="up">📷 Ajouter<input accept="image/*" hidden="" type="file"></label>
            <button class="rm" type="button" style="${removeStyle}">🗑 Retirer</button>
          </div>
        `;
      }
    }

    buildSpellElement() {
      return `
        <div class="spell-element-section">
          <div class="spell-element-display" style="text-align: center; margin: 0.5rem 0;">
            <span class="element-badge" style="display: inline-block; padding: 4px 12px; background: var(--accent); color: white; border-radius: 16px; font-size: 0.9em; font-weight: 600;">
              ${this.getElementIcon(this.data.element)} ${this.data.element}
            </span>
          </div>
          <div class="spell-element-selector" style="text-align: center; margin: 0.5rem 0; display: none;">
            <label for="spell-element-${this.data.nom}" style="display: block; margin-bottom: 0.25rem; font-weight: 600;">Élément:</label>
            <select id="spell-element-${this.data.nom}" class="editable" data-edit-type="select" data-edit-section="spell-element" data-item-identifier="${this.data.nom}">
              <option value="Feu" ${this.data.element === 'Feu' ? 'selected' : ''}>${this.getElementIcon('Feu')} Feu</option>
              <option value="Eau" ${this.data.element === 'Eau' ? 'selected' : ''}>${this.getElementIcon('Eau')} Eau</option>
              <option value="Terre" ${this.data.element === 'Terre' ? 'selected' : ''}>${this.getElementIcon('Terre')} Terre</option>
              <option value="Air" ${this.data.element === 'Air' ? 'selected' : ''}>${this.getElementIcon('Air')} Air</option>
              <option value="Lumière" ${this.data.element === 'Lumière' ? 'selected' : ''}>${this.getElementIcon('Lumière')} Lumière</option>
              <option value="Nuit" ${this.data.element === 'Nuit' ? 'selected' : ''}>${this.getElementIcon('Nuit')} Nuit</option>
              <option value="Divin" ${this.data.element === 'Divin' ? 'selected' : ''}>${this.getElementIcon('Divin')} Divin</option>
              <option value="Maléfique" ${this.data.element === 'Maléfique' ? 'selected' : ''}>${this.getElementIcon('Maléfique')} Maléfique</option>
            </select>
          </div>
        </div>
      `;
    }

    buildMonsterElement() {
      const elementColor = this.getElementColor(this.data.element);
      
      return `
        <div class="monster-element-section">
          <div class="monster-element-display">
            <span class="element-badge" style="
              display: inline-flex; 
              align-items: center; 
              padding: 4px 8px; 
              background: rgba(${parseInt(elementColor.slice(1,3), 16)}, ${parseInt(elementColor.slice(3,5), 16)}, ${parseInt(elementColor.slice(5,7), 16)}, 0.1); 
              border-radius: 6px; 
              border: 1px solid ${elementColor};
              font-size: 0.8em;
              font-weight: 600;
            ">
              <span style="margin-right: 4px;">${this.getElementIcon(this.data.element)}</span>
              <span style="color: ${elementColor};">${this.data.element}</span>
            </span>
          </div>
          <div class="monster-element-selector" style="margin-top: 0.5rem; display: none;">
            <select class="editable" data-edit-type="select" data-edit-section="monster-element" data-item-identifier="${this.data.nom}" style="width: 100%; padding: 4px; border: 1px solid ${elementColor}; border-radius: 4px; font-size: 0.8em;">
              <option value="Feu" ${this.data.element === 'Feu' ? 'selected' : ''}>${this.getElementIcon('Feu')} Feu</option>
              <option value="Eau" ${this.data.element === 'Eau' ? 'selected' : ''}>${this.getElementIcon('Eau')} Eau</option>
              <option value="Terre" ${this.data.element === 'Terre' ? 'selected' : ''}>${this.getElementIcon('Terre')} Terre</option>
              <option value="Air" ${this.data.element === 'Air' ? 'selected' : ''}>${this.getElementIcon('Air')} Air</option>
              <option value="Lumière" ${this.data.element === 'Lumière' ? 'selected' : ''}>${this.getElementIcon('Lumière')} Lumière</option>
              <option value="Nuit" ${this.data.element === 'Nuit' ? 'selected' : ''}>${this.getElementIcon('Nuit')} Nuit</option>
              <option value="Divin" ${this.data.element === 'Divin' ? 'selected' : ''}>${this.getElementIcon('Divin')} Divin</option>
              <option value="Maléfique" ${this.data.element === 'Maléfique' ? 'selected' : ''}>${this.getElementIcon('Maléfique')} Maléfique</option>
            </select>
          </div>
        </div>
      `;
    }

    getElementIcon(element) {
      return window.ElementIcons?.[element] || '⚡';
    }

    getElementColor(element) {
      return window.ElementColors?.[element]?.color || '#666';
    }

    buildTableTresorCard() {
      const tableIndex = window.TABLES_TRESORS?.tables ? window.TABLES_TRESORS.tables.indexOf(this.data) : 0;
      const totalTables = window.TABLES_TRESORS?.tables?.length || 1;
      
      // Condition améliorée pour afficher les boutons d'édition des fourchettes
      const shouldShowFourchetteButtons = this.shouldShowEditButtons || 
                                         (!window.STANDALONE_VERSION && window.location.search.includes('dev=1')) ||
                                         (document.body.classList.contains('dev-on')) ||
                                         (window.location.protocol === 'file:' && !window.STANDALONE_VERSION) ||
                                         // Condition de fallback pour le développement
                                         (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1');
      
      // Construire l'affichage des tags
      const tagsDisplay = this.data.tags && this.data.tags.length > 0 
        ? this.data.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';
      
      // Construire l'affichage des fourchettes
      const fourchetteDisplay = this.data.fourchettes?.map((fourchette, index) => {
        const objet = fourchette.objet;
        const objetLink = objet?.type === 'reference' 
          ? `<a href="#" class="object-preview-link" data-object-numero="${objet.numero}" style="color: var(--accent); text-decoration: none;" title="Cliquer pour prévisualiser l'objet #${objet.numero}">📦 ${objet.nom} (N°${objet.numero})</a>`
          : `📦 ${objet?.nom || 'Objet inconnu'}`;
        
        const editButtons = shouldShowFourchetteButtons ? `
          <div class="fourchette-actions" style="margin-left: 8px; display: flex; gap: 4px;">
            ${index > 0 ? `<button class="move-fourchette-up-btn" data-table-name="${this.data.nom}" data-fourchette-index="${index}" title="Déplacer vers le haut" style="background: #059669; color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;">⬆️</button>` : ''}
            ${index < this.data.fourchettes.length - 1 ? `<button class="move-fourchette-down-btn" data-table-name="${this.data.nom}" data-fourchette-index="${index}" title="Déplacer vers le bas" style="background: #059669; color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;">⬇️</button>` : ''}
            <button class="edit-fourchette-btn" data-table-name="${this.data.nom}" data-fourchette-index="${index}" title="Éditer cette fourchette" style="background: #3b82f6; color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;">✏️</button>
            <button class="delete-fourchette-btn" data-table-name="${this.data.nom}" data-fourchette-index="${index}" title="Supprimer cette fourchette" style="background: #dc2626; color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;">🗑️</button>
          </div>
        ` : '';
        
        return `
          <div class="fourchette-row" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; margin: 4px 0; background: rgba(139, 92, 23, 0.1); border-radius: 6px; border-left: 3px solid var(--bronze);">
            <div class="fourchette-range" style="font-weight: bold; color: var(--bronze); min-width: 80px;">
              🎲 ${fourchette.min || 1}-${fourchette.max || 1}
            </div>
            <div class="fourchette-objet" style="flex: 1; margin-left: 12px;">
              ${objetLink}
            </div>
            ${editButtons}
          </div>
        `;
      }).join('') || '<div style="font-style: italic; color: #666; text-align: center; padding: 1rem;">Aucune fourchette définie</div>';

      return `
        <div class="card editable-section" data-section-type="tableTresor" data-table-tresor-name="${this.data.nom}" data-category-name="${this.categoryName}">
          ${this.buildEditableTitle(this.data.nom, 'table-tresor-name')}
          <div style="text-align: center; margin: 0.5rem 0;">
            ${this.buildEditableTagsField(tagsDisplay, 'table-tresor-tags', 'Tags')}
          </div>
          
          <hr style="margin: 1rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.6;">
          
          <div class="fourchettes-section">
            <h4 style="color: var(--bronze); margin: 1rem 0 0.5rem 0; display: flex; align-items: center; gap: 8px;">
              🎲 Fourchettes de butin
            </h4>
            <div class="fourchettes-list">
              ${fourchetteDisplay}
            </div>
          </div>
          
          ${shouldShowFourchetteButtons ? `
            <div class="edit-actions" style="margin-top: 1rem; text-align: center; display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center;">
              <button class="table-tresor-add-fourchette btn" data-table-tresor-name="${this.data.nom}" type="button" style="background: var(--accent); color: white;">
                ➕ Ajouter fourchette
              </button>
              ${this.buildMoveButtons('table-tresor', tableIndex, totalTables)}
            </div>
            ${this.buildDeleteButton('table-tresor')}
          ` : ''}
        </div>
      `;
    }

    buildObjetCard() {
      const favorisButtonHTML = this.buildFavorisButton('objets', this.data.nom);
      
      // Build tags display
      const tagsDisplay = this.data.tags && this.data.tags.length > 0
        ? this.data.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';
      
      return `
        <div class="card editable-section objet-card" data-section-type="objet" data-objet-name="${this.data.nom}" data-numero="${this.data.numero}" data-object-numero="${this.data.numero}" data-category-name="${this.categoryName}">
          ${favorisButtonHTML}
          ${this.buildEditableTitle(this.data.nom, 'objet-name')}
          ${this.data.numero ? `<div style="text-align: center; font-weight: bold; color: var(--bronze); margin-bottom: 0.5rem;">N°${this.data.numero}</div>` : ''}
          
          ${this.buildIllustration(`objet:${this.data.nom}`, this.data.nom, 'objet')}
          
          <div style="text-align: center; margin: 0.5rem 0;">
            ${this.buildEditableTagsField(tagsDisplay, 'objet-tags', 'Tags')}
          </div>
          
          ${this.buildEditableField(this.data.description, 'objet-description', 'Description', { style: 'text-align: center; font-style: italic; margin: 1rem 0;' })}
          
          <hr style="margin: 1rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.6;">
          
          ${this.buildEditableField(this.data.effet, 'objet-effet', 'Effet', { style: 'margin: 1rem 0;' })}
          
          <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 1rem; font-size: 0.9em;">
            ${this.data.prix ? `<div>${this.buildEditableField(this.data.prix, 'objet-prix', 'Prix')}</div>` : ''}
            ${this.data.poids ? `<div>${this.buildEditableField(this.data.poids, 'objet-poids', 'Poids')}</div>` : ''}
          </div>
          
          ${this.buildDeleteButton('objet')}
        </div>
      `;
    }

    buildGenericCard() {
      return `
        <div class="card">
          <h4>${this.data.nom || 'Unknown'}</h4>
          <p>Generic card for type: ${this.type}</p>
        </div>
      `;
    }

    buildEditButton(buttonType) {
      return `<button class="edit-btn" type="button" title="✏️ Éditer" data-button-type="${buttonType}">✏️</button>`;
    }

    buildDeleteButton(type) {
      const config = this.config;
      const deleteIcon = config?.icons?.delete || '🗑️';
      
      return `
        <div class="delete-button-container" style="margin-top: 1rem; text-align: center;">
          <button class="${type}-delete btn" data-${type}-name="${this.data.nom}" ${this.categoryName ? `data-category-name="${this.categoryName}"` : ''} type="button" style="background: #dc2626; color: white; border: 2px solid #b91c1c;">
            ${deleteIcon} Supprimer ${type}
          </button>
        </div>
      `;
    }

    buildMoveButtons(type, index, totalItems) {
      if (totalItems <= 1) {
        return '';
      }

      return `
        <div class="move-buttons" style="display: flex; gap: 0.5rem; justify-content: center; margin-top: 1rem;">
          <button class="${type}-move-up btn small" data-${type}-name="${this.data.nom}" data-category-name="${this.categoryName}" type="button" style="background: #3b82f6; color: white; padding: 4px 8px; font-size: 0.8em;" ${index === 0 ? 'disabled' : ''}>
            ↑ Haut
          </button>
          <button class="${type}-move-down btn small" data-${type}-name="${this.data.nom}" data-category-name="${this.categoryName}" type="button" style="background: #3b82f6; color: white; padding: 4px 8px; font-size: 0.8em;" ${index >= totalItems - 1 ? 'disabled' : ''}>
            ↓ Bas
          </button>
        </div>
      `;
    }

    getCategoryData() {
      if (this.type === 'don' && this.categoryName) {
        const categoryData = window.DONS.find(cat => cat.nom === this.categoryName);
        return categoryData || { dons: [] };
      }
      return { [this.type + 's']: [] };
    }

    /**
     * Construit le bouton étoile pour les favoris
     * @param {string} type - Type de contenu ('sorts' ou 'objets')
     * @param {string} nom - Nom de l'élément
     * @returns {string} HTML du bouton favoris
     */
    buildFavorisButton(type, nom) {
      // Vérifier que le FavorisManager est disponible
      if (typeof window.FavorisManager === 'undefined') {
        return '';
      }
      
      return window.FavorisManager.createStarButton(type, nom);
    }
  }

  window.CardBuilder = CardBuilder;

})();
// ============================================================================
// JDR-BAB APPLICATION - PAGE BUILDER
// ============================================================================

(() => {
  "use strict";

  class PageBuilder {
    constructor() {
      // Will use unified dev mode check
    }

    // Simple unified dev mode check
    get shouldShowEditButtons() {
      return JdrApp.utils.isDevMode();
    }

    static getInstance() {
      if (!PageBuilder.instance) {
        PageBuilder.instance = new PageBuilder();
      }
      return PageBuilder.instance;
    }

    buildCategoryPage(type, category) {
      const config = window.ContentTypes[type];
      
      // Gestion spéciale pour les objets (page unique avec filtres)
      if (type === 'objet' && config.pageType === 'single') {
        return this.buildSingleObjectPage(category);
      }
      
      // Gestion spéciale pour les tables de trésors (page unique)
      if (type === 'tableTresor' && config.pageType === 'single') {
        return this.buildSingleTableTresorPage(category);
      }
      
      const pageId = `${config.container}-${this.sanitizeId(category.nom || 'unknown')}`;
      const itemsProperty = this.getItemsProperty(type);
      
      // Get items and sort them for spells
      let items = category[itemsProperty] || [];
      if (type === 'spell') {
        items = this.sortSpellsByLevel([...items]);
      }

      return `
        <article class="" data-page="${pageId}">
          <section>
            ${this.buildCategoryHeader(category, type)}
            ${type === 'spell' ? this.buildSpellLevelFilter() : ''}
            <div style="display: flex; gap: 8px; margin-bottom: 1rem; flex-wrap: wrap;">
              ${this.buildAddButton(type, category.nom)}
              ${this.buildDeleteCategoryButton(type, category.nom)}
            </div>
            <div class="grid cols-2" id="${config.container}-container-${this.sanitizeId(category.nom)}">
              ${items.map((item, index) => 
                CardBuilder.create(type, item, category.nom, index).build()
              ).join('')}
            </div>
            ${this.buildGeneralDonsSection(type, category.nom)}
          </section>
        </article>
      `;
    }
    
    buildSingleObjectPage(objectData) {
      const allObjects = objectData.objets || [];
      
      // Objects page now only shows ID search - all objects hidden by default
      return `
        <article class="" data-page="objets">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2>📦 Objets</h2>
              ${this.buildIllustration('page:objets')}
            </div>
            
            ${this.buildPageDescription('objet')}
            
            ${this.buildIdSearchFilter()}
            
            <div class="grid cols-2" id="objets-container">
              ${allObjects.map((item, index) => {
                const cardHTML = CardBuilder.create('objet', item, 'objets', index).build();
                // Hide all objects by default - only ID search will show them
                return cardHTML.replace('<div class="card', '<div class="card" style="display: none;"');
              }).join('')}
            </div>
            
            ${!window.activeIdSearch ? '<p style="text-align: center; color: #666; margin: 2rem 0;">Utilisez la recherche par ID ci-dessus pour trouver un objet spécifique.</p>' : ''}
          </section>
        </article>
      `;
    }

    buildGameMasterObjectPage(objectData) {
      const config = window.ContentTypes['objet'];
      const allObjects = objectData.objets || [];
      const availableTags = config?.filterConfig?.availableTags || [];
      
      // Initialize active tags for GM page
      if (!window.ACTIVE_GM_OBJECT_TAGS) {
        window.ACTIVE_GM_OBJECT_TAGS = [];
      }
      const activeTags = window.ACTIVE_GM_OBJECT_TAGS;
      
      // Filter objects based on active tags
      const filteredObjects = activeTags.length === 0 
        ? allObjects // No tags active = show all objects
        : allObjects.filter(obj => {
            // AND logic - object must have ALL active tags
            if (!obj.tags || obj.tags.length === 0) return false;
            return activeTags.every(activeTag => obj.tags.includes(activeTag));
          });
      
      
      const result = `
        <article class="" data-page="gestion-objets">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2>📦 Gestion des Objets</h2>
              ${this.buildIllustration('page:gestion-objets')}
            </div>
            
            <div style="margin: 1rem 0; padding: 1rem; background: var(--card); border-radius: 8px; border-left: 4px solid var(--bronze);">
              <p class="lead">Page dédiée au Maître de jeu pour gérer, créer et modifier les objets du jeu. Utilisez les filtres pour organiser votre contenu et les outils de création pour ajouter de nouveaux équipements.</p>
            </div>
            
            ${this.buildIdSearchFilter()}
            ${this.buildGMTagFilters(activeTags, availableTags)}
            
            <div style="display: flex; gap: 8px; margin-bottom: 1rem; flex-wrap: wrap;">
              ${this.buildAddButton('objet', 'objets')}
              ${this.buildTagsManagerButton()}
            </div>
            
            <div class="grid cols-2" id="gestion-objets-container">
              ${filteredObjects.map((item, index) => 
                CardBuilder.create('objet', item, 'objets', index).build()
              ).join('')}
            </div>
            
            ${filteredObjects.length === 0 ? '<p style="text-align: center; color: #666; margin: 2rem 0;">Aucun objet ne correspond aux filtres sélectionnés.</p>' : ''}
          </section>
        </article>
      `;
      
      return result;
    }

    buildSingleMonsterPage(monsterData) {
      let config = window.ContentTypes?.['monster'];
      const allMonsters = monsterData || [];
      const instance = PageBuilder.getInstance(); // Créer une instance pour accéder aux méthodes
      
      // Defensive check for config with fallback
      if (!config || !config.filterConfig) {
        console.warn('Monster config not loaded, using fallback defaults');
        console.log('ContentTypes available:', window.ContentTypes ? Object.keys(window.ContentTypes) : 'undefined');
        config = {
          filterConfig: {
            defaultVisibleTags: ['Forêt'],
            availableTags: ['Forêt', 'Boss', 'Minion', 'Volant', 'Aquatique', 'Terrestre']
          }
        };
      }
      
      // Utiliser le state du filtre s'il existe, sinon les tags par défaut
      const visibleTags = window.MONSTRES_FILTER_STATE?.visibleTags || config.filterConfig.defaultVisibleTags;
      
      // Filter monsters according to visible tags (AND mode)
      const filteredMonsters = visibleTags.length === 0 
        ? [] // If no tags are visible, show nothing
        : allMonsters.filter(monster => {
            // Check that the monster has the required tags to be visible
            if (!monster.tags) return false;
            
            // In AND mode: monster must have ALL visible tags
            const hasAllVisibleTags = visibleTags.every(tag => monster.tags.includes(tag));
            if (!hasAllVisibleTags) return false;
            
            return true;
          });
      
      return `
        <article class="" data-page="monstres">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2>🐲 Monstres</h2>
              ${instance.buildIllustration('page:monstres')}
            </div>
            
            ${instance.buildPageDescription('monster')}
            
            ${instance.buildTagFilters(visibleTags, config.filterConfig.availableTags, 'monster')}
            
            <div style="display: flex; gap: 8px; margin-bottom: 1rem; flex-wrap: wrap;">
              ${instance.buildAddButton('monster', 'monstres')}
              ${instance.buildTagsManagerButton()}
            </div>
            
            <div class="grid cols-2" id="monstres-container">
              ${filteredMonsters.map((item, index) => 
                CardBuilder.create('monster', item, 'monstres', index).build()
              ).join('')}
            </div>
            
            ${filteredMonsters.length === 0 ? '<p style="text-align: center; color: #666; margin: 2rem 0;">Aucun monstre ne correspond aux filtres sélectionnés.</p>' : ''}
          </section>
        </article>
      `;
    }

    buildClassPage(classData) {
      const pageId = this.sanitizeId(classData.nom);
      
      return `
        <article class="" data-page="${pageId}" data-page-title="${classData.nom}">
          <section>
            ${this.buildClassHeader(classData)}
            ${this.buildEditableSection(classData.resume, 'class-resume', 'paragraph', classData.nom)}
            <h3>Capacités de classe</h3>
            ${this.buildSimpleEditableContent(classData.capacites, 'class-capacites', classData.nom)}
            <h3>Sous-classes</h3>
            <div class="subclass-stack">
              ${classData.sousClasses ? classData.sousClasses.map(sousClasse => 
                CardBuilder.create('subclass', sousClasse, classData.nom).build()
              ).join('') : ''}
            </div>
            ${this.buildAddSubclassButton()}
          </section>
        </article>
      `;
    }

    buildStaticPage(pageId, pageData) {
      const isActive = pageId === 'creation' ? 'active' : '';
      
      // Defense against missing or malformed pageData
      if (!pageData || typeof pageData !== 'object') {
        console.warn('buildStaticPage: invalid pageData', pageData);
        return `<article class="${isActive}" data-page="${pageId}"><section><h2>Page non disponible</h2><p>Les données de cette page ne sont pas disponibles.</p></section></article>`;
      }
      
      const title = pageData.title || pageId;
      const page = pageData.page || pageId;
      
      // Special handling for favoris page
      if (pageId === 'favoris') {
        return this.buildFavorisPage(pageId, pageData);
      }
      
      // Special handling for campaign page
      if (pageId === 'campagne') {
        return this.buildCampaignPage(pageId, pageData);
      }
      
      return `
        <article class="${isActive}" data-page="${page}" data-static-page="true" data-page-title="${title}">
          <section>
            ${this.buildStaticPageHeader(pageData)}
            ${this.buildSections(pageData.sections)}
            ${this.buildAddSectionButton()}
          </section>
        </article>
      `;
    }

    buildCategoryHeader(category, type) {
      const config = window.ContentTypes[type];
      
      // Don't show descriptions for spell categories
      const showDescription = type !== 'spell';
      
      return `
        <div style="text-align:center;margin-bottom:2rem;">
          ${this.buildEditableTitle(category.nom, `${type}-category-name`)}
          ${this.buildIllustration(`${type}category:${category.nom}`)}
        </div>
        ${showDescription ? this.buildEditableSection(category.description, `${type}-category-description`, 'paragraph', category.nom) : ''}
      `;
    }

    buildClassHeader(classData) {
      return `
        <div style="text-align:center;margin-bottom:2rem;">
          ${this.buildEditableTitle(classData.nom, 'class-name', classData.nom)}
          ${this.buildIllustration(`class:${classData.nom}`)}
        </div>
      `;
    }

    buildStaticPageHeader(pageData) {
      const printButton = pageData.page === 'etats' ? this.buildPrintButton() : '';
      
      return `
        <div style="text-align:center;margin-bottom:2rem;">
          <div style="display:inline-flex;align-items:center;gap:8px;">
            <h2 class="editable editable-title" data-edit-type="generic" data-edit-section="page-title">${pageData.title}</h2>
            ${this.buildEditButton('title')}
          </div>
          ${this.buildIllustration(`page:${pageData.page}`)}
          ${printButton}
        </div>
      `;
    }

    buildCompactCampaignHeader(pageData) {
      return `
        <div style="text-align:center;margin-bottom:0.5rem;">
          <div style="display:inline-flex;align-items:center;gap:8px;">
            <h2 class="editable editable-title" data-edit-type="generic" data-edit-section="page-title">${pageData.title}</h2>
            ${this.buildEditButton('title')}
          </div>
        </div>
      `;
    }

    buildEditableTitle(content, editType, editSection = null) {
      return `
        <div style="display:inline-flex;align-items:center;gap:8px;justify-content:center;">
          <h2 class="editable editable-title" data-edit-type="generic" data-edit-section="${editSection || content}">${content}</h2>
          ${this.buildEditButton('title')}
        </div>
      `;
    }

    buildEditableSection(content, editType, sectionType, editSection) {
      const className = sectionType === 'paragraph' ? 'lead editable editable-paragraph' : 'editable editable-field';
      
      return `
        <div class="editable-section" data-section-type="${editType}">
          <p class="${className}" data-edit-type="generic" data-edit-section="${editSection}">${content}</p>
          ${this.buildEditButton(sectionType)}
        </div>
      `;
    }


    buildSimpleEditableContent(content, editType, editSection) {
      // Everything should be HTML format only
      let htmlContent;
      if (typeof content === 'string') {
        htmlContent = content || '';
      } else {
        // Fallback if somehow still array format - convert once and warn
        console.warn('Found array format in buildSimpleEditableContent, converting to HTML:', content);
        if (Array.isArray(content)) {
          htmlContent = '<ul>' + content.map(item => '<li>' + item + '</li>').join('') + '</ul>';
        } else {
          htmlContent = '';
        }
      }
      
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable" data-edit-type="generic" data-edit-section="${editSection}">
            ${htmlContent}
          </div>
          ${this.buildEditButton('section')}
        </div>
      `;
    }

    buildSections(sections) {
      // Defense against undefined sections
      if (!sections || !Array.isArray(sections)) {
        console.warn('buildSections: sections is not an array', sections);
        return '';
      }
      
      return sections.map((section, sectionIndex) => {
        switch (section.type) {
          case 'intro':
            return this.buildIntroSection(section, sectionIndex);
          case 'card':
            return this.buildCardSection(section, sectionIndex);
          case 'grid':
            return this.buildGridSection(section, sectionIndex);
          case 'filters':
            return this.buildFiltersSection(section, sectionIndex);
          case 'monster-list':
            return this.buildMonsterListSection(section, sectionIndex);
          default:
            return `<div><!-- Unknown section type: ${section.type} --></div>`;
        }
      }).join('');
    }

    buildIntroSection(section, sectionIndex) {
      const editSection = `intro-${sectionIndex}`;
      return `
        <div class="editable-section" data-section-type="intro" data-section-index="${sectionIndex}">
          <p class="editable editable-intro" data-edit-type="generic" data-edit-section="${editSection}">${section.content}</p>
          ${this.buildEditButton('section')}
        </div>
        ${this.buildAddParagraphButton('intro')}
      `;
    }

    buildCardSection(cardData, sectionIndex) {
      let cardHTML = `<div class="card editable-section" data-section-type="card" data-section-index="${sectionIndex}">`;
      
      if (cardData.deletable && cardData.sectionType) {
        cardHTML += `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${cardData.id}-title">${cardData.title}</h3>
            ${this.buildEditButton('title')}
            ${this.buildRemoveSectionButton(cardData.sectionType)}
          </div>
        `;
      } else {
        cardHTML += `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${cardData.id}-title">${cardData.title}</h3>
            ${this.buildEditButton('title')}
          </div>
        `;
      }

      // Handle different content formats
      let htmlContent = '';
      let editSection = cardData.id || 'card-' + sectionIndex;
      
      if (typeof cardData.content === 'string') {
        // Direct HTML string
        htmlContent = cardData.content;
      } else if (typeof cardData.content === 'object' && cardData.content?.content) {
        // Object with nested content property
        htmlContent = cardData.content.content;
        if (cardData.content.editSection) {
          editSection = cardData.content.editSection;
        }
      } else {
        htmlContent = cardData.content || '';
      }
      
      cardHTML += `
        <div style="position:relative;">
          <div class="editable" data-edit-type="generic" data-edit-section="${editSection}">${htmlContent}</div>
          ${this.buildEditButton('section')}
        </div>
      `;

      if (cardData.deletable && cardData.sectionName) {
        // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
        cardHTML += `
          <div style="margin-top: 1rem; text-align: center;">
            <button class="section-delete btn small" data-section-name="${cardData.sectionName}" type="button" style="background: #ff6b6b; color: white;">🗑 Supprimer section</button>
          </div>
        `;
      }
      
      cardHTML += `</div>`;
      return cardHTML;
    }


    buildContentItem(item) {
      if (item.type === 'paragraph') {
        const content = `
          <div class="editable-section" data-section-type="paragraph">
            <p class="editable editable-paragraph" data-edit-type="generic" data-edit-section="${item.editSection}">${item.content}</p>
            ${this.buildEditButton('paragraph')}
          </div>
        `;
        const addBtn = this.buildAddParagraphButton(item.editSection);
        return content + addBtn;
      }
      return `<div>${item.content}</div>`;
    }

    buildGridSection(gridSection, sectionIndex) {
      const items = gridSection.content || gridSection.items || [];
      if (!Array.isArray(items)) {
        return '<div><!-- Grid items is not an array --></div>';
      }

      const cols = gridSection.cols || 2;
      let gridHTML = `<div class="grid" style="display: grid; grid-template-columns: repeat(${cols}, 1fr); gap: 1rem;">`;
      
      items.forEach((item, itemIndex) => {
        gridHTML += this.buildCardSection(item, `${sectionIndex}-${itemIndex}`);
      });
      
      gridHTML += '</div>';
      return gridHTML;
    }

    buildComplexContent(content) {
      // Generic HTML content - no special processing
      return content || '';
    }


    buildIllustration(illusKey, altText = '') {
      let imageUrl = '';
      let imageStyle = 'display: none;';
      let removeStyle = 'display: none;';
      
      if (window.JdrApp?.modules?.images?.getImageUrl) {
        imageUrl = window.JdrApp.modules.images.getImageUrl(illusKey);
        if (imageUrl) {
          imageUrl = window.JdrApp.modules.images.processImageUrl(imageUrl);
          imageStyle = 'display: inline-block;';
          removeStyle = 'display: inline-flex;';
        }
      }

      // HYBRID APPROACH: Never generate buttons in standalone, always generate in dev mode
      const isStandalone = window.STANDALONE_VERSION === true;
      
      if (isStandalone) {
        // STANDALONE: Never generate image buttons at all
        return `
          <div class="illus" data-illus-key="${illusKey}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
          </div>
        `;
      } else {
        // DEV MODE: Always generate buttons, let CSS handle visibility
        return `
          <div class="illus" data-illus-key="${illusKey}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
            <label class="up">📷 Ajouter<input accept="image/*" hidden="" type="file"></label>
            <button class="rm" type="button" style="${removeStyle}">🗑 Retirer</button>
          </div>
        `;
      }
    }

    buildFiltersSection(section, sectionIndex) {
      const contentType = section.contentType || 'monster';
      
      // Ensure ContentTypes is loaded
      if (!window.ContentTypes) {
        console.warn('ContentTypes not loaded yet, skipping filters');
        return '';
      }
      
      let config = window.ContentTypes[contentType];
      const filterMode = section.filterMode || 'OR';
      
      // Fallback configuration for monster if not loaded
      if (!config && contentType === 'monster') {
        config = {
          filterConfig: {
            availableTags: ["Foret", "Animal", "Humanoid", "Dragon", "Faible", "Puissant", "Boss", "Feu", "Eau", "Terre", "Air", "Rapide", "Poison"],
            defaultVisibleTags: ["Foret", "Animal", "Humanoid"]
          }
        };
      }
      
      if (!config || !config.filterConfig) {
        return '';
      }
      
      const availableTags = config.filterConfig.availableTags || [];
      const defaultTags = config.filterConfig.defaultVisibleTags || [];
      
      return `
        <div class="filter-section" data-content-type="${contentType}" data-filter-mode="${filterMode}">
          <h3>🔍 Filtres (${filterMode === 'AND' ? 'ET' : 'OU'})</h3>
          <div class="filter-tags" data-default-tags='${JSON.stringify(defaultTags)}'>
            ${availableTags.map(tag => `
              <label class="filter-tag ${defaultTags.includes(tag) ? 'active' : ''}">
                <input type="checkbox" value="${tag}" ${defaultTags.includes(tag) ? 'checked' : ''}>
                <span>${tag}</span>
              </label>
            `).join('')}
          </div>
          ${this.buildDevModeButtons(contentType)}
        </div>
      `;
    }

    buildMonsterListSection(section, sectionIndex) {
      const contentType = section.contentType || 'monster';
      
      return `
        <div class="monster-list-section" data-content-type="${contentType}">
          <div class="monsters-grid" id="monsters-container">
            <!-- Les monstres seront générés par JavaScript -->
          </div>
        </div>
      `;
    }

    buildDevModeButtons(contentType) {
      // Ensure ContentTypes is loaded for proper button generation
      if (!window.ContentTypes) {
        return '';
      }
      
      // For monster type, generate buttons even if config is missing (they'll work with fallback)
      if (contentType !== 'monster' && !window.ContentTypes[contentType]) {
        return '';
      }
      
      // Use the same approach as modal buttons - conditional rendering based on dev mode
      const isDevMode = JdrApp.utils.isDevMode();
      const displayStyle = isDevMode ? 'block' : 'none';
      
      return `
        <div class="dev-mode-buttons" style="margin-top: 1rem; display: ${displayStyle};" data-dev-only="true">
          <button class="btn btn-small add-${contentType}-btn">➕ Ajouter ${contentType === 'monster' ? 'un monstre' : 'un élément'}</button>
          <button class="btn btn-small manage-tags-btn" data-content-type="${contentType}">🏷️ Gérer les tags</button>
        </div>
      `;
    }

    buildEditButton(type) {
      const titles = {
        title: 'Éditer le titre',
        paragraph: 'Éditer ce paragraphe',
        field: 'Éditer ce champ',
        list: 'Éditer cette liste',
        section: 'Éditer cette section'
      };

      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="edit-btn edit-${type}-btn" title="${titles[type] || 'Éditer'}">✏️</button>`;
    }

    buildAddButton(type, categoryName) {
      const config = window.ContentTypes[type];
      const icon = config?.icons?.add || '➕';
      
      // ALWAYS generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="${type}-add btn" data-category-name="${categoryName}" type="button" style="background: var(--accent); color: white;">${icon} Ajouter un ${type === 'spell' ? 'sort' : type === 'don' ? 'don' : type === 'monster' ? 'monstre' : 'élément'}</button>`;
    }

    buildDeleteCategoryButton(type, categoryName) {
      const config = window.ContentTypes[type];
      const deleteIcon = config?.icons?.delete || '🗑️';
      
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="${type}-category-delete btn" data-category-name="${categoryName}" data-category-type="${type}" type="button" style="background: #dc2626; color: white;">${deleteIcon} Supprimer catégorie</button>`;
    }

    buildAddSubclassButton() {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<div class="add-subclass-btn">➕ Ajouter une sous-classe</div>`;
    }

    buildAddSectionButton() {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<div class="add-paragraph-btn" data-target="section">➕ Ajouter une nouvelle section</div>`;
    }

    buildAddParagraphButton(target) {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<div class="add-paragraph-btn" data-target="${target}">➕ Ajouter un paragraphe</div>`;
    }

    buildRemoveSectionButton(sectionType) {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="remove-section-btn" data-section-type="${sectionType}" type="button" style="background: #dc2626; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 12px;">🗑 Supprimer section</button>`;
    }

    getItemsProperty(type) {
      switch (type) {
        case 'spell': return 'sorts';
        case 'don': return 'dons';
        case 'objet': return 'objets';
        case 'class': return 'sousClasses';
        default: return 'items';
      }
    }

    // Extract level number from prerequis text
    extractLevelFromPrerequisite(prerequis) {
      if (!prerequis) return 0;
      const match = prerequis.match(/Niveau (\d+)/i);
      return match ? parseInt(match[1], 10) : 0;
    }

    // Sort spells by level (prerequisite level)
    sortSpellsByLevel(spells) {
      return spells.sort((a, b) => {
        const levelA = this.extractLevelFromPrerequisite(a.prerequis);
        const levelB = this.extractLevelFromPrerequisite(b.prerequis);
        return levelA - levelB;
      });
    }

    // Build spell level filter UI
    buildSpellLevelFilter() {
      return `
        <div class="spell-level-filter" style="margin: 1rem 0; padding: 1rem; background: var(--card); border: 2px solid var(--rule); border-radius: 12px;">
          <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
            <label style="font-weight: 600; color: var(--accent-ink);">
              🎯 Filtrer par niveau maximum :
            </label>
            <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
              <input 
                type="number" 
                id="spell-level-filter" 
                min="0" 
                max="20" 
                value="20"
                style="width: 80px; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px; text-align: center; font-weight: 600;"
              >
              <button 
                id="reset-spell-filter" 
                class="btn small" 
                style="background: var(--bronze); color: white; padding: 0.5rem 1rem;"
                title="Réinitialiser le filtre"
              >
                🔄 Tout afficher
              </button>
              <!-- Texte du filtre ajouté dynamiquement par SpellFilter.js -->
            </div>
          </div>
        </div>
      `;
    }

    buildIdSearchFilter() {
      const isIdSearchActive = window.activeIdSearch || false;
      const isDevMode = JdrApp.utils.isDevMode();
      const searchBorderColor = isIdSearchActive ? '#16a34a' : 'var(--rule)';
      const searchBoxShadow = isIdSearchActive ? 'box-shadow: 0 0 8px rgba(22, 163, 74, 0.3);' : '';
      const searchIndicator = isIdSearchActive ? '🎯 ' : '🔍 ';
      const buttonText = isIdSearchActive ? '🔄 Affichage normal' : '🔄 Tout afficher';
      const buttonTitle = isIdSearchActive ? 'Retourner à l\'affichage normal avec filtres' : 'Effacer la recherche et afficher tous les objets';
      
      return `
        <div class="id-search-filter" style="margin: 0.5rem 0; background: var(--card); border: 2px solid ${searchBorderColor}; border-radius: 12px; display: flex; flex-direction: column; ${searchBoxShadow}">
          <div style="display: flex; align-items: center; justify-content: center; gap: 1rem; flex-wrap: wrap; padding: 0.375rem; min-height: 2.5rem;">
            <label for="id-search-input" style="font-weight: 600; color: var(--accent-ink); white-space: nowrap; display: flex; align-items: center; height: 100%;">
              ${searchIndicator}Recherche par ID :
            </label>
            <div style="display: flex; align-items: center; gap: 0.5rem; height: 100%;">
              <input 
                type="number" 
                id="id-search-input" 
                min="1" 
                placeholder="Numéro d'objet (ex: 42)"
                style="padding: 0.2rem; border: 1px solid ${searchBorderColor}; border-radius: 6px; font-size: 0.95em; width: 150px; height: 2rem; display: flex; align-items: center;"
              >
              <button 
                id="search-object-btn" 
                class="btn small" 
                style="background: var(--primary-color); color: white; padding: 0.2rem 0.4rem; white-space: nowrap; font-size: 0.9em; display: flex; align-items: center; height: 2rem; justify-content: center;"
                title="Rechercher cet objet"
              >
                🔍 Chercher
              </button>
              <button 
                id="clear-id-search" 
                class="btn small" 
                style="background: var(--bronze); color: white; padding: 0.2rem 0.4rem; white-space: nowrap; font-size: 0.9em; display: ${!isDevMode ? 'none' : 'flex'}; align-items: center; height: 2rem; justify-content: center;"
                title="${buttonTitle}"
              >
                ${buttonText}
              </button>
            </div>
          </div>
          <div id="id-search-result" style="padding: 0 0.375rem 0.375rem; font-size: 0.85em; color: var(--paper-muted); min-height: 0.5em; line-height: 1.2; text-align: center;">
            <!-- Résultat de la recherche affiché ici -->
          </div>
        </div>
      `;
    }

    buildPageDescription(type) {
      const config = window.ContentTypes[type];
      
      if (!config || !config.pageDescription) {
        return '';
      }
      
      const pageDesc = config.pageDescription;
      
      // Obtenir la description de manière unifiée
      let description = '';
      
      if (pageDesc.dataSource === 'external') {
        // Utilisation d'un fichier externe via dataKey
        const dataObj = window[pageDesc.dataKey];
        if (!dataObj) {
          // Créer l'objet externe s'il n'existe pas
          window[pageDesc.dataKey] = { [pageDesc.storageKey]: pageDesc.defaultValue };
        }
        description = window[pageDesc.dataKey][pageDesc.storageKey] || pageDesc.defaultValue;
      } else {
        // Source de données intégrée dans le dataKey principal
        const mainDataKey = config.dataKey;
        const mainData = window[mainDataKey];
        
        if (!mainData) {
          console.warn(`Main data key ${mainDataKey} not found for type ${type}`);
          description = pageDesc.defaultValue;
        } else {
          // Initialiser la description si elle n'existe pas
          if (!mainData[pageDesc.storageKey]) {
            mainData[pageDesc.storageKey] = pageDesc.defaultValue;
          }
          description = mainData[pageDesc.storageKey];
        }
      }
      
      const cssClass = `${type}-category-description`;
      const sectionType = `${type}-category-description`;
      
      return `
        <div class="${cssClass}" style="margin: 1rem 0; padding: 1rem; background: var(--card); border-radius: 8px; border-left: 4px solid var(--bronze);">
          <div class="editable-section" data-section-type="${sectionType}">
            <p class="lead editable editable-paragraph" data-edit-type="generic" data-edit-section="${pageDesc.editSection}">${description}</p>
            ${this.buildEditButton('section')}
          </div>
        </div>
      `;
    }

    buildTagFilters(activeTags, availableTags, context = 'objet') {
      if (!availableTags || availableTags.length === 0) {
        return '';
      }

      const filterTitle = context === 'monster' ? '🎯 Filtrer les monstres par tags :' : 
                         context === 'tableTresor' ? '🎯 Filtrer les tables par tags :' : 
                         '🎯 Filtrer par tags :';

      return `
        <div class="tag-filters" style="margin: 1rem 0; padding: 1rem; background: var(--card); border: 2px solid var(--rule); border-radius: 12px;">
          <div style="margin-bottom: 1rem;">
            <h4 style="margin: 0 0 0.5rem 0; color: var(--accent-ink); font-size: 1em;">
              ${filterTitle}
            </h4>
            <p style="margin: 0; font-size: 0.85em; color: var(--paper-muted); font-style: italic;">
              Cliquez sur les tags pour filtrer le contenu
            </p>
          </div>
          <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
            ${availableTags.map(tag => {
              const isActive = activeTags && activeTags.includes(tag);
              const bgColor = isActive ? '#16a34a' : '#6b7280';
              const opacity = isActive ? '1' : '0.6';
              const prefix = isActive ? '✓ ' : '';
              
              return `
                <button 
                  class="filter-chip" 
                  data-tag="${tag}"
                  style="
                    padding: 0.25rem 0.75rem;
                    border: none;
                    border-radius: 20px;
                    background: ${bgColor};
                    color: white;
                    opacity: ${opacity};
                    font-size: 0.85em;
                    cursor: pointer;
                    transition: all 0.2s ease;
                  "
                  title="${isActive ? 'Cliquez pour désactiver' : 'Cliquez pour activer'}"
                >
                  ${prefix}${tag}
                </button>
              `;
            }).join('')}
          </div>
        </div>
      `;
    }

    buildGMTagFilters(activeTags, availableTags) {
      if (!availableTags || availableTags.length === 0) {
        return '';
      }

      return `
        <div class="gm-tag-filters" style="margin: 1rem 0; padding: 1rem; background: var(--card); border: 2px solid var(--bronze); border-radius: 12px;">
          <div style="margin-bottom: 1rem;">
            <h4 style="margin: 0 0 0.5rem 0; color: var(--accent-ink); font-size: 1em;">
              🎯 Filtrer les objets par tags (Mode GM) :
            </h4>
            <p style="margin: 0; font-size: 0.85em; color: var(--paper-muted); font-style: italic;">
              Cliquez sur les tags pour filtrer les objets. Logique ET (tous les tags sélectionnés requis).
            </p>
          </div>
          <div style="display: flex; flex-wrap: wrap; gap: 0.5rem;">
            ${availableTags.map(tag => {
              const isActive = activeTags && activeTags.includes(tag);
              const bgColor = isActive ? '#16a34a' : '#6b7280';
              const opacity = isActive ? '1' : '0.6';
              const prefix = isActive ? '✓ ' : '';
              
              return `
                <button 
                  class="gm-filter-chip" 
                  data-tag="${tag}"
                  style="
                    padding: 0.25rem 0.75rem;
                    border: none;
                    border-radius: 20px;
                    background: ${bgColor};
                    color: white;
                    opacity: ${opacity};
                    font-size: 0.85em;
                    cursor: pointer;
                    transition: all 0.2s ease;
                  "
                  title="${isActive ? 'Cliquez pour désactiver' : 'Cliquez pour activer'}"
                >
                  ${prefix}${tag}
                </button>
              `;
            }).join('')}
          </div>
        </div>
      `;
    }
    
    // SUPPRIMÉ: buildFilterManagerButton - fonctionnalité retirée

    buildTagsManagerButton() {
      // Only show in dev mode - use direct utils check
      if (!JdrApp.utils.isDevMode()) {
        return '';
      }
      return `<button class="tags-manager-btn btn" type="button" style="background: #dc2626; color: white; border: 2px solid #b91c1c;">🏷️ Gérer les tags</button>`;
    }

    buildGeneralDonsSection(type, categoryName) {
      // Only add General Dons section for 'don' type pages, and not for the 'Generaux' category itself
      if (type !== 'don' || categoryName === 'Generaux') {
        return '';
      }

      // Find the "Generaux" category in the DONS data
      const generalCategory = window.DONS?.find(cat => cat.nom === 'Generaux');
      if (!generalCategory || !generalCategory.dons || generalCategory.dons.length === 0) {
        return '';
      }

      // Generate cards for all general dons
      const generalDonsCards = generalCategory.dons.map((don, index) => 
        CardBuilder.create('don', don, 'Generaux', index).build()
      ).join('');

      return `
        <div style="margin-top: 2rem; padding-top: 1.5rem; border-top: 2px solid var(--rule);">
          <h3 style="color: var(--bronze); margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
            🎖️ Dons Généraux
          </h3>
          <p style="margin-bottom: 1.5rem; font-style: italic; color: var(--accent-ink); opacity: 0.8;">
            Ces dons sont accessibles à toutes les classes et peuvent compléter votre build.
          </p>
          <div class="grid cols-2">
            ${generalDonsCards}
          </div>
        </div>
      `;
    }

    // SUPPRIMÉ: buildFilterManagerButton - fonctionnalité retirée
    
    buildTagsManagerButton() {
      // ALWAYS generate the button - CSS will control visibility based on body.dev-on/dev-off  
      if (window.STANDALONE_VERSION) return '';
      
      return `<button class="tags-manager-btn btn" type="button" style="background: #dc2626; color: white; border: 2px solid #b91c1c;">🏷️ Gérer les tags</button>`;
    }

    buildPrintButton() {
      return `
        <div style="margin-top: 1rem;">
          <button id="print-etats-btn" class="print-button" type="button" title="Imprimer la liste des états">
            🖨️ Version imprimable
          </button>
        </div>
      `;
    }

    buildSingleTableTresorPage(tableData) {
      let config = window.ContentTypes?.['tableTresor'];
      const allTables = tableData.tables || [];
      const instance = PageBuilder.getInstance();
      
      // Defensive check for config with fallback
      if (!config || !config.filterConfig) {
        console.warn('TableTresor config not loaded, using fallback defaults');
        config = {
          filterConfig: {
            defaultVisibleTags: ['Commun'],
            availableTags: ['Faible', 'Commun', 'Rare', 'Épique', 'Légendaire', 'Boss', 'Humanoïde', 'Bête', 'Dragon', 'Mort-vivant', 'Élémentaire']
          }
        };
      }
      
      // Priority: Use saved metadata tags as single source of truth
      let availableTags = window.TABLES_TRESORS?._metadata?.availableTags || [];
      
      // Utiliser le state du filtre s'il existe, sinon les tags par défaut qui existent vraiment
      let defaultVisibleTags = config.filterConfig.defaultVisibleTags || [];
      // Filter defaultVisibleTags to only include tags that actually exist in metadata
      if (availableTags.length > 0) {
        defaultVisibleTags = defaultVisibleTags.filter(tag => availableTags.includes(tag));
      }
      const visibleTags = window.TABLES_TRESORS_FILTER_STATE?.visibleTags || defaultVisibleTags;
      
      
      // Filter tables according to visible tags
      const filterMode = config.filterMode || 'OR';
      const filteredTables = visibleTags.length === 0 
        ? allTables // If no tags are visible, show all tables
        : allTables.filter(table => {
            // Check that the table has tags when filtering is active
            if (!table.tags || table.tags.length === 0) return false;
            
            if (filterMode === 'AND') {
              // In AND mode: table must have ALL visible tags
              return visibleTags.every(tag => table.tags.includes(tag));
            } else {
              // In OR mode: table must have AT LEAST ONE visible tag
              return visibleTags.some(tag => table.tags.includes(tag));
            }
          });
          
      
      return `
        <article class="" data-page="tables-tresors">
          <section>
            <header class="page-header">
              <h1 class="page-title" style="display: flex; align-items: center; gap: 0.5rem;">
                💎 Tables de trésors
              </h1>
            </header>
            
            ${instance.buildPageDescription('tableTresor')}
            
            ${instance.buildTagFilters(visibleTags, availableTags, 'tableTresor')}
            
            <div data-dev-only class="dev-buttons-container">
              ${instance.buildAddButton('tableTresor', 'tables')}
              ${instance.buildTagsManagerButton()}
            </div>
            </div>
            
            <div class="grid cols-1" id="tables-tresors-container" style="gap: 1.5rem;">
              ${filteredTables.map((table, index) => 
                CardBuilder.create('tableTresor', table, 'tables', index).build()
              ).join('')}
            </div>
            
            ${filteredTables.length === 0 ? `
              <div style="text-align: center; padding: 2rem; background: var(--card); border-radius: 12px; margin: 1rem 0;">
                <p style="color: var(--accent-ink); font-size: 1.1em; margin-bottom: 1rem;">
                  💎 ${allTables.length === 0 ? 'Aucune table de trésor définie' : 'Aucune table ne correspond aux filtres sélectionnés'}
                </p>
                <p style="color: var(--paper-muted); font-style: italic;">
                  ${allTables.length === 0 
                    ? (instance.shouldShowEditButtons ? 'Utilisez le bouton "Ajouter une table de trésor" ci-dessus pour créer votre première table.' : 'Le Maître de jeu peut créer des tables de trésors en mode développement.')
                    : 'Modifiez vos filtres pour voir d\'autres tables de trésors.'
                  }
                </p>
              </div>
            ` : ''}
            
            <div style="margin-top: 1rem; padding: 1rem; background: var(--card); border-radius: 8px; border-left: 4px solid var(--bronze);">
              <p style="color: var(--accent-ink); margin: 0;">
                📊 Résultats: ${filteredTables.length} table${filteredTables.length !== 1 ? 's' : ''} affichée${filteredTables.length !== 1 ? 's' : ''} sur ${allTables.length} au total
              </p>
            </div>
          </section>
        </article>
      `;
    }

    buildCampaignPage(pageId, pageData) {
      const campaigns = pageData.subPages || {};
      const campaignList = Object.keys(campaigns);
      
      // Get current selections (default to first available or empty)
      const selectedCampaign = window.JdrApp?.state?.selectedCampaign || (campaignList.length > 0 ? campaignList[0] : null);
      const currentCampaign = selectedCampaign && campaigns[selectedCampaign] ? campaigns[selectedCampaign] : null;
      const subPageList = currentCampaign ? Object.keys(currentCampaign.subPages || {}) : [];
      const selectedSubPage = window.JdrApp?.state?.selectedSubPage || (subPageList.length > 0 ? subPageList[0] : null);
      const currentSubPage = selectedSubPage && currentCampaign?.subPages?.[selectedSubPage] ? currentCampaign.subPages[selectedSubPage] : null;
      
      return `
        <article class="" data-page="${pageId}" data-static-page="true" data-page-title="${pageData.title}">
          <section>
            ${pageId === 'campagne' ? this.buildCompactCampaignHeader(pageData) : this.buildStaticPageHeader(pageData)}
            ${pageId === 'campagne' ? '' : this.buildSections(pageData.sections)}
            
            <div class="campaign-manager" style="margin-top: 0.5rem;">
              <!-- Campaign Management Controls -->
              <div class="campaign-controls" style="background: var(--card); border-radius: 12px; padding: 1rem; margin-bottom: 0.5rem;">
                <div style="display: flex; justify-content: center; align-items: center; margin-bottom: 0.5rem;">
                  <div class="dev-buttons" style="display: flex; gap: 8px;">
                    <button class="btn primary small dev-only" onclick="JdrApp.modules.ui.addCampaign()" style="display: none;">
                      ➕ Nouvelle Campagne
                    </button>
                  </div>
                </div>
                
                ${campaignList.length === 0 ? `
                  <div style="text-align: center; padding: 2rem;">
                    <p style="color: var(--accent-ink); font-size: 1.1em; margin-bottom: 1rem;">
                      📖 Aucune campagne créée
                    </p>
                    <p style="color: var(--paper-muted); font-style: italic;">
                      <span class="dev-only" style="display: none;">Utilisez le bouton "Nouvelle Campagne" ci-dessus pour créer votre première campagne.</span>
                      <span class="non-dev-only">Le Maître de jeu peut créer des campagnes en mode développement.</span>
                    </p>
                  </div>
                ` : `
                  <!-- Campaign Selector -->
                  <div class="campaign-selector" style="margin-bottom: 0.5rem; text-align: center;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--accent-ink); text-align: center;">
                      📚 Campagne Active:
                    </label>
                    <div style="display: inline-flex; align-items: center; gap: 8px;">
                      <select id="campaignSelector" onchange="JdrApp.modules.ui.selectCampaign(this.value)" 
                              style="padding: 8px; border-radius: 6px; border: 2px solid var(--rule); background: var(--paper); font-family: inherit;">
                        ${campaignList.map(name => 
                          `<option value="${name}" ${name === selectedCampaign ? 'selected' : ''}>${name}</option>`
                        ).join('')}
                      </select>
                      <button class="btn danger small dev-only" onclick="JdrApp.modules.ui.deleteCampaign('${selectedCampaign}')" 
                              style="display: none;" ${!selectedCampaign ? 'disabled' : ''}>
                        🗑️ Supprimer
                      </button>
                    </div>
                  </div>
                `}
              </div>
              <!-- Campaign Content -->
              ${selectedCampaign && currentCampaign ? this.buildSelectedCampaignContent(selectedCampaign, currentCampaign, selectedSubPage, currentSubPage) : ''}
            </div>
            
            ${this.buildAddSectionButton()}
          </section>
        </article>
      `;
    }

    buildSelectedCampaignContent(campaignName, campaign, selectedSubPage, currentSubPage) {
      const subPageList = campaign.subPages ? Object.keys(campaign.subPages) : [];
      
      return `
        <div class="selected-campaign" style="background: var(--card); border-radius: 12px; padding: 1.5rem; border-left: 4px solid var(--bronze);">
          <!-- Campaign Header -->
          <div class="campaign-header" style="margin-bottom: 1.5rem; border-bottom: 2px solid var(--rule); padding-bottom: 1rem;">
            <div style="display: flex; align-items: center; margin-bottom: 0.5rem;">
              <h3 class="editable" data-edit-type="generic" data-edit-section="campaign-${campaignName}-name" 
                  style="margin: 0; color: var(--accent-ink); flex: 1;">
                ${campaignName}
              </h3>
              ${this.buildEditButton('title')}
            </div>
          </div>
          
          <!-- Sub-pages Section -->
          <div class="campaign-subpages">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
              <button class="btn primary small dev-only" onclick="JdrApp.modules.ui.addCampaignSubPage('${campaignName}')" style="display: none;">
                ➕ Nouvelle Sous-page
              </button>
            </div>
            
            ${subPageList.length === 0 ? `
              <div style="text-align: center; padding: 2rem; background: var(--paper-light); border-radius: 8px; margin-bottom: 1rem;">
                <p style="color: var(--paper-muted); font-style: italic;">
                  Aucune sous-page créée pour cette campagne.
                </p>
                <p class="dev-only" style="color: var(--paper-muted); font-size: 0.9em; display: none;">
                  Utilisez le bouton "Nouvelle Sous-page" pour commencer.
                </p>
              </div>
            ` : `
              <!-- Sub-page Selector -->
              <div class="subpage-selector" style="margin-bottom: 1.5rem;">
                <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--accent-ink);">
                  📝 Sous-page Active:
                </label>
                <select id="subPageSelector" onchange="JdrApp.modules.ui.selectSubPage(this.value)" 
                        style="padding: 8px; border-radius: 6px; border: 2px solid var(--rule); background: var(--paper); font-family: inherit;">
                  ${subPageList.map(name => 
                    `<option value="${name}" ${name === selectedSubPage ? 'selected' : ''}>${name}</option>`
                  ).join('')}
                </select>
                <button class="btn danger small dev-only" onclick="JdrApp.modules.ui.deleteCampaignSubPage('${campaignName}', '${selectedSubPage}')" 
                        style="margin-left: 8px; display: none;" ${!selectedSubPage ? 'disabled' : ''}>
                  🗑️ Supprimer
                </button>
              </div>
              
              <!-- Sub-page Content -->
              ${selectedSubPage && currentSubPage ? this.buildSelectedSubPageContent(campaignName, selectedSubPage, currentSubPage) : ''}
            `}
          </div>
        </div>
      `;
    }

    buildSelectedSubPageContent(campaignName, subPageName, subPage) {
      return `
        <div class="selected-subpage" style="background: var(--paper-light); border-radius: 8px; padding: 1.5rem; border: 2px solid var(--rule);">
          <!-- Sub-page Header -->
          <div class="subpage-header" style="margin-bottom: 1rem; border-bottom: 1px solid var(--rule); padding-bottom: 0.75rem;">
            <div style="display: flex; align-items: center;">
              <h5 class="editable" data-edit-type="generic" data-edit-section="subpage-${campaignName}-${subPageName}-title" 
                  style="margin: 0; color: var(--accent-ink); font-size: 1.2em; flex: 1;">
                📄 ${subPage.title || subPageName}
              </h5>
              ${this.buildEditButton('title')}
            </div>
          </div>
          
          <!-- Sub-page Content -->
          <div style="display: flex; align-items: flex-start;">
            <div class="subpage-content editable" data-edit-type="generic" data-edit-section="subpage-${campaignName}-${subPageName}-content" 
                 style="line-height: 1.6; min-height: 200px; flex: 1;">
              ${subPage.content || '<p>Contenu de la sous-page...</p>'}
            </div>
            ${this.buildEditButton('section')}
          </div>
        </div>
      `;
    }

    buildEditButton(buttonType) {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="edit-btn" type="button" style="background: var(--accent); color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 12px; margin-left: 8px;">✏️</button>`;
    }
    

    sanitizeId(str) {
      return str.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    }

    /**
     * Construit la page spéciale des favoris
     * @param {string} pageId - ID de la page
     * @param {Object} pageData - Données de la page
     * @returns {string} HTML de la page favoris
     */
    buildFavorisPage(pageId, pageData) {
      const title = pageData.title || 'Favoris';
      
      return `
        <article class="" data-page="${pageId}" data-static-page="true" data-page-title="${title}">
          <section>
            ${this.buildStaticPageHeader(pageData)}
            
            <div class="favoris-section favoris-collapsible" id="favoris-objets-section">
              <div class="favoris-header" onclick="this.parentElement.classList.toggle('collapsed')">
                <h2>📦 Objets favoris</h2>
                <span class="favoris-toggle">▼</span>
              </div>
              <div class="favoris-content">
                <div id="favoris-objets-container" class="favoris-grid">
                  <!-- Les objets favoris seront affichés ici dynamiquement -->
                </div>
                <div id="favoris-objets-empty" class="favoris-empty" style="display: none;">
                  <p>Aucun objet en favoris</p>
                  <p style="font-size: 0.9em;">Cliquez sur l'étoile ⭐ à côté d'un objet pour l'ajouter à vos favoris</p>
                </div>
              </div>
            </div>

            <div class="favoris-section favoris-collapsible" id="favoris-sorts-section">
              <div class="favoris-header" onclick="this.parentElement.classList.toggle('collapsed')">
                <h2>🔮 Sorts favoris</h2>
                <span class="favoris-toggle">▼</span>
              </div>
              <div class="favoris-content">
                <div id="favoris-sorts-container" class="favoris-grid">
                  <!-- Les sorts favoris seront affichés ici dynamiquement -->
                </div>
                <div id="favoris-sorts-empty" class="favoris-empty" style="display: none;">
                  <p>Aucun sort en favoris</p>
                  <p style="font-size: 0.9em;">Cliquez sur l'étoile ⭐ à côté d'un sort pour l'ajouter à vos favoris</p>
                </div>
              </div>
            </div>
          </section>
        </article>
      `;
    }
  }

  window.PageBuilder = PageBuilder.getInstance();

})();
// ============================================================================
// JDR-BAB APPLICATION - UTILITIES MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // DEV MODE UTILITIES
  // ========================================
  JdrApp.utils.isDevMode = function() {
    // Simple check - if it's standalone, dev mode is always false
    if (window.STANDALONE_VERSION) return false;
    
    // Use the editor's actual state instead of CSS classes for reliability
    if (JdrApp.modules && JdrApp.modules.editor) {
      return JdrApp.modules.editor.isDevMode;
    }
    
    // Fallback: check body class if editor not available yet
    return document.body.classList.contains('dev-on');
  };

  // ========================================
  // CENTRALIZED EVENT MANAGEMENT
  // ========================================
  JdrApp.utils.events = {
    listeners: new Map(),
    
    // Centralized event registration
    register(type, selector, handler, options = {}) {
      const key = `${type}-${selector || 'window'}-${Date.now()}`;
      const wrapper = (e) => {
        if (!selector) {
          handler(e);
        } else {
          // Gérer les sélecteurs spéciaux comme [class$="-add"]
          if (this.matchesSelector(e.target, selector)) {
            handler(e);
          }
        }
      };
      
      if (selector) {
        document.addEventListener(type, wrapper, options);
      } else {
        window.addEventListener(type, wrapper, options);
      }
      
      this.listeners.set(key, { type, wrapper, options });
      return key;
    },

    // Helper pour matcher les sélecteurs complexes
    matchesSelector(element, selector) {
      // Gérer les sélecteurs d'attributs comme [class$="-add"]
      if (selector.startsWith('[class$="') && selector.endsWith('"]')) {
        const suffix = selector.slice(9, -2); // Extraire "-add" de '[class$="-add"]'
        return element.className && element.className.split(' ').some(cls => cls.endsWith(suffix));
      }
      
      // Gérer les sélecteurs d'attributs comme [class*="something"]
      if (selector.startsWith('[class*="') && selector.endsWith('"]')) {
        const substring = selector.slice(9, -2); // Extraire "something" 
        return element.className && element.className.includes(substring);
      }
      
      // Utiliser la méthode native pour les autres sélecteurs
      try {
        return element.matches(selector) || element.closest(selector);
      } catch (e) {
        // Fallback pour les sélecteurs invalides
        return false;
      }
    },
    
    // Delayed execution manager
    delayed: new Map(),
    timeout(key, fn, delay = 0) {
      if (this.delayed.has(key)) {
        clearTimeout(this.delayed.get(key));
      }
      const id = setTimeout(() => {
        fn();
        this.delayed.delete(key);
      }, delay);
      this.delayed.set(key, id);
    },
    
    // Common event handlers
    onDOMReady(fn) {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', fn);
      } else {
        fn();
      }
    },
    
    onHashChange(fn) {
      window.addEventListener('hashchange', fn);
    },
    
    onRouteChange(fn) {
      this.onHashChange(() => this.timeout('route-change', fn, 0));
      this.onDOMReady(() => this.timeout('dom-ready-route', fn, 0));
    }
  };

  // ========================================
  // DOM UTILITIES LIBRARY
  // ========================================
  JdrApp.utils.dom = {
    // Common selectors
    $(selector) { return document.querySelector(selector); },
    $(selector) { return document.querySelectorAll(selector); },
    
    // Element creation with common patterns
    create(tag, className = '', innerHTML = '', attributes = {}) {
      const el = document.createElement(tag);
      if (className) el.className = className;
      if (innerHTML) el.innerHTML = innerHTML;
      Object.entries(attributes).forEach(([key, value]) => {
        el.setAttribute(key, value);
      });
      return el;
    },
    
    
    // Safe innerHTML replacement
    safeSetHTML(element, html) {
      if (element) {
        element.innerHTML = html;
      }
    },
    
    // Safe text content setting
    safeSetText(element, text) {
      if (element) {
        element.textContent = text;
      }
    },
    
    // Toggle class utility
    toggleClass(element, className, force = null) {
      if (element) {
        if (force !== null) {
          element.classList.toggle(className, force);
        } else {
          element.classList.toggle(className);
        }
      }
    },
    
    // Show/hide utilities
    show(element, display = 'block') {
      if (element) {
        element.style.display = display;
      }
    },
    
    hide(element) {
      if (element) {
        element.style.display = 'none';
      }
    }
  };

  // ========================================
  // DATA UTILITIES
  // ========================================
  JdrApp.utils.data = {
    // Find spell by name across all categories
    findSpell(name) {
      if (!window.SORTS) return null;
      
      for (const category of window.SORTS) {
        const spell = category.sorts.find(s => s.nom === name);
        if (spell) return { spell, category: category.nom };
      }
      return null;
    },
    
    // Find class by name
    findClass(name) {
      if (!window.CLASSES) return null;
      return window.CLASSES.find(c => c.nom === name);
    },
    
    // Find don by name across all categories
    findDon(name) {
      if (!window.DONS) return null;
      
      for (const category of window.DONS) {
        const don = category.dons.find(d => d.nom === name);
        if (don) return { don, category: category.nom };
      }
      return null;
    },
    
    // Get spell category by name
    getSpellCategory(categoryName) {
      if (!window.SORTS) return null;
      return window.SORTS.find(cat => cat.nom === categoryName);
    },
    
    // Get don category by name
    getDonCategory(categoryName) {
      if (!window.DONS) return null;
      return window.DONS.find(cat => cat.nom === categoryName);
    },
    
    // Deep clone object
    deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    },
    
    // Sanitize string for use as identifier
    sanitizeId(str) {
      return str.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    },
    
    // Generate unique ID
    generateId(prefix = 'id') {
      return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    },
    
    // Escape HTML
    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  };

  // ========================================
  // IMAGE UTILITIES
  // ========================================
  
  // Compress image function
  JdrApp.utils.compressImage = function(file, maxWidth = 800, quality = 0.85) {
    return new Promise((resolve, reject) => {
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      img.onload = function() {
        // Calculate new dimensions
        let { width, height } = img;
        
        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }
        
        // Set canvas size
        canvas.width = width;
        canvas.height = height;
        
        // Detect if image has transparency (PNG)
        const isPNG = file.type === 'image/png' || file.name.toLowerCase().endsWith('.png');
        
        if (isPNG) {
          // For PNG, don't compress at all to preserve quality
          resolve(file);
        } else {
          // For JPEG/other formats, use white background
          ctx.fillStyle = '#FFFFFF';
          ctx.fillRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);
          
          canvas.toBlob((blob) => {
            resolve(blob);
          }, 'image/jpeg', quality);
        }
      };
      
      img.onerror = (error) => {
        reject(error);
      };
      
      img.src = URL.createObjectURL(file);
    });
  };

  // Upload to ImageBB function
  JdrApp.utils.uploadToImageBB = function(file) {
    return new Promise((resolve, reject) => {
      // ImageBB API key
      const API_KEY = '06a98f5c0c2dad952e6ab94b03040f36';
      
      const formData = new FormData();
      formData.append('image', file);
      
      fetch(`https://api.imgbb.com/1/upload?key=${API_KEY}`, {
        method: 'POST',
        body: formData
      })
      .then(response => {
        return response.json();
      })
      .then(data => {
        if (data.success) {
          resolve(data.data.url);
        } else {
          throw new Error('Upload failed: ' + (data.error ? data.error.message : 'Unknown error'));
        }
      })
      .catch(error => {
        // Fallback to local storage
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    });
  };

  // ========================================
  // PERFORMANCE OPTIMIZATION UTILITIES
  // ========================================
  
  // Minify HTML to reduce size (for performance optimization)
  JdrApp.utils.minifyHTML = function(html) {
    if (!html || typeof html !== 'string') return html;
    
    return html
      // Remove comments
      .replace(/<!--[\s\S]*?-->/g, '')
      // Remove extra whitespace between tags
      .replace(/>\s+</g, '><')
      // Remove whitespace at start and end of lines
      .replace(/^\s+|\s+$/gm, '')
      // Remove empty lines
      .replace(/\n\s*\n/g, '\n')
      // Trim the result
      .trim();
  };

  // Debounce function for performance
  JdrApp.utils.debounce = function(func, wait, immediate) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        timeout = null;
        if (!immediate) func.apply(this, args);
      };
      const callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) func.apply(this, args);
    };
  };

  // Throttle function for performance
  JdrApp.utils.throttle = function(func, limit) {
    let inThrottle;
    return function(...args) {
      if (!inThrottle) {
        func.apply(this, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  };

})();
// ============================================================================
// DEVICE DETECTION UTILITIES
// ============================================================================

(() => {
  "use strict";

  window.DeviceDetection = {
    
    // Detect if device is a tablet based on multiple factors
    isTablet() {
      const userAgent = navigator.userAgent.toLowerCase();
      const screen = window.screen;
      const width = Math.max(screen.width, screen.height);
      const height = Math.min(screen.width, screen.height);
      
      // Check user agent for tablet indicators
      const tabletUA = /ipad|android(?!.*mobile)|tablet|kindle|playbook|nook|silk/i.test(userAgent);
      
      // Check for coarse pointer (touch) and tablet-like dimensions
      const hasCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
      const tabletDimensions = (width >= 768 && width <= 1366) && (height >= 600);
      
      // iPad specific check
      const isIPad = /ipad/i.test(userAgent) || 
                   (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
      
      // Android tablet check (excludes phones)
      const isAndroidTablet = /android/i.test(userAgent) && !/mobile/i.test(userAgent);
      
      return tabletUA || isIPad || isAndroidTablet || (hasCoarsePointer && tabletDimensions);
    },

    // Detect mobile phones specifically
    isMobile() {
      const userAgent = navigator.userAgent.toLowerCase();
      return /mobile|iphone|ipod|android.*mobile|blackberry|windows.*phone/i.test(userAgent);
    },

    // Check if device has touch capability
    isTouchDevice() {
      return 'ontouchstart' in window || 
             navigator.maxTouchPoints > 0 || 
             navigator.msMaxTouchPoints > 0;
    },

    // Check screen orientation
    isPortrait() {
      return window.innerHeight > window.innerWidth;
    },

    // Check if device should use mobile navigation
    shouldUseMobileNav() {
      const isSmallScreen = window.innerWidth <= 1024;
      const isTabletDevice = this.isTablet();
      const isMobileDevice = this.isMobile();
      
      return isMobileDevice || (isTabletDevice && isSmallScreen) || 
             (this.isTouchDevice() && isSmallScreen);
    },

    // Get device type as string
    getDeviceType() {
      if (this.isMobile()) return 'mobile';
      if (this.isTablet()) return 'tablet';
      return 'desktop';
    },

    // Check if should auto-close sidebar after navigation
    shouldAutoCloseSidebar() {
      return this.shouldUseMobileNav();
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - IMAGES MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // IMAGES MANAGEMENT MODULE
  // ========================================
  JdrApp.modules.images = {
    // Store for preloaded images
    imageStore: {},
    
    async init() {
      await this.loadImageData();
      this.initImageHandlers();
      this.initLazyLoading();
      
      // Auto-sync monster images on startup to ensure consistency
      setTimeout(() => {
        this.ensureMonsterImageMappings();
      }, 1000);
    },

    // Initialize lazy loading with Intersection Observer
    initLazyLoading() {
      if ('IntersectionObserver' in window) {
        this.lazyImageObserver = new IntersectionObserver((entries, observer) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const img = entry.target;
              const dataSrc = img.getAttribute('data-src');
              if (dataSrc) {
                img.src = dataSrc;
                img.removeAttribute('data-src');
                img.classList.remove('lazy-load');
                img.classList.add('lazy-loaded');
                
                // Une fois l'image chargée, s'assurer que les événements d'agrandissement sont attachés
                img.addEventListener('load', () => {
                  if (JdrApp.modules.editor && JdrApp.modules.editor.attachImageEvents) {
                    JdrApp.modules.editor.attachImageEvents();
                  }
                }, { once: true });
              }
              observer.unobserve(img);
            }
          });
        }, {
          rootMargin: '50px 0px', // Start loading 50px before image comes into view
          threshold: 0.01
        });
      } else {
        // Fallback for browsers without IntersectionObserver
        this.initFallbackLazyLoading();
      }
    },

    // Fallback lazy loading for older browsers
    initFallbackLazyLoading() {
      const lazyLoad = () => {
        const lazyImages = document.querySelectorAll('img.lazy-load[data-src]');
        lazyImages.forEach(img => {
          const rect = img.getBoundingClientRect();
          if (rect.top < window.innerHeight + 50 && rect.bottom > -50) {
            const dataSrc = img.getAttribute('data-src');
            if (dataSrc) {
              img.src = dataSrc;
              img.removeAttribute('data-src');
              img.classList.remove('lazy-load');
              img.classList.add('lazy-loaded');
              
              // Une fois l'image chargée, s'assurer que les événements d'agrandissement sont attachés
              img.addEventListener('load', () => {
                if (JdrApp.modules.editor && JdrApp.modules.editor.attachImageEvents) {
                  JdrApp.modules.editor.attachImageEvents();
                }
              }, { once: true });
            }
          }
        });
      };
      
      // Use throttled scroll events for better performance
      const throttledLazyLoad = JdrApp.utils.throttle(lazyLoad, 100);
      const debouncedLazyLoad = JdrApp.utils.debounce(lazyLoad, 250);
      
      window.addEventListener('scroll', throttledLazyLoad, { passive: true });
      window.addEventListener('resize', debouncedLazyLoad, { passive: true });
      lazyLoad(); // Initial check
    },

    // Load image data from JSON file or embedded data
    async loadImageData() {
      try {
        if (window.IMAGES) {
          this.imageStore = window.IMAGES.images || window.IMAGES || {};
          return;
        }
        
        const response = await fetch('./data/images.json');
        if (response.ok) {
          const data = await response.json();
          this.imageStore = data.images || {};
        } else {
          this.imageStore = {};
        }
      } catch (error) {
        this.imageStore = {};
      }
    },

    // Get image URL for a given key
    getImageUrl(illusKey) {
      return this.imageStore[illusKey] || null;
    },

    // Apply image to an illustration element
    applyImage(illusElement, imageUrl) {
      if (!illusElement || !imageUrl) return;

      const img = illusElement.querySelector('img.thumb');
      if (!img) return;

      // Set image source and make it visible
      img.src = this.processImageUrl(imageUrl);
      img.style.display = 'inline-block';
      img.style.opacity = '1'; // Reset opacity after upload
      
      // Show remove button if it exists
      const removeBtn = illusElement.querySelector('.rm');
      if (removeBtn) {
        removeBtn.style.display = 'inline-flex';
      }

    },

    // Process image URL to handle proxying for mobile compatibility
    processImageUrl(originalUrl) {
      // If it's an i.ibb.co URL, use proxy for better mobile compatibility
      if (originalUrl.includes('i.ibb.co') && !originalUrl.includes('images.weserv.nl')) {
        const format = this.supportsWebP() ? 'webp' : 'jpeg';
        const quality = this.getOptimalQuality();
        return `https://images.weserv.nl/?url=${encodeURIComponent(originalUrl)}&we&output=${format}&q=${quality}&w=400&h=300&fit=inside`;
      }
      
      // For local monster paths, encode only the filename to handle French characters properly
      if (originalUrl.startsWith('data/images/Monstres/')) {
        const pathParts = originalUrl.split('/');
        const filename = pathParts[pathParts.length - 1];
        const pathWithoutFilename = pathParts.slice(0, -1).join('/');
        return `${pathWithoutFilename}/${encodeURIComponent(filename)}`;
      }
      
      return originalUrl;
    },

    // Detect WebP support
    supportsWebP() {
      if (this._webpSupport !== undefined) return this._webpSupport;
      
      try {
        this._webpSupport = document.createElement('canvas')
          .toDataURL('image/webp', 0.5)
          .indexOf('data:image/webp') === 0;
      } catch (err) {
        this._webpSupport = false;
      }
      
      return this._webpSupport;
    },

    // Get optimal quality based on connection speed
    getOptimalQuality() {
      if ('connection' in navigator) {
        const connection = navigator.connection;
        if (connection.effectiveType === '4g') return 85;
        if (connection.effectiveType === '3g') return 75;
        if (connection.effectiveType === '2g') return 65;
        return 60; // slow-2g
      }
      return 80; // Default quality
    },

    autoLoadImages() {
      const illusElements = document.querySelectorAll('[data-illus-key]');
      let loadedCount = 0;

      illusElements.forEach(illusElement => {
        const illusKey = illusElement.dataset.illusKey;
        const imageUrl = this.getImageUrl(illusKey);
        
        if (imageUrl) {
          const img = illusElement.querySelector('img');
          if (img && img.classList.contains('lazy-load')) {
            // For lazy loading, set data-src and observe
            const processedUrl = this.processImageUrl(imageUrl);
            img.setAttribute('data-src', processedUrl);
            if (this.lazyImageObserver) {
              this.lazyImageObserver.observe(img);
            }
          } else {
            // Fallback to immediate loading
            this.applyImage(illusElement, imageUrl);
          }
          loadedCount++;
        }
      });

      return loadedCount;
    },

    // Initialize image upload handlers
    initImageHandlers() {
      // Delegate image upload handling
      document.addEventListener('change', (event) => {
        if (event.target.matches('.illus input[type="file"]')) {
          this.handleImageUpload(event.target);
        }
      });

      // Delegate image removal handling  
      document.addEventListener('click', (event) => {
        if (event.target.matches('.illus .rm')) {
          this.handleImageRemoval(event.target);
        }
      });
    },

    // Handle image upload
    async handleImageUpload(fileInput) {
      const file = fileInput.files[0];
      if (!file) return;

      const illusElement = fileInput.closest('.illus');
      if (!illusElement) return;

      const illusKey = illusElement.dataset.illusKey;
      
      try {
        // Show loading state
        const img = illusElement.querySelector('img.thumb');
        if (img) {
          img.style.opacity = '0.5';
        }

        // Compress and upload image
        const compressedFile = await JdrApp.utils.compressImage(file, 800, 0.8);
        const imageUrl = await JdrApp.utils.uploadToImageBB(compressedFile);
        
        // Apply the uploaded image
        this.applyImage(illusElement, imageUrl);
        
        // Update local store
        this.imageStore[illusKey] = imageUrl;
        
        // Auto-sync to prevent loss of image assignments
        this.autoSyncImages();
        
        
      } catch (error) {
        // Reset loading state
        const img = illusElement.querySelector('img.thumb');
        if (img) {
          img.style.opacity = '1';
        }
        
        alert('Erreur lors du téléchargement de l\'image. Veuillez réessayer.');
      }
      
      // Clear file input
      fileInput.value = '';
    },

    // Handle image removal
    handleImageRemoval(removeBtn) {
      const illusElement = removeBtn.closest('.illus');
      if (!illusElement) return;

      const illusKey = illusElement.dataset.illusKey;
      const img = illusElement.querySelector('img.thumb');
      
      if (img) {
        img.src = '';
        img.style.display = 'none';
      }
      
      removeBtn.style.display = 'none';
      
      // Remove from store
      delete this.imageStore[illusKey];
      
      // Auto-sync to update persistent storage
      this.autoSyncImages();
    },

    // Manually add/update an image
    setImage(illusKey, imageUrl) {
      this.imageStore[illusKey] = imageUrl;
      
      // Apply to any existing elements with this key
      const illusElements = document.querySelectorAll(`[data-illus-key="${illusKey}"]`);
      illusElements.forEach(element => {
        this.applyImage(element, imageUrl);
      });
      
      // Auto-sync to prevent loss
      this.autoSyncImages();
    },

    // Get all current images for export
    getAllImages() {
      return { ...this.imageStore };
    },

    // Import images from external data
    importImages(imageData) {
      if (typeof imageData === 'object' && imageData !== null) {
        Object.assign(this.imageStore, imageData);
        this.autoLoadImages();
      }
    },

    // Auto-sync images to prevent data loss
    autoSyncImages() {
      // Ensure we have monster image mappings for all existing monsters
      this.ensureMonsterImageMappings();
      
      // Ensure we have object image mappings for all existing objects
      this.ensureObjectImageMappings();
      
      // Trigger auto-save if available
      if (JdrApp.modules.storage && JdrApp.modules.storage.saveChanges) {
        JdrApp.modules.storage.saveChanges(true); // Silent save
      }
    },

    // Ensure all monsters have image mappings in images.json structure
    ensureMonsterImageMappings() {
      if (!window.MONSTRES || !Array.isArray(window.MONSTRES)) {
        return;
      }

      let hasUpdates = false;

      window.MONSTRES.forEach(monster => {
        const imageKey = `monster:${monster.nom}`;
        
        // If monster has no image mapping in store, create one
        if (!this.imageStore[imageKey]) {
          // Check if monster has a valid image path
          if (monster.image && monster.image.trim()) {
            this.imageStore[imageKey] = monster.image;
            hasUpdates = true;
          }
        }
        
        // Also validate that the image file exists
        this.validateMonsterImagePath(monster);
      });

      if (hasUpdates) {
      }
    },

    // Validate and fix monster image paths
    validateMonsterImagePath(monster) {
      if (!monster.image || !monster.nom) {
        return false;
      }

      // Extract filename from current path
      const currentPath = monster.image;
      const filename = currentPath.split('/').pop();
      
      // Check if path follows correct format
      const expectedPattern = /^data\/images\/Monstres\/foret\/Monstre_Forêt_\w+\.png$/;
      
      if (!expectedPattern.test(currentPath)) {
        // Try to fix common issues
        let correctedPath = null;
        
        // Map common filename patterns to correct paths
        const filenameMap = {
          'araignee-geante.png': 'Monstre_Forêt_Araignée.png',
          'crabe-des-bois.png': 'Monstre_Forêt_Crab.png',  
          'groink.png': 'Monstre_Forêt_Groink.png',
          'groink-chaman.png': 'Monstre_Forêt_Groink_Chaman.png',
          'guepe-geante.png': 'Monstre_Forêt_GuepeGeante.png',
          'ours-des-bois.png': 'Monstre_Forêt_Ours.png'
        };

        if (filenameMap[filename]) {
          correctedPath = `data/images/Monstres/foret/${filenameMap[filename]}`;
        } else if (!filename.startsWith('Monstre_Forêt_')) {
          // Try to construct path from monster name
          const safeName = monster.nom.replace(/[^a-zA-Z0-9àâäéèêëïîôùûüÿçÀÂÄÉÈÊËÏÎÔÙÛÜŸÇ_]/g, '');
          correctedPath = `data/images/Monstres/foret/Monstre_Forêt_${safeName}.png`;
        }

        if (correctedPath && correctedPath !== currentPath) {
          
          // Update monster data
          monster.image = correctedPath;
          
          // Update image mapping
          const imageKey = `monster:${monster.nom}`;
          this.imageStore[imageKey] = correctedPath;
          
          return true;
        }
      }
      
      return false;
    },

    // Force synchronization of all monster data
    forceSyncMonsterImages() {
      
      let syncCount = 0;
      
      if (window.MONSTRES && Array.isArray(window.MONSTRES)) {
        window.MONSTRES.forEach(monster => {
          const corrected = this.validateMonsterImagePath(monster);
          if (corrected) {
            syncCount++;
          }
        });
      }
      
      this.ensureMonsterImageMappings();
      
      
      // Save changes
      if (JdrApp.modules.storage && JdrApp.modules.storage.saveChanges) {
        JdrApp.modules.storage.saveChanges(true);
      }
      
      return syncCount;
    },

    // Ensure all objects have image mappings in images.json structure
    ensureObjectImageMappings() {
      if (!window.OBJETS || !Array.isArray(window.OBJETS.objets)) {
        return;
      }

      let hasUpdates = false;

      window.OBJETS.objets.forEach(objet => {
        const imageKey = `objet:${objet.nom}`;
        
        // If object has no image mapping in store, create one
        if (!this.imageStore[imageKey]) {
          // Check if object has a valid image path
          if (objet.image && objet.image.trim()) {
            this.imageStore[imageKey] = objet.image;
            hasUpdates = true;
          }
        } else {
          // If imageStore has an image but objet.image is empty, sync it back
          if (this.imageStore[imageKey] && (!objet.image || !objet.image.trim())) {
            objet.image = this.imageStore[imageKey];
            hasUpdates = true;
          }
        }
      });

      if (hasUpdates) {
        // Auto-save objects data if it changed
        if (JdrApp.modules.storage && JdrApp.modules.storage.saveChanges) {
          JdrApp.modules.storage.saveChanges(true);
        }
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - STORAGE MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // STORAGE MODULE
  // ========================================
  JdrApp.modules.storage = {
    
    init() {
      
      // Clear localStorage on startup - JSON files are always source of truth
      this.clearStorageOnStartup();
      
      // Set up save handlers
      JdrApp.utils.events.register('click', '#saveAndExport', () => this.saveAndExportZip());
      
      // Listen for storage save events
      EventBus.on(Events.STORAGE_SAVE, () => {
        this.saveChanges(true); // Silent save
      });
      
      // Auto-save functionality
      this.setupAutoSave();
    },

    setupAutoSave() {
      // Auto-save disabled - we save immediately on each edit instead
      // Previously: Auto-save every 30 seconds if in dev mode
    },

    clearStorageOnStartup() {
      // Clear all localStorage data on page load - JSON files are source of truth
      localStorage.removeItem('jdr-bab-edits');
      localStorage.removeItem('jdr-bab-static-pages');
      localStorage.removeItem('jdr-bab-last-modified');
    },

    saveChanges(silent = false) {
      try {
        // Force collect all pending edits
        const editedData = JdrApp.modules.editor ? JdrApp.modules.editor.forceCollectAllEdits() : {};
        
        // Data is already saved in memory (window.STATIC_PAGES, window.SORTS, etc.)
        // No localStorage persistence needed - JSON files are source of truth
        
        if (!silent) {
          this.showNotification('💾 Modifications sauvegardées en mémoire', 'success');
        }
        
      } catch (error) {
        console.error('❌ Failed to save changes:', error);
        if (!silent) {
          this.showNotification('❌ Erreur lors de la sauvegarde', 'error');
        }
      }
    },

    async saveAndExportZip() {
      try {
        this.showNotification('📦 Création de l\'archive ZIP...', 'info');
        
        // Force collect all pending edits
        JdrApp.modules.editor.forceCollectAllEdits();
        
        // Check if JSZip is available
        if (typeof JSZip === 'undefined') {
          await this.loadJSZip();
        }
        
        const zip = new JSZip();
        
        // Add main HTML file
        const mainHTML = await this.getMainHTML();
        zip.file('index.html', mainHTML);
        
        // Add CSS files
        const cssFiles = ['theme.css', 'utilities.css', 'components.css', 'layout.css', 'editor.css'];
        for (const cssFile of cssFiles) {
          const cssContent = await this.fetchFileContent(`css/${cssFile}`);
          if (cssContent) {
            zip.file(`css/${cssFile}`, cssContent);
          }
        }
        
        // Add JS files
        const jsFiles = ['core.js', 'utils.js', 'router.js', 'renderer.js', 'editor.js', 'storage.js', 'ui.js'];
        for (const jsFile of jsFiles) {
          const jsContent = await this.fetchFileContent(`js/${jsFile}`);
          if (jsContent) {
            zip.file(`js/${jsFile}`, jsContent);
          }
        }
        
        // Add modules
        const moduleFiles = ['images.js'];
        for (const moduleFile of moduleFiles) {
          const moduleContent = await this.fetchFileContent(`js/modules/${moduleFile}`);
          if (moduleContent) {
            zip.file(`js/modules/${moduleFile}`, moduleContent);
          }
        }
        
        // Add data files with current edits
        zip.file('data/sorts.json', JSON.stringify(window.SORTS, null, 2));
        zip.file('data/classes.json', JSON.stringify(window.CLASSES, null, 2));
        zip.file('data/dons.json', JSON.stringify(window.DONS, null, 2));
        zip.file('data/objets.json', JSON.stringify(window.OBJETS, null, 2));
        
        // Add monsters data with current edits
        if (window.MONSTRES) {
          zip.file('data/monstres.json', JSON.stringify(window.MONSTRES, null, 2));
        }
        
        // Add tables tresors data with current edits  
        if (window.TABLES_TRESORS) {
          zip.file('data/tables-tresors.json', JSON.stringify(window.TABLES_TRESORS, null, 2));
        }
        
        // Add collections data with current edits
        if (window.COLLECTIONS) {
          zip.file('data/collections.json', JSON.stringify(window.COLLECTIONS, null, 2));
        }
        
        // Add TOC structure with new pages
        if (window.TOC_STRUCTURE) {
          zip.file('data/toc-structure.json', JSON.stringify(window.TOC_STRUCTURE, null, 2));
        }
        
        // Add ContentTypes configuration (includes availableTags modifications)
        if (window.ContentTypes) {
          const updatedContentTypesJS = this.generateContentTypesJS(window.ContentTypes);
          zip.file('js/config/contentTypes.js', updatedContentTypesJS);
        }
        
        // Add static pages config and data
        if (window.STATIC_PAGES_CONFIG) {
          zip.file('data/static-pages-config.json', JSON.stringify(window.STATIC_PAGES_CONFIG, null, 2));
        }
        
        if (window.STATIC_PAGES) {
          for (const [pageId, pageData] of Object.entries(window.STATIC_PAGES)) {
            zip.file(`data/${pageId}.json`, JSON.stringify(pageData, null, 2));
          }
        }
        
        // Note: All static pages are now handled via window.STATIC_PAGES above
        
        // Ensure all image mappings are synchronized before export
        if (JdrApp.modules.images && JdrApp.modules.images.autoSyncImages) {
          JdrApp.modules.images.autoSyncImages();
        }
        
        // Add current images (including newly uploaded ones)
        if (JdrApp.modules.images && JdrApp.modules.images.getAllImages) {
          const currentImages = JdrApp.modules.images.getAllImages();
          const imagesData = {
            images: currentImages,
            meta: {
              total_images: Object.keys(currentImages).length,
              exported_date: new Date().toISOString().slice(0, 10),
              note: "Ces images incluent les nouvelles images uploadées"
            }
          };
          zip.file('data/images.json', JSON.stringify(imagesData, null, 2));
        }
        
        // Add page descriptions
        if (window.MONSTRES_PAGE_DESC) {
          zip.file('data/monstres-page-desc.json', JSON.stringify(window.MONSTRES_PAGE_DESC, null, 2));
        }
        
        if (window.TABLES_TRESORS_PAGE_DESC) {
          zip.file('data/tables-tresors-page-desc.json', JSON.stringify(window.TABLES_TRESORS_PAGE_DESC, null, 2));
        }
        
        // Add custom page descriptions (collections, etc.)
        if (JdrApp.data.customPageDescriptions) {
          zip.file('data/custom-page-descriptions.json', JSON.stringify(JdrApp.data.customPageDescriptions, null, 2));
        }
        
        // Add package.json and other config files
        const configFiles = ['package.json'];
        for (const configFile of configFiles) {
          const configContent = await this.fetchFileContent(configFile);
          if (configContent) {
            zip.file(configFile, configContent);
          }
        }
        
        // Generate and download ZIP
        const zipBlob = await zip.generateAsync({type: 'blob'});
        const timestamp = new Date().toISOString().slice(0, 16).replace(/[:-]/g, '');
        this.downloadFile(`JdrBab-${timestamp}.zip`, zipBlob, 'application/zip');
        
        this.showNotification('📦 Archive ZIP créée et téléchargée!', 'success');
        
      } catch (error) {
        console.error('❌ Failed to create ZIP:', error);
        this.showNotification('❌ Erreur lors de la création du ZIP', 'error');
      }
    },

    generateContentTypesJS(contentTypes) {
      // Generate the updated contentTypes.js file with current availableTags
      const availableTags = contentTypes.objet?.filterConfig?.availableTags || [];
      const defaultVisibleTags = contentTypes.objet?.filterConfig?.defaultVisibleTags || [];
      
      // Get monster tags configuration
      const monsterAvailableTags = contentTypes.monster?.filterConfig?.availableTags || [];
      const monsterDefaultVisibleTags = contentTypes.monster?.filterConfig?.defaultVisibleTags || [];
      
      return `// ============================================================================
// JDR-BAB APPLICATION - CONTENT TYPES CONFIGURATION
// ============================================================================

(() => {
  "use strict";

  window.ContentTypes = {
    spell: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        element: { type: 'select', label: 'Élément', required: true, options: ['Feu', 'Eau', 'Terre', 'Air', 'Lumière', 'Nuit', 'Divin', 'Maléfique'] },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'Prérequis', required: true },
        portee: { type: 'richtext', label: 'Portée', required: true },
        tempsIncantation: { type: 'richtext', label: "Temps d'incantation", required: true },
        coutMana: { type: 'richtext', label: 'Coût mana', required: true },
        resistance: { type: 'richtext', label: 'Résistance', required: true },
        effetNormal: { type: 'richtext', label: 'Effet normal', required: true },
        effetCritique: { type: 'richtext', label: 'Effet critique', required: false }
      },
      editMapping: {
        'spell-name': 'nom',
        'spell-element': 'element',
        'spell-description': 'description',
        'spell-prerequis': 'prerequis',
        'spell-portee': 'portee',
        'spell-mana': 'coutMana',
        'spell-temps-incantation': 'tempsIncantation',
        'spell-resistance': 'resistance',
        'spell-effect-normal': 'effetNormal',
        'spell-effect-critical': 'effetCritique'
      },
      identifiers: {
        name: 'nom',
        category: 'sorts'
      },
      template: 'spell-card',
      container: 'sorts',
      dataKey: 'SORTS',
      icons: { 
        category: '🔮', 
        item: '✨',
        add: '➕',
        delete: '🗑️'
      },
      defaultValues: {
        nom: "Nouveau Sort",
        element: "Feu",
        description: "Lance une boule de Feu sur un adversaire.",
        prerequis: "📋 <strong>Prérequis:</strong> Niveau 1",
        portee: "🎯 <strong>Portée:</strong> 20m",
        tempsIncantation: "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        coutMana: "🔵 <strong>Coût mana:</strong> 3",
        resistance: "<strong>Sans effet si:</strong> Esquive.",
        effetNormal: "<strong>Effet:</strong> Inflige 5 dégats de <span style='color: #e25822; font-weight: bold;'>Feu</span> à la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        effetCritique: "<strong>Coup Critique:&nbsp;</strong>&nbsp;Double les dégâts et enflamme la cible."
      }
    },

    don: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'Prérequis', required: true },
        cout: { type: 'richtext', label: 'Coût', required: true }
      },
      editMapping: {
        'don-name': 'nom',
        'don-description': 'description',
        'don-prerequis': 'prerequis',
        'don-cout': 'cout'
      },
      identifiers: {
        name: 'nom',
        category: 'dons'
      },
      template: 'don-card',
      container: 'dons',
      dataKey: 'DONS',
      icons: { 
        category: '🎖️', 
        item: '🏆',
        add: '➕',
        delete: '🗑️'
      },
      defaultValues: {
        nom: "Nouveau Don",
        description: "Description du don.",
        prerequis: "Aucun prérequis",
        cout: "1 point de don"
      }
    },

    class: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        resume: { type: 'textarea', label: 'Résumé', required: true },
        capacites: { type: 'list', label: 'Capacités', required: true }
      },
      editMapping: {
        'class-name': 'nom',
        'class-resume': 'resume',
        'class-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: null
      },
      template: 'class-page',
      container: 'classes',
      dataKey: 'CLASSES',
      icons: { 
        category: '⚔️', 
        item: '🛡️',
        add: '➕',
        delete: '🗑️'
      }
    },

    subclass: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        base: { type: 'stats', label: 'Statistiques de base', required: true },
        progression: { type: 'richtext', label: 'Progression', required: true },
        capacites: { type: 'list', label: 'Capacités', required: true }
      },
      editMapping: {
        'subclass-name': 'nom',
        'subclass-description': 'description',
        'subclass-stats': 'base',
        'subclass-progression': 'progression',
        'subclass-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: 'sousClasses',
        parent: 'class'
      },
      template: 'subclass-card',
      icons: { 
        item: '⚡',
        add: '➕',
        delete: '🗑️'
      },
      defaultValues: {
        nom: "Nouvelle sous-classe",
        description: "Description de la sous-classe",
        base: {
          Force: 3,
          Agilité: 3,
          Endurance: 3,
          Intelligence: 3,
          Volonté: 3,
          Chance: 3
        },
        progression: "<strong>📈 Progression par niveau:</strong> +1 Force 💪, +1 Agilité 🏃",
        capacites: [
          "<em>Capacité unique</em>: Description de la capacité spéciale de cette sous-classe."
        ]
      }
    },

    objet: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        numero: { type: 'number', label: 'Numéro', required: true },
        image: { type: 'text', label: 'Image', required: false },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        effet: { type: 'richtext', label: 'Effet', required: true },
        prix: { type: 'richtext', label: 'Prix', required: true },
        poids: { type: 'richtext', label: 'Poids', required: true }
      },
      editMapping: {
        'objet-name': 'nom',
        'objet-numero': 'numero',
        'objet-image': 'image',
        'objet-description': 'description',
        'objet-tags': 'tags',
        'objet-effet': 'effet',
        'objet-prix': 'prix',
        'objet-poids': 'poids'
      },
      identifiers: {
        name: 'nom',
        category: 'objets'
      },
      template: 'objet-card',
      container: 'objets',
      dataKey: 'OBJETS',
      pageType: 'single', // Page unique avec filtres
      icons: { 
        category: '📦', 
        item: '🎒',
        add: '➕',
        delete: '🗑️'
      },
      // Configuration des filtres disponibles (MISE À JOUR AUTOMATIQUE)
      filterConfig: {
        availableTags: ${JSON.stringify(availableTags, null, 10)},
        defaultVisibleTags: ${JSON.stringify(defaultVisibleTags, null, 10)} // Filtres affichés par défaut
      },
      defaultValues: {
        nom: "Nouvel Objet",
        numero: 1,
        image: "",
        description: "Description de l'objet.",
        tags: ["Nouvel objet"],
        effet: "<strong>Effet:</strong> Description de l'effet de l'objet.",
        prix: "🔷 <strong>Prix:</strong> 10",
        poids: "⚖️ <strong>Poids:</strong> 1"
      }
    },

    monster: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        image: { type: 'text', label: 'Image', required: false },
        element: { 
          type: 'select', 
          label: "Élément d'affiliation", 
          required: true,
          options: [
            { value: 'Feu', label: '🔥 Feu' },
            { value: 'Eau', label: '💧 Eau' },
            { value: 'Terre', label: '🤎 Terre' },
            { value: 'Air', label: '🟢 Air' },
            { value: 'Lumiere', label: '☀️ Lumière' },
            { value: 'Nuit', label: '⚫ Nuit' },
            { value: 'Divin', label: '⚪ Divin' },
            { value: 'Malefique', label: '🟣 Maléfique' }
          ]
        },
        pointsDeVie: { type: 'number', label: 'Points de vie', required: true },
        armurePhysique: { type: 'number', label: 'Armure physique', required: true },
        esquive: { type: 'number', label: 'Esquive', required: true },
        coupCritique: { type: 'number', label: 'Coup critique', required: true },
        coupCritiqueSorts: { type: 'number', label: 'Critique sorts', required: true },
        resistanceAlterations: { type: 'number', label: 'Résistance altérations', required: true },
        armureFeu: { type: 'number', label: 'Armure Feu', required: true },
        armureEau: { type: 'number', label: 'Armure Eau', required: true },
        armureTerre: { type: 'number', label: 'Armure Terre', required: true },
        armureAir: { type: 'number', label: 'Armure Air', required: true },
        armureLumiere: { type: 'number', label: 'Armure Lumière', required: true },
        armureObscurite: { type: 'number', label: 'Armure Obscurité', required: true },
        armureDivin: { type: 'number', label: 'Armure Divin', required: true },
        armureMalefique: { type: 'number', label: 'Armure Maléfique', required: true },
        abilites: { type: 'richtext', label: 'Abilités', required: false },
        butin: { type: 'richtext', label: 'Butin', required: false }
      },
      editMapping: {
        'monster-name': 'nom',
        'monster-tags': 'tags',
        'monster-image': 'image',
        'monster-element': 'element',
        // Stats principaux
        'monster-pointsdevie': 'pointsDeVie',
        'monster-armurephysique': 'armurePhysique', 
        'monster-esquive': 'esquive',
        'monster-coupcritique': 'coupCritique',
        'monster-coupcritiquesorts': 'coupCritiqueSorts',
        'monster-resistancealterations': 'resistanceAlterations',
        // Armures élémentaires
        'monster-armurefeu': 'armureFeu',
        'monster-armureeau': 'armureEau',
        'monster-armureterre': 'armureTerre',
        'monster-armureair': 'armureAir',
        'monster-armurelumiere': 'armureLumiere',
        'monster-armureobscurite': 'armureObscurite',
        'monster-armuredivin': 'armureDivin',
        'monster-armuremalefique': 'armureMalefique',
        // Contenu narratif
        'monster-abilites': 'abilites',
        'monster-butin': 'butin'
      },
      identifiers: {
        name: 'nom',
        category: 'monstres'
      },
      template: 'monster-card',
      container: 'monstres',
      dataKey: 'MONSTRES',
      pageType: 'single',
      filterMode: 'AND',
      icons: { 
        category: '🐲', 
        item: '👾',
        add: '➕',
        delete: '🗑️'
      },
      filterConfig: {
        availableTags: ${JSON.stringify(monsterAvailableTags, null, 10)},
        defaultVisibleTags: ${JSON.stringify(monsterDefaultVisibleTags, null, 10)}
      },
      defaultValues: {
        nom: "Nouveau Monstre",
        tags: ["Forêt"],
        image: "",
        element: "Feu",
        pointsDeVie: 20,
        armurePhysique: 2,
        esquive: 5,
        coupCritique: 10,
        coupCritiqueSorts: 8,
        resistanceAlterations: 3,
        armureFeu: 0,
        armureEau: 0,
        armureTerre: 0,
        armureAir: 0,
        armureLumiere: 0,
        armureObscurite: 0,
        armureDivin: 0,
        armureMalefique: 0,
        abilites: "<strong>Attaque basique:</strong> Inflige 5 dégâts physiques.",
        butin: "<strong>Butin:</strong> 10-50 pièces d'or."
      }
    },

    tableTresor: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        fourchettes: { type: 'list', label: 'Fourchettes', required: true }
      },
      editMapping: {
        'table-tresor-name': 'nom',
        'table-tresor-description': 'description',
        'table-tresor-tags': 'tags'
      },
      identifiers: {
        name: 'nom',
        category: 'tables'
      },
      template: 'table-tresor-card',
      container: 'tables-tresors',
      dataKey: 'TABLES_TRESORS',
      pageType: 'single',
      filterMode: 'OR',
      icons: { 
        category: '💎', 
        item: '📦',
        add: '➕',
        delete: '🗑️'
      },
      filterConfig: {
        // availableTags managed dynamically via window.TABLES_TRESORS._metadata.availableTags
        defaultVisibleTags: [
          "Forêt",
          "Boss"
        ]
      },
      defaultValues: {
        nom: "Nouvelle Table de Trésor",
        description: "Table de butin pour une situation spécifique.",
        tags: ["Forêt"],
        fourchettes: [
          {
            min: 1,
            max: 10,
            objet: {
              type: "reference",
              numero: 1,
              nom: "Objet par défaut"
            }
          }
        ]
      }
    },

    staticPage: {
      fields: {
        title: { type: 'text', label: 'Titre', required: true },
        sections: { type: 'sections', label: 'Sections', required: true }
      },
      template: 'static-page',
      icons: { 
        category: '📄', 
        item: '📝'
      }
    }
  };

  window.StatIcons = {
    'Force': '💪',
    'Agilité': '🏃',
    'Endurance': '🛡️',
    'Intelligence': '🧠',
    'Volonté': '⚡',
    'Chance': '🍀'
  };

  window.ElementColors = {
    'Feu': { color: '#ff6b35', weight: 'bold' },
    'Eau': { color: '#4682b4', weight: 'bold' },
    'Terre': { color: '#8b4513', weight: 'bold' },
    'Air': { color: '#22c55e', weight: 'bold' },
    'Lumière': { color: '#ffd700', weight: 'bold' },
    'Nuit': { color: '#1a1a1a', weight: 'bold' },
    'Divin': { color: '#f5f5f5', weight: 'bold', background: 'rgba(100, 100, 100, 0.3)', padding: '2px 4px', borderRadius: '3px' },
    'Maléfique': { color: '#8b5cf6', weight: 'bold' }
  };

  window.ElementIcons = {
    'Feu': '🔥',
    'Eau': '💧',
    'Terre': '🤎',
    'Air': '🟢',
    'Lumière': '☀️',
    'Nuit': '⚫',
    'Divin': '⚪',
    'Maléfique': '🟣'
  };

})();`;
    },

    async loadJSZip() {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    },

    async fetchFileContent(filePath) {
      try {
        const response = await fetch(filePath);
        if (response.ok) {
          return await response.text();
        }
        // Could not fetch file
        return null;
      } catch (error) {
        // Error fetching file
        return null;
      }
    },

    async getMainHTML() {
      // Get the current index.html content or reconstruct it
      try {
        const response = await fetch('index.html');
        if (response.ok) {
          return await response.text();
        }
      } catch (error) {
        // Could not fetch index.html, generating from current state
      }
      
      // Fallback: generate HTML from current document state
      return `<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta name="referrer" content="no-referrer-when-downgrade">
<title>JDR‑BAB — Livret de règles</title>
<meta content="Livret web multipages des règles JDR‑BAB, thème parchemin, illustrations par catégorie/classe/sous‑classe, export HTML autonome." name="description">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&amp;family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600&amp;display=swap" rel="stylesheet">

<!-- CSS Modulaire -->
<link rel="stylesheet" href="css/theme.css">
<link rel="stylesheet" href="css/utilities.css">
<link rel="stylesheet" href="css/components.css">
<link rel="stylesheet" href="css/layout.css">
<link rel="stylesheet" href="css/editor.css">
</head>
<body class="dev-off" style="">

<!-- Le contenu HTML complet sera injecté ici par le JavaScript -->
<div id="app-loading">Chargement...</div>

<!-- JavaScript Modulaire -->
</body>
</html>`;
    },


    downloadJSON(filename, data) {
      const json = JSON.stringify(data, null, 2);
      this.downloadFile(filename, json, 'application/json');
    },

    downloadFile(filename, content, mimeType = 'text/html') {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.style.display = 'none';
      
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      URL.revokeObjectURL(url);
    },

    showNotification(message, type = 'info') {
      // Simple notification system
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${type === 'success' ? '#10B981' : type === 'error' ? '#EF4444' : '#3B82F6'};
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        font-weight: 500;
        z-index: 10000;
        animation: slideIn 0.3s ease;
      `;
      
      // Add animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      notification.textContent = message;
      document.body.appendChild(notification);
      
      // Auto-remove after 3 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    },

    // Load edits from localStorage on startup
    loadStoredEdits() {
      try {
        const storedEdits = localStorage.getItem('jdr-bab-edits');
        
        if (storedEdits && JdrApp.modules.editor) {
          JdrApp.modules.editor.editedData = JSON.parse(storedEdits);
        }
        
        // Load stored static pages data (includes dynamically created sections)
        const storedStaticPages = localStorage.getItem('jdr-bab-static-pages');
        if (storedStaticPages) {
          const staticPagesData = JSON.parse(storedStaticPages);
          
          // Merge with existing STATIC_PAGES data
          if (window.STATIC_PAGES) {
            Object.assign(window.STATIC_PAGES, staticPagesData);
          } else {
            window.STATIC_PAGES = staticPagesData;
          }
          
          console.log('Restored static pages data from localStorage:', Object.keys(staticPagesData));
        }
        
        // Ne plus charger jdr-bab-data - laisser les JSON être la source de vérité
        
      } catch (error) {
        console.warn('Failed to load stored edits:', error);
      }
    },

    // Handle ZIP file import
    async handleZipImport(event) {
      const file = event.target.files[0];
      if (!file || file.type !== 'application/zip') {
        this.showNotification('❌ Veuillez sélectionner un fichier ZIP', 'error');
        return;
      }

      try {
        this.showNotification('📥 Import en cours...', 'info');

        // Check if JSZip is available
        if (typeof JSZip === 'undefined') {
          await this.loadJSZip();
        }

        const zip = new JSZip();
        const contents = await zip.loadAsync(file);

        // Import data files
        const dataFiles = ['sorts.json', 'classes.json', 'dons.json', 'objets.json', 'monstres.json'];
        for (const dataFile of dataFiles) {
          const zipFile = contents.file(`data/${dataFile}`);
          if (zipFile) {
            const content = await zipFile.async('text');
            const data = JSON.parse(content);
            
            if (dataFile === 'sorts.json') {
              window.SORTS = data;
              JdrApp.data.SORTS = data;
            } else if (dataFile === 'classes.json') {
              window.CLASSES = data;
              JdrApp.data.CLASSES = data;
            } else if (dataFile === 'dons.json') {
              window.DONS = data;
              JdrApp.data.DONS = data;
            } else if (dataFile === 'objets.json') {
              window.OBJETS = data;
              JdrApp.data.OBJETS = data;
            } else if (dataFile === 'monstres.json') {
              window.MONSTRES = data;
              JdrApp.data.MONSTRES = data;
            } else if (dataFile === 'tables-tresors.json') {
              window.TABLES_TRESORS = data;
              JdrApp.data.TABLES_TRESORS = data;
            } else if (dataFile === 'collections.json') {
              window.COLLECTIONS = data;
              JdrApp.data.COLLECTIONS = data;
            } else if (dataFile === 'toc-structure.json') {
              window.TOC_STRUCTURE = data;
              JdrApp.data.TOC_STRUCTURE = data;
            }
          }
        }

        // Import static pages config
        const configFile = contents.file('data/static-pages-config.json');
        if (configFile) {
          const configContent = await configFile.async('text');
          window.STATIC_PAGES_CONFIG = JSON.parse(configContent);
          JdrApp.data.STATIC_PAGES_CONFIG = JSON.parse(configContent);
        }

        // Import static pages data
        if (window.STATIC_PAGES_CONFIG && window.STATIC_PAGES_CONFIG.pages) {
          window.STATIC_PAGES = {};
          JdrApp.data.STATIC_PAGES = {};
          for (const pageConfig of window.STATIC_PAGES_CONFIG.pages) {
            if (pageConfig.active) {
              const pageFile = contents.file(`data/${pageConfig.file}`);
              if (pageFile) {
                const pageContent = await pageFile.async('text');
                const pageData = JSON.parse(pageContent);
                window.STATIC_PAGES[pageConfig.id] = pageData;
                JdrApp.data.STATIC_PAGES[pageConfig.id] = pageData;
              }
            }
          }
        }

        // Import images
        const imagesFile = contents.file('data/images.json');
        if (imagesFile && JdrApp.modules.images && JdrApp.modules.images.importImages) {
          const imagesContent = await imagesFile.async('text');
          const imagesData = JSON.parse(imagesContent);
          if (imagesData.images) {
            JdrApp.modules.images.importImages(imagesData.images);
          }
        }

        // Import custom page descriptions
        const customDescFile = contents.file('data/custom-page-descriptions.json');
        if (customDescFile) {
          const customDescContent = await customDescFile.async('text');
          const customDescData = JSON.parse(customDescContent);
          window.CUSTOM_PAGE_DESCRIPTIONS = customDescData;
          JdrApp.data.customPageDescriptions = { ...JdrApp.data.customPageDescriptions, ...customDescData };
        }

        // Save imported data to localStorage
        this.saveChanges(true);

        this.showNotification('✅ Import réussi! Rechargement...', 'success');

        // Reload page to show imported data
        setTimeout(() => {
          window.location.reload();
        }, 1000);

      } catch (error) {
        this.showNotification('❌ Erreur lors de l\'import', 'error');
      }

      // Reset file input
      event.target.value = '';
    },


  };

})();
// ============================================================================
// JDR-BAB APPLICATION - SPELL FILTER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // SPELL FILTER MODULE
  // ========================================
  const SpellFilter = {
    // Cache for performance
    _cachedCards: null,
    _lastCategoryHash: null,
    
    init() {
      this.setupEventListeners();
    },

    setupEventListeners() {
      // Use throttled event delegation for better performance
      document.addEventListener('input', (e) => {
        if (e.target && e.target.id === 'spell-level-filter') {
          // Throttle filter calls for smoother performance
          this.throttledFilter(parseInt(e.target.value, 10));
        }
      });

      document.addEventListener('click', (e) => {
        if (e.target && e.target.id === 'reset-spell-filter') {
          e.preventDefault();
          this.resetFilter();
        }
      });

      // Setup when page changes (router events)
      if (window.EventBus && window.Events) {
        EventBus.on(Events.PAGE_RENDER, (payload) => {
          if (payload.type === 'category' && payload.categoryType === 'spell') {
            // Clear cache and re-setup filter after page render
            this.clearCache();
            setTimeout(() => this.initializeFilter(), 200);
          }
        });
      }

      // Also listen to hash changes for direct navigation
      window.addEventListener('hashchange', () => {
        this.clearCache();
        setTimeout(() => this.initializeFilter(), 200);
      });
    },

    // Clear cache when changing pages
    clearCache() {
      this._cachedCards = null;
      this._lastCategoryHash = null;
    },

    // Throttled filter function for better performance
    throttledFilter: (function() {
      let timeout = null;
      return function(maxLevel) {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          this.filterSpellsByLevel(maxLevel);
        }, 100); // 100ms throttle
      };
    })(),

    initializeFilter() {
      const filterInput = document.querySelector('#spell-level-filter');
      if (!filterInput) return;
      
      // Set initial value and apply filter
      const initialValue = parseInt(filterInput.value, 10) || 20;
      this.filterSpellsByLevel(initialValue);
    },

    filterSpellsByLevel(maxLevel) {
      // Get current page from URL hash
      const currentHash = window.location.hash.replace('#/', '');
      
      if (!currentHash.startsWith('sorts-')) {
        return;
      }
      
      // Extract category name from hash - handle double sorts- prefix
      // URLs like 'sorts-sorts-de-mage' or 'sorts-mage' should both work
      let currentCategoryName = currentHash.replace('sorts-', '');
      if (currentCategoryName.startsWith('sorts-')) {
        // Handle double prefix case: 'sorts-sorts-de-mage' -> 'sorts-de-mage'
        currentCategoryName = currentCategoryName.replace('sorts-', '');
      }
      
      // Use cached cards if same category, otherwise refresh cache
      let spellCards;
      if (this._lastCategoryHash === currentHash && this._cachedCards) {
        spellCards = this._cachedCards;
      } else {
        // Only query DOM when necessary
        spellCards = document.querySelectorAll('article.active .card[data-spell-name]');
        this._cachedCards = spellCards;
        this._lastCategoryHash = currentHash;
      }
      
      if (spellCards.length === 0) return;

      let visibleCount = 0;
      let categoryTotalCount = 0;

      spellCards.forEach((card) => {
        const spellName = card.dataset.spellName;
        const categoryName = card.dataset.categoryName;
        
        // More flexible category matching
        const matches = this.categoryMatches(categoryName, currentCategoryName);
        
        if (matches) {
          categoryTotalCount++;
          
          // Find the spell data to get its level
          const spellLevel = this.getSpellLevel(spellName, categoryName);
          
          if (spellLevel <= maxLevel) {
            card.style.display = '';
            visibleCount++;
          } else {
            card.style.display = 'none';
          }
        } else {
          // Hide cards from other categories completely
          card.style.display = 'none';
        }
      });
      
      // Update filter display with count (use category total instead of all spells)
      this.updateFilterDisplay(maxLevel, visibleCount, categoryTotalCount);
    },

    categoryMatches(categoryName, currentCategoryName) {
      if (!categoryName || !currentCategoryName) {
        return false;
      }
      
      const catLower = categoryName.toLowerCase();
      const currentLower = currentCategoryName.toLowerCase();
      
      
      
      // Normalize both strings: replace hyphens with spaces
      const normalizedCat = catLower.replace(/[-_]/g, ' ').trim();
      const normalizedCurrent = currentLower.replace(/[-_]/g, ' ').trim();
      
      // Direct match
      if (normalizedCat === normalizedCurrent) {
        return true;
      }
      
      // Handle all possible URL-to-category mappings (including malformed URLs):
      const categoryMappings = {
        'mage': 'sorts de mage',
        'sorts de mage': 'sorts de mage',
        'de mage': 'sorts de mage',            // After normalization (tirets → espaces)
        'pretre': 'sorts de prêtre', 
        'prêtre': 'sorts de prêtre',
        'pr tre': 'sorts de prêtre',           // Malformed: missing ê
        'sorts de pr tre': 'sorts de prêtre',  // Malformed: missing ê
        'de pr tre': 'sorts de prêtre',        // After normalization - FIXED!
        'de-pr-tre': 'sorts de prêtre',        // Direct URL version (tirets)
        'sorts de prêtre': 'sorts de prêtre',  // Full name
        'de prêtre': 'sorts de prêtre',        // After double prefix removal + normalization
        'enchanteur': "sorts d'enchanteur",
        'd enchanteur': "sorts d'enchanteur",  // Malformed: missing '
        'sorts d enchanteur': "sorts d'enchanteur", // Malformed: missing '
        'd enchanteur': "sorts d'enchanteur",  // After normalization - FIXED!
        'd-enchanteur': "sorts d'enchanteur", // Direct URL version (tirets)
        "sorts d'enchanteur": "sorts d'enchanteur", // Full name
        "d'enchanteur": "sorts d'enchanteur"   // After double prefix removal
      };
      
      // Direct mapping lookup (try both original and normalized versions)
      const mappingMatch = categoryMappings[currentLower] || categoryMappings[normalizedCurrent];
      if (mappingMatch && normalizedCat === mappingMatch.toLowerCase()) {
        return true;
      }
      
      // Reverse lookup - strip common prefixes from category
      const strippedCat = normalizedCat
        .replace(/^sorts de /, '')
        .replace(/^sorts d'/, '')
        .replace(/^sorts d /, '')    // Handle missing apostrophe
        .replace(/^sorts /, '');
        
      if (strippedCat === normalizedCurrent) {
        return true;
      }
      
      // Handle various character issues
      const normalizedStrippedCat = strippedCat
        .replace(/ê/g, 'e')     // ê -> e
        .replace(/'/g, '')      // Remove apostrophes
        .replace(/\s+/g, ' ')   // Normalize spaces
        .trim();
        
      const normalizedExtracted = normalizedCurrent
        .replace(/ê/g, 'e')     
        .replace(/'/g, '')      
        .replace(/\s+/g, ' ')   
        .trim();
        
      if (normalizedStrippedCat === normalizedExtracted) {
        return true;
      }
      
      // Additional fuzzy matches for common issues
      if ((strippedCat === 'prêtre' || strippedCat === 'pretre') && 
          (normalizedCurrent.includes('pr') && normalizedCurrent.includes('tre'))) {
        return true;
      }
      
      if (strippedCat === 'enchanteur' && 
          (normalizedCurrent.includes('enchanteur') || normalizedCurrent.includes('d enchanteur'))) {
        return true;
      }
      
      
      return false;
    },

    getSpellLevel(spellName, categoryName) {
      if (!window.SORTS) return 0;

      // Find the category using flexible matching
      let category = window.SORTS.find(cat => {
        const catLower = cat.nom.toLowerCase();
        const nameLower = categoryName.toLowerCase();
        
        return catLower === nameLower ||
               catLower === `sorts de ${nameLower}` ||
               catLower === `sorts d'${nameLower}` ||
               catLower.includes(nameLower);
      });
      
      if (!category || !category.sorts) return 0;

      // Find the spell
      const spell = category.sorts.find(sort => sort.nom === spellName);
      if (!spell || !spell.prerequis) return 0;

      // Extract level from prerequisite - handle HTML content
      const cleanPrerequisite = spell.prerequis.replace(/<[^>]*>/g, '');
      const match = cleanPrerequisite.match(/Niveau\s*(\d+)/i);
      
      return match ? parseInt(match[1], 10) : 0;
    },

    updateFilterDisplay(maxLevel, visibleCount, totalCount) {
      const activeArticle = document.querySelector('article.active');
      if (!activeArticle) return;
      
      const filterContainer = activeArticle.querySelector('.spell-level-filter');
      if (!filterContainer) return;
      
      // Chercher le container des contrôles (avec input et bouton)
      const controlsContainer = filterContainer.querySelector('div[style*="flex-wrap"]');
      if (!controlsContainer) return;
      
      // Supprimer les anciens textes
      const allOldTexts = filterContainer.querySelectorAll('.filter-result-text');
      allOldTexts.forEach(old => old.remove());
      
      // Créer le nouveau texte
      const resultText = document.createElement('span');
      resultText.className = 'filter-result-text';
      resultText.textContent = `📊 ${visibleCount}/${totalCount} sorts affichés (niveau ≤ ${maxLevel})`;
      resultText.style.cssText = `
        padding: 0.5rem 1rem !important;
        background-color: #e8f4f8 !important;
        color: #2c5aa0 !important;
        border: 1px solid #b3d9e8 !important;
        border-radius: 6px !important;
        font-size: 0.85rem !important;
        font-weight: 600 !important;
        white-space: nowrap !important;
        display: inline-block !important;
      `;
      
      // L'ajouter dans le container des contrôles
      controlsContainer.appendChild(resultText);
    },

    resetFilter() {
      const filterInput = document.querySelector('#spell-level-filter');
      if (filterInput) {
        filterInput.value = '20';
        this.filterSpellsByLevel(20);
      }
      
      // Clear the count display
      const countContainer = document.querySelector('#spell-filter-count');
      if (countContainer) {
        countContainer.textContent = '';
        countContainer.style.display = 'none';
      }
    }
  };

  // Initialize the spell filter when the app is ready
  function initializeSpellFilter() {
    
    if (window.JdrApp) {
      if (JdrApp.modules) {
        JdrApp.modules.spellFilter = SpellFilter;
      }
    }
    
    // Initialize the filter
    SpellFilter.init();
    
    // Try to initialize the filter after a delay to ensure DOM is ready
    setTimeout(() => {
      if (window.location.hash.includes('sorts-')) {
        SpellFilter.initializeFilter();
      }
    }, 500);
  }

  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeSpellFilter);
  } else {
    // DOM is already ready
    initializeSpellFilter();
  }

  window.SpellFilter = SpellFilter;

})();
// ============================================================================
// JDR-BAB APPLICATION - TABLES DE TRESORS MANAGER
// ============================================================================

(() => {
  "use strict";

  class TablesTresorsManager {
    constructor() {
      this.initialized = false;
      this.currentPreviewModal = null;
      this.currentEditModal = null;
      this.modalIsOpening = false;
    }

    static getInstance() {
      if (!TablesTresorsManager.instance) {
        TablesTresorsManager.instance = new TablesTresorsManager();
      }
      return TablesTresorsManager.instance;
    }

    init() {
      if (this.initialized) return;
      
      this.setupEventListeners();
      this.initialized = true;
      // TablesTresorsManager initialized
    }

    setupEventListeners() {
      // Preview d'objets
      document.addEventListener('click', (e) => {
        if (e.target.matches('.object-preview-link')) {
          e.preventDefault();
          e.stopPropagation();
          const numeroObjet = e.target.dataset.objectNumero;
          this.showObjectPreview(numeroObjet);
        }
      });

      // Édition de fourchette
      document.addEventListener('click', (e) => {
        if (e.target.matches('.edit-fourchette-btn')) {
          const tableName = e.target.dataset.tableName;
          const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
          this.showEditFourchetteModal(tableName, fourchetteIndex);
        }
      });

      // Suppression de fourchette
      document.addEventListener('click', (e) => {
        if (e.target.matches('.delete-fourchette-btn')) {
          const tableName = e.target.dataset.tableName;
          const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
          this.deleteFourchette(tableName, fourchetteIndex);
        }
      });

      // Ajout de nouvelle fourchette
      document.addEventListener('click', (e) => {
        if (e.target.matches('.table-tresor-add-fourchette')) {
          const tableName = e.target.dataset.tableTresorName;
          this.showEditFourchetteModal(tableName, -1); // -1 pour nouvelle fourchette
        }
      });

      // Fermer les modals en cliquant à l'extérieur
      document.addEventListener('click', (e) => {
        if (e.target.matches('.modal-overlay')) {
          this.closeAllModals();
        }
      });

      // Fermer avec la touche Escape
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          this.closeAllModals();
        }
      });

      // Preview de table de trésor via lien HTML
      document.addEventListener('click', (e) => {
        if (e.target.matches('.treasure-table-link')) {
          e.preventDefault();
          const tableName = e.target.dataset.tableName;
          this.showTablePreview(tableName);
        }
      });
    }

    showObjectPreview(numeroObjet) {
      try {
        // Trouver l'objet par son numéro
        const objet = window.OBJETS?.objets?.find(obj => obj.numero == numeroObjet);
        
        if (!objet) {
          console.error('Objet non trouvé:', numeroObjet);
          return;
        }

        const previewHtml = this.generateObjectPreviewHtml(objet);
        this.showModal(previewHtml, 'object-preview');
        
      } catch (error) {
        console.error('Erreur lors de l\'affichage de la preview:', error);
      }
    }

    showTablePreview(tableName) {
      try {
        // Trouver la table par son nom
        const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === tableName);
        
        if (!table) {
          console.error('Table non trouvée:', tableName);
          return;
        }

        const previewHtml = this.generateTablePreviewHtml(table);
        const modalContent = `
          <div class="table-preview-content">
            ${previewHtml}
            <div style="text-align: center; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--rule);">
              <button class="btn" onclick="window.TablesTresorsManager.closeAllModals()" style="background: var(--accent); color: white;">
                ✓ Fermer
              </button>
              <button class="btn" onclick="window.TablesTresorsManager.goToTablesTresorsPage()" style="background: var(--bronze); color: white; margin-left: 0.5rem;">
                🔗 Aller à la page tables de trésors
              </button>
            </div>
          </div>
        `;
        
        this.showModal(modalContent, 'table-preview');
        
      } catch (error) {
        console.error('Erreur lors de l\'affichage de la preview de table:', error);
      }
    }

    generateObjectPreviewHtml(objet) {
      // Utiliser le CardBuilder pour générer la card d'objet standard
      const cardHtml = CardBuilder.create('objet', objet, 'preview').build();
      
      // Wrapper la card dans un conteneur de preview avec les boutons
      return `
        <div class="object-preview-content">
          <div style="margin-bottom: 1.5rem;">
            ${cardHtml}
          </div>
          
          <div style="text-align: center; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--rule);">
            <button class="btn" onclick="window.TablesTresorsManager.closeAllModals()" style="background: var(--accent); color: white;">
              ✓ Fermer
            </button>
            <button class="btn" onclick="window.TablesTresorsManager.goToObject(${objet.numero})" style="background: var(--bronze); color: white; margin-left: 0.5rem;">
              🔗 Aller à la page objets
            </button>
          </div>
        </div>
      `;
    }

    showEditFourchetteModal(tableName, fourchetteIndex) {
      try {
        const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === tableName);
        if (!table) {
          console.error('Table non trouvée:', tableName);
          return;
        }

        const isNewFourchette = fourchetteIndex === -1;
        const fourchette = isNewFourchette ? { min: 1, max: 1, objet: { type: 'reference', numero: 1, nom: 'Choisir un objet' } } : table.fourchettes[fourchetteIndex];

        if (!isNewFourchette && !fourchette) {
          console.error('Fourchette non trouvée:', fourchetteIndex);
          return;
        }

        const editHtml = this.generateEditFourchetteHtml(tableName, fourchetteIndex, fourchette, isNewFourchette);
        this.showModal(editHtml, 'edit-fourchette');

      } catch (error) {
        console.error('Erreur lors de l\'affichage du modal d\'édition:', error);
      }
    }

    generateEditFourchetteHtml(tableName, fourchetteIndex, fourchette, isNewFourchette) {
      // Générer la liste des tags uniques
      const allTags = new Set();
      window.OBJETS?.objets?.forEach(obj => {
        obj.tags?.forEach(tag => allTags.add(tag));
      });
      const sortedTags = Array.from(allTags).sort();
      
      const tagOptions = ['<option value="">Tous les objets</option>']
        .concat(sortedTags.map(tag => `<option value="${tag}">${tag}</option>`))
        .join('');

      // Générer la liste des objets disponibles
      const objetsOptions = window.OBJETS?.objets?.map(obj => 
        `<option value="${obj.numero}" data-tags="${obj.tags?.join(',') || ''}" ${obj.numero == fourchette.objet.numero ? 'selected' : ''}>N°${obj.numero} - ${obj.nom}</option>`
      ).join('') || '<option value="1">Aucun objet disponible</option>';

      return `
        <div class="edit-fourchette-content">
          <header style="text-align: center; margin-bottom: 1rem; border-bottom: 2px solid var(--bronze); padding-bottom: 1rem;">
            <h3 style="margin: 0; color: var(--accent);">
              ${isNewFourchette ? '➕ Ajouter une fourchette' : '✏️ Éditer la fourchette'}
            </h3>
            <div style="color: var(--bronze); font-size: 0.9em;">Table: ${tableName}</div>
          </header>
          
          <form id="edit-fourchette-form">
            <input type="hidden" id="table-name" value="${tableName}">
            <input type="hidden" id="fourchette-index" value="${fourchetteIndex}">
            <input type="hidden" id="is-new-fourchette" value="${isNewFourchette}">
            <div style="margin: 1rem 0;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: bold; color: var(--accent);">
                🎲 Fourchette de dé (1-20):
              </label>
              <div style="display: flex; gap: 1rem; align-items: center;">
                <div style="flex: 1;">
                  <label style="font-size: 0.9em; color: var(--paper-muted);">Minimum:</label>
                  <input 
                    type="number" 
                    id="fourchette-min" 
                    min="1" 
                    max="20" 
                    value="${fourchette.min || 1}"
                    style="width: 100%; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px;"
                    required
                  >
                </div>
                <div style="padding: 1rem 0.5rem; color: var(--accent); font-weight: bold;">-</div>
                <div style="flex: 1;">
                  <label style="font-size: 0.9em; color: var(--paper-muted);">Maximum:</label>
                  <input 
                    type="number" 
                    id="fourchette-max" 
                    min="1" 
                    max="20" 
                    value="${fourchette.max || 1}"
                    style="width: 100%; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px;"
                    required
                  >
                </div>
              </div>
            </div>
            
            <div style="margin: 1rem 0;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: bold; color: var(--accent);">
                🏷️ Filtrer par tag:
              </label>
              <select 
                id="tag-filter" 
                style="width: 100%; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px; background: var(--paper-light);"
              >
                ${tagOptions}
              </select>
            </div>
            
            <div style="margin: 1rem 0;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: bold; color: var(--accent);">
                📦 Objet associé:
              </label>
              <select 
                id="fourchette-objet" 
                style="width: 100%; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px;"
                required
              >
                ${objetsOptions}
              </select>
              <div style="margin-top: 0.5rem;">
                <button 
                  type="button" 
                  id="preview-selected-object" 
                  class="btn small" 
                  style="background: var(--bronze); color: white; font-size: 0.8em;"
                >
                  👁️ Aperçu de l'objet sélectionné
                </button>
              </div>
            </div>
            
            <div style="text-align: center; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--rule);">
              <button type="submit" class="btn" style="background: var(--accent); color: white;">
                ${isNewFourchette ? '➕ Ajouter' : '✓ Sauvegarder'}
              </button>
              <button type="button" onclick="window.TablesTresorsManager.closeAllModals()" class="btn" style="background: #6b7280; color: white; margin-left: 0.5rem;">
                ❌ Annuler
              </button>
            </div>
          </form>
        </div>
      `;
    }

    showModal(content, modalClass = '') {
      // Éviter l'ouverture de modals multiples rapidement
      if (this.modalIsOpening) {
        return;
      }
      
      this.modalIsOpening = true;
      this.closeAllModals(); // Fermer les modals existants

      const modalHtml = `
        <div class="modal-overlay ${modalClass}" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 1000;">
          <div class="modal-content" style="background: var(--paper); border-radius: 12px; padding: 2rem; max-width: 90vw; max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 25px rgba(0,0,0,0.3); border: 2px solid var(--rule);">
            ${content}
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML('beforeend', modalHtml);
      
      // Setup form handler si c'est le modal d'édition
      if (modalClass === 'edit-fourchette') {
        this.setupEditFormHandlers();
      }
      
      // Réinitialiser le flag après un court délai
      setTimeout(() => {
        this.modalIsOpening = false;
      }, 200);
    }

    setupEditFormHandlers() {
      const form = document.getElementById('edit-fourchette-form');
      if (!form) return;

      form.addEventListener('submit', (e) => {
        e.preventDefault();
        this.saveFourchette();
      });

      // Preview de l'objet sélectionné
      const previewBtn = document.getElementById('preview-selected-object');
      if (previewBtn) {
        previewBtn.addEventListener('click', () => {
          const selectElement = document.getElementById('fourchette-objet');
          const selectedNumero = selectElement.value;
          this.showObjectPreview(selectedNumero);
        });
      }

      // Filtrage par tag
      const tagFilter = document.getElementById('tag-filter');
      const objectSelect = document.getElementById('fourchette-objet');
      
      if (tagFilter && objectSelect) {
        // Stocker toutes les options initiales
        const allOptions = Array.from(objectSelect.options);
        
        tagFilter.addEventListener('change', () => {
          const selectedTag = tagFilter.value;
          const currentSelectedValue = objectSelect.value;
          
          // Vider les options actuelles
          objectSelect.innerHTML = '';
          
          // Filtrer et réajouter les options
          const filteredOptions = allOptions.filter(option => {
            if (!selectedTag) return true; // Afficher tous si aucun tag sélectionné
            const optionTags = option.dataset.tags || '';
            return optionTags.split(',').includes(selectedTag);
          });
          
          // Réajouter les options filtrées
          filteredOptions.forEach(option => {
            objectSelect.appendChild(option.cloneNode(true));
          });
          
          // Restaurer la sélection si elle est toujours disponible
          const stillAvailable = filteredOptions.find(option => option.value === currentSelectedValue);
          if (stillAvailable) {
            objectSelect.value = currentSelectedValue;
          } else if (filteredOptions.length > 0) {
            objectSelect.selectedIndex = 0;
          }
        });
      }

      // Validation en temps réel
      const minInput = document.getElementById('fourchette-min');
      const maxInput = document.getElementById('fourchette-max');
      
      const validateRange = () => {
        const min = parseInt(minInput.value);
        const max = parseInt(maxInput.value);
        
        if (min > max) {
          maxInput.value = min;
        }
      };

      minInput.addEventListener('change', validateRange);
      maxInput.addEventListener('change', validateRange);
    }

    saveFourchette() {
      try {
        const form = document.getElementById('edit-fourchette-form');
        const formData = new FormData(form);
        
        const min = parseInt(document.getElementById('fourchette-min').value);
        const max = parseInt(document.getElementById('fourchette-max').value);
        const objetNumero = parseInt(document.getElementById('fourchette-objet').value);
        
        // Trouver l'objet sélectionné
        const objet = window.OBJETS?.objets?.find(obj => obj.numero === objetNumero);
        if (!objet) {
          alert('Objet sélectionné introuvable');
          return;
        }

        const newFourchette = {
          min: min,
          max: max,
          objet: {
            type: 'reference',
            numero: objet.numero,
            nom: objet.nom
          }
        };

        // Extraire les informations depuis les champs cachés du formulaire
        const tableName = document.getElementById('table-name').value;
        const fourchetteIndex = parseInt(document.getElementById('fourchette-index').value);
        const isNewFourchette = document.getElementById('is-new-fourchette').value === 'true';
        
        const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === tableName);
        
        if (!table) {
          console.error('Table non trouvée pour la sauvegarde');
          return;
        }

        if (isNewFourchette) {
          table.fourchettes.push(newFourchette);
        } else {
          // Mode modification - remplacer la fourchette existante
          if (fourchetteIndex >= 0 && fourchetteIndex < table.fourchettes.length) {
            table.fourchettes[fourchetteIndex] = newFourchette;
          } else {
            console.error('Index de fourchette invalide pour la modification:', fourchetteIndex);
            return;
          }
        }

        // Sauvegarder et regénérer la page
        this.saveToStorage();
        this.refreshTablesTresorsPage();
        this.closeAllModals();

      } catch (error) {
        console.error('Erreur lors de la sauvegarde:', error);
        alert('Erreur lors de la sauvegarde de la fourchette');
      }
    }

    deleteFourchette(tableName, fourchetteIndex) {
      if (!confirm('Êtes-vous sûr de vouloir supprimer cette fourchette ?')) {
        return;
      }

      try {
        const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === tableName);
        if (!table) {
          console.error('Table non trouvée:', tableName);
          return;
        }

        if (fourchetteIndex < 0 || fourchetteIndex >= table.fourchettes.length) {
          console.error('Index de fourchette invalide:', fourchetteIndex);
          return;
        }

        table.fourchettes.splice(fourchetteIndex, 1);
        
        this.saveToStorage();
        this.refreshTablesTresorsPage();
        
        // Fourchette supprimée avec succès

      } catch (error) {
        console.error('Erreur lors de la suppression:', error);
        alert('Erreur lors de la suppression de la fourchette');
      }
    }

    goToObject(numeroObjet) {
      this.closeAllModals();
      // Naviguer vers la page objets avec focus sur l'objet spécifique
      JdrApp.modules.router.navigate('objets');
      
      // Optionnel: highlight l'objet après navigation
      setTimeout(() => {
        const objectCard = document.querySelector(`[data-objet-name*="${numeroObjet}"]`);
        if (objectCard) {
          objectCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
          objectCard.style.border = '3px solid var(--accent)';
          setTimeout(() => {
            objectCard.style.border = '';
          }, 2000);
        }
      }, 500);
    }

    goToTablesTresorsPage() {
      this.closeAllModals();
      // Naviguer vers la page tables de trésors
      if (JdrApp.modules.router && JdrApp.modules.router.navigate) {
        JdrApp.modules.router.navigate('tables-tresors');
      } else {
        // Fallback direct navigation
        window.location.hash = '#/tables-tresors';
      }
    }

    closeAllModals() {
      const modals = document.querySelectorAll('.modal-overlay');
      modals.forEach(modal => modal.remove());
      this.currentPreviewModal = null;
      this.currentEditModal = null;
    }

    saveToStorage() {
      // Les modifications sont déjà dans window.TABLES_TRESORS et seront incluses dans les exports
      // Émettre l'événement de mise à jour pour notifier les autres modules
      if (window.EventBus && window.Events) {
        EventBus.emit(Events.CONTENT_UPDATE, {
          type: 'tablesTresors',
          data: window.TABLES_TRESORS
        });
      }
    }

    refreshTablesTresorsPage() {
      // Regénérer la page des tables de trésors
      if (JdrApp.modules.router && JdrApp.modules.router.getCurrentRoute() === 'tables-tresors') {
        // Force complete page regeneration via router navigation
        JdrApp.modules.router.navigate('tables-tresors');
      }
    }

    // Generate HTML link with table preview
    generateTreasureTableHtmlLink(tableName) {
      try {
        const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === tableName);
        if (!table) {
          console.error('Table non trouvée:', tableName);
          return '';
        }

        // Generate table preview HTML
        const tableHtml = this.generateTablePreviewHtml(table);
        
        // Create a compact link with preview tooltip
        const htmlLink = `<span class="treasure-table-link" data-table-name="${tableName}" style="color: var(--accent); cursor: pointer; text-decoration: underline;" title="Cliquer pour voir la table des trésors">[Table: ${tableName}]</span>`;
        
        return htmlLink;

      } catch (error) {
        console.error('Erreur lors de la génération du lien HTML:', error);
        return `[Erreur: ${tableName}]`;
      }
    }

    generateTablePreviewHtml(table) {
      const fourchettesList = table.fourchettes.map(fourchette => {
        const range = (fourchette.min || 1) === (fourchette.max || 1) 
          ? `${fourchette.min || 1}` 
          : `${fourchette.min || 1}-${fourchette.max || 1}`;
        
        return `
          <tr>
            <td style="text-align: center; font-weight: bold; color: var(--accent);">${range}</td>
            <td>
              <span class="object-preview-link" data-object-numero="${fourchette.objet.numero}" style="color: var(--accent); cursor: pointer; text-decoration: underline;" title="Cliquer pour voir la preview de l'objet">
                ${fourchette.objet.nom} (N°${fourchette.objet.numero})
              </span>
            </td>
          </tr>
        `;
      }).join('');

      return `
        <div class="treasure-table-preview" style="background: var(--paper); border: 2px solid var(--bronze); border-radius: 12px; padding: 1rem; max-width: 500px;">
          <h3 style="margin: 0 0 1rem 0; color: var(--accent); text-align: center;">🎲 ${table.nom}</h3>
          
          <table style="width: 100%; border-collapse: collapse; margin-top: 1rem;">
            <thead>
              <tr style="background: var(--bronze); color: white;">
                <th style="padding: 8px; text-align: center; border: 1px solid var(--rule);">Dé (d20)</th>
                <th style="padding: 8px; text-align: left; border: 1px solid var(--rule);">Objet obtenu</th>
              </tr>
            </thead>
            <tbody>
              ${fourchettesList}
            </tbody>
          </table>
        </div>
      `;
    }

    // Copy HTML link to clipboard
    copyTreasureTableHtmlLink(tableName) {
      try {
        const htmlLink = this.generateTreasureTableHtmlLink(tableName);
        
        // Copy to clipboard using modern API
        navigator.clipboard.writeText(htmlLink).then(() => {
          this.showNotification('✓ Lien HTML copié dans le presse-papiers!', 'success');
        }).catch(err => {
          // Fallback for older browsers
          const textArea = document.createElement('textarea');
          textArea.value = htmlLink;
          document.body.appendChild(textArea);
          textArea.select();
          document.execCommand('copy');
          document.body.removeChild(textArea);
          
          this.showNotification('✓ Lien HTML copié dans le presse-papiers!', 'success');
        });

      } catch (error) {
        console.error('Erreur lors de la copie:', error);
        this.showNotification('❌ Erreur lors de la copie du lien', 'error');
      }
    }

    // Show notification
    showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#2196F3'};
        color: white;
        padding: 12px 20px;
        border-radius: 8px;
        z-index: 1001;
        font-size: 14px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        animation: slideInRight 0.3s ease;
      `;
      notification.textContent = message;
      
      document.body.appendChild(notification);
      
      // Auto remove after 3 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.style.animation = 'slideOutRight 0.3s ease';
          setTimeout(() => notification.remove(), 300);
        }
      }, 3000);
    }
  }

  // Exposer globalement pour les event handlers inline
  window.TablesTresorsManager = TablesTresorsManager.getInstance();

  // Auto-initialiser quand le DOM est prêt
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => window.TablesTresorsManager.init());
  } else {
    window.TablesTresorsManager.init();
  }

})();
// ============================================================================
// JDR-BAB APPLICATION - FAVORIS MANAGER
// ============================================================================

(() => {
  "use strict";

  /**
   * Gestionnaire des favoris pour sorts et objets
   * Permet d'ajouter/supprimer des éléments en favoris avec persistance locale
   */
  class FavorisManager {
    constructor() {
      this.favoris = this.loadFavoris();
      this.initializeEventListeners();
    }

    /**
     * Charge les favoris depuis le stockage local
     */
    loadFavoris() {
      try {
        const saved = localStorage.getItem(window.STORAGE_KEYS.FAVORIS);
        return saved ? JSON.parse(saved) : {
          sorts: [],
          objets: []
        };
      } catch (error) {
        console.warn('Erreur lors du chargement des favoris:', error);
        return {
          sorts: [],
          objets: []
        };
      }
    }

    /**
     * Sauvegarde les favoris dans le stockage local
     */
    saveFavoris() {
      try {
        localStorage.setItem(window.STORAGE_KEYS.FAVORIS, JSON.stringify(this.favoris));
        EventBus.emit(window.Events.FAVORIS_UPDATE, { favoris: this.favoris });
      } catch (error) {
        console.error('Erreur lors de la sauvegarde des favoris:', error);
      }
    }

    /**
     * Vérifie si un élément est en favoris
     * @param {string} type - 'sorts' ou 'objets'
     * @param {string} nom - Nom de l'élément
     * @returns {boolean}
     */
    isFavoris(type, nom) {
      return this.favoris[type] && this.favoris[type].includes(nom);
    }

    /**
     * Ajoute un élément aux favoris
     * @param {string} type - 'sorts' ou 'objets'
     * @param {string} nom - Nom de l'élément
     */
    addFavoris(type, nom) {
      if (!this.favoris[type]) {
        this.favoris[type] = [];
      }
      
      if (!this.favoris[type].includes(nom)) {
        this.favoris[type].push(nom);
        this.saveFavoris();
        
        EventBus.emit(window.Events.FAVORIS_ADD, { 
          type, 
          nom, 
          count: this.favoris[type].length 
        });
        
        this.showFeedback(`✨ ${nom} ajouté aux favoris`, 'success');
        return true;
      }
      return false;
    }

    /**
     * Supprime un élément des favoris
     * @param {string} type - 'sorts' ou 'objets'
     * @param {string} nom - Nom de l'élément
     */
    removeFavoris(type, nom) {
      if (this.favoris[type]) {
        const index = this.favoris[type].indexOf(nom);
        if (index > -1) {
          this.favoris[type].splice(index, 1);
          this.saveFavoris();
          
          EventBus.emit(window.Events.FAVORIS_REMOVE, { 
            type, 
            nom,
            count: this.favoris[type].length 
          });
          
          this.showFeedback(`🗑️ ${nom} retiré des favoris`, 'info');
          return true;
        }
      }
      return false;
    }

    /**
     * Bascule l'état favori d'un élément
     * @param {string} type - 'sorts' ou 'objets'
     * @param {string} nom - Nom de l'élément
     */
    toggleFavoris(type, nom) {
      if (this.isFavoris(type, nom)) {
        return this.removeFavoris(type, nom);
      } else {
        return this.addFavoris(type, nom);
      }
    }

    /**
     * Récupère tous les favoris d'un type
     * @param {string} type - 'sorts' ou 'objets'
     * @returns {Array}
     */
    getFavoris(type) {
      return this.favoris[type] || [];
    }

    /**
     * Récupère tous les favoris
     * @returns {Object}
     */
    getAllFavoris() {
      return { ...this.favoris };
    }

    /**
     * Compte le nombre de favoris d'un type
     * @param {string} type - 'sorts' ou 'objets'
     * @returns {number}
     */
    countFavoris(type) {
      return this.favoris[type] ? this.favoris[type].length : 0;
    }

    /**
     * Vide tous les favoris d'un type
     * @param {string} type - 'sorts' ou 'objets'
     */
    clearFavoris(type) {
      if (this.favoris[type]) {
        const count = this.favoris[type].length;
        this.favoris[type] = [];
        this.saveFavoris();
        this.showFeedback(`🗑️ ${count} favoris ${type} supprimés`, 'info');
      }
    }

    /**
     * Initialise les écouteurs d'événements
     */
    initializeEventListeners() {
      // Écouter les clics sur les étoiles de favoris
      document.addEventListener('click', (event) => {
        const starBtn = event.target.closest('.favoris-star');
        if (starBtn) {
          event.preventDefault();
          event.stopPropagation();
          
          const type = starBtn.dataset.type;
          const nom = starBtn.dataset.nom;
          
          this.toggleFavoris(type, nom);
          this.updateStarDisplay(starBtn, type, nom);
        }
      });
    }

    /**
     * Met à jour l'affichage de l'étoile
     * @param {Element} starBtn - Bouton étoile
     * @param {string} type - Type de favori
     * @param {string} nom - Nom de l'élément
     */
    updateStarDisplay(starBtn, type, nom) {
      const isFav = this.isFavoris(type, nom);
      starBtn.innerHTML = isFav ? '⭐' : '☆';
      starBtn.classList.toggle('favoris-active', isFav);
      starBtn.title = isFav ? 'Retirer des favoris' : 'Ajouter aux favoris';
    }

    /**
     * Affiche un feedback utilisateur
     * @param {string} message - Message à afficher
     * @param {string} type - Type de feedback (success, info, warning, error)
     */
    showFeedback(message, type = 'info') {
      // Utilise le système de notification existant si disponible
      if (window.JdrApp && window.JdrApp.ui && window.JdrApp.ui.showNotification) {
        window.JdrApp.ui.showNotification(message, type);
      } else {
        // Fallback simple
        
        // Créer une notification temporaire
        const notification = document.createElement('div');
        notification.className = `favoris-notification favoris-${type}`;
        notification.textContent = message;
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: var(--surface-color, #f0f0f0);
          color: var(--text-color, #333);
          padding: 12px 16px;
          border-radius: 8px;
          border-left: 4px solid var(--accent-color, #d4af37);
          box-shadow: 0 4px 8px rgba(0,0,0,0.1);
          z-index: 10000;
          font-size: 14px;
          max-width: 300px;
          animation: slideInRight 0.3s ease-out;
        `;
        
        document.body.appendChild(notification);
        
        setTimeout(() => {
          notification.style.animation = 'slideOutRight 0.3s ease-in';
          setTimeout(() => {
            if (notification.parentNode) {
              notification.parentNode.removeChild(notification);
            }
          }, 300);
        }, 3000);
      }
    }

    /**
     * Crée un bouton étoile pour les favoris
     * @param {string} type - 'sorts' ou 'objets'
     * @param {string} nom - Nom de l'élément
     * @returns {string} HTML du bouton étoile
     */
    createStarButton(type, nom, data = null) {
      const isFav = this.isFavoris(type, nom);
      
      return `
        <button class="favoris-star ${isFav ? 'favoris-active' : ''}" 
                data-type="${type}" 
                data-nom="${nom}" 
                title="${isFav ? 'Retirer des favoris' : 'Ajouter aux favoris'}"
                aria-label="${isFav ? 'Retirer des favoris' : 'Ajouter aux favoris'}">
          ${isFav ? '⭐' : '☆'}
        </button>
      `;
    }
  }

  // ========================================
  // INITIALISATION GLOBALE
  // ========================================
  
  // Créer l'instance globale
  window.FavorisManager = new FavorisManager();
  
  // Exposer dans le namespace JdrApp si disponible
  if (window.JdrApp) {
    window.JdrApp.favoris = window.FavorisManager;
  }

})();
// ============================================================================
// JDR-BAB APPLICATION - FAVORIS RENDERER
// ============================================================================

(() => {
  "use strict";

  /**
   * Gestionnaire de rendu pour la page des favoris
   * Met à jour l'affichage des favoris en temps réel
   */
  class FavorisRenderer {
    constructor() {
      this.isInitialized = false;
      this.initializeEventListeners();
    }

    /**
     * Initialise les écouteurs d'événements
     */
    initializeEventListeners() {
      // Écouter les changements de favoris
      EventBus.on(window.Events.FAVORIS_UPDATE, (data) => {
        this.updateFavorisDisplay();
      });

      EventBus.on(window.Events.FAVORIS_ADD, (data) => {
        this.updateFavorisDisplay();
      });

      EventBus.on(window.Events.FAVORIS_REMOVE, (data) => {
        this.updateFavorisDisplay();
      });

      // Écouter les changements de page pour mettre à jour au besoin
      EventBus.on('router:page-changed', (data) => {
        if (data.page === 'favoris') {
          setTimeout(() => this.updateFavorisDisplay(), 100);
        }
      });
    }

    /**
     * Met à jour l'affichage complet des favoris
     */
    updateFavorisDisplay() {
      if (!window.FavorisManager) {
        console.warn('FavorisManager not available');
        return;
      }

      // Vérifier si nous sommes sur la page des favoris
      const favorisPage = document.querySelector('[data-page="favoris"]');
      if (!favorisPage || favorisPage.style.display === 'none') {
        return;
      }

      // Mettre à jour dans l'ordre : objets d'abord, puis sorts (même ordre que PageBuilder)
      this.updateObjetsDisplay();
      this.updateSortsDisplay();
    }

    /**
     * Met à jour l'affichage des sorts favoris
     */
    updateSortsDisplay() {
      const container = document.getElementById('favoris-sorts-container');
      const emptyState = document.getElementById('favoris-sorts-empty');
      const section = document.getElementById('favoris-sorts-section');
      
      if (!container || !emptyState) return;

      const favorisNames = window.FavorisManager.getFavoris('sorts');
      
      if (favorisNames.length === 0) {
        container.style.display = 'none';
        emptyState.style.display = 'block';
        return;
      }

      container.style.display = 'block';
      emptyState.style.display = 'none';

      // Récupérer les données des sorts favoris
      const favorisData = this.getSortsData(favorisNames);
      
      // Générer les cartes avec les images
      const cardsHtml = favorisData.map(sortData => {
        return CardBuilder.create('spell', sortData.sort, sortData.category).build();
      }).join('');

      container.innerHTML = cardsHtml;

      // Déclencher le chargement des images après insertion du contenu
      if (JdrApp.modules.renderer?.autoLoadImages) {
        setTimeout(() => JdrApp.modules.renderer.autoLoadImages(), 50);
      }

      // S'assurer que la section n'est pas pliée si elle a du contenu
      if (section && favorisNames.length > 0) {
        section.classList.remove('collapsed');
      }
    }

    /**
     * Met à jour l'affichage des objets favoris
     */
    updateObjetsDisplay() {
      const container = document.getElementById('favoris-objets-container');
      const emptyState = document.getElementById('favoris-objets-empty');
      const section = document.getElementById('favoris-objets-section');
      
      if (!container || !emptyState) return;

      const favorisNames = window.FavorisManager.getFavoris('objets');
      
      if (favorisNames.length === 0) {
        container.style.display = 'none';
        emptyState.style.display = 'block';
        return;
      }

      container.style.display = 'block';
      emptyState.style.display = 'none';

      // Récupérer les données des objets favoris
      const favorisData = this.getObjetsData(favorisNames);
      
      // Générer les cartes avec les images
      const cardsHtml = favorisData.map(objetData => {
        return CardBuilder.create('objet', objetData, null).build();
      }).join('');

      container.innerHTML = cardsHtml;

      // Déclencher le chargement des images après insertion du contenu
      if (JdrApp.modules.renderer?.autoLoadImages) {
        setTimeout(() => JdrApp.modules.renderer.autoLoadImages(), 50);
      }

      // S'assurer que la section n'est pas pliée si elle a du contenu
      if (section && favorisNames.length > 0) {
        section.classList.remove('collapsed');
      }
    }

    /**
     * Récupère les données des sorts favoris
     * @param {Array} favorisNames - Noms des sorts favoris
     * @returns {Array} Données des sorts avec leurs catégories
     */
    getSortsData(favorisNames) {
      const sortsData = [];
      
      if (!window.SORTS) return sortsData;

      // Parcourir toutes les catégories de sorts
      window.SORTS.forEach(category => {
        if (category.sorts) {
          category.sorts.forEach(sort => {
            if (favorisNames.includes(sort.nom)) {
              sortsData.push({
                sort: sort,
                category: category.nom
              });
            }
          });
        }
      });

      return sortsData;
    }

    /**
     * Récupère les données des objets favoris
     * @param {Array} favorisNames - Noms des objets favoris
     * @returns {Array} Données des objets
     */
    getObjetsData(favorisNames) {
      const objetsData = [];
      
      if (!window.OBJETS || !window.OBJETS.objets) return objetsData;

      // Parcourir tous les objets
      window.OBJETS.objets.forEach(objet => {
        if (favorisNames.includes(objet.nom)) {
          objetsData.push(objet);
        }
      });

      return objetsData;
    }

    /**
     * Force la mise à jour de l'affichage
     */
    forceUpdate() {
      this.updateFavorisDisplay();
    }

    /**
     * Initialise le renderer quand la DOM est prête
     */
    initialize() {
      if (this.isInitialized) return;
      
      // Attendre que tout soit chargé
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          setTimeout(() => this.updateFavorisDisplay(), 500);
        });
      } else {
        setTimeout(() => this.updateFavorisDisplay(), 100);
      }

      this.isInitialized = true;
    }
  }

  // ========================================
  // INITIALISATION GLOBALE
  // ========================================
  
  // Créer l'instance globale
  window.FavorisRenderer = new FavorisRenderer();
  
  // Exposer dans le namespace JdrApp si disponible
  if (window.JdrApp) {
    window.JdrApp.favorisRenderer = window.FavorisRenderer;
  }

  // Initialiser automatiquement
  window.FavorisRenderer.initialize();

})();
// ============================================================================
// JDR-BAB APPLICATION - SCROLL OPTIMIZER
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // SCROLL PERFORMANCE OPTIMIZER MODULE
  // ========================================
  window.ScrollOptimizer = {
    _initialized: false,
    _observers: new Map(),
    _virtualizationEnabled: false,
    _visibleCards: new Set(),
    _scrollTimeout: null,
    _lastScrollTime: 0,

    init() {
      if (this._initialized) return;
      
      this.setupScrollOptimizations();
      this.initializeVirtualization();
      this.optimizeExistingContent();
      
      this._initialized = true;
    },

    // Configure scroll event optimizations
    setupScrollOptimizations() {
      // Debounced scroll handler for expensive operations
      const debouncedScrollHandler = this.debounce(() => {
        this.updateVisibleCards();
        this.triggerLazyLoading();
      }, 100);

      // Throttled scroll handler for smooth operations
      const throttledScrollHandler = this.throttle(() => {
        this.handleSmoothScrollEffects();
      }, 16); // ~60fps

      // Add passive scroll listeners
      window.addEventListener('scroll', throttledScrollHandler, { passive: true });
      window.addEventListener('scroll', debouncedScrollHandler, { passive: true });
      
      // Optimize resize events
      window.addEventListener('resize', this.debounce(() => {
        this.recalculateViewport();
        this.updateVisibleCards();
      }, 250), { passive: true });
    },

    // Initialize virtual scrolling for long lists
    initializeVirtualization() {
      // Enable for pages with many cards (>20)
      this.observePageChanges();
    },

    // Observe page changes to apply optimizations
    observePageChanges() {
      if (!('MutationObserver' in window)) return;

      const observer = new MutationObserver((mutations) => {
        mutations.forEach(mutation => {
          if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
            mutation.addedNodes.forEach(node => {
              if (node.nodeType === Node.ELEMENT_NODE) {
                this.optimizeNewContent(node);
              }
            });
          }
        });
      });

      observer.observe(document.getElementById('views') || document.body, {
        childList: true,
        subtree: true
      });

      this._observers.set('pageChanges', observer);
    },

    // Optimize newly added content
    optimizeNewContent(element) {
      // Only optimize content in active articles
      const activeArticle = element.closest('article.active') || element.querySelector('article.active');
      if (!activeArticle && !element.matches('article.active')) {
        return; // Skip optimization for inactive articles
      }
      
      // Skip optimization for collections pages and filtered content
      const targetElement = activeArticle || element;
      if (targetElement.id === 'collections-objets' || 
          targetElement.querySelector('#collection-results') ||
          targetElement.querySelector('.objects-tag-display')) {
        return; // Skip collections and filtered object pages
      }
      
      const cards = targetElement.querySelectorAll('.card:not([style*="display: none"]), .spell-card:not([style*="display: none"]), .item-card:not([style*="display: none"])');
      const subclassSections = targetElement.querySelectorAll('.editable-section[data-section-type="subclass"]');
      
      // Removed console.log for better performance
      
      // Special handling for class pages with subclass sections
      if (subclassSections.length > 5) {
        this.optimizeClassPage(targetElement, subclassSections);
      } else if (cards.length > 15) {
        this.enableVirtualization(targetElement, cards);
      } else {
        this.applyBasicOptimizations(cards);
      }
    },

    // Optimize class pages with many subclasses
    optimizeClassPage(container, subclassSections) {
      // Removed console.log for better performance
      
      // Use progressive loading for subclasses
      subclassSections.forEach((section, index) => {
        if (index > 3) { // Keep first 4 visible
          this.deferSubclassRendering(section, index);
        } else {
          this.optimizeSubclassSection(section);
        }
      });
      
      // Add scroll-triggered loading for deferred sections
      this.setupProgressiveLoading(container, subclassSections);
    },

    // Defer rendering of subclass sections
    deferSubclassRendering(section, index) {
      section.style.cssText = `
        content-visibility: auto;
        contain-intrinsic-size: 0 400px;
        contain: layout style paint;
        opacity: 0.8;
        transform: translateZ(0);
      `;
      
      // Add loading indicator for deferred sections
      section.setAttribute('data-loading-state', 'deferred');
      section.setAttribute('data-section-index', index);
    },

    // Optimize individual subclass sections
    optimizeSubclassSection(section) {
      // Optimize images within subclass
      const images = section.querySelectorAll('img');
      images.forEach(img => {
        this.optimizeImage(img);
      });
      
      // Optimize large text content
      const textElements = section.querySelectorAll('[data-edit-type="generic"]');
      textElements.forEach(element => {
        if (element.textContent.length > 500) {
          element.style.contain = 'layout style';
        }
      });
    },

    // Setup progressive loading for class pages
    setupProgressiveLoading(container, sections) {
      if (!('IntersectionObserver' in window)) return;

      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const section = entry.target;
            const loadingState = section.getAttribute('data-loading-state');
            
            if (loadingState === 'deferred') {
              this.fullyLoadSubclassSection(section);
              observer.unobserve(section);
            }
          }
        });
      }, {
        rootMargin: '100px 0px', // Start loading 100px before visible
        threshold: 0.1
      });

      // Observe deferred sections
      sections.forEach(section => {
        if (section.getAttribute('data-loading-state') === 'deferred') {
          observer.observe(section);
        }
      });

      this._observers.set('classPageLoader', observer);
    },

    // Fully load a deferred subclass section
    fullyLoadSubclassSection(section) {
      // Remove deferral styles
      section.style.cssText = `
        opacity: 1;
        transform: none;
        transition: opacity 0.3s ease;
      `;
      
      section.setAttribute('data-loading-state', 'loaded');
      
      // Optimize the newly loaded content
      this.optimizeSubclassSection(section);
      
      // Ensure images are loaded
      if (JdrApp.modules.images) {
        JdrApp.modules.images.autoLoadImages();
      }
    },

    // Optimize individual images
    optimizeImage(img) {
      if (!img.hasAttribute('loading')) {
        img.setAttribute('loading', 'lazy');
      }
      
      if (!img.hasAttribute('decoding')) {
        img.setAttribute('decoding', 'async');
      }
      
      // Add size hints for layout stability
      if (!img.style.aspectRatio && img.width && img.height) {
        img.style.aspectRatio = `${img.width} / ${img.height}`;
      }
    },

    // Enable virtual scrolling for large lists
    enableVirtualization(container, cards) {
      this._virtualizationEnabled = true;
      
      // Create viewport container
      const viewport = document.createElement('div');
      viewport.className = 'virtualized-viewport';
      viewport.style.cssText = `
        height: 70vh;
        overflow-y: auto;
        position: relative;
      `;

      // Create content container
      const content = document.createElement('div');
      content.className = 'virtualized-content';
      content.style.position = 'relative';

      // Calculate total height and item height
      const itemHeight = this.calculateItemHeight(cards[0]);
      const totalHeight = cards.length * itemHeight;
      content.style.height = `${totalHeight}px`;

      // Set up virtual scrolling
      this.setupVirtualScroll(viewport, content, Array.from(cards), itemHeight);

      // Replace original content
      const parent = container.parentNode;
      parent.insertBefore(viewport, container);
      viewport.appendChild(content);
      container.style.display = 'none';
    },

    // Setup virtual scrolling mechanics
    setupVirtualScroll(viewport, content, items, itemHeight) {
      const visibleCount = Math.ceil(viewport.clientHeight / itemHeight) + 2; // Buffer
      let startIndex = 0;

      const updateVisibleItems = () => {
        const scrollTop = viewport.scrollTop;
        const newStartIndex = Math.floor(scrollTop / itemHeight);
        
        if (newStartIndex === startIndex) return;
        
        startIndex = Math.max(0, newStartIndex);
        const endIndex = Math.min(items.length, startIndex + visibleCount);

        // Clear existing content
        content.innerHTML = '';

        // Render visible items
        for (let i = startIndex; i < endIndex; i++) {
          const item = items[i].cloneNode(true);
          item.style.cssText = `
            position: absolute;
            top: ${i * itemHeight}px;
            width: 100%;
            box-sizing: border-box;
          `;
          content.appendChild(item);
        }

        // Re-initialize lazy loading for new items
        if (JdrApp.modules.images) {
          JdrApp.modules.images.autoLoadImages();
        }
      };

      // Throttled scroll handler for virtual scrolling
      const throttledUpdate = this.throttle(updateVisibleItems, 16);
      viewport.addEventListener('scroll', throttledUpdate, { passive: true });
      
      // Initial render
      updateVisibleItems();
    },

    // Apply basic optimizations to smaller lists
    applyBasicOptimizations(cards) {
      cards.forEach((card, index) => {
        // Special handling for spell cards (more complex)
        if (card.classList.contains('spell-card')) {
          this.optimizeSpellCard(card, index);
        } else {
          // Defer non-critical rendering for other card types
          if (index > 10) {
            this.deferCardRendering(card);
          }
        }
        
        // Optimize images in all cards
        this.optimizeCardImages(card);
      });
    },

    // Optimize spell cards specifically (they're more complex)
    optimizeSpellCard(card, index) {
      // Spell cards are complex, so use more aggressive optimization
      if (index > 6) { // Show only first 7 spell cards immediately
        this.deferSpellCardRendering(card);
      } else {
        this.optimizeVisibleSpellCard(card);
      }
    },

    // Defer rendering for spell cards with intersection observer
    deferSpellCardRendering(card) {
      card.style.cssText = `
        content-visibility: auto;
        contain-intrinsic-size: 0 450px; /* Taller for spell cards */
        contain: layout style;
        opacity: 0.7;
        transform: translateZ(0);
      `;
      
      card.setAttribute('data-loading-state', 'deferred-spell');
      
      // Set up intersection observer for this specific card
      this.observeSpellCard(card);
    },

    // Optimize visible spell cards
    optimizeVisibleSpellCard(card) {
      // Optimize complex HTML structure in spell cards
      const editableFields = card.querySelectorAll('[data-edit-type="generic"]');
      editableFields.forEach(field => {
        if (field.innerHTML.length > 200) {
          field.style.contain = 'layout style';
        }
      });
      
      // Optimize hr elements (lots of them in spell cards)
      const hrs = card.querySelectorAll('hr');
      hrs.forEach(hr => {
        hr.style.contain = 'layout paint';
      });
    },

    // Observe spell cards for lazy loading
    observeSpellCard(card) {
      if (!('IntersectionObserver' in window)) {
        // Fallback: load immediately on older browsers
        this.loadSpellCard(card);
        return;
      }

      if (!this._spellCardObserver) {
        this._spellCardObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              this.loadSpellCard(entry.target);
              this._spellCardObserver.unobserve(entry.target);
            }
          });
        }, {
          rootMargin: '50px 0px',
          threshold: 0.1
        });
        
        this._observers.set('spellCards', this._spellCardObserver);
      }

      this._spellCardObserver.observe(card);
    },

    // Load a deferred spell card
    loadSpellCard(card) {
      card.style.cssText = `
        opacity: 1;
        transform: none;
        transition: opacity 0.2s ease;
      `;
      
      card.setAttribute('data-loading-state', 'loaded');
      this.optimizeVisibleSpellCard(card);
    },

    // Defer rendering of cards outside initial viewport
    deferCardRendering(card) {
      card.style.cssText = `
        content-visibility: auto;
        contain-intrinsic-size: 0 300px;
      `;
    },

    // Optimize images within cards
    optimizeCardImages(card) {
      const images = card.querySelectorAll('img');
      images.forEach(img => {
        if (!img.hasAttribute('loading')) {
          img.setAttribute('loading', 'lazy');
        }
        
        // Add decode hint for better performance
        if (!img.hasAttribute('decoding')) {
          img.setAttribute('decoding', 'async');
        }
      });
    },

    // Update visible cards tracking
    updateVisibleCards() {
      const cards = document.querySelectorAll('.card, .spell-card, .item-card');
      const viewport = {
        top: window.scrollY,
        bottom: window.scrollY + window.innerHeight
      };

      this._visibleCards.clear();

      cards.forEach((card, index) => {
        const rect = card.getBoundingClientRect();
        const absoluteTop = rect.top + window.scrollY;
        const absoluteBottom = absoluteTop + rect.height;

        if (absoluteBottom > viewport.top - 100 && absoluteTop < viewport.bottom + 100) {
          this._visibleCards.add(index);
          
          // Prioritize visible cards for interactions
          card.style.transform = 'translateZ(0)'; // Force GPU layer
        } else {
          // Deprioritize invisible cards
          card.style.transform = '';
        }
      });
    },

    // Handle smooth scroll effects
    handleSmoothScrollEffects() {
      this._lastScrollTime = Date.now();
      
      // Disable heavy animations during scroll
      document.body.classList.add('scrolling');
      
      clearTimeout(this._scrollTimeout);
      this._scrollTimeout = setTimeout(() => {
        document.body.classList.remove('scrolling');
      }, 150);
    },

    // Trigger lazy loading for visible area
    triggerLazyLoading() {
      if (JdrApp.modules.images && JdrApp.modules.images.autoLoadImages) {
        JdrApp.modules.images.autoLoadImages();
      }
    },

    // Recalculate viewport dimensions
    recalculateViewport() {
      // Update any cached viewport dimensions
      this._viewportHeight = window.innerHeight;
      this._viewportWidth = window.innerWidth;
    },

    // Calculate item height for virtualization
    calculateItemHeight(sampleItem) {
      if (!sampleItem) return 200; // Default height
      
      const rect = sampleItem.getBoundingClientRect();
      return rect.height || 200;
    },

    // Optimize existing content on page
    optimizeExistingContent() {
      const existingCards = document.querySelectorAll('.card, .spell-card, .item-card');
      
      if (existingCards.length > 0) {
        this.optimizeNewContent(document.getElementById('views') || document.body);
      }
    },

    // Utility: Debounce function
    debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    },

    // Utility: Throttle function
    throttle(func, limit) {
      let inThrottle;
      return function() {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
          func.apply(context, args);
          inThrottle = true;
          setTimeout(() => inThrottle = false, limit);
        }
      }
    },

    // Clean up optimizations
    cleanup() {
      this._observers.forEach(observer => observer.disconnect());
      this._observers.clear();
      
      clearTimeout(this._scrollTimeout);
      
      this._initialized = false;
    }
  };

})();
// ============================================================================
// DYNAMIC CENTERING SYSTEM
// ============================================================================

(() => {
  "use strict";

  class DynamicCentering {
    constructor() {
      this.sidebarWidth = 350; // Width of the sidebar
      this.isEnabled = false;
      this.observer = null;
      this.rafId = null;
    }

    init() {
      this.isEnabled = true;
      this.setupResizeObserver();
      this.setupWindowResize();
      // Initial calculation
      this.updateCentering();
    }

    setupResizeObserver() {
      if (!window.ResizeObserver) return;

      // Observe changes to the main content container
      const viewsContainer = document.getElementById('views');
      if (!viewsContainer) return;

      this.observer = new ResizeObserver(() => {
        if (this.rafId) {
          cancelAnimationFrame(this.rafId);
        }
        this.rafId = requestAnimationFrame(() => this.updateCentering());
      });

      this.observer.observe(viewsContainer);
    }

    setupWindowResize() {
      let resizeTimer;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => this.updateCentering(), 100);
      });
    }

    updateCentering() {
      if (!this.isEnabled) return;

      const viewsContainer = document.getElementById('views');
      if (!viewsContainer) return;

      const viewportWidth = window.innerWidth;

      // Use CSS media queries for robust device detection (same as CSS breakpoints)
      const isMobileBreakpoint = window.matchMedia('(max-width: 980px)').matches;
      const isTabletBreakpoint = window.matchMedia('(max-width: 1024px)').matches;
      const isCoarsePointer = window.matchMedia('(pointer: coarse)').matches;
      const isTouchOnly = window.matchMedia('(hover: none)').matches;
      
      // Check if sidebar is actually visible/active
      const sidebar = document.querySelector('.sidebar');
      const isSidebarVisible = sidebar && !sidebar.classList.contains('mobile-open') && 
                              window.getComputedStyle(sidebar).position === 'fixed' &&
                              viewportWidth > 1024; // Sidebar only shows above 1024px (desktop only)
      
      // Disable dynamic centering if:
      // 1. CSS mobile breakpoint is active (matches our responsive CSS) OR
      // 2. CSS tablet breakpoint is active (force full width on tablet) OR
      // 3. Device has coarse pointer (touch-first device) OR  
      // 4. Device can't hover (mobile/touch-only) OR
      // 5. Sidebar is not visible
      if (isMobileBreakpoint || isTabletBreakpoint || isCoarsePointer || isTouchOnly || !isSidebarVisible) {
        // Reset to CSS responsive behavior - force full width on tablet/mobile
        viewsContainer.style.marginLeft = '';
        viewsContainer.style.marginRight = '';
        return;
      }

      // Get actual container dimensions
      const containerRect = viewsContainer.getBoundingClientRect();
      const actualContentWidth = containerRect.width;

      // Calculate available space after sidebar
      const availableSpace = viewportWidth - this.sidebarWidth;
      
      // Calculate optimal margin to center content in available space
      const optimalMarginLeft = this.sidebarWidth + (availableSpace - actualContentWidth) / 2;

      // Apply the centering with bounds checking
      const minMarginLeft = this.sidebarWidth + 20; // Minimum clearance
      const maxMarginLeft = viewportWidth - actualContentWidth - 20; // Don't overflow right
      
      const finalMarginLeft = Math.max(minMarginLeft, Math.min(optimalMarginLeft, maxMarginLeft));

      // Apply the calculated margin
      viewsContainer.style.marginLeft = `${finalMarginLeft}px`;
      viewsContainer.style.marginRight = '20px';

      // Debug info (remove in production)
      if (window.location.hash.includes('debug-centering')) {
        console.log('🎯 Dynamic Centering:', {
          viewportWidth,
          availableSpace,
          actualContentWidth,
          optimalMarginLeft,
          finalMarginLeft
        });
      }
    }

    disable() {
      this.isEnabled = false;
      if (this.observer) {
        this.observer.disconnect();
      }
      if (this.rafId) {
        cancelAnimationFrame(this.rafId);
      }
      
      // Reset to CSS default
      const viewsContainer = document.getElementById('views');
      if (viewsContainer) {
        viewsContainer.style.marginLeft = '';
        viewsContainer.style.marginRight = '';
      }
    }
  }

  // Initialize the dynamic centering system
  const dynamicCentering = new DynamicCentering();

  // Attach to JdrApp
  if (window.JdrApp) {
    JdrApp.modules.dynamicCentering = dynamicCentering;
  }

  // Auto-initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      // Delay initialization to ensure layout is stable
      setTimeout(() => dynamicCentering.init(), 500);
    });
  } else {
    setTimeout(() => dynamicCentering.init(), 500);
  }

  // Make it globally available for debugging
  window.DynamicCentering = dynamicCentering;

})();
// ============================================================================
// JDR-BAB APPLICATION - ROUTER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // ROUTING SYSTEM
  // ========================================
  JdrApp.modules.router = {
    currentRoute: '',
    
    init() {
      
      // Set up route change listeners
      JdrApp.utils.events.onHashChange(() => this.parseRoute());
      JdrApp.utils.events.onDOMReady(() => this.parseRoute());
      
      // Listen for dev mode changes to refresh objects page
      if (window.EventBus && window.Events) {
        EventBus.on(Events.EDITOR_TOGGLE, (payload) => {
          const currentHash = window.location.hash;
          // Refresh objects page specifically when dev mode changes
          if (currentHash === '#/objets') {
            setTimeout(() => {
              // Force a complete refresh by setting the flag
              this._forceObjectsRefresh = true;
              this.renderObjectsPage();
            }, 150);
          }
        });
      }
    },
    
    parseRoute() {
      const hash = location.hash.replace('#/', '');
      const page = hash || 'creation';
      const exists = JdrApp.utils.dom.$(`article[data-page="${page}"]`);
      
      this.currentRoute = page;
      
      // Handle dynamic category routing
      // Fix: check if exists is falsy OR empty NodeList
      const shouldUseRouter = !exists || (exists.length === 0);
      
      if (shouldUseRouter) {
        if (this.handleDynamicRoute(page)) {
          return; // Route was handled dynamically
        }
      }
      
      this.show(exists ? page : 'creation');
    },

    handleDynamicRoute(page) {
      // Handle sorts-* routes
      if (page.startsWith('sorts-')) {
        return this.renderDynamicCategory('sorts', 'spell', page);
      }
      
      // Handle dons-* routes  
      if (page.startsWith('dons-')) {
        return this.renderDynamicCategory('dons', 'don', page);
      }
      
      // Handle single objets page (objects now use unified page with tag filtering)
      if (page === 'objets') {
        return this.renderObjectsPage();
      }
      
      // Handle collections-objets page
      if (page === 'collections-objets') {
        return this.renderCollectionsObjectsPage();
      }
      
      // Handle single monstres page (monsters now use unified page with tag filtering)
      if (page === 'monstres') {
        return this.renderMonstersPage();
      }
      
      // Handle single tables-tresors page  
      if (page === 'tables-tresors') {
        return this.renderTablesTresorsPage();
      }
      
      // Handle feuille-personnage page
      if (page === 'feuille-personnage') {
        return this.renderFeuillePersonnagePage();
      }
      
      // Handle favoris page
      if (page === 'favoris') {
        return this.renderFavorisPage();
      }
      
      // Handle GM objects page
      if (page === 'gestion-objets') {
        return this.renderGMObjectsPage();
      }
      
      return false; // Route not handled
    },

    renderDynamicCategory(prefix, type, page) {
      const categoryId = page.replace(`${prefix}-`, '');
      const dataKey = prefix.toUpperCase();
      const dataSource = window[dataKey];
      
      if (!dataSource) return false;
      
      const category = dataSource.find(cat => 
        JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
      );
      
      if (category) {
        // Render the category page dynamically
        JdrApp.modules.renderer.renderCategoryPage(type, category);
        
        // Update active states
        this.updateActiveStates(page);
        
        return true;
      }
      
      return false;
    },

    updateActiveStates(page) {
      // Remove active class from all articles and hide them
      document.querySelectorAll('article').forEach(a => {
        a.classList.remove('active');
        a.style.display = 'none'; // Force hide all articles
      });
      
      // Remove active class from all TOC links
      document.querySelectorAll('.toc a').forEach(a => a.classList.remove('active'));
      
      // Show the current page article
      const currentArticle = document.querySelector(`article[data-page="${page}"]`);
      if (currentArticle) {
        currentArticle.classList.add('active');
        currentArticle.style.display = 'block'; // Force show current article
        
        // IMPORTANT: Reset the activeIdSearch state when navigating to Objects page
        if (page === 'objets') {
          window.activeIdSearch = false;
          
          // Clear any search results
          const resultDiv = document.getElementById('id-search-result');
          if (resultDiv) {
            resultDiv.textContent = '';
          }
          
          // Clear search input
          const searchInput = document.getElementById('id-search-input');
          if (searchInput) {
            searchInput.value = '';
          }
        }
      }
      
      // Set active link in TOC
      const activeLink = document.querySelector(`a[href="#/${page}"]`);
      if (activeLink) {
        activeLink.classList.add('active');
        
        // Expand parent category if needed
        const category = activeLink.closest('.toc-category');
        if (category) {
          category.classList.remove('collapsed');
        }
      }
    },
    
    show(page) {
      // Hide all articles and remove active class
      document.querySelectorAll('article').forEach(a => {
        a.classList.remove('active');
        a.style.display = 'none';
      });
      
      // Show and activate the target page
      const target = document.querySelector(`article[data-page="${page}"]`);
      if (target) {
        target.classList.add('active');
        target.style.display = 'block';
        
        // Reset ID search state when navigating to Objects page
        if (page === 'objets') {
          window.activeIdSearch = false;
          setTimeout(() => {
            const resultDiv = document.getElementById('id-search-result');
            if (resultDiv) {
              resultDiv.textContent = '';
            }
            const searchInput = document.getElementById('id-search-input');
            if (searchInput) {
              searchInput.value = '';
            }
          }, 100);
        }
      }
      
      // Update TOC active states
      document.querySelectorAll('.toc a').forEach(a => a.classList.remove('active'));
      const activeLink = document.querySelector(`a[href="#/${page}"]`);
      if (activeLink) activeLink.classList.add('active');

      
      // Ensure edit buttons state is properly applied after navigation
      if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
        setTimeout(() => {
          if (JdrApp.modules.editor.isDevMode) {
            JdrApp.modules.editor.forceShowAllEditButtons();
          } else {
            JdrApp.modules.editor.forceHideAllEditButtons();
          }
        }, 50);
      }
    },
    
    navigate(route) {
      location.hash = `#/${route}`;
      // Force parseRoute() in case hashchange event doesn't fire
      setTimeout(() => {
        this.parseRoute();
      }, 10);
    },
    
    getCurrentRoute() {
      return this.currentRoute;
    },
    
    // Generate table of contents based on hierarchical structure
    generateTOC() {
      const tocContainer = document.querySelector('#toc');
      if (!tocContainer) return;

      if (!window.TOC_STRUCTURE) {
        console.warn('TOC_STRUCTURE not loaded, falling back to basic TOC');
        this.generateBasicTOC();
        return;
      }

      const tocHTML = `
        <h4>Sommaire</h4>
        ${window.TOC_STRUCTURE.directPages ? 
          window.TOC_STRUCTURE.directPages.map(page => this.generateTOCItem(page)).join('') : 
          ''}
        ${window.TOC_STRUCTURE.sections
          .filter(section => !section.requiresMJ || window.JdrApp.state.isMJ)
          .map(section => this.generateTOCSection(section)).join('')}
        <div class="mj-toggle-container" style="margin: 1rem 0; text-align: center; border-top: 2px solid var(--rule); padding-top: 1rem;">
          <button id="mjToggleBtn" class="btn-base btn-small" style="background: var(--bronze); color: white; border-color: var(--bronze); position: relative;">
            🎭 Maître de jeu
            <span id="mjStatusIndicator" style="position: absolute; top: -5px; right: -5px; width: 12px; height: 12px; border-radius: 50%; background: #dc2626; border: 2px solid white; display: none;"></span>
          </button>
        </div>
      `;
      
      tocContainer.innerHTML = tocHTML;
      
      // Attacher les événements directement aux éléments après création
      this.attachFoldoutEvents();
      
      // Initialiser les hauteurs dynamiques pour toutes les sections ouvertes
      this.initializeDynamicHeights();
      
      // Ajouter l'event listener pour le bouton MJ
      this.setupMJToggle();
    },

    initializeDynamicHeights() {
      // Calculer et appliquer les hauteurs dynamiques pour toutes les sections non-collapsées
      document.querySelectorAll('.toc-section:not(.collapsed) .toc-section-content').forEach(content => {
        const childCount = content.querySelectorAll('a, .toc-category').length;
        const itemHeight = 50; // Hauteur approximative par élément
        const baseHeight = 100; // Hauteur de base pour le padding
        const dynamicHeight = Math.max(500, (childCount * itemHeight) + baseHeight);
        
        content.style.maxHeight = `${dynamicHeight}px`;
      });
    },

    setupMJToggle() {
      const mjBtn = document.getElementById('mjToggleBtn');
      if (!mjBtn) return;

      // Initialize visual state based on current MJ status
      this.updateMJButtonVisual();
      this.updateMJBodyClass();

      const handleMJToggle = () => {
        if (window.JdrApp.state.isMJ) {
          // Déjà en mode MJ, désactiver
          window.JdrApp.state.isMJ = false;
          this.updateMJButtonVisual();
          this.updateMJBodyClass();
          this.generateTOC(); // Régénérer le TOC pour cacher les sections MJ
          
          // Refresh objects display if currently on objects page
          this.refreshObjectsPageIfActive();
        } else {
          // Demander confirmation avant d'activer le mode MJ
          this.showMJConfirmation(() => {
            window.JdrApp.state.isMJ = true;
            this.updateMJButtonVisual();
            this.updateMJBodyClass();
            this.generateTOC(); // Régénérer le TOC pour afficher les sections MJ
            
            // Refresh objects display if currently on objects page
            this.refreshObjectsPageIfActive();
          });
        }
      };

      // Ajouter support tactile pour mobile
      mjBtn.addEventListener('click', handleMJToggle);
      mjBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleMJToggle();
      });
    },

    attachFoldoutEvents() {
      // Attacher les événements directement aux headers de section
      document.querySelectorAll('.toc-section-header').forEach(header => {
        header.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const section = header.closest('.toc-section');
          if (section) {
            const wasCollapsed = section.classList.contains('collapsed');
            section.classList.toggle('collapsed');
            const isCollapsed = section.classList.contains('collapsed');
            
            const toggle = section.querySelector('.toc-section-toggle');
            if (toggle) {
              toggle.textContent = isCollapsed ? '▶' : '▼';
            }
            
            const content = section.querySelector('.toc-section-content');
            if (content) {
              // Force les styles directement en JavaScript pour compatibilité standalone
              if (isCollapsed) {
                content.style.maxHeight = '0px';
                content.style.opacity = '0';
                content.style.paddingTop = '0';
                content.style.paddingBottom = '0';
                content.style.overflow = 'hidden';
              } else {
                // Calculer dynamiquement la hauteur nécessaire en fonction du contenu
                const childCount = content.querySelectorAll('a, .toc-category').length;
                const itemHeight = 50; // Hauteur approximative par élément (incluant padding et marge)
                const baseHeight = 100; // Hauteur de base pour le padding
                const dynamicHeight = Math.max(500, (childCount * itemHeight) + baseHeight);
                
                content.style.maxHeight = `${dynamicHeight}px`;
                content.style.opacity = '1';
                content.style.paddingTop = '';
                content.style.paddingBottom = '';
                content.style.overflow = 'visible';
              }
            }
          }
        });
      });

      // Attacher les événements aux liens de catégorie
      document.querySelectorAll('.toc-category > a').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const category = link.closest('.toc-category');
          if (category) {
            category.classList.toggle('collapsed');
          }
        });
      });

      // Attacher les événements aux liens de navigation normaux
      document.querySelectorAll('.toc a:not(.toc-category > a)').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const route = link.getAttribute('data-route');
          if (route) {
            // Special handling for objects page - force refresh when navigating to it
            if (route === 'objets') {
              // Set a flag to force refresh objects page after navigation
              JdrApp.modules.router._forceObjectsRefresh = true;
            }
            JdrApp.modules.router.navigate(route);
            
            // Auto-close sidebar on mobile/touch devices after navigation
            this.autoCloseMobileSidebar();
          }
        });
      });
    },

    /**
     * Auto-close sidebar on mobile/touch devices after navigation
     */
    autoCloseMobileSidebar() {
      // Check if device should show mobile toggle (touch device or mobile size)
      const isTouchDevice = 'ontouchstart' in window || 
                           navigator.maxTouchPoints > 0 || 
                           navigator.msMaxTouchPoints > 0 ||
                           window.matchMedia('(pointer: coarse)').matches;
      
      const isMobileSize = window.innerWidth <= window.UI_CONSTANTS?.BREAKPOINTS?.MOBILE;
      const shouldAutoClose = isTouchDevice || isMobileSize;
      
      if (shouldAutoClose) {
        const sidebar = document.querySelector('#sidebar');
        const menuToggle = document.querySelector('#menuToggle');
        const backdrop = document.querySelector('#backdrop');
        
        if (sidebar && sidebar.classList.contains('mobile-open')) {
          // Close mobile nav
          sidebar.classList.remove('mobile-open');
          if (menuToggle) menuToggle.setAttribute('aria-expanded', 'false');
          if (backdrop) backdrop.style.display = 'none';
          document.body.style.overflow = '';
        }
      }
    },

    updateMJButtonVisual() {
      const mjBtn = document.getElementById('mjToggleBtn');
      const mjIndicator = document.getElementById('mjStatusIndicator');
      
      if (!mjBtn) return;
      
      if (window.JdrApp.state.isMJ) {
        // Mode MJ activé - bouton doré avec indicateur vert
        mjBtn.style.background = 'var(--gold)';
        mjBtn.style.borderColor = 'var(--gold)';
        mjBtn.innerHTML = '🎭 Mode MJ activé <span id="mjStatusIndicator" style="position: absolute; top: -5px; right: -5px; width: 12px; height: 12px; border-radius: 50%; background: #16a34a; border: 2px solid white; display: inline-block;"></span>';
      } else {
        // Mode normal - bouton bronze sans indicateur
        mjBtn.style.background = 'var(--bronze)';
        mjBtn.style.borderColor = 'var(--bronze)';
        mjBtn.innerHTML = '🎭 Maître de jeu <span id="mjStatusIndicator" style="position: absolute; top: -5px; right: -5px; width: 12px; height: 12px; border-radius: 50%; background: #dc2626; border: 2px solid white; display: none;"></span>';
      }
    },

    updateMJBodyClass() {
      const body = document.body;
      if (window.JdrApp.state.isMJ) {
        body.classList.remove('mj-off');
        body.classList.add('mj-on');
      } else {
        body.classList.remove('mj-on');
        body.classList.add('mj-off');
      }
    },

    showMJConfirmation(onConfirm) {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0,0,0,0.7);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
      `;
      
      modal.innerHTML = `
        <div style="
          background: var(--card);
          border: 3px solid var(--bronze);
          border-radius: 16px;
          padding: 2rem;
          max-width: 500px;
          margin: 1rem;
          text-align: center;
          box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        ">
          <h3 style="color: var(--bronze); margin-top: 0;">⚠️ Mode Maître de jeu</h3>
          <p style="margin: 1.5rem 0; line-height: 1.6;">
            Êtes-vous sûr de vouloir activer le mode Maître de jeu?<br><br>
            <strong style="color: var(--bronze);">Si vous êtes juste un joueur, vous risquez d'être spoilé!</strong>
          </p>
          <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 2rem;">
            <button id="mjConfirmYes" class="btn-base" style="background: var(--bronze); color: white; border-color: var(--bronze);">
              Oui, je suis MJ
            </button>
            <button id="mjConfirmNo" class="btn-base" style="background: var(--rule); color: var(--accent-ink); border-color: var(--rule);">
              Non, annuler
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      modal.querySelector('#mjConfirmYes').addEventListener('click', () => {
        document.body.removeChild(modal);
        onConfirm();
      });
      
      modal.querySelector('#mjConfirmNo').addEventListener('click', () => {
        document.body.removeChild(modal);
      });
      
      // Fermer en cliquant sur le fond
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
        }
      });
    },

    generateTOCSection(section) {
      // Make all sections collapsed by default (ignoring section.collapsed from data)
      const sectionClass = 'toc-section collapsed';
      const toggleIcon = '▶';
      
      return `
        <div class="${sectionClass}" data-section="${section.id}">
          <div class="toc-section-header">
            <span class="toc-section-title">${section.title}</span>
            <span class="toc-section-toggle">${toggleIcon}</span>
          </div>
          <div class="toc-section-content">
            ${section.items.map(item => this.generateTOCItem(item)).join('')}
          </div>
        </div>
      `;
    },

    generateTOCItem(item) {
      if (item.type === 'page') {
        return `<a data-route="${item.id}" href="#/${item.id}" class="">${item.icon} ${item.title}</a>`;
      } else if (item.type === 'category') {
        return this.generateTOCCategory(item);
      }
      return '';
    },

    generateTOCCategory(item) {
      const dataSource = window[item.items]; // CLASSES, SORTS, DONS
      if (!dataSource) return '';

      if (item.id === 'classes') {
        return `
          <div class="toc-category collapsed">
            <a data-route="classes" href="#/classes" class="">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource.map(classe => 
                `<a data-route="${JdrApp.utils.data.sanitizeId(classe.nom)}" href="#/${JdrApp.utils.data.sanitizeId(classe.nom)}" class="">${this.getClassIcon(classe.nom)} ${classe.nom}</a>`
              ).join('')}
            </div>
          </div>
        `;
      } else if (item.id === 'sorts') {
        return `
          <div class="toc-category">
            <a data-route="sorts" href="#/sorts">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource.map(category => 
                `<a data-route="sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getSortCategoryIcon(category.nom)} ${category.nom}</a>`
              ).join('')}
            </div>
          </div>
        `;
      } else if (item.id === 'dons') {
        return `
          <div class="toc-category collapsed">
            <a data-route="dons" href="#/dons" class="">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource.map(category => 
                `<a data-route="dons-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/dons-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getDonCategoryIcon(category.nom)} ${category.nom}</a>`
              ).join('')}
            </div>
          </div>
        `;
      }

      return '';
    },

    generateBasicTOC() {
      const tocContainer = document.querySelector('#toc');
      if (!tocContainer) return;

      const tocHTML = `
        <h4>Sommaire</h4>
        <a class="" data-route="creation" href="#/creation">🧙‍♂️ Création d'un personnage</a>
        
        <div class="toc-category collapsed">
          <a data-route="classes" href="#/classes" class="">⚔️ Classes</a>
          <div class="toc-sub">
            ${window.CLASSES ? window.CLASSES.map(classe => 
              `<a data-route="${JdrApp.utils.data.sanitizeId(classe.nom)}" href="#/${JdrApp.utils.data.sanitizeId(classe.nom)}" class="">${this.getClassIcon(classe.nom)} ${classe.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <div class="toc-category collapsed">
          <a data-route="sorts" href="#/sorts">🔮 Sorts</a>
          <div class="toc-sub">
            ${window.SORTS ? window.SORTS.map(category => 
              `<a data-route="sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getSortCategoryIcon(category.nom)} ${category.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <div class="toc-category collapsed">
          <a data-route="dons" href="#/dons" class="">🎖️ Dons</a>
          <div class="toc-sub">
            ${window.DONS ? window.DONS.map(category => 
              `<a data-route="dons-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/dons-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getDonCategoryIcon(category.nom)} ${category.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <a data-route="objets" href="#/objets" class="">📦 Objets</a>
        
        <a data-route="elements" href="#/elements" class="">🌟 Éléments</a>
        <a data-route="stats" href="#/stats" class="">📊 Statistiques</a>
        <a data-route="competences-tests" href="#/competences-tests" class="">🎯 Compétences & Tests</a>
        <a data-route="etats" href="#/etats" class="">⚡ Etats</a>
      `;
      
      tocContainer.innerHTML = tocHTML;
    },
    
    renderObjectsPage() {
      if (!window.OBJETS) return false;
      
      // Ensure the page is shown as active first
      this.show('objets');
      
      // Force complete regeneration if coming from navigation or MJ mode change
      const shouldForceRefresh = this._forceObjectsRefresh || false;
      this._forceObjectsRefresh = false; // Reset the flag
      
      // Force complete regeneration of the objects page content
      // This ensures that objects filtered out by MJ restrictions are now properly generated in the DOM
      setTimeout(() => {
        if (JdrApp.modules.renderer && JdrApp.modules.renderer.regenerateCurrentPage) {
          JdrApp.modules.renderer.regenerateCurrentPage();
        }
      }, shouldForceRefresh ? 100 : 50); // Slightly longer delay when forced refresh
      
      return true;
    },


    // Helper method to refresh objects page if currently active
    refreshObjectsPageIfActive() {
      const currentHash = window.location.hash;
      if (currentHash === '#/objets' || currentHash === '#objets') {
        setTimeout(() => {
          // Force full page regeneration to ensure objects filtered by MJ mode are now visible
          // This calls renderObjectsPage() which will regenerate the entire page with current filters
          this.renderObjectsPage();
        }, 150); // Slightly longer delay to ensure MJ state is updated
      }
    },
    
    getClassIcon(className) {
      const icons = {
        'Guerrier': '🗡️',
        'Mage': '🔮',
        'Prêtre': '⛪',
        'Rôdeur': '🏃',
        'Enchanteur': '✨'
      };
      return icons[className] || '⚔️';
    },
    
    getSortCategoryIcon(categoryName) {
      const icons = {
        'Sorts de Mage': '🔮',
        'Sorts de Prêtre': '⛪',
        'Sorts d\'Enchanteur': '✨',
        'Sorts de Monstres': '💀'
      };
      return icons[categoryName] || '🔮';
    },
    
    getDonCategoryIcon(categoryName) {
      const icons = {
        'Guerrier': '🗡️',
        'Mage': '🔮',
        'Pretre': '⛪',  // Sans accent comme dans les données
        'Prêtre': '⛪',  // Avec accent au cas où
        'Rôdeur': '🏃',
        'Enchanteur': '✨',
        'Généraux': '🎖️',
        'Generaux': '🎖️'  // Sans accent comme dans les données
      };
      return icons[categoryName] || '🎖️';
    },

    getMonstreCategoryIcon(categoryName) {
      const icons = {
        'Forêt': '🌲',
        'Foret': '🌲',  // Sans accent
        'Donjon': '🏰',
        'Dragons': '🐉',
        'Mort-vivants': '💀',
        'Démons': '👹',
        'Demons': '👹',  // Sans accent
        'Animaux': '🦁',
        'Humanoïdes': '🧌',
        'Humanoïdes': '🧌'  // Sans accent
      };
      return icons[categoryName] || '👹';
    },
    
    getObjetCategoryIcon(categoryName) {
      const icons = {
        'Armes': '⚔️',
        'Armures': '🛡️',
        'Potions': '🧪',
        'Herbes Magiques': '🌿',
        'Objets Magiques': '✨',
        'Accessoires': '💍',
        'Consommables': '🍞',
        'Composants': '🔮',
        'Outils': '🔨'
      };
      return icons[categoryName] || '📦';
    },

    renderObjectsPage() {
      // Use PageBuilder to generate the objets page dynamically
      JdrApp.modules.renderer.renderUnifiedContentPage('objet', window.OBJETS || []);
      this.updateActiveStates('objets');
      this.show('objets'); // Activer la page
      return true;
    },

    renderGMObjectsPage() {
      if (!window.OBJETS) return false;
      
      // Generate the GM objects page using PageBuilder
      const pageHtml = PageBuilder.buildGameMasterObjectPage(window.OBJETS);
      
      // Find or create the views container
      const viewsContainer = document.querySelector('#views');
      if (!viewsContainer) {
        console.error('Views container not found');
        return false;
      }
      
      // Remove existing GM objects page if it exists
      const existingPage = document.querySelector('[data-page="gestion-objets"]');
      if (existingPage) {
        existingPage.remove();
      }
      
      // Insert the new page
      viewsContainer.insertAdjacentHTML('beforeend', pageHtml);
      
      // Setup search functionality for GM page
      setTimeout(() => {
        this.setupGMObjectSearch();
      }, 100);
      
      // Show and activate page
      this.show('gestion-objets');
      this.updateActiveStates('gestion-objets');
      
      return true;
    },

    setupGMObjectSearch() {
      // Setup ID search for the GM objects page
      const idSearchInput = document.getElementById('id-search-input');
      if (idSearchInput) {
        // Remove existing listeners
        const newInput = idSearchInput.cloneNode(true);
        idSearchInput.parentNode.replaceChild(newInput, idSearchInput);
        
        newInput.addEventListener('keyup', (e) => {
          if (e.key === 'Enter') {
            const searchId = e.target.value.trim();
            if (JdrApp.modules.renderer && JdrApp.modules.renderer.performIdSearch) {
              JdrApp.modules.renderer.performIdSearch(searchId);
            }
          }
        });
      }
      
      // Setup clear button
      const clearButton = document.getElementById('clear-id-search');
      if (clearButton) {
        const newClearButton = clearButton.cloneNode(true);
        clearButton.parentNode.replaceChild(newClearButton, clearButton);
        
        newClearButton.addEventListener('click', () => {
          if (JdrApp.modules.renderer && JdrApp.modules.renderer.clearIdSearch) {
            JdrApp.modules.renderer.clearIdSearch();
          }
        });
      }
    },

    renderMonstersPage() {
      // Use PageBuilder to generate the monstres page dynamically
      JdrApp.modules.renderer.renderUnifiedContentPage('monster', window.MONSTRES || []);
      this.updateActiveStates('monstres');
      this.show('monstres'); // Activer la page
      return true;
    },
    
    renderTablesTresorsPage() {
      // Use PageBuilder to generate the tables-tresors page dynamically
      JdrApp.modules.renderer.renderUnifiedContentPage('tableTresor', window.TABLES_TRESORS || { tables: [] });
      this.updateActiveStates('tables-tresors');
      this.show('tables-tresors'); // Activer la page
      return true;
    },

    renderCollectionsObjectsPage() {
      // Safety check - if collections data is not available, try to wait a bit
      if (!window.COLLECTIONS || !window.COLLECTIONS.collections || window.COLLECTIONS.collections.length === 0) {
        setTimeout(() => this.renderCollectionsObjectsPage(), 100);
        return false;
      }
      
      // Create or find the page element
      let pageElement = document.getElementById('collections-objets');
      
      // If the page doesn't exist, create it
      if (!pageElement) {
        pageElement = document.createElement('article');
        pageElement.id = 'collections-objets';
        pageElement.setAttribute('data-page', 'collections-objets');
        pageElement.className = 'page';
        
        // Insert it into the views container
        const viewsContainer = document.querySelector('#views');
        
        if (viewsContainer) {
          viewsContainer.appendChild(pageElement);
        } else {
          console.error('Views container not found');
          return false;
        }
      }
      
      // Create the collections page content
      const collectionsContent = `
        <div class="page-header">
          <h1>📚 Collections d'Objets</h1>
          <div class="editable-section" data-section-type="pageDescription">
            <p class="editable" data-edit-type="generic" data-edit-section="description" data-item-identifier="collections-objets" data-page-type="collections">${this.getCollectionsDescription()}</p>
            <button class="edit-btn" data-edit-type="collections-description" style="display: none;">✏️ Modifier</button>
          </div>
        </div>
        
        <div class="collections-search">
          <div class="search-container">
            <input 
              type="text" 
              id="collection-search-input" 
              placeholder="Tapez le nom d'une collection..." 
              class="search-input"
              value="Départ"
            />
            <button id="collection-search-btn" class="search-button">🔍 Rechercher</button>
          </div>
        </div>
        
        <div id="collection-results" class="collection-results" style="display: none;">
          <div id="collection-header" class="collection-header"></div>
          <div id="tag-filters" class="tag-filters"></div>
          <div id="collection-items" class="collection-items"></div>
        </div>
        
        <div id="available-collections" class="available-collections" style="display: none;">
          <h2>Collections disponibles</h2>
          <div class="collections-grid">
            <!-- Collections will be generated dynamically -->
          </div>
        </div>
      `;
      
      // Insert content into the page
      pageElement.innerHTML = collectionsContent;
      this.setupCollectionsEventListeners();
      
      // Show collections grid in dev mode, auto-fill search in normal mode
      const availableCollections = document.getElementById('available-collections');
      const searchInput = document.getElementById('collection-search-input');
      const isDevMode = this.isDevModeActive();
      
      
      // Generate collections dynamically
      this.generateCollectionsGrid();
      
      if (availableCollections) {
        if (isDevMode) {
          availableCollections.style.display = 'block';
          // In dev mode, show all collections without needing search
          // But keep the search functional for filtering
        } else {
          availableCollections.style.display = 'none';
          // In normal mode, collections are hidden - user must search manually
        }
      } else {
        console.error('❌ available-collections element not found');
      }
      
      // Setup dev mode change listener
      this.setupDevModeListener();
      
      // Show and activate page after content is inserted
      this.show('collections-objets');
      this.updateActiveStates('collections-objets');
      
      // Ensure the page is visible regardless of dev mode
      if (pageElement) {
        pageElement.classList.add('active');
      }
      
      return true;
    },

    setupCollectionsEventListeners() {
      // console.log('Setting up collections event listeners...');
      const searchInput = document.getElementById('collection-search-input');
      const searchBtn = document.getElementById('collection-search-btn');
      const collectionCards = document.querySelectorAll('.collection-card');
      
      // console.log('Found elements:', {
      //   searchInput: !!searchInput,
      //   searchBtn: !!searchBtn,
      //   collectionCards: collectionCards.length
      // });
      
      // Search functionality
      const performSearch = () => {
        const searchTerm = searchInput.value.trim();
        if (searchTerm) {
          this.displayCollection(searchTerm);
        }
      };
      
      searchBtn.addEventListener('click', performSearch);
      searchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          performSearch();
        }
      });
      
      // Collection card clicks
      collectionCards.forEach(card => {
        card.addEventListener('click', () => {
          const collection = card.getAttribute('data-collection');
          searchInput.value = collection;
          this.displayCollection(collection);
        });
      });
    },

    displayCollection(collectionName) {
      if (!window.OBJETS || !window.OBJETS.objets || !window.COLLECTIONS || !window.COLLECTIONS.collections) return;
      
      // Find the collection by name or ID
      const collection = window.COLLECTIONS.collections.find(coll => 
        coll.id === collectionName || 
        coll.nom.toLowerCase() === collectionName.toLowerCase()
      );
      
      if (!collection) {
        this.showCollectionNotFound(collectionName);
        return;
      }
      
      // Filter objects by collection (using object numbers/IDs defined in collection)
      const filteredObjects = window.OBJETS.objets.filter(obj => {
        return collection.objets && collection.objets.includes(obj.numero);
      });
      
      const resultsContainer = document.getElementById('collection-results');
      const headerContainer = document.getElementById('collection-header');
      const itemsContainer = document.getElementById('collection-items');
      const tagFiltersContainer = document.getElementById('tag-filters');
      const availableCollections = document.getElementById('available-collections');
      
      // Hide available collections and show results
      if (availableCollections) {
        availableCollections.style.display = 'none';
      }
      if (resultsContainer) {
        resultsContainer.style.display = 'block';
      }
      
      const isDevMode = JdrApp.utils.isDevMode();
      
      // Update header with collection info
      if (headerContainer) {
        headerContainer.innerHTML = `
          ${isDevMode ? `
            <div class="collection-navigation" style="margin-bottom: 1rem;">
              <button class="btn small back-to-collections-btn" style="background: #6B7280;">← Retour aux collections</button>
            </div>
          ` : ''}
          <h2>${collection.icon} ${collection.nom}</h2>
          <p class="collection-description">${collection.description}</p>
          <p>${filteredObjects.length} objet(s) dans cette collection</p>
          ${isDevMode ? `
            <div class="collection-dev-actions" style="margin-top: 1rem;">
              <button class="btn small add-object-btn" data-collection="${collection.id}">➕ Ajouter un objet à cette collection</button>
              <button class="btn small remove-object-btn" data-collection="${collection.id}">➖ Retirer un objet de cette collection</button>
            </div>
          ` : ''}
        `;
      }
      
      // Get all unique tags from filtered objects for additional filtering
      const allTags = [...new Set(filteredObjects.flatMap(obj => obj.tags || []))];
      
      // Create tag filters if objects have multiple tags
      if (allTags.length > 1 && tagFiltersContainer) {
        tagFiltersContainer.innerHTML = `
          <h3>Filtrer par tag:</h3>
          <div class="tag-buttons">
            <button class="tag-filter-btn active" data-tag="all">Tous</button>
            ${allTags.map(tag => `
              <button class="tag-filter-btn" data-tag="${tag}">${tag}</button>
            `).join('')}
          </div>
        `;
      } else if (tagFiltersContainer) {
        tagFiltersContainer.innerHTML = '';
      }
      
      // Display objects
      this.renderCollectionItems(filteredObjects);
      
      // Setup add/remove object button listeners if in dev mode
      if (isDevMode) {
        const addObjectBtn = document.querySelector('.add-object-btn');
        if (addObjectBtn) {
          addObjectBtn.addEventListener('click', () => {
            const collection = addObjectBtn.getAttribute('data-collection');
            this.addObjectToCollection(collection);
          });
        }
        
        const removeObjectBtn = document.querySelector('.remove-object-btn');
        if (removeObjectBtn) {
          removeObjectBtn.addEventListener('click', () => {
            const collection = removeObjectBtn.getAttribute('data-collection');
            this.removeObjectFromCollection(collection);
          });
        }

        const backToCollectionsBtn = document.querySelector('.back-to-collections-btn');
        if (backToCollectionsBtn) {
          backToCollectionsBtn.addEventListener('click', () => {
            this.showCollectionsGrid();
          });
        }
      }
      
      // Tag filter event listeners
      document.querySelectorAll('.tag-filter-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          // Update active state
          document.querySelectorAll('.tag-filter-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          
          const selectedTag = btn.getAttribute('data-tag');
          let itemsToShow = filteredObjects;
          
          if (selectedTag !== 'all') {
            itemsToShow = filteredObjects.filter(obj => 
              obj.tags && obj.tags.includes(selectedTag)
            );
          }
          
          this.renderCollectionItems(itemsToShow);
        });
      });
    },

    showCollectionNotFound(collectionName) {
      const resultsContainer = document.getElementById('collection-results');
      const headerContainer = document.getElementById('collection-header');
      const itemsContainer = document.getElementById('collection-items');
      const tagFiltersContainer = document.getElementById('tag-filters');
      const availableCollections = document.getElementById('available-collections');
      
      // Show error message for non-existent collection
      if (availableCollections) {
        availableCollections.style.display = 'none';
      }
      if (resultsContainer) {
        resultsContainer.style.display = 'block';
      }
      
      if (headerContainer) {
        const isDevMode = this.isDevModeActive();
        headerContainer.innerHTML = `
          <div class="collection-error">
            <h2>❌ Collection introuvable</h2>
            <p>Aucune collection nommée "<strong>${collectionName}</strong>" n'a été trouvée.</p>
            ${isDevMode ? 
              `<p>Les collections disponibles sont listées ci-dessous.</p>` : 
              `<p>Vérifiez l'orthographe ou contactez un administrateur pour connaître les collections disponibles.</p>`
            }
          </div>
        `;
      }
      
      if (itemsContainer) {
        itemsContainer.innerHTML = '';
      }
      if (tagFiltersContainer) {
        tagFiltersContainer.innerHTML = '';
      }
      
      // Clear search input after delay and show available collections only in dev mode
      setTimeout(() => {
        document.getElementById('collection-search-input').value = '';
        
        // Only show collections grid in dev mode
        const isDevMode = this.isDevModeActive();
        if (availableCollections) {
          availableCollections.style.display = isDevMode ? 'block' : 'none';
        }
        if (resultsContainer) {
          resultsContainer.style.display = 'none';
        }
      }, 3000);
    },

    renderCollectionItems(items) {
      const itemsContainer = document.getElementById('collection-items');
      
      // Multiple ways to detect dev mode for robustness
      const isDevMode = (
        (JdrApp && JdrApp.utils && JdrApp.utils.isDevMode && JdrApp.utils.isDevMode()) ||
        document.body.classList.contains('dev-on') ||
        (JdrApp.modules && JdrApp.modules.editor && JdrApp.modules.editor.isDevMode)
      );
      
      
      // Check if CardBuilder is available
      if (!window.CardBuilder) {
        console.error('CardBuilder not available, falling back to simple display');
        const itemsHTML = items.map(item => `
          <div class="card" data-object-numero="${item.numero}">
            <h4>${item.nom}</h4>
            <p><strong>N°${item.numero}</strong></p>
            <p>${item.description}</p>
            <hr>
            <p>${item.effet}</p>
            <div style="display: flex; justify-content: space-between;">
              <span>${item.prix}</span>
              <span>${item.poids}</span>
            </div>
            ${isDevMode ? `
              <div class="dev-controls" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #ccc;">
                <button class="btn small edit-object-btn" data-numero="${item.numero}">✏️ Éditer</button>
                <button class="btn small remove-from-collection-btn" data-numero="${item.numero}" style="background: #f59e0b;">➖ Retirer</button>
                <button class="btn small delete-object-btn" data-numero="${item.numero}" style="background: #ef4444;">🗑️ Supprimer</button>
              </div>
            ` : ''}
          </div>
        `).join('');
        itemsContainer.innerHTML = itemsHTML;
      } else {
        // Use the existing CardBuilder system to ensure consistent formatting and images
        const itemsHTML = items.map(item => {
          return window.CardBuilder.create('objet', item, 'objets').build();
        }).join('');
        
        itemsContainer.innerHTML = itemsHTML;
        
        // Add dev controls after DOM insertion if in dev mode
        if (isDevMode) {
          items.forEach(item => {
            const card = itemsContainer.querySelector(`.card[data-objet-name="${item.nom}"]`);
            if (card) {
              const devControls = document.createElement('div');
              devControls.className = 'dev-controls collection-dev-controls';
              devControls.style.cssText = 'margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #ddd;';
              devControls.innerHTML = `
                <button class="btn small edit-object-btn" data-numero="${item.numero}" style="margin: 2px;">✏️ Éditer</button>
                <button class="btn small remove-from-collection-btn" data-numero="${item.numero}" style="margin: 2px; background: #f59e0b;">➖ Retirer de cette collection</button>
                <button class="btn small delete-object-btn" data-numero="${item.numero}" style="margin: 2px; background: #ef4444;">🗑️ Supprimer définitivement</button>
              `;
              card.appendChild(devControls);
            }
          });
        }
      }
      
      // Add event listeners for dev controls
      if (isDevMode) {
        this.setupCollectionEditControls();
      }
      
      // Auto-load images and manage dev mode buttons after rendering
      setTimeout(() => {
        if (JdrApp.modules.renderer && JdrApp.modules.renderer.autoLoadImages) {
          JdrApp.modules.renderer.autoLoadImages();
        }
        
        // Force apply dev mode classes to ensure CSS rules work
        this.ensureDevModeClasses();
      }, 100);
    },

    setupCollectionEditControls() {
      // Edit object buttons
      const editBtns = document.querySelectorAll('.edit-object-btn');
      const removeBtns = document.querySelectorAll('.remove-from-collection-btn');
      const deleteBtns = document.querySelectorAll('.delete-object-btn');
      
      // console.log('🎛️ Setting up object controls:', {
      //   editBtns: editBtns.length,
      //   removeBtns: removeBtns.length,
      //   deleteBtns: deleteBtns.length
      // });

      editBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const objectNumero = parseInt(btn.getAttribute('data-numero'));
          // console.log('✏️ Edit object clicked:', objectNumero);
          this.editCollectionObject(objectNumero);
        });
      });

      // Remove from collection buttons
      removeBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const objectNumero = parseInt(btn.getAttribute('data-numero'));
          // console.log('➖ Remove from collection clicked:', objectNumero);
          this.removeObjectFromCurrentCollection(objectNumero);
        });
      });

      // Delete object buttons
      deleteBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const objectNumero = parseInt(btn.getAttribute('data-numero'));
          // console.log('🗑️ Delete object clicked:', objectNumero);
          this.deleteCollectionObject(objectNumero);
        });
      });
    },

    editCollectionObject(objectNumero) {
      // Find the object in the data (normalize comparison)
      const object = window.OBJETS.objets.find(obj => parseInt(obj.numero) === objectNumero);
      if (!object) {
        console.error('Object not found:', objectNumero);
        return;
      }

      // Navigate to the objects page and trigger edit for this specific object
      // This reuses the existing object editing functionality
      window.location.hash = '#/objets';
      
      // Wait for the page to load, then trigger edit
      setTimeout(() => {
        const objectCard = document.querySelector(`[data-numero="${objectNumero}"]`);
        if (objectCard) {
          // Trigger the existing edit functionality
          const editableElements = objectCard.querySelectorAll('.editable');
          if (editableElements.length > 0) {
            // Focus on the first editable element to start editing
            editableElements[0].click();
          }
        }
      }, 500);
    },

    removeObjectFromCurrentCollection(objectNumero) {
      // Find the object in the data (normalize comparison)
      const object = window.OBJETS.objets.find(obj => parseInt(obj.numero) === objectNumero);
      if (!object) {
        console.error('Object not found:', objectNumero);
        return;
      }

      // Determine which collection we're currently viewing
      const searchInput = document.getElementById('collection-search-input');
      const currentCollectionName = searchInput ? searchInput.value : null;
      
      if (!currentCollectionName) {
        alert('Impossible de déterminer la collection actuelle.');
        return;
      }

      // Find the current collection
      const collection = window.COLLECTIONS.collections.find(coll => 
        coll.nom === currentCollectionName || coll.id === currentCollectionName
      );
      
      if (!collection) {
        alert(`Collection "${currentCollectionName}" introuvable.`);
        return;
      }

      // Check if the object is in this collection (normalize comparison)
      const objNum = parseInt(objectNumero);
      const isInCollection = collection.objets.includes(objNum) || collection.objets.includes(objectNumero);
      if (!isInCollection) {
        alert(`L'objet "${object.nom}" n'est pas dans la collection "${collection.nom}".`);
        return;
      }

      // Confirm removal
      const confirmRemove = confirm(
        `Êtes-vous sûr de vouloir retirer l'objet "${object.nom}" de la collection "${collection.nom}"?\n\n` +
        `L'objet ne sera pas supprimé, seulement retiré de cette collection.`
      );
      if (!confirmRemove) return;

      // Remove the object from the collection (normalize comparison)
      let objectIndex = collection.objets.indexOf(objNum);
      if (objectIndex === -1) {
        objectIndex = collection.objets.indexOf(objectNumero);
      }
      if (objectIndex !== -1) {
        collection.objets.splice(objectIndex, 1);
        
        // Show notification
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification(`➖ Objet "${object.nom}" retiré de la collection "${collection.nom}"`, 'success');
        }

        // Refresh the current collection view
        this.displayCollection(collection.id);
      }
    },

    deleteCollectionObject(objectNumero) {
      // Find the object in the data (normalize comparison)  
      const object = window.OBJETS.objets.find(obj => parseInt(obj.numero) === objectNumero);
      if (!object) {
        console.error('Object not found:', objectNumero);
        return;
      }

      // Confirm deletion
      const confirmDelete = confirm(`Êtes-vous sûr de vouloir supprimer l'objet "${object.nom}" (N°${object.numero}) ?`);
      if (!confirmDelete) return;

      // Remove the object from the data (normalize comparison)
      const objectIndex = window.OBJETS.objets.findIndex(obj => parseInt(obj.numero) === objectNumero);
      if (objectIndex !== -1) {
        window.OBJETS.objets.splice(objectIndex, 1);
        
        // Show notification
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification(`🗑️ Objet "${object.nom}" supprimé`, 'success');
        }

        // Refresh the current collection view
        const currentSearch = document.getElementById('collection-search-input').value;
        if (currentSearch) {
          this.displayCollection(currentSearch);
        }
      }
    },

    addObjectToCollection(collectionId) {
      // Find the collection
      const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
      if (!collection) {
        alert('Collection introuvable.');
        return;
      }
      
      // Show a list of all available objects to choose from
      const allObjects = window.OBJETS.objets;
      if (allObjects.length === 0) {
        alert('Aucun objet disponible à ajouter.');
        return;
      }
      
      // Filter out objects already in this collection
      // Normalize number comparison to handle both string and number types
      const availableObjects = allObjects.filter(obj => {
        const objNum = parseInt(obj.numero);
        return !collection.objets.includes(objNum) && !collection.objets.includes(obj.numero);
      });
      
      if (availableObjects.length === 0) {
        alert('Tous les objets sont déjà dans cette collection.');
        return;
      }
      
      // Create a selection modal with dropdown
      this.showObjectSelectionModal(
        `Ajouter un objet à la collection "${collection.nom}"`,
        availableObjects,
        (selectedObject) => {
          // Add the object to the collection (normalize to number type)
          const objNum = parseInt(selectedObject.numero);
          collection.objets.push(objNum);
          
          // Show notification
          if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
            JdrApp.modules.storage.showNotification(`➕ Objet "${selectedObject.nom}" ajouté à la collection "${collection.nom}"`, 'success');
          }
          
          // Refresh the current collection view to show the added object
          this.displayCollection(collectionId);
          
          // Auto-scroll to the added object
          setTimeout(() => {
            const addedObjectCard = document.querySelector(`[data-numero="${selectedObject.numero}"]`);
            if (addedObjectCard) {
              addedObjectCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
              // Highlight the added object briefly
              addedObjectCard.style.border = '3px solid #10B981';
              setTimeout(() => {
                addedObjectCard.style.border = '';
              }, 2000);
            }
          }, 500);
        }
      );
    },

    removeObjectFromCollection(collectionId) {
      // Find the collection
      const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
      if (!collection) {
        alert('Collection introuvable.');
        return;
      }
      
      if (!collection.objets || collection.objets.length === 0) {
        alert('Cette collection est vide.');
        return;
      }
      
      // Get the objects in this collection
      const collectionObjects = window.OBJETS.objets.filter(obj => 
        collection.objets.includes(obj.numero)
      );
      
      // Create a selection modal with dropdown
      this.showObjectSelectionModal(
        `Retirer un objet de la collection "${collection.nom}"`,
        collectionObjects,
        (selectedObject) => {
          // Remove the object from the collection
          const objectIndex = collection.objets.indexOf(selectedObject.numero);
          if (objectIndex !== -1) {
            collection.objets.splice(objectIndex, 1);
            
            // Show notification
            if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
              JdrApp.modules.storage.showNotification(`➖ Objet "${selectedObject.nom}" retiré de la collection "${collection.nom}"`, 'success');
            }
            
            // Refresh the current collection view
            this.displayCollection(collectionId);
          }
        }
      );
    },

    showCollectionsGrid() {
      // Hide collection results and show collections grid only in dev mode
      const resultsContainer = document.getElementById('collection-results');
      const availableCollections = document.getElementById('available-collections');
      const searchInput = document.getElementById('collection-search-input');
      
      if (resultsContainer) {
        resultsContainer.style.display = 'none';
      }
      
      // Only show collections grid in dev mode
      const isDevMode = this.isDevModeActive();
      if (availableCollections) {
        availableCollections.style.display = isDevMode ? 'block' : 'none';
      }
      
      // Clear the search input
      if (searchInput) {
        searchInput.value = '';
      }
      
      // Refresh the collections grid to ensure it's up to date if in dev mode
      if (isDevMode) {
        this.generateCollectionsGrid();
      }
    },

    showObjectSelectionModal(title, objects, onSelectCallback) {
      // Remove any existing modal
      const existingModal = document.querySelector('#object-selection-modal');
      if (existingModal) {
        existingModal.remove();
      }

      // Create modal HTML
      const modal = document.createElement('dialog');
      modal.id = 'object-selection-modal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        border: 3px solid #8B4513;
        border-radius: 12px;
        padding: 0;
        background: transparent !important;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5) !important;
      `;

      const selectOptions = objects
        .map(obj => `<option value="${obj.numero}">N°${obj.numero} - ${obj.nom}</option>`)
        .join('');

      modal.innerHTML = `
        <div style="
          background: white; 
          border-radius: 12px; 
          padding: 1.5rem; 
          border: 3px solid #8B4513;
          font-family: inherit;
          font-size: 16px;
        ">
          <h2 style="
            color: #8B4513; 
            font-family: 'Cinzel', serif; 
            margin: 0 0 1rem 0; 
            text-align: center;
          ">${title}</h2>
          
          <div style="margin: 1rem 0;">
            <label for="object-select" style="
              display: block; 
              margin-bottom: 0.5rem; 
              color: #8B4513; 
              font-weight: bold;
            ">Sélectionnez un objet :</label>
            <select id="object-select" style="
              width: 100%; 
              padding: 0.5rem; 
              border: 2px solid #8B4513; 
              border-radius: 8px; 
              font-size: 16px;
              font-family: inherit;
            ">
              <option value="">-- Choisissez un objet --</option>
              ${selectOptions}
            </select>
          </div>
          
          <div style="
            display: flex; 
            gap: 1rem; 
            justify-content: center; 
            margin-top: 1.5rem;
          ">
            <button class="btn-confirm-selection" style="
              background: #10B981; 
              color: white; 
              border: none; 
              padding: 0.75rem 1.5rem; 
              border-radius: 8px; 
              cursor: pointer; 
              font-weight: bold;
            ">Confirmer</button>
            <button class="btn-cancel-selection" style="
              background: #6B7280; 
              color: white; 
              border: none; 
              padding: 0.75rem 1.5rem; 
              border-radius: 8px; 
              cursor: pointer; 
              font-weight: bold;
            ">Annuler</button>
          </div>
        </div>
      `;

      // Add to body and show
      document.body.appendChild(modal);
      modal.showModal();

      // Set up event handlers
      const select = modal.querySelector('#object-select');
      const confirmBtn = modal.querySelector('.btn-confirm-selection');
      const cancelBtn = modal.querySelector('.btn-cancel-selection');

      confirmBtn.addEventListener('click', () => {
        const selectedNumero = parseInt(select.value);
        if (selectedNumero) {
          const selectedObject = objects.find(obj => obj.numero === selectedNumero);
          if (selectedObject && onSelectCallback) {
            onSelectCallback(selectedObject);
          }
        } else {
          alert('Veuillez sélectionner un objet.');
          return;
        }
        modal.close();
        modal.remove();
      });

      cancelBtn.addEventListener('click', () => {
        modal.close();
        modal.remove();
      });

      // Handle ESC key
      modal.addEventListener('close', () => {
        modal.remove();
      });
    },

    ensureDevModeClasses() {
      // Ensure the body has the correct dev mode class
      const isDevMode = JdrApp && JdrApp.utils && JdrApp.utils.isDevMode ? JdrApp.utils.isDevMode() : false;
      
      if (isDevMode) {
        document.body.classList.remove('dev-off');
        document.body.classList.add('dev-on');
      } else {
        document.body.classList.remove('dev-on');
        document.body.classList.add('dev-off');
      }
      
      // Force hide image buttons on collections page if not in dev mode
      if (!isDevMode) {
        const collectionItems = document.getElementById('collection-items');
        if (collectionItems) {
          const imageButtons = collectionItems.querySelectorAll('.illus label.up, .illus button.rm');
          imageButtons.forEach(button => {
            button.style.setProperty('display', 'none', 'important');
          });
        }
      }
    },

    getCollectionsDescription() {
      return JdrApp.data.customPageDescriptions['collections-objets'] || 'Recherchez et explorez des collections d\'objets organisées par thème';
    },

    generateCollectionsGrid() {
      if (!window.COLLECTIONS || !window.COLLECTIONS.collections) {
        return;
      }
      
      // Use defined collections instead of extracting from tags
      const collections = window.COLLECTIONS.collections;
      
      // Collection icons are now defined in the collections data itself
      
      const isDevMode = this.isDevModeActive();
      const collectionsGrid = document.querySelector('.collections-grid');
      
      if (!collectionsGrid) return;
      
      // Generate HTML for each collection
      const collectionsHTML = collections
        .map((collection) => {
          const count = collection.objets ? collection.objets.length : 0;
          return `
            <div class="collection-card" data-collection="${collection.id}">
              <div class="collection-icon">${collection.icon}</div>
              <h3>${collection.nom}</h3>
              <p>${count} objet(s)</p>
              <p class="collection-description">${collection.description}</p>
              ${isDevMode ? `
                <div class="collection-dev-controls">
                  <button class="btn small edit-collection-btn" data-collection="${collection.id}" title="Modifier cette collection">✏️ Modifier</button>
                  <button class="btn small delete-collection-btn" data-collection="${collection.id}" title="Supprimer cette collection">🗑️ Supprimer</button>
                </div>
              ` : ''}
            </div>
          `;
        }).join('');
      
      // Add "create new collection" button in dev mode
      const devActions = isDevMode ? `
        <div class="collection-card new-collection-card">
          <div class="collection-icon">➕</div>
          <h3>Nouvelle Collection</h3>
          <p>Créer une collection</p>
          <button class="btn small create-collection-btn">➕ Créer</button>
        </div>
      ` : '';
      
      collectionsGrid.innerHTML = collectionsHTML + devActions;
      
      // console.log('📦 Collections grid generated:', {
      //   collectionsCount: collections.length,
      //   hasDevActions: !!devActions,
      //   gridContent: collectionsGrid.innerHTML.length + ' chars'
      // });
      
      // Setup event listeners for collections (always active)
      this.setupCollectionEventListeners();
      
      // Setup dev-specific controls only in dev mode
      if (isDevMode) {
        this.setupCollectionManagementControls();
      }
    },

    isDevModeActive() {
      // Multiple ways to detect dev mode for robustness
      return (
        (JdrApp && JdrApp.utils && JdrApp.utils.isDevMode && JdrApp.utils.isDevMode()) ||
        document.body.classList.contains('dev-on') ||
        (JdrApp.modules && JdrApp.modules.editor && JdrApp.modules.editor.isDevMode)
      );
    },

    setupCollectionEventListeners() {
      // Collection card click listeners (open collection for viewing/editing)
      const collectionCards = document.querySelectorAll('.collection-card:not(.new-collection-card)');
      
      collectionCards.forEach(card => {
        card.addEventListener('click', (e) => {
          // Don't trigger if clicking on control buttons
          if (e.target.closest('.collection-dev-controls')) {
            return;
          }
          
          const collectionId = card.getAttribute('data-collection');
          if (collectionId) {
            // Find collection to get its name
            const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
            if (collection) {
              // Fill search input with collection name
              const searchInput = document.getElementById('collection-search-input');
              if (searchInput) {
                searchInput.value = collection.nom;
              }
              
              // Open the collection
              this.displayCollection(collectionId);
            }
          }
        });
      });
    },

    setupCollectionManagementControls() {
      // Create new collection button
      const createBtn = document.querySelector('.create-collection-btn');
      const editBtns = document.querySelectorAll('.edit-collection-btn');
      const deleteBtns = document.querySelectorAll('.delete-collection-btn');
      
      // console.log('🎛️ Setting up collection controls:', {
      //   createBtn: !!createBtn,
      //   editBtns: editBtns.length,
      //   deleteBtns: deleteBtns.length
      // });
      
      if (createBtn) {
        createBtn.addEventListener('click', () => {
          // console.log('➕ Create collection clicked');
          this.createNewCollection();
        });
      }

      // Edit collection buttons (rename)
      editBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const collectionName = btn.getAttribute('data-collection');
          // console.log('✏️ Edit collection clicked:', collectionName);
          this.renameCollection(collectionName);
        });
      });

      // Delete collection buttons
      deleteBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const collectionName = btn.getAttribute('data-collection');
          // console.log('🗑️ Delete collection clicked:', collectionName);
          this.deleteCollection(collectionName);
        });
      });
    },

    createNewCollection() {
      const collectionName = prompt('Nom de la nouvelle collection:');
      if (!collectionName || !collectionName.trim()) return;
      
      const trimmedName = collectionName.trim();
      
      // Generate an ID from the name
      const collectionId = trimmedName.toLowerCase().replace(/[^a-z0-9]/g, '-');
      
      // Check if collection already exists
      const existingCollection = window.COLLECTIONS.collections.find(coll => 
        coll.id === collectionId || coll.nom.toLowerCase() === trimmedName.toLowerCase()
      );
      
      if (existingCollection) {
        alert(`La collection "${trimmedName}" existe déjà.`);
        return;
      }
      
      // Get collection description and icon
      const collectionDescription = prompt('Description de la collection:', 'Nouvelle collection d\'objets');
      const collectionIcon = prompt('Icône de la collection (emoji):', '📦');
      
      // Create new collection object
      const newCollection = {
        id: collectionId,
        nom: trimmedName,
        description: collectionDescription || 'Nouvelle collection d\'objets',
        icon: collectionIcon || '📦',
        objets: []
      };
      
      // Add to collections data
      window.COLLECTIONS.collections.push(newCollection);
      
      // Refresh the grid
      this.generateCollectionsGrid();
      
      if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
        JdrApp.modules.storage.showNotification(`✅ Collection "${trimmedName}" créée avec succès!`, 'success');
      }
    },

    renameCollection(collectionId) {
      // Find the collection by ID
      const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
      if (!collection) {
        alert('Collection introuvable.');
        return;
      }
      
      const newName = prompt(`Nouveau nom pour la collection "${collection.nom}":`, collection.nom);
      if (!newName || !newName.trim() || newName.trim() === collection.nom) return;
      
      const trimmedNewName = newName.trim();
      
      // Check if new name already exists
      const existingCollection = window.COLLECTIONS.collections.find(coll => 
        coll.id !== collectionId && coll.nom.toLowerCase() === trimmedNewName.toLowerCase()
      );
      
      if (existingCollection) {
        alert(`La collection "${trimmedNewName}" existe déjà.`);
        return;
      }
      
      // Update collection name
      collection.nom = trimmedNewName;
      
      // Refresh the collections grid
      this.generateCollectionsGrid();
      
      if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
        JdrApp.modules.storage.showNotification(`✅ Collection renommée en "${trimmedNewName}"`, 'success');
      }
    },

    deleteCollection(collectionId) {
      // Find the collection by ID
      const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
      if (!collection) {
        alert('Collection introuvable.');
        return;
      }
      
      const objectCount = collection.objets ? collection.objets.length : 0;
      
      const confirmDelete = confirm(
        `Êtes-vous sûr de vouloir supprimer la collection "${collection.nom}"?\n` +
        `Cette collection contient ${objectCount} objet(s).\n` +
        `Les objets ne seront pas supprimés, seulement la collection sera retirée.`
      );
      
      if (!confirmDelete) return;
      
      // Remove the collection from the collections array
      const collectionIndex = window.COLLECTIONS.collections.findIndex(coll => coll.id === collectionId);
      if (collectionIndex !== -1) {
        window.COLLECTIONS.collections.splice(collectionIndex, 1);
        
        // Refresh the collections grid
        this.generateCollectionsGrid();
        
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification(`🗑️ Collection "${collection.nom}" supprimée`, 'success');
        }
      }
    },

    setupDevModeListener() {
      // Listen for dev mode changes via EventBus
      if (window.EventBus && window.Events) {
        EventBus.on(Events.EDITOR_TOGGLE, (payload) => {
          // console.log('🔄 Dev mode changed via EventBus:', payload.enabled);
          setTimeout(() => this.refreshCollectionsView(), 50);
        });
      }
      
      // Also listen for body class changes (fallback)
      if (window.MutationObserver) {
        if (this.devModeObserver) {
          this.devModeObserver.disconnect();
        }
        
        // Track the previous dev mode state to avoid loops
        let lastDevMode = this.isDevModeActive();
        
        this.devModeObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
              const currentDevMode = this.isDevModeActive();
              
              // Only refresh if dev mode actually changed
              if (currentDevMode !== lastDevMode) {
                // console.log('🔄 Body class changed, refreshing views - Dev mode:', currentDevMode);
                lastDevMode = currentDevMode;
                setTimeout(() => this.refreshCollectionsView(), 100);
              }
            }
          });
        });
        
        this.devModeObserver.observe(document.body, {
          attributes: true,
          attributeFilter: ['class']
        });
      }
    },

    refreshCollectionsView() {
      const currentHash = window.location.hash;
      
      // Refresh collections page if we're on it
      if (currentHash === '#/collections-objets') {
        const availableCollections = document.getElementById('available-collections');
        const isDevMode = this.isDevModeActive();
        
        // console.log('🔄 Refreshing collections view - Dev mode:', isDevMode);
        
        // Regenerate the collections grid
        this.generateCollectionsGrid();
        
        // Update visibility
        if (availableCollections) {
          if (isDevMode) {
              availableCollections.style.display = 'block';
          } else {
              availableCollections.style.display = 'none';
          }
        }
      }
      
      // Also refresh objects page if we're on it (for filter visibility)
      if (currentHash === '#/objets') {
        console.log('🔄 Refreshing objects page due to dev mode change');
        setTimeout(() => {
          this.renderObjectsPage();
        }, 100); // Augmenter le délai pour être sûr que le dev mode est à jour
      }
    },

    updateCollectionsDescription(newDescription) {
      JdrApp.data.customPageDescriptions['collections-objets'] = newDescription;
      // Also update via ContentFactory for consistency
      if (window.ContentFactory) {
        ContentFactory.updatePageDescription('collections', newDescription);
      }
    },

    renderFeuillePersonnagePage() {
      // Create or find the page element
      let pageElement = document.getElementById('feuille-personnage');
      
      // If the page doesn't exist, create it
      if (!pageElement) {
        pageElement = document.createElement('article');
        pageElement.id = 'feuille-personnage';
        pageElement.setAttribute('data-page', 'feuille-personnage');
        pageElement.className = 'page';
        
        // Insert it into the views container
        const viewsContainer = document.querySelector('#views');
        
        if (viewsContainer) {
          viewsContainer.appendChild(pageElement);
        } else {
          console.error('Views container not found');
          return false;
        }
      }
      
      // Create full PDF content for all versions  
      const feuillePersonnageContent = `
        <div class="page-header">
          <h1>📋 Feuille de personnage</h1>
        </div>
        
          
          
          <!-- PDF Info and Actions -->
          <div class="pdf-info-container" style="width: 100%; margin: 1rem 0; padding: 2rem; border: 2px solid var(--bronze); border-radius: 12px; background: var(--card); text-align: center;">
            <h3 style="color: var(--gold); font-family: 'Cinzel', serif; margin: 0 0 1rem 0;">📄 Feuille de personnage PDF</h3>
            <p style="color: var(--text); margin: 1rem 0;">Feuille de personnage complète de 3 pages pour vos aventures BabJDR</p>
            
            <div class="pdf-preview-actions" style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; margin-top: 1.5rem;">
              <button id="open-pdf-new-tab" class="btn-base" style="background: var(--bronze); color: white;">
                📖 Voir le PDF
              </button>
              <button id="download-pdf-direct" class="btn-base" style="background: var(--emerald); color: white;">
                📥 Télécharger
              </button>
              <button id="print-pdf-direct" class="btn-base" style="background: var(--gold); color: white;">
                🖨️ Imprimer
              </button>
            </div>
            
            <p style="color: var(--text-muted); font-size: 0.9rem; margin-top: 1rem;">
              💡 Astuce : Cliquez sur "Voir le PDF" pour l'ouvrir dans un nouvel onglet
            </p>
          </div>
          
          <div class="pdf-fallback" style="display: none; text-align: center; padding: 2rem; background: var(--accent-bg); border-radius: 8px; margin: 1rem 0;">
            <h3 style="color: var(--bronze);">📄 Feuille de personnage BabJDR</h3>
            <p style="color: var(--accent-ink); margin: 1rem 0;">
              Votre navigateur ne peut pas afficher le PDF directement. Utilisez les boutons ci-dessous:
            </p>
            
            <div class="pdf-info" style="background: white; border: 1px solid var(--rule); border-radius: 8px; padding: 1.5rem; margin: 1rem 0; text-align: left;">
              <h4 style="color: var(--bronze); margin-top: 0;">📝 Contenu de la feuille:</h4>
              <ul style="color: var(--accent-ink); line-height: 1.8;">
                <li><strong>Informations du personnage:</strong> Nom, classe, niveau, expérience</li>
                <li><strong>Caractéristiques:</strong> Force, Endurance, Agilité, Intelligence, Volonté, Chance</li>
                <li><strong>Statistiques dérivées:</strong> Vie, Mana, Initiative, Fortune, Armure, Esquive</li>
                <li><strong>Compétences:</strong> Hardiesse, Finesse, Coordination, Réflexion, Éloquence</li>
                <li><strong>Éléments:</strong> Armure élémentaire (Feu, Eau, Terre, Air, Lumière, Nuit, Divin, Maléfique)</li>
                <li><strong>Sorts et capacités:</strong> Liste des sorts connus et dons acquis</li>
                <li><strong>Inventaire:</strong> Consommables et sac général</li>
                <li><strong>Background:</strong> Histoire, apparence et personnalité du personnage</li>
              </ul>
            </div>
          </div>
          
        </div>
        
        <div class="character-sheet-info" style="margin-top: 1rem; text-align: center; color: var(--accent-ink);">
          <p><strong>💡 Info:</strong> La feuille de personnage est un PDF imprimable de 3 pages contenant tous les champs nécessaires pour votre personnage.</p>
        </div>
      `;
      
      // Insert content into the page
      pageElement.innerHTML = feuillePersonnageContent;
      
      // Setup event listeners for print and download functionality
      this.setupCharacterSheetActions();
      
      
      // Show and activate page
      this.show('feuille-personnage');
      this.updateActiveStates('feuille-personnage');
      
      return true;
    },

    setupCharacterSheetActions() {
      const pdfUrl = 'https://github.com/ben-128/BabJdr/raw/master/data/feuille-personnage.pdf';
      
      // Setup main action buttons
      const openBtn = document.getElementById('open-character-sheet');
      const printBtn = document.getElementById('print-character-sheet');
      const downloadBtn = document.getElementById('download-character-sheet');
      
      // Setup preview action buttons
      const openTabBtn = document.getElementById('open-pdf-new-tab');
      const printDirectBtn = document.getElementById('print-pdf-direct');
      const downloadDirectBtn = document.getElementById('download-pdf-direct');
      
      // Check if PDF embed is supported and handle fallback
      const pdfEmbed = document.getElementById('pdf-embed');
      const pdfFallback = document.querySelector('.pdf-fallback');
      
      if (pdfEmbed) {
        // Add load error handler for PDF embed
        pdfEmbed.addEventListener('error', () => {
          // Hide embed and show fallback
          pdfEmbed.style.display = 'none';
          if (pdfFallback) {
            pdfFallback.style.display = 'block';
          }
        });
        
        // Test if PDF can be loaded after a delay
        setTimeout(() => {
          // Check if the embed has loaded properly
          try {
            const embedDoc = pdfEmbed.contentDocument || pdfEmbed.contentWindow.document;
            if (!embedDoc || embedDoc.body.innerHTML.includes('%PDF')) {
              // PDF is showing as raw text, use fallback
              pdfEmbed.style.display = 'none';
              if (pdfFallback) {
                pdfFallback.style.display = 'block';
              }
            }
          } catch (e) {
            // Can't access content, probably loaded correctly
          }
        }, 1000);
      }
      
      // Open PDF in new tab
      const openPDF = () => {
        window.open(pdfUrl, '_blank');
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification('📖 PDF ouvert dans un nouvel onglet', 'success');
        }
      };
      
      // Print PDF
      const printPDF = () => {
        const printWindow = window.open(pdfUrl, '_blank');
        if (printWindow) {
          printWindow.focus();
          setTimeout(() => {
            try {
              printWindow.print();
            } catch (e) {
              alert('PDF ouvert. Utilisez Ctrl+P pour imprimer.');
            }
          }, 1000);
        } else {
          alert('Impossible d\'ouvrir le PDF. Vérifiez que les popups ne sont pas bloqués.');
        }
      };
      
      // Download PDF
      const downloadPDF = () => {
        const link = document.createElement('a');
        link.href = pdfUrl;
        link.download = 'Feuille-Personnage-BabJDR.pdf';
        link.style.display = 'none';
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification('📥 Téléchargement en cours...', 'success');
        }
      };
      
      // Attach event listeners
      if (openBtn) openBtn.addEventListener('click', openPDF);
      if (printBtn) printBtn.addEventListener('click', printPDF);
      if (downloadBtn) downloadBtn.addEventListener('click', downloadPDF);
      
      if (openTabBtn) openTabBtn.addEventListener('click', openPDF);
      if (printDirectBtn) printDirectBtn.addEventListener('click', printPDF);
      if (downloadDirectBtn) downloadDirectBtn.addEventListener('click', downloadPDF);
    },

    renderFavorisPage() {
      // Use the unified PageBuilder to render the favoris page  
      const favorisData = window.FAVORIS || {
        page: 'favoris',
        title: '⭐ Favoris',
        static: true,
        sections: [
          {
            type: 'intro',
            content: 'Retrouvez ici vos sorts et objets préférés. Cliquez sur l\'étoile ⭐ à côté des éléments pour les ajouter à vos favoris.'
          }
        ]
      };
      
      // Generate the page HTML using PageBuilder directly
      const pageHtml = PageBuilder.buildStaticPage('favoris', favorisData);
      
      // Find or create the views container and insert the page
      const viewsContainer = document.querySelector('#views');
      if (viewsContainer) {
        // Remove existing favoris page if it exists
        const existingPage = document.querySelector('[data-page="favoris"]');
        if (existingPage) {
          existingPage.remove();
        }
        
        viewsContainer.insertAdjacentHTML('beforeend', pageHtml);
      }
      
      // Trigger favoris display update
      if (window.FavorisRenderer) {
        setTimeout(() => window.FavorisRenderer.updateFavorisDisplay(), 100);
      }

      // Show and activate page
      this.show('favoris');
      this.updateActiveStates('favoris');
      
      return true;
    },

    renderObjectsPage() {
      // Check if page already exists and force refresh is requested
      const existingPage = document.querySelector('[data-page="objets"]');
      const shouldRefresh = this._forceObjectsRefresh || !existingPage;
      
      if (!shouldRefresh && existingPage) {
        // Page exists and no refresh needed, just show it
        setTimeout(() => {
          this.setupObjectSearchFunctionality();
        }, 100);
        this.show('objets');
        this.updateActiveStates('objets');
        return true;
      }
      
      // Reset the force refresh flag
      this._forceObjectsRefresh = false;
      
      // Get objects data
      const objectsData = window.OBJETS || { objets: [] };
      
      // Use PageBuilder to generate the objects page
      if (!window.PageBuilder) {
        console.error('PageBuilder not available for objects page');
        return false;
      }
      
      // Generate page HTML using PageBuilder
      const pageHtml = PageBuilder.buildSingleObjectPage(objectsData);
      
      // Find or create the views container
      const viewsContainer = document.querySelector('#views');
      if (!viewsContainer) {
        console.error('Views container not found');
        return false;
      }
      
      // Remove existing objects page if it exists
      if (existingPage) {
        existingPage.remove();
      }
      
      // Insert the new page
      viewsContainer.insertAdjacentHTML('beforeend', pageHtml);
      
      // Setup object search functionality
      setTimeout(() => {
        this.setupObjectSearchFunctionality();
      }, 100);
      
      // Show and activate page
      this.show('objets');
      this.updateActiveStates('objets');
      
      return true;
    },

    refreshObjectsPageIfActive() {
      if (window.location.hash === '#/objets') {
        console.log('🔄 Refreshing objects page due to state change');
        setTimeout(() => {
          this._forceObjectsRefresh = true;
          this.renderObjectsPage();
        }, 50);
      }
    },

    setupObjectSearchFunctionality() {
      // Setup ID search functionality
      const idSearchInput = document.getElementById('id-search-input');
      const clearButton = document.getElementById('clear-id-search');
      const resultDiv = document.getElementById('id-search-result');
      
      if (!idSearchInput) {
        return;
      }
      
      // Search function
      const performIdSearch = (searchValue) => {
        const objectsContainer = document.getElementById('objets-container');
        if (!objectsContainer) {
          return;
        }
        
        const allCards = objectsContainer.querySelectorAll('.card');
        let foundCard = null;
        
        if (!searchValue || searchValue.trim() === '') {
          // Show all cards when search is empty in dev mode, hide in normal mode
          const isDevMode = JdrApp.utils.isDevMode();
          allCards.forEach(card => {
            card.style.display = isDevMode ? 'block' : 'none';
          });
          window.activeIdSearch = false;
          if (resultDiv) {
            resultDiv.textContent = 'Entrez un numéro pour rechercher un objet spécifique';
          }
          return;
        }
        
        // Hide all cards first
        allCards.forEach(card => {
          card.style.display = 'none';
        });
        
        // Find and show matching card
        const searchNumber = parseInt(searchValue);
        if (!isNaN(searchNumber)) {
          allCards.forEach(card => {
            // Try multiple possible attribute names for the object number
            const cardNumero = card.getAttribute('data-numero') || 
                              card.getAttribute('data-object-numero') ||
                              card.getAttribute('data-objet-numero');
            
            if (cardNumero && parseInt(cardNumero) === searchNumber) {
              card.style.display = 'block';
              card.style.visibility = 'visible';
              foundCard = card;
              
              // Center the found object
              setTimeout(() => {
                card.scrollIntoView({ 
                  behavior: 'smooth', 
                  block: 'center', 
                  inline: 'center' 
                });
              }, 100);
            }
          });
        }
        
        window.activeIdSearch = true;
        
        // Update result text
        if (resultDiv) {
          if (foundCard) {
            const objectName = foundCard.querySelector('h4, .card-title')?.textContent || 'Objet trouvé';
            resultDiv.textContent = `✅ Objet trouvé: ${objectName}`;
            resultDiv.style.color = '#16a34a';
          } else {
            resultDiv.textContent = `❌ Aucun objet trouvé avec le numéro ${searchNumber}`;
            resultDiv.style.color = '#ef4444';
          }
        }
      };
      
      // Setup event listeners - Only search on Enter, not on input
      idSearchInput.addEventListener('keyup', (e) => {
        if (e.key === 'Enter') {
          performIdSearch(e.target.value);
        }
      });
      
      if (clearButton) {
        clearButton.addEventListener('click', () => {
          idSearchInput.value = '';
          performIdSearch('');
        });
      }
      
      // Setup tag filter functionality if available
      this.setupObjectTagFilters();
    },

    setupObjectTagFilters() {
      const filterChips = document.querySelectorAll('.filter-chip');
      const objectsContainer = document.getElementById('objets-container');
      
      if (!objectsContainer || filterChips.length === 0) return;
      
      filterChips.forEach(chip => {
        chip.addEventListener('click', (e) => {
          const tag = e.target.getAttribute('data-tag');
          if (!tag) return;
          
          const isActive = e.target.classList.contains('active');
          
          // Toggle the tag in global state
          if (!window.ACTIVE_OBJECT_TAGS) {
            window.ACTIVE_OBJECT_TAGS = [];
          }
          
          if (isActive) {
            // Remove tag
            window.ACTIVE_OBJECT_TAGS = window.ACTIVE_OBJECT_TAGS.filter(t => t !== tag);
          } else {
            // Add tag
            window.ACTIVE_OBJECT_TAGS.push(tag);
          }
          
          // Refresh the objects page to apply filters
          this._forceObjectsRefresh = true;
          this.renderObjectsPage();
        });
      });
    },

    renderGMObjectsPage() {
      if (!window.OBJETS) {
        console.error('OBJETS data not loaded');
        return false;
      }
      
      // Generate the GM objects page HTML
      const pageHTML = window.PageBuilder.buildGameMasterObjectPage(window.OBJETS);
      
      // Update only the specific article instead of wiping entire views container
      let gmObjectsArticle = document.querySelector('article[data-page="gestion-objets"]');
      if (!gmObjectsArticle) {
        // Create the article if it doesn't exist
        const viewsContainer = document.getElementById('views');
        if (viewsContainer) {
          viewsContainer.insertAdjacentHTML('beforeend', pageHTML);
          gmObjectsArticle = document.querySelector('article[data-page="gestion-objets"]');
        }
      } else {
        // Update existing article content
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = pageHTML;
        const newArticleContent = tempDiv.querySelector('article[data-page="gestion-objets"]');
        if (newArticleContent) {
          gmObjectsArticle.innerHTML = newArticleContent.innerHTML;
        }
      }
      
      if (gmObjectsArticle) {
        this.updateActiveStates('gestion-objets');
        this.setupGMObjectSearch();
        return true;
      }
      
      return false;
    },

    setupGMObjectSearch() {
      // Setup ID search for GM objects page
      const idSearchInput = document.getElementById('id-search-input');
      const searchButton = document.getElementById('search-object-btn');
      const clearButton = document.getElementById('clear-id-search');
      
      const performIdSearch = (searchId) => {
        const objectsContainer = document.getElementById('gestion-objets-container');
        if (!objectsContainer) return;
        
        const allCards = objectsContainer.querySelectorAll('.card');
        
        if (!searchId) {
          // Show all objects
          allCards.forEach(card => card.style.display = 'block');
          window.activeIdSearch = false;
          return;
        }
        
        // Hide all first
        allCards.forEach(card => card.style.display = 'none');
        
        // Find and show matching object
        const targetCard = Array.from(allCards).find(card => {
          const cardIdElement = card.querySelector('.object-id');
          return cardIdElement && cardIdElement.textContent.includes(`#${searchId}`);
        });
        
        if (targetCard) {
          targetCard.style.display = 'block';
          targetCard.style.gridColumn = '1 / -1';
          targetCard.style.justifySelf = 'center';
          window.activeIdSearch = true;
        } else {
          window.activeIdSearch = false;
        }
      };
      
      if (searchButton && idSearchInput) {
        searchButton.addEventListener('click', () => {
          const searchId = idSearchInput.value.trim();
          performIdSearch(searchId);
        });
        
        idSearchInput.addEventListener('keypress', (e) => {
          if (e.key === 'Enter') {
            const searchId = idSearchInput.value.trim();
            performIdSearch(searchId);
          }
        });
      }
      
      if (clearButton) {
        clearButton.addEventListener('click', () => {
          idSearchInput.value = '';
          performIdSearch('');
        });
      }
    },

    renderMonstersPage() {
      if (!window.MONSTRES) {
        console.error('MONSTRES data not loaded');
        return false;
      }
      
      // Generate the monsters page HTML
      const pageHTML = window.PageBuilder.buildSingleMonsterPage(window.MONSTRES);
      
      // Update only the specific article instead of wiping entire views container
      let monstersArticle = document.querySelector('article[data-page="monstres"]');
      if (!monstersArticle) {
        // Create the article if it doesn't exist
        const viewsContainer = document.getElementById('views');
        if (viewsContainer) {
          viewsContainer.insertAdjacentHTML('beforeend', pageHTML);
          monstersArticle = document.querySelector('article[data-page="monstres"]');
        }
      } else {
        // Update existing article content
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = pageHTML;
        const newArticleContent = tempDiv.querySelector('article[data-page="monstres"]');
        if (newArticleContent) {
          monstersArticle.innerHTML = newArticleContent.innerHTML;
        }
      }
      
      if (monstersArticle) {
        this.updateActiveStates('monstres');
        return true;
      }
      
      return false;
    },

    renderTablesTresorsPage() {
      if (!window.TABLES_TRESORS) {
        console.error('TABLES_TRESORS data not loaded');
        return false;
      }
      
      // Generate the tables page HTML
      const pageHTML = window.PageBuilder.buildSingleTableTresorPage(window.TABLES_TRESORS);
      
      // Update only the specific article instead of wiping entire views container
      let tablesArticle = document.querySelector('article[data-page="tables-tresors"]');
      if (!tablesArticle) {
        // Create the article if it doesn't exist
        const viewsContainer = document.getElementById('views');
        if (viewsContainer) {
          viewsContainer.insertAdjacentHTML('beforeend', pageHTML);
          tablesArticle = document.querySelector('article[data-page="tables-tresors"]');
        }
      } else {
        // Update existing article content
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = pageHTML;
        const newArticleContent = tempDiv.querySelector('article[data-page="tables-tresors"]');
        if (newArticleContent) {
          tablesArticle.innerHTML = newArticleContent.innerHTML;
        }
      }
      
      if (tablesArticle) {
        this.updateActiveStates('tables-tresors');
        return true;
      }
      
      return false;
    }
  
  };

})();

// ============================================================================
// JDR-BAB APPLICATION - RENDERER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // CONTENT RENDERER MODULE
  // ========================================
  JdrApp.modules.renderer = {
    currentSearch: '',
    
    init() {
      // Delay content generation to ensure all configurations are loaded
      setTimeout(() => {
        this.generateContent();
        this.autoLoadImages();
      }, 10);
      this.setupEventListeners();
    },

    setupEventListeners() {
      EventBus.on(Events.PAGE_RENDER, (payload) => {
        if (payload.type === 'category') {
          this.renderCategoryPage(payload.categoryType, payload.category);
        }
      });

      EventBus.on(Events.CONTENT_ADD, () => {
        setTimeout(() => this.autoLoadImages(), 100);
      });
    },

    generateContent() {
      JdrApp.modules.router.generateTOC.call(JdrApp.modules.router);
      this.generateArticles();
      this.generateDevToolbox();
      
      if (JdrApp.modules.editor) {
        setTimeout(() => {
          if (JdrApp.modules.editor.isDevMode) {
            JdrApp.modules.editor.forceShowAllEditButtons();
          } else {
            JdrApp.modules.editor.forceHideAllEditButtons();
          }
        }, 100);
      }
    },

    generateArticles() {
      const viewsContainer = document.querySelector('#views');
      if (!viewsContainer) return;

      // Use progressive rendering to avoid blocking the main thread
      this.progressiveRender([
        { fn: () => this.generateStaticPages(), name: 'static' },
        { fn: () => this.generateClassPages(), name: 'classes' },
        { fn: () => this.generateCategoryPages(), name: 'categories' },
        { fn: () => this.generateMonstersPage(), name: 'monsters' },
        { fn: () => this.generateGMObjectsPage(), name: 'gm-objects' }
      ], viewsContainer);
    },

    // Progressive rendering to avoid blocking the UI thread
    async progressiveRender(renderFunctions, container) {
      container.innerHTML = ''; // Clear first
      
      for (let i = 0; i < renderFunctions.length; i++) {
        const { fn, name } = renderFunctions[i];
        
        // Use requestAnimationFrame to yield to browser between renders
        await new Promise(resolve => {
          requestAnimationFrame(() => {
            try {
              const html = fn();
              if (html) {
                container.insertAdjacentHTML('beforeend', html);
              }
            } catch (error) {
              console.warn(`Error rendering ${name}:`, error);
            }
            resolve();
          });
        });
        
        // Yield every few operations to prevent blocking
        if (i % 2 === 0) {
          await new Promise(resolve => setTimeout(resolve, 5));
        }
      }

      // Post-render operations with improved batching
      requestAnimationFrame(() => {
        this.batchPostRenderOperations();
        
      });
    },

    // Batch post-render operations to reduce layout thrashing
    batchPostRenderOperations() {
      // Batch DOM reads first, then writes
      const hasDevMode = JdrApp.modules.editor && JdrApp.modules.editor.isDevMode;
      const hasEditor = JdrApp.modules.editor;
      const monstersContainer = document.getElementById('monsters-container');

      // Batch writes
      this.autoLoadImages();
      
      if (hasEditor) {
        this.applyDevModeToNewContent();
        
        if (hasEditor.attachImageEvents) {
          hasEditor.attachImageEvents();
        }
        
        if (hasDevMode) {
          setTimeout(() => hasEditor.createProxyButtons(), 50);
        }
        
        // Force image event attachment after a delay to catch lazy-loaded images
        setTimeout(() => {
          if (hasEditor.attachImageEvents) {
            hasEditor.attachImageEvents();
          }
        }, 1000);
      }
      
      if (monstersContainer) {
        setTimeout(() => this.populateMonstersPage(), 30);
      }

      // Setup object search functionality if we're on the objects page
      this.setupObjectSearchIfNeeded();
    },

    applyDevModeToNewContent() {
      if (JdrApp.modules.editor) {
        if (JdrApp.utils.isDevMode()) {
          JdrApp.modules.editor.forceShowAllEditButtons();
        } else {
          JdrApp.modules.editor.forceHideAllEditButtons();
        }
      }
    },


    generateStaticPages() {
      let html = '';
      if (window.STATIC_PAGES) {
        Object.entries(window.STATIC_PAGES).forEach(([pageId, pageData]) => {
          html += PageBuilder.buildStaticPage(pageId, pageData);
        });
      }
      return html;
    },


    generateClassPages() {
      if (!window.CLASSES) return '';
      
      return window.CLASSES.map(classe => 
        PageBuilder.buildClassPage(classe)
      ).join('');
    },

    generateCategoryPages() {
      let html = '';
      
      if (window.SORTS) {
        html += window.SORTS.map(category => 
          PageBuilder.buildCategoryPage('spell', category)
        ).join('');
      }

      if (window.DONS) {
        html += window.DONS.map(category => 
          PageBuilder.buildCategoryPage('don', category)
        ).join('');
      }

      // Generate single objects page (different from category pages)
      if (window.OBJETS) {
        html += PageBuilder.buildSingleObjectPage(window.OBJETS);
      }

      return html;
    },

    generateMonstersPage() {
      if (!window.MONSTRES) return '';
      
      return PageBuilder.buildSingleMonsterPage(window.MONSTRES);
    },

    generateGMObjectsPage() {
      if (!window.OBJETS) return '';
      
      return PageBuilder.buildGameMasterObjectPage(window.OBJETS);
    },


    renderCategoryPage(type, category) {
      const config = window.ContentTypes[type];
      
      // Handle special case for objects (single page, no category name)
      let pageId;
      if (type === 'objet') {
        pageId = 'objets'; // Objects use fixed page ID
      } else {
        pageId = `${config.container}-${JdrApp.utils.data.sanitizeId(category.nom)}`;
      }
      
      let article = document.querySelector(`article[data-page="${pageId}"]`);
      
      // Create article if it doesn't exist (for dynamically created categories)
      if (!article) {
        article = document.createElement('article');
        article.setAttribute('data-page', pageId);
        // DON'T make it active immediately - let the show() method handle this
        
        const viewsContainer = document.querySelector('#views');
        if (viewsContainer) {
          viewsContainer.appendChild(article);
        } else {
          // Views container not found
          return;
        }
      }
      
      const newContent = PageBuilder.buildCategoryPage(type, category);
      const parser = new DOMParser();
      const newDoc = parser.parseFromString(newContent, 'text/html');
      const newArticle = newDoc.querySelector('article');
      
      if (newArticle) {
        article.innerHTML = newArticle.innerHTML;
        
        // Make sure only this article is active
        document.querySelectorAll('article').forEach(a => a.classList.remove('active'));
        article.classList.add('active');
        
        // Plus simple et plus fiable
        this.autoLoadImages();
        
        // Attach image events for standalone compatibility
        if (JdrApp.modules.editor && JdrApp.modules.editor.attachImageEvents) {
          JdrApp.modules.editor.attachImageEvents();
        }
        
        // Ensure dev mode state is applied after content change
        setTimeout(() => {
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          } else if (window.STANDALONE_VERSION) {
            // FORCE STANDALONE MODE: Ensure dev-off class and hide all dev buttons
            document.body.className = 'dev-off';
          }
        }, 50);
      }
    },

    renderSortCategory(page) {
      const categoryId = page.replace('sorts-', '');
      const category = window.SORTS?.find(cat => 
        JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
      );
      
      if (category) {
        this.renderCategoryPage('spell', category);
      }
    },

    generateDevToolbox() {
      const devToolbox = JdrApp.utils.dom.$('#devToolbox');
      if (!devToolbox) return;

      const toolboxHTML = `
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--rule);">
          <span style="font-size: 18px;">🛠</span>
          <strong style="color: var(--accent-ink); font-family: 'Cinzel', serif;">Outils de développement</strong>
        </div>
        
        <div style="margin-bottom: 12px;">
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">✏️ Édition</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="saveAndExport" title="Sauvegarder et exporter tout en ZIP">💾 Export ZIP</button>
          </div>
        </div>
        
        <div style="margin-bottom: 12px;">
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">📝 Création</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="addCategory" title="Créer une nouvelle catégorie/page">📄 Nouvelle page</button>
            <button class="btn small" id="addSpellCategory" title="Créer une nouvelle catégorie de sorts">🔮 Catégorie de sorts</button>
            <button class="btn small" id="addDonCategory" title="Créer une nouvelle catégorie de dons">🎖️ Catégorie de dons</button>
          </div>
        </div>
        
      `;

      devToolbox.innerHTML = toolboxHTML;
    },

    autoLoadImages() {
      if (JdrApp.modules.images) {
        return JdrApp.modules.images.autoLoadImages();
      }
      return 0;
    },

    regenerateCurrentPage() {
      // Find the currently active article
      const activeArticle = document.querySelector('article.active');
      if (!activeArticle) return;

      const pageId = activeArticle.dataset.page;
      if (!pageId) return;

      // Determine what type of page it is and regenerate only that page
      if (pageId.startsWith('sorts-')) {
        const categoryId = pageId.replace('sorts-', '');
        const category = window.SORTS?.find(cat => 
          JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
        );
        if (category) {
          this.renderCategoryPage('spell', category);
        }
      } else if (pageId.startsWith('dons-')) {
        const categoryId = pageId.replace('dons-', '');
        const category = window.DONS?.find(cat => 
          JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
        );
        if (category) {
          this.renderCategoryPage('don', category);
        }
      } else if (pageId === 'objets') {
        // Regenerate objects page using the generic approach
        const newHTML = this.generatePageContent(pageId);
        if (newHTML) {
          activeArticle.innerHTML = newHTML;
          this.autoLoadImages();
          
          // Apply dev mode state immediately
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          } else if (window.STANDALONE_VERSION) {
            // FORCE STANDALONE MODE: Ensure dev-off class and hide all dev buttons
            document.body.className = 'dev-off';
          }
        }
      } else {
        // For class pages, static pages, etc. - regenerate the specific content
        const newHTML = this.generatePageContent(pageId);
        if (newHTML) {
          activeArticle.innerHTML = newHTML;
          this.autoLoadImages();
          
          // Apply dev mode state immediately
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          } else if (window.STANDALONE_VERSION) {
            // FORCE STANDALONE MODE: Ensure dev-off class and hide all dev buttons
            document.body.className = 'dev-off';
          }
        }
      }
    },

    generatePageContent(pageId) {
      // Generate content for a specific page without affecting navigation
      if (window.CLASSES) {
        const classe = window.CLASSES.find(c => JdrApp.utils.data.sanitizeId(c.nom) === pageId);
        if (classe) {
          const content = PageBuilder.buildClassPage(classe);
          const parser = new DOMParser();
          const doc = parser.parseFromString(content, 'text/html');
          const article = doc.querySelector('article');
          return article ? article.innerHTML : null;
        }
      }

      if (window.STATIC_PAGES && window.STATIC_PAGES[pageId]) {
        const content = PageBuilder.buildStaticPage(pageId, window.STATIC_PAGES[pageId]);
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        const article = doc.querySelector('article');
        return article ? article.innerHTML : null;
      }

      // Handle objects page
      if (pageId === 'objets' && window.OBJETS) {
        const content = PageBuilder.buildSingleObjectPage(window.OBJETS);
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        const article = doc.querySelector('article');
        return article ? article.innerHTML : null;
      }

      return null;
    },

    populateMonstersPage() {
      const monstersContainer = document.getElementById('monstres-container');
      if (!monstersContainer || !window.MONSTRES) return;

      // Clear existing content
      monstersContainer.innerHTML = '';

      // Generate monster cards directly
      const cardsHTML = window.MONSTRES.map((monster, index) => 
        CardBuilder.create('monster', monster, 'monstres', index).build()
      ).join('');
      
      monstersContainer.innerHTML = cardsHTML;

      // Apply dev mode styling and load images
      this.applyDevModeToNewContent();
      this.autoLoadImages();
    },

    renderUnifiedContentPage(contentType, data) {
      // This method dynamically creates a unified content page (like objets or monstres)
      // using the PageBuilder with the appropriate build method
      let content = '';
      let pageId = '';
      
      if (contentType === 'objet' && data) {
        content = PageBuilder.buildSingleObjectPage(data);
        pageId = 'objets';
      } else if (contentType === 'monster' && data) {
        content = PageBuilder.buildSingleMonsterPage(data);
        pageId = 'monstres';
      } else if (contentType === 'tableTresor' && data) {
        content = PageBuilder.buildSingleTableTresorPage(data);
        pageId = 'tables-tresors';
      }
      
      if (content && pageId) {
        // Find or create the specific article element in #views
        const viewsContainer = document.querySelector('#views');
        if (viewsContainer) {
          // Remove existing article for this page if it exists
          const existingArticle = document.querySelector(`article[data-page="${pageId}"]`);
          if (existingArticle) {
            existingArticle.remove();
          }
          
          // Add the new content to the views container
          viewsContainer.insertAdjacentHTML('beforeend', content);
          
          this.autoLoadImages();
          
          // Apply dev mode state with slight delay to ensure DOM is processed
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            setTimeout(() => {
              if (JdrApp.modules.editor.isDevMode) {
                JdrApp.modules.editor.forceShowAllEditButtons();
              } else {
                JdrApp.modules.editor.forceHideAllEditButtons();
              }
            }, 10);
          }
          
          // Setup object search specifically for objects page
          if (contentType === 'objet') {
            setTimeout(() => {
              this.setupObjectSearchIfNeeded();
            }, 100);
          }
        }
      }
    },

    setupObjectSearchIfNeeded() {
      // Check if we're on the objects page and the search input exists
      const idSearchInput = document.getElementById('id-search-input');
      const clearSearchButton = document.getElementById('clear-id-search');
      
      if (!idSearchInput) return; // Not on objects page or search not available

      // Remove any existing event listeners to avoid duplicates
      const newSearchInput = idSearchInput.cloneNode(true);
      idSearchInput.parentNode.replaceChild(newSearchInput, idSearchInput);
      
      // Add multiple event listeners to catch Enter key
      newSearchInput.addEventListener('keyup', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          e.stopPropagation();
          const searchId = e.target.value.trim();
          this.performIdSearch(searchId);
        }
      });
      
      newSearchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          e.stopPropagation();
          const searchId = e.target.value.trim();
          this.performIdSearch(searchId);
        }
      });
      
      newSearchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          e.stopPropagation();
          const searchId = e.target.value.trim();
          this.performIdSearch(searchId);
        }
      });

      // Setup search button
      const searchButton = document.getElementById('search-object-btn');
      if (searchButton) {
        const newSearchButton = searchButton.cloneNode(true);
        searchButton.parentNode.replaceChild(newSearchButton, searchButton);
        
        newSearchButton.addEventListener('click', () => {
          const searchId = newSearchInput.value.trim();
          this.performIdSearch(searchId);
        });
      }

      // Setup clear search button if it exists
      if (clearSearchButton) {
        const newClearButton = clearSearchButton.cloneNode(true);
        clearSearchButton.parentNode.replaceChild(newClearButton, clearSearchButton);
        
        newClearButton.addEventListener('click', () => {
          this.clearIdSearch();
        });
      }
    },

    performIdSearch(searchId) {
      const resultDiv = document.getElementById('id-search-result');
      const objectsContainer = document.getElementById('objets-container');
      const gmObjectsContainer = document.getElementById('gestion-objets-container');
      
      // Determine which container to use based on current page
      const activeContainer = objectsContainer || gmObjectsContainer;
      
      if (!searchId || !activeContainer) {
        if (resultDiv) resultDiv.textContent = '';
        return;
      }

      // Hide all objects first
      const allObjectCards = activeContainer.querySelectorAll('.card');
      allObjectCards.forEach(card => {
        card.style.display = 'none';
      });

      // Find object by ID (search in data-object-numero attribute)
      const targetCard = activeContainer.querySelector(`[data-object-numero="${searchId}"]`);
      
      if (targetCard) {
        // Show the found object and center it both visually and scroll-wise
        targetCard.style.display = 'block';
        
        // Add highlight effect
        targetCard.style.border = '3px solid #16a34a';
        targetCard.style.boxShadow = '0 0 15px rgba(22, 163, 74, 0.5)';
        
        // CENTER THE OBJECT VISUALLY IN THE GRID
        // When only one object is shown, center it horizontally in the grid
        const container = activeContainer;
        if (container) {
          // Temporarily change grid to center the single item
          const isDesktop = window.innerWidth > 768;
          if (isDesktop) {
            // On desktop: center the single card by spanning both columns
            targetCard.style.gridColumn = '1 / -1'; // Span all columns
            targetCard.style.justifySelf = 'center'; // Center within the span
            targetCard.style.maxWidth = '500px'; // Reasonable max width for single card
          } else {
            // On mobile: grid is already single column, just center it
            targetCard.style.justifySelf = 'center';
            targetCard.style.maxWidth = '100%';
          }
        }
        
        // Center the object on screen with scroll
        setTimeout(() => {
          // Use scrollIntoView for reliable centering
          targetCard.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center', 
            inline: 'center' 
          });
          
          // Additional fine-tuning for better positioning
          setTimeout(() => {
            const rect = targetCard.getBoundingClientRect();
            const viewportHeight = window.innerHeight;
            
            // Only adjust vertically to avoid horizontal scroll issues
            const cardCenterY = rect.top + (rect.height / 2);
            const viewportCenterY = viewportHeight / 2;
            const scrollAdjustY = cardCenterY - viewportCenterY;
            
            // Apply vertical scroll adjustment only
            window.scrollBy({
              top: scrollAdjustY,
              left: 0, // Don't adjust horizontal scroll
              behavior: 'smooth'
            });
          }, 300);
        }, 150);

        // Update search result message
        if (resultDiv) {
          const objectName = targetCard.getAttribute('data-objet-name') || 'Objet';
          resultDiv.innerHTML = `<span style="color: #16a34a;">✅ Objet #${searchId} trouvé: ${objectName}</span>`;
        }
        
        // Mark search as active
        window.activeIdSearch = true;
      } else {
        // No object found
        if (resultDiv) {
          resultDiv.innerHTML = `<span style="color: #dc2626;">❌ Aucun objet trouvé avec l'ID #${searchId}</span>`;
        }
        
        // Show all objects if nothing found
        allObjectCards.forEach(card => {
          card.style.display = 'block';
        });
      }
    },

    clearIdSearch() {
      const idSearchInput = document.getElementById('id-search-input');
      const resultDiv = document.getElementById('id-search-result');
      const objectsContainer = document.getElementById('objets-container');
      const gmObjectsContainer = document.getElementById('gestion-objets-container');
      
      // Clear search input
      if (idSearchInput) {
        idSearchInput.value = '';
      }
      
      // Clear result message
      if (resultDiv) {
        resultDiv.textContent = '';
      }
      
      // Show all objects and remove highlights for both containers
      [objectsContainer, gmObjectsContainer].forEach(container => {
        if (container) {
          const allObjectCards = container.querySelectorAll('.card');
          allObjectCards.forEach(card => {
            // For regular objects page, keep objects hidden by default
            // For GM objects page, show all objects
            if (container.id === 'objets-container') {
              card.style.display = 'none'; // Regular page: hide all
            } else if (container.id === 'gestion-objets-container') {
              card.style.display = 'block'; // GM page: show all
            }
            // Remove highlight effects and grid centering styles
            card.style.border = '';
            card.style.boxShadow = '';
            card.style.gridColumn = ''; // Reset grid column span
            card.style.justifySelf = ''; // Reset justify
            card.style.maxWidth = ''; // Reset max width
          });
        }
      });
      
      // Mark search as inactive
      window.activeIdSearch = false;
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - UNIFIED EDITOR SYSTEM
// ============================================================================

(() => {
  "use strict";

  class UnifiedEditor {
    constructor() {
      this.currentEditSession = null;
    }

    /*
     * IMPORTANT: Content Restoration Best Practices
     * =============================================
     * ALWAYS use restoreElementContent() for any content that has been edited
     * NEVER directly assign to innerHTML in editing contexts
     * This prevents HTML tags from being displayed as visible text
     */

    static getInstance() {
      if (!UnifiedEditor.instance) {
        UnifiedEditor.instance = new UnifiedEditor();
      }
      return UnifiedEditor.instance;
    }

    // Parse edit context from DOM element
    parseEditContext(element) {
      // Force reset any stuck elements FIRST
      this.forceResetAllEditingElements();
      
      const editableElement = element.classList.contains('editable-section') 
        ? element.querySelector('.editable') 
        : element;

      if (!editableElement) {
        return null;
      }

      const editType = editableElement.dataset.editType;
      const editSection = editableElement.dataset.editSection;
      
      // For simplified HTML editing, everything is treated as HTML content
      if (editType === 'html') {
        return this.parseHtmlEditContext(element, editSection);
      }
      
      // Generic editing - use contextual detection, don't force type
      if (editType === 'generic') {
        // Use the full parsing logic and keep the detected contentType
        return this.parseHtmlEditContext(element, editSection);
      }

      // Tags editing for objects
      if (editType === 'tags') {
        return this.parseTagsEditContext(element, editSection);
      }

      // Select element editing (for dropdowns like monster elements)
      if (editType === 'select') {
        return this.parseSelectEditContext(element, editSection);
      }

      // All legacy edit types have been migrated to 'generic'
      return null;
    }

    parseHtmlEditContext(element, editSection) {
      // Detect context automatically based on page structure
      // Order matters: check most specific first (spells, dons, classes, then static pages)
      
      // Check if we're in a spell card first (most specific)
      const spellCard = element.closest('.card[data-spell-name]');
      if (spellCard) {
        const spellName = spellCard.dataset.spellName;
        const spellIndex = spellCard.dataset.spellIndex;
        const categoryName = spellCard.dataset.categoryName;
        
        // Use class-based detection for spell sections to avoid index mismatches
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        // Detect the spell property from the element's classes or data attributes
        let spellEditSection = 'description'; // default fallback
        
        // Check for specific section classes to determine the property
        if (editableElement.classList.contains('spell-name') || editableElement.dataset.editSection === 'spell-name') {
          spellEditSection = 'nom';
        } else if (editableElement.classList.contains('spell-description') || editableElement.dataset.editSection === 'spell-description') {
          spellEditSection = 'description';
        } else if (editableElement.classList.contains('spell-prerequis') || editableElement.dataset.editSection === 'spell-prerequis') {
          spellEditSection = 'prerequis';
        } else if (editableElement.classList.contains('spell-portee') || editableElement.dataset.editSection === 'spell-portee') {
          spellEditSection = 'portee';
        } else if (editableElement.classList.contains('spell-mana') || editableElement.dataset.editSection === 'spell-mana') {
          spellEditSection = 'coutMana';
        } else if (editableElement.classList.contains('spell-temps-incantation') || editableElement.dataset.editSection === 'spell-temps-incantation') {
          spellEditSection = 'tempsIncantation';
        } else if (editableElement.classList.contains('spell-resistance') || editableElement.dataset.editSection === 'spell-resistance') {
          spellEditSection = 'resistance';
        } else if (editableElement.classList.contains('spell-effect-normal') || editableElement.dataset.editSection === 'spell-effect-normal') {
          spellEditSection = 'effetNormal';
        } else if (editableElement.classList.contains('spell-effect-critical') || editableElement.dataset.editSection === 'spell-effect-critical') {
          spellEditSection = 'effetCritique';
        }
        
        return {
          contentType: 'spell',
          itemIdentifier: spellName,
          itemIndex: spellIndex,
          categoryName: categoryName,
          property: 'html',
          editType: 'html',
          editSection: spellEditSection,
          config: window.ContentTypes.spell,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a don card
      const donCard = element.closest('.card[data-don-name]');
      if (donCard) {
        const donName = donCard.dataset.donName;
        const donIndex = donCard.dataset.donIndex;
        const categoryName = donCard.dataset.categoryName;
        
        // Use index-based detection for don sections
        const allEditables = Array.from(donCard.querySelectorAll('.editable'));
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const currentIndex = allEditables.indexOf(editableElement);
        
        // Map index to don property based on CardBuilder order
        // 0=nom, 1=description, 2=prerequis, 3=cout
        const donSections = ['nom', 'description', 'prerequis', 'cout'];
        const donEditSection = donSections[currentIndex] || 'description';
        
        return {
          contentType: 'don',
          itemIdentifier: donName,
          itemIndex: donIndex,
          categoryName: categoryName,
          property: 'html',
          editType: 'html',
          editSection: donEditSection,
          config: window.ContentTypes.don,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in an objet card
      const objetCard = element.closest('.card[data-objet-name]');
      if (objetCard) {
        const objetName = objetCard.dataset.objetName;
        const categoryName = objetCard.dataset.categoryName;
        
        // Use index-based detection for objet sections
        const allEditables = Array.from(objetCard.querySelectorAll('.editable'));
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const currentIndex = allEditables.indexOf(editableElement);
        
        // Map index to objet property based on CardBuilder order
        // 0=nom, 1=numero, 2=tags, 3=description, 4=effet, 5=prix, 6=poids
        const objetSections = ['nom', 'numero', 'tags', 'description', 'effet', 'prix', 'poids'];
        const objetEditSection = objetSections[currentIndex] || 'description';
        
        return {
          contentType: 'objet',
          itemIdentifier: objetName,
          categoryName: categoryName,
          property: 'html',
          editType: 'html',
          editSection: objetEditSection,
          config: window.ContentTypes.objet,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        // Use data-item-identifier if available, otherwise fall back to monsterName
        const itemIdentifier = editableElement?.dataset?.itemIdentifier || monsterName;
        
        // Use editSection directly (new format: "monster-fieldName")
        const editSection = editableElement?.dataset?.editSection || 'abilites';
        
        return {
          contentType: 'monster',
          itemIdentifier: itemIdentifier,
          categoryName: categoryName || 'monstres',
          property: 'html',
          editType: 'html', 
          editSection: editSection,
          config: window.ContentTypes.monster,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a table-tresor card
      const tableTresorCard = element.closest('.card[data-table-tresor-name]');
      if (tableTresorCard) {
        const tableName = tableTresorCard.dataset.tableTresorName;
        const categoryName = tableTresorCard.dataset.categoryName;
        
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        // Use data-item-identifier if available, otherwise fall back to tableName
        const itemIdentifier = editableElement?.dataset?.itemIdentifier || tableName;
        
        // Use editSection directly (new format: "table-tresor-fieldName")
        const editSection = editableElement?.dataset?.editSection || 'description';
        
        return {
          contentType: 'tableTresor',
          itemIdentifier: itemIdentifier,
          categoryName: categoryName || 'tables',
          property: 'html',
          editType: 'html', 
          editSection: editSection,
          config: window.ContentTypes.tableTresor,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a class page (before static pages!)
      // IMPORTANT: Exclude static pages even if they have data-page-title
      const classArticle = element.closest('article[data-page-title]:not([data-static-page="true"])');
      if (classArticle) {
        const className = classArticle.dataset.pageTitle;
        
        // Check if we're editing a subclass (look for subclass card)
        const subclassCard = element.closest('.card[data-subclass-name]');
        if (subclassCard) {
          // Determine what part of the subclass we're editing
          let subclassEditSection = 'content';
          
          const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
          
          if (editableElement) {
            const parentSection = editableElement.closest('.editable-section');
            
            // Use index-based detection for subclasses
            const subclassCard = editableElement.closest('.card[data-subclass-name]');
            const allEditables = subclassCard ? Array.from(subclassCard.querySelectorAll('.editable')) : [];
            const currentIndex = allEditables.indexOf(editableElement);
            
            // Map index to property based on subclass structure  
            // UPDATED ORDER: Index 0 = nom (title), Index 1 = description, Index 2 = base (stats), Index 3 = progression, Index 4+ = capacites
            if (element.closest('.stats-grid') || currentIndex === 2) {
              subclassEditSection = 'base';
            } else if (currentIndex === 0) {
              subclassEditSection = 'nom';
            } else if (currentIndex === 1) {
              subclassEditSection = 'description';
            } else if (currentIndex === 3) {
              subclassEditSection = 'progression';  
            } else if (currentIndex >= 4) {
              subclassEditSection = 'capacites';
            }
          }
          
          return {
            contentType: 'subclass',
            itemIdentifier: subclassCard.dataset.subclassName,
            categoryName: className,
            property: 'html',
            editType: 'html',
            editSection: subclassEditSection,
            config: window.ContentTypes.subclass,
            element: element.classList.contains('editable-section') ? element.querySelector('.editable') : element,
            container: element
          };
        }
        
        // Otherwise it's a class - determine what part of the class we're editing
        let classEditSection = 'content';
        
        // More specific detection based on parent elements and content
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        if (editableElement) {
          const parentCard = editableElement.closest('.card');
          const parentSection = editableElement.closest('.editable-section');
          
          // Use index-based detection instead of content analysis
          const classArticle = editableElement.closest('article[data-page-title]');
          const allEditables = classArticle ? Array.from(classArticle.querySelectorAll('.editable')) : [];
          const currentIndex = allEditables.indexOf(editableElement);
          
          // Map index to property based on class structure
          // Index 0 = resume (first editable in class)
          // Index 1+ = capacites (subsequent editables are class capabilities)
          if (currentIndex === 0) {
            classEditSection = 'resume';
          } else if (currentIndex >= 1) {
            classEditSection = 'capacites';
          }
        }
        
        return {
          contentType: 'class',
          itemIdentifier: className,
          categoryName: null,
          property: 'html',
          editType: 'html',
          editSection: classEditSection,
          config: window.ContentTypes.class,
          element: element.classList.contains('editable-section') ? element.querySelector('.editable') : element,
          container: element
        };
      }
      
      // Check if we're editing a page description (unified system)
      const pageDescSection = element.closest('.editable-section[data-section-type*="-category-description"], .editable-section[data-section-type="pageDescription"]');
      if (pageDescSection) {
        const sectionType = pageDescSection.dataset.sectionType;
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const editSection = editableElement ? editableElement.dataset.editSection : '';
        
        let contentType;
        
        // Handle different types of page descriptions
        if (sectionType === 'pageDescription') {
          // For generic page descriptions, get the content type from the editable element
          const pageType = editableElement?.dataset?.pageType;
          contentType = pageType || 'collections'; // fallback to collections
        } else {
          // Extract content type from section type (e.g., "objet-category-description" -> "objet")
          contentType = sectionType.replace('-category-description', '');
        }
        
        // Use unified page description system via ContentFactory
        return {
          contentType: 'pageDescription',
          pageType: contentType, // The actual content type (spell, don, objet, collections, etc.)
          itemIdentifier: contentType,
          categoryName: null,
          property: 'description',
          editType: 'html',
          editSection: editSection,
          element: editableElement,
          container: element,
          applyEdit: (content) => {
            const success = ContentFactory.updatePageDescription(contentType, content);
            if (!success) {
              console.error(`❌ Failed to update page description for ${contentType}`);
            }
            return success;
          }
        };
      }
        
      // Check if we're editing a category description (spell/don category pages - fallback for old system)
      const categorySection = element.closest('.editable-section');
      if (categorySection && categorySection.dataset.sectionType && categorySection.dataset.sectionType.includes('category-description')) {
        const sectionType = categorySection.dataset.sectionType;
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const editSection = editableElement ? editableElement.dataset.editSection : '';
        
        // Extract content type from section type
        const contentType = sectionType.replace('-category-description', '');
        
        return {
          contentType: 'category',
          itemIdentifier: editSection, // This is the category name
          categoryName: editSection,
          property: 'description',
          editType: 'html',
          editSection: 'description',
          categoryType: contentType,
          config: window.ContentTypes[contentType],
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're editing campaign or sub-page content (specific handling before static page fallback)
      const campaignArticle = element.closest('article[data-static-page="true"]');
      if (campaignArticle && campaignArticle.dataset.page === 'campagne') {
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const editSection = editableElement?.dataset?.editSection || '';
        
        // Handle campaign-specific edit sections
        if (editSection.startsWith('campaign-')) {
          // Parse campaign edit section: campaign-{campaignName}-{property}
          const parts = editSection.split('-');
          if (parts.length >= 3) {
            const campaignName = parts.slice(1, -1).join('-'); // Handle campaign names with hyphens
            const property = parts[parts.length - 1]; // last part is the property
            
            return {
              contentType: 'campaign',
              itemIdentifier: campaignName,
              categoryName: null,
              property: 'html',
              editType: 'html',
              editSection: property, // 'name' or 'description'
              config: window.ContentTypes.campaign,
              element: editableElement,
              container: element,
              applyEdit: (content) => {
                return this.updateCampaignData('campaign', campaignName, property, content);
              }
            };
          }
        } else if (editSection.startsWith('subpage-')) {
          // Parse sub-page edit section: subpage-{campaignName}-{subPageName}-{property}
          const parts = editSection.split('-');
          if (parts.length >= 4) {
            const campaignName = parts[1];
            const subPageName = parts.slice(2, -1).join('-'); // Handle sub-page names with hyphens
            const property = parts[parts.length - 1]; // last part is the property
            
            return {
              contentType: 'campaignSubPage',
              itemIdentifier: `${campaignName}:${subPageName}`,
              categoryName: campaignName,
              property: 'html',
              editType: 'html',
              editSection: property, // 'title' or 'content'
              config: window.ContentTypes.campaignSubPage,
              element: editableElement,
              container: element,
              applyEdit: (content) => {
                return this.updateCampaignData('subpage', campaignName, property, content, subPageName);
              }
            };
          }
        }
      }
      
      // Check if we're in a static page (LAST, as fallback)
      // Now we include ALL static pages, regardless of data-page-title
      const staticPageArticle = element.closest('article[data-static-page="true"]');
      if (staticPageArticle) {
        const pageName = staticPageArticle.dataset.page;
        
        // Enhanced page detection with ID-based fallback
        let actualPageName = pageName;
        const elementEditSection = element.dataset?.editSection || 'none';
        
        // If the element's edit section contains a page prefix, use that instead
        if (elementEditSection !== 'none' && elementEditSection.includes('-')) {
          const possiblePageId = elementEditSection.split('-')[0];
          // Check if this matches a known static page
          if (window.STATIC_PAGES && window.STATIC_PAGES[possiblePageId]) {
            actualPageName = possiblePageId;
          }
        }
        
        // Use the corrected page name
        const finalPageName = actualPageName;
        
        // Use index-based detection for static page sections
        const allEditables = Array.from(staticPageArticle.querySelectorAll('.editable'));
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const currentIndex = allEditables.indexOf(editableElement);
        
        // For static pages, use the actual edit section from the element's data attribute
        const actualEditSection = elementEditSection !== 'none' ? elementEditSection : `section-${currentIndex}`;
        
        return {
          contentType: 'staticPage',
          itemIdentifier: finalPageName,  // Use corrected page name
          categoryName: null,
          property: 'html',
          editType: 'html',
          editSection: actualEditSection,  // Use actual edit section ID
          config: window.ContentTypes.staticPage,
          element: editableElement,
          container: element
        };
      }
      
      // Default fallback
      return {
        contentType: 'unknown',
        itemIdentifier: editSection || 'content',
        categoryName: null,
        property: 'html',
        editType: 'html',
        editSection,
        config: { fields: {} },
        element: element.classList.contains('editable-section') ? element.querySelector('.editable') : element,
        container: element
      };
    }

    parseTagsEditContext(element, editSection) {
      // Check if we're in an object card
      const objetCard = element.closest('.card[data-objet-name]');
      if (objetCard) {
        const objetName = objetCard.dataset.objetName;
        const categoryName = objetCard.dataset.categoryName;
        
        return {
          contentType: 'objet',
          itemIdentifier: objetName,
          categoryName: categoryName,
          property: 'tags',
          editType: 'tags',
          editSection: editSection,
          config: window.ContentTypes.objet,
          element: element.classList.contains('editable') ? element : element.querySelector('.editable'),
          container: element
        };
      }
      
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        return {
          contentType: 'monster',
          itemIdentifier: monsterName,
          categoryName: categoryName || 'monstres',
          property: 'tags',
          editType: 'tags',
          editSection: editSection,
          config: window.ContentTypes.monster,
          element: element.classList.contains('editable') ? element : element.querySelector('.editable'),
          container: element
        };
      }
      
      return null;
    }

    parseSelectEditContext(element, editSection) {
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        return {
          contentType: 'monster',
          itemIdentifier: monsterName,
          categoryName: categoryName || 'monstres',
          property: 'element',
          editType: 'select',
          editSection: editSection,
          config: window.ContentTypes.monster,
          element: element,
          container: element.closest('.monster-element-section')
        };
      }
      
      // Check if we're in a spell card
      const spellCard = element.closest('.card[data-spell-name]');
      if (spellCard) {
        const spellName = spellCard.dataset.spellName;
        const spellIndex = spellCard.dataset.spellIndex;
        const categoryName = spellCard.dataset.categoryName;
        
        return {
          contentType: 'spell',
          itemIdentifier: spellName,
          itemIndex: spellIndex,
          categoryName: categoryName,
          property: 'element',
          editType: 'select',
          editSection: editSection,
          config: window.ContentTypes.spell,
          element: element,
          container: element.closest('.spell-element-section')
        };
      }
      
      return null;
    }

    makeElementEditable(editableElement, container) {
      const originalHtml = editableElement.innerHTML;
      container.dataset.originalContent = originalHtml;
      container.dataset.editing = 'true';

      // Decode any encoded HTML before showing for editing
      const decodedHtml = this.decodeHtmlEntities(originalHtml);
      editableElement.innerHTML = decodedHtml;
      editableElement.contentEditable = true;
      editableElement.style.cssText += `
        background-color: rgba(255, 255, 0, 0.1);
        border: 1px dashed var(--bronze);
        border-radius: 4px;
        padding: 4px;
        font-family: monospace;
        white-space: pre-wrap;
      `;

      // Add editing controls toolbar
      this.addEditingControls(container, editableElement);

      editableElement.focus();

      const range = document.createRange();
      range.selectNodeContents(editableElement);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
    }

    makeTagsEditable(editableElement, container) {
      
      const originalHtml = editableElement.innerHTML;
      container.dataset.originalContent = originalHtml;
      container.dataset.editing = 'true';

      // Get current tags from the object
      const objetName = this.currentEditSession.itemIdentifier;
      
      const objet = window.OBJETS?.objets?.find(obj => obj.nom === objetName);
      
      const currentTags = objet?.tags || [];
      const availableTags = window.ContentTypes.objet.filterConfig.availableTags;

      // Create and show modal instead of inline editor
      this.showTagsModal(objetName, currentTags, availableTags);
    }

    showTagsModal(objetName, currentTags, availableTags) {
      // Remove any existing tags modal
      const existingModal = document.querySelector('#tagsEditModal');
      if (existingModal) {
        existingModal.remove();
      }

      // Use native HTML5 dialog element for proper z-index handling
      const modal = document.createElement('dialog');
      modal.id = 'tagsEditModal';
      modal.style.cssText = `
        max-width: 500px !important;
        width: 90% !important;
        padding: 0 !important;
        border: none !important;
        border-radius: 12px !important;
        background: transparent !important;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5) !important;
      `;

      const checkboxesHTML = availableTags.map(tag => `
        <div style="display: flex; align-items: center; gap: 0.5rem; margin: 0.5rem 0; padding: 0.5rem; background: #f5f5f5; border-radius: 8px;">
          <input 
            type="checkbox" 
            id="modal-tag-${tag}" 
            value="${tag}" 
            ${currentTags.includes(tag) ? 'checked' : ''}
            style="margin: 0;"
          >
          <label for="modal-tag-${tag}" style="flex: 1; cursor: pointer; font-weight: 500;">
            <span style="background: #8B4513; color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 0.5rem;">${tag}</span>
            ${tag}
          </label>
        </div>
      `).join('');

      modal.innerHTML = `
        <div style="
          background: white; 
          border-radius: 12px; 
          padding: 1.5rem; 
          border: 3px solid #8B4513;
          font-family: inherit;
          font-size: 16px;
          color: #333;
        ">
          <h3 style="margin: 0 0 1rem 0; color: #8B4513; font-size: 1.2em;">🏷️ Éditer les tags de "${objetName}"</h3>
          <p style="margin: 0 0 1rem 0; color: #666; font-size: 0.9em;">Sélectionnez les tags à assigner à cet objet :</p>
          
          <div id="tagsCheckboxes" style="margin: 1rem 0;">
            ${checkboxesHTML}
          </div>
          
          <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem;">
            <button type="button" class="btn-cancel-tags-modal" style="
              background: #666; 
              color: white; 
              border: none; 
              padding: 8px 16px; 
              border-radius: 6px; 
              cursor: pointer;
              font-weight: 500;
              font-size: 14px;
            ">
              ❌ Annuler
            </button>
            <button type="button" class="btn-save-tags-modal" style="
              background: #8B4513; 
              color: white; 
              border: none; 
              padding: 8px 16px; 
              border-radius: 6px; 
              cursor: pointer;
              font-weight: 500;
              font-size: 14px;
            ">
              💾 Sauvegarder
            </button>
          </div>
        </div>
      `;

      // Append to body and show modal using native dialog API
      document.body.appendChild(modal);

      // Use showModal() for proper top-level display
      try {
        modal.showModal();
      } catch (error) {
        console.error('Error calling showModal():', error);
      }

      // Set up event handlers
      modal.querySelector('.btn-save-tags-modal').addEventListener('click', () => {
        this.saveTagsFromModal(modal);
      });

      modal.querySelector('.btn-cancel-tags-modal').addEventListener('click', () => {
        this.cancelTagsModal(modal);
      });

      // Native dialog handles backdrop clicks and ESC automatically
      modal.addEventListener('cancel', (e) => {
        this.cancelTagsModal(modal);
      });

      // Close on backdrop click (for dialog elements)
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.cancelTagsModal(modal);
        }
      });
    }

    saveTagsFromModal(modal) {
      if (!this.currentEditSession) return false;

      const checkboxes = modal.querySelectorAll('input[type="checkbox"]:checked');
      const selectedTags = Array.from(checkboxes).map(cb => cb.value);

      if (selectedTags.length === 0) {
        alert('Veuillez sélectionner au moins un tag');
        return false;
      }

      // Update data based on content type
      const itemName = this.currentEditSession.itemIdentifier;
      let targetItem = null;
      
      if (this.currentEditSession.contentType === 'objet') {
        // Update the object data
        targetItem = window.OBJETS?.objets?.find(obj => obj.nom === itemName);
      } else if (this.currentEditSession.contentType === 'monster') {
        // Update the monster data
        targetItem = window.MONSTRES?.find(monster => monster.nom === itemName);
      } else if (this.currentEditSession.contentType === 'tableTresor') {
        // Update the table tresor data
        targetItem = window.TABLES_TRESORS?.tables?.find(table => table.nom === itemName);
      }
      
      if (targetItem) {
        targetItem.tags = selectedTags;
        
        // Update the display
        const tagsDisplay = selectedTags.map(tag => 
          `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`
        ).join('');
        
        // Restore the element and update its content
        this.resetEditingState(this.currentEditSession.container);
        this.restoreElementContent(this.currentEditSession, tagsDisplay);
        
        // Save to storage
        EventBus.emit(Events.STORAGE_SAVE);
        
        // Close modal and clear edit session
        modal.close();
        modal.remove();
        this.currentEditSession = null;
        
        // Show success notification
        JdrApp.modules.ui.showNotification(`🏷️ Tags mis à jour : ${selectedTags.join(', ')}`, 'success');
        
        return true;
      }
      
      return false;
    }

    cancelTagsModal(modal) {
      // Close modal without saving
      modal.close();
      modal.remove();
      
      // Cancel the edit session
      this.cancelCurrentEdit();
    }

    // Save current editing session
    saveCurrentEdit() {
      if (!this.currentEditSession) return false;

      const session = this.currentEditSession;
      // Get the edited HTML content from innerHTML (user edited the rendered content)
      const newContent = session.element.innerHTML.trim();
      const normalizedContent = this.normalizeHTMLContent(newContent);

      // Reset editing state first to avoid interfering with content restoration
      this.resetEditingState(session.container);

      if (normalizedContent !== session.originalContent) {
        const success = this.saveContent(session, normalizedContent);
        if (success) {
          // Convert back from text to rendered HTML
          this.restoreElementContent(session, normalizedContent);
          
          EventBus.emit(Events.CONTENT_UPDATE, {
            contentType: session.contentType,
            itemIdentifier: session.itemIdentifier,
            property: session.property,
            value: normalizedContent
          });
        } else {
          // If save failed, restore original content
          this.restoreElementContent(session, session.originalContent);
        }
      } else {
        // Even if no changes, restore HTML rendering
        this.restoreElementContent(session, session.originalContent);
      }

      this.currentEditSession = null;
      return true;
    }

    // Update content in data structure - unified method for all content types
    updateContentInDataStructure(session, content) {
      try {
        switch (session.contentType) {
          case 'spell':
            return this.updateSpellData(session, content);
          case 'don':
            return this.updateDonData(session, content);
          case 'objet':
            return this.updateObjetData(session, content);
          case 'monster':
            return this.updateMonsterData(session, content);
          case 'category':
            return this.updateCategoryData(session, content);
          case 'subclass':
            return this.updateSubclassData(session, content);
          case 'class':
            return this.updateClassData(session, content);
          case 'staticPage':
            return this.updateStaticPageData(session, content);
          case 'tableTresor':
            return this.updateTableTresorData(session, content);
          case 'pageDescription':
            return this.updatePageDescriptionData(session, content);
          case 'campaign':
            return session.applyEdit(content);
          case 'campaignSubPage':
            return session.applyEdit(content);
          default:
            console.error('Unknown content type for update:', session.contentType);
            return false;
        }
      } catch (error) {
        console.error('Error updating content:', error, session);
        return false;
      }
    }

    // Update spell data
    updateSpellData(session, content) {
      const category = window.SORTS?.find(cat => cat.nom === session.categoryName);
      if (!category) return false;
      
      const spell = category.sorts?.find(s => s.nom === session.itemIdentifier);
      if (!spell) return false;
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.spell;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // If we're updating the name, we need to update the container's data-spell-name attribute
      if (propertyName === 'nom') {
        const oldName = spell.nom;
        spell[propertyName] = content;
        
        // Update the data-spell-name attribute on the card container
        const spellCard = session.container.closest('.card[data-spell-name]');
        if (spellCard && spellCard.dataset.spellName === oldName) {
          spellCard.dataset.spellName = content;
        }
      } else {
        spell[propertyName] = content;
      }
      
      return true;
    }

    // Update don data
    updateDonData(session, content) {
      const category = window.DONS?.find(cat => cat.nom === session.categoryName);
      if (!category) return false;
      
      const don = category.dons?.find(d => d.nom === session.itemIdentifier);
      if (!don) return false;
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.don;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // If we're updating the name, we need to update the container's data-don-name attribute
      if (propertyName === 'nom') {
        const oldName = don.nom;
        don[propertyName] = content;
        
        // Update the data-don-name attribute on the card container
        const donCard = session.container.closest('.card[data-don-name]');
        if (donCard && donCard.dataset.donName === oldName) {
          donCard.dataset.donName = content;
        }
      } else {
        don[propertyName] = content;
      }
      
      return true;
    }

    // Update objet data
    updateObjetData(session, content) {
      const objet = window.OBJETS?.objets?.find(o => o.nom === session.itemIdentifier);
      if (!objet) return false;
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.objet;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // If we're updating the name, we need to update the container's data-objet-name attribute
      if (propertyName === 'nom') {
        const oldName = objet.nom;
        objet[propertyName] = content;
        
        // Update the data-objet-name attribute on the card container
        const objetCard = session.container.closest('.card[data-objet-name]');
        if (objetCard && objetCard.dataset.objetName === oldName) {
          objetCard.dataset.objetName = content;
        }
      } else {
        objet[propertyName] = content;
      }
      
      return true;
    }

    // Update monster data
    updateMonsterData(session, content) {
      const monster = window.MONSTRES?.find(m => m.nom === session.itemIdentifier);
      if (!monster) {
        console.error('Monster not found:', session.itemIdentifier, 'Available monsters:', window.MONSTRES?.map(m => m.nom));
        return false;
      }
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.monster;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // Backup current value for rollback capability
      const originalValue = monster[propertyName];
      
      try {
        // If we're updating the name, we need to update the container's data-monster-name attribute
        if (propertyName === 'nom') {
          const oldName = monster.nom;
          monster[propertyName] = content;
          
          // Update the data-monster-name attribute on the card container
          const monsterCard = session.container.closest('.card[data-monster-name]');
          if (monsterCard && monsterCard.dataset.monsterName === oldName) {
            monsterCard.dataset.monsterName = content;
          }
        } else {
          // Update the monster property
          monster[propertyName] = content;
        }
        
        // Force synchronization using ContentFactory to prevent data reversion
        const contentFactory = window.ContentFactory?.getInstance ? window.ContentFactory.getInstance() : null;
        if (contentFactory && contentFactory.updateItem) {
          // Use ContentFactory to ensure proper data synchronization
          contentFactory.updateItem('monster', null, monster.nom, propertyName, content);
        }
        
        // Additional safety: ensure image mapping is maintained
        if (propertyName === 'image' && JdrApp.modules.images) {
          const imageKey = `monster:${monster.nom}`;
          JdrApp.modules.images.setImage(imageKey, content);
        }
        
        // Create backup for crash recovery
        this.createMonsterBackup(monster);
        
        return true;
        
      } catch (error) {
        // Rollback on error
        console.error('❌ Error updating monster, rolling back:', error);
        monster[propertyName] = originalValue;
        return false;
      }
    }

    // Update table tresor data
    updateTableTresorData(session, content) {
      const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === session.itemIdentifier);
      if (!table) {
        console.error('Table tresor not found:', session.itemIdentifier, 'Available tables:', window.TABLES_TRESORS?.tables?.map(t => t.nom));
        return false;
      }
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.tableTresor;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // Backup current value for rollback capability
      const originalValue = table[propertyName];
      
      try {
        // If we're updating the name, we need to update the container's data-table-tresor-name attribute
        if (propertyName === 'nom') {
          const oldName = table.nom;
          table[propertyName] = content;
          
          // Update the data-table-tresor-name attribute on the card container
          const tableTresorCard = session.container.closest('.card[data-table-tresor-name]');
          if (tableTresorCard && tableTresorCard.dataset.tableTresorName === oldName) {
            tableTresorCard.dataset.tableTresorName = content;
            
            // Also update the button that uses the table name
            const addFourchetteBtn = tableTresorCard.querySelector('.table-tresor-add-fourchette');
            if (addFourchetteBtn && addFourchetteBtn.dataset.tableTresorName === oldName) {
              addFourchetteBtn.dataset.tableTresorName = content;
            }
          }
          
          // If we're updating the name, we need to update the session itemIdentifier
          // to prevent future saves from failing with the old name
          if (this.currentEditSession && this.currentEditSession.itemIdentifier === originalValue) {
            this.currentEditSession.itemIdentifier = content;
          }
        } else {
          // Update the table property
          table[propertyName] = content;
        }
        
        // Force synchronization using ContentFactory to prevent data reversion
        const contentFactory = window.ContentFactory?.getInstance ? window.ContentFactory.getInstance() : null;
        if (contentFactory && contentFactory.updateItem) {
          // Use ContentFactory to ensure proper data synchronization
          contentFactory.updateItem('tableTresor', 'tables', table.nom, propertyName, content);
        }
        
        return true;
        
      } catch (error) {
        // Rollback on error
        console.error('❌ Error updating table tresor, rolling back:', error);
        table[propertyName] = originalValue;
        return false;
      }
    }

    // Update page description data (unified system)
    updatePageDescriptionData(session, content) {
      // Use the ContentFactory method that already handles the configuration
      const success = ContentFactory.updatePageDescription(session.pageType, content);
      
      if (success) {
        return true;
      } else {
        console.error(`❌ Failed to update page description for ${session.pageType}`);
        return false;
      }
    }

    // Update category data (generic for all category types)
    updateCategoryData(session, content) {
      // Handle different category types generically
      if (session.categoryType === 'don') {
        const category = window.DONS?.find(cat => cat.nom === session.categoryName);
        if (category && session.editSection === 'description') {
          category.description = content;
          return true;
        }
      } else if (session.categoryType === 'spell') {
        const category = window.SORTS?.find(cat => cat.nom === session.categoryName);
        if (category && session.editSection === 'description') {
          category.description = content;
          return true;
        }
      }
      
      // Simple fallback - if we're editing description and nothing else matched, 
      // and we have OBJETS, assume it's the objects category
      if (session.editSection === 'description' && window.OBJETS) {
        window.OBJETS.description = content;
        return true;
      }
      
      return false;
    }

    // Update subclass data
    updateSubclassData(session, content) {
      const classe = window.CLASSES?.find(c => c.nom === session.categoryName);
      if (!classe) return false;
      
      const subclass = classe.sousClasses?.find(sc => sc.nom === session.itemIdentifier);
      if (!subclass) return false;
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.subclass;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // If we're updating the name, we need to update the container's data-subclass-name attribute
      if (propertyName === 'nom') {
        const oldName = subclass.nom;
        subclass[propertyName] = content;
        
        // Update the data-subclass-name attribute on the card container
        const subclassCard = session.container.closest('.card[data-subclass-name]');
        if (subclassCard && subclassCard.dataset.subclassName === oldName) {
          subclassCard.dataset.subclassName = content;
        }
      } else {
        subclass[propertyName] = content;
      }
      
      return true;
    }

    // Update class data
    updateClassData(session, content) {
      const classe = window.CLASSES?.find(c => c.nom === session.itemIdentifier);
      if (!classe) return false;
      
      classe[session.editSection] = content;
      return true;
    }

    // Update static page data
    updateStaticPageData(session, content) {
      const pageKey = session.itemIdentifier;
      const pageData = window.STATIC_PAGES?.[pageKey];
      
      if (!pageData) return false;
      
      // Handle page title
      if (session.editSection === 'page-title') {
        pageData.title = content;
        return true;
      }
      
      // Handle campaign data (special case for campaign page)
      if (pageKey === 'campagne') {
        return this.updateCampaignData(pageData, session, content);
      }
      
      // Handle sections
      return this.updateStaticPageSection(pageData, session, content);
    }

    // Update specific section in static page data
    updateStaticPageSection(pageData, session, content) {
      if (!pageData.sections) return false;
      
      const sections = pageData.sections;
      
      // Find section by ID or type
      for (let i = 0; i < sections.length; i++) {
        const section = sections[i];
        
        // Direct ID match
        if (section.id === session.editSection) {
          section.content = content;
          return true;
        }
        
        // Handle title updates (ID + "-title")
        if (session.editSection.endsWith('-title')) {
          const sectionId = session.editSection.replace('-title', '');
          if (section.id === sectionId) {
            section.title = content;
            return true;
          }
        }
        
        // Handle intro sections
        if (section.type === 'intro' && session.editSection.includes('intro')) {
          section.content = content;
          return true;
        }
        
        // Handle card sections
        if (section.type === 'card' && section.id === session.editSection) {
          section.content = content;
          return true;
        }
      }
      
      // If no existing section found, check if we need to create one for intro
      if (session.editSection === 'intro' || session.editSection.includes('intro')) {
        const introSection = sections.find(s => s.type === 'intro');
        if (introSection) {
          introSection.content = content;
          return true;
        }
      }
      
      return false;
    }

    // Update campaign and sub-page data
    updateCampaignData(pageData, session, content) {
      const editSection = session.editSection;
      
      // Initialize subPages if not exists
      if (!pageData.subPages) {
        pageData.subPages = {};
      }
      
      // Parse edit section: campaign-{campaignName}-{field} or subpage-{campaignName}-{subPageName}-{field}
      if (editSection.startsWith('campaign-')) {
        // Format: campaign-{campaignName}-{field}
        const parts = editSection.split('-');
        if (parts.length >= 3) {
          const campaignName = parts.slice(1, -1).join('-'); // Handle campaign names with dashes
          const field = parts[parts.length - 1];
          
          if (!pageData.subPages[campaignName]) {
            pageData.subPages[campaignName] = {
              name: campaignName,
              description: 'Description de la campagne',
              subPages: {}
            };
          }
          
          if (field === 'name') {
            // If renaming campaign, we need to move the entire campaign data
            if (campaignName !== content && !pageData.subPages[content]) {
              pageData.subPages[content] = pageData.subPages[campaignName];
              pageData.subPages[content].name = content;
              delete pageData.subPages[campaignName];
            }
          } else if (field === 'description') {
            pageData.subPages[campaignName].description = content;
          }
          
          return true;
        }
      } else if (editSection.startsWith('subpage-')) {
        // Format: subpage-{campaignName}-{subPageName}-{field}
        const parts = editSection.split('-');
        if (parts.length >= 4) {
          const campaignName = parts[1];
          const subPageName = parts.slice(2, -1).join('-'); // Handle sub-page names with dashes
          const field = parts[parts.length - 1];
          
          if (!pageData.subPages[campaignName]) {
            return false; // Campaign doesn't exist
          }
          
          if (!pageData.subPages[campaignName].subPages) {
            pageData.subPages[campaignName].subPages = {};
          }
          
          if (!pageData.subPages[campaignName].subPages[subPageName]) {
            pageData.subPages[campaignName].subPages[subPageName] = {
              title: subPageName,
              content: '<p>Contenu de la sous-page...</p>'
            };
          }
          
          if (field === 'title') {
            // If renaming sub-page, we need to move the entire sub-page data
            if (subPageName !== content && !pageData.subPages[campaignName].subPages[content]) {
              pageData.subPages[campaignName].subPages[content] = pageData.subPages[campaignName].subPages[subPageName];
              pageData.subPages[campaignName].subPages[content].title = content;
              delete pageData.subPages[campaignName].subPages[subPageName];
            }
          } else if (field === 'content') {
            pageData.subPages[campaignName].subPages[subPageName].content = content;
          }
          
          return true;
        }
      }
      
      return false;
    }

    // Save content using unified system
    saveContent(session, content) {
      try {
        // Determine which JSON category to save to
        let jsonCategory;
        
        switch (session.contentType) {
          case 'spell':
            jsonCategory = 'SORTS';
            break;
          case 'don':
            jsonCategory = 'DONS';
            break;
          case 'class':
            jsonCategory = 'CLASSES';
            break;
          case 'subclass':
            jsonCategory = 'CLASSES';  // Subclasses are stored within CLASSES
            break;
          case 'category':
            // Category descriptions can be in SORTS, DONS, or OBJETS
            if (session.categoryType === 'don') {
              jsonCategory = 'DONS';
            } else if (session.categoryType === 'spell') {
              jsonCategory = 'SORTS';
            } else {
              // Default to OBJETS for other category descriptions
              jsonCategory = 'OBJETS';
            }
            break;
          case 'objet':
            jsonCategory = 'OBJETS';
            break;
          case 'monster':
            jsonCategory = 'MONSTRES';
            break;
          case 'staticPage':
          case 'generic':
            jsonCategory = 'STATIC_PAGES';
            break;
          default:
            return false;
        }
        
        return this.saveToJson(session, content, jsonCategory);
      } catch (error) {
        console.error('Save error:', error);
        return false;
      }
    }

    // Unified save method that takes a JSON category parameter
    saveToJson(session, content, jsonCategory) {
      const jsonData = window[jsonCategory];
      if (!jsonData) {
        console.error(`JSON category ${jsonCategory} not found`);
        return false;
      }


      // Generic save - find the target object and save the content
      let targetObject = null;
      
      if (session.contentType === 'spell' || session.contentType === 'don') {
        // Find in category -> items structure
        for (const category of jsonData) {
          if (category.nom === session.categoryName) {
            const itemsKey = session.contentType === 'spell' ? 'sorts' : 'dons';
            // Use index-based identification if available, fallback to name-based
            if (session.itemIndex !== undefined && session.itemIndex !== null) {
              const index = parseInt(session.itemIndex, 10);
              targetObject = category[itemsKey]?.[index];
            } else {
              targetObject = category[itemsKey]?.find(item => item.nom === session.itemIdentifier);
            }
            break;
          }
        }
      } else if (session.contentType === 'class') {
        // Find class directly
        targetObject = jsonData.find(c => c.nom === session.itemIdentifier);
      } else if (session.contentType === 'subclass') {
        // Find subclass within a class
        const parentClass = jsonData.find(c => c.nom === session.categoryName);
        if (parentClass?.sousClasses) {
          targetObject = parentClass.sousClasses.find(sc => sc.nom === session.itemIdentifier);
        }
      } else if (session.contentType === 'objet') {
        // Find object directly in the objets array
        targetObject = jsonData.objets?.find(obj => obj.nom === session.itemIdentifier);
      } else if (session.contentType === 'monster') {
        // Find monster directly in the array
        targetObject = jsonData?.find(monster => monster.nom === session.itemIdentifier);
      } else if (session.contentType === 'tableTresor') {
        // Find table tresor directly in the array
        targetObject = jsonData?.tables?.find(table => table.nom === session.itemIdentifier);
      } else if (session.contentType === 'category') {
        // Find category by name and update its description
        targetObject = jsonData.find(category => category.nom === session.categoryName);
      } else if (session.contentType === 'staticPage' || session.contentType === 'generic') {
        return this.saveStaticPageToJson(jsonData, session, content);
      }
      
      if (targetObject) {
        targetObject[session.editSection] = content;
        return true;
      } else {
        return false;
      }
    }


    saveStaticPageToJson(jsonData, session, content) {
      const pageData = jsonData[session.itemIdentifier];
      if (!pageData?.sections) {
        console.error('Page data or sections not found for:', session.itemIdentifier);
        return false;
      }

      // Generic search by section ID or special cases
      const updateSection = (sections) => {
        for (const section of sections) {
          // Direct ID match for content
          if (section.id === session.editSection) {
            section.content = content;
            return true;
          }
          
          // Handle title updates (ID + "-title")
          if (session.editSection.endsWith('-title')) {
            const sectionId = session.editSection.replace('-title', '');
            if (section.id === sectionId) {
              section.title = content;
              return true;
            }
          }
          
          // Handle page title
          if (session.editSection === 'page-title') {
            // Page title is stored in the page data, not sections
            // This will be handled at page level
            return false;
          }
          
          // Handle intro sections
          if (section.type === 'intro' && session.editSection === 'intro') {
            section.content = content;
            return true;
          }

          // Handle nested content arrays (for grid sections)
          if (section.content && Array.isArray(section.content)) {
            if (updateSection(section.content)) {
              return true;
            }
          }
        }
        return false;
      };

      // Special handling for page title
      if (session.editSection === 'page-title') {
        pageData.title = content;
        return true;
      }

      if (updateSection(pageData.sections)) {
        return true;
      }

      console.error('Section not found for editSection:', session.editSection);
      return false;
    }

    // No special processing - everything is just HTML now
    processContentByType(content, fieldConfig) {
      return content;
    }

    // UNIFIED CONTENT RESTORATION - USE THIS FOR ALL CONTENT TYPES
    // This method ensures that HTML content is always properly rendered
    // and prevents HTML tags from being displayed as visible text
    restoreElementContent(session, content) {
      // IMPORTANT: Always use innerHTML to render HTML content properly
      // Never use textContent for edited content as it will show HTML tags
      session.element.innerHTML = content;
      
      // NOTE FOR DEVELOPERS: 
      // - For ANY new content type, use this method instead of direct innerHTML assignment
      // - This prevents the recurring issue of visible HTML tags after editing
      // - ALL content types (static pages, spells, classes, dons) go through this
    }

    resetEditingState(container) {
      const editableElement = container.querySelector('.editable') || container;
      
      // Standard editing cleanup (modal is handled separately)
      editableElement.contentEditable = false;
      // Simplified cleanup to prevent stack overflow
      editableElement.style.background = '';
      editableElement.style.border = '';
      editableElement.style.padding = '';
      editableElement.style.fontFamily = '';
      editableElement.style.whiteSpace = '';
      
      // Reset both container and editable element attributes
      container.dataset.editing = 'false';
      delete container.dataset.originalContent;
      
      // Also reset on the editable element itself in case it's the same
      if (editableElement !== container) {
        editableElement.dataset.editing = 'false';
        delete editableElement.dataset.originalContent;
      }
    }


    decodeHtmlEntities(html) {
      // Decode HTML entities step by step to prevent double-encoding
      let decoded = html
        .replace(/&amp;lt;/g, '<')  // &amp;lt; -> <
        .replace(/&amp;gt;/g, '>')  // &amp;gt; -> >
        .replace(/&lt;/g, '<')     // &lt; -> <
        .replace(/&gt;/g, '>')     // &gt; -> >
        .replace(/&quot;/g, '"')   // &quot; -> "
        .replace(/&#39;/g, "'")    // &#39; -> '
        .replace(/&amp;/g, '&');   // &amp; -> & (do this last)
      return decoded;
    }

    normalizeHTMLContent(html) {
      // SIMPLIFIED VERSION to prevent infinite loops
      // Just return the trimmed HTML without complex transformations
      if (!html || typeof html !== 'string') {
        return '';
      }
      
      // Basic cleanup only - avoid complex regex chains that can loop
      let cleaned = html.trim();
      
      // Only safe, non-recursive replacements
      cleaned = cleaned.replace(/&quot;/g, '"');
      cleaned = cleaned.replace(/&#39;/g, "'");
      cleaned = cleaned.replace(/<br\s*\/?>/gi, '<br>');
      
      return cleaned;
    }

    // Cancel current edit
    cancelCurrentEdit() {
      if (!this.currentEditSession) return false;

      const session = this.currentEditSession;
      // Reset editing state first to avoid interfering with content restoration
      this.resetEditingState(session.container);
      // Restore original content
      this.restoreElementContent(session, session.originalContent);
      this.currentEditSession = null;
      return true;
    }

    // Check if element is currently being edited
    isEditing(element) {
      return element.dataset.editing === 'true';
    }

    // Save all active edits
    saveAllEdits() {
      if (this.currentEditSession) {
        this.saveCurrentEdit();
      }

      // Handle any remaining editing elements
      document.querySelectorAll('[data-editing="true"]').forEach(element => {
        if (!this.isValidForEdit(element)) {
          this.resetEditingState(element);
        }
      });
    }

    isValidForEdit(element) {
      const context = this.parseEditContext(element);
      return context !== null;
    }

    // Handle tags editing context
    parseTagsEditContext(element, editSection) {
      // Check if we're in an objet card
      const objetCard = element.closest('.card[data-objet-name]');
      if (objetCard) {
        const objetName = objetCard.dataset.objetName;
        const categoryName = objetCard.dataset.categoryName;
        
        return {
          contentType: 'objet',
          itemIdentifier: objetName,
          categoryName: categoryName,
          property: 'tags',
          editType: 'tags',
          editSection: 'tags',
          config: window.ContentTypes.objet,
          element: element.classList.contains('editable-tags') ? element : element.querySelector('.editable-tags'),
          container: element
        };
      }
      
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        const editableElement = element.classList.contains('editable-tags') ? element : element.querySelector('.editable-tags');
        
        // Use data-item-identifier if available, otherwise fall back to monsterName
        const itemIdentifier = editableElement?.dataset?.itemIdentifier || monsterName;
        
        return {
          contentType: 'monster',
          itemIdentifier: itemIdentifier,
          categoryName: categoryName || 'monstres',
          property: 'tags',
          editType: 'tags',
          editSection: 'tags',
          config: window.ContentTypes.monster,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a table de trésor card
      const tableTresorCard = element.closest('.card[data-table-tresor-name]');
      if (tableTresorCard) {
        const tableTresorName = tableTresorCard.dataset.tableTresorName;
        const categoryName = tableTresorCard.dataset.categoryName || 'tables';
        
        const editableElement = element.classList.contains('editable-tags') ? element : element.querySelector('.editable-tags');
        
        // Use data-item-identifier if available, otherwise fall back to tableTresorName
        const itemIdentifier = editableElement?.dataset?.itemIdentifier || tableTresorName;
        
        return {
          contentType: 'tableTresor',
          itemIdentifier: itemIdentifier,
          categoryName: categoryName,
          property: 'tags',
          editType: 'tags',
          editSection: 'tags',
          config: window.ContentTypes.tableTresor,
          element: editableElement,
          container: element
        };
      }
      
      return null;
    }

    // Force reset of all elements that might be stuck in editing mode
    forceResetAllEditingElements() {
      // Reset any elements with contenteditable=true
      const editableElements = document.querySelectorAll('[contenteditable="true"]');
      editableElements.forEach(element => {
        element.contentEditable = false;
        element.style.background = '';
        element.style.border = '';
        element.style.padding = '';
        element.style.borderRadius = '';
        element.style.fontFamily = '';
        element.style.whiteSpace = '';
      });
      
      // Reset any containers with data-editing=true
      const editingContainers = document.querySelectorAll('[data-editing="true"]');
      editingContainers.forEach(container => {
        container.dataset.editing = 'false';
        delete container.dataset.originalContent;
      });
      
      // Clear any current edit session
      this.currentEditSession = null;
    }

    // Main entry point for starting edit
    startEdit(element) {
      // Force reset of any stuck editing elements first
      this.forceResetAllEditingElements();
      
      // Cancel any existing edit first
      if (this.currentEditSession) {
        this.saveCurrentEdit();
      }

      const context = this.parseEditContext(element);
      if (!context) {
        return false;
      }

      // Handle tags editing differently - show modal instead of inline editing
      if (context.editType === 'tags') {
        this.startTagsEdit(context);
        return true;
      }

      // Handle select editing differently - show dropdown instead of inline editing
      if (context.editType === 'select') {
        this.startSelectEdit(context);
        return true;
      }

      // Start normal inline editing
      return this.startInlineEdit(context);
    }

    // Start inline editing (for non-tags content)
    startInlineEdit(context) {
      const element = context.element;
      const container = context.container;

      // Store original content
      const originalContent = element.innerHTML;
      
      // Create edit session
      this.currentEditSession = {
        ...context,
        originalContent: originalContent
      };

      // Set up editing state
      container.dataset.editing = 'true';
      container.dataset.originalContent = originalContent;
      
      // Decode any encoded HTML before showing for editing
      const decodedHtml = this.decodeHtmlEntities(originalContent);
      element.innerHTML = decodedHtml;
      
      // Always use modal editing for consistency
      // Force modal editing for all content types to ensure uniform behavior
      this.showHTMLEditModal(element, decodedHtml);

      return true;
    }

    // Save current edit
    saveCurrentEdit() {
      if (!this.currentEditSession) return false;

      const session = this.currentEditSession;
      const element = session.element;
      const newContent = element.innerHTML.trim();
      
      // Normalize and clean HTML content
      const processedContent = this.normalizeHTMLContent(newContent);
      
      // Apply changes to data structure
      const success = this.updateContentInDataStructure(session, processedContent);
      
      if (success) {
        // Update display
        this.restoreElementContent(session, processedContent);
        
        // Note: Storage save is handled elsewhere to prevent loops
        // Show success notification
        if (JdrApp.modules.ui?.showNotification) {
          JdrApp.modules.ui.showNotification('💾 Modification sauvegardée', 'success');
        }
      } else {
        console.error('Failed to save edit:', session);
      }
      
      // Reset editing state
      this.resetEditingState(session.container);
      this.currentEditSession = null;
      
      return success;
    }

    // Show modal for editing HTML content
    showHTMLEditModal(element, htmlContent) {
      // Store the current edit session for later use
      const editSession = this.currentEditSession;
      
      const modal = document.createElement('dialog');
      modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 0;
        border: none;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        max-width: 80vw;
        max-height: 80vh;
        z-index: 1000000 !important;
        background: transparent;
      `;

      // Créer un backdrop manuel
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999999 !important;
        backdrop-filter: blur(4px);
      `;

      modal.innerHTML = `
        <div style="background: var(--paper); border-radius: 12px; padding: 1.5rem; border: 2px solid var(--rule); max-height: 80vh; overflow-y: auto; display: flex; flex-direction: column;">
          <h3 style="margin: 0 0 1rem 0; color: var(--accent-ink); flex-shrink: 0;">Édition du contenu</h3>
          
          <div style="margin-bottom: 1rem; flex-shrink: 0;">
            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Aperçu du rendu:</label>
            <div id="preview" style="border: 1px solid var(--rule); padding: 1rem; border-radius: 6px; background: var(--card); min-height: 60px; max-height: 150px; overflow-y: auto;">
              ${htmlContent}
            </div>
          </div>
          
          <div style="margin-bottom: 1rem; flex: 1; min-height: 0; display: flex; flex-direction: column;">
            <label for="htmlEditor" style="display: block; margin-bottom: 0.5rem; font-weight: 600; flex-shrink: 0;">Code HTML:</label>
            <textarea 
              id="htmlEditor" 
              style="width: 100%; flex: 1; min-height: 200px; padding: 1rem; border: 1px solid var(--rule); border-radius: 6px; font-family: monospace; font-size: 14px; resize: vertical;"
              placeholder="Entrez le HTML ici..."
            >${htmlContent}</textarea>
          </div>
          
          <div style="margin-bottom: 1rem; flex-shrink: 0;">
            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 0.5rem;">
              <button id="editorElementsBtn" class="btn" style="background: #059669; color: white; font-size: 12px;">🔥 Éléments</button>
              <button id="editorEtatsBtn" class="btn" style="background: #7c2d12; color: white; font-size: 12px;">⚡ États</button>
              <button id="editorSpellLinksBtn" class="btn" style="background: #6b21a8; color: white; font-size: 12px;">🔗 Liens Sorts</button>
              <button id="editorPageLinksBtn" class="btn" style="background: #1d4ed8; color: white; font-size: 12px;">🔗 Liens Pages</button>
              <button id="editorMonsterLinksBtn" class="btn" style="background: #dc2626; color: white; font-size: 12px;">🐲 Liens Monstres</button>
              <button id="editorTreasureTablesBtn" class="btn" style="background: #b45309; color: white; font-size: 12px;">🎲 Tables Trésors</button>
            </div>
            <div style="font-size: 12px; color: var(--paper-muted); line-height: 1.4;">
              💡 <strong>Astuce:</strong> Utilisez ces boutons pour insérer rapidement des éléments, états, liens vers les sorts, les pages, les monstres et les tables de trésors dans votre contenu HTML.
            </div>
          </div>
          
          <div style="display: flex; gap: 1rem; justify-content: flex-end; flex-shrink: 0;">
            <button id="cancelEdit" class="btn" style="background: #6b7280; color: white;">Annuler</button>
            <button id="saveEdit" class="btn" style="background: var(--accent); color: white;">💾 Sauvegarder</button>
          </div>
        </div>
      `;

      document.body.appendChild(backdrop);
      document.body.appendChild(modal);
      modal.show();

      const textarea = modal.querySelector('#htmlEditor');
      const preview = modal.querySelector('#preview');
      const saveBtn = modal.querySelector('#saveEdit');
      const cancelBtn = modal.querySelector('#cancelEdit');
      const elementsBtn = modal.querySelector('#editorElementsBtn');
      const etatsBtn = modal.querySelector('#editorEtatsBtn');
      const spellLinksBtn = modal.querySelector('#editorSpellLinksBtn');
      const pageLinksBtn = modal.querySelector('#editorPageLinksBtn');
      const monsterLinksBtn = modal.querySelector('#editorMonsterLinksBtn');
      const treasureTablesBtn = modal.querySelector('#editorTreasureTablesBtn');

      // Helper function to insert text at cursor position in textarea
      const insertTextAtCursor = (text) => {
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const currentValue = textarea.value;
        
        textarea.value = currentValue.substring(0, start) + text + currentValue.substring(end);
        textarea.selectionStart = textarea.selectionEnd = start + text.length;
        textarea.focus();
        
        // Update preview
        try {
          preview.innerHTML = textarea.value;
        } catch (e) {
          preview.textContent = 'Aperçu invalide: ' + e.message;
        }
      };

      // Store the insertTextAtCursor function globally so modals can access it
      window.editorInsertTextAtCursor = insertTextAtCursor;

      // Toolbox buttons handlers
      if (elementsBtn) {
        elementsBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showElementsModal) {
            JdrApp.modules.ui.showElementsModal();
          }
        });
      }

      if (etatsBtn) {
        etatsBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showEtatsModal) {
            JdrApp.modules.ui.showEtatsModal();
          }
        });
      }

      if (spellLinksBtn) {
        spellLinksBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showSpellLinksModal) {
            JdrApp.modules.ui.showSpellLinksModal();
          }
        });
      }

      if (pageLinksBtn) {
        pageLinksBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showPageLinksModal) {
            JdrApp.modules.ui.showPageLinksModal();
          }
        });
      }

      if (monsterLinksBtn) {
        monsterLinksBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showMonsterLinksModal) {
            JdrApp.modules.ui.showMonsterLinksModal();
          }
        });
      }

      // Live preview update with debounce to prevent performance issues
      let previewUpdateTimeout;
      textarea.addEventListener('input', () => {
        clearTimeout(previewUpdateTimeout);
        previewUpdateTimeout = setTimeout(() => {
          try {
            preview.innerHTML = textarea.value;
          } catch (e) {
            preview.textContent = 'Aperçu invalide: ' + e.message;
          }
        }, 300); // 300ms debounce
      });

      // Save handler
      saveBtn.addEventListener('click', () => {
        const newContent = textarea.value.trim();
        const normalizedContent = this.normalizeHTMLContent(newContent);
        
        // Update the element content
        element.innerHTML = normalizedContent;
        
        // Update in data structure using stored session
        const success = this.updateContentInDataStructure(editSession, normalizedContent);
        
        if (success) {
          EventBus.emit(Events.STORAGE_SAVE);
          if (JdrApp.modules.ui?.showNotification) {
            JdrApp.modules.ui.showNotification('💾 Modification sauvegardée', 'success');
          }
        }
        
        // Clean up
        this.resetEditingState(editSession.container);
        this.currentEditSession = null;
        window.editorInsertTextAtCursor = null;
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Cancel handler
      cancelBtn.addEventListener('click', () => {
        this.resetEditingState(editSession.container);
        this.currentEditSession = null;
        window.editorInsertTextAtCursor = null;
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Close on backdrop click
      backdrop.addEventListener('click', () => {
        this.resetEditingState(editSession.container);
        this.currentEditSession = null;
        window.editorInsertTextAtCursor = null;
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Treasure tables button handler
      if (treasureTablesBtn) {
        treasureTablesBtn.addEventListener('click', () => {
          this.showTreasureTablesModal(insertTextAtCursor);
        });
      }

      // Focus textarea
      textarea.focus();
      textarea.select();
    }

    // Handle select editing by toggling display/selector visibility
    startSelectEdit(context) {
      const element = context.element;
      const container = context.container;

      // Store the current edit session
      this.currentEditSession = {
        ...context,
        originalContent: element.value // For select, we store the value, not innerHTML
      };

      // Find the display and selector sections
      const sectionContainer = element.closest('.monster-element-section, .spell-element-section');
      if (!sectionContainer) {
        return false;
      }

      const displaySection = sectionContainer.querySelector('.monster-element-display, .spell-element-display');
      const selectorSection = sectionContainer.querySelector('.monster-element-selector, .spell-element-selector');
      
      if (!displaySection || !selectorSection) {
        return false;
      }

      // Toggle visibility
      displaySection.style.display = 'none';
      selectorSection.style.display = 'block';

      // Set up change listener for the select element
      const selectElement = selectorSection.querySelector('select');
      if (selectElement) {
        selectElement.focus();
        
        // Add event listener for changes
        const changeHandler = () => {
          this.saveSelectEdit(selectElement);
          selectElement.removeEventListener('change', changeHandler);
          selectElement.removeEventListener('blur', blurHandler);
        };

        const blurHandler = () => {
          this.cancelSelectEdit(sectionContainer);
          selectElement.removeEventListener('change', changeHandler);
          selectElement.removeEventListener('blur', blurHandler);
        };

        selectElement.addEventListener('change', changeHandler);
        selectElement.addEventListener('blur', blurHandler);
      }

      return true;
    }

    // Save select edit
    saveSelectEdit(selectElement) {
      if (!this.currentEditSession) return false;

      const newValue = selectElement.value;
      const session = this.currentEditSession;

      // Update the data structure
      const success = this.updateContentInDataStructure(session, newValue);

      if (success) {
        // Update the display immediately
        this.updateElementDisplay(session, newValue);
        
        // Emit storage save event
        EventBus.emit(Events.STORAGE_SAVE);
        
        // Show success notification
        if (JdrApp.modules.ui?.showNotification) {
          JdrApp.modules.ui.showNotification('💾 Élément mis à jour', 'success');
        }
      }

      // Hide selector and show display
      this.resetSelectEdit();
      this.currentEditSession = null;
      return success;
    }

    // Cancel select edit
    cancelSelectEdit(sectionContainer) {
      this.resetSelectEdit();
      this.currentEditSession = null;
    }

    // Reset select edit UI state
    resetSelectEdit() {
      if (!this.currentEditSession) return;

      const element = this.currentEditSession.element;
      const sectionContainer = element.closest('.monster-element-section, .spell-element-section');
      if (!sectionContainer) return;

      const displaySection = sectionContainer.querySelector('.monster-element-display, .spell-element-display');
      const selectorSection = sectionContainer.querySelector('.monster-element-selector, .spell-element-selector');
      
      if (displaySection && selectorSection) {
        displaySection.style.display = 'block';
        selectorSection.style.display = 'none';
      }
    }

    // Update element display after selection change
    updateElementDisplay(session, newValue) {
      const element = session.element;
      const sectionContainer = element.closest('.monster-element-section, .spell-element-section');
      if (!sectionContainer) return;

      const displaySection = sectionContainer.querySelector('.monster-element-display, .spell-element-display');
      const badge = displaySection?.querySelector('.element-badge');
      
      if (badge) {
        // Get element icon and color
        const icon = window.ElementIcons?.[newValue] || '⚡';
        const color = window.ElementColors?.[newValue]?.color || '#666';
        
        // Update the badge content and style
        if (session.contentType === 'monster') {
          // For monsters, we need to update the complete badge styling
          const iconSpan = badge.querySelector('span:first-child');
          const textSpan = badge.querySelector('span:last-child');
          if (iconSpan && textSpan) {
            iconSpan.textContent = icon;
            textSpan.textContent = newValue;
            textSpan.style.color = color;
            
            // Update the complete badge background and border
            const hexColor = color;
            const rgbMatch = hexColor.match(/^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
            if (rgbMatch) {
              const r = parseInt(rgbMatch[1], 16);
              const g = parseInt(rgbMatch[2], 16);
              const b = parseInt(rgbMatch[3], 16);
              badge.style.background = `rgba(${r}, ${g}, ${b}, 0.1)`;
              badge.style.border = `1px solid ${hexColor}`;
            }
          }
        } else if (session.contentType === 'spell') {
          // Update spell badge
          badge.innerHTML = `${icon} ${newValue}`;
        }
      }
    }

    // Handle tags editing by showing modal
    startTagsEdit(context) {
      // For tags, we don't do inline editing, we show a modal
      this.showTagsModal(context);
    }

    // Show tags editing modal
    showTagsModal(context) {
      // Find the target item (object or monster)
      let targetItem = null;
      let availableTags = [];
      
      if (context.contentType === 'objet') {
        const allObjects = window.OBJETS?.objets || [];
        targetItem = allObjects.find(o => o.nom === context.itemIdentifier);
        availableTags = window.ContentTypes.objet.filterConfig.availableTags || [];
      } else if (context.contentType === 'monster') {
        const allMonsters = window.MONSTRES || [];
        targetItem = allMonsters.find(m => m.nom === context.itemIdentifier);
        availableTags = window.ContentTypes.monster.filterConfig.availableTags || [];
      } else if (context.contentType === 'tableTresor') {
        const allTables = window.TABLES_TRESORS?.tables || [];
        targetItem = allTables.find(t => t.nom === context.itemIdentifier);
        // Use metadata as primary source, fallback to ContentTypes config
        availableTags = window.TABLES_TRESORS?._metadata?.availableTags || 
                       window.ContentTypes.tableTresor?.filterConfig?.availableTags || [];
      }
      
      if (!targetItem) {
        console.error('Item not found for tags editing:', context.itemIdentifier, 'Type:', context.contentType);
        return;
      }

      const itemTags = targetItem.tags || [];

      // Remove existing modal if any
      const existingModal = document.querySelector('#tagsEditModal');
      if (existingModal) {
        existingModal.remove();
      }

      // Create modal
      const modal = document.createElement('dialog');
      modal.id = 'tagsEditModal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        padding: 0;
        border: none;
        border-radius: 12px;
        background: transparent;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      `;
      
      const tagsCheckboxes = availableTags.map(tag => {
        const isSelected = itemTags.includes(tag);
        return `
          <div style="display: flex; align-items: center; gap: 0.5rem; margin: 0.5rem 0; padding: 0.5rem; background: var(--card); border-radius: 8px;">
            <input 
              type="checkbox" 
              id="tag-${tag}" 
              value="${tag}" 
              ${isSelected ? 'checked' : ''}
              style="margin: 0;"
            >
            <label for="tag-${tag}" style="flex: 1; cursor: pointer; font-weight: 500;">
              <span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 0.5rem;">${tag}</span>
              ${tag}
            </label>
          </div>
        `;
      }).join('');

      modal.innerHTML = `
        <div style="background: var(--paper); border-radius: 12px; padding: 1.5rem; border: 2px solid var(--rule);">
          <h3 style="margin: 0 0 1rem 0; color: var(--accent-ink);">Édition des tags - ${targetItem.nom}</h3>
          <p style="margin: 0 0 1rem 0; color: var(--paper-muted);">Sélectionnez les tags pour cet objet :</p>
          <div id="tagsCheckboxes" style="margin: 1rem 0; max-height: 300px; overflow-y: auto;">
            ${tagsCheckboxes}
          </div>
          <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem;">
            <button class="btn" id="saveTagsBtn" style="background: var(--accent); color: white;">
              💾 Sauvegarder
            </button>
            <button class="btn modal-close" style="background: #666; color: white;">
              ❌ Annuler
            </button>
          </div>
        </div>
      `;

      // Add event listeners
      modal.addEventListener('click', (e) => {
        if (e.target.id === 'saveTagsBtn') {
          this.saveTagsFromModal(modal, targetItem, context);
        } else if (e.target.classList.contains('modal-close')) {
          modal.close();
          modal.remove();
        }
      });

      // Handle dialog close events
      modal.addEventListener('cancel', () => {
        modal.close();
        modal.remove();
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.close();
          modal.remove();
        }
      });

      document.body.appendChild(modal);
      modal.showModal();
    }

    // Save tags from modal
    saveTagsFromModal(modal, obj, context) {
      // Get selected tags
      const checkboxes = modal.querySelectorAll('input[type="checkbox"]:checked');
      const selectedTags = Array.from(checkboxes).map(cb => cb.value);

      if (selectedTags.length === 0) {
        JdrApp.modules.ui.showNotification('❌ Veuillez sélectionner au moins un tag', 'error');
        return;
      }

      // Update tags for the target item (works for both objects and monsters)
      obj.tags = selectedTags;

      // Update the display immediately
      const tagDisplay = context.element;
      if (tagDisplay) {
        const tagsDisplayHTML = selectedTags.map(tag => 
          `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`
        ).join('');
        tagDisplay.innerHTML = tagsDisplayHTML;
      }

      // Trigger save to storage
      EventBus.emit(Events.STORAGE_SAVE);
      
      // Close modal
      modal.close();
      modal.remove();
      
      JdrApp.modules.ui.showNotification(`💾 Tags sauvegardés pour "${obj.nom}"`, 'success');
    }

    // Create backup of monster data for recovery
    createMonsterBackup(monster) {
      try {
        if (!window.MonsterBackups) {
          window.MonsterBackups = new Map();
        }
        
        // Keep only last MAX_MONSTER_BACKUPS backups per monster
        const backupKey = monster.nom;
        const currentBackups = window.MonsterBackups.get(backupKey) || [];
        
        const backup = {
          timestamp: Date.now(),
          data: JSON.parse(JSON.stringify(monster)) // Deep copy
        };
        
        currentBackups.push(backup);
        const maxBackups = window.DEFAULT_VALUES?.MAX_MONSTER_BACKUPS || 10;
        if (currentBackups.length > maxBackups) {
          currentBackups.shift(); // Remove oldest
        }
        
        window.MonsterBackups.set(backupKey, currentBackups);
        
      } catch (error) {
        // Ignore backup failures - not critical
      }
    }

    // Recover monster from backup
    recoverMonsterFromBackup(monsterName, backupIndex = 0) {
      try {
        if (!window.MonsterBackups || !window.MonsterBackups.has(monsterName)) {
          console.error('No backup found for monster:', monsterName);
          return false;
        }
        
        const backups = window.MonsterBackups.get(monsterName);
        const backup = backups[backups.length - 1 - backupIndex]; // Get latest by default
        
        if (!backup) {
          console.error('Backup index out of range for monster:', monsterName);
          return false;
        }
        
        // Find monster in current data
        const monster = window.MONSTRES?.find(m => m.nom === monsterName);
        if (!monster) {
          console.error('Monster not found in current data:', monsterName);
          return false;
        }
        
        // Restore data
        Object.assign(monster, backup.data);
        
        // Force sync
        const contentFactory = window.ContentFactory?.getInstance ? window.ContentFactory.getInstance() : null;
        if (contentFactory && contentFactory.refreshData) {
          contentFactory.refreshData();
        }
        
        return true;
        
      } catch (error) {
        console.error('Failed to recover monster from backup:', error);
        return false;
      }
    }

    // Global validation and repair of monster data
    validateAndRepairMonsterData() {
      if (!window.MONSTRES || !Array.isArray(window.MONSTRES)) {
        return 0;
      }
      
      let repairCount = 0;
      const contentTypes = window.ContentTypes?.monster;
      
      window.MONSTRES.forEach((monster, index) => {
        // Ensure required properties exist
        if (!monster.nom) {
          monster.nom = `Monstre ${index + 1}`;
          repairCount++;
        }
        
        // Validate numeric properties
        if (contentTypes && contentTypes.fields) {
          Object.entries(contentTypes.fields).forEach(([fieldName, fieldConfig]) => {
            if (fieldConfig.type === 'number') {
              if (typeof monster[fieldName] !== 'number' || isNaN(monster[fieldName])) {
                const defaultValue = contentTypes.defaultValues?.[fieldName] || 0;
                monster[fieldName] = defaultValue;
                repairCount++;
              }
            }
          });
        }
        
        // Ensure image path exists and is valid
        if (!monster.image || typeof monster.image !== 'string') {
          monster.image = `data/images/Monstres/foret/Monstre_Forêt_${monster.nom.replace(/[^a-zA-Z0-9]/g, '')}.png`;
          repairCount++;
        }
        
        // Validate image mapping exists
        if (JdrApp.modules.images) {
          const imageKey = `monster:${monster.nom}`;
          if (!JdrApp.modules.images.getImageUrl(imageKey)) {
            JdrApp.modules.images.setImage(imageKey, monster.image);
          }
        }
      });
      
      if (repairCount > 0) {
        // Save repaired data
        if (JdrApp.modules.storage && JdrApp.modules.storage.saveChanges) {
          JdrApp.modules.storage.saveChanges(true);
        }
      }
      
      return repairCount;
    }
    
    // Update static page data method
    updateStaticPageData(session, content) {
      try {
        const pageId = session.itemIdentifier;
        const editSection = session.editSection;
        
        // Get the static page data
        const staticPageData = window.STATIC_PAGES?.[pageId];
        if (!staticPageData) {
          console.error('Static page not found:', pageId);
          return false;
        }
        
        // Handle different edit section formats
        if (editSection.startsWith('intro-')) {
          // Editing intro section
          const sectionIndex = parseInt(editSection.split('-')[1]);
          if (staticPageData.sections && staticPageData.sections[sectionIndex] && staticPageData.sections[sectionIndex].type === 'intro') {
            staticPageData.sections[sectionIndex].content = content;
          }
        } else if (editSection === 'page-title') {
          // Editing page title
          staticPageData.title = content;
        } else if (editSection.endsWith('-title')) {
          // Editing card title (e.g., "dieux-new-2-1756899335313-title")
          const cardId = editSection.slice(0, -6); // Remove "-title"
          const cardSection = staticPageData.sections?.find(s => s.id === cardId);
          if (cardSection) {
            cardSection.title = content;
          }
        } else {
          // Editing card content (e.g., "dieux-new-2-1756899335313")
          const cardSection = staticPageData.sections?.find(s => s.id === editSection);
          if (cardSection) {
            cardSection.content = content;
          } else {
            console.warn('Unhandled static page edit section:', editSection);
            return false;
          }
        }
        
        return true;
        
      } catch (error) {
        console.error('Failed to update static page data:', error);
        return false;
      }
    }

    // Campaign and sub-page data update method
    updateCampaignData(type, campaignName, property, content, subPageName = null) {
      try {
        // Get the campaign data from the static pages
        const campagneData = window.STATIC_PAGES?.campagne;
        if (!campagneData || !campagneData.subPages) {
          return false;
        }
        
        if (type === 'campaign') {
          // Update campaign property (name or description)
          if (!campagneData.subPages[campaignName]) {
            return false;
          }
          
          if (property === 'name') {
            // Renaming a campaign requires more complex handling
            // For now, just update the description property
            return false;
          } else if (property === 'description') {
            campagneData.subPages[campaignName].description = content;
          }
        } else if (type === 'subpage') {
          // Update sub-page property (title or content)
          if (!campagneData.subPages[campaignName] || !campagneData.subPages[campaignName].subPages || !subPageName) {
            return false;
          }
          
          const subPage = campagneData.subPages[campaignName].subPages[subPageName];
          if (!subPage) {
            return false;
          }
          
          if (property === 'title') {
            subPage.title = content;
          } else if (property === 'content') {
            subPage.content = content;
          }
        }
        
        // Data updated in memory only - will be saved during export
        // No automatic save to prevent infinite loops
        
        return true;
        
      } catch (error) {
        console.error('Failed to update campaign data:', error);
        return false;
      }
    }

    addEditingControls(container, editableElement) {
      // Remove any existing editing controls
      const existingControls = container.querySelector('.editing-controls');
      if (existingControls) {
        existingControls.remove();
      }

      // Create editing controls toolbar
      const controlsDiv = document.createElement('div');
      controlsDiv.className = 'editing-controls';
      controlsDiv.style.cssText = `
        position: absolute;
        top: -40px;
        right: 0;
        background: var(--paper);
        border: 1px solid var(--bronze);
        border-radius: 6px;
        padding: 4px;
        display: flex;
        gap: 4px;
        z-index: 1000;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      `;

      // Get available treasure tables for the dropdown
      const availableTables = window.TABLES_TRESORS?.tables || [];
      let treasureControls = '';
      
      if (availableTables.length > 0) {
        const tableOptions = availableTables.map(table => 
          `<option value="${table.nom}">${table.nom}</option>`
        ).join('');

        treasureControls = `
          <div class="treasure-table-controls" style="display: flex; align-items: center; gap: 2px; border-right: 1px solid var(--rule); padding-right: 4px; margin-right: 4px;">
            <select class="treasure-table-select" style="font-size: 11px; padding: 2px; border: 1px solid var(--rule); border-radius: 3px;">
              <option value="">Choisir table</option>
              ${tableOptions}
            </select>
            <button type="button" class="copy-treasure-link-btn btn" style="
              background: var(--bronze); 
              color: white; 
              border: none; 
              padding: 2px 6px; 
              border-radius: 3px; 
              cursor: pointer; 
              font-size: 10px;
              white-space: nowrap;
            " title="Copier le lien HTML de la table sélectionnée">
              📋 Table
            </button>
          </div>
        `;
      }

      controlsDiv.innerHTML = `
        ${treasureControls}
        <button type="button" class="save-edit-btn btn" style="
          background: var(--accent); 
          color: white; 
          border: none; 
          padding: 2px 6px; 
          border-radius: 3px; 
          cursor: pointer; 
          font-size: 11px;
        ">
          ✓ Sauver
        </button>
        <button type="button" class="cancel-edit-btn btn" style="
          background: #666; 
          color: white; 
          border: none; 
          padding: 2px 6px; 
          border-radius: 3px; 
          cursor: pointer; 
          font-size: 11px;
        ">
          ✕ Annuler
        </button>
      `;

      // Position the container relatively for absolute positioning of controls
      container.style.position = 'relative';
      container.appendChild(controlsDiv);

      // Set up event listeners
      this.setupEditingControlsListeners(controlsDiv, container, editableElement);
    }

    setupEditingControlsListeners(controlsDiv, container, editableElement) {
      // Save button
      const saveBtn = controlsDiv.querySelector('.save-edit-btn');
      if (saveBtn) {
        saveBtn.addEventListener('click', () => {
          // Get current content
          const newContent = editableElement.innerHTML.trim();
          const normalizedContent = this.normalizeHTMLContent(newContent);
          
          // Update in data structure using current session
          if (this.currentEditSession) {
            const success = this.updateContentInDataStructure(this.currentEditSession, normalizedContent);
            
            if (success) {
              EventBus.emit(Events.STORAGE_SAVE);
              if (JdrApp.modules.ui?.showNotification) {
                JdrApp.modules.ui.showNotification('💾 Modification sauvegardée', 'success');
              }
            }
            
            // Reset editing state
            this.resetEditingState(container);
            this.currentEditSession = null;
          }
          
          this.removeEditingControls(container);
        });
      }

      // Cancel button  
      const cancelBtn = controlsDiv.querySelector('.cancel-edit-btn');
      if (cancelBtn) {
        cancelBtn.addEventListener('click', () => {
          // Reset editing state without saving
          this.resetEditingState(container);
          if (this.currentEditSession) {
            this.currentEditSession = null;
          }
          this.removeEditingControls(container);
        });
      }

      // Copy treasure table link button
      const copyBtn = controlsDiv.querySelector('.copy-treasure-link-btn');
      const tableSelect = controlsDiv.querySelector('.treasure-table-select');
      
      if (copyBtn && tableSelect) {
        copyBtn.addEventListener('click', () => {
          const selectedTable = tableSelect.value;
          if (selectedTable && window.TablesTresorsManager) {
            const htmlLink = window.TablesTresorsManager.generateTreasureTableHtmlLink(selectedTable);
            
            // Insert the link at cursor position
            if (editableElement.contentEditable === 'true') {
              const selection = window.getSelection();
              if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                range.deleteContents();
                const linkNode = document.createTextNode(htmlLink);
                range.insertNode(linkNode);
                
                // Move cursor after the inserted text
                range.setStartAfter(linkNode);
                range.setEndAfter(linkNode);
                selection.removeAllRanges();
                selection.addRange(range);
              } else {
                // Fallback: append at the end
                editableElement.innerHTML += htmlLink;
              }
              
              // Show notification
              if (window.TablesTresorsManager.showNotification) {
                window.TablesTresorsManager.showNotification('✓ Lien de table inséré!', 'success');
              }
            }
          }
        });
      }

      // Also handle Enter and Escape keys on the editable element
      editableElement.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          e.preventDefault();
          // Reset editing state without saving
          this.resetEditingState(container);
          if (this.currentEditSession) {
            this.currentEditSession = null;
          }
          this.removeEditingControls(container);
        } else if (e.key === 'Enter' && e.ctrlKey) {
          e.preventDefault();
          // Save with Ctrl+Enter
          const newContent = editableElement.innerHTML.trim();
          const normalizedContent = this.normalizeHTMLContent(newContent);
          
          if (this.currentEditSession) {
            const success = this.updateContentInDataStructure(this.currentEditSession, normalizedContent);
            
            if (success) {
              EventBus.emit(Events.STORAGE_SAVE);
              if (JdrApp.modules.ui?.showNotification) {
                JdrApp.modules.ui.showNotification('💾 Modification sauvegardée', 'success');
              }
            }
            
            this.resetEditingState(container);
            this.currentEditSession = null;
          }
          
          this.removeEditingControls(container);
        }
      });
    }

    removeEditingControls(container) {
      const controls = container.querySelector('.editing-controls');
      if (controls) {
        controls.remove();
      }
    }

    // Show treasure tables selection modal
    showTreasureTablesModal(insertTextAtCursor) {
      const availableTables = window.TABLES_TRESORS?.tables || [];
      
      if (availableTables.length === 0) {
        if (JdrApp.modules.ui?.showNotification) {
          JdrApp.modules.ui.showNotification('❌ Aucune table de trésor disponible', 'error');
        }
        return;
      }

      // Create modal
      const modal = document.createElement('dialog');
      modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 0;
        border: none;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        max-width: 500px;
        width: 90%;
        z-index: 1000001 !important;
        background: transparent;
      `;

      // Create backdrop
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 1000000 !important;
        backdrop-filter: blur(4px);
      `;

      const tableOptions = availableTables.map(table => 
        `<option value="${table.nom}">${table.nom}${table.tags ? ` (${table.tags.join(', ')})` : ''}</option>`
      ).join('');

      modal.innerHTML = `
        <div style="background: var(--paper); border-radius: 12px; padding: 1.5rem; border: 2px solid var(--rule);">
          <h3 style="margin: 0 0 1rem 0; color: var(--accent-ink);">🎲 Insérer un lien de table de trésor</h3>
          
          <div style="margin-bottom: 1rem;">
            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Choisir une table:</label>
            <select id="treasureTableSelect" style="width: 100%; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px; font-size: 14px;">
              <option value="">-- Sélectionner une table --</option>
              ${tableOptions}
            </select>
          </div>

          <div style="margin-bottom: 1rem;">
            <div id="tablePreview" style="border: 1px solid var(--rule); padding: 1rem; border-radius: 6px; background: var(--card); min-height: 50px; font-size: 12px; color: var(--paper-muted);">
              Sélectionnez une table pour voir l'aperçu
            </div>
          </div>
          
          <div style="display: flex; gap: 1rem; justify-content: flex-end;">
            <button id="cancelTreasureModal" class="btn" style="background: #6b7280; color: white;">Annuler</button>
            <button id="insertTreasureLink" class="btn" style="background: var(--accent); color: white;" disabled>🎲 Insérer le lien</button>
          </div>
        </div>
      `;

      document.body.appendChild(backdrop);
      document.body.appendChild(modal);
      modal.show();

      // Get elements
      const select = modal.querySelector('#treasureTableSelect');
      const preview = modal.querySelector('#tablePreview');
      const insertBtn = modal.querySelector('#insertTreasureLink');
      const cancelBtn = modal.querySelector('#cancelTreasureModal');

      // Handle table selection
      select.addEventListener('change', () => {
        const selectedTableName = select.value;
        if (selectedTableName) {
          insertBtn.disabled = false;
          
          const selectedTable = availableTables.find(t => t.nom === selectedTableName);
          if (selectedTable && window.TablesTresorsManager) {
            const previewHtml = window.TablesTresorsManager.generateTablePreviewHtml(selectedTable);
            preview.innerHTML = previewHtml;
          }
        } else {
          insertBtn.disabled = true;
          preview.innerHTML = 'Sélectionnez une table pour voir l\'aperçu';
        }
      });

      // Handle insert
      insertBtn.addEventListener('click', () => {
        const selectedTableName = select.value;
        if (selectedTableName && window.TablesTresorsManager) {
          const htmlLink = window.TablesTresorsManager.generateTreasureTableHtmlLink(selectedTableName);
          insertTextAtCursor(htmlLink);
          
          if (JdrApp.modules.ui?.showNotification) {
            JdrApp.modules.ui.showNotification('✓ Lien de table inséré!', 'success');
          }
        }
        
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Handle cancel
      cancelBtn.addEventListener('click', () => {
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Handle backdrop click
      backdrop.addEventListener('click', () => {
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Focus select
      select.focus();
    }
  }

  window.UnifiedEditor = UnifiedEditor.getInstance();

})();
// ============================================================================
// JDR-BAB APPLICATION - EDITOR MODULE (REFACTORED)
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // EDITOR MODULE - Now uses UnifiedEditor
  // ========================================
  JdrApp.modules.editor = {
    editedData: {},
    isDevMode: false,

    init() {
      this.setupEventListeners();
      this.setupEditableHandlers();
      this.setupCreationHandlers();
      this.setupImageHandlers();
      this.updateDevModeState();
    },

    setupEventListeners() {
      JdrApp.utils.events.register('click', '#devToggle', () => this.toggleDevMode());

      EventBus.on(Events.EDITOR_TOGGLE, (payload) => {
        this.isDevMode = payload.enabled;
        this.updateDevModeState();
      });

      EventBus.on(Events.CONTENT_UPDATE, () => {
        this.saveChangesToStorage();
      });

    },

    toggleDevMode() {
      if (window.STANDALONE_VERSION) return;
      
      this.isDevMode = !this.isDevMode;
      EventBus.emit(Events.EDITOR_TOGGLE, { enabled: this.isDevMode });
    },

    updateDevModeState() {
      if (window.STANDALONE_VERSION) {
        document.body.className = 'dev-off';
        this.forceHideAllEditButtons();
        return;
      }
      
      document.body.classList.toggle('dev-on', this.isDevMode);
      document.body.classList.toggle('dev-off', !this.isDevMode);
      
      const devToggle = document.querySelector('#devToggle');
      const devToolbox = document.querySelector('#devToolbox');
      
      if (devToggle) {
        devToggle.textContent = `🛠 Dev Mode: ${this.isDevMode ? 'ON' : 'OFF'}`;
      }
      
      if (devToolbox) {
        devToolbox.style.display = this.isDevMode ? 'block' : 'none';
        
        // Initialize toolbox content if empty or only has comments
        if (this.isDevMode) {
          const trimmedContent = devToolbox.innerHTML.trim();
          if (trimmedContent === '' || trimmedContent === '<!-- Dev toolbox content will be injected here -->' || !devToolbox.querySelector('.dev-toolbox-content')) {
            this.initializeDevToolbox(devToolbox);
          }
        }
      }
      
      // Update dev-only containers visibility - same approach as modal buttons
      const devOnlyElements = document.querySelectorAll('[data-dev-only]');
      devOnlyElements.forEach(element => {
        element.style.display = this.isDevMode ? 'block' : 'none';
      });
      
      if (this.isDevMode) {
        this.forceShowAllEditButtons();
      } else {
        this.forceHideAllEditButtons();
      }

      // Regenerate monsters page if currently viewing it
      const currentPage = window.location.hash.replace('#/', '');
      if (currentPage === 'monstres' && JdrApp.modules.renderer && JdrApp.modules.renderer.populateMonstersPage) {
        setTimeout(() => {
          JdrApp.modules.renderer.populateMonstersPage();
        }, 100);
      }
    },

    forceHideAllEditButtons() {
      if (this.isDevMode) {
        return;
      }
      
      const selectors = [
        '.edit-btn', '[class$="-add"]', '[class$="-delete"]', '[class*="-move-"]',
        '.section-delete', '.remove-section-btn', '.add-paragraph-btn', 
        '.add-subclass-btn', '.delete-subclass-btn',
        '.spell-delete', '.don-delete', // Explicit delete buttons
        '.illus .up', '.illus .rm', '.illus label', '.illus input[type="file"]',
        '.tags-manager-btn', '.filter-manager-btn' // Tags and filter manager buttons
      ];
      
      selectors.forEach(selector => {
        document.querySelectorAll(selector).forEach(element => {
          element.style.display = 'none';
          element.style.visibility = 'hidden';
          element.setAttribute('aria-hidden', 'true');
        });
      });
    },
    
    forceShowAllEditButtons() {
      if (!this.isDevMode) return;
      
      // Ensure body has the correct classes
      document.body.classList.add('dev-on');
      document.body.classList.remove('dev-off');
      
      // Force reset all CSS properties that might be causing 0x0 dimensions
      const selectors = [
        '.edit-btn', '[class$="-add"]', '[class$="-delete"]', '[class*="-move-"]',
        '.section-delete', '.remove-section-btn', '.add-paragraph-btn', 
        '.add-subclass-btn', '.delete-subclass-btn',
        '.spell-delete', '.don-delete', '.objet-delete',
        '.spell-add', '.don-add', '.objet-add',
        '.illus .up', '.illus .rm', '.illus label', '.illus input[type="file"]',
        '.tags-manager-btn', '.filter-manager-btn' // Tags and filter manager buttons
      ];
      
      selectors.forEach(selector => {
        document.querySelectorAll(selector).forEach(element => {
          // Force reset all dimension properties
          element.style.removeProperty('display');
          element.style.removeProperty('visibility');
          element.style.removeProperty('opacity');
          element.style.removeProperty('width');
          element.style.removeProperty('height');
          element.style.removeProperty('min-width');
          element.style.removeProperty('min-height');
          element.style.removeProperty('pointer-events');
          element.removeAttribute('aria-hidden');
          
          // Let CSS handle the styling
          element.style.display = '';
          element.style.visibility = '';
        });
      });
    },

    setupEditableHandlers() {
      // Unified edit button handler
      JdrApp.utils.events.register('click', '.edit-btn', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!this.isDevMode) return;
        
        // Prevent multiple edit sessions
        if (UnifiedEditor.currentEditSession) {
          console.warn('Another edit session is already active');
          return;
        }
        
        // Find the editable element near the button
        let editableElement = e.target.previousElementSibling;
        
        // If not found as previous sibling, look in parent
        if (!editableElement || !editableElement.classList.contains('editable')) {
          const parent = e.target.parentElement;
          editableElement = parent.querySelector('.editable');
        }
        
        // Fallback: look for closest editable element
        if (!editableElement || !editableElement.classList.contains('editable')) {
          editableElement = e.target.closest('.editable-section')?.querySelector('.editable') ||
                           e.target.closest('.card')?.querySelector('.editable');
        }
        
        if (editableElement && editableElement.classList.contains('editable')) {
          UnifiedEditor.startEdit(editableElement);
        } else {
          console.warn('No editable element found for edit button');
        }
      });

      // Handle select element changes directly
      JdrApp.utils.events.register('change', '.editable[data-edit-type="select"]', (e) => {
        if (!this.isDevMode) return;
        
        const selectElement = e.target;
        const newValue = selectElement.value;
        
        // Parse context and save immediately
        const context = UnifiedEditor.parseEditContext(selectElement);
        if (context) {
          // Update the data structure
          const success = UnifiedEditor.updateContentInDataStructure(context, newValue);
          if (success) {
            // Update display
            UnifiedEditor.updateElementDisplay(context, newValue);
            
            // Save to storage
            EventBus.emit(Events.STORAGE_SAVE);
            
            // Show notification
            if (JdrApp.modules.ui?.showNotification) {
              JdrApp.modules.ui.showNotification('💾 Élément mis à jour', 'success');
            }
          }
        }
      });

      // Click outside to save
      JdrApp.utils.events.register('click', 'body', (e) => {
        if (!e.target.closest('.editable') && !e.target.matches('.edit-btn')) {
          UnifiedEditor.saveAllEdits();
        }
      });

      // Keyboard shortcuts
      JdrApp.utils.events.register('keydown', '.editable', (e) => {
        if ((e.key === 'Enter' && !e.shiftKey) || e.key === 'Escape') {
          e.preventDefault();
          UnifiedEditor.saveCurrentEdit();
        }
      });

      // Prevent double-click editing (force button-only editing)
      JdrApp.utils.events.register('dblclick', '.editable', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      });
    },

    setupCreationHandlers() {
      // Unified subclass management
      JdrApp.utils.events.register('click', '.add-subclass-btn', (e) => {
        if (!this.isDevMode) return;
        this.addNewSubclass(e.target);
      });

      JdrApp.utils.events.register('click', '.delete-subclass-btn', (e) => {
        if (!this.isDevMode) return;
        this.deleteSubclass(e.target);
      });
    },

    addNewSubclass(button) {
      const article = button.closest('article');
      if (!article) return;
      
      let className = article.dataset.pageTitle;
      if (!className) {
        const hash = window.location.hash.match(/#\/([^\/]+)/);
        if (hash) {
          className = hash[1].charAt(0).toUpperCase() + hash[1].slice(1);
        }
      }
      
      
      if (!className || !window.CLASSES) {
        return;
      }
      
      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe) {
        return;
      }
      
      const config = window.ContentTypes.subclass;
      const newSubclass = { ...config.defaultValues };
      
      
      if (!classe.sousClasses) classe.sousClasses = [];
      classe.sousClasses.push(newSubclass);
      
      
      EventBus.emit(Events.CONTENT_ADD, {
        type: 'subclass',
        category: className,
        item: newSubclass
      });
      
      // Recharger juste le contenu de l'article au lieu de toute la page
      this.reloadClassPage(className);
    },

    deleteSubclass(button) {
      const className = button.dataset.className;
      const subclassName = button.dataset.subclassName;
      
      if (!className || !subclassName) return;
      if (!confirm(`Êtes-vous sûr de vouloir supprimer la sous-classe "${subclassName}" ?`)) return;

      const classe = window.CLASSES?.find(c => c.nom === className);
      if (!classe?.sousClasses) return;

      const index = classe.sousClasses.findIndex(sc => sc.nom === subclassName);
      if (index === -1) return;

      const deletedSubclass = classe.sousClasses.splice(index, 1)[0];
      
      EventBus.emit(Events.CONTENT_DELETE, {
        type: 'subclass',
        category: className,
        item: deletedSubclass
      });
      
      // Recharger juste le contenu de l'article au lieu de toute la page  
      this.reloadClassPage(className);
    },

    reloadClassPage(className) {
      // Trouver l'article de la classe
      const article = document.querySelector(`article[data-page-title="${className}"]`);
      if (!article) return;

      // Régénérer le contenu de la classe
      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe) return;

      // Vérifier que PageBuilder existe
      if (!window.PageBuilder) {
        console.error('PageBuilder not available, falling back to page reload');
        window.location.reload();
        return;
      }

      // Utiliser PageBuilder pour régénérer le contenu
      const newContent = window.PageBuilder.buildClassPage(classe);
      const parser = new DOMParser();
      const newDoc = parser.parseFromString(newContent, 'text/html');
      const newArticle = newDoc.querySelector('article');
      
      if (newArticle) {
        article.innerHTML = newArticle.innerHTML;
        
        // Réappliquer les images et l'état de dev mode
        setTimeout(() => {
          if (JdrApp.modules.renderer?.autoLoadImages) {
            JdrApp.modules.renderer.autoLoadImages();
          }
          // Apply dev mode state properly
          if (this.isDevMode) {
            this.forceShowAllEditButtons();
          } else {
            this.forceHideAllEditButtons();
          }
        }, 50);
      }
    },

    setupImageHandlers() {
      // Fonction pour attacher les événements aux images existantes
      this.attachImageEvents();
      
      // Observer pour attacher les événements aux nouvelles images créées dynamiquement
      if (typeof MutationObserver !== 'undefined') {
        const observer = new MutationObserver(() => {
          this.attachImageEvents();
        });
        observer.observe(document.body, { childList: true, subtree: true });
      }
      
      // Force l'attachement après un délai pour s'assurer que les images lazy sont chargées
      setTimeout(() => {
        this.attachImageEvents();
      }, 2000);
    },

    attachImageEvents() {
      // Attacher aux inputs de fichier
      document.querySelectorAll('.illus input[type="file"]').forEach(input => {
        if (!input.hasAttribute('data-events-attached')) {
          input.addEventListener('change', (e) => this.handleImageUpload(e));
          input.setAttribute('data-events-attached', 'true');
        }
      });

      // Attacher aux boutons de suppression
      document.querySelectorAll('.illus .rm').forEach(button => {
        if (!button.hasAttribute('data-events-attached')) {
          button.addEventListener('click', (e) => this.handleImageRemoval(e));
          button.setAttribute('data-events-attached', 'true');
        }
      });

      // Attacher aux images pour agrandissement - toutes les images, pas seulement celles dans .illus
      const images = document.querySelectorAll('img');
      
      images.forEach(img => {
        // Éviter les images dans les éditeurs ou les inputs
        if (!img.closest('.editor-content') && !img.hasAttribute('data-events-attached')) {
          
          // Ajouter support tactile pour mobile
          img.addEventListener('click', (e) => {
            this.toggleImageEnlargement(e.target);
          });
          img.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.toggleImageEnlargement(e.target);
          });
          
          // Attendre que l'image lazy soit chargée pour définir le curseur
          img.addEventListener('load', () => {
            if (this.isImageEnlargeable(img)) {
              img.style.cursor = 'zoom-in';
            }
          });
          
          // Si l'image est déjà chargée
          if (img.complete && img.naturalWidth > 0) {
            if (this.isImageEnlargeable(img)) {
              img.style.cursor = 'zoom-in';
            }
          }
          
          img.setAttribute('data-events-attached', 'true');
        }
      });
    },

    handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const illus = event.target.closest('.illus');
        const img = illus.querySelector('img');
        const rmButton = illus.querySelector('.rm');
        const illusKey = illus.dataset.illusKey;

        img.src = e.target.result;
        img.style.display = 'block';
        if (rmButton) rmButton.style.display = 'block';

        if (JdrApp.modules.images?.setImageUrl) {
          JdrApp.modules.images.setImageUrl(illusKey, e.target.result);
        }

        EventBus.emit(Events.IMAGE_UPLOAD, { 
          illusKey, 
          src: e.target.result 
        });
      };
      
      reader.readAsDataURL(file);
    },

    handleImageRemoval(event) {
      const illus = event.target.closest('.illus');
      const img = illus.querySelector('img');
      const rmButton = illus.querySelector('.rm');
      const illusKey = illus.dataset.illusKey;

      img.src = '';
      img.style.display = 'none';
      if (rmButton) rmButton.style.display = 'none';

      if (JdrApp.modules.images?.removeImage) {
        JdrApp.modules.images.removeImage(illusKey);
      }

      EventBus.emit(Events.IMAGE_DELETE, { illusKey });
    },

    toggleImageEnlargement(img) {
      // Vérifier si l'image est valide pour l'agrandissement
      if (!this.isImageEnlargeable(img)) {
        return;
      }
      
      if (img.classList.contains('enlarged')) {
        this.closeEnlargedImage();
      } else {
        this.showEnlargedImage(img);
      }
    },

    // Vérifier si une image peut être agrandie
    isImageEnlargeable(img) {
      // Ne pas agrandir les placeholders SVG
      if (img.src && img.src.startsWith('data:image/svg+xml')) {
        return false;
      }
      
      // Ne pas agrandir si pas de source réelle
      if (!img.src && !img.getAttribute('data-src')) {
        return false;
      }
      
      // Ne pas agrandir les images trop petites (probablement des icônes)
      if (img.naturalWidth < 50 || img.naturalHeight < 50) {
        return false;
      }
      
      return true;
    },

    showEnlargedImage(img) {
      // Fermer toute image déjà ouverte
      this.closeEnlargedImage();
      
      // Créer un conteneur modal complet
      const modal = document.createElement('div');
      modal.id = 'image-enlargement-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0,0,0,0.8);
        z-index: 2147483647;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: zoom-out;
      `;
      
      // Créer une copie de l'image
      const enlargedImg = img.cloneNode(true);
      
      // Extraire l'URL originale pour le chargement haute résolution
      let originalUrl = img.src;
      if (img.hasAttribute('data-src') && !enlargedImg.src) {
        originalUrl = img.getAttribute('data-src');
      }
      
      // Si l'image utilise le service weserv.nl, extraire l'URL originale haute résolution
      if (originalUrl.includes('images.weserv.nl')) {
        const urlParams = new URLSearchParams(originalUrl.split('?')[1]);
        const encodedOriginal = urlParams.get('url');
        if (encodedOriginal) {
          originalUrl = decodeURIComponent(encodedOriginal);
        }
      }
      
      // Charger l'image haute résolution SEULEMENT maintenant
      enlargedImg.src = originalUrl;
      enlargedImg.removeAttribute('data-src');
      
      // Supprimer les classes de lazy loading qui pourraient interférer
      enlargedImg.classList.remove('lazy-load', 'lazy-loaded');
      
      enlargedImg.style.cssText = `
        max-width: 90vw;
        max-height: 90vh;
        width: auto;
        height: auto;
        object-fit: contain;
        border: 3px solid var(--gold);
        border-radius: 8px;
        background: white;
        box-shadow: 0 20px 60px rgba(0,0,0,.8), 0 0 20px rgba(212,175,55,.3);
        cursor: zoom-out;
        opacity: 1;
        transition: none;
      `;
      
      modal.appendChild(enlargedImg);
      document.body.appendChild(modal);
      
      // Fermer au clic et au touch pour mobile
      modal.onclick = () => this.closeEnlargedImage();
      modal.addEventListener('touchend', (e) => {
        if (e.target === modal) {
          e.preventDefault();
          this.closeEnlargedImage();
        }
      });
      
      // Fermer avec Échap
      const escapeHandler = (e) => {
        if (e.key === 'Escape') {
          this.closeEnlargedImage();
          document.removeEventListener('keydown', escapeHandler);
        }
      };
      document.addEventListener('keydown', escapeHandler);
      
      // Marquer l'image originale comme agrandie
      img.classList.add('enlarged');
    },

    closeEnlargedImage() {
      const modal = document.getElementById('image-enlargement-modal');
      if (modal) {
        modal.remove();
      }
      
      // Retirer la classe de toutes les images
      document.querySelectorAll('img.enlarged').forEach(img => {
        img.classList.remove('enlarged');
      });
      
      // Nettoyer les anciens backdrops
      const oldBackdrop = document.querySelector('.image-backdrop');
      if (oldBackdrop) {
        oldBackdrop.remove();
      }
    },


    saveChangesToStorage() {
      try {
        localStorage.setItem('jdr-bab-edits', JSON.stringify(this.editedData));
        localStorage.setItem('jdr-bab-last-modified', Date.now().toString());
        EventBus.emit(Events.STORAGE_SAVE);
      } catch (error) {
        // Failed to save changes
      }
    },

    forceCollectAllEdits() {
      // Collect page description edits before general edits
      this.collectPageDescriptionEdits();
      UnifiedEditor.saveAllEdits();
      return this.editedData;
    },

    collectPageDescriptionEdits() {
      // Check for edited table tresor page description
      const tablesTresorsDesc = document.querySelector('[data-section-type="table-tresor-category-description"] .editable');
      if (tablesTresorsDesc && tablesTresorsDesc.innerHTML) {
        const content = tablesTresorsDesc.innerHTML.trim();
        if (content && content !== "Tables de butin permettant de générer aléatoirement des récompenses selon les fourchettes définies. Lancez un dé 20 et consultez la table correspondante pour déterminer l'objet obtenu.") {
          if (!window.TABLES_TRESORS_PAGE_DESC) {
            window.TABLES_TRESORS_PAGE_DESC = {};
          }
          window.TABLES_TRESORS_PAGE_DESC.description = content;
        }
      }

      // Check for edited monster page description
      const monstersDesc = document.querySelector('[data-section-type="monster-category-description"] .editable');
      if (monstersDesc && monstersDesc.innerHTML) {
        const content = monstersDesc.innerHTML.trim();
        if (content && content !== "Créatures, ennemis et adversaires que peuvent affronter les héros dans leurs aventures.") {
          if (!window.MONSTRES_PAGE_DESC) {
            window.MONSTRES_PAGE_DESC = {};
          }
          window.MONSTRES_PAGE_DESC.description = content;
        }
      }
    },


    saveAllEdits() {
      return UnifiedEditor.saveAllEdits();
    },

    regenerateCurrentPage() {
      // Force regeneration of only the current page content (not all pages)
      if (JdrApp.modules.renderer && JdrApp.modules.renderer.regenerateCurrentPage) {
        JdrApp.modules.renderer.regenerateCurrentPage();
      }
    },

    initializeDevToolbox(devToolbox) {
      // Check if toolbox already has content and preserve it
      const existingContent = devToolbox.querySelector('.dev-toolbox-content');
      if (existingContent) {
        // Toolbox already initialized, don't override
        return;
      }

      // Store any existing content that might be there from other modules
      const existingHTML = devToolbox.innerHTML.trim();
      const hasExistingContent = existingHTML && 
        existingHTML !== '<!-- Dev toolbox content will be injected here -->' && 
        existingHTML !== '';

      // If there was existing content, preserve it without adding treasure tools
      if (hasExistingContent) {
        // Keep existing content as-is, don't add our tools
        return;
      } else {
        // Toolbox is empty, don't initialize anything for now
        // This keeps the toolbox clean as requested
        devToolbox.innerHTML = '<!-- Dev toolbox: tools removed as requested -->';
      }
    },

    setupDevToolboxEventListeners() {
      // No toolbox event listeners needed for now
      // Toolbox tools have been removed as requested
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - UI UTILITIES MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // UI UTILITIES - HELPER FUNCTIONS
  // ========================================
  window.UIUtilities = {
    /**
     * Remove HTML tags from text content
     */
    stripHtml(html) {
      const tmp = document.createElement('div');
      tmp.innerHTML = html || '';
      return tmp.textContent || tmp.innerText || '';
    },

    /**
     * Get optimized color for element type
     */
    getElementColor(element) {
      // Couleurs optimisées pour la lisibilité sur fond clair et foncé
      const colorMap = {
        'Feu': '#e25822',        // Rouge-orange vif
        'Eau': '#2563eb',        // Bleu vif
        'Terre': '#92400e',      // Marron foncé
        'Air': '#059669',        // Vert émeraude
        'Lumière': '#d97706',    // Orange doré (au lieu du jaune pâle)
        'Nuit': '#6b21a8',       // Violet foncé (au lieu du noir)
        'Divin': '#7c2d12',      // Marron doré (au lieu du blanc)
        'Maléfique': '#7c3aed'   // Violet intense
      };
      
      return colorMap[element] || '#666666';
    },

    /**
     * Get icon for element type
     */
    getElementIcon(element) {
      const icons = window.ElementIcons || {};
      return icons[element] || '⚡';
    },

    /**
     * Copy text to clipboard with notification
     */
    copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        this.showNotification('📋 Copié dans le presse-papiers', 'success');
      }).catch(() => {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        this.showNotification('📋 Copié dans le presse-papiers', 'success');
      });
    },

    /**
     * Show notification message
     */
    showNotification(message, type = 'info') {
      EventBus.emit(Events.NOTIFICATION_SHOW, { message, type });
      
      // Fallback notification if storage module is not available
      if (!JdrApp.modules.storage?.showNotification) {
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: ${type === 'success' ? '#10B981' : type === 'error' ? '#EF4444' : '#3B82F6'};
          color: white;
          padding: 12px 16px;
          border-radius: 8px;
          font-weight: 500;
          z-index: 10000;
          animation: slideIn 0.3s ease;
        `;
        
        notification.textContent = message;
        document.body.appendChild(notification);
        
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 3000);
      } else {
        JdrApp.modules.storage.showNotification(message, type);
      }
    },

    /**
     * Get current page ID from DOM
     */
    getCurrentPageId() {
      // Find the currently visible article (not hidden)
      const articles = document.querySelectorAll('article[data-static-page="true"]');
      let visibleArticle = null;
      
      for (const article of articles) {
        const style = window.getComputedStyle(article);
        if (style.display !== 'none' && style.visibility !== 'hidden') {
          visibleArticle = article;
          break;
        }
      }
      
      // Fallback: check if main content area exists and extract from URL or DOM
      if (!visibleArticle) {
        const hash = window.location.hash.substring(1);
        if (hash.startsWith('/')) {
          return hash.substring(1) || 'creation';
        }
        return 'creation';
      }
      
      return visibleArticle.id || 'creation';
    },

    /**
     * Force page refresh via router
     */
    forcePageRefresh() {
      // Trigger router to completely rebuild the page
      if (JdrApp.modules?.router?.handleRoute) {
        JdrApp.modules.router.handleRoute();
      } else {
        // Fallback: reload the page
        window.location.reload();
      }
    },

    /**
     * Trigger data save to localStorage/persistent storage
     */
    triggerDataSave() {
      EventBus.emit(Events.STORAGE_SAVE);
    },

    /**
     * Extract content type from CSS class name
     */
    extractTypeFromClass(className) {
      const matches = className.match(/(spell|don|objet|monster|tableTresor|class)-/);
      return matches ? matches[1] : null;
    },

    /**
     * Refresh specific page types
     */
    refreshObjectsPage() {
      if (window.location.hash === '#/objets') {
        this.forcePageRefresh();
      }
    },

    refreshMonstersPage() {
      if (window.location.hash === '#/monstres') {
        this.forcePageRefresh();
      }
    },

    refreshTablesPage() {
      if (window.location.hash === '#/tables-tresors') {
        this.forcePageRefresh();
      }
    },

    /**
     * Generate unique readable ID for new elements
     */
    generateUniqueId(prefix = 'element') {
      const timestamp = Date.now();
      const random = Math.random().toString(36).substring(2, 8);
      return `${prefix}-${timestamp}-${random}`;
    },

    /**
     * Slugify text for URL-safe IDs
     */
    slugify(text) {
      return text.toLowerCase()
        .replace(/[àáâãäå]/g, 'a')
        .replace(/[èéêë]/g, 'e')
        .replace(/[ìíîï]/g, 'i')
        .replace(/[òóôõö]/g, 'o')
        .replace(/[ùúûü]/g, 'u')
        .replace(/[ýÿ]/g, 'y')
        .replace(/[ñ]/g, 'n')
        .replace(/[ç]/g, 'c')
        .replace(/[^a-z0-9]/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '');
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - BASE MODAL CLASS
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // BASE MODAL - GENERIC MODAL MANAGEMENT
  // ========================================
  window.BaseModal = {
    /**
     * Initialize modal system event listeners
     */
    init() {
      this.setupModalEventListeners();
    },

    /**
     * Setup global modal event listeners
     */
    setupModalEventListeners() {
      // Close modal on overlay click or close button
      JdrApp.utils.events.register('click', '.modal-overlay, .modal-close', (e) => {
        const modal = e.target.closest('.modal') || document.querySelector('.modal.visible');
        if (modal) {
          this.closeModal(modal);
        }
      });

      // Prevent modal content clicks from closing modal
      JdrApp.utils.events.register('click', '.modal-content', (e) => {
        e.stopPropagation();
      });

      // Close modal on Escape key
      JdrApp.utils.events.register('keydown', 'body', (e) => {
        if (e.key === 'Escape') {
          const openModal = document.querySelector('.modal.visible');
          if (openModal) {
            this.closeModal(openModal);
          }
        }
      });

      // EventBus integration
      EventBus.on(Events.MODAL_OPEN, (payload) => {
        this.openModal(payload.modalId);
      });

      EventBus.on(Events.MODAL_CLOSE, (payload) => {
        const modal = payload.modal || document.querySelector('.modal.visible');
        if (modal) {
          this.closeModal(modal);
        }
      });
    },

    /**
     * Create a generic modal with common structure
     */
    createModal(id, title, content, options = {}) {
      const modal = document.createElement('div');
      modal.id = id;
      modal.className = 'modal';
      modal.style.display = 'none';

      const isDialog = options.useDialog !== false;
      
      if (isDialog) {
        modal.innerHTML = `
          <div class="modal-overlay">
            <div class="modal-content">
              <div class="modal-header">
                <h3>${title}</h3>
                <button class="modal-close" type="button">✕</button>
              </div>
              <div class="modal-body">
                ${content}
              </div>
              ${options.footer ? `<div class="modal-footer">${options.footer}</div>` : ''}
            </div>
          </div>
        `;
      } else {
        // For dialog elements
        modal.innerHTML = `
          <div class="modal-header">
            <h3>${title}</h3>
            <button class="modal-close" type="button">✕</button>
          </div>
          <div class="modal-body">
            ${content}
          </div>
          ${options.footer ? `<div class="modal-footer">${options.footer}</div>` : ''}
        `;
      }

      return modal;
    },

    /**
     * Open modal by ID or element
     */
    openModal(modalId) {
      const modal = typeof modalId === 'string' 
        ? JdrApp.utils.dom.$(`#${modalId}`) 
        : modalId;
        
      if (modal) {
        if (modal.tagName === 'DIALOG') {
          modal.showModal();
        } else {
          modal.classList.add('visible');
          modal.style.display = 'flex';
        }
        
        // Focus first input element
        const firstInput = modal.querySelector('input, textarea, select');
        if (firstInput) {
          setTimeout(() => firstInput.focus(), 100);
        }

        // Emit event
        EventBus.emit(Events.MODAL_OPENED, { modal, modalId });
      }
    },

    /**
     * Close modal
     */
    closeModal(modal) {
      if (modal) {
        if (modal.tagName === 'DIALOG') {
          modal.close();
        } else {
          modal.classList.remove('visible');
          modal.style.display = 'none';
        }
        
        // Reset form if present
        const form = modal.querySelector('form');
        if (form) {
          form.reset();
        }

        // Emit event
        EventBus.emit(Events.MODAL_CLOSED, { modal });
      }
    },

    /**
     * Remove modal from DOM
     */
    destroyModal(modalId) {
      const modal = typeof modalId === 'string' 
        ? JdrApp.utils.dom.$(`#${modalId}`) 
        : modalId;
        
      if (modal) {
        this.closeModal(modal);
        if (modal.parentNode) {
          modal.parentNode.removeChild(modal);
        }
      }
    },

    /**
     * Show confirmation dialog
     */
    showConfirmation(message, title = 'Confirmation', onConfirm = null, onCancel = null) {
      const modalId = 'confirmationModal';
      
      // Remove existing confirmation modal
      this.destroyModal(modalId);

      const content = `
        <p style="margin-bottom: 20px;">${message}</p>
      `;

      const footer = `
        <button type="button" class="btn btn-secondary" id="cancelBtn">Annuler</button>
        <button type="button" class="btn btn-danger" id="confirmBtn">Confirmer</button>
      `;

      const modal = this.createModal(modalId, title, content, { footer });
      document.body.appendChild(modal);

      // Setup button handlers
      const confirmBtn = modal.querySelector('#confirmBtn');
      const cancelBtn = modal.querySelector('#cancelBtn');

      const handleConfirm = () => {
        if (onConfirm) onConfirm();
        this.closeModal(modal);
        this.destroyModal(modal);
      };

      const handleCancel = () => {
        if (onCancel) onCancel();
        this.closeModal(modal);
        this.destroyModal(modal);
      };

      confirmBtn.addEventListener('click', handleConfirm);
      cancelBtn.addEventListener('click', handleCancel);

      this.openModal(modalId);
      
      return modal;
    },

    /**
     * Show input dialog
     */
    showInput(message, title = 'Saisie', defaultValue = '', onSubmit = null, onCancel = null) {
      const modalId = 'inputModal';
      
      // Remove existing input modal
      this.destroyModal(modalId);

      const content = `
        <label style="display: block; margin-bottom: 10px;">${message}</label>
        <input type="text" id="inputValue" value="${defaultValue}" style="width: 100%; padding: 8px; margin-bottom: 20px;" />
      `;

      const footer = `
        <button type="button" class="btn btn-secondary" id="cancelBtn">Annuler</button>
        <button type="button" class="btn btn-primary" id="submitBtn">Valider</button>
      `;

      const modal = this.createModal(modalId, title, content, { footer });
      document.body.appendChild(modal);

      const inputElement = modal.querySelector('#inputValue');
      const submitBtn = modal.querySelector('#submitBtn');
      const cancelBtn = modal.querySelector('#cancelBtn');

      const handleSubmit = () => {
        const value = inputElement.value.trim();
        if (onSubmit) onSubmit(value);
        this.closeModal(modal);
        this.destroyModal(modal);
      };

      const handleCancel = () => {
        if (onCancel) onCancel();
        this.closeModal(modal);
        this.destroyModal(modal);
      };

      submitBtn.addEventListener('click', handleSubmit);
      cancelBtn.addEventListener('click', handleCancel);
      
      inputElement.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          handleSubmit();
        }
      });

      this.openModal(modalId);
      inputElement.focus();
      inputElement.select();
      
      return modal;
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - UI CORE MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // UI CORE - INITIALIZATION AND MAIN SETUP
  // ========================================
  window.UICore = {
    _initialized: false,

    /**
     * Initialize UI system - called once at startup
     */
    init() {
      // Prevent multiple initialization to avoid duplicate event listeners
      if (this._initialized) {
        return;
      }
      
      this.setupEventListeners();
      this.setupSearch();
      this.setupModals();
      this.setupResponsive();
      this.setupNewPageHandler();
      this._initialized = true;
      
    },

    /**
     * Setup main EventBus listeners
     */
    setupEventListeners() {
      // Content management via EventBus
      EventBus.on(Events.CONTENT_ADD, (payload) => {
        this.handleContentAdd(payload.type, payload.category, payload.item);
      });

      EventBus.on(Events.CONTENT_DELETE, (payload) => {
        this.handleContentDelete(payload.type, payload.category, payload.item);
      });

      EventBus.on(Events.CONTENT_MOVE, (payload) => {
        this.handleContentMove(payload.type, payload.category, payload.itemName, payload.direction);
      });

      // Delegate UI event handlers to specialized modules
      if (window.EventHandlers) {
        EventHandlers.setupContentHandlers();
        EventHandlers.setupTagsManagement();
      }
    },

    /**
     * Setup search functionality
     */
    setupSearch() {
      const searchInput = JdrApp.utils.dom.$('#search');
      const clearButton = JdrApp.utils.dom.$('#clear');
      
      if (searchInput) {
        // Only search on Enter key press
        JdrApp.utils.events.register('keydown', '#search', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            const query = e.target.value.trim();
            if (query.length > 0) {
              this.performSearch(query);
            } else {
              this.clearMainSearchResults();
            }
          } else if (e.key === 'Escape') {
            this.clearMainSearchResults();
            e.target.value = '';
            e.target.blur();
          }
        });
      }
      
      if (clearButton) {
        JdrApp.utils.events.register('click', '#clear', () => {
          if (searchInput) {
            searchInput.value = '';
            this.clearMainSearchResults();
          }
        });
      }
    },

    /**
     * Setup modal system
     */
    setupModals() {
      // Utilise BaseModal pour la gestion générique des modales
      BaseModal.init();

      // Resource tools
      JdrApp.utils.events.register('click', '#elementsBtn', () => {
        this.showElementsModal();
      });

      JdrApp.utils.events.register('click', '#etatsBtn', () => {
        this.showEtatsModal();
      });

      JdrApp.utils.events.register('click', '#spellLinksBtn', () => {
        this.showSpellLinksModal();
      });

      JdrApp.utils.events.register('click', '#pageLinksBtn', () => {
        this.showPageLinksModal();
      });

      JdrApp.utils.events.register('click', '#monsterLinksBtn', () => {
        this.showMonsterLinksModal();
      });

      // Gestionnaire pour les liens de sorts dans le contenu
      JdrApp.utils.events.register('click', '.spell-link', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const spellName = e.target.dataset.spell;
        const categoryName = e.target.dataset.category;
        this.showSpellPreview(spellName, categoryName, e.target);
      });

      // Gestionnaire pour les liens d'états dans le contenu
      JdrApp.utils.events.register('click', '.etat-link', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const etatName = e.target.dataset.etat;
        
        // Récupérer dynamiquement la description depuis les données statiques
        let etatDescription = '';
        if (window.STATIC_PAGES?.etats?.sections) {
          const etatSection = window.STATIC_PAGES.etats.sections.find(section => 
            section.type === 'card' && section.title === etatName
          );
          if (etatSection) {
            // Convertir le HTML en texte propre
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = etatSection.content;
            tempDiv.innerHTML = tempDiv.innerHTML
              .replace(/<\/p>/gi, '\n')
              .replace(/<br\s*\/?>/gi, '\n')
              .replace(/<\/li>/gi, '\n')
              .replace(/<\/div>/gi, '\n');
            etatDescription = (tempDiv.textContent || tempDiv.innerText || etatSection.content)
              .replace(/\n\s*\n/g, '\n')
              .trim();
          }
        }
        
        this.showEtatPreview(etatName, etatDescription, e.target);
      });

      // Gestionnaire pour les liens de monstres dans le contenu
      JdrApp.utils.events.register('click', '.monster-link', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const monsterName = e.target.dataset.monster;
        this.showMonsterPreview(monsterName, e.target, e);
      });
    },

    /**
     * Setup responsive design
     */
    setupResponsive() {
      this.setupMobileNavigation();
      this.setupLegacyResponsive();
    },

    /**
     * Setup new page creation handler
     */
    setupNewPageHandler() {
      // Setup section selection modal for new page creation
      JdrApp.utils.events.register('click', '.new-page-button', (e) => {
        this.showSectionSelectionModal();
      });
    },

    /**
     * Content event handlers - delegated from EventBus
     */
    handleContentAdd(type, category, item) {
      // Additional handling after content is added
      setTimeout(() => {
        if (JdrApp.modules.renderer?.autoLoadImages) {
          JdrApp.modules.renderer.autoLoadImages();
        }
      }, 100);
    },

    handleContentDelete(type, category, item) {
      // Cleanup after content deletion
    },

    handleContentMove(type, category, itemName, direction) {
      // Additional handling after content is moved
    },

    /**
     * Delegate method calls to appropriate modules
     */
    performSearch(query) {
      if (window.SearchManager) {
        return SearchManager.performSearch(query);
      }
      // Fallback to ui.js method if SearchManager not available yet
      if (JdrApp.modules.ui?.performSearch) {
        return JdrApp.modules.ui.performSearch(query);
      }
    },

    clearMainSearchResults() {
      if (window.SearchManager) {
        return SearchManager.clearMainSearchResults();
      }
      // Fallback to ui.js method
      if (JdrApp.modules.ui?.clearMainSearchResults) {
        return JdrApp.modules.ui.clearMainSearchResults();
      }
    },

    // Modal methods - delegate to ModalManager
    showElementsModal() {
      if (window.ModalManager) {
        return ModalManager.showElementsModal();
      }
      if (JdrApp.modules.ui?.showElementsModal) {
        return JdrApp.modules.ui.showElementsModal();
      }
    },

    showEtatsModal() {
      if (window.ModalManager) {
        return ModalManager.showEtatsModal();
      }
      if (JdrApp.modules.ui?.showEtatsModal) {
        return JdrApp.modules.ui.showEtatsModal();
      }
    },

    showSpellLinksModal() {
      if (window.ModalManager) {
        return ModalManager.showSpellLinksModal();
      }
      if (JdrApp.modules.ui?.showSpellLinksModal) {
        return JdrApp.modules.ui.showSpellLinksModal();
      }
    },

    showPageLinksModal() {
      if (window.ModalManager) {
        return ModalManager.showPageLinksModal();
      }
      if (JdrApp.modules.ui?.showPageLinksModal) {
        return JdrApp.modules.ui.showPageLinksModal();
      }
    },

    showMonsterLinksModal() {
      if (window.ModalManager) {
        return ModalManager.showMonsterLinksModal();
      }
      if (JdrApp.modules.ui?.showMonsterLinksModal) {
        return JdrApp.modules.ui.showMonsterLinksModal();
      }
    },

    showSpellPreview(spellName, categoryName, triggerElement) {
      if (JdrApp.modules.ui?.showSpellPreview) {
        return JdrApp.modules.ui.showSpellPreview(spellName, categoryName, triggerElement);
      }
    },

    showEtatPreview(etatName, etatDescription, triggerElement) {
      if (JdrApp.modules.ui?.showEtatPreview) {
        return JdrApp.modules.ui.showEtatPreview(etatName, etatDescription, triggerElement);
      }
    },

    showMonsterPreview(monsterName, triggerElement, event) {
      if (JdrApp.modules.ui?.showMonsterPreview) {
        return JdrApp.modules.ui.showMonsterPreview(monsterName, triggerElement, event);
      }
    },

    setupMobileNavigation() {
      if (window.ResponsiveManager) {
        return ResponsiveManager.setupMobileNavigation();
      }
      if (JdrApp.modules.ui?.setupMobileNavigation) {
        return JdrApp.modules.ui.setupMobileNavigation();
      }
    },

    setupLegacyResponsive() {
      if (window.ResponsiveManager) {
        return ResponsiveManager.setupLegacyResponsive();
      }
      if (JdrApp.modules.ui?.setupLegacyResponsive) {
        return JdrApp.modules.ui.setupLegacyResponsive();
      }
    },

    showSectionSelectionModal() {
      if (window.PageManager) {
        return PageManager.showSectionSelectionModal();
      }
      if (JdrApp.modules.ui?.showSectionSelectionModal) {
        return JdrApp.modules.ui.showSectionSelectionModal();
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - EVENT HANDLERS MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // EVENT HANDLERS - UI EVENT DELEGATION
  // ========================================
  window.EventHandlers = {

    /**
     * Setup content-related event handlers
     */
    setupContentHandlers() {
      // Generic content addition
      JdrApp.utils.events.register('click', '[class$="-add"]', (e) => {
        const type = UIUtilities.extractTypeFromClass(e.target.className);
        const categoryName = e.target.dataset.categoryName;
        
        if (type && categoryName) {
          this.delegateToUI('addContent', type, categoryName);
        }
      });

      // Generic content deletion - using multiple specific selectors
      JdrApp.utils.events.register('click', '.spell-delete, .don-delete, .delete-subclass-btn, .objet-delete, .monster-delete, .tableTresor-delete', (e) => {
        const type = UIUtilities.extractTypeFromClass(e.target.className);
        const categoryName = e.target.dataset.categoryName;
        
        // Handle different dataset attribute naming patterns
        const itemName = this.extractItemName(e.target, type);
        
        if (type && categoryName && itemName) {
          this.delegateToUI('deleteContent', type, categoryName, itemName);
        }
      });

      // Generic content movement
      JdrApp.utils.events.register('click', '[class*="-move-"]', (e) => {
        const type = UIUtilities.extractTypeFromClass(e.target.className);
        const categoryName = e.target.dataset.categoryName;
        const itemName = this.extractItemName(e.target, type);
        const direction = e.target.className.includes('move-up') ? -1 : 1;
        
        if (type && categoryName && itemName) {
          this.delegateToUI('moveContent', type, categoryName, itemName, direction);
        }
      });

      // Filter manager button for objects
      JdrApp.utils.events.register('click', '.filter-manager-btn', () => {
        this.delegateToUI('showFilterManagementModal');
      });

      // Tags manager button for objects
      JdrApp.utils.events.register('click', '.tags-manager-btn', () => {
        this.delegateToUI('showTagsManagementModal');
      });

      // Filter chip toggle for objects - DISABLED (handled by core.js now)
      // JdrApp.utils.events.register('click', '.filter-chip', (e) => {
      //   e.preventDefault();
      //   e.stopPropagation();
      //   this.delegateToUI('toggleFilter', e.target);
      // });

      // Select all tags button
      JdrApp.utils.events.register('click', '#select-all-tags', () => {
        this.delegateToUI('selectAllTags');
      });

      // Select no tags button
      JdrApp.utils.events.register('click', '#select-no-tags', () => {
        this.delegateToUI('selectNoTags');
      });

      // ID search functionality (only on Enter key or button click)
      JdrApp.utils.events.register('keydown', '#id-search-input', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          this.delegateToUI('performIdSearch', e.target.value);
        } else if (e.key === 'Escape') {
          e.target.value = '';
          this.delegateToUI('clearIdSearch');
        }
      });

      JdrApp.utils.events.register('click', '#clear-id-search', () => {
        this.delegateToUI('clearIdSearch');
      });

      // Spell element change
      JdrApp.utils.events.register('change', '.spell-element-selector select', (e) => {
        this.delegateToUI('updateSpellElement', e.target);
      });

      // Paragraph addition
      JdrApp.utils.events.register('click', '.add-paragraph-btn', (e) => {
        const target = e.target.dataset.target;
        this.delegateToUI('addParagraph', target, e.target);
      });

      // Section deletion for static pages
      JdrApp.utils.events.register('click', '.section-delete', (e) => {
        const sectionName = e.target.dataset.sectionName;
        if (sectionName && confirm(`Supprimer la section "${sectionName}" ?`)) {
          this.delegateToUI('deleteSection', sectionName, e.target);
        }
      });

      // Dev toolbox category creation buttons
      JdrApp.utils.events.register('click', '#addSpellCategory', () => {
        this.delegateToUI('createNewCategory', 'spell');
      });

      JdrApp.utils.events.register('click', '#addDonCategory', () => {
        this.delegateToUI('createNewCategory', 'don');
      });

      // Category deletion buttons
      JdrApp.utils.events.register('click', '[class$="-category-delete"]', (e) => {
        const categoryName = e.target.dataset.categoryName;
        const categoryType = e.target.dataset.categoryType;
        
        if (categoryName && categoryType) {
          this.delegateToUI('deleteCategory', categoryType, categoryName);
        }
      });

      // Print button for states page
      JdrApp.utils.events.register('click', '#print-states', () => {
        window.print();
      });
    },

    /**
     * Setup tags management event handlers
     */
    setupTagsManagement() {
      // Tables de trésors - Edition des fourchettes
      JdrApp.utils.events.register('click', '.edit-fourchette-btn', (e) => {
        const tableName = e.target.dataset.tableName;
        const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
        
        if (tableName && fourchetteIndex >= 0) {
          this.delegateToUI('editFourchette', tableName, fourchetteIndex);
        }
      });

      // Tables de trésors - Suppression des fourchettes
      JdrApp.utils.events.register('click', '.delete-fourchette-btn', (e) => {
        const tableName = e.target.dataset.tableName;
        const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
        
        if (tableName && fourchetteIndex >= 0) {
          if (confirm('Êtes-vous sûr de vouloir supprimer cette fourchette ?')) {
            this.delegateToUI('deleteFourchette', tableName, fourchetteIndex);
          }
        }
      });

      // Tables de trésors - Déplacement des fourchettes vers le haut
      JdrApp.utils.events.register('click', '.move-fourchette-up-btn', (e) => {
        const tableName = e.target.dataset.tableName;
        const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
        
        if (tableName && fourchetteIndex > 0) {
          this.delegateToUI('moveFourchette', tableName, fourchetteIndex, fourchetteIndex - 1);
        }
      });

      // Tables de trésors - Déplacement des fourchettes vers le bas
      JdrApp.utils.events.register('click', '.move-fourchette-down-btn', (e) => {
        const tableName = e.target.dataset.tableName;
        const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
        
        if (tableName && fourchetteIndex >= 0) {
          this.delegateToUI('moveFourchette', tableName, fourchetteIndex, fourchetteIndex + 1);
        }
      });

      // Tables de trésors - Ajout de fourchettes
      JdrApp.utils.events.register('click', '.table-tresor-add-fourchette', (e) => {
        const tableName = e.target.dataset.tableTresorName;
        
        if (tableName) {
          this.delegateToUI('addFourchette', tableName);
        }
      });

      // Tables de trésors - Prévisualisation des objets (géré par TablesTresorsManager)
      // Cette gestion est déjà dans TablesTresorsManager, pas besoin de duplication
    },

    /**
     * Extract item name from element based on type
     */
    extractItemName(element, type) {
      if (type === 'spell') {
        return element.dataset.spellName;
      } else if (type === 'don') {
        return element.dataset.donName;
      } else if (type === 'objet') {
        return element.dataset.objetName;
      } else if (type === 'monster') {
        return element.dataset.monsterName;
      } else if (type === 'tableTresor') {
        return element.dataset.tableTresorName;
      } else if (type === 'class') {
        return element.dataset.className || element.dataset.subclassName;
      } else {
        return element.dataset[`${type}Name`];
      }
    },

    /**
     * Delegate method calls to UI module
     */
    delegateToUI(methodName, ...args) {
      if (JdrApp.modules.ui && typeof JdrApp.modules.ui[methodName] === 'function') {
        return JdrApp.modules.ui[methodName](...args);
      } else {
        console.warn(`UI method ${methodName} not found or not available yet`);
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - CONTENT MANAGER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // CONTENT MANAGER - CRUD OPERATIONS
  // ========================================
  window.ContentManager = {

    /**
     * Add new content item
     */
    addContent(type, categoryName) {
      const config = window.ContentTypes[type];
      if (!config) {
        UIUtilities.showNotification(`❌ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Create new item with default values
      const defaultItem = ContentFactory.createDefaultItem(type);
      
      // Special handling for objects and monsters (add to single array)
      if (type === 'objet') {
        this.addObject(defaultItem);
      } else if (type === 'monster') {
        this.addMonster(defaultItem);
      } else {
        // Standard category-based addition
        this.addStandardContent(type, categoryName, defaultItem);
      }
      
      EventBus.emit(Events.STORAGE_SAVE);
      UIUtilities.showNotification(`${config.icons.add} Nouvel élément ajouté`, 'success');
    },

    /**
     * Add object to objects array
     */
    addObject(defaultItem) {
      if (!window.OBJETS.objets) {
        window.OBJETS.objets = [];
      }
      
      // Get next number
      const existingNumbers = window.OBJETS.objets.map(obj => obj.numero || 0);
      const nextNumber = existingNumbers.length > 0 ? Math.max(...existingNumbers) + 1 : 1;
      defaultItem.numero = nextNumber;
      
      window.OBJETS.objets.push(defaultItem);
      UIUtilities.refreshObjectsPage();
    },

    /**
     * Add monster to monsters array
     */
    addMonster(defaultItem) {
      if (!window.MONSTRES) {
        window.MONSTRES = [];
      }
      
      window.MONSTRES.push(defaultItem);
      UIUtilities.refreshMonstersPage();
    },

    /**
     * Add content using standard category-based approach
     */
    addStandardContent(type, categoryName, defaultItem) {
      const success = ContentFactory.addItem(type, categoryName, defaultItem);
      if (success) {
        EventBus.emit(Events.CONTENT_ADD, {
          type: type,
          category: categoryName,
          item: defaultItem
        });
        
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: type,
          category: ContentFactory.getEntity(type).findCategory(categoryName)
        });
      }
    },

    /**
     * Delete content item
     */
    deleteContent(type, categoryName, itemName) {
      const config = window.ContentTypes[type];
      if (!config) {
        UIUtilities.showNotification(`❌ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      if (!confirm(`Supprimer "${itemName}" ?`)) {
        return;
      }

      // Special handling for objects and monsters
      if (type === 'objet') {
        this.deleteObject(itemName);
      } else if (type === 'monster') {
        this.deleteMonster(itemName);
      } else {
        // Standard category-based deletion
        this.deleteStandardContent(type, categoryName, itemName);
      }
      
      EventBus.emit(Events.STORAGE_SAVE);
      UIUtilities.showNotification(`${config.icons.delete} "${itemName}" supprimé`, 'success');
    },

    /**
     * Delete object from objects array
     */
    deleteObject(itemName) {
      if (window.OBJETS?.objets) {
        const itemIndex = window.OBJETS.objets.findIndex(obj => obj.nom === itemName);
        if (itemIndex >= 0) {
          window.OBJETS.objets.splice(itemIndex, 1);
          UIUtilities.refreshObjectsPage();
        }
      }
    },

    /**
     * Delete monster from monsters array
     */
    deleteMonster(itemName) {
      if (window.MONSTRES) {
        const itemIndex = window.MONSTRES.findIndex(monster => monster.nom === itemName);
        if (itemIndex >= 0) {
          window.MONSTRES.splice(itemIndex, 1);
          UIUtilities.refreshMonstersPage();
        }
      }
    },

    /**
     * Delete content using standard category-based approach
     */
    deleteStandardContent(type, categoryName, itemName) {
      const success = ContentFactory.deleteItem(type, categoryName, itemName);
      if (success) {
        EventBus.emit(Events.CONTENT_DELETE, {
          type: type,
          category: categoryName,
          item: itemName
        });
        
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: type,
          category: ContentFactory.getEntity(type).findCategory(categoryName)
        });
      }
    },

    /**
     * Move content item
     */
    moveContent(type, categoryName, itemName, direction) {
      const config = window.ContentTypes[type];
      if (!config) {
        UIUtilities.showNotification(`❌ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Special handling for objects
      if (type === 'objet') {
        this.moveObject(itemName, direction);
      } else {
        // Standard category-based movement
        this.moveStandardContent(type, categoryName, itemName, direction);
      }
      
      EventBus.emit(Events.STORAGE_SAVE);
      const directionText = direction > 0 ? 'descendu' : 'monté';
      UIUtilities.showNotification(`🔄 "${itemName}" ${directionText}`, 'success');
    },

    /**
     * Move object in objects array
     */
    moveObject(itemName, direction) {
      if (window.OBJETS?.objets) {
        const itemIndex = window.OBJETS.objets.findIndex(obj => obj.nom === itemName);
        if (itemIndex >= 0) {
          const newIndex = itemIndex + direction;
          if (newIndex >= 0 && newIndex < window.OBJETS.objets.length) {
            const item = window.OBJETS.objets.splice(itemIndex, 1)[0];
            window.OBJETS.objets.splice(newIndex, 0, item);
            UIUtilities.refreshObjectsPage();
          }
        }
      }
    },

    /**
     * Move content using standard category-based approach
     */
    moveStandardContent(type, categoryName, itemName, direction) {
      const success = ContentFactory.moveItem(type, categoryName, itemName, direction);
      if (success) {
        EventBus.emit(Events.CONTENT_MOVE, {
          type: type,
          category: categoryName,
          itemName: itemName,
          direction: direction
        });
        
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: type,
          category: ContentFactory.getEntity(type).findCategory(categoryName)
        });
      }
    },

    /**
     * Handle content addition post-processing
     */
    handleContentAdd(type, category, item) {
      // Additional handling after content is added
      setTimeout(() => {
        if (JdrApp.modules.renderer?.autoLoadImages) {
          JdrApp.modules.renderer.autoLoadImages();
        }
      }, 100);
    },

    /**
     * Handle content deletion post-processing
     */
    handleContentDelete(type, category, item) {
      // Cleanup after content deletion
    },

    /**
     * Handle content movement post-processing
     */
    handleContentMove(type, category, itemName, direction) {
      // Additional handling after content is moved
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - TAGS MANAGER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // TAGS MANAGER - TAG MANAGEMENT FOR MONSTERS AND TREASURES
  // ========================================
  window.TagsManager = {

    /**
     * Show tags management modal based on content type
     */
    showTagsManagementModal() {
      // Déterminer le type de contenu basé sur la page actuelle
      const currentPage = window.location.hash.replace('#/', '') || 'creation';
      let contentType = 'objet'; // par défaut
      
      if (currentPage === 'monstres') {
        contentType = 'monster';
      } else if (currentPage === 'tables-tresors') {
        contentType = 'tableTresor';
      }

      if (contentType === 'monster') {
        this.showMonsterTagsManagement();
      } else if (contentType === 'tableTresor') {
        this.showTableTresorTagsManagement();
      } else {
        // For objects (legacy support)
        this.showGeneralTagsManagement();
      }
    },

    /**
     * Show monster tags management modal
     */
    showMonsterTagsManagement() {
      const config = window.ContentTypes.monster;
      if (!config || !config.filterConfig) {
        UIUtilities.showNotification('Configuration des tags monstres non trouvée', 'error');
        return;
      }

      // Remove existing modal if any
      const existingModal = document.querySelector('#monsterTagsModal');
      if (existingModal) {
        existingModal.remove();
      }

      const availableTags = config.filterConfig.availableTags || [];
      const modal = this.createMonsterTagsModal(availableTags);
      document.body.appendChild(modal);
      
      // Use native dialog showModal for proper z-index
      modal.showModal();
    },

    /**
     * Show table tresor tags management modal
     */
    showTableTresorTagsManagement() {
      // Priority: Load tags from metadata, then config, then fallback
      let availableTags = [];
      
      if (window.TABLES_TRESORS?._metadata?.availableTags) {
        availableTags = window.TABLES_TRESORS._metadata.availableTags;
      } else {
        // Initialize metadata if missing
        availableTags = ['Forêt', 'Boss', 'Coffre'];
        if (window.TABLES_TRESORS) {
          if (!window.TABLES_TRESORS._metadata) {
            window.TABLES_TRESORS._metadata = {};
          }
          window.TABLES_TRESORS._metadata.availableTags = [...availableTags];
        }
      }

      // Remove existing modal if any
      const existingModal = document.querySelector('#tableTresorTagsModal');
      if (existingModal) {
        existingModal.remove();
      }
      
      const modal = this.createTableTresorTagsModal(availableTags);
      document.body.appendChild(modal);
      modal.showModal();
    },

    /**
     * Show general tags management for objects
     */
    showGeneralTagsManagement() {
      // Delegate to ui.js for now (will be extracted in Phase 4)
      if (JdrApp.modules.ui?.showTagsManagementModal) {
        return JdrApp.modules.ui.showTagsManagementModal();
      }
    },

    /**
     * Create monster tags modal
     */
    createMonsterTagsModal(availableTags) {
      const modal = document.createElement('dialog');
      modal.id = 'monsterTagsModal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        padding: 20px;
        border: none;
        border-radius: 12px;
        background: var(--background);
        color: var(--text);
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      `;

      modal.innerHTML = `
        <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
          <h3 style="margin: 0; color: var(--accent);">🏷️ Gestion des Tags - Monstres</h3>
          <button class="modal-close" style="background: none; border: none; font-size: 20px; cursor: pointer; color: var(--text);">✕</button>
        </div>
        
        <div class="modal-body">
          <div style="margin-bottom: 20px;">
            <h4>Tags Disponibles:</h4>
            <div id="availableTagsList" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px;">
              ${availableTags.map(tag => `
                <span class="tag-item" style="background: var(--accent-dark); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; display: flex; align-items: center; gap: 4px;">
                  ${tag}
                  <button class="delete-tag-btn" data-tag="${tag}" style="background: none; border: none; color: white; cursor: pointer; font-size: 14px;">🗑️</button>
                </span>
              `).join('')}
            </div>
            
            <div style="display: flex; gap: 8px; align-items: center;">
              <input type="text" id="newMonsterTag" placeholder="Nouveau tag..." style="flex: 1; padding: 8px; border: 1px solid var(--border); border-radius: 4px;">
              <button id="addMonsterTagBtn" style="background: var(--accent); color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Ajouter</button>
            </div>
          </div>
        </div>
      `;

      this.setupMonsterTagsModalEvents(modal, availableTags);
      return modal;
    },

    /**
     * Create table tresor tags modal
     */
    createTableTresorTagsModal(availableTags) {
      const modal = document.createElement('dialog');
      modal.id = 'tableTresorTagsModal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        padding: 20px;
        border: none;
        border-radius: 12px;
        background: var(--background);
        color: var(--text);
        box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      `;

      modal.innerHTML = `
        <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
          <h3 style="margin: 0; color: var(--accent);">🏷️ Gestion des Tags - Tables de Trésors</h3>
          <button class="modal-close-btn" style="background: none; border: none; font-size: 20px; cursor: pointer; color: var(--text);">✕</button>
        </div>
        
        <div class="modal-body">
          <div style="margin-bottom: 20px;">
            <h4>Tags Disponibles:</h4>
            <div id="availableTagsList" style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 15px;">
              ${availableTags.map(tag => `
                <span class="tag-item" style="background: var(--accent-dark); color: white; padding: 4px 8px; border-radius: 4px; font-size: 12px; display: flex; align-items: center; gap: 4px;">
                  ${tag}
                  <button class="delete-tag-btn" data-tag="${tag}" style="background: none; border: none; color: white; cursor: pointer; font-size: 14px;">🗑️</button>
                </span>
              `).join('')}
            </div>
            
            <div style="display: flex; gap: 8px; align-items: center;">
              <input type="text" id="newTableTresorTag" placeholder="Nouveau tag..." style="flex: 1; padding: 8px; border: 1px solid var(--border); border-radius: 4px;">
              <button id="addTableTresorTagBtn" style="background: var(--accent); color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer;">Ajouter</button>
            </div>
          </div>
        </div>
      `;

      this.setupTableTresorTagsModalEvents(modal, availableTags);
      return modal;
    },

    /**
     * Setup monster tags modal events
     */
    setupMonsterTagsModalEvents(modal, availableTags) {
      // Close modal
      modal.querySelector('.modal-close').addEventListener('click', () => {
        modal.close();
      });

      // Add new tag
      const addTag = () => {
        const newTagInput = modal.querySelector('#newMonsterTag');
        const newTag = newTagInput.value.trim();
        
        if (newTag && !availableTags.includes(newTag)) {
          // Add to the current available tags
          availableTags.push(newTag);
          
          // Save to the config
          const config = window.ContentTypes.monster;
          config.filterConfig.availableTags = [...availableTags];
          
          // Save changes to storage
          EventBus.emit(Events.STORAGE_SAVE);
          
          modal.close();
          this.showMonsterTagsManagement(); // Refresh modal
          UIUtilities.showNotification(`Tag "${newTag}" ajouté avec succès`, 'success');
        } else if (newTag && availableTags.includes(newTag)) {
          UIUtilities.showNotification('Ce tag existe déjà', 'error');
        }
      };

      const addBtn = modal.querySelector('#addMonsterTagBtn');
      const newTagInput = modal.querySelector('#newMonsterTag');

      addBtn.addEventListener('click', addTag);
      newTagInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          addTag();
        }
      });

      // Delete tag buttons using event delegation
      modal.addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-tag-btn')) {
          const tagToDelete = e.target.dataset.tag;
          
          if (confirm(`Supprimer le tag "${tagToDelete}" ?`)) {
            const config = window.ContentTypes.monster;
            const index = config.filterConfig.availableTags.indexOf(tagToDelete);
            
            if (index > -1) {
              // Remove from available tags
              config.filterConfig.availableTags.splice(index, 1);
              
              // Remove the tag from all monsters
              if (window.MONSTRES) {
                window.MONSTRES.forEach(monster => {
                  if (monster.tags && monster.tags.includes(tagToDelete)) {
                    monster.tags = monster.tags.filter(tag => tag !== tagToDelete);
                    // Ensure monster has at least one tag if possible
                    if (monster.tags.length === 0 && config.filterConfig.availableTags.length > 0) {
                      monster.tags = [config.filterConfig.availableTags[0]];
                    }
                  }
                });
              }
              
              // Save changes
              EventBus.emit(Events.STORAGE_SAVE);
              
              // Refresh modal and monsters page
              modal.close();
              this.showMonsterTagsManagement();
              
              // Force complete page reload for monsters page
              if (window.location.hash === '#/monstres') {
                UIUtilities.forcePageRefresh();
              }
              
              UIUtilities.showNotification(`✅ Tag "${tagToDelete}" supprimé avec succès`, 'success');
            }
          }
        }
      });
    },

    /**
     * Setup table tresor tags modal events
     */
    setupTableTresorTagsModalEvents(modal, availableTags) {
      // Close modal
      const closeButtons = modal.querySelectorAll('.modal-close-btn');
      closeButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          modal.close();
        });
      });

      // Add new tag
      const addTag = () => {
        const newTagInput = modal.querySelector('#newTableTresorTag');
        const newTag = newTagInput.value.trim();
        
        if (newTag && !availableTags.includes(newTag)) {
          // Add to available tags
          availableTags.push(newTag);
          
          // Save in TABLES_TRESORS metadata for persistence
          if (window.TABLES_TRESORS) {
            if (!window.TABLES_TRESORS._metadata) {
              window.TABLES_TRESORS._metadata = {};
            }
            window.TABLES_TRESORS._metadata.availableTags = [...availableTags];
          }
          
          // Save changes
          EventBus.emit(Events.STORAGE_SAVE);
          
          // Refresh modal and page
          modal.close();
          this.showTableTresorTagsManagement();
          
          // Force refresh of the tables-tresors page
          if (window.location.hash === '#/tables-tresors') {
            UIUtilities.forcePageRefresh();
          }
          
          UIUtilities.showNotification(`Tag "${newTag}" ajouté avec succès`, 'success');
        } else if (newTag && availableTags.includes(newTag)) {
          UIUtilities.showNotification('Ce tag existe déjà', 'error');
        }
      };

      const addBtn = modal.querySelector('#addTableTresorTagBtn');
      const newTagInput = modal.querySelector('#newTableTresorTag');

      addBtn.addEventListener('click', addTag);
      newTagInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          addTag();
        }
      });

      // Delete tag functionality
      modal.addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-tag-btn')) {
          const tagToDelete = e.target.dataset.tag;
          
          if (confirm(`Supprimer le tag "${tagToDelete}" ?`)) {
            // Remove from available tags
            const index = availableTags.indexOf(tagToDelete);
            if (index > -1) {
              availableTags.splice(index, 1);
              
              // Remove from all tables that use this tag
              if (window.TABLES_TRESORS?.categories) {
                window.TABLES_TRESORS.categories.forEach(category => {
                  category.tables.forEach(table => {
                    if (table.tags && table.tags.includes(tagToDelete)) {
                      table.tags = table.tags.filter(tag => tag !== tagToDelete);
                    }
                  });
                });
              }
              
              // Save in metadata
              if (window.TABLES_TRESORS) {
                if (!window.TABLES_TRESORS._metadata) {
                  window.TABLES_TRESORS._metadata = {};
                }
                window.TABLES_TRESORS._metadata.availableTags = [...availableTags];
              }
              
              // Save changes
              EventBus.emit(Events.STORAGE_SAVE);
              
              // Close and refresh
              modal.close();
              
              // Force page reload
              if (window.location.hash === '#/tables-tresors') {
                UIUtilities.forcePageRefresh();
              }
              
              setTimeout(() => {
                this.showTableTresorTagsManagement();
              }, 200);
              
              UIUtilities.showNotification(`✅ Tag "${tagToDelete}" supprimé avec succès`, 'success');
            }
          }
        }
      });
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - SEARCH MANAGER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // SEARCH MANAGER - SEARCH FUNCTIONALITY
  // ========================================
  window.SearchManager = {

    /**
     * Perform search across all content types
     */
    performSearch(query) {
      const normalizedQuery = query.toLowerCase().trim();
      
      if (!normalizedQuery) {
        this.clearMainSearchResults();
        return;
      }

      const results = [];
      
      // Search in spells
      if (window.SORTS && Array.isArray(window.SORTS)) {
        window.SORTS.forEach(category => {
          if (category.sorts && Array.isArray(category.sorts)) {
            category.sorts.forEach(spell => {
              if (this.matchesSearch(spell, normalizedQuery)) {
                results.push({
                  type: 'spell',
                  category: category.nom,
                  data: spell,
                  summary: this.generateSpellSummary(spell)
                });
              }
            });
          }
        });
      }

      // Search in dons
      if (window.DONS && Array.isArray(window.DONS)) {
        window.DONS.forEach(category => {
          if (category.dons && Array.isArray(category.dons)) {
            category.dons.forEach(don => {
              if (this.matchesSearch(don, normalizedQuery)) {
                results.push({
                  type: 'don',
                  category: category.nom,
                  data: don,
                  summary: this.generateDonSummary(don)
                });
              }
            });
          }
        });
      }

      // Search in classes
      if (window.CLASSES && Array.isArray(window.CLASSES)) {
        window.CLASSES.forEach(classe => {
          if (this.matchesSearch(classe, normalizedQuery)) {
            results.push({
              type: 'class',
              category: 'Classes',
              data: classe,
              summary: this.generateClassSummary(classe)
            });
          }
          
          // Search in subclasses
          if (classe.sousClasses && Array.isArray(classe.sousClasses)) {
            classe.sousClasses.forEach(sousClasse => {
              if (this.matchesSearch(sousClasse, normalizedQuery)) {
                results.push({
                  type: 'subclass',
                  category: classe.nom,
                  data: sousClasse,
                  summary: this.generateSubclassSummary(sousClasse, classe.nom)
                });
              }
            });
          }
        });
      }

      // Search in objects
      if (window.OBJETS && window.OBJETS.objets && Array.isArray(window.OBJETS.objets)) {
        window.OBJETS.objets.forEach(objet => {
          if (this.matchesSearch(objet, normalizedQuery)) {
            results.push({
              type: 'objet',
              category: 'Objets',
              data: objet,
              summary: this.generateObjetSummary(objet)
            });
          }
        });
      }

      // Search in static pages
      if (window.STATIC_PAGES) {
        Object.entries(window.STATIC_PAGES).forEach(([pageId, pageData]) => {
          if (pageData && this.matchesSearch(pageData, normalizedQuery)) {
            results.push({
              type: 'static-page',
              category: 'Pages',
              data: pageData,
              pageId: pageId,
              summary: this.generateStaticPageSummary(pageData)
            });
          }
        });
      }

      this.displaySearchResults(results, query);
    },

    /**
     * Check if item matches search query
     */
    matchesSearch(item, query) {
      // Fonction pour nettoyer le HTML et extraire le texte
      const stripHtml = (text) => {
        if (!text) return '';
        if (typeof text !== 'string') text = String(text);
        return text.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
      };

      const processArray = (arr) => {
        if (!arr) return '';
        if (Array.isArray(arr)) {
          return arr.map(item => stripHtml(item)).join(' ');
        }
        return stripHtml(arr);
      };

      // Collecter TOUS les champs textuels possibles
      const searchFields = [
        // Champs communs
        item.nom, item.name, item.title, item.titre,
        item.description, item.resume, item.content,
        item.prerequis, item.coutMana, item.cout, item.temps,
        item.distance, item.duree, item.damage, item.effet,
        item.capacites, item.competences, item.avantages,
        item.inconvenients, item.cout_creation,
        
        // Champs spécifiques aux classes
        item.caracteristiques, item.competencesPrincipales,
        item.progression, item.equipementDeBase,
        
        // Champs des objets et monstres  
        item.type, item.tags, item.element, item.numero,
        item.pointsDeVie, item.armure, item.dommages,
        
        // Champs des sections de pages statiques
        processArray(item.sections),
        
        // Sous-classes
        processArray(item.sousClasses),
        
        // Meta-données
        item.author, item.source, item.version
      ];

      // Joindre tous les champs en un seul texte de recherche
      const searchText = searchFields
        .filter(field => field !== null && field !== undefined)
        .map(field => stripHtml(field))
        .join(' ')
        .toLowerCase();
      
      // Chercher chaque mot de la requête
      const queryWords = query.toLowerCase().split(/\s+/).filter(word => word.length > 0);
      return queryWords.every(word => searchText.includes(word));
    },

    /**
     * Display search results
     */
    displaySearchResults(results, query) {
      if (results.length === 0) {
        this.showNoResults(query);
        return;
      }

      // Group results by type for better organization
      const groupedResults = {};
      results.forEach(result => {
        const type = result.type;
        if (!groupedResults[type]) {
          groupedResults[type] = [];
        }
        groupedResults[type].push(result);
      });

      // Generate HTML for results
      let resultsHTML = `
        <div class="search-results-header">
          <h2>🔍 Résultats de recherche pour "${query}"</h2>
          <p>${results.length} résultat${results.length > 1 ? 's' : ''} trouvé${results.length > 1 ? 's' : ''}</p>
          <button class="btn small" onclick="JdrApp.modules.ui.clearMainSearchResults()">
            ← Retour au sommaire
          </button>
        </div>
        <div class="search-results-content">
      `;

      // Add results by type
      Object.entries(groupedResults).forEach(([type, typeResults]) => {
        const typeLabel = this.getTypeLabel(type);
        resultsHTML += `
          <div class="search-results-section">
            <h3>${typeLabel} (${typeResults.length})</h3>
            <div class="search-results-grid">
        `;
        
        typeResults.forEach(result => {
          resultsHTML += this.generateResultCard(result);
        });
        
        resultsHTML += `
            </div>
          </div>
        `;
      });

      resultsHTML += `</div>`;
      
      // Replace main content with search results
      const main = document.querySelector('main .content');
      if (main) {
        main.innerHTML = resultsHTML;
      }
    },

    /**
     * Show no results message
     */
    showNoResults(query) {
      const noResultsHTML = `
        <div class="search-results-header">
          <h2>🔍 Aucun résultat pour "${query}"</h2>
          <p>Essayez avec d'autres mots-clés ou vérifiez l'orthographe.</p>
          <button class="btn small" onclick="JdrApp.modules.ui.clearMainSearchResults()">
            ← Retour au sommaire
          </button>
        </div>
      `;
      
      const main = document.querySelector('main .content');
      if (main) {
        main.innerHTML = noResultsHTML;
      }
    },

    /**
     * Clear search results and return to normal view
     */
    clearMainSearchResults() {
      // Reload the current page or go back to homepage
      if (window.location.hash && window.location.hash !== '#/') {
        // Reload current page
        if (JdrApp.modules.router && JdrApp.modules.router.handleRoute) {
          JdrApp.modules.router.handleRoute();
        }
      } else {
        // Go to homepage
        window.location.hash = '#/creation';
      }
      
      // Clear search input
      const searchInput = document.querySelector('#search');
      if (searchInput) {
        searchInput.value = '';
      }
    },

    // Summary generators
    generateSpellSummary(spell) {
      return `🔮 ${UIUtilities.stripHtml(spell.nom)} - ${UIUtilities.stripHtml(spell.prerequis || 'Aucun prérequis')} | ${UIUtilities.stripHtml(spell.coutMana || 'Coût inconnu')}`;
    },

    generateDonSummary(don) {
      return `🏆 ${UIUtilities.stripHtml(don.nom)} - ${UIUtilities.stripHtml(don.prerequis || 'Aucun prérequis')} | ${UIUtilities.stripHtml(don.cout || 'Coût inconnu')}`;
    },

    generateClassSummary(classe) {
      return `⚔️ ${UIUtilities.stripHtml(classe.nom)} - ${UIUtilities.stripHtml(classe.resume || 'Classe de combat')}`;
    },

    generateSubclassSummary(sousClasse, parentClass) {
      return `⚡ ${UIUtilities.stripHtml(sousClasse.nom)} (${UIUtilities.stripHtml(parentClass)}) - Sous-classe spécialisée`;
    },

    generateObjetSummary(objet) {
      const tags = objet.tags && Array.isArray(objet.tags) ? objet.tags.join(', ') : '';
      const numero = objet.numero ? `#${objet.numero}` : '';
      return `⚔️ ${UIUtilities.stripHtml(objet.nom)} ${numero} - ${UIUtilities.stripHtml(tags)} | ${UIUtilities.stripHtml(objet.prix || 'Prix non défini')}`;
    },

    generateStaticPageSummary(pageData) {
      return `📄 ${UIUtilities.stripHtml(pageData.title)} - ${UIUtilities.stripHtml(pageData.description || 'Page d\'information du jeu')}`;
    },

    getTypeLabel(type) {
      const typeLabels = {
        'spell': '🔮 Sorts',
        'don': '🏆 Dons',
        'class': '⚔️ Classes',
        'subclass': '⚡ Sous-classes',
        'objet': '⚔️ Objets',
        'static-page': '📄 Pages'
      };
      return typeLabels[type] || type;
    },

    generateResultCard(result) {
      const linkHash = this.generateLinkHash(result);
      
      return `
        <div class="search-result-card" onclick="window.location.hash='${linkHash}'">
          <div class="search-result-content">
            <div class="search-result-summary">${result.summary}</div>
            <div class="search-result-category">${result.category}</div>
          </div>
        </div>
      `;
    },

    generateLinkHash(result) {
      switch (result.type) {
        case 'spell':
          return `#/sorts-${UIUtilities.slugify(result.category)}`;
        case 'don':
          return `#/dons-${UIUtilities.slugify(result.category)}`;
        case 'class':
          return `#/${UIUtilities.slugify(result.data.nom)}`;
        case 'subclass':
          return `#/${UIUtilities.slugify(result.category)}`;
        case 'objet':
          return `#/objets`;
        case 'static-page':
          return `#/${result.pageId}`;
        default:
          return '#/creation';
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - MODAL MANAGER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // MODAL MANAGER - SPECIALIZED MODALS
  // ========================================
  window.ModalManager = {

    /**
     * Show elements modal for dev tools
     */
    showElementsModal() {
      let modal = JdrApp.utils.dom.$('#elementsModal');
      if (!modal) {
        modal = this.createElementsModal();
        document.body.appendChild(modal);
      }
      
      BaseModal.openModal('elementsModal');
    },

    /**
     * Create elements selection modal
     */
    createElementsModal() {
      const elements = Object.entries(window.ElementColors).map(([name, config]) => ({
        name,
        color: config.color,
        icon: UIUtilities.getElementIcon(name)
      }));

      const elementsHTML = elements.map(element => `
        <div class="element-item" data-element="${element.name}" data-color="${element.color}">
          <div class="element-icon" style="background: ${element.color};">${element.icon}</div>
          <div class="element-name">${element.name}</div>
          <div class="copy-indicator">Copié!</div>
        </div>
      `).join('');

      const modal = BaseModal.createModal('elementsModal', '⚡ Éléments', `
        <p>Cliquez sur un élément pour copier son code HTML stylé dans le presse-papiers :</p>
        <div class="elements-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px; margin: 20px 0;">
          ${elementsHTML}
        </div>
      `);

      // Add event listeners
      modal.addEventListener('click', (e) => {
        const elementItem = e.target.closest('.element-item');
        if (elementItem) {
          const elementName = elementItem.dataset.element;
          const elementColor = elementItem.dataset.color;
          
          // Get element configuration
          const elementConfig = window.ElementColors[elementName];
          if (elementConfig) {
            const styleString = `color: ${elementConfig.color}; font-weight: ${elementConfig.weight || 'bold'};`;
            
            const html = `<span style="${styleString}">${elementName}</span>`;
            UIUtilities.copyToClipboard(html);
          } else {
            // Fallback for elements not found
            const html = `<span style="color: ${elementColor}; font-weight: bold;">${elementName}</span>`;
            UIUtilities.copyToClipboard(html);
          }
          
          elementItem.classList.add('copied');
          
          // Fermer la modale après un court délai pour voir l'effet "Copié!"
          setTimeout(() => {
            BaseModal.closeModal(modal);
            elementItem.classList.remove('copied');
          }, 800);
        }
      });

      return modal;
    },

    /**
     * Show states modal
     */
    showEtatsModal() {
      let modal = JdrApp.utils.dom.$('#etatsModal');
      if (!modal) {
        modal = this.createEtatsModal();
        document.body.appendChild(modal);
      }
      
      BaseModal.openModal('etatsModal');
    },

    /**
     * Create states modal
     */
    createEtatsModal() {
      // Extract states from static pages
      let etats = [];
      if (window.STATIC_PAGES?.etats?.sections) {
        etats = window.STATIC_PAGES.etats.sections.filter(section => 
          section.type === 'card' && section.title
        );
      }

      const etatsHTML = etats.map(etat => `
        <div class="etat-item" data-etat-name="${etat.title}">
          <div class="etat-name">${etat.title}</div>
          <div class="copy-indicator">Copié!</div>
        </div>
      `).join('');

      const modal = BaseModal.createModal('etatsModal', '🎭 États', `
        <p>Cliquez sur un état pour copier son lien HTML dans le presse-papiers :</p>
        <div class="etats-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 8px; margin: 20px 0;">
          ${etatsHTML}
        </div>
      `);

      // Add event listeners
      modal.addEventListener('click', (e) => {
        const etatItem = e.target.closest('.etat-item');
        if (etatItem) {
          const etatName = etatItem.dataset.etatName;
          
          // Create clickable link
          const etatLink = `<span class="etat-link" data-etat="${etatName}" style="color: var(--accent); cursor: pointer; text-decoration: underline;">${etatName}</span>`;
          
          // Toujours copier dans le presse-papiers
          UIUtilities.copyToClipboard(etatLink);
          
          etatItem.classList.add('copied');
          
          // Fermer la modale après un court délai pour voir l'effet "Copié!"
          setTimeout(() => {
            BaseModal.closeModal(modal);
            etatItem.classList.remove('copied');
          }, 800);
        }
      });

      return modal;
    },

    /**
     * Show spell links modal
     */
    showSpellLinksModal() {
      let modal = JdrApp.utils.dom.$('#spellLinksModal');
      if (!modal) {
        modal = this.createSpellLinksModal();
        document.body.appendChild(modal);
      }
      
      BaseModal.openModal('spellLinksModal');
    },

    /**
     * Create spell links modal
     */
    createSpellLinksModal() {
      // Extract spells from data
      let spells = [];
      if (window.SORTS && Array.isArray(window.SORTS)) {
        window.SORTS.forEach(category => {
          if (category.sorts && Array.isArray(category.sorts)) {
            category.sorts.forEach(spell => {
              spells.push({
                name: spell.nom,
                category: category.nom,
                element: spell.element || 'Neutre',
                description: spell.description || ''
              });
            });
          }
        });
      }

      const spellsHTML = spells.map(spell => `
        <div class="spell-item" data-spell-name="${spell.name}" data-spell-category="${spell.category}">
          <div class="spell-info">
            <div class="spell-name" style="color: ${UIUtilities.getElementColor(spell.element)}; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">${spell.name}</div>
            <span data-spell-meta style="color: ${UIUtilities.getElementColor(spell.element)} !important; font-size: 12px; margin-bottom: 6px; display: block;">${UIUtilities.getElementIcon(spell.element)} ${spell.element} • ${spell.category}</span>
            <div class="spell-description">${spell.description.length > 80 ? spell.description.substring(0, 80) + '...' : spell.description}</div>
          </div>
          <div class="copy-indicator">Copié!</div>
        </div>
      `).join('');

      const modal = BaseModal.createModal('spellLinksModal', '🔮 Liens de Sorts', `
        <p>Cliquez sur un sort pour copier son lien HTML dans le presse-papiers :</p>
        <div class="spells-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 12px; margin: 20px 0; max-height: 400px; overflow-y: auto;">
          ${spellsHTML}
        </div>
      `);

      // Add event listeners
      modal.addEventListener('click', (e) => {
        const spellItem = e.target.closest('.spell-item');
        if (spellItem) {
          const spellName = spellItem.dataset.spellName;
          const spellCategory = spellItem.dataset.spellCategory;
          
          // Create clickable spell link
          const spellLink = `<span class="spell-link" data-spell="${spellName}" data-category="${spellCategory}" style="color: var(--accent); cursor: pointer; text-decoration: underline;">${spellName}</span>`;
          
          UIUtilities.copyToClipboard(spellLink);
          
          spellItem.classList.add('copied');
          
          // Fermer la modale après un court délai pour voir l'effet "Copié!"
          setTimeout(() => {
            BaseModal.closeModal(modal);
            spellItem.classList.remove('copied');
          }, 800);
        }
      });

      return modal;
    },

    /**
     * Show monster links modal
     */
    showMonsterLinksModal() {
      let modal = JdrApp.utils.dom.$('#monsterLinksModal');
      if (!modal) {
        modal = this.createMonsterLinksModal();
        document.body.appendChild(modal);
      }
      
      BaseModal.openModal('monsterLinksModal');
    },

    /**
     * Create monster links modal
     */
    createMonsterLinksModal() {
      // Extract monsters from data
      let monsters = [];
      if (window.MONSTRES && Array.isArray(window.MONSTRES)) {
        monsters = window.MONSTRES.map(monster => ({
          name: monster.nom,
          element: monster.element || 'Neutre',
          pointsDeVie: monster.pointsDeVie || '?',
          tags: monster.tags || [],
          description: monster.description || ''
        }));
      }

      const monstersHTML = monsters.map(monster => `
        <div class="monster-item" data-monster-name="${monster.name}">
          <div class="monster-info">
            <div class="monster-name" style="color: ${UIUtilities.getElementColor(monster.element)}; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">${monster.name}</div>
            <span data-monster-meta style="color: ${UIUtilities.getElementColor(monster.element)} !important; font-size: 12px; margin-bottom: 6px; display: block;">${UIUtilities.getElementIcon(monster.element)} ${monster.element} • ${monster.pointsDeVie} PV • ${monster.tags.join(', ')}</span>
            <div class="monster-description">${UIUtilities.stripHtml(monster.description).length > 80 ? UIUtilities.stripHtml(monster.description).substring(0, 80) + '...' : UIUtilities.stripHtml(monster.description)}</div>
          </div>
          <div class="copy-indicator">Copié!</div>
        </div>
      `).join('');

      const modal = BaseModal.createModal('monsterLinksModal', '👹 Liens de Monstres', `
        <p>Cliquez sur un monstre pour copier son lien HTML dans le presse-papiers :</p>
        <div class="monsters-grid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 12px; margin: 20px 0; max-height: 400px; overflow-y: auto;">
          ${monstersHTML}
        </div>
      `);

      // Add event listeners
      modal.addEventListener('click', (e) => {
        const monsterItem = e.target.closest('.monster-item');
        if (monsterItem) {
          const monsterName = monsterItem.dataset.monsterName;
          
          // Create clickable monster link
          const monsterLink = `<span class="monster-link" data-monster="${monsterName}" style="color: var(--accent); cursor: pointer; text-decoration: underline;">${monsterName}</span>`;
          
          UIUtilities.copyToClipboard(monsterLink);
          
          monsterItem.classList.add('copied');
          
          // Fermer la modale après un court délai pour voir l'effet "Copié!"
          setTimeout(() => {
            BaseModal.closeModal(modal);
            monsterItem.classList.remove('copied');
          }, 800);
        }
      });

      return modal;
    },

    /**
     * Show page links modal
     */
    showPageLinksModal() {
      // Simple implementation - delegate to ui.js for now
      if (JdrApp.modules.ui?.showPageLinksModal) {
        return JdrApp.modules.ui.showPageLinksModal();
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - RESPONSIVE MANAGER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // RESPONSIVE MANAGER - MOBILE & RESPONSIVE DESIGN
  // ========================================
  window.ResponsiveManager = {

    /**
     * Setup responsive design features
     */
    setupResponsive() {
      this.setupMobileNavigation();
      this.setupLegacyResponsive();
    },

    /**
     * Setup mobile navigation
     */
    setupMobileNavigation() {
      this.createMobileNavToggle();
      this.setupResponsiveBreakpoints();
    },

    /**
     * Create mobile navigation toggle
     */
    createMobileNavToggle() {
      // Use existing toggle or create new one
      let menuToggle = document.querySelector('#menuToggle');
      let isExisting = !!menuToggle;

      if (!menuToggle) {
        menuToggle = document.createElement('button');
        menuToggle.id = 'menuToggle';
        menuToggle.className = 'menu-toggle';
        menuToggle.setAttribute('aria-controls', 'sidebar');
        menuToggle.setAttribute('aria-expanded', 'false');
        menuToggle.setAttribute('aria-label', 'Ouvrir le sommaire');
        
        // Insert at the beginning of the shell
        const shell = document.querySelector('.shell');
        if (shell) {
          shell.insertBefore(menuToggle, shell.firstChild);
        }
      }
      
      // Create prettier button with icon and text
      menuToggle.innerHTML = `
        <span class="menu-icon">☰</span>
        <span class="menu-text">Sommaire</span>
      `;
      
      // Add proper styling - fix width and position issues
      menuToggle.style.cssText = `
        position: fixed !important;
        top: 16px !important;
        left: 16px !important;
        z-index: 1000 !important;
        background: var(--primary-color, #8b4513) !important;
        color: white !important;
        border: none !important;
        border-radius: 8px !important;
        padding: 12px 16px !important;
        font-size: 14px !important;
        font-weight: 500 !important;
        cursor: pointer !important;
        box-shadow: 0 2px 8px rgba(0,0,0,0.15) !important;
        transition: all 0.2s ease !important;
        display: flex !important;
        align-items: center !important;
        gap: 8px !important;
        width: auto !important;
        max-width: 140px !important;
        min-width: 120px !important;
      `;
      
      // Remove old event listeners to avoid conflicts
      const newMenuToggle = menuToggle.cloneNode(true);
      menuToggle.replaceWith(newMenuToggle);
      menuToggle = newMenuToggle;

      // Add hover effect
      if (menuToggle) {
        menuToggle.addEventListener('mouseenter', () => {
          menuToggle.style.transform = 'scale(1.05)';
          menuToggle.style.boxShadow = '0 4px 12px rgba(0,0,0,0.25)';
        });
        
        menuToggle.addEventListener('mouseleave', () => {
          menuToggle.style.transform = 'scale(1)';
          menuToggle.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
        });

        // Add toggle functionality
        menuToggle.addEventListener('click', () => {
          this.toggleMobileNav();
        });
      }

      // Create backdrop for mobile
      if (!document.querySelector('#backdrop')) {
        const backdrop = document.createElement('div');
        backdrop.id = 'backdrop';
        backdrop.className = 'backdrop';
        backdrop.style.display = 'none';
        backdrop.addEventListener('click', () => {
          this.toggleMobileNav();
        });
        const shell = document.querySelector('.shell');
        if (shell) {
          shell.appendChild(backdrop);
        } else {
          document.body.appendChild(backdrop);
        }
      }
    },

    /**
     * Toggle mobile navigation
     */
    toggleMobileNav() {
      const sidebar = document.querySelector('#sidebar');
      const menuToggle = document.querySelector('#menuToggle');
      const backdrop = document.querySelector('#backdrop');
      
      if (!sidebar || !menuToggle) return;

      const isExpanded = menuToggle.getAttribute('aria-expanded') === 'true';
      
      if (isExpanded) {
        // Close mobile nav
        sidebar.classList.remove('mobile-open');
        menuToggle.setAttribute('aria-expanded', 'false');
        if (backdrop) backdrop.style.display = 'none';
        document.body.style.overflow = '';
      } else {
        // Open mobile nav
        sidebar.classList.add('mobile-open');
        menuToggle.setAttribute('aria-expanded', 'true');
        if (backdrop) backdrop.style.display = 'block';
        document.body.style.overflow = 'hidden';
      }
    },

    /**
     * Setup responsive breakpoints
     */
    setupResponsiveBreakpoints() {
      // Handle window resize
      let resizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          this.handleResize();
        }, 100);
      });

      // Initial setup
      this.handleResize();
    },

    /**
     * Handle window resize
     */
    handleResize() {
      const width = window.innerWidth;
      const sidebar = document.querySelector('#sidebar');
      const menuToggle = document.querySelector('#menuToggle');
      const backdrop = document.querySelector('#backdrop');

      // Check if device is touch-capable
      const isTouchDevice = this.isTouchDevice();
      const isMobileSize = width <= window.UI_CONSTANTS.BREAKPOINTS.MOBILE;
      const isTabletSize = width > window.UI_CONSTANTS.BREAKPOINTS.MOBILE && width <= window.UI_CONSTANTS.BREAKPOINTS.TABLET_LANDSCAPE;
      
      // Show menu toggle on touch devices OR mobile size screens
      const shouldShowToggle = isTouchDevice || isMobileSize;

      if (shouldShowToggle) {
        // Mobile/Touch mode
        if (menuToggle) menuToggle.style.display = 'block';
        if (sidebar) {
          sidebar.classList.remove('desktop-open');
          // Close mobile nav on resize to mobile
          sidebar.classList.remove('mobile-open');
          if (menuToggle) menuToggle.setAttribute('aria-expanded', 'false');
        }
        if (backdrop) backdrop.style.display = 'none';
        document.body.style.overflow = '';
      } else {
        // Desktop mode (non-touch, large screen)
        if (menuToggle) menuToggle.style.display = 'none';
        if (sidebar) {
          sidebar.classList.remove('mobile-open');
          sidebar.classList.add('desktop-open');
        }
        if (backdrop) backdrop.style.display = 'none';
        document.body.style.overflow = '';
      }
    },

    /**
     * Check if device has touch capability
     */
    isTouchDevice() {
      return 'ontouchstart' in window || 
             navigator.maxTouchPoints > 0 || 
             navigator.msMaxTouchPoints > 0 ||
             window.matchMedia('(pointer: coarse)').matches;
    },

    /**
     * Setup legacy responsive features
     */
    setupLegacyResponsive() {
      // Handle orientation changes on mobile
      window.addEventListener('orientationchange', () => {
        setTimeout(() => {
          this.handleResize();
        }, 300);
      });

      // Handle touch events for better mobile experience
      this.setupTouchEvents();
    },

    /**
     * Setup touch events for mobile
     */
    setupTouchEvents() {
      let touchStartX = 0;
      let touchStartY = 0;

      // Handle touch start
      document.addEventListener('touchstart', (e) => {
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }, { passive: true });

      // Handle swipe gestures
      document.addEventListener('touchend', (e) => {
        if (!e.changedTouches[0]) return;

        const touchEndX = e.changedTouches[0].clientX;
        const touchEndY = e.changedTouches[0].clientY;
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;

        // Only handle horizontal swipes
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 50) {
          const sidebar = document.querySelector('#sidebar');
          const menuToggle = document.querySelector('#menuToggle');
          
          if (!sidebar || !menuToggle) return;

          const isExpanded = menuToggle.getAttribute('aria-expanded') === 'true';
          const isMobile = window.innerWidth <= window.UI_CONSTANTS.BREAKPOINTS.MOBILE;

          if (isMobile) {
            // Swipe right from left edge to open
            if (deltaX > 0 && touchStartX < 50 && !isExpanded) {
              this.toggleMobileNav();
            }
            // Swipe left when sidebar is open to close
            else if (deltaX < 0 && isExpanded) {
              this.toggleMobileNav();
            }
          }
        }
      }, { passive: true });
    },

    /**
     * Check if device is mobile
     */
    isMobileDevice() {
      return window.innerWidth <= window.UI_CONSTANTS.BREAKPOINTS.MOBILE;
    },

    /**
     * Check if device is tablet
     */
    isTabletDevice() {
      const width = window.innerWidth;
      return width > window.UI_CONSTANTS.BREAKPOINTS.MOBILE && 
             width <= window.UI_CONSTANTS.BREAKPOINTS.TABLET;
    },

    /**
     * Get current device type
     */
    getDeviceType() {
      if (this.isMobileDevice()) return 'mobile';
      if (this.isTabletDevice()) return 'tablet';
      return 'desktop';
    },

    /**
     * Apply device-specific optimizations
     */
    applyDeviceOptimizations() {
      const deviceType = this.getDeviceType();
      document.body.setAttribute('data-device-type', deviceType);

      // Add device-specific CSS classes
      document.body.classList.remove('device-mobile', 'device-tablet', 'device-desktop');
      document.body.classList.add(`device-${deviceType}`);

      // Apply device-specific optimizations
      switch (deviceType) {
        case 'mobile':
          this.applyMobileOptimizations();
          break;
        case 'tablet':
          this.applyTabletOptimizations();
          break;
        case 'desktop':
          this.applyDesktopOptimizations();
          break;
      }
    },

    /**
     * Apply mobile-specific optimizations
     */
    applyMobileOptimizations() {
      // Reduce animations for better performance
      document.body.classList.add('reduced-motion');
      
      // Optimize scroll behavior
      if (window.ScrollOptimizer) {
        ScrollOptimizer.enableMobileOptimizations();
      }
    },

    /**
     * Apply tablet-specific optimizations
     */
    applyTabletOptimizations() {
      // Tablet-specific optimizations
      document.body.classList.remove('reduced-motion');
    },

    /**
     * Apply desktop-specific optimizations
     */
    applyDesktopOptimizations() {
      // Desktop-specific optimizations
      document.body.classList.remove('reduced-motion');
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - PAGE MANAGER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // PAGE MANAGER - STATIC PAGE MANAGEMENT
  // ========================================
  window.PageManager = {

    /**
     * Show section selection modal for new page creation
     */
    showSectionSelectionModal() {
      const modalId = 'sectionSelectionModal';
      
      // Remove existing modal
      BaseModal.destroyModal(modalId);

      const content = `
        <p>Sélectionnez le type de contenu à ajouter :</p>
        <div class="section-types" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin: 20px 0;">
          <button class="btn btn-primary section-type-btn" data-type="section">
            📄 Nouvelle Section
          </button>
          <button class="btn btn-secondary section-type-btn" data-type="paragraph">
            📝 Nouveau Paragraphe
          </button>
        </div>
      `;

      const modal = BaseModal.createModal(modalId, '➕ Nouveau Contenu', content);
      document.body.appendChild(modal);

      // Setup event handlers
      modal.addEventListener('click', (e) => {
        if (e.target.classList.contains('section-type-btn')) {
          const type = e.target.dataset.type;
          BaseModal.closeModal(modal);
          BaseModal.destroyModal(modal);
          
          if (type === 'section') {
            this.createNewSection();
          } else if (type === 'paragraph') {
            this.createNewParagraph();
          }
        }
      });

      BaseModal.openModal(modalId);
    },

    /**
     * Create new section
     */
    createNewSection() {
      const sectionTitle = prompt('Titre de la nouvelle section :');
      if (!sectionTitle || !sectionTitle.trim()) return;

      const pageId = UIUtilities.getCurrentPageId();
      if (!pageId) {
        UIUtilities.showNotification('❌ Impossible de déterminer la page courante', 'error');
        return;
      }

      // Generate unique ID
      const sectionId = UIUtilities.generateUniqueId('section');
      
      // Create section data
      const newSection = {
        id: sectionId,
        type: 'card',
        title: sectionTitle.trim(),
        content: '<p>Contenu de la nouvelle section...</p>'
      };

      // Add to page data
      if (!window.STATIC_PAGES[pageId]) {
        window.STATIC_PAGES[pageId] = { sections: [] };
      }
      if (!window.STATIC_PAGES[pageId].sections) {
        window.STATIC_PAGES[pageId].sections = [];
      }

      window.STATIC_PAGES[pageId].sections.push(newSection);

      // Save and refresh
      this.savePageData();
      this.refreshCurrentPage();
      
      UIUtilities.showNotification('➕ Nouvelle section ajoutée et sauvegardée', 'success');
    },

    /**
     * Create new paragraph
     */
    createNewParagraph() {
      const paragraphContent = prompt('Contenu du nouveau paragraphe :');
      if (!paragraphContent || !paragraphContent.trim()) return;

      const pageId = UIUtilities.getCurrentPageId();
      if (!pageId) {
        UIUtilities.showNotification('❌ Impossible de déterminer la page courante', 'error');
        return;
      }

      // Generate unique ID
      const paragraphId = UIUtilities.generateUniqueId('paragraph');
      
      // Create paragraph data
      const newParagraph = {
        id: paragraphId,
        type: 'text',
        content: `<p>${paragraphContent.trim()}</p>`
      };

      // Add to page data
      if (!window.STATIC_PAGES[pageId]) {
        window.STATIC_PAGES[pageId] = { sections: [] };
      }
      if (!window.STATIC_PAGES[pageId].sections) {
        window.STATIC_PAGES[pageId].sections = [];
      }

      window.STATIC_PAGES[pageId].sections.push(newParagraph);

      // Save and refresh
      this.savePageData();
      this.refreshCurrentPage();
      
      UIUtilities.showNotification('➕ Paragraphe ajouté et sauvegardé', 'success');
    },

    /**
     * Add paragraph to existing target
     */
    addParagraph(target, button) {
      if (!target || !button) {
        UIUtilities.showNotification('❌ Target ou bouton manquant', 'error');
        return;
      }

      const paragraphContent = prompt('Contenu du nouveau paragraphe :');
      if (!paragraphContent || !paragraphContent.trim()) return;

      // Handle different types of additions based on target
      if (target === 'new-section') {
        this.createNewSection();
      } else {
        this.addParagraphToSection(target, button);
      }
    },

    /**
     * Add paragraph to specific section
     */
    addParagraphToSection(target, button) {
      const paragraphContent = prompt('Contenu du nouveau paragraphe :');
      if (!paragraphContent || !paragraphContent.trim()) return;

      // Generate unique ID
      const pageId = UIUtilities.getCurrentPageId();
      const paragraphId = UIUtilities.generateUniqueId('paragraph');
      
      // Create paragraph data
      const newParagraph = {
        id: paragraphId,
        type: 'text',
        content: `<p>${paragraphContent.trim()}</p>`
      };

      // Find target section and add paragraph
      if (window.STATIC_PAGES[pageId]?.sections) {
        const targetSection = window.STATIC_PAGES[pageId].sections.find(section => 
          section.id === target
        );
        
        if (targetSection) {
          if (!targetSection.paragraphs) {
            targetSection.paragraphs = [];
          }
          targetSection.paragraphs.push(newParagraph);
        } else {
          // Add as new section if target not found
          window.STATIC_PAGES[pageId].sections.push(newParagraph);
        }
      }

      // Save and refresh
      this.savePageData();
      this.refreshCurrentPage();
      
      UIUtilities.showNotification('➕ Paragraphe ajouté et sauvegardé', 'success');
    },

    /**
     * Delete section
     */
    deleteSection(sectionName, button) {
      if (!sectionName || !button) {
        UIUtilities.showNotification('❌ Section ou bouton manquant', 'error');
        return;
      }

      if (!confirm(`Supprimer la section "${sectionName}" ?`)) {
        return;
      }

      const pageId = UIUtilities.getCurrentPageId();
      if (!pageId || !window.STATIC_PAGES[pageId]?.sections) {
        UIUtilities.showNotification('❌ Page ou sections non trouvées', 'error');
        return;
      }

      // Find and remove the section
      const section = button.closest('.card');
      if (section) {
        // Extract the section ID from the editable elements
        const editableElements = section.querySelectorAll('[data-edit-type]');
        let sectionId = null;
        
        for (const element of editableElements) {
          const id = element.dataset.sectionId || element.id;
          if (id) {
            // Remove "-title" suffix if present to get base ID
            sectionId = id.replace(/-title$/, '');
            break;
          }
        }

        if (sectionId) {
          // Remove from data
          window.STATIC_PAGES[pageId].sections = window.STATIC_PAGES[pageId].sections.filter(
            s => s.id !== sectionId
          );

          // Save the deletion to JSON
          this.savePageData();

          // Recalculate all section indices after deletion
          this.recalculateSectionIndices(pageId);

          // Trigger persistent storage save
          UIUtilities.triggerDataSave();
          
          UIUtilities.showNotification(`🗑️ Section "${sectionName}" supprimée et mise à jour JSON`, 'success');
          
          // Refresh page
          this.refreshCurrentPage();
        }
      }
    },

    /**
     * Save page data
     */
    savePageData() {
      // Trigger storage save event
      UIUtilities.triggerDataSave();
    },

    /**
     * Refresh current page
     */
    refreshCurrentPage() {
      UIUtilities.forcePageRefresh();
    },

    /**
     * Count existing sections for unique ID generation
     */
    countExistingSections() {
      const pageId = UIUtilities.getCurrentPageId();
      if (!pageId || !window.STATIC_PAGES || !window.STATIC_PAGES[pageId]) {
        return 0;
      }
      const pageData = window.STATIC_PAGES[pageId];
      return pageData.sections ? pageData.sections.length : 0;
    },

    /**
     * Save new section to JSON data
     */
    saveNewSectionToJSON(sectionId, title, content) {
      const pageId = UIUtilities.getCurrentPageId();
      
      if (!pageId || !window.STATIC_PAGES || !window.STATIC_PAGES[pageId]) {
        return false;
      }
      
      const pageData = window.STATIC_PAGES[pageId];
      if (!pageData.sections) {
        pageData.sections = [];
      }
      
      // Create new section object
      const newSection = {
        id: sectionId,
        type: 'card',
        title: title,
        content: content
      };
      
      // Add to sections array
      pageData.sections.push(newSection);
      
      return true;
    },

    /**
     * Recalculate section indices after changes
     */
    recalculateSectionIndices(pageId) {
      if (!window.STATIC_PAGES[pageId]?.sections) {
        return false;
      }
      
      const sections = window.STATIC_PAGES[pageId].sections;
      
      // Update indices for all sections
      sections.forEach((section, index) => {
        if (section.id) {
          section.index = index;
        }
      });
      
      console.log(`Recalculated indices for ${sections.length} sections in page ${pageId}`);
      return true;
    },

    /**
     * Create new category for content types
     */
    createNewCategory(type) {
      const config = window.ContentTypes[type];
      if (!config) {
        UIUtilities.showNotification(`❌ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Demander le nom de la catégorie
      const categoryName = prompt(`Nom de la nouvelle catégorie ${config.container} :`);
      if (!categoryName || !categoryName.trim()) {
        return;
      }

      const trimmedName = categoryName.trim();
      
      // Vérifier si la catégorie existe déjà
      const entity = ContentFactory.getEntity(type);
      if (entity && entity.findCategory(trimmedName)) {
        UIUtilities.showNotification(`❌ La catégorie "${trimmedName}" existe déjà`, 'error');
        return;
      }

      // Créer la nouvelle catégorie
      const success = ContentFactory.addCategory(type, {
        nom: trimmedName,
        [config.dataKey.toLowerCase()]: []
      });

      if (success) {
        // Sauvegarder les modifications
        EventBus.emit(Events.STORAGE_SAVE);

        // Rafraîchir ContentFactory
        ContentFactory.refreshData();

        // Rafraîchir le router TOC
        if (JdrApp.modules.router && JdrApp.modules.router.generateTOC) {
          JdrApp.modules.router.generateTOC();
        }

        // Naviguer vers la nouvelle catégorie
        const categoryRoute = `${config.container}-${JdrApp.utils.data.sanitizeId(trimmedName)}`;
        JdrApp.modules.router.navigate(categoryRoute);

        UIUtilities.showNotification(`${config.icons.category} Catégorie "${trimmedName}" créée avec succès!`, 'success');
      }
    },

    /**
     * Delete category
     */
    deleteCategory(type, categoryName) {
      const config = window.ContentTypes[type];
      if (!config) {
        UIUtilities.showNotification(`❌ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      if (!confirm(`Supprimer la catégorie "${categoryName}" et tout son contenu ?`)) {
        return;
      }

      const success = ContentFactory.deleteCategory(type, categoryName);

      if (success) {
        // Sauvegarder les modifications
        EventBus.emit(Events.STORAGE_SAVE);

        // Rafraîchir ContentFactory
        ContentFactory.refreshData();

        // Rafraîchir le router TOC
        if (JdrApp.modules.router && JdrApp.modules.router.generateTOC) {
          JdrApp.modules.router.generateTOC();
        }

        // Naviguer vers la page principale du type
        JdrApp.modules.router.navigate(config.container);

        UIUtilities.showNotification(`${config.icons.delete} Catégorie "${categoryName}" supprimée`, 'success');
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - UI MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // UI INTERACTIONS MODULE
  // ========================================
  JdrApp.modules.ui = {
    _initialized: false,
    
    init() {
      // Prevent multiple initialization to avoid duplicate event listeners
      if (this._initialized) {
        return;
      }
      
      // Use UICore for main initialization
      if (window.UICore) {
        UICore.init();
      } else {
        console.error('UICore not available - ensure ui/ modules are loaded');
        return;
      }
      
      this._initialized = true;
    },

    setupEventListeners() {
      // Delegate to UICore
      if (window.UICore) {
        return UICore.setupEventListeners();
      }
    },

    setupSearch() {
      // Delegate to UICore
      if (window.UICore) {
        return UICore.setupSearch();
      }
    },

    setupModals() {
      // Delegate to UICore
      if (window.UICore) {
        return UICore.setupModals();
      }
    },

    setupResponsive() {
      // Delegate to UICore
      if (window.UICore) {
        return UICore.setupResponsive();
      }
    },

    setupNewPageHandler() {
      // Delegate to UICore
      if (window.UICore) {
        return UICore.setupNewPageHandler();
      }
    },

    // Event handlers - delegate to modular components
    handleContentAdd(type, category, item) {
      if (window.ContentManager) {
        return ContentManager.handleContentAdd(type, category, item);
      }
    },

    handleContentDelete(type, category, item) {
      if (window.ContentManager) {
        return ContentManager.handleContentDelete(type, category, item);
      }
    },

    handleContentMove(type, category, itemName, direction) {
      if (window.ContentManager) {
        return ContentManager.handleContentMove(type, category, itemName, direction);
      }
    },

    // Search methods - delegate to SearchManager
    performSearch(query) {
      if (window.SearchManager) {
        return SearchManager.performSearch(query);
      }
    },

    clearMainSearchResults() {
      if (window.SearchManager) {
        return SearchManager.clearMainSearchResults();
      }
    },

    // Modal methods - delegate to ModalManager
    openModal(type, data = null) {
      if (window.ModalManager) {
        return ModalManager.openModal(type, data);
      }
    },

    closeModal() {
      if (window.ModalManager) {
        return ModalManager.closeModal();
      }
    },

    // Page management - delegate to PageManager
    showPage(pageId) {
      if (window.PageManager) {
        return PageManager.showPage(pageId);
      }
    },

    // Responsive methods - delegate to ResponsiveManager
    updateResponsiveLayout() {
      if (window.ResponsiveManager) {
        return ResponsiveManager.updateResponsiveLayout();
      }
    },

    // Tags methods - delegate to TagsManager
    updateTagsDisplay() {
      if (window.TagsManager) {
        return TagsManager.updateTagsDisplay();
      }
    },

    toggleTag(tagName, isActive) {
      if (window.TagsManager) {
        return TagsManager.toggleTag(tagName, isActive);
      }
    },

    // Event handling delegation
    setupDragAndDrop() {
      if (window.EventHandlers) {
        return EventHandlers.setupDragAndDrop();
      }
    },

    setupKeyboardShortcuts() {
      if (window.EventHandlers) {
        return EventHandlers.setupKeyboardShortcuts();
      }
    },

    // ID Search functionality (for objects page)
    performIdSearch(searchValue) {
      const searchId = searchValue.trim();
      const resultDiv = document.querySelector('#id-search-result');
      
      if (!searchId) {
        this.clearIdSearch();
        return;
      }

      const searchNumber = parseInt(searchId, 10);
      if (isNaN(searchNumber)) {
        if (resultDiv) {
          resultDiv.innerHTML = '❌ Veuillez saisir un numéro valide';
          resultDiv.style.color = '#dc2626';
        }
        return;
      }

      // Find object by number
      const allObjects = window.OBJETS?.objets || [];
      const foundObject = allObjects.find(obj => obj.numero === searchNumber);

      if (!foundObject) {
        if (resultDiv) {
          resultDiv.innerHTML = `❌ Aucun objet trouvé avec l'ID ${searchNumber}`;
          resultDiv.style.color = '#dc2626';
        }
        // Hide all objects
        this.hideAllObjects();
        return;
      }

      // Set global flag BEFORE regenerating page
      window.activeIdSearch = true;

      // Immediately hide the container to prevent flash
      const container = document.querySelector('#objets-container');
      if (container) {
        container.style.visibility = 'hidden';
      }

      // Show success message immediately
      if (resultDiv) {
        resultDiv.innerHTML = `✅ Objet trouvé : "${foundObject.nom}" (ID: ${searchNumber})`;
        resultDiv.style.color = '#16a34a';
      }

      // Force regenerate page with all objects AND visual feedback
      if (JdrApp.modules.renderer?.regenerateCurrentPage) {
        JdrApp.modules.renderer.regenerateCurrentPage();
      }

      // After regeneration, configure display and show only target object
      requestAnimationFrame(() => {
        const newContainer = document.querySelector('#objets-container');
        if (newContainer) {
          // Hide all objects first
          this.hideAllObjects();
          
          // Show only the target object and make container visible again
          setTimeout(() => {
            this.showOnlyObjectById(searchNumber);
            newContainer.style.visibility = 'visible';
            
            // Restore the search value in the input field
            const searchInput = document.querySelector('#id-search-input');
            if (searchInput) {
              searchInput.value = searchNumber;
            }
          }, 10);
        }
      });
    },

    clearIdSearch() {
      const input = document.querySelector('#id-search-input');
      const resultDiv = document.querySelector('#id-search-result');
      
      if (input) {
        input.value = '';
      }
      
      if (resultDiv) {
        resultDiv.innerHTML = '';
      }
      
      // Clear the global flag
      window.activeIdSearch = false;
      
      // Show all objects again
      this.showAllObjects();
    },

    hideAllObjects() {
      document.querySelectorAll('.card').forEach(card => {
        card.style.display = 'none';
      });
    },

    showAllObjects() {
      document.querySelectorAll('.card').forEach(card => {
        card.style.display = '';
      });
    },

    showOnlyObjectById(searchNumber) {
      this.hideAllObjects();
      
      // Show only the target object
      const targetCard = document.querySelector(`[data-object-id="${searchNumber}"]`);
      if (targetCard) {
        targetCard.style.display = '';
        targetCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
      }
    }
  };

  // Auto-initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      JdrApp.modules.ui.init();
    });
  } else {
    // DOM is already loaded
    JdrApp.modules.ui.init();
  }

})();
// ============================================================================
// JSPDF LOADER - Character Sheet PDF Generation Support
// ============================================================================

(() => {
  "use strict";

  // Check if jsPDF is already loaded
  if (window.jsPDF) {
    return;
  }

  // For standalone builds, we need to handle jsPDF loading
  const loadJsPDF = () => {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
      script.onload = () => {
        resolve();
      };
      script.onerror = () => {
        console.error('❌ Failed to load jsPDF');
        reject();
      };
      document.head.appendChild(script);
    });
  };

  // Load jsPDF if not available
  if (typeof window.jsPDF === 'undefined') {
    loadJsPDF().catch(() => {
      // Silent fallback - PDF generation will not be available
    });
  }

})();

</script>

<!-- PWA Service Worker (Embedded) -->
<script>
// Create dynamic manifest for PWA - Protocol-aware
if (window.MANIFEST_DATA) {
  let manifest = JSON.parse(JSON.stringify(window.MANIFEST_DATA));
  
  // Only modify manifest for file:// protocol
  if (window.location.protocol === 'file:') {
    manifest.start_url = window.location.href;
    manifest.scope = window.location.href;
    
    // Create a simple SVG icon that works with file:// protocol
    const simpleIcon = 'data:image/svg+xml;base64,' + btoa('<svg xmlns="http://www.w3.org/2000/svg" width="144" height="144" viewBox="0 0 144 144"><rect width="144" height="144" fill="#f4f0e6" rx="16"/><rect x="24" y="30" width="96" height="84" fill="#fff" stroke="#8b4513" stroke-width="2" rx="4"/><line x1="36" y1="50" x2="108" y2="50" stroke="#8b4513" stroke-width="2"/><line x1="36" y1="70" x2="108" y2="70" stroke="#8b4513" stroke-width="2"/><line x1="36" y1="90" x2="90" y2="90" stroke="#8b4513" stroke-width="2"/><circle cx="120" cy="24" r="4" fill="#d4af37"/></svg>');
    
    manifest.icons = [
      {
        "src": simpleIcon,
        "sizes": "144x144",
        "type": "image/svg+xml",
        "purpose": "any"
      },
      {
        "src": simpleIcon,
        "sizes": "192x192", 
        "type": "image/svg+xml",
        "purpose": "any"
      },
      {
        "src": simpleIcon,
        "sizes": "512x512",
        "type": "image/svg+xml", 
        "purpose": "any"
      }
    ];
    
    // Remove problematic elements for file:// 
    manifest.shortcuts = [];
    delete manifest.screenshots;
    console.log('📱 PWA manifest adapted for file:// protocol');
  } else {
    // For HTTPS - use original manifest as-is
    console.log('📱 PWA using original manifest for HTTPS');
  }
  
  // Create manifest blob and URL
  const manifestBlob = new Blob([JSON.stringify(manifest)], { type: 'application/json' });
  const manifestUrl = URL.createObjectURL(manifestBlob);
  
  // Inject manifest link dynamically
  const manifestLink = document.createElement('link');
  manifestLink.rel = 'manifest';
  manifestLink.href = manifestUrl;
  document.head.appendChild(manifestLink);
  
  console.log('📱 PWA manifest injected');
}

// Service Worker only works on HTTPS or localhost
const canUseServiceWorker = 'serviceWorker' in navigator && 
  (window.location.protocol === 'https:' || 
   window.location.hostname === 'localhost' ||
   window.location.hostname === '127.0.0.1');

if (canUseServiceWorker) {
  // Service Worker Registration - use external file only
  const swUrl = '/sw.js';

  // Progressive Web App - Service Worker Registration
  window.addEventListener('load', () => {
    navigator.serviceWorker.register(swUrl)
      .then((registration) => {
        console.log('✅ Service Worker registered successfully:', registration);
        
        // Check for updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing;
          if (newWorker) {
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                // New content available, notify user
                if (window.JdrApp && JdrApp.modules && JdrApp.modules.ui) {
                  JdrApp.modules.ui.showNotification('🔄 Nouvelle version disponible ! Rechargez la page.', 'info');
                }
              }
            });
          }
        });
      })
      .catch((error) => {
        console.log('❌ Service Worker registration failed:', error);
      });
  });

  // Listen for app install prompt
  let deferredPrompt;
  window.addEventListener('beforeinstallprompt', (e) => {
    console.log('💾 PWA install prompt available');
    e.preventDefault();
    deferredPrompt = e;
    
    // Show install button or notification
    if (window.JdrApp && JdrApp.modules && JdrApp.modules.ui) {
      JdrApp.modules.ui.showNotification('📱 Installer JDR-BAB sur votre appareil ?', 'info');
    }
  });

  // Track install success
  window.addEventListener('appinstalled', (e) => {
    console.log('✅ PWA was installed successfully');
    if (window.JdrApp && JdrApp.modules && JdrApp.modules.ui) {
      JdrApp.modules.ui.showNotification('✅ JDR-BAB installé avec succès !', 'success');
    }
    deferredPrompt = null;
  });
} else {
  console.log('⚠️ Service Worker not available (requires HTTPS)');
  console.log('💡 For full PWA features, serve via HTTPS server');
}

// PWA Display Mode Detection
if (window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone) {
  console.log('📱 Running as PWA');
  document.body.classList.add('pwa-mode');
}

// Basic PWA install prompt for non-HTTPS environments
if (!canUseServiceWorker && window.MANIFEST_DATA) {
  console.log('💡 Limited PWA support without Service Worker');
  console.log('📱 Try: Add to Home Screen (mobile) or Install App (desktop)');
}
</script>
</body>
</html>