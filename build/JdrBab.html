<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta name="referrer" content="no-referrer-when-downgrade">
<!-- Generated on 2025-08-20T09:23:45.654Z by JdrBab Build System -->
<title>JDR‚ÄëBAB ‚Äî Livret de r√®gles</title>
<meta content="Livret web multipages des r√®gles JDR‚ÄëBAB, th√®me parchemin, illustrations par cat√©gorie/classe/sous‚Äëclasse, export HTML autonome." name="description">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&amp;family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600&amp;display=swap" rel="stylesheet">
<style>
/* ‚Äî‚Äî Th√®me Heroic Fantasy ‚Äî‚Äî */
:root{
  --paper:#f4f0e6;        /* parchemin ancien */
  --paper-ink:#2c1810;    /* encre noire profonde */
  --paper-muted:#8b6f47;  /* bronze ancien */
  --accent-ink:#4a2c17;   /* titres sombres */
  --rule:#d4c4a8;         /* bordures dor√©es */
  --card:#faf6ee;         /* cartes parchemin */
  --link:#8b4513;         /* liens cuivre */
  --gold:#d4af37;         /* or */
  --bronze:#cd7f32;       /* bronze */
  --shadow:0 8px 32px rgba(0,0,0,.15), 0 2px 8px rgba(139,69,19,.1);
  --card-shadow:0 6px 20px rgba(0,0,0,.1), 0 2px 6px rgba(139,69,19,.08);
  --image-border:3px solid #8b4513;
  --image-shadow:0 4px 12px rgba(0,0,0,.2), inset 0 1px 2px rgba(212,175,55,.3);
  
  /* Element colors system */
  --feu:#ff6b35; --feu-bg:rgba(255,107,53,.1); --feu-border:rgba(255,107,53,.3);
  --air:#87ceeb; --air-bg:rgba(135,206,235,.1); --air-border:rgba(135,206,235,.3);
  --eau:#4682b4; --eau-bg:rgba(70,130,180,.1); --eau-border:rgba(70,130,180,.3);
  --terre:#8b7355; --terre-bg:rgba(139,115,85,.1); --terre-border:rgba(139,115,85,.3);
  --divin:#ffd700; --divin-bg:rgba(255,215,0,.1); --divin-border:rgba(255,215,0,.3);
  --malefique:#8b008b; --malefique-bg:rgba(139,0,139,.1); --malefique-border:rgba(139,0,139,.3);
  
  /* Spacing system */
  --space-xs:4px; --space-sm:6px; --space-md:8px; --space-lg:12px; --space-xl:16px; --space-2xl:24px;
  
  /* Common transitions */
  --transition-fast:.2s ease; --transition-normal:.3s ease; --transition-slow:.5s ease;
}

@media (prefers-color-scheme: dark){ 
  :root{ 
    --paper:#e9e0cc; 
    --card:#f3ead4; 
    --paper-ink:#1c170f; 
  } 
}

/* Base styles */
html,body{height:100%}
body{
  margin:0;
  background:
    radial-gradient(1600px 800px at 50% -10%, rgba(212,175,55,.08), transparent 45%),
    radial-gradient(1400px 700px at 120% 10%, rgba(139,69,19,.06), transparent 40%),
    radial-gradient(800px 400px at 20% 80%, rgba(205,127,50,.04), transparent 30%),
    repeating-linear-gradient(90deg, rgba(74,44,23,.02) 0 1px, transparent 1px 3px),
    repeating-linear-gradient(0deg, rgba(139,69,19,.015) 0 1px, transparent 1px 4px),
    var(--paper);
  color:var(--paper-ink); 
  font:17px/1.65 "Source Serif Pro", "Cinzel", ui-serif, Georgia, Cambria, "Times New Roman", Times, serif; 
  -webkit-font-smoothing:antialiased; 
  text-rendering:optimizeLegibility;
}

/* Typography */
a{color:var(--link);text-decoration:none} 
a:hover{text-decoration:underline}
strong, b{font-weight:700; font-family: "Source Serif Pro", serif; color:var(--accent-ink)}
em, i{font-style:italic; font-weight:400}
h1,h2,h3{font-family: "Cinzel", "Trajan Pro", ui-serif, Georgia, Cambria, Times, serif; color:var(--accent-ink); text-shadow: 1px 1px 2px rgba(0,0,0,.1)}
h1{font-size:clamp(32px,4.5vw,44px);letter-spacing:.03em;margin:.2rem 0 .4rem; font-weight:600;
   background:linear-gradient(135deg, var(--gold), var(--bronze)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text}
h2{font-size:clamp(24px,3.2vw,30px);margin:.2rem 0 .2rem; font-weight:500; color:var(--bronze)}
h3{font-size:clamp(19px,2.4vw,24px);margin:.8rem 0 .2rem; font-weight:500; color:var(--accent-ink)}
.muted{color:var(--paper-muted)}
.lead{font-size:18px}
.rule{height:1px;background:linear-gradient(90deg, transparent, var(--rule), transparent);margin:10px 0}
/* === UTILITY CLASSES === */

/* Spacing utilities */
.m-0{margin:0} .m-1{margin:var(--space-xs)} .m-2{margin:var(--space-md)} .m-3{margin:var(--space-lg)} .m-4{margin:var(--space-xl)}
.mt-0{margin-top:0} .mt-1{margin-top:var(--space-xs)} .mt-2{margin-top:var(--space-md)} .mt-3{margin-top:var(--space-lg)}
.mb-0{margin-bottom:0} .mb-1{margin-bottom:var(--space-xs)} .mb-2{margin-bottom:var(--space-md)} .mb-3{margin-bottom:var(--space-lg)}
.p-0{padding:0} .p-1{padding:var(--space-xs)} .p-2{padding:var(--space-md)} .p-3{padding:var(--space-lg)} .p-4{padding:var(--space-xl)}

/* Flex utilities */
.flex{display:flex} .flex-col{flex-direction:column} .flex-wrap{flex-wrap:wrap}
.items-center{align-items:center} .items-start{align-items:flex-start} .items-end{align-items:flex-end}
.justify-center{justify-content:center} .justify-start{justify-content:flex-start} .justify-end{justify-content:flex-end}
.gap-1{gap:var(--space-xs)} .gap-2{gap:var(--space-md)} .gap-3{gap:var(--space-lg)}

/* Element color utilities */
.text-feu{color:var(--feu)} .text-air{color:var(--air)} .text-eau{color:var(--eau)} .text-terre{color:var(--terre)} .text-divin{color:var(--divin)} .text-malefique{color:var(--malefique)}
.bg-feu{background:var(--feu-bg);border-color:var(--feu-border)} .bg-air{background:var(--air-bg);border-color:var(--air-border)}
.bg-eau{background:var(--eau-bg);border-color:var(--eau-border)} .bg-terre{background:var(--terre-bg);border-color:var(--terre-border)}
.bg-divin{background:var(--divin-bg);border-color:var(--divin-border)} .bg-malefique{background:var(--malefique-bg);border-color:var(--malefique-border)}

/* Grid utilities */
.grid{display:grid;gap:var(--space-lg)}
.cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}
.cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}
@media (max-width: 900px){ .cols-3{grid-template-columns:1fr} }
@media (max-width: 768px){ .cols-2{grid-template-columns:1fr !important} }

/* Misc utilities */
.subclass-stack{display:flex;flex-direction:column;gap:var(--space-lg)}
.chip{font-size:12px;border:1px solid var(--rule);border-radius:999px;padding:4px 8px;background:rgba(155,107,47,.08)}
.chips{display:flex;flex-wrap:wrap;gap:6px;justify-content:center}
/* ‚Äî Layout ‚Äî */
.shell{display:grid;grid-template-rows:1fr auto;min-height:100svh}

.page{position:relative;min-height:100vh;padding-left:318px;padding-right:18px;padding-top:18px;padding-bottom:18px}

/* Centrer le contenu principal dans l'espace disponible */
#views{max-width:1200px;margin:0 auto}
@media (max-width: 980px){ .page{padding-left:12px;padding-right:12px} }

.sidebar{position:fixed;top:0;left:0;width:300px;height:100vh;overflow-y:auto;overflow-x:hidden;z-index:100;background:var(--paper)}
@media (max-width: 980px){ .sidebar{position:relative;width:100%;height:auto;background:transparent} }
.panel{background:var(--card);border:2px solid var(--rule);border-radius:16px;box-shadow:var(--card-shadow);padding:14px;
       position:relative; overflow:hidden;margin:12px}
.toc{max-height:calc(100vh - 150px);overflow-y:auto;overflow-x:hidden}
.panel::before{content:''; position:absolute; top:0; left:0; right:0; height:2px; 
               background:linear-gradient(90deg, transparent, var(--gold), transparent); opacity:.4}

.toc h4{margin:6px 8px;color:var(--paper-muted);text-transform:uppercase;font-size:12px;letter-spacing:.12em}
.toc a{display:flex;gap:8px;padding:8px;border-radius:10px;color:inherit;border:1px solid transparent;
       transition:all .3s cubic-bezier(0.4, 0, 0.2, 1); position:relative; overflow:hidden}
.toc a::before{content:''; position:absolute; top:0; left:-100%; width:100%; height:100%;
               background:linear-gradient(90deg, transparent, rgba(212,175,55,.15), transparent);
               transition:left .5s ease; z-index:0}
.toc a:hover{transform:translateX(4px); background:rgba(212,175,55,.08); border-color:rgba(139,69,19,.3);
             box-shadow:0 4px 12px rgba(139,69,19,.15), inset 0 1px 2px rgba(212,175,55,.2)}
.toc a:hover::before{left:100%}
.toc a > *{position:relative; z-index:1}
.toc a.active{background:linear-gradient(135deg, rgba(212,175,55,.12), rgba(139,69,19,.08)); 
              border-color:var(--bronze); box-shadow:inset 0 1px 3px rgba(212,175,55,.2);
              transform:translateX(2px)}
.toc-category{margin:0}
.toc-category > a{position:relative; cursor:pointer}
.toc-category > a::after{content:'‚ñº'; position:absolute; right:8px; top:50%; transform:translateY(-50%); 
                         font-size:10px; transition:transform .3s ease; color:var(--bronze)}
.toc-category.collapsed > a::after{transform:translateY(-50%) rotate(-90deg)}
.toc-sub{margin-left:24px;border-left:2px solid var(--rule);padding-left:8px; 
         overflow:hidden; transition:all .3s ease}
.toc-category.collapsed .toc-sub{max-height:0; opacity:0; padding-top:0; padding-bottom:0; margin-top:0; margin-bottom:0}
.toc-category:not(.collapsed) .toc-sub{max-height:500px; opacity:1}
.toc-sub a{font-size:14px;padding:6px 8px; margin-left:4px}
.toc-sub a:hover{transform:translateX(6px); margin-left:0}

/* Outils lat√©raux */
.tools{display:flex;gap:var(--space-md);flex-wrap:wrap;margin:var(--space-md) 0}

/* Article and section layout */
article{display:none}
article.active{display:block}
section{background:var(--card);border:1px solid var(--rule);border-radius:14px;box-shadow:var(--shadow);padding:18px;margin:0 0 14px}

/* Footer */
footer{padding:24px;text-align:center;color:var(--paper-muted)}

/* Print styles */
@media print{ 
  .sidebar, .tools{display:none} 
  .page{grid-template-columns:1fr;padding:0} 
  section{break-inside:avoid;box-shadow:none} 
}

/* Responsive */
@media (max-width: 768px) {
  .illus .thumb { width: 100%; max-width: 300px; height: auto; }
}
/* Component base classes */
.card-base{background:var(--card);border:2px solid var(--rule);border-radius:14px;box-shadow:var(--card-shadow);padding:14px;position:relative;overflow:hidden}
.card-base::before{content:''; position:absolute; top:0; left:0; right:0; height:1px;background:linear-gradient(90deg, transparent, var(--gold), transparent); opacity:.6}
.card-base::after{content:''; position:absolute; bottom:0; left:0; right:0; height:1px;background:linear-gradient(90deg, transparent, var(--bronze), transparent); opacity:.3}

.btn-base{display:inline-flex;gap:var(--space-md);align-items:center;background:var(--card);border:2px solid var(--rule);border-radius:12px;padding:var(--space-md) var(--space-lg);box-shadow:var(--card-shadow);cursor:pointer;transition:var(--transition-fast);font-weight:500}
.btn-base:hover{transform:translateY(-1px);box-shadow:0 8px 25px rgba(0,0,0,.15);border-color:var(--bronze)}
.btn-small{padding:var(--space-sm) var(--space-md)}

.modal-base{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);z-index:99999;display:none;align-items:center;justify-content:center}
.modal-base.visible{display:flex}
.modal-content-base{background:var(--card);border:2px solid var(--rule);border-radius:16px;padding:var(--space-2xl);box-shadow:var(--shadow);position:relative}

/* Cards */
.card{border:2px solid var(--rule);border-radius:14px;padding:14px;
      background:linear-gradient(145deg, #faf7f0, var(--card), #f8f4e8);
      box-shadow:var(--card-shadow); position:relative; overflow:hidden}
.card::before{content:''; position:absolute; top:0; left:0; right:0; height:1px;
              background:linear-gradient(90deg, transparent, var(--gold), transparent); opacity:.6}
.card::after{content:''; position:absolute; bottom:0; left:0; right:0; height:1px;
             background:linear-gradient(90deg, transparent, var(--bronze), transparent); opacity:.3}
.card ul, ul{padding-left:35px !important;margin-left:0 !important}

/* Buttons */
.btn{display:inline-flex;gap:var(--space-md);align-items:center;background:var(--card);border:2px solid var(--rule);border-radius:12px;padding:var(--space-md) var(--space-lg);box-shadow:var(--card-shadow);cursor:pointer;
     transition:var(--transition-fast); font-weight:500}
.btn:hover{transform:translateY(-1px); box-shadow:0 8px 25px rgba(0,0,0,.15); border-color:var(--bronze)}
.btn.small{padding:var(--space-sm) var(--space-md)}

/* Search bar */
.searchbar{display:flex;gap:var(--space-md);align-items:center}
.searchbar input{flex:1 1 auto;max-width:100%;height:38px;font-size:15px;padding:var(--space-md) 10px;border-radius:10px;border:1px solid var(--rule);background:#fff6e8;color:inherit}
.searchbar button{height:38px}

/* Illustrations */
.illus{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap;margin:.6rem 0}
.illus img{max-width:100%;height:auto;border-radius:12px; transition:all .3s ease}
.illus img.enlarged{transition:none !important}
.illus .thumb{width:500px;height:300px;object-fit:contain}

/* Images avec cadres - syst√®me unifi√© */
.illus-spell, .illus-class, .illus-subclass, .illus-don,
article[data-page="guerrier"] .illus,
article[data-page="mage"] .illus,
article[data-page="pretre"] .illus,
article[data-page="rodeur"] .illus,
article[data-page="enchanteur"] .illus,
.illus[data-illus-key^="class:"],
.illus[data-illus-key^="subclass:"],
.illus[data-illus-key^="spell:"],
.illus[data-illus-key^="sort:"],
.illus[data-illus-key^="spellcategory:"],
.illus[data-illus-key^="don:"] {
  display:flex !important; flex-direction:column !important; align-items:center !important;
  justify-content:center !important; margin:1rem auto !important;
}

.illus-spell img, .illus-class img, .illus-subclass img, .illus-don img,
article[data-page="guerrier"] .illus img,
article[data-page="mage"] .illus img,
article[data-page="pretre"] .illus img,
article[data-page="rodeur"] .illus img,
article[data-page="enchanteur"] .illus img,
.illus[data-illus-key^="class:"] img,
.illus[data-illus-key^="subclass:"] img,
.illus[data-illus-key^="spell:"] img,
.illus[data-illus-key^="sort:"] img,
.illus[data-illus-key^="spellcategory:"] img,
.illus[data-illus-key^="don:"] img {
  border:var(--image-border) !important; 
  box-shadow:var(--image-shadow) !important;
  padding:4px !important; 
  background:transparent !important;
  border-radius:16px !important; 
  max-width:fit-content !important;
  width:auto !important;
  cursor:pointer !important;
}

.illus-spell img:hover, .illus-class img:hover, .illus-subclass img:hover, .illus-don img:hover,
article[data-page="guerrier"] .illus img:hover,
article[data-page="mage"] .illus img:hover,
article[data-page="pretre"] .illus img:hover,
article[data-page="rodeur"] .illus img:hover,
article[data-page="enchanteur"] .illus img:hover,
.illus[data-illus-key^="class:"] img:hover,
.illus[data-illus-key^="subclass:"] img:hover,
.illus[data-illus-key^="spell:"] img:hover,
.illus[data-illus-key^="sort:"] img:hover,
.illus[data-illus-key^="spellcategory:"] img:hover,
.illus[data-illus-key^="don:"] img:hover {
  transform:scale(1.03) !important; 
  box-shadow:var(--image-shadow), 0 8px 25px rgba(139,69,19,.25) !important;
}

/* Variantes de taille d'images */
.illus-small img { max-width: 150px !important; }
.illus-large img { max-width: 400px !important; }

/* Style sp√©cial pour les sorts - cadre dor√© et taille augment√©e */
.illus-spell img,
.card .illus img {
  border: 3px solid var(--gold) !important;
  box-shadow: var(--image-shadow), 0 0 10px rgba(212,175,55,.3) !important;
  max-width: 350px !important;
  max-height: 250px !important;
  object-fit: contain !important;
}

/* Style sp√©cial pour les sous-classes - 2 images centr√©es et coll√©es */
.subclass-images {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0;
  margin: 0.6rem 0;
}

.subclass-images .illus {
  margin: 0;
  flex: 0 0 auto;
}

.subclass-images .illus img {
  max-width: 400px !important;
  max-height: 300px !important;
  object-fit: contain !important;
  border-radius: 12px 0 0 12px !important;
}

.subclass-images .illus:last-child img {
  border-radius: 0 12px 12px 0 !important;
}

/* Style sp√©cial pour les titres de sous-classes */
.subclass-title {
  font-size: 1.8rem !important;
  font-weight: 600 !important;
  text-align: center !important;
  margin: 0 0 1.5rem 0 !important;
  color: var(--accent-ink) !important;
  font-family: 'Cinzel', serif !important;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.1) !important;
  letter-spacing: 0.5px !important;
}
/* Editor and Dev Mode styles */

/* === HIDE ALL EDITING ELEMENTS IN STANDALONE MODE === */
/* Hide all editing elements when dev mode is OFF */

/* ULTRA NUCLEAR OPTION - Hide ALL editing buttons when dev mode is OFF */
/* This rule will override ANY other CSS that might be showing edit buttons */
body.dev-off button[title*="‚úèÔ∏è"],
body.dev-off *[class*="edit"],
body.dev-off *[class*="Edit"],

/* NUCLEAR OPTION - Hide all buttons with editing text content */
body.dev-off button:is([class*="add"], [class*="delete"], [class*="remove"], [class*="move"], [class*="upload"], [class*="edit"]),
body.dev-off button[data-category-name],
body.dev-off button[data-spell-name], 
body.dev-off button[data-don-name],
body.dev-off button[data-section-name],
body.dev-off button[data-section-type],
body.dev-off .btn:is([class*="add"], [class*="delete"], [class*="remove"], [class*="move"], [class*="edit"]),
body.dev-off .add-paragraph-btn,
body.dev-off .section-delete,
body.dev-off .spell-delete,
body.dev-off .don-delete,
body.dev-off .don-move-up,
body.dev-off .don-move-down,
body.dev-off .remove-section-btn,
body.dev-off .illus .up,
body.dev-off .illus .rm,
body.dev-off .illus label.up,
body.dev-off .illus button.rm,
body.dev-off .illus label,
body.dev-off .illus input[type="file"],
body.dev-off button[class*="add"]:not(.menu-toggle),
body.dev-off button[class*="delete"],
body.dev-off button[class*="remove"],
body.dev-off button[class*="move"],
body.dev-off button[class*="edit"],
body.dev-off .spell-add,
body.dev-off .don-add,
body.dev-off .category-add,
body.dev-off .add-*,
body.dev-off [data-bound] .up,
body.dev-off [data-bound] .rm,
body.dev-off [data-bound] label,
body.dev-off [data-bound] button,
/* Specific button selectors */
body.dev-off button[data-category-name],
body.dev-off button[data-spell-name],
body.dev-off button[data-don-name],
body.dev-off button[data-section-name],
body.dev-off button[data-section-type],
/* Input file upload elements */
body.dev-off input[type="file"],
body.dev-off label[for*="file"],
/* Additional specific selectors */
body.dev-off .add-subclass-btn,
body.dev-off .add-new-section,
/* COMPREHENSIVE EDIT BUTTON HIDING */
body.dev-off .edit-btn,
body.dev-off .edit-title-btn,
body.dev-off .edit-paragraph-btn,
body.dev-off .edit-list-btn,
body.dev-off .edit-field-btn,
body.dev-off .edit-effect-btn,
body.dev-off .edit-stats-btn,
body.dev-off .edit-section-btn,
body.dev-off button.edit-btn,
body.dev-off button.edit-title-btn,
body.dev-off button.edit-paragraph-btn,
body.dev-off button.edit-list-btn,
body.dev-off button.edit-field-btn,
body.dev-off button.edit-effect-btn,
body.dev-off button.edit-stats-btn,
body.dev-off button.edit-section-btn,
body.dev-off .editable-section .edit-btn,
body.dev-off .editable-section button[class*="edit"],
body.dev-off .card .edit-btn,
body.dev-off .card button[class*="edit"],
body.dev-off .editable-item .edit-btn,
body.dev-off .editable-item button[class*="edit"],
body.dev-off [data-section-type] .edit-btn,
body.dev-off [data-section-type] button[class*="edit"],
body.dev-off .add-*-btn,
/* Very specific selectors for inline styled buttons */
body.dev-off button[style*="background: #ff6b6b"],
body.dev-off button[style*="background: var(--bronze)"],
body.dev-off button[style*="background: #dc2626"],
/* Target buttons by text content patterns */
body.dev-off .btn.small[data-category-name],
body.dev-off .btn.small[data-spell-name],  
body.dev-off .btn.small[data-don-name],
body.dev-off .btn.small[data-section-name],
body.dev-off .btn.small[data-don-index],
/* Target specific button classes from renderer */
body.dev-off .spell-add,
body.dev-off .don-add,
body.dev-off .spell-delete,
body.dev-off .don-delete,
body.dev-off .don-move-up,
body.dev-off .don-move-down,
body.dev-off .section-delete,
body.dev-off .remove-section-btn,
/* Universal button selectors with edit-related titles */
body.dev-off button[title*="diter"],
body.dev-off button[title*="Edit"],
body.dev-off button[title*="Supprimer"],
body.dev-off button[title*="Ajouter"],
body.dev-off button[title*="Haut"],
body.dev-off button[title*="Bas"] {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  pointer-events: none !important;
}

/* Syst√®me d'agrandissement d'images */
.illus img.enlarged {
  position:fixed !important; top:50% !important; left:50% !important; 
  transform:translate(-50%, -50%) !important; z-index:9999 !important;
  max-width:85vw !important; max-height:85vh !important; width:auto !important; height:auto !important;
  box-shadow:0 20px 60px rgba(0,0,0,.5), inset 0 4px 12px rgba(212,175,55,.8) !important;
  cursor:zoom-out !important; 
  transition:none !important;
  pointer-events:auto !important;
  object-fit:contain !important;
}

/* Forcer l'√©tat stable sur hover pour les images agrandies */
.illus img.enlarged:hover,
article[data-page="guerrier"] .illus img.enlarged:hover,
article[data-page="mage"] .illus img.enlarged:hover,
article[data-page="pretre"] .illus img.enlarged:hover,
article[data-page="rodeur"] .illus img.enlarged:hover,
article[data-page="enchanteur"] .illus img.enlarged:hover,
.illus[data-illus-key^="class:"] img.enlarged:hover,
article[data-page="sorts-mage"] .illus img.enlarged:hover,
article[data-page="sorts-pretre"] .illus img.enlarged:hover,
article[data-page="sorts-enchanteur"] .illus img.enlarged:hover,
.illus[data-illus-key^="spellcategory:"] img.enlarged:hover {
  transform:translate(-50%, -50%) !important;
  transition:none !important;
}

.image-backdrop {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:9998; opacity:0; transition:opacity .3s ease; pointer-events:none;
}
.image-backdrop.visible {
  opacity:1; pointer-events:auto;
}

/* Interactive buttons */
.btn-action{display:inline-flex;gap:var(--space-sm);align-items:center;padding:var(--space-sm) 10px;border-radius:10px;cursor:pointer;border:1px solid}
.btn-upload{border-color:rgba(0,0,0,.25);border-style:dashed;background:#fff8ee}
.btn-remove{border-color:rgba(120,0,0,.25);background:#fee2e2}
.btn-add{border-color:rgba(0,120,0,.25);background:#f0fff4;margin-bottom:10px}
.btn-delete{padding:var(--space-xs) var(--space-md);border-radius:6px;font-size:12px;margin-left:10px}
.illus .up{border-color:rgba(0,0,0,.25);border-style:dashed;background:#fff8ee}
.illus .rm, .spell-delete{border-color:rgba(120,0,0,.25);background:#fee2e2}
.spell-add{border-color:rgba(0,120,0,.25);background:#f0fff4;margin-bottom:10px}
.spell-delete{padding:var(--space-xs) var(--space-md);border-radius:6px;font-size:12px;margin-left:10px}

/* Bouton d'ajout de paragraphe - seulement dans les articles */
.add-paragraph-btn {
  display:none !important;
}
/* Masquer explicitement dans la sidebar et le sommaire */
.sidebar .add-paragraph-btn,
.toc .add-paragraph-btn,
#toc .add-paragraph-btn {
  display:none !important;
  visibility:hidden !important;
}
/* Afficher SEULEMENT dans les articles actifs en mode dev */
body.dev-on article.active .add-paragraph-btn {
  display:block !important; margin:10px 0; padding:8px 12px; background:var(--card); 
  border:2px dashed var(--bronze); border-radius:8px; cursor:pointer;
  color:var(--bronze); text-align:center; transition:all .2s ease;
}
body.dev-on article.active .add-paragraph-btn:hover {
  background:rgba(139,69,19,.08); border-color:var(--gold);
  color:var(--gold);
}

/* Bouton d'ajout de sous-classe */
.add-subclass-btn {
  display:none; margin:12px 0 4px 0; padding:8px 12px; background:var(--card);
  border:1px dashed var(--bronze); border-radius:8px; cursor:pointer;
  color:var(--bronze); text-align:center; font-size:13px;
  transition:all .2s ease; width:100%;
}
/* Afficher dans les pages de classes en mode dev */
body.dev-on article[data-page="guerrier"] .add-subclass-btn,
body.dev-on article[data-page="mage"] .add-subclass-btn,
body.dev-on article[data-page="pretre"] .add-subclass-btn,
body.dev-on article[data-page="rodeur"] .add-subclass-btn,
body.dev-on article[data-page="enchanteur"] .add-subclass-btn {
  display:block !important;
}
body.dev-on article[data-page="guerrier"] .add-subclass-btn:hover,
body.dev-on article[data-page="mage"] .add-subclass-btn:hover,
body.dev-on article[data-page="pretre"] .add-subclass-btn:hover,
body.dev-on article[data-page="rodeur"] .add-subclass-btn:hover,
body.dev-on article[data-page="enchanteur"] .add-subclass-btn:hover {
  background:rgba(139,69,19,.08); border-color:var(--gold);
  color:var(--gold); transform:translateY(-1px);
  box-shadow:0 4px 8px rgba(0,0,0,.1);
}

/* Modales */
.category-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.category-modal.visible {
  display:flex;
}
.category-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:500px; width:90%; box-shadow:var(--shadow);
  position:relative;
}

/* Modal pour les ic√¥nes */
.icons-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.icons-modal.visible {
  display:flex;
}
.icons-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:600px; width:90%; max-height:80vh; overflow-y:auto;
  box-shadow:var(--shadow); position:relative;
}
.icons-grid {
  display:grid; grid-template-columns:repeat(auto-fill, minmax(60px, 1fr));
  gap:var(--space-md); margin:var(--space-xl) 0; max-height:400px; overflow-y:auto;
  border:1px solid var(--rule); border-radius:var(--space-md); padding:var(--space-xl);
}
.icon-item {
  display:flex; align-items:center; justify-content:center;
  padding:var(--space-lg); border:1px solid var(--rule); border-radius:var(--space-md);
  cursor:pointer; transition:var(--transition-fast); font-size:24px;
  background:var(--paper);
}
.icon-item:hover {
  background:var(--bronze); color:white; transform:scale(1.1);
  box-shadow:0 4px 8px rgba(0,0,0,.2);
}
.icon-item.copied {
  background:var(--gold); color:white; animation:copyFlash .5s ease;
}
@keyframes copyFlash {
  0% { transform:scale(1.1); }
  50% { transform:scale(1.3); }
  100% { transform:scale(1.1); }
}

/* Modal pour les √©l√©ments */
.elements-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.elements-modal.visible {
  display:flex;
}
.elements-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:400px; width:90%; 
  box-shadow:var(--shadow); position:relative;
}
.elements-list {
  display:flex; flex-direction:column; gap:var(--space-md); margin:var(--space-xl) 0;
}
.element-item {
  display:flex; align-items:center; gap:var(--space-md); padding:var(--space-md);
  border:2px solid var(--rule); border-radius:var(--space-md); cursor:pointer;
  transition:var(--transition-fast); background:var(--card);
}
.element-item:hover {
  background:var(--paper); border-color:var(--bronze); transform:translateY(-2px);
  box-shadow:0 4px 12px rgba(0,0,0,.1);
}
.element-item:active {
  transform:translateY(0) scale(0.98);
}
.element-icon {
  width:24px; height:24px; border-radius:50%; flex-shrink:0;
}
.element-name {
  font-weight:600; flex-grow:1;
}
.copy-indicator {
  font-size:12px; color:var(--paper-muted); opacity:0;
  transition:opacity 0.3s ease;
}
.element-item.copied .copy-indicator {
  opacity:1;
}

/* === UNIFIED EDIT BUTTONS FOR ALL SECTIONS === */
.editable-section {
  position: relative;
  margin: 8px 0;
}

.editable-section .edit-btn {
  position: absolute;
  right: 8px;
  top: 8px;
  background: var(--bronze);
  color: white;
  border: none;
  border-radius: 6px;
  padding: 4px 8px;
  cursor: pointer;
  font-size: 12px;
  opacity: 0.6;
  transition: all 0.2s ease;
  z-index: 10;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.editable-section:hover .edit-btn {
  opacity: 1;
  transform: scale(1.05);
  background: var(--gold);
}

.editable-section .edit-btn:hover {
  background: var(--gold) !important;
  transform: scale(1.1) !important;
  box-shadow: 0 3px 8px rgba(0,0,0,0.2);
}

.editable-section .edit-btn:active {
  transform: scale(0.95) !important;
}

/* Special positioning for different types */
.editable-list-container .edit-btn {
  right: 16px;
  top: 16px;
}

.editable-section[data-section-type="intro"] .edit-btn {
  right: 12px;
  top: 12px;
}

/* Title edit buttons */
.edit-title-btn {
  position: relative !important;
  right: auto !important;
  top: auto !important;
  margin-left: 12px;
  transform: none !important;
}

.edit-title-btn:hover {
  transform: scale(1.1) !important;
}

/* When editing, hide the button and expand content */
.editable-section[data-editing="true"] .edit-btn {
  display: none;
}

/* Visual feedback for editable sections */
.editable-section:hover {
  background: rgba(184, 134, 11, 0.05);
  border-radius: 8px;
  transition: background 0.2s ease;
}

.editable-section[data-editing="true"] {
  background: rgba(255, 255, 0, 0.1);
  border: 1px dashed var(--bronze);
  border-radius: 8px;
  padding: 8px;
}

/* Legacy support for old list items */
.editable-item {
  position: relative;
  padding-right: 40px;
}

.editable-content {
  display: block;
  margin-right: 35px;
}
</style>
</head>
<body class="dev-off">

<div class="shell">
  <button aria-controls="sidebar" aria-expanded="false" aria-label="Ouvrir le sommaire" class="menu-toggle" id="menuToggle" style="display:none">‚ò∞ Sommaire</button>
  <div class="backdrop" hidden="" id="backdrop"></div>
  
  <main class="page">
    <aside class="sidebar" id="sidebar">
      <div class="panel">
        <div class="searchbar">
          <input autocomplete="off" id="search" placeholder="Rechercher une r√®gle, une classe‚Ä¶">
          <button class="btn" id="clear" title="Effacer">‚úñ</button>
        </div>
        <div class="tools">
          <!-- Dev mode disabled in standalone version -->
        </div>
        <div class="toc" id="toc">
          <!-- Table of contents will be generated by JavaScript -->
        </div>
      </div>
    </aside>
    
    <div id="views">
      <!-- Main content will be generated by JavaScript -->
      <div id="app-loading">Chargement...</div>
    </div>
  </main>
  
  <footer>
    <p>JDR‚ÄëBAB ‚Äî R√®gles et contenus sous licence libre</p>
  </footer>
</div>

<script>

    // Global data from modular files
    window.SORTS = [
  {
    "nom": "Sorts de Mage",
    "description": "Sorts de destruction.",
    "sorts": [
      {
        "nom": "Boule de Feu",
        "description": "Lance une boule de Feu sur un adversaire.",
        "categorie": "Mage",
        "prerequis": "üìã <strong>Pr√©requis:</strong> Niveau 1",
        "portee": "üéØ <strong>Port√©e:</strong> 20m",
        "tempsIncantation": "‚è∞ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "üîµ <strong>Co√ªt mana:</strong> 3",
        "duree": "‚è≥ <strong>Dur√©e:</strong> Instantan√©",
        "resistance": "<strong>Sans effet si:</strong> Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige 5 d√©gats de <span style=\"color: #e25822; font-weight: bold;\">Feu</span> √† la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les d√©gats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Double les d√©g√¢ts et enflamme la cible, infligeant 2 d√©gats de Feu au prochain tour du lanceur.",
        "effetEchec": "<strong>√âchec Critique:&nbsp;</strong>Le sort inflige ses d√©gats √† un alli√© dans la trajectoire."
      },
      {
        "nom": "√âclair",
        "description": "Frappe une cible avec un √©clair √©lectrique.",
        "categorie": "Mage",
        "prerequis": "üìã <strong>Pr√©requis:</strong> Niveau 2",
        "portee": "üéØ <strong>Port√©e:</strong> 20m",
        "tempsIncantation": "‚è∞ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "üîµ <strong>Co√ªt mana:</strong> 5",
        "duree": "‚è≥ <strong>Dur√©e:</strong> Instantan√©",
        "resistance": "<strong>Sans effet si:</strong> Aucune",
        "effetNormal": "<strong>Effet:</strong> &nbsp;Inflige 6 d√©gats d'<span style=\"color: #22c55e; font-weight: bold;\">Air</span> √† la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les d√©gats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>Double les d√©g√¢ts et inflige les d√©gats √† un enemy √† moins de 5m de la cible.",
        "effetEchec": "<strong>√âchec Critique:&nbsp;</strong>Le sort inflige ses d√©gats √† un alli√© dans la trajectoire."
      },
      {
        "nom": "Vague d√©ferlante",
        "description": "Une puissante vague d'eau s'abat sur vos ennemis.",
        "categorie": "Sorts de Mage",
        "prerequis": "üìã <strong>Pr√©requis:</strong> Niveau 3",
        "portee": "üéØ <strong>Port√©e:</strong> 5m",
        "coutMana": "üîµ <strong>Co√ªt mana:</strong> 6",
        "tempsIncantation": "‚è∞ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "‚è≥ <strong>Dur√©e:</strong> Instantan√©",
        "resistance": "<strong>Sans effet si:</strong> Volant.",
        "effetNormal": "<strong>Effet:</strong> &nbsp;Inflige 6 d√©gats d'<span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span> aux cr√©ature devant le lanceur (largeur 1.5m distance 5m) et les repousse jusqu'√† 5m.<br>&nbsp;Tous les 5 points d'intelligence, augmente les d√©gats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>Double d√©gats et port√©e.",
        "effetEchec": "<strong>√âchec Critique:&nbsp;</strong>Sans effet."
      }
    ]
  },
  {
    "nom": "Sorts de Pr√™tre",
    "description": "Sorts de soutiens et anti mort-vivants.",
    "sorts": [
      {
        "nom": "Ch√¢timent",
        "description": "Invoque un magie divine qui blesse les morts-vivants",
        "categorie": "Anti-mort-vivant",
        "prerequis": "üìã <strong>Pr√©requis:</strong> Niveau 1",
        "portee": "üéØ <strong>Port√©e:</strong> 20m",
        "tempsIncantation": "‚è∞ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "üîµ <strong>Co√ªt mana:</strong> 3",
        "duree": "‚è≥ <strong>Dur√©e:</strong> Instantan√©",
        "resistance": "<strong>Sans effet si:</strong> &nbsp;<br>- Non mort-vivant <br>- Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige *Intelligence* d√©g√¢ts <span style=\"color: #ffd700; font-weight: bold;\">Divin</span> √† la cible.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>Double d√©g√¢ts.",
        "effetEchec": "<strong>√âchec Critique:&nbsp;</strong>Sans effet."
      },
      {
        "nom": "Soin mineur",
        "description": "Une magie divine soigne les blessures du h√©ros ou d'un alli√© proche.",
        "categorie": "Sorts de Pr√™tre",
        "prerequis": "üìã <strong>Pr√©requis:</strong> Niveau 1",
        "portee": "üéØ <strong>Port√©e:</strong> 10m",
        "coutMana": "üîµ <strong>Co√ªt mana:</strong> 5",
        "tempsIncantation": "‚è∞ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "‚è≥ <strong>Dur√©e:</strong> Instantan√©",
        "resistance": "<strong>Sans effet si:</strong> &nbsp;mort-vivant.",
        "effetNormal": "<strong>Effet:</strong> Soigne la cible de 5 points de vie. Tous les 5 points d'intelligence, augmente le soin de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>Double le soin.",
        "effetEchec": "<strong>√âchec Critique:&nbsp;</strong>Sans effet."
      },
      {
        "nom": "Protection",
        "description": "Prot√®ge le lanceur ou un alli√©.",
        "categorie": "Sorts de Pr√™tre",
        "prerequis": "üìã <strong>Pr√©requis:</strong> Niveau 2",
        "portee": "üéØ <strong>Port√©e:</strong> 3m",
        "tempsIncantation": "‚è∞ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "üîµ <strong>Co√ªt mana:</strong> 5",
        "duree": "‚è≥ <strong>Dur√©e:</strong> Instantan√©",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Augmente l'armure de 3 pendant 5 tours.<br> Tous les 5 d'Intelligence, augmente l'armure de 1 suppl√©mentaire.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> Double l'armure prodigu√©e.",
        "effetEchec": "<strong>√âchec Critique:&nbsp;</strong> Sans effet."
      }
    ]
  },
  {
    "nom": "Sorts d'Enchanteur",
    "description": "Sorts d'am√©lioration et d'affaiblissement.",
    "sorts": [
      {
        "nom": "Accroche terrestre",
        "description": "Le sol se soul√®ve et s'agrippe aux jambes de la cible, alourdissant ses pas d'une √©treinte de pierre vivante.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "üìã <strong>Pr√©requis:</strong> Niveau 1",
        "portee": "üéØ <strong>Port√©e:</strong> 30m",
        "coutMana": "üîµ <strong>Co√ªt mana:</strong> 3",
        "tempsIncantation": "‚è∞ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "‚è≥ <strong>Dur√©e:</strong> Instantan√©",
        "resistance": "<strong>Sans effet si:</strong> <br>- Volont√© &gt; Intelligence du lanceur<br>- Element <span style=\"color: #8b5e34; font-weight: bold;\">Terre</span><br>- L√©vitation ou Volant.",
        "effetNormal": "<strong>Effet:</strong>&nbsp;La cible voit sa vitesse de d√©placement r√©duite de moiti√©e et ne peut plus esquiver ou sauter.",
        "effetCritique": "<strong>&nbsp;</strong>&nbsp;La cible est immobilis√©e pendant la dur√©e du sort.",
        "effetEchec": "<strong>&nbsp;</strong>&nbsp;Aucun effet."
      },
      {
        "nom": "Acc√©l√©ration",
        "description": "Une magie des vents acc√©l√®re un alli√© ou le lanceur.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "üìã <strong>Pr√©requis:</strong> Niveau 1",
        "portee": "üéØ <strong>Port√©e:</strong> 5m",
        "coutMana": "üîµ <strong>Co√ªt mana:</strong> 4",
        "tempsIncantation": "‚è∞ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "‚è≥ <strong>Dur√©e:</strong> Instantan√©",
        "resistance": "<strong>Sans effet si:</strong> Aucune",
        "effetNormal": "<strong>Effet:</strong> &nbsp;La vitesse de d√©placement de la cible est augment√©e de 50% pendant 5 tours.<br>Non Cumulable. Si le sort est lanc√© √† nouveau, les anciennes cibles perdent l'am√©lioration.&nbsp;",
        "effetCritique": "La vitesse est augment√©e de 100%.",
        "effetEchec": "Aucun effet."
      },
      {
        "nom": "Sommeil",
        "description": "Un voile d'ombre caresse la cible, l'enveloppant dans un sommeil surnaturel.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "üìã <strong>Pr√©requis:</strong> Niveau 2",
        "portee": "üéØ <strong>Port√©e:</strong> 5m",
        "coutMana": "üîµ <strong>Co√ªt mana:</strong> 8",
        "tempsIncantation": "‚è∞ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "‚è≥ <strong>Dur√©e:</strong> Instantan√©",
        "resistance": "<strong>Sans effet si:</strong> <br>- Volont√© &gt; Intelligence du lanceur<br>- Element <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span>",
        "effetNormal": "<strong>Effet:</strong> La cible devient inactive pendant ses 2 prochains tours. Si la cible subit des d√©gats, elle est reveill√©e.",
        "effetCritique": "L'effet dure 4 tours.",
        "effetEchec": "Le lanceur est endormi √† son prochain tour."
      }
    ]
  },
  {
    "nom": "Sorts de Monstres",
    "description": "Sorts divers de monstres.",
    "sorts": []
  }
];
    window.CLASSES = [
  {
    "nom": "Guerrier",
    "resume": "H√©ros sans √©gal au combat au corp √† corp.",
    "capacites": [
      "<em>Expert de l'√©quipement</em>: Toutes les armes, armures (l√©g√®res/lourdes), bouclier.",
      "<em>Hardiesse</em>: Gagne la comp√©tence Hardiesse rang 1."
    ],
    "sousClasses": [
      {
        "nom": "Nain des montagnes",
        "base": {
          "Force": "5",
          "Agilit√©": "2",
          "Endurance": "7",
          "Intelligence": "1",
          "Volont√©": "5",
          "Chance": "1"
        },
        "progression": "<strong>üìà Progression par niveau:</strong> +2 Force üí™, +3 Endurance üõ°Ô∏è, +1 Volont√©‚ö°",
        "capacites": [
          "<em>Brise rocher</em>: Gagne 1 de comp√©tence sur les tests de comp√©tence Hardiesse pour une destruction d'objet.",
          "<em>Volont√© inflexible</em>: Les nains poss√®dent une volont√© inflexible qui les rendent r√©sistants aux sortil√®ges (caract√©ristique Volont√© √©lev√©e)."
        ]
      },
      {
        "nom": "Berserker",
        "base": {
          "Force": 5,
          "Agilit√©": 4,
          "Endurance": 5,
          "Intelligence": 1,
          "Volont√©": 1,
          "Chance": 1
        },
        "progression": "<strong>üìà Progression par niveau:</strong> +2 Force üí™, +1 Agilit√© üèÉ, +2 Endurance üõ°Ô∏è",
        "capacites": [
          "<em>Frappe en cha√Æne</em>: Sur un critique au corps √† corps, touche aussi un adversaire √† moins de 2m.",
          "<em>Risque sauvage</em>: +1 chance de critique physique s'il ne porte pas de bouclier."
        ]
      }
    ]
  },
  {
    "nom": "Mage",
    "resume": "Sp√©cialiste de la magie destructrice.",
    "capacites": [
      "<em>√âquipement de mage</em>: b√¢tons, robes.",
      "<em>Sorts de mage</em>: Apprend et lance des sorts de mage."
    ],
    "sousClasses": [
      {
        "nom": "√ârudit",
        "base": {
          "Force": 1,
          "Agilit√©": 1,
          "Endurance": 2,
          "Intelligence": 5,
          "Volont√©": 3,
          "Chance": 1
        },
        "progression": "<strong>üìà Progression par niveau:</strong> +3 Intelligence üß†, +2 Volont√© ‚ö°",
        "capacites": [
          "<em>Instruit</em>: Gagne la comp√©tence R√©flexion rang 1.",
          "<em>Apprentissage acc√©l√©r√©</em>: Le niveau de l'√©rudit est consid√©r√© comme deux fois plus grand pour les pr√©requis d'apprentissage de sorts."
        ]
      },
      {
        "nom": "Elfe",
        "base": {
          "Force": 2,
          "Agilit√©": 2,
          "Endurance": 3,
          "Intelligence": 3,
          "Volont√©": 2,
          "Chance": 1
        },
        "progression": "<strong>üìà Progression par niveau:</strong> +1 Force üí™, +1 Agilit√© üèÉ, +1 Endurance üõ°Ô∏è, +1 Intelligence üß†, +1 Volont√© ‚ö°",
        "capacites": [
          "<em>Instinct elfique</em>: Gagne la comp√©tence Coordination rang 1.",
          "<em>√âquipement d'elfe</em>: Ep√©es √† une main, armures l√©g√®res.",
          "<em>Briseur de sceaux</em>: Gagne 1 de comp√©tence sur les tests de comp√©tence pour comprendre ou ouvrir une porte scell√©e magiquement"
        ]
      }
    ]
  },
  {
    "nom": "Pr√™tre",
    "resume": "Sp√©cialiste de la magie de soutien et anti morts-vivants.",
    "capacites": [
      "<em>√âquipement de pr√™tre</em>: b√¢tons, robes.",
      "<em>Sorts de pr√™tre</em>: Apprend et lance des sorts de Pr√™tre.",
      "<em>Eloquence</em>: Gagne la comp√©tence Eloquence rang 1."
    ],
    "sousClasses": [
      {
        "nom": "Inquisiteur",
        "base": {
          "Force": 3,
          "Agilit√©": 1,
          "Endurance": 4,
          "Intelligence": 3,
          "Volont√©": 5,
          "Chance": 1
        },
        "progression": "<strong>üìà Progression par niveau:</strong> +1 Force üí™, +2 Intelligence üß†, +1 Volont√© ‚ö°, +1 Endurance üõ°Ô∏è",
        "capacites": [
          "<em>Magie purificatrice</em>: Les sorts visant les morts-vivants ne ratent jamais.",
          "<em>Port du bouclier</em>: Peut s'√©quiper d'un bouclier."
        ]
      },
      {
        "nom": "Clerc Divin",
        "base": {
          "Force": 1,
          "Agilit√©": 1,
          "Endurance": 2,
          "Intelligence": 3,
          "Volont√©": 5,
          "Chance": 5
        },
        "progression": "<strong>üìà Progression par niveau:</strong> +2 Intelligence üß†, +2 Volont√© ‚ö°, + 1 Chance üçÄ",
        "capacites": [
          "<em>Ma√Ætre des soins</em>: Augmente les chances de critiques pour les sorts de soins de 1.",
          "<em>Bien n√©</em>: R√©duit les d√©gats <span style=\"color: #ffd700; font-weight: bold;\">Divin</span> re√ßu de 50%. Si son √©l√©ment d'affiliation est <span style=\"color: #ffd700; font-weight: bold;\">Divin</span>, il devient insensible aux d√©gats <span style=\"color: #ffd700; font-weight: bold;\">Divin</span>."
        ]
      }
    ]
  },
  {
    "nom": "R√¥deur",
    "resume": "H√©ros tr√®s agile.",
    "capacites": [
      "<em>√âquipement de r√¥deur</em>: armures l√©g√®res, dagues.",
      "<em>Coordination</em>: Gagne la comp√©tence Coordination rang 1."
    ],
    "sousClasses": [
      {
        "nom": "Voleur",
        "base": {
          "Force": 3,
          "Agilit√©": 5,
          "Endurance": 2,
          "Intelligence": 2,
          "Volont√©": 2,
          "Chance": 5
        },
        "progression": "<strong>üìà Progression par niveau:</strong> +3 Agilit√© üèÉ, +1 Force üí™, +1 Endurance üõ°Ô∏è",
        "capacites": [
          "<em>Mains expertes</em>: Gagne la comp√©tence Finesse rang 1.",
          "<em>Sprint</em>: Peut utiliser une Action secondaire pour doubler sa vitesse.",
          "<em>Vicieux</em>: Un coup critique dans le dos triple les d√©gats au lieu de les doubler."
        ]
      },
      {
        "nom": "Chasseur",
        "base": {
          "Force": 3,
          "Agilit√©": 5,
          "Endurance": 2,
          "Intelligence": 4,
          "Volont√©": 2,
          "Chance": 1
        },
        "progression": "<strong>üìà Progression par niveau:</strong> +2 Agilit√© üèÉ, +1 Force üí™, +1 Endurance üõ°Ô∏è, +1 Intelligence üß†",
        "capacites": [
          "<em>Ma√Ætrise des plantes</em>: Peut utiliser des plantes m√©dicinales. Leur utilisation n√©cessite un niveau d'Intelligence.",
          "<em>Armes du Chasseur</em>: Peut utiliser les √©p√©es courtes et les arcs.",
          "<em>Connaissance de la nature</em>: Gagne 1 de comp√©tence sur les tests de R√©flexion li√© √† animal ou une plante."
        ]
      }
    ]
  },
  {
    "nom": "Enchanteur",
    "resume": "D√©tenteur d'une magie singuli√®re, qui fait de lui un alli√© pr√©cieux.",
    "capacites": [
      "<em>√âquipement d'enchanteur</em>: robes, b√¢tons, baguettes.",
      "<em>Sorts d'enchanteur</em>: Apprend et lance des sorts d'Enchanteur."
    ],
    "sousClasses": [
      {
        "nom": "Esprit de la grande F√©e",
        "base": {
          "Force": 1,
          "Agilit√©": 5,
          "Endurance": 1,
          "Intelligence": 5,
          "Volont√©": 2,
          "Chance": 1
        },
        "progression": "<strong>üìà Progression par niveau:</strong> +1 Agilit√© üèÉ, +2 Intelligence üß†, +1 Volont√© ‚ö°, +1 Chance üçÄ",
        "capacites": [
          "<em>Tatillon</em>: Gagne la comp√©tence Finesse rang 1.",
          "<em>L√©vitation</em>: ignore d√©g√¢ts/ralentissements venant du sol.",
          "<em>Rayon de l'Amiti√©</em>: les sorts b√©n√©fiques ciblent 1 alli√© suppl√©mentaire."
        ]
      },
      {
        "nom": "Lutin",
        "base": {
          "Force": 1,
          "Agilit√©": 1,
          "Endurance": 1,
          "Intelligence": 5,
          "Volont√©": 2,
          "Chance": 5
        },
        "progression": "<strong>üìà Progression par niveau:</strong> +2 Intelligence üß†, +1 Volont√© ‚ö°, +2 Chance üçÄ",
        "capacites": [
          "<em>Secrets bien gard√©s</em>: Gagne la comp√©tence Reflexion rang 1.",
          "<em>Expert des baguettes</em>: sur critique √† la baguette, la charge n'est pas consomm√©e.",
          "<em>Sourire malicieux</em>: les sorts √† effets n√©gatifs peuvent cibler 1 adversaire suppl√©mentaire."
        ]
      }
    ]
  }
];
    window.DONS = [
  {
    "nom": "Guerrier",
    "description": "Dons accessibles aux guerriers.",
    "dons": [
      {
        "nom": "Expertise du bouclier",
        "description": "Si le h√©ros a un bouclier √©quip√©, il peut utiliser une action secondaire pour doubler son armure physique jusqu'au prochain tour.",
        "prerequis": "-",
        "cout": "1 point de don"
      },
      {
        "nom": "Charge",
        "description": "Une fois par combat, peut utiliser une action secondaire pour doubler sa vitesse de d√©placement et forcer un coup critique sur la prochaine attaque physique de ce tour (si elle r√©ussie).",
        "prerequis": "üèÉAgilit√© 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Volont√© de fer",
        "description": "Une fois par jour, le h√©ros peut utiliser une action secondaire pour se d√©barasser de toutes ses alterations magiques.",
        "prerequis": "‚ö°Volont√© 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Coup de bouclier",
        "description": "Si le h√©ros a un bouclier √©quip√©, lorsque le h√©ros subit des d√©gats aux corps √† corps, il peut choisir d'utiliser une action secondaire pour infliger √† l'attaquant des d√©gats √©quivalents √† l'armure du bouclier.",
        "prerequis": "-",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "R√¥deur",
    "description": "Description de cette cat√©gorie de dons.",
    "dons": [
      {
        "nom": "Croche-patte",
        "description": "Peut utiliser une action secondaire pour mettre un adversaire au corp √† corp, de moins de 2m, et qui se trouve au sol, √† <span style=\"color: #8b5e34; font-weight: bold;\">Terre</span>.",
        "prerequis": "-",
        "cout": "1 point de don"
      },
      {
        "nom": "Chasse et p√™che",
        "description": "Le h√©ros n'as plus besoin de sa ratio de nourriture quotidienne.",
        "prerequis": "-",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Mage",
    "description": "Description de cette cat√©gorie de dons.",
    "dons": [
      {
        "nom": "Gemme de mana",
        "description": "Une fois par jour, le h√©ros peut r√©cup√©rer l'int√©gralit√© de son Mana en utilisant une action secondaire.",
        "prerequis": "-",
        "cout": "1 point de don"
      },
      {
        "nom": "Resistance √©l√©mentaire 1",
        "description": "Le h√©ros gagne 5 d'armure √©l√©mentaire de <span style=\"color: #e25822; font-weight: bold;\">Feu</span>, <span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span>, <span style=\"color: #8b5e34; font-weight: bold;\">Terre</span>, <span style=\"color: #22c55e; font-weight: bold;\">Air</span>.",
        "prerequis": "Non cumulable.",
        "cout": "1 point de don"
      },
      {
        "nom": "Resistance magique 1",
        "description": "Le h√©ros gagne 5 d'armure √©l√©mentaire de <span style=\"color: #fbbf24; font-weight: bold;\">Lumi√®re</span>, <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span>, <span style=\"color: #ffd700; font-weight: bold;\">Divin</span>, <span style=\"color: #a855f7; font-weight: bold;\">Mal√©fique</span>.",
        "prerequis": "Non cumulable.",
        "cout": "1 point de don"
      },
      {
        "nom": "Sp√©cialisation √©l√©mentaire 1",
        "description": "Le h√©ros peut choisir un √©l√©ment et augmenter de 5 les d√©gats inflig√©s avec les sorts de cet √©l√©ment.",
        "prerequis": "Non cumulable",
        "cout": "1 point de don"
      },
      {
        "nom": "Infusion √©l√©mentaire",
        "description": "Le h√©ros peut, en utilisant une action secondaire, choisir un de ses sorts et d√©penser son co√ªt en mana. Son arme est alors impr√©gn√©e de l'√©lement du sort, et infligera √† sa prochaine attaque des d√©gats de cet l'√©l√©ment √† la place des d√©gats physiques.",
        "prerequis": "-",
        "cout": "1 point de don"
      },
      {
        "nom": "Polyglotte",
        "description": "Peut lire et parler toutes les langues.",
        "prerequis": "Reflexion rang 2.",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Pretre",
    "description": "Description de cette cat√©gorie de dons.",
    "dons": [
      {
        "nom": "M√©cr√©ants",
        "description": "Les d√©gats physiques inflig√©s aux cr√©atures de l'√©l√©ment <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span> ou <span style=\"color: #a855f7; font-weight: bold;\">Mal√©fique</span> sont doubl√©s.",
        "prerequis": "-",
        "cout": "1 point de don"
      },
      {
        "nom": "Au milieu du combat",
        "description": "Permet de porter une armure l√©g√®re.",
        "prerequis": "üí™Force 3",
        "cout": "1 point de don"
      },
      {
        "nom": "Jugement √©clair",
        "description": "Si le Pr√™tre a effectu√© un sort ce tour ci, il peut effectuer une attaque au corp √† corp avec une action secondaire.",
        "prerequis": "üí™Force 3",
        "cout": "1 point de don"
      },
      {
        "nom": "Musique",
        "description": "Permet d'apprendre un instrument de musique (ou de savoir chanter) au choix, gagnant 2 de comp√©tences sur les tests de comp√©tence √©loquence le n√©c√©ssitant.",
        "prerequis": "-",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Enchanteur",
    "description": "Description de cette cat√©gorie de dons.",
    "dons": [
      {
        "nom": "R√©parateur de baguettes",
        "description": "Permet de regagner une charge de baguette, une fois par jour.",
        "prerequis": "-",
        "cout": "1 point de don"
      },
      {
        "nom": "Magie al√©atoire destructrice",
        "description": "Permet de choisir et d'apprendre un sort de mage et de pouvoir le lancer √† volont√©. Le sort ne peut pas √™tre chang√© par la suite.",
        "prerequis": "Non cumulable.",
        "cout": "1 point de don"
      },
      {
        "nom": "Magie al√©atoire de pr√™tre",
        "description": "Permet de choisir et d'apprendre un sort de pr√™tre et de pouvoir le lancer √† volont√©. Le sort ne peut pas √™tre chang√© par la suite.",
        "prerequis": "Non cumulable",
        "cout": "1 point de don"
      },
      {
        "nom": "Alteration risqu√©e",
        "description": "Lorsque un sort d'alteration magique est effectu√© alors que la cible est au corps √† corps, il ne peut plus √™tre resist√© par la Volont√© de la cible.",
        "prerequis": "-",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Generaux",
    "description": "Dons accessibles √† toutes les classes.",
    "dons": [
      {
        "nom": "Toujours pret",
        "description": "Le maximum d'efforts passe √† 6.",
        "prerequis": "Aucun pr√©requis",
        "cout": "1 point de don"
      },
      {
        "nom": "Dou√©",
        "description": "Gagne une comp√©tence rang 1.",
        "prerequis": "N'as pas ce don.",
        "cout": "1 points de don"
      },
      {
        "nom": "Brillant",
        "description": "Gagne une comp√©tence rang 2.",
        "prerequis": "La comp√©tence rang 1.",
        "cout": "2 points de don"
      },
      {
        "nom": "Prodigieux",
        "description": "Gagne une comp√©tence rang 3.",
        "prerequis": "La comp√©tence rang 2.",
        "cout": "3 point de don"
      },
      {
        "nom": "Hyperactif",
        "description": "Le h√©ros dispose maintenant de deux actions secondaires par tour.",
        "prerequis": "Niveau 3",
        "cout": "2 points de don"
      },
      {
        "nom": "Equitation",
        "description": "Permet de monter √† cheval ou √©quivalent.",
        "prerequis": "Niveau 5",
        "cout": "1 point de don"
      }
    ]
  }
];
    window.IMAGES = {
  "images": {
    "subclass:Guerrier:Nain des montagnes": "https://i.ibb.co/Zpv02X9p/e8c10c36dc90.jpg",
    "subclass:Guerrier:Berserker": "https://i.ibb.co/DPYjyGVd/b85000c2afa4.jpg",
    "subclass:Mage:√ârudit": "https://i.ibb.co/M5pcNmF9/05fa4e535010.jpg",
    "subclass:Mage:Elfe": "https://i.ibb.co/K1SMkgb/d738588e0528.jpg",
    "subclass:Pr√™tre:Inquisiteur": "https://i.ibb.co/dJ02RNMc/c9cd3553df7e.jpg",
    "subclass:Pr√™tre:Clerc Divin": "https://i.ibb.co/8gFGZYqJ/698304cc75ee.jpg",
    "subclass:R√¥deur:Voleur": "https://i.ibb.co/q3jSxDnQ/90e89c692b47.jpg",
    "subclass:R√¥deur:Chasseur": "https://i.ibb.co/70wP75z/53de7da9e55c.jpg",
    "subclass:Enchanteur:Esprit de la grande F√©e": "https://i.ibb.co/Cswfsyzz/9920a4e75242.jpg",
    "subclass:Enchanteur:Lutin": "https://i.ibb.co/Fbspq9hP/dd5e7b366e0f.jpg",
    "sort:Sorts de Mage:Boule de Feu": "https://i.ibb.co/vCWmgrQ5/Boule-De-Feu.png",
    "sort:Sorts de Mage:√âclair": "https://i.ibb.co/h194qhvd/Eclair.png",
    "sort:Sorts de Mage:Vague d√©ferlante": "https://i.ibb.co/BSHtL8K/Vague.png",
    "sort:Sorts de Pr√™tre:Ch√¢timent": "https://i.ibb.co/JRPyXx1L/Chatiment-Sacr.png",
    "sort:Sorts de Pr√™tre:Soin mineur": "https://i.ibb.co/YBC2HSnK/Soin-Mineur.png",
    "sort:Sorts d'Enchanteur:Accroche terrestre": "https://i.ibb.co/27W4NtSQ/Accroche-Terre.png",
    "sort:Sorts d'Enchanteur:Acc√©l√©ration": "https://i.ibb.co/Vc072qQB/Acceleration.png",
    "sort:Sorts d'Enchanteur:Sommeil": "https://i.ibb.co/rKyTh27C/Sleep.png",
    "sort:Sorts de Pr√™tre:Nouveau Sort": "https://i.ibb.co/QvK52kxH/Protection.png",
    "sort:Sorts de Pr√™tre:Protection": "https://i.ibb.co/QvK52kxH/Protection.png",
    "subclass:Guerrier:Nain des montagnes:1": "https://i.ibb.co/FL9m5HJn/Nain.png",
    "subclass:Guerrier:Nain des montagnes:2": "https://i.ibb.co/wNnJxSbj/NaineF.png",
    "subclass:Guerrier:Berserker:1": "https://i.ibb.co/YBWFbTKv/berseker.png",
    "subclass:Guerrier:Berserker:2": "https://i.ibb.co/20b74x2R/Berseker-F.png",
    "subclass:Mage:√ârudit:1": "https://i.ibb.co/N8qT2Hf/Mage.png",
    "subclass:Mage:√ârudit:2": "https://i.ibb.co/LdcPDSJQ/MageF.png",
    "subclass:Mage:Elfe:2": "https://i.ibb.co/7xvD2mdt/ElfeF.png",
    "subclass:Mage:Elfe:1": "https://i.ibb.co/gFVKrTcV/Elfe.png",
    "subclass:Pr√™tre:Inquisiteur:1": "https://i.ibb.co/tMcsCB8s/Inquisiteur.png",
    "subclass:Pr√™tre:Clerc Divin:1": "https://i.ibb.co/209W4ZHW/Pr-tre.png",
    "subclass:R√¥deur:Voleur:1": "https://i.ibb.co/NghMq11n/Voleur-min.png",
    "subclass:R√¥deur:Voleur:2": "https://i.ibb.co/h1BtkGMX/VoleurF.png",
    "subclass:R√¥deur:Chasseur:1": "https://i.ibb.co/yF8jrJYr/Chasseur-min.png",
    "subclass:R√¥deur:Chasseur:2": "https://i.ibb.co/3mQjLJbp/Chasseur-F.png",
    "subclass:Enchanteur:Esprit de la grande F√©e:1": "https://i.ibb.co/9k9ywvnP/F-eM.png",
    "subclass:Enchanteur:Esprit de la grande F√©e:2": "https://i.ibb.co/pjxDfXBC/F-e.png",
    "subclass:Enchanteur:Lutin:1": "https://i.ibb.co/6cxkMW1d/Lutin.png",
    "subclass:Enchanteur:Lutin:2": "https://i.ibb.co/qLbjJhxw/LutinF.png",
    "subclass:Pr√™tre:Inquisiteur:2": "https://i.ibb.co/LXwmWYR3/Inquisiteur-F.png",
    "subclass:Pr√™tre:Clerc Divin:2": "https://i.ibb.co/HfBVNLM3/PretreF.png"
  },
  "meta": {
    "total_images": 40,
    "exported_date": "2025-08-19",
    "note": "Ces images incluent les nouvelles images upload√©es"
  }
};
    
    // Build STATIC_PAGES correctly by combining individual page data
    window.STATIC_PAGES = {
      'creation': {
  "page": "creation",
  "title": "Cr√©ation d'un personnage",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "Guide pour cr√©er un personnage dans le JDR BAB."
    },
    {
      "type": "card",
      "title": "√âtapes de cr√©ation",
      "content": {
        "type": "ordered_list",
        "editType": "creation",
        "items": [
          "Choisir une <strong>classe</strong> puis une <strong>sous‚Äëclasse</strong>.",
          "Choisir un <strong>√©l√©ment</strong>.",
          "Choisir les <strong>dons</strong> (avec 2 points de dons).",
          "Choisir l'<strong>√©quipement</strong> de d√©part (avec 100 √©clats).",
          "Choisir un <strong>m√©tier</strong>.",
          "Remplir sa feuille de personnage (Efforts, Argent...).",
          "D√©finir le <strong>nom</strong>, l'<strong>histoire</strong> et l'<strong>apparence</strong>."
        ]
      }
    }
  ]
},
      'elements': {
  "page": "elements",
  "title": "Elements",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "Introduction au syst√®me d'√©l√©ments du JDR BAB."
    },
    {
      "type": "card",
      "title": "Syst√®me d'√©l√©ments",
      "content": [
        {
          "type": "paragraph",
          "editType": "elements",
          "editSection": "general",
          "content": "Il existe huit √©l√©ments, chacun ayant un oppos√©. Chaqu√© H√©ros o√π monstre poss√®de un √©l√©ment d'affiliation. Une cr√©ature affili√©e √† un √©l√©ment re√ßoit deux fois moins de d√©gats venant de cette √©l√©ment, et deux fois plus venant de l'√©l√©ment oppos√©.&nbsp;<br>"
        },
        {
          "type": "paragraph",
          "editType": "elements",
          "editSection": "example",
          "content": "Par exemple, une cr√©ature d'√©l√©ment <span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span>&nbsp;subissant une attaque de 10 d√©gats <span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span> ne recevra que 5 d√©gats au final. Si elle subit une attaque de 10 d√©gats de <span style=\"color: #e25822; font-weight: bold;\">Feu</span> , elle en subira 20 au final. Et si elle subit une attaque de 10 d√©gats d'<span style=\"color: #22c55e; font-weight: bold;\">Air</span>, elle en subira 10 au final."
        }
      ]
    },
    {
      "type": "card",
      "title": "Paires oppos√©es",
      "content": {
        "type": "element_pairs",
        "pairs": [
          {
            "element1": {
              "name": "Feu",
              "color": "#e25822"
            },
            "element2": {
              "name": "Eau",
              "color": "#2b6cb0"
            }
          },
          {
            "element1": {
              "name": "Terre",
              "color": "#8b5e34"
            },
            "element2": {
              "name": "Air",
              "color": "#22c55e"
            }
          },
          {
            "element1": {
              "name": "Lumi√®re",
              "color": "#fbbf24"
            },
            "element2": {
              "name": "Nuit",
              "color": "#0f172a"
            }
          },
          {
            "element1": {
              "name": "Divin",
              "color": "#ffd700"
            },
            "element2": {
              "name": "Mal√©fique",
              "color": "#a855f7"
            }
          }
        ]
      }
    },
    {
      "type": "grid",
      "cols": 2,
      "content": [
        {
          "type": "card",
          "title": "D√©fense",
          "content": [
            {
              "type": "paragraph",
              "editType": "elements",
              "editSection": "defense",
              "content": "Certaines armures/objets/bonus peuvent procurer une armure sp√©cifique √† un √©l√©ment.  Il faudra alors d√©duire au resultat final. le calcul de d√©gats se fait dans cette ordre : <br><div> D√©gats -> x 2 si critique -> x 0.5 ou x 2 si affilisation √©l√©ment -> reduction de l'armure</div>"
            }
          ],
          "deletable": true,
          "sectionName": "D√©fense"
        },
        {
          "type": "card",
          "title": "Attaque",
          "content": [
            {
              "type": "paragraph",
              "editType": "elements",
              "editSection": "attack",
              "content": "Une attaque ne peut avoir qu'un seul √©l√©ment. Si plusieurs objets/√©quipements/bonus donne un √©l√©ment √† l'attaque, le h√©ros qui choisi devra choisir quel est l'√©l√©ment utilis√©."
            }
          ],
          "deletable": true,
          "sectionName": "Attaque"
        }
      ]
    }
  ]
},
      'stats': {
  "page": "stats",
  "title": "Statistiques",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "Les six statistiques principales des personnages et leurs effets."
    },
    {
      "type": "card",
      "title": "Statistiques de base",
      "content": {
        "type": "grid",
        "cols": 2,
        "items": [
          {
            "type": "card",
            "title": "üí™ Force",
            "content": [
              {
                "type": "paragraph",
                "editType": "stat",
                "editSection": "force",
                "content": "Am√©liore les d√©g√¢ts physiques."
              }
            ],
            "deletable": true,
            "sectionName": "Force"
          },
          {
            "type": "card",
            "title": "üõ°Ô∏è Endurance",
            "content": [
              {
                "type": "paragraph",
                "editType": "stat",
                "editSection": "endurance",
                "content": "-Les points de vie maximum sont de :<br><strong>(10 + 2 x Endurance)</strong><br>- Un repos r√©g√©n√®re des points de vie √©gaux √† l'endurance<br>"
              }
            ],
            "deletable": true,
            "sectionName": "Endurance"
          },
          {
            "type": "card",
            "title": "üèÉ Agilit√©",
            "content": [
              {
                "type": "paragraph",
                "editType": "stat",
                "editSection": "agilite",
                "content": "Chaque 5 points ajoutent <strong>+1</strong> aux jets d'esquive et de critique physique."
              }
            ],
            "deletable": true,
            "sectionName": "Agilit√©"
          },
          {
            "type": "card",
            "title": "üß† Intelligence",
            "content": [
              {
                "type": "paragraph",
                "editType": "stat",
                "editSection": "intelligence",
                "content": "D√©termine la puissance des sorts."
              }
            ],
            "deletable": true,
            "sectionName": "Intelligence"
          },
          {
            "type": "card",
            "title": "‚ö° Volont√©",
            "content": [
              {
                "type": "paragraph",
                "editType": "stat",
                "editSection": "volonte",
                "content": "- Le mana maximum est de : <strong>(20 + 2 x Volont√©)</strong><br>- R√©duit les chances de subir des alt√©rations magiques."
              }
            ],
            "deletable": true,
            "sectionName": "Volont√©"
          },
          {
            "type": "card",
            "title": "üçÄ Chance",
            "content": [
              {
                "type": "paragraph",
                "editType": "stat",
                "editSection": "chance",
                "content": "- Am√©liore le butin des coffres et les √©v√©nements al√©atoires.<br>- Chaque 5 points ajoutent <strong>+1</strong> aux chances de coup critique avec les sorts et les baguettes."
              }
            ],
            "deletable": true,
            "sectionName": "Chance"
          }
        ]
      }
    }
  ]
},
      'competences-tests': {
  "page": "competences-tests",
  "title": "Comp√©tences & Tests",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "Syst√®me de comp√©tences et de tests du JDR BAB."
    },
    {
      "type": "grid",
      "cols": 2,
      "items": [
        {
          "type": "card",
          "title": "Efforts",
          "content": {
            "type": "list",
            "editType": "efforts",
            "items": [
              "<em>Chaque h√©ros dispose de 5 Efforts maximum.</em>",
              "<em>Repos</em>: +1 Effort ‚Ä¢ Sommeil&nbsp;: +3 Efforts.",
              "<em>Les Efforts peuvent √™tre d√©pens√©s pour am√©liorer un test de comp√©tence.</em>"
            ]
          }
        },
        {
          "type": "card",
          "title": "Comp√©tences",
          "content": {
            "type": "list",
            "editType": "competences",
            "items": [
              "<em>Hardiesse</em>: Pousser, casser, sauter‚Ä¶",
              "<em>Finesse</em>: Crocheter, fabriquer, √™tre discret‚Ä¶",
              "<em>Coordination</em>: Percevoir, √©quilibre, piloter‚Ä¶",
              "<em>R√©flexion</em>: Savoir, comprendre, deviner‚Ä¶",
              "<em>√âloquence</em>: Persuader, mentir, intimider‚Ä¶"
            ]
          }
        }
      ]
    },
    {
      "type": "card",
      "title": "Tests de comp√©tences",
      "content": [
        {
          "type": "paragraph",
          "editType": "tests",
          "editSection": "regles",
          "content": "Quand un Mj annonce un test de comp√©tence, un h√©ros peut choisir de d√©penser des efforts pour booster sa comp√©tence. La difficult√© d'un test est cach√©e et est entre 1 et 4 (facile, normale, difficile, expert)."
        },
        {
          "type": "paragraph",
          "editType": "tests",
          "editSection": "resolution",
          "content": "Une fois le test r√©solu, le Ma√Ætre de Jeu annonce le r√©sultat. Si le joueur a d√©pens√© plus d'Efforts que n√©cessaire, l'exc√©dent est perdu."
        }
      ]
    }
  ]
},
      'etats': {
  "page": "etats",
  "title": "Etats",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "Diff√©rents √©tats possibles d'une cr√©ature ou d'un h√©ros."
    },
    {
      "type": "card",
      "title": "A terre",
      "deletable": true,
      "sectionType": "section1755517689257",
      "content": [
        {
          "type": "paragraph",
          "editType": "custom",
          "editSection": "section1755517689257-content",
          "content": "Ne peut plus faire d'action.<br>Ne peut plus esquiver, et les attaques √† l'encontre de la cr√©ature sont √©quivalentes √† des attaques dans le dos.<br>Doit d√©penser une action secondaire pour se relever."
        }
      ]
    },
    {
      "type": "card",
      "title": "Endormi/assom√©/Effray√©",
      "deletable": true,
      "sectionType": "section1755543246768",
      "content": [
        {
          "type": "paragraph",
          "editType": "custom",
          "editSection": "section1755543246768-content",
          "content": "Ne peut plus faire d'action.<br>Ne peut plus esquiver, et les attaques √† l'encontre de la cr√©ature sont √©quivalentes √† des attaques dans le dos.<br>Une attaque sur la cr√©ature la sort de son √©tat."
        }
      ]
    }
  ]
}
    };
    
    // Static pages configuration
    window.STATIC_PAGES_CONFIG = {};
    
    // Mark as standalone version for renderer
    window.STANDALONE_VERSION = true;
    
    // Initialize app when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      // Ensure dev mode is off
      document.body.className = 'dev-off';
      
      // Initialize JdrApp if it exists
      if (window.JdrApp && window.JdrApp.init) {
        window.JdrApp.init();
      }
    });
  
// ============================================================================
// JDR-BAB APPLICATION - CORE MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // MAIN APPLICATION NAMESPACE
  // ========================================
  window.JdrApp = {
    // Core data
    data: {
      SORTS: null,
      CLASSES: null,
      DONS: null,
      STATIC_PAGES: {},
      editedData: {}
    },
    
    // Core modules
    modules: {
      router: {},
      renderer: {},
      editor: {},
      storage: {},
      images: {}
    },
    
    // Utilities
    utils: {
      dom: {},
      events: {},
      data: {}
    },

    // Initialization
    async init() {
      try {
        await this.loadData();
        await this.loadContent();
        this.initializeModules();
      } catch (error) {
        console.error('Failed to initialize JdrApp:', error);
      }
    },

    async loadData() {
      try {
        // Check if we're in standalone mode (data already injected)
        if (window.SORTS && window.CLASSES && window.DONS && window.STATIC_PAGES) {
          const sorts = window.SORTS;
          const classes = window.CLASSES;
          const dons = window.DONS;
          const staticPagesData = window.STATIC_PAGES;
          const staticPagesConfig = window.STATIC_PAGES_CONFIG || {};
          
          this.data.SORTS = sorts;
          this.data.CLASSES = classes;
          this.data.DONS = dons;
          this.data.STATIC_PAGES = staticPagesData;
          this.data.STATIC_PAGES_CONFIG = staticPagesConfig;
          
          window.SORTS = sorts;
          window.CLASSES = classes;
          window.DONS = dons;
          window.STATIC_PAGES = staticPagesData;
          window.STATIC_PAGES_CONFIG = staticPagesConfig;
          
          // Load stored edits AFTER setting up the data structure
          this.loadStoredEditsEarly();
          return;
        }
        
        // Development mode - fetch files
        const [sorts, classes, dons, staticPagesConfig] = await Promise.all([
          fetch('data/sorts.json').then(r => r.json()),
          fetch('data/classes.json').then(r => r.json()),
          fetch('data/dons.json').then(r => r.json()),
          fetch('data/static-pages-config.json').then(r => r.json())
        ]);

        const staticPagesData = {};
        const activePages = staticPagesConfig.pages.filter(page => page.active);
        
        for (const pageConfig of activePages) {
          try {
            const pageData = await fetch(`data/${pageConfig.file}`).then(r => r.json());
            staticPagesData[pageConfig.id] = pageData;
          } catch (error) {
            console.warn(`Failed to load static page ${pageConfig.id}:`, error);
          }
        }

        this.data.SORTS = sorts;
        this.data.CLASSES = classes;
        this.data.DONS = dons;
        this.data.STATIC_PAGES = staticPagesData;
        this.data.STATIC_PAGES_CONFIG = staticPagesConfig;

        window.SORTS = sorts;
        window.CLASSES = classes;
        window.DONS = dons;
        window.STATIC_PAGES = this.data.STATIC_PAGES;
        window.STATIC_PAGES_CONFIG = this.data.STATIC_PAGES_CONFIG;
        
        // Load stored edits in development mode (after data is loaded)
        this.loadStoredEditsEarly();
      } catch (error) {
        console.error('Failed to load data:', error);
        throw error;
      }
    },

    async loadContent() {
      try {
        const viewsDiv = document.getElementById('views');
        if (viewsDiv) {
          const loadingDiv = document.getElementById('app-loading');
          if (loadingDiv) {
            loadingDiv.innerHTML = '<!-- Content will be generated by renderer -->';
          }
        } else {
          const contentHTML = await this.getContentHTML();
          const loadingDiv = document.getElementById('app-loading');
          if (loadingDiv) {
            loadingDiv.outerHTML = contentHTML;
          }
        }
      } catch (error) {
        console.error('Failed to load content:', error);
        throw error;
      }
    },

    async getContentHTML() {
      // This would ideally load from a separate HTML file
      // For now, we'll return the content structure
      return `
        <div class="shell">
          <button aria-controls="sidebar" aria-expanded="false" aria-label="Ouvrir le sommaire" class="menu-toggle" id="menuToggle" style="display:none">‚ò∞ Sommaire</button>
          <div class="backdrop" hidden="" id="backdrop"></div>
          <main class="page">
            <aside class="sidebar" id="sidebar">
              <div class="panel">
                <div class="searchbar">
                  <input autocomplete="off" id="search" placeholder="Rechercher une r√®gle, une classe‚Ä¶">
                  <button class="btn" id="clear" title="Effacer">‚úñ</button>
                </div>
                <div class="tools">
                  <button class="btn small" id="devToggle" title="Activer/d√©sactiver le mode d√©veloppeur">üõ† Dev Mode: OFF</button>
                </div>
                <div class="dev-toolbox" id="devToolbox" style="display: none;">
                  <!-- Dev toolbox content will be injected here -->
                </div>
                <div class="toc" id="toc">
                  <!-- Table of contents will be injected here -->
                </div>
              </div>
            </aside>
            <div id="views">
              <!-- Dynamic content will be injected here -->
            </div>
          </main>
          <footer></footer>
        </div>
      `;
    },

    // Load stored edits early in the loading process (before rendering)
    loadStoredEditsEarly() {
      // Ne plus charger automatiquement le localStorage
      // Laisser les JSON files √™tre la source de v√©rit√©
    },

    initializeModules() {
      if (this.utils.events.init) this.utils.events.init();
      if (this.utils.dom.init) this.utils.dom.init();
      if (this.modules.images.init) this.modules.images.init();
      if (this.modules.renderer.init) this.modules.renderer.init();
      if (this.modules.router.init) this.modules.router.init();
      if (this.modules.editor.init) this.modules.editor.init();
      if (this.modules.storage.init) this.modules.storage.init();
      if (this.modules.ui.init) this.modules.ui.init();
    },

    // Force reload JSON data (clear localStorage cache)
    forceReloadData() {
      // Effacer seulement les √©ditions temporaires
      localStorage.removeItem('jdr-bab-edits');
      localStorage.removeItem('jdr-bab-last-modified');
      window.location.reload();
    }
  };

  // Auto-initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => window.JdrApp.init());
  } else {
    window.JdrApp.init();
  }

})();
// ============================================================================
// JDR-BAB APPLICATION - UTILITIES MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // CENTRALIZED EVENT MANAGEMENT
  // ========================================
  JdrApp.utils.events = {
    listeners: new Map(),
    
    // Centralized event registration
    register(type, selector, handler, options = {}) {
      const key = `${type}-${selector || 'window'}-${Date.now()}`;
      const wrapper = (e) => {
        if (!selector || e.target.matches(selector) || e.target.closest(selector)) {
          handler(e);
        }
      };
      
      if (selector) {
        document.addEventListener(type, wrapper, options);
      } else {
        window.addEventListener(type, wrapper, options);
      }
      
      this.listeners.set(key, { type, wrapper, options });
      return key;
    },
    
    // Delayed execution manager
    delayed: new Map(),
    timeout(key, fn, delay = 0) {
      if (this.delayed.has(key)) {
        clearTimeout(this.delayed.get(key));
      }
      const id = setTimeout(() => {
        fn();
        this.delayed.delete(key);
      }, delay);
      this.delayed.set(key, id);
    },
    
    // Common event handlers
    onDOMReady(fn) {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', fn);
      } else {
        fn();
      }
    },
    
    onHashChange(fn) {
      window.addEventListener('hashchange', fn);
    },
    
    onRouteChange(fn) {
      this.onHashChange(() => this.timeout('route-change', fn, 0));
      this.onDOMReady(() => this.timeout('dom-ready-route', fn, 0));
    }
  };

  // ========================================
  // DOM UTILITIES LIBRARY
  // ========================================
  JdrApp.utils.dom = {
    // Common selectors
    $(selector) { return document.querySelector(selector); },
    $(selector) { return document.querySelectorAll(selector); },
    
    // Element creation with common patterns
    create(tag, className = '', innerHTML = '', attributes = {}) {
      const el = document.createElement(tag);
      if (className) el.className = className;
      if (innerHTML) el.innerHTML = innerHTML;
      Object.entries(attributes).forEach(([key, value]) => {
        el.setAttribute(key, value);
      });
      return el;
    },
    
    
    // Safe innerHTML replacement
    safeSetHTML(element, html) {
      if (element) {
        element.innerHTML = html;
      }
    },
    
    // Safe text content setting
    safeSetText(element, text) {
      if (element) {
        element.textContent = text;
      }
    },
    
    // Toggle class utility
    toggleClass(element, className, force = null) {
      if (element) {
        if (force !== null) {
          element.classList.toggle(className, force);
        } else {
          element.classList.toggle(className);
        }
      }
    },
    
    // Show/hide utilities
    show(element, display = 'block') {
      if (element) {
        element.style.display = display;
      }
    },
    
    hide(element) {
      if (element) {
        element.style.display = 'none';
      }
    }
  };

  // ========================================
  // DATA UTILITIES
  // ========================================
  JdrApp.utils.data = {
    // Find spell by name across all categories
    findSpell(name) {
      if (!window.SORTS) return null;
      
      for (const category of window.SORTS) {
        const spell = category.sorts.find(s => s.nom === name);
        if (spell) return { spell, category: category.nom };
      }
      return null;
    },
    
    // Find class by name
    findClass(name) {
      if (!window.CLASSES) return null;
      return window.CLASSES.find(c => c.nom === name);
    },
    
    // Find don by name across all categories
    findDon(name) {
      if (!window.DONS) return null;
      
      for (const category of window.DONS) {
        const don = category.dons.find(d => d.nom === name);
        if (don) return { don, category: category.nom };
      }
      return null;
    },
    
    // Get spell category by name
    getSpellCategory(categoryName) {
      if (!window.SORTS) return null;
      return window.SORTS.find(cat => cat.nom === categoryName);
    },
    
    // Get don category by name
    getDonCategory(categoryName) {
      if (!window.DONS) return null;
      return window.DONS.find(cat => cat.nom === categoryName);
    },
    
    // Deep clone object
    deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    },
    
    // Sanitize string for use as identifier
    sanitizeId(str) {
      return str.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    },
    
    // Generate unique ID
    generateId(prefix = 'id') {
      return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    },
    
    // Escape HTML
    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  };

  // ========================================
  // IMAGE UTILITIES
  // ========================================
  
  // Compress image function
  JdrApp.utils.compressImage = function(file, maxWidth = 800, quality = 0.85) {
    return new Promise((resolve, reject) => {
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      img.onload = function() {
        // Calculate new dimensions
        let { width, height } = img;
        
        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }
        
        // Set canvas size
        canvas.width = width;
        canvas.height = height;
        
        // Detect if image has transparency (PNG)
        const isPNG = file.type === 'image/png' || file.name.toLowerCase().endsWith('.png');
        
        if (isPNG) {
          // For PNG, don't compress at all to preserve quality
          resolve(file);
        } else {
          // For JPEG/other formats, use white background
          ctx.fillStyle = '#FFFFFF';
          ctx.fillRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);
          
          canvas.toBlob((blob) => {
            resolve(blob);
          }, 'image/jpeg', quality);
        }
      };
      
      img.onerror = (error) => {
        reject(error);
      };
      
      img.src = URL.createObjectURL(file);
    });
  };

  // Upload to ImageBB function
  JdrApp.utils.uploadToImageBB = function(file) {
    return new Promise((resolve, reject) => {
      // ImageBB API key
      const API_KEY = '06a98f5c0c2dad952e6ab94b03040f36';
      
      const formData = new FormData();
      formData.append('image', file);
      
      fetch(`https://api.imgbb.com/1/upload?key=${API_KEY}`, {
        method: 'POST',
        body: formData
      })
      .then(response => {
        return response.json();
      })
      .then(data => {
        if (data.success) {
          resolve(data.data.url);
        } else {
          throw new Error('Upload failed: ' + (data.error ? data.error.message : 'Unknown error'));
        }
      })
      .catch(error => {
        // Fallback to local storage
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    });
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - IMAGES MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // IMAGES MANAGEMENT MODULE
  // ========================================
  JdrApp.modules.images = {
    // Store for preloaded images
    imageStore: {},
    
    async init() {
      await this.loadImageData();
      this.initImageHandlers();
    },

    // Load image data from JSON file or embedded data
    async loadImageData() {
      try {
        if (window.IMAGES) {
          this.imageStore = window.IMAGES.images || window.IMAGES || {};
          return;
        }
        
        const response = await fetch('./data/images.json');
        if (response.ok) {
          const data = await response.json();
          this.imageStore = data.images || {};
        } else {
          this.imageStore = {};
        }
      } catch (error) {
        this.imageStore = {};
      }
    },

    // Get image URL for a given key
    getImageUrl(illusKey) {
      return this.imageStore[illusKey] || null;
    },

    // Apply image to an illustration element
    applyImage(illusElement, imageUrl) {
      if (!illusElement || !imageUrl) return;

      const img = illusElement.querySelector('img.thumb');
      if (!img) return;

      // Set image source and make it visible
      img.src = this.processImageUrl(imageUrl);
      img.style.display = 'inline-block';
      img.style.opacity = '1'; // Reset opacity after upload
      
      // Show remove button if it exists
      const removeBtn = illusElement.querySelector('.rm');
      if (removeBtn) {
        removeBtn.style.display = 'inline-flex';
      }

    },

    // Process image URL to handle proxying for mobile compatibility
    processImageUrl(originalUrl) {
      // If it's an i.ibb.co URL, use proxy for better mobile compatibility
      if (originalUrl.includes('i.ibb.co') && !originalUrl.includes('images.weserv.nl')) {
        return `https://images.weserv.nl/?url=${encodeURIComponent(originalUrl)}`;
      }
      return originalUrl;
    },

    autoLoadImages() {
      const illusElements = document.querySelectorAll('[data-illus-key]');
      let loadedCount = 0;

      illusElements.forEach(illusElement => {
        const illusKey = illusElement.dataset.illusKey;
        const imageUrl = this.getImageUrl(illusKey);
        
        if (imageUrl) {
          this.applyImage(illusElement, imageUrl);
          loadedCount++;
        }
      });

      return loadedCount;
    },

    // Initialize image upload handlers
    initImageHandlers() {
      // Delegate image upload handling
      document.addEventListener('change', (event) => {
        if (event.target.matches('.illus input[type="file"]')) {
          this.handleImageUpload(event.target);
        }
      });

      // Delegate image removal handling  
      document.addEventListener('click', (event) => {
        if (event.target.matches('.illus .rm')) {
          this.handleImageRemoval(event.target);
        }
      });
    },

    // Handle image upload
    async handleImageUpload(fileInput) {
      const file = fileInput.files[0];
      if (!file) return;

      const illusElement = fileInput.closest('.illus');
      if (!illusElement) return;

      const illusKey = illusElement.dataset.illusKey;
      
      try {
        // Show loading state
        const img = illusElement.querySelector('img.thumb');
        if (img) {
          img.style.opacity = '0.5';
        }

        // Compress and upload image
        const compressedFile = await JdrApp.utils.compressImage(file, 800, 0.8);
        const imageUrl = await JdrApp.utils.uploadToImageBB(compressedFile);
        
        // Apply the uploaded image
        this.applyImage(illusElement, imageUrl);
        
        // Update local store
        this.imageStore[illusKey] = imageUrl;
        
        
      } catch (error) {
        // Reset loading state
        const img = illusElement.querySelector('img.thumb');
        if (img) {
          img.style.opacity = '1';
        }
        
        alert('Erreur lors du t√©l√©chargement de l\'image. Veuillez r√©essayer.');
      }
      
      // Clear file input
      fileInput.value = '';
    },

    // Handle image removal
    handleImageRemoval(removeBtn) {
      const illusElement = removeBtn.closest('.illus');
      if (!illusElement) return;

      const illusKey = illusElement.dataset.illusKey;
      const img = illusElement.querySelector('img.thumb');
      
      if (img) {
        img.src = '';
        img.style.display = 'none';
      }
      
      removeBtn.style.display = 'none';
      
      // Remove from store
      delete this.imageStore[illusKey];
      
    },

    // Manually add/update an image
    setImage(illusKey, imageUrl) {
      this.imageStore[illusKey] = imageUrl;
      
      // Apply to any existing elements with this key
      const illusElements = document.querySelectorAll(`[data-illus-key="${illusKey}"]`);
      illusElements.forEach(element => {
        this.applyImage(element, imageUrl);
      });
    },

    // Get all current images for export
    getAllImages() {
      return { ...this.imageStore };
    },

    // Import images from external data
    importImages(imageData) {
      if (typeof imageData === 'object' && imageData !== null) {
        Object.assign(this.imageStore, imageData);
        this.autoLoadImages();
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - STORAGE MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // STORAGE MODULE
  // ========================================
  JdrApp.modules.storage = {
    
    init() {
      
      // Load stored edits immediately on startup
      this.loadStoredEdits();
      
      // Set up save handlers
      JdrApp.utils.events.register('click', '#saveAndExport', () => this.saveAndExportZip());
      
      // Set up force reload handler
      JdrApp.utils.events.register('click', '#forceReload', () => JdrApp.forceReloadData());
      
      
      // Auto-save functionality
      this.setupAutoSave();
    },

    setupAutoSave() {
      // Auto-save disabled - we save immediately on each edit instead
      // Previously: Auto-save every 30 seconds if in dev mode
    },

    saveChanges(silent = false) {
      try {
        // Force collect all pending edits
        const editedData = JdrApp.modules.editor.forceCollectAllEdits();
        
        // Save only current edits (not full data to avoid overwriting JSON changes)
        localStorage.setItem('jdr-bab-edits', JSON.stringify(editedData));
        localStorage.setItem('jdr-bab-last-modified', Date.now().toString());
        
        if (!silent) {
          this.showNotification('üíæ Modifications sauvegard√©es localement', 'success');
        }
        
      } catch (error) {
        console.error('‚ùå Failed to save changes:', error);
        if (!silent) {
          this.showNotification('‚ùå Erreur lors de la sauvegarde', 'error');
        }
      }
    },

    async saveAndExportZip() {
      try {
        this.showNotification('üì¶ Cr√©ation de l\'archive ZIP...', 'info');
        
        // Force collect all pending edits
        JdrApp.modules.editor.forceCollectAllEdits();
        
        // Check if JSZip is available
        if (typeof JSZip === 'undefined') {
          await this.loadJSZip();
        }
        
        const zip = new JSZip();
        
        // Add main HTML file
        const mainHTML = await this.getMainHTML();
        zip.file('index.html', mainHTML);
        
        // Add CSS files
        const cssFiles = ['theme.css', 'utilities.css', 'components.css', 'layout.css', 'editor.css'];
        for (const cssFile of cssFiles) {
          const cssContent = await this.fetchFileContent(`css/${cssFile}`);
          if (cssContent) {
            zip.file(`css/${cssFile}`, cssContent);
          }
        }
        
        // Add JS files
        const jsFiles = ['core.js', 'utils.js', 'router.js', 'renderer.js', 'editor.js', 'storage.js', 'ui.js'];
        for (const jsFile of jsFiles) {
          const jsContent = await this.fetchFileContent(`js/${jsFile}`);
          if (jsContent) {
            zip.file(`js/${jsFile}`, jsContent);
          }
        }
        
        // Add modules
        const moduleFiles = ['images.js'];
        for (const moduleFile of moduleFiles) {
          const moduleContent = await this.fetchFileContent(`js/modules/${moduleFile}`);
          if (moduleContent) {
            zip.file(`js/modules/${moduleFile}`, moduleContent);
          }
        }
        
        // Add data files with current edits
        zip.file('data/sorts.json', JSON.stringify(window.SORTS, null, 2));
        zip.file('data/classes.json', JSON.stringify(window.CLASSES, null, 2));
        zip.file('data/dons.json', JSON.stringify(window.DONS, null, 2));
        
        // Add static pages config and data
        if (window.STATIC_PAGES_CONFIG) {
          zip.file('data/static-pages-config.json', JSON.stringify(window.STATIC_PAGES_CONFIG, null, 2));
        }
        
        if (window.STATIC_PAGES) {
          for (const [pageId, pageData] of Object.entries(window.STATIC_PAGES)) {
            zip.file(`data/${pageId}.json`, JSON.stringify(pageData, null, 2));
          }
        }
        
        // Note: All static pages are now handled via window.STATIC_PAGES above
        
        // Add current images (including newly uploaded ones)
        if (JdrApp.modules.images && JdrApp.modules.images.getAllImages) {
          const currentImages = JdrApp.modules.images.getAllImages();
          const imagesData = {
            images: currentImages,
            meta: {
              total_images: Object.keys(currentImages).length,
              exported_date: new Date().toISOString().slice(0, 10),
              note: "Ces images incluent les nouvelles images upload√©es"
            }
          };
          zip.file('data/images.json', JSON.stringify(imagesData, null, 2));
        }
        
        // Add package.json and other config files
        const configFiles = ['package.json'];
        for (const configFile of configFiles) {
          const configContent = await this.fetchFileContent(configFile);
          if (configContent) {
            zip.file(configFile, configContent);
          }
        }
        
        // Generate and download ZIP
        const zipBlob = await zip.generateAsync({type: 'blob'});
        const timestamp = new Date().toISOString().slice(0, 16).replace(/[:-]/g, '');
        this.downloadFile(`JdrBab-${timestamp}.zip`, zipBlob, 'application/zip');
        
        this.showNotification('üì¶ Archive ZIP cr√©√©e et t√©l√©charg√©e!', 'success');
        
      } catch (error) {
        console.error('‚ùå Failed to create ZIP:', error);
        this.showNotification('‚ùå Erreur lors de la cr√©ation du ZIP', 'error');
      }
    },

    async loadJSZip() {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    },

    async fetchFileContent(filePath) {
      try {
        const response = await fetch(filePath);
        if (response.ok) {
          return await response.text();
        }
        // Could not fetch file
        return null;
      } catch (error) {
        // Error fetching file
        return null;
      }
    },

    async getMainHTML() {
      // Get the current index.html content or reconstruct it
      try {
        const response = await fetch('index.html');
        if (response.ok) {
          return await response.text();
        }
      } catch (error) {
        // Could not fetch index.html, generating from current state
      }
      
      // Fallback: generate HTML from current document state
      return `<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta name="referrer" content="no-referrer-when-downgrade">
<title>JDR‚ÄëBAB ‚Äî Livret de r√®gles</title>
<meta content="Livret web multipages des r√®gles JDR‚ÄëBAB, th√®me parchemin, illustrations par cat√©gorie/classe/sous‚Äëclasse, export HTML autonome." name="description">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&amp;family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600&amp;display=swap" rel="stylesheet">

<!-- CSS Modulaire -->
<link rel="stylesheet" href="css/theme.css">
<link rel="stylesheet" href="css/utilities.css">
<link rel="stylesheet" href="css/components.css">
<link rel="stylesheet" href="css/layout.css">
<link rel="stylesheet" href="css/editor.css">
</head>
<body class="dev-off" style="">

<!-- Le contenu HTML complet sera inject√© ici par le JavaScript -->
<div id="app-loading">Chargement...</div>

<!-- JavaScript Modulaire -->
<script src="js/core.js"></script>
<script src="js/utils.js"></script>
<script src="js/modules/images.js"></script>
<script src="js/router.js"></script>
<script src="js/renderer.js"></script>
<script src="js/editor.js"></script>
<script src="js/storage.js"></script>
<script src="js/ui.js"></script>

</body>
</html>`;
    },


    downloadJSON(filename, data) {
      const json = JSON.stringify(data, null, 2);
      this.downloadFile(filename, json, 'application/json');
    },

    downloadFile(filename, content, mimeType = 'text/html') {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.style.display = 'none';
      
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      URL.revokeObjectURL(url);
    },

    showNotification(message, type = 'info') {
      // Simple notification system
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${type === 'success' ? '#10B981' : type === 'error' ? '#EF4444' : '#3B82F6'};
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        font-weight: 500;
        z-index: 10000;
        animation: slideIn 0.3s ease;
      `;
      
      // Add animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      notification.textContent = message;
      document.body.appendChild(notification);
      
      // Auto-remove after 3 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    },

    // Load edits from localStorage on startup
    loadStoredEdits() {
      try {
        const storedEdits = localStorage.getItem('jdr-bab-edits');
        
        if (storedEdits) {
          JdrApp.modules.editor.editedData = JSON.parse(storedEdits);
        }
        
        // Ne plus charger jdr-bab-data - laisser les JSON √™tre la source de v√©rit√©
        
      } catch (error) {
        // Failed to load stored edits
      }
    },

    // Handle ZIP file import
    async handleZipImport(event) {
      const file = event.target.files[0];
      if (!file || file.type !== 'application/zip') {
        this.showNotification('‚ùå Veuillez s√©lectionner un fichier ZIP', 'error');
        return;
      }

      try {
        this.showNotification('üì• Import en cours...', 'info');

        // Check if JSZip is available
        if (typeof JSZip === 'undefined') {
          await this.loadJSZip();
        }

        const zip = new JSZip();
        const contents = await zip.loadAsync(file);

        // Import data files
        const dataFiles = ['sorts.json', 'classes.json', 'dons.json'];
        for (const dataFile of dataFiles) {
          const zipFile = contents.file(`data/${dataFile}`);
          if (zipFile) {
            const content = await zipFile.async('text');
            const data = JSON.parse(content);
            
            if (dataFile === 'sorts.json') {
              window.SORTS = data;
            } else if (dataFile === 'classes.json') {
              window.CLASSES = data;
            } else if (dataFile === 'dons.json') {
              window.DONS = data;
            }
          }
        }

        // Import static pages config
        const configFile = contents.file('data/static-pages-config.json');
        if (configFile) {
          const configContent = await configFile.async('text');
          window.STATIC_PAGES_CONFIG = JSON.parse(configContent);
        }

        // Import static pages data
        if (window.STATIC_PAGES_CONFIG && window.STATIC_PAGES_CONFIG.pages) {
          window.STATIC_PAGES = {};
          for (const pageConfig of window.STATIC_PAGES_CONFIG.pages) {
            if (pageConfig.active) {
              const pageFile = contents.file(`data/${pageConfig.file}`);
              if (pageFile) {
                const pageContent = await pageFile.async('text');
                window.STATIC_PAGES[pageConfig.id] = JSON.parse(pageContent);
              }
            }
          }
        }

        // Import images
        const imagesFile = contents.file('data/images.json');
        if (imagesFile && JdrApp.modules.images && JdrApp.modules.images.importImages) {
          const imagesContent = await imagesFile.async('text');
          const imagesData = JSON.parse(imagesContent);
          if (imagesData.images) {
            JdrApp.modules.images.importImages(imagesData.images);
          }
        }

        // Save imported data to localStorage
        this.saveChanges(true);

        this.showNotification('‚úÖ Import r√©ussi! Rechargement...', 'success');

        // Reload page to show imported data
        setTimeout(() => {
          window.location.reload();
        }, 1000);

      } catch (error) {
        this.showNotification('‚ùå Erreur lors de l\'import', 'error');
      }

      // Reset file input
      event.target.value = '';
    },


  };

})();
// ============================================================================
// JDR-BAB APPLICATION - ROUTER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // ROUTING SYSTEM
  // ========================================
  JdrApp.modules.router = {
    currentRoute: '',
    
    init() {
      
      // Set up route change listeners
      JdrApp.utils.events.onHashChange(() => this.parseRoute());
      JdrApp.utils.events.onDOMReady(() => this.parseRoute());
      
      // Set up TOC click handlers
      JdrApp.utils.events.register('click', '.toc a', (e) => {
        e.preventDefault();
        const route = e.target.getAttribute('data-route');
        if (route) {
          this.navigate(route);
        }
      });

      // Set up category collapse/expand
      JdrApp.utils.events.register('click', '.toc-category > a', (e) => {
        e.preventDefault();
        const category = e.target.closest('.toc-category');
        if (category) {
          category.classList.toggle('collapsed');
        }
      });
    },
    
    parseRoute() {
      const hash = location.hash.replace('#/', '');
      const page = hash || 'creation';
      const exists = JdrApp.utils.dom.$(`article[data-page="${page}"]`);
      
      this.currentRoute = page;
      
      // Handle category routing
      if (page.startsWith('sorts-') && exists) {
        JdrApp.modules.renderer.renderSortCategory(page);
      }
      
      this.show(exists ? page : 'creation');
    },
    
    show(page) {
      document.querySelectorAll('article').forEach(a => a.classList.remove('active'));
      const target = document.querySelector(`article[data-page="${page}"]`);
      if (target) target.classList.add('active');
      
      document.querySelectorAll('.toc a').forEach(a => a.classList.remove('active'));
      const activeLink = document.querySelector(`a[href="#/${page}"]`);
      if (activeLink) activeLink.classList.add('active');
    },
    
    navigate(route) {
      location.hash = `#/${route}`;
    },
    
    getCurrentRoute() {
      return this.currentRoute;
    },
    
    // Generate table of contents based on data
    generateTOC() {
      const tocContainer = document.querySelector('#toc');
      if (!tocContainer) return;

      const tocHTML = `
        <h4>Sommaire</h4>
        <a class="" data-route="creation" href="#/creation">üßô‚Äç‚ôÇÔ∏è Cr√©ation d'un personnage</a>
        
        <div class="toc-category">
          <a data-route="classes" href="#/classes" class="">‚öîÔ∏è Classes</a>
          <div class="toc-sub">
            ${window.CLASSES ? window.CLASSES.map(classe => 
              `<a data-route="${JdrApp.utils.data.sanitizeId(classe.nom)}" href="#/${JdrApp.utils.data.sanitizeId(classe.nom)}" class="">${this.getClassIcon(classe.nom)} ${classe.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <div class="toc-category">
          <a data-route="sorts" href="#/sorts">üîÆ Sorts</a>
          <div class="toc-sub">
            ${window.SORTS ? window.SORTS.map(category => 
              `<a data-route="sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getSortCategoryIcon(category.nom)} ${category.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <div class="toc-category">
          <a data-route="dons" href="#/dons" class="">üéñÔ∏è Dons</a>
          <div class="toc-sub">
            ${window.DONS ? window.DONS.map(category => 
              `<a data-route="dons-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/dons-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getDonCategoryIcon(category.nom)} ${category.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <a data-route="elements" href="#/elements" class="">üåü √âl√©ments</a>
        <a data-route="stats" href="#/stats" class="">üìä Statistiques</a>
        <a data-route="competences-tests" href="#/competences-tests" class="">üéØ Comp√©tences & Tests</a>
        <a data-route="etats" href="#/etats" class="">‚ö° Etats</a>
      `;
      
      tocContainer.innerHTML = tocHTML;
    },
    
    getClassIcon(className) {
      const icons = {
        'Guerrier': 'üó°Ô∏è',
        'Mage': 'üîÆ',
        'Pr√™tre': '‚õ™',
        'R√¥deur': 'üèÉ',
        'Enchanteur': '‚ú®'
      };
      return icons[className] || '‚öîÔ∏è';
    },
    
    getSortCategoryIcon(categoryName) {
      const icons = {
        'Sorts de Mage': 'üîÆ',
        'Sorts de Pr√™tre': '‚õ™',
        'Sorts d\'Enchanteur': '‚ú®',
        'Sorts de Monstres': 'üíÄ'
      };
      return icons[categoryName] || 'üîÆ';
    },
    
    getDonCategoryIcon(categoryName) {
      const icons = {
        'Guerrier': 'üó°Ô∏è',
        'Mage': 'üîÆ',
        'Pr√™tre': '‚õ™',
        'R√¥deur': 'üèÉ',
        'Enchanteur': '‚ú®',
        'G√©n√©raux': 'üéñÔ∏è'
      };
      return icons[categoryName] || 'üéñÔ∏è';
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - RENDERER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // CONTENT RENDERER MODULE
  // ========================================
  JdrApp.modules.renderer = {
    // Current search and filter state
    currentSearch: '',
    
    // Helper to check if we should render editing buttons
    shouldRenderEditButtons() {
      return !window.STANDALONE_VERSION;
    },
    
    init() {
      this.generateContent();
      this.autoLoadImages();
    },

    generateContent() {
      JdrApp.modules.router.generateTOC();
      this.generateArticles();
      this.generateDevToolbox();
      
      // Show/hide edit buttons based on dev mode state
      if (JdrApp.modules.editor) {
        setTimeout(() => {
          if (JdrApp.modules.editor.isDevMode) {
            JdrApp.modules.editor.forceShowAllEditButtons();
          } else {
            JdrApp.modules.editor.forceHideAllEditButtons();
          }
        }, 100);
      }
    },

    generateArticles() {
      const viewsContainer = document.querySelector('#views');
      if (!viewsContainer) return;

      let articlesHTML = '';
      articlesHTML += this.generateCreationPage();
      
      articlesHTML += this.generateElementsPage();
      articlesHTML += this.generateStatsPage();
      articlesHTML += this.generateCompetencesPage();
      articlesHTML += this.generateEtatsPage();

      if (window.CLASSES) {
        window.CLASSES.forEach(classe => {
          articlesHTML += this.generateClassPage(classe);
        });
      }

      if (window.SORTS) {
        window.SORTS.forEach(category => {
          articlesHTML += this.generateSortCategoryPage(category);
        });
      }

      if (window.DONS) {
        window.DONS.forEach(category => {
          articlesHTML += this.generateDonCategoryPage(category);
        });
      }

      viewsContainer.innerHTML = articlesHTML;
      setTimeout(() => this.autoLoadImages(), 100);
    },

    generateCreationPage() {
      return this.generateStaticPage('creation');
    },

    generateClassPage(classe) {
      const pageId = JdrApp.utils.data.sanitizeId(classe.nom);
      
      return `
        <article class="" data-page="${pageId}" data-page-title="${classe.nom}">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2 class="editable editable-title" data-edit-type="class-name" data-edit-section="${classe.nom}">${classe.nom}</h2>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-title-btn" title="√âditer le nom de la classe">‚úèÔ∏è</button>' : ''}
              ${this.createIllustration(`class:${classe.nom}`)}
            </div>
            
            <div class="editable-section" data-section-type="class-resume">
              <p class="lead editable editable-paragraph" data-edit-type="class-resume" data-edit-section="${classe.nom}">${classe.resume}</p>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-paragraph-btn" title="√âditer la description de la classe">‚úèÔ∏è</button>' : ''}
            </div>
            
            <h3>Capacit√©s de classe</h3>
            <div class="editable-section editable-list-container" data-section-type="class-capacites">
              <ul class="editable editable-list" data-edit-type="class-capacites" data-edit-section="${classe.nom}">
                ${classe.capacites.map(cap => `<li>${cap}</li>`).join('')}
              </ul>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-list-btn" title="√âditer les capacit√©s de classe">‚úèÔ∏è</button>' : ''}
            </div>
            
            <h3>Sous-classes</h3>
            <div class="subclass-stack">
              ${classe.sousClasses.map(sousClasse => this.generateSubClassCard(classe.nom, sousClasse)).join('')}
            </div>
            ${this.shouldRenderEditButtons() ? '<div class="add-subclass-btn">‚ûï Ajouter une sous-classe</div>' : ''}
          </section>
        </article>
      `;
    },

    generateSubClassCard(className, sousClasse) {
      return `
        <div class="card editable-section" data-section-type="subclass" data-class-name="${className}" data-subclass-name="${sousClasse.nom}">
          <div class="editable-section" data-section-type="subclass-name">
            <h4 class="editable editable-title subclass-title" data-edit-type="subclass-name" data-edit-section="${className}-${sousClasse.nom}">${sousClasse.nom}</h4>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-title-btn" title="√âditer le nom de la sous-classe">‚úèÔ∏è</button>' : ''}
          </div>
          
          ${this.createSubclassIllustrations(className, sousClasse.nom)}
          
          <div class="editable-section" data-section-type="subclass-stats">
            <div class="editable editable-stats" data-edit-type="subclass-stats" data-edit-section="${className}-${sousClasse.nom}">
              <div class="chips">
                ${Object.entries(sousClasse.base).map(([stat, value]) => {
                  const statIcons = {
                    'Force': 'üí™',
                    'Agilit√©': 'üèÉ',
                    'Endurance': 'üõ°Ô∏è',
                    'Intelligence': 'üß†',
                    'Volont√©': '‚ö°',
                    'Chance': 'üçÄ'
                  };
                  const icon = statIcons[stat] || '‚ö°';
                  return `<span class="chip">${icon} ${stat}: <strong>${value}</strong></span>`;
                }).join('')}
              </div>
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-stats-btn" title="√âditer les statistiques de base">‚úèÔ∏è</button>' : ''}
          </div>
          
          <div class="editable-section" data-section-type="subclass-progression">
            <div class="editable editable-field" data-edit-type="subclass-progression" data-edit-section="${className}-${sousClasse.nom}">
              ${sousClasse.progression}
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-field-btn" title="√âditer la progression par niveau">‚úèÔ∏è</button>' : ''}
          </div>
          
          <h5>Capacit√©s</h5>
          <div class="editable-section editable-list-container" data-section-type="subclass-capacites">
            <ul class="editable editable-list" data-edit-type="subclass-capacites" data-edit-section="${className}-${sousClasse.nom}">
              ${sousClasse.capacites.map(cap => `<li>${cap}</li>`).join('')}
            </ul>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-list-btn" title="√âditer les capacit√©s">‚úèÔ∏è</button>' : ''}
          </div>
          
          ${this.shouldRenderEditButtons() ? '<button class="delete-subclass-btn" title="Supprimer cette sous-classe" data-class-name="' + className + '" data-subclass-name="' + sousClasse.nom + '">üóëÔ∏è Supprimer</button>' : ''}
        </div>
      `;
    },

    generateSortCategoryPage(category) {
      const pageId = `sorts-${JdrApp.utils.data.sanitizeId(category.nom)}`;
      
      return `
        <article class="" data-page="${pageId}">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2 class="editable editable-title" data-edit-type="spell-category-name" data-edit-section="${category.nom}">${category.nom}</h2>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-title-btn" title="√âditer le nom de la cat√©gorie">‚úèÔ∏è</button>' : ''}
              ${this.createIllustration(`spellcategory:${category.nom}`)}
            </div>
            
            <div class="editable-section" data-section-type="spell-category-description">
              <p class="lead editable editable-paragraph" data-edit-type="spell-category-description" data-edit-section="${category.nom}">${category.description}</p>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-paragraph-btn" title="√âditer la description de la cat√©gorie">‚úèÔ∏è</button>' : ''}
            </div>
            
            ${this.shouldRenderEditButtons() ? `<button class="spell-add" data-category-name="${category.nom}" type="button">‚ûï Ajouter un sort</button>` : ''}
            
            <div class="grid cols-2">
              ${category.sorts.map((sort, index) => this.generateSpellCard(category, sort, index)).join('')}
            </div>
          </section>
        </article>
      `;
    },

    generateSpellCard(category, sort, index) {
      return `
        <div class="card editable-section" data-section-type="spell" data-spell-name="${sort.nom}" data-category-name="${category.nom}">
          <div class="editable-section" data-section-type="spell-name">
            <h4 style="margin: 0 0 1rem 0; text-align: center;" class="editable editable-title" data-edit-type="spell-name" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}">${sort.nom}</h4>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-title-btn" title="√âditer le nom du sort">‚úèÔ∏è</button>' : ''}
          </div>
          
          ${this.createIllustration(`sort:${category.nom}:${sort.nom}`, sort.nom)}
          
          <div class="editable-section" data-section-type="spell-description">
            <p class="muted editable editable-paragraph" data-edit-type="spell-description" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}" style="margin: 0 0 1rem 0; text-align: center;">${sort.description}</p>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-paragraph-btn" title="√âditer la description">‚úèÔ∏è</button>' : ''}
          </div>
          
          <div class="editable-section" data-section-type="spell-prerequis">
            <div class="editable editable-field" data-edit-type="spell-prerequis" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}">
              ${sort.prerequis}
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-field-btn" title="√âditer les pr√©requis">‚úèÔ∏è</button>' : ''}
          </div>
          
          <div class="editable-section" data-section-type="spell-portee">
            <div class="editable editable-field" data-edit-type="spell-portee" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}">
              ${sort.portee}
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-field-btn" title="√âditer la port√©e">‚úèÔ∏è</button>' : ''}
          </div>
          
          <div class="editable-section" data-section-type="spell-mana">
            <div class="editable editable-field" data-edit-type="spell-mana" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}">
              ${sort.coutMana}
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-field-btn" title="√âditer le co√ªt mana">‚úèÔ∏è</button>' : ''}
          </div>

          <div class="editable-section" data-section-type="spell-temps-incantation">
            <div class="editable editable-field" data-edit-type="spell-temps-incantation" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}">
              ${sort.tempsIncantation}
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-field-btn" title="√âditer le temps d\'incantation">‚úèÔ∏è</button>' : ''}
          </div>
          
          <hr style="margin: 0.5rem 0; border: none; border-top: 1px solid var(--rule);">
          
          <div class="editable-section" data-section-type="spell-resistance">
            <div class="editable editable-field" data-edit-type="spell-resistance" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}">
              ${sort.resistance}
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-field-btn" title="√âditer la r√©sistance">‚úèÔ∏è</button>' : ''}
          </div>
          
          <div class="editable-section" data-section-type="spell-effect-normal">
            <div class="editable editable-effect" data-edit-type="spell-effect-normal" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}" style="margin: 1rem 0;">
              ${sort.effetNormal}
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-effect-btn" title="√âditer l\'effet normal">‚úèÔ∏è</button>' : ''}
          </div>
          
          <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
          
          ${sort.effetCritique ? `
            <div class="editable-section" data-section-type="spell-effect-critical">
              <div class="editable editable-effect" data-edit-type="spell-effect-critical" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}" style="margin: 1rem 0;">
                ${sort.effetCritique}
              </div>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-effect-btn" title="√âditer l\'effet critique">‚úèÔ∏è</button>' : ''}
            </div>
          ` : ''}
          
          ${sort.effetEchec ? `
            <div class="editable-section" data-section-type="spell-effect-failure">
              <div class="editable editable-effect" data-edit-type="spell-effect-failure" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}" style="margin: 1rem 0;">
                ${sort.effetEchec}
              </div>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-effect-btn" title="√âditer l\'effet d\'√©chec">‚úèÔ∏è</button>' : ''}
            </div>
          ` : ''}
          
          ${this.shouldRenderEditButtons() ? `<button class="spell-delete btn small" data-category-name="${category.nom}" data-spell-name="${sort.nom}" type="button" style="background: #ff6b6b; color: white; margin-top: 8px;">üóë Supprimer</button>` : ''}
        </div>
      `;
    },

    generateDonCategoryPage(category) {
      const pageId = `dons-${JdrApp.utils.data.sanitizeId(category.nom)}`;
      
      return `
        <article class="" data-page="${pageId}">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2 class="editable editable-title" data-edit-type="don-category-name" data-edit-section="${category.nom}">${category.nom}</h2>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-title-btn" title="√âditer le nom de la cat√©gorie">‚úèÔ∏è</button>' : ''}
              ${this.createIllustration(`doncategory:${category.nom}`)}
            </div>
            
            <div class="editable-section" data-section-type="don-category-description">
              <p class="lead editable editable-paragraph" data-edit-type="don-category-description" data-edit-section="${category.nom}">${category.description}</p>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-paragraph-btn" title="√âditer la description de la cat√©gorie">‚úèÔ∏è</button>' : ''}
            </div>
            
            ${this.shouldRenderEditButtons() ? `<button class="don-add" data-category-name="${category.nom}" type="button">‚ûï Ajouter un don</button>` : ''}
            
            <div class="grid cols-2">
              ${category.dons.map((don, index) => this.generateDonCard(category, don, index)).join('')}
            </div>
          </section>
        </article>
      `;
    },

    generateDonCard(category, don, index) {
      return `
        <div class="card editable-section" data-section-type="don" data-don-name="${don.nom}" data-category-name="${category.nom}">
          <div class="editable-section" data-section-type="don-name">
            <h4 style="margin: 0 0 1rem 0; text-align: center;" class="editable editable-title" data-edit-type="don-name" data-edit-section="${don.nom}">${don.nom}</h4>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-title-btn" title="√âditer le nom du don">‚úèÔ∏è</button>' : ''}
          </div>
          
          ${this.createIllustration(`don:${don.nom}`, don.nom)}
          
          <div class="editable-section" data-section-type="don-description">
            <p class="editable editable-paragraph" data-edit-type="don-description" data-edit-section="${don.nom}">${don.description}</p>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-paragraph-btn" title="√âditer la description">‚úèÔ∏è</button>' : ''}
          </div>
          
          <div class="editable-section" data-section-type="don-prerequis">
            <div class="editable editable-field" data-edit-type="don-prerequis" data-edit-section="${don.nom}">
              ${don.prerequis}
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-field-btn" title="√âditer les pr√©requis">‚úèÔ∏è</button>' : ''}
          </div>
          
          <div class="editable-section" data-section-type="don-cout">
            <div class="editable editable-field" data-edit-type="don-cout" data-edit-section="${don.nom}" style="color: var(--bronze); font-weight: 600;">
              ${don.cout}
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-field-btn" title="√âditer le co√ªt">‚úèÔ∏è</button>' : ''}
          </div>
          
          ${this.shouldRenderEditButtons() ? `
          <div style="display: flex; gap: 4px; margin-top: 8px; flex-wrap: wrap;">
            <button class="don-delete btn small" data-category-name="${category.nom}" data-don-name="${don.nom}" style="background: #ff6b6b; color: white;">üóë Supprimer</button>
            <button class="don-move-up btn small" data-category-name="${category.nom}" data-don-name="${don.nom}" data-don-index="${index}" style="background: var(--bronze); color: white;" ${index === 0 ? 'disabled' : ''}>‚¨ÜÔ∏è Haut</button>
            <button class="don-move-down btn small" data-category-name="${category.nom}" data-don-name="${don.nom}" data-don-index="${index}" style="background: var(--bronze); color: white;" ${index === category.dons.length - 1 ? 'disabled' : ''}>‚¨áÔ∏è Bas</button>
          </div>
          ` : ''}
        </div>
      `;
    },

    // Generic method to generate static pages from JSON data
    generateStaticPage(pageId) {
      if (!window.STATIC_PAGES || !window.STATIC_PAGES[pageId]) {
        return '';
      }

      const pageData = window.STATIC_PAGES[pageId];
      const isActive = pageId === 'creation' ? 'active' : '';
      
      return `
        <article class="${isActive}" data-page="${pageData.page}" data-static-page="true" data-page-title="${pageData.title}">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2 class="editable editable-title" data-edit-type="page-title" data-edit-section="${pageData.page}">${pageData.title}</h2>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-title-btn" title="√âditer le titre de la page">‚úèÔ∏è</button>' : ''}
              ${this.createIllustration(`page:${pageData.page}`)}
            </div>
            ${this.renderSections(pageData.sections)}
            ${this.shouldRenderEditButtons() ? '<div class="add-paragraph-btn" data-target="section">‚ûï Ajouter une nouvelle section</div>' : ''}
          </section>
        </article>
      `;
    },

    // Helper method to render sections from JSON data
    renderSections(sections) {
      return sections.map((section, sectionIndex) => {
        switch (section.type) {
          case 'intro':
            return `
              <div class="editable-section" data-section-type="intro" data-section-index="${sectionIndex}">
                <p class="editable editable-intro" data-edit-type="intro" data-edit-section="intro">${section.content}</p>
                ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-section-btn" title="√âditer cette introduction">‚úèÔ∏è</button>' : ''}
              </div>
              ${this.shouldRenderEditButtons() ? '<div class="add-paragraph-btn" data-target="intro">‚ûï Ajouter un paragraphe ici</div>' : ''}
            `;
          
          case 'card':
            return this.renderCard(section, sectionIndex);
          
          case 'grid':
            return this.renderGrid(section, sectionIndex);
          
          default:
            return `<div><!-- Unknown section type: ${section.type} --></div>`;
        }
      }).join('');
    },

    // Helper method to render a card section
    renderCard(cardData, sectionIndex) {
      let cardHTML = `<div class="card editable-section" data-section-type="card" data-section-index="${sectionIndex}">`;
      
      if (cardData.deletable && cardData.sectionType) {
        cardHTML += `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="card-title" data-edit-section="${cardData.sectionType}-title">${cardData.title}</h3>
            ${this.shouldRenderEditButtons() ? `<button class="edit-btn edit-title-btn" title="√âditer le titre">‚úèÔ∏è</button>` : ''}
            ${this.shouldRenderEditButtons() ? `<button class="remove-section-btn" data-section-type="${cardData.sectionType}" type="button" style="background: #dc2626; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 12px;">üóë Supprimer section</button>` : ''}
          </div>
        `;
      } else {
        cardHTML += `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="card-title" data-edit-section="card-${sectionIndex}">${cardData.title}</h3>
            ${this.shouldRenderEditButtons() ? `<button class="edit-btn edit-title-btn" title="√âditer le titre">‚úèÔ∏è</button>` : ''}
          </div>
        `;
      }

      // Handle different content types
      if (Array.isArray(cardData.content)) {
        cardHTML += cardData.content.map(item => this.renderContentItem(item)).join('');
      } else if (typeof cardData.content === 'object') {
        cardHTML += this.renderComplexContent(cardData.content);
      } else {
        cardHTML += `<div>${cardData.content}</div>`;
      }

      if (cardData.deletable && cardData.sectionName && this.shouldRenderEditButtons()) {
        cardHTML += `
          <div style="margin-top: 1rem; text-align: center;">
            <button class="section-delete btn small" data-section-name="${cardData.sectionName}" type="button" style="background: #ff6b6b; color: white;">üóë Supprimer section</button>
          </div>
        `;
      }
      
      cardHTML += `</div>`; // Close the card div!
      return cardHTML;
    },

    // Helper method to render content items
    renderContentItem(item) {
      if (item.type === 'paragraph') {
        const content = `
          <div class="editable-section" data-section-type="paragraph">
            <p class="editable editable-paragraph" data-edit-type="paragraph" data-edit-section="${item.editSection}">${item.content}</p>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-paragraph-btn" title="√âditer ce paragraphe">‚úèÔ∏è</button>' : ''}
          </div>
        `;
        const addBtn = this.shouldRenderEditButtons() ? `<div class="add-paragraph-btn" data-target="${item.editSection}">‚ûï Ajouter un paragraphe</div>` : '';
        return content + addBtn;
      }
      return `<div>${item.content}</div>`;
    },

    // Helper method to render complex content (lists, grids, etc.)
    renderComplexContent(content) {
      switch (content.type) {
        case 'ordered_list':
          return `
            <div class="editable-section editable-list-container" data-section-type="ordered_list">
              <ol class="editable editable-list" data-edit-type="ordered-list" data-edit-section="${content.editType}">
                ${content.items.map(item => `<li>${item}</li>`).join('')}
              </ol>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-list-btn" title="√âditer cette liste compl√®te">‚úèÔ∏è</button>' : ''}
            </div>
            ${this.shouldRenderEditButtons() ? '<div class="add-paragraph-btn" data-target="creation-steps">‚ûï Ajouter un paragraphe</div>' : ''}
          `;
        
        case 'list':
          return `
            <div class="editable-section editable-list-container" data-section-type="list">
              <ul class="editable editable-list" data-edit-type="list" data-edit-section="${content.editType}">
                ${content.items.map(item => `<li>${item}</li>`).join('')}
              </ul>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-list-btn" title="√âditer cette liste compl√®te">‚úèÔ∏è</button>' : ''}
            </div>
            ${this.shouldRenderEditButtons() ? `<div class="add-paragraph-btn" data-target="${content.editType}">‚ûï Ajouter un paragraphe</div>` : ''}
          `;
        
        case 'element_pairs':
          return this.renderElementPairs(content.pairs);
        
        case 'grid':
          return this.renderGrid(content);
        
        default:
          return `<div><!-- Unknown content type: ${content.type} --></div>`;
      }
    },

    // Helper method to render element pairs
    renderElementPairs(pairs) {
      return `
        <div class="pairs">
          ${pairs.map(pair => `
            <div class="cell">
              <svg aria-hidden="true" class="eico" viewBox="0 0 24 24">
                <circle cx="12" cy="12" fill="${pair.element1.color}" r="9"></circle>
              </svg>
              <span><span style="color: ${pair.element1.color}; font-weight: bold;${pair.element1.textShadow ? ` text-shadow: ${pair.element1.textShadow};` : ''}">${pair.element1.name}</span></span>
            </div>
            <div class="vs">‚áÜ</div>
            <div class="cell right">
              <svg aria-hidden="true" class="eico" viewBox="0 0 24 24">
                <circle cx="12" cy="12" fill="${pair.element2.color}" r="9"></circle>
              </svg>
              <span><span style="color: ${pair.element2.color}; font-weight: bold;${pair.element2.textShadow ? ` text-shadow: ${pair.element2.textShadow};` : ''}">${pair.element2.name}</span></span>
            </div>
          `).join('')}
        </div>
      `;
    },

    // Helper method to render grids
    renderGrid(gridData) {
      return `
        <div class="grid cols-${gridData.cols}">
          ${gridData.content ? gridData.content.map(item => this.renderCard(item)).join('') : 
            gridData.items ? gridData.items.map(item => this.renderCard(item)).join('') : ''}
        </div>
      `;
    },

    generateElementsPage() {
      return this.generateStaticPage('elements');
    },

    generateStatsPage() {
      return this.generateStaticPage('stats');
    },

    generateCompetencesPage() {
      return this.generateStaticPage('competences-tests');
    },

    generateEtatsPage() {
      return this.generateStaticPage('etats');
    },


    generateDevToolbox() {
      const devToolbox = JdrApp.utils.dom.$('#devToolbox');
      if (!devToolbox) return;

      const toolboxHTML = `
        <!-- En-t√™te de la toolbox -->
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--rule);">
          <span style="font-size: 18px;">üõ†</span>
          <strong style="color: var(--accent-ink); font-family: 'Cinzel', serif;">Outils de d√©veloppement</strong>
        </div>
        
        <!-- Groupe : √âdition et sauvegarde -->
        <div style="margin-bottom: 12px;">
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">‚úèÔ∏è √âdition</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="saveAndExport" title="Sauvegarder et exporter tout en ZIP">üíæ Export ZIP</button>
            <button class="btn small" id="forceReload" title="Recharger les donn√©es JSON (efface le cache)">üîÑ Recharger JSON</button>
          </div>
        </div>
        
        <!-- Groupe : Cr√©ation de contenu -->
        <div style="margin-bottom: 12px;">
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">üìù Cr√©ation</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="addCategory" title="Cr√©er une nouvelle cat√©gorie/page">üìÑ Nouvelle page</button>
            <button class="btn small" id="addSpellCategory" title="Cr√©er une nouvelle cat√©gorie de sorts">üîÆ Cat√©gorie de sorts</button>
            <button class="btn small" id="addDonCategory" title="Cr√©er une nouvelle cat√©gorie de dons">üéñÔ∏è Cat√©gorie de dons</button>
          </div>
        </div>
        
        <!-- Groupe : Ressources -->
        <div>
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">üé≠ Ressources</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="elementsBtn" title="Choisir un √©l√©ment pour copier sa balise HTML color√©e">üé® √âl√©ments</button>
            <button class="btn small" id="showIcons" title="Afficher la liste des ic√¥nes disponibles">üî• Ic√¥nes</button>
          </div>
        </div>
      `;

      devToolbox.innerHTML = toolboxHTML;
    },

    // General image renderer with style options
    renderImage(illusKey, options = {}) {
      const {
        altText = '',
        styleType = 'default', // 'spell', 'class', 'subclass', 'don', 'default'
        size = 'medium', // 'small', 'medium', 'large'
        frame = true
      } = options;

      // Check if image is available in images module
      let imageUrl = '';
      let imageStyle = 'display: none;';
      let removeStyle = 'display: none;';
      
      if (JdrApp.modules.images && JdrApp.modules.images.getImageUrl) {
        imageUrl = JdrApp.modules.images.getImageUrl(illusKey);
        if (imageUrl) {
          imageUrl = JdrApp.modules.images.processImageUrl(imageUrl);
          imageStyle = 'display: inline-block;';
          removeStyle = 'display: inline-flex;';
        }
      }

      // Build CSS classes based on style type
      let containerClasses = 'illus';
      let imageClasses = 'thumb';
      
      if (frame && ['spell', 'class', 'subclass', 'don'].includes(styleType)) {
        containerClasses += ` illus-${styleType}`;
      }
      
      if (size !== 'medium') {
        containerClasses += ` illus-${size}`;
      }

      // In standalone version, don't render editing buttons
      if (window.STANDALONE_VERSION) {
        return `
          <div class="${containerClasses}" data-illus-key="${illusKey}" data-style-type="${styleType}" data-bound="1">
            <img alt="Illustration ${altText}" class="${imageClasses}" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
          </div>
        `;
      }
      
      return `
        <div class="${containerClasses}" data-illus-key="${illusKey}" data-style-type="${styleType}" data-bound="1">
          <img alt="Illustration ${altText}" class="${imageClasses}" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
          <label class="up">üì∑ Ajouter<input accept="image/*" hidden="" type="file"></label>
          <button class="rm" type="button" style="${removeStyle}">üóë Retirer</button>
        </div>
      `;
    },

    // Simplified wrapper for backward compatibility
    createIllustration(illusKey, altText = '') {
      // Determine style type from illus key
      let styleType = 'default';
      if (illusKey.startsWith('spell:') || illusKey.startsWith('sort:')) styleType = 'spell';
      else if (illusKey.startsWith('class:')) styleType = 'class';
      else if (illusKey.startsWith('subclass:')) styleType = 'subclass';
      else if (illusKey.startsWith('don:')) styleType = 'don';
      
      return this.renderImage(illusKey, { altText, styleType });
    },

    createSubclassIllustrations(className, subclassName) {
      const illusKey1 = `subclass:${className}:${subclassName}:1`;
      const illusKey2 = `subclass:${className}:${subclassName}:2`;
      
      return `
        <div class="subclass-images">
          ${this.renderImage(illusKey1, { altText: `${subclassName} (Image 1)`, styleType: 'subclass' })}
          ${this.renderImage(illusKey2, { altText: `${subclassName} (Image 2)`, styleType: 'subclass' })}
        </div>
      `;
    },

    // Simplified dynamic rendering
    renderSortCategory(page) {
      const categoryId = page.replace('sorts-', '');
      const category = window.SORTS?.find(cat => 
        JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
      );
      
      if (!category) {
        return;
      }
      
      const article = document.querySelector(`article[data-page="${page}"]`);
      if (!article) {
        return;
      }
      
      // Generate content directly
      const content = `
        <section>
          <header>
            <h1>${category.nom}</h1>
            <div class="hero-illus">
              ${this.createIllustration(`spellcategory:${category.nom}`)}
            </div>
            
            <div class="editable-section" data-section-type="spell-category-description">
              <p class="lead editable editable-paragraph" data-edit-type="spell-category-description" data-edit-section="${category.nom}">${category.description}</p>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-paragraph-btn" title="√âditer la description de la cat√©gorie">‚úèÔ∏è</button>' : ''}
            </div>
            
            ${this.shouldRenderEditButtons() ? `<button class="spell-add" data-category-name="${category.nom}" type="button">‚ûï Ajouter un sort</button>` : ''}
          </header>
          
          <div class="grid cols-2">
            ${category.sorts.map((sort, index) => this.generateSpellCard(category, sort, index)).join('')}
          </div>
        </section>
      `;
      
      article.innerHTML = content;
    },




    // Auto-load images for all illustration slots
    autoLoadImages() {
      // Use images module if available
      if (JdrApp.modules.images) {
        return JdrApp.modules.images.autoLoadImages();
      }
      return 0;
    },

  };

})();
// ============================================================================
// JDR-BAB APPLICATION - EDITOR MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // EDITOR MODULE
  // ========================================
  JdrApp.modules.editor = {
    editedData: {},
    modifiedElements: new Map(), // Track what was actually modified
    isDevMode: false, // Always false by default, no localStorage read

    init() {
      
      // Set up dev mode toggle
      JdrApp.utils.events.register('click', '#devToggle', () => this.toggleDevMode());
      
      // Set up editable element handlers
      this.setupEditableHandlers();
      
      // Set up creation handlers for new elements
      this.setupCreationHandlers();
      
      // Set up image upload handlers
      this.setupImageHandlers();
      
      // Initialize dev mode state - enable automatically in development
      this.updateDevModeState();
    },

    toggleDevMode() {
      // In standalone version, prevent dev mode toggle
      if (window.STANDALONE_VERSION) {
        return;
      }
      
      this.isDevMode = !this.isDevMode;
      document.body.classList.toggle('dev-on', this.isDevMode);
      document.body.classList.toggle('dev-off', !this.isDevMode);
      
      // Note: No localStorage save - dev mode resets on page reload
      this.updateDevModeState();
    },

    updateDevModeState() {
      if (window.STANDALONE_VERSION) {
        document.body.className = 'dev-off';
        this.forceHideAllEditButtons();
        return;
      }
      
      // Apply correct body classes
      document.body.classList.toggle('dev-on', this.isDevMode);
      document.body.classList.toggle('dev-off', !this.isDevMode);
      
      const devToggle = document.querySelector('#devToggle');
      const devToolbox = document.querySelector('#devToolbox');
      
      if (devToggle) {
        devToggle.textContent = `üõ† Dev Mode: ${this.isDevMode ? 'ON' : 'OFF'}`;
      }
      
      if (devToolbox) {
        devToolbox.style.display = this.isDevMode ? 'block' : 'none';
      }
      
      // Show/hide edit buttons based on dev mode state
      if (this.isDevMode) {
        this.forceShowAllEditButtons();
      } else {
        this.forceHideAllEditButtons();
      }
    },
    
    forceHideAllEditButtons() {
      // Only hide buttons if dev mode is actually OFF
      if (this.isDevMode || window.STANDALONE_VERSION === false) {
        return; // Don't hide buttons in dev mode ON
      }
      
      // Aggressively hide ALL edit buttons using JavaScript when dev mode is OFF
      const editButtonSelectors = [
        '.edit-btn',
        '.edit-title-btn', 
        '.edit-paragraph-btn',
        '.edit-list-btn',
        '.edit-field-btn',
        '.edit-effect-btn',
        '.edit-stats-btn',
        '.edit-section-btn',
        'button[class*="edit"]',
        'button[title*="‚úèÔ∏è"]',
        'button[title*="diter"]',
        'button[title*="Edit"]',
        '.spell-add',
        '.don-add',
        '.spell-delete',
        '.don-delete',
        '.don-move-up',
        '.don-move-down',
        '.section-delete',
        '.remove-section-btn',
        '.add-paragraph-btn',
        '.add-subclass-btn',
        '.delete-subclass-btn',
        'button[data-category-name]',
        'button[data-spell-name]',
        'button[data-don-name]',
        'button[data-section-name]',
        'button[data-section-type]',
        '.illus .up',
        '.illus .rm',
        '.illus label',
        '.illus input[type="file"]'
      ];
      
      editButtonSelectors.forEach(selector => {
        try {
          const elements = document.querySelectorAll(selector);
          elements.forEach(element => {
            element.style.display = 'none';
            element.style.visibility = 'hidden';
            element.style.opacity = '0';
            element.style.pointerEvents = 'none';
            element.setAttribute('aria-hidden', 'true');
          });
        } catch (error) {
          // Silently handle selector errors
        }
      });
    },
    
    forceShowAllEditButtons() {
      // Show edit buttons when dev mode is ON
      const editButtonSelectors = [
        '.edit-btn',
        '.edit-title-btn', 
        '.edit-paragraph-btn',
        '.edit-list-btn',
        '.edit-field-btn',
        '.edit-effect-btn',
        '.edit-stats-btn',
        '.edit-section-btn',
        'button[class*="edit"]',
        'button[title*="‚úèÔ∏è"]',
        'button[title*="diter"]',
        'button[title*="Edit"]',
        '.spell-add',
        '.don-add',
        '.spell-delete',
        '.don-delete',
        '.don-move-up',
        '.don-move-down',
        '.section-delete',
        '.remove-section-btn',
        '.add-paragraph-btn',
        '.add-subclass-btn',
        '.delete-subclass-btn',
        'button[data-category-name]',
        'button[data-spell-name]',
        'button[data-don-name]',
        'button[data-section-name]',
        'button[data-section-type]',
        '.illus .up',
        '.illus .rm',
        '.illus label',
        '.illus input[type="file"]'
      ];
      
      editButtonSelectors.forEach(selector => {
        try {
          const elements = document.querySelectorAll(selector);
          elements.forEach(element => {
            element.style.display = '';
            element.style.visibility = '';
            element.style.opacity = '';
            element.style.pointerEvents = '';
            element.removeAttribute('aria-hidden');
          });
        } catch (error) {
          // Silently handle selector errors
        }
      });
    },

    setupEditableHandlers() {
      // Edit button click
      JdrApp.utils.events.register('click', '.edit-btn', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!this.isDevMode) {
          return;
        }
        
        // Find the parent editable section
        const editableSection = e.target.closest('.editable-section');
        if (editableSection) {
          this.makeEditableSection(editableSection);
          return;
        }
        
        // Fallback: Find the parent list item (legacy support)
        const listItem = e.target.closest('.editable-item');
        if (listItem) {
          this.makeEditableItem(listItem);
          return;
        }
        
        // No editable element found
      });

      // Completely disable any double-click editing by blocking ALL events on .editable elements
      JdrApp.utils.events.register('dblclick', '.editable', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      });

      JdrApp.utils.events.register('click', '.editable', (e) => {
        // Only allow clicks for keyboard navigation, no editing triggers
      });

      // Click outside to save
      JdrApp.utils.events.register('click', 'body', (e) => {
        if (!e.target.closest('.editable') && !e.target.matches('.editable') && !e.target.matches('.edit-btn')) {
          this.saveAllEdits();
        }
      });

      // Enter to save, Escape to save and exit
      JdrApp.utils.events.register('keydown', '.editable', (e) => {
        if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey) {
            e.preventDefault();
          // Find the parent editable section or item
          const editableContainer = e.target.closest('.editable-section, .editable-item') || e.target;
          this.saveEdit(editableContainer);
        } else if (e.key === 'Escape') {
            e.preventDefault();
          // Find the parent editable section or item
          const editableContainer = e.target.closest('.editable-section, .editable-item') || e.target;
          this.saveEdit(editableContainer);
        }
      });
    },

    // Find the best editable target element
    findEditableTarget(clickedElement) {
      // If the clicked element itself has edit attributes, use it
      if (clickedElement.dataset.editType && clickedElement.dataset.editSection !== undefined) {
        return clickedElement;
      }
      
      // Otherwise, look for the closest parent with edit attributes
      let current = clickedElement;
      while (current && current !== document.body) {
        if (current.classList && current.classList.contains('editable') && 
            current.dataset.editType && current.dataset.editSection !== undefined) {
          // Found parent editable element
          return current;
        }
        current = current.parentElement;
      }
      
      // Fallback: return the original clicked element if it's at least .editable
      if (clickedElement.classList && clickedElement.classList.contains('editable')) {
        // Using fallback editable element
        return clickedElement;
      }
      
      // No suitable editable element found
      return null;
    },

    makeEditableSection(section) {
      
      if (section.dataset.editing === 'true') {
        return;
      }
      
      // Find the editable element inside the section
      const editableElement = section.querySelector('.editable');
      if (!editableElement) {
        return;
      }
      
      // STRICT VALIDATION: Ensure editableElement has required data attributes
      if (!editableElement.dataset.editType || !editableElement.dataset.editSection) {
        return;
      }
      
      // Store original content on the section itself (which has the data attributes)
      section.dataset.originalContent = editableElement.innerHTML;
      section.dataset.editing = 'true';
      
      
      // Show HTML source for editing
      const htmlSource = editableElement.innerHTML;
      editableElement.textContent = htmlSource; // Show HTML as text
      
      // Make the editable element editable
      editableElement.contentEditable = true;
      editableElement.style.backgroundColor = 'rgba(255, 255, 0, 0.1)';
      editableElement.style.border = '1px dashed var(--bronze)';
      editableElement.style.borderRadius = '4px';
      editableElement.style.padding = '4px';
      editableElement.style.fontFamily = 'monospace'; // Monospace font for HTML editing
      editableElement.style.whiteSpace = 'pre-wrap'; // Preserve whitespace
      editableElement.focus();
      
      // Select all text
      const range = document.createRange();
      range.selectNodeContents(editableElement);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
    },

    makeEditableItem(listItem) {
      
      if (listItem.dataset.editing === 'true') {
        return;
      }
      
      // Find the content div inside the list item
      const contentDiv = listItem.querySelector('.editable-content');
      if (!contentDiv) {
        return;
      }
      
      // Store original content on the list item itself (which has the data attributes)
      listItem.dataset.originalContent = contentDiv.innerHTML;
      listItem.dataset.editing = 'true';
      
      // List item made editable
      
      // Make the content div editable
      contentDiv.contentEditable = true;
      contentDiv.style.backgroundColor = 'rgba(255, 255, 0, 0.1)';
      contentDiv.style.border = '1px dashed var(--bronze)';
      contentDiv.style.borderRadius = '4px';
      contentDiv.style.padding = '4px';
      contentDiv.focus();
      
      // Select all text
      const range = document.createRange();
      range.selectNodeContents(contentDiv);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
    },

    makeEditable(element) {
      
      if (element.dataset.editing === 'true') {
        return;
      }
      
      // Store original content
      element.dataset.originalContent = element.innerHTML;
      element.dataset.editing = 'true';
      
      // Element made editable
      
      // Make contenteditable
      element.contentEditable = true;
      element.style.backgroundColor = 'rgba(255, 255, 0, 0.1)';
      element.style.border = '1px dashed var(--bronze)';
      element.focus();
      
      // Select all text
      const range = document.createRange();
      range.selectNodeContents(element);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
    },

    saveEdit(element) {
      // For editable sections, get the edit type from the .editable element inside
      let editType = element.dataset.editType;
      let editSection = element.dataset.editSection;
      
      // For list items, get content from the .editable-content div
      let newContent;
      if (element.classList.contains('editable-item')) {
        const contentDiv = element.querySelector('.editable-content');
        newContent = contentDiv ? contentDiv.innerHTML.trim() : element.innerHTML.trim();
      } else if (element.classList.contains('editable-section')) {
        // For editable sections, get content from the .editable element inside
        const editableElement = element.querySelector('.editable');
        if (editableElement) {
          // Get the text content (HTML source) and use it as the new HTML
          newContent = editableElement.textContent.trim();
          editType = editableElement.dataset.editType;
          editSection = editableElement.dataset.editSection;
        } else {
          newContent = element.innerHTML.trim();
        }
      } else {
        newContent = element.innerHTML.trim();
      }
      
      const originalContent = element.dataset.originalContent;
      
      // Normalize HTML content to ensure consistency
      newContent = this.normalizeHTMLContent(newContent);
      
      
      if (newContent !== originalContent) {
        
        // Store edit in editedData
        this.storeEdit(element, newContent);
        
        // Track this element as modified (only if editType is valid)
        if (editType && typeof editType === 'string') {
          const elementId = this.getElementId(element);
          
          this.modifiedElements.set(elementId, {
            element: element,
            content: newContent,
            editType: editType,
            timestamp: Date.now()
          });
          
        } else {
          // Skipping element with invalid editType
        }
        
        // For editable sections, update the visual content immediately
        if (element.classList.contains('editable-section')) {
          const editableElement = element.querySelector('.editable');
          if (editableElement) {
            // Update the visible content with the new HTML
            editableElement.innerHTML = newContent;
          }
        } else if (element.classList.contains('editable-item')) {
          const contentDiv = element.querySelector('.editable-content');
          if (contentDiv) {
            // Update the visible content for list items
            contentDiv.innerHTML = newContent;
          }
        } else {
          // For direct editable elements, the content is already updated
        }
        
        // Apply element coloring if needed
        this.applyElementColoring(element);
        
        // IMMEDIATELY save changes to localStorage to persist edits
        this.saveChangesToStorage();
      } else {
        // No content change detected
      }
      
      // Reset editing state
      this.resetEditingState(element);
    },

    cancelEdit(element) {
      
      // Restore original content
      if (element.classList.contains('editable-section')) {
        const editableElement = element.querySelector('.editable');
        if (editableElement && element.dataset.originalContent) {
          editableElement.innerHTML = element.dataset.originalContent;
        }
      } else if (element.classList.contains('editable-item')) {
        const contentDiv = element.querySelector('.editable-content');
        if (contentDiv && element.dataset.originalContent) {
          contentDiv.innerHTML = element.dataset.originalContent;
        }
      } else {
        if (element.dataset.originalContent) {
          element.innerHTML = element.dataset.originalContent;
        }
      }
      
      this.resetEditingState(element);
    },

    resetEditingState(element) {
      // For list items, reset the .editable-content div
      if (element.classList.contains('editable-item')) {
        const contentDiv = element.querySelector('.editable-content');
        if (contentDiv) {
          contentDiv.contentEditable = false;
          contentDiv.style.backgroundColor = '';
          contentDiv.style.border = '';
          contentDiv.style.borderRadius = '';
          contentDiv.style.padding = '';
          // Note: We don't restore original content here - the new content should stay
        }
      } else if (element.classList.contains('editable-section')) {
        // For editable sections, reset the .editable element inside
        const editableElement = element.querySelector('.editable');
        if (editableElement) {
          editableElement.contentEditable = false;
          editableElement.style.backgroundColor = '';
          editableElement.style.border = '';
          editableElement.style.borderRadius = '';
          editableElement.style.padding = '';
          editableElement.style.fontFamily = ''; // Reset font
          editableElement.style.whiteSpace = ''; // Reset whitespace
          
          // Note: We don't restore original content here - the updated content should stay
          // The content has already been updated in the saveEdit method
        }
      } else {
        element.contentEditable = false;
        element.style.backgroundColor = '';
        element.style.border = '';
        // Note: We don't restore original content here - the new content should stay
      }
      
      element.dataset.editing = 'false';
      delete element.dataset.originalContent;
    },

    saveAllEdits() {
      // Save both old-style editable elements and new-style editable sections
      JdrApp.utils.dom.$('.editable[data-editing="true"], .editable-section[data-editing="true"], .editable-item[data-editing="true"]').forEach(element => {
        // STRICT VALIDATION: Only save elements with proper data attributes
        if (this.hasValidEditData(element)) {
          this.saveEdit(element);
        } else {
          this.resetEditingState(element);
        }
      });
    },
    
    hasValidEditData(element) {
      // For editable sections, check the .editable element inside
      if (element.classList.contains('editable-section')) {
        const editableElement = element.querySelector('.editable');
        return editableElement && editableElement.dataset.editType && editableElement.dataset.editSection;
      }
      
      // For editable items and direct editable elements
      return element.dataset.editType && (element.dataset.editSection || element.dataset.editSpell || element.dataset.editDon || element.dataset.editClass);
    },

    storeEdit(element, content) {
      // Find the actual editable element that has the data attributes
      let editableElement = element;
      let editType = element.dataset.editType;
      
      // If this is an editable section, get the data from the .editable element inside
      if (element.classList.contains('editable-section')) {
        const innerEditable = element.querySelector('.editable');
        if (innerEditable && innerEditable.dataset.editType) {
          editableElement = innerEditable;
          editType = innerEditable.dataset.editType;
        }
      }
      
      // Validate editType before proceeding
      if (!editType || typeof editType !== 'string') {
        return;
      }
      
      // Update data directly in global structures based on element attributes
      this.updateGlobalData(editableElement, content, editType);
    },

    getEditKey(element) {
      // Generate a unique key based on element data attributes
      const editType = element.dataset.editType;
      
      if (element.dataset.editSpell) {
        return element.dataset.editSpell;
      } else if (element.dataset.editDon) {
        return element.dataset.editDon;
      } else if (element.dataset.editClass) {
        return element.dataset.editClass;
      } else if (element.dataset.editCategory) {
        return element.dataset.editCategory;
      } else if (element.dataset.editSection) {
        return element.dataset.editSection;
      }
      
      return 'default';
    },

    getElementId(element) {
      // Find the actual editable element that has the data attributes
      let editableElement = element;
      
      // If this is an editable section, get the data from the .editable element inside
      if (element.classList.contains('editable-section')) {
        const innerEditable = element.querySelector('.editable');
        if (innerEditable && innerEditable.dataset.editType) {
          editableElement = innerEditable;
        }
      }
      
      // Create a unique ID for tracking modifications
      const editType = editableElement.dataset.editType;
      const editSpell = editableElement.dataset.editSpell;
      const editDon = editableElement.dataset.editDon;
      const editClass = editableElement.dataset.editClass;
      const editSubclass = editableElement.dataset.editSubclass;
      const editCategory = editableElement.dataset.editCategory;
      const editSection = editableElement.dataset.editSection;
      
      if (editSpell) return `spell:${editSpell}:${editType}`;
      if (editDon) return `don:${editDon}:${editType}`;
      if (editClass && editSubclass) return `subclass:${editClass}:${editSubclass}:${editType}`;
      if (editClass) return `class:${editClass}:${editType}`;
      if (editCategory) return `category:${editCategory}:${editType}`;
      if (editSection) return `section:${editSection}:${editType}`;
      
      // Fallback: use element position in DOM
      const allEditables = Array.from(document.querySelectorAll('.editable'));
      const index = allEditables.indexOf(editableElement);
      return `element:${index}:${editType}`;
    },



    updateStaticPageData(element, content) {
      const editSection = element.dataset.editSection;
      
      if (!window.STATIC_PAGES) return false;
      
      const article = element.closest('article[data-static-page="true"]');
      if (!article) return false;
      
      const pageId = article.dataset.page;
      const pageData = window.STATIC_PAGES[pageId];
      
      if (!pageData || !pageData.sections) return false;
      
      return this.updateSectionContent(pageData.sections, editSection, content, element);
    },

    updateStaticPageDataByEditType(element, content) {
      const editType = element.dataset.editType;
      
      if (!window.STATIC_PAGES) return false;
      
      const article = element.closest('article[data-static-page="true"]');
      if (!article) return false;
      
      const pageId = article.dataset.page;
      const pageData = window.STATIC_PAGES[pageId];
      
      if (!pageData || !pageData.sections) return false;
      
      return this.updateSectionContentByEditType(pageData.sections, editType, content, element);
    },

    updateSectionContentByEditType(sections, editType, content, element) {
      const editSection = element.dataset.editSection;
      
      for (let i = 0; i < sections.length; i++) {
        const section = sections[i];
        
        // Handle card content with ordered lists
        if (section.type === 'card' && section.content) {
          if (section.content.type === 'ordered_list' && section.content.editType === editSection) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            const listItems = tempDiv.querySelectorAll('li');
            section.content.items = Array.from(listItems).map(li => li.innerHTML);
            return true;
          }
          
          if (section.content.type === 'list' && section.content.editType === editSection) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            const listItems = tempDiv.querySelectorAll('li');
            section.content.items = Array.from(listItems).map(li => li.innerHTML);
            return true;
          }
        }
        
        // Handle grid content
        if (section.type === 'grid' && section.content) {
          for (let j = 0; j < section.content.length; j++) {
            const gridItem = section.content[j];
            if (gridItem.content && Array.isArray(gridItem.content)) {
              const result = this.updateSectionContentByEditType([{content: gridItem.content}], editType, content, element);
              if (result) return true;
            }
          }
        }
      }
      
      return false;
    },

    updateSectionContent(sections, editSection, content, element) {
      
      for (let i = 0; i < sections.length; i++) {
        const section = sections[i];
        // Checking section
        
        // Check if this is the section we're looking for
        if (section.type === 'intro' && editSection === 'intro') {
          section.content = content;
          return true;
        }
        
        // Handle card content
        if (section.type === 'card' && section.content) {
          // Check if this is a card title edit
          if (editSection.endsWith('-title') && section.sectionType) {
            const sectionId = editSection.replace('-title', '');
            if (section.sectionType === sectionId) {
              section.title = content;
              return true;
            }
          }
          
          if (section.content.type === 'ordered_list' && section.content.editType === editSection) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            const listItems = tempDiv.querySelectorAll('li');
            section.content.items = Array.from(listItems).map(li => li.innerHTML);
            return true;
          }
          
          // Handle array content in cards
          if (Array.isArray(section.content)) {
            for (let j = 0; j < section.content.length; j++) {
              const contentItem = section.content[j];
              if (contentItem.editSection === editSection) {
                contentItem.content = content;
                return true;
              }
            }
          }
        }
        
        // Handle grid content
        if (section.type === 'grid' && section.content) {
          for (let j = 0; j < section.content.length; j++) {
            const gridItem = section.content[j];
            if (gridItem.content && Array.isArray(gridItem.content)) {
              const result = this.updateSectionContent([{content: gridItem.content}], editSection, content, element);
              if (result) return true;
            }
          }
        }
      }
      
      return false;
    },

    applyElementColoring(element) {
      // Apply element coloring with delay
      setTimeout(() => {
        this.colorizeElements(element);
      }, 500);
    },

    colorizeElements(container = document) {
      const elementMap = {
        'Feu': { color: '#ff6b35', weight: 'bold' },
        'Air': { color: '#87ceeb', weight: 'bold' },
        'Eau': { color: '#4682b4', weight: 'bold' },
        'Terre': { color: '#8b7355', weight: 'bold' },
        'Divin': { color: '#ffd700', weight: 'bold' },
        'Mal√©fique': { color: '#8b008b', weight: 'bold' }
      };

      const walker = document.createTreeWalker(
        container,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );

      const textNodes = [];
      let node;
      while (node = walker.nextNode()) {
        textNodes.push(node);
      }

      textNodes.forEach(textNode => {
        let content = textNode.textContent;
        let hasChanges = false;

        Object.entries(elementMap).forEach(([element, style]) => {
          const regex = new RegExp(`\\b${element}\\b`, 'g');
          if (regex.test(content)) {
            content = content.replace(regex, `<span style="color: ${style.color}; font-weight: ${style.weight};">${element}</span>`);
            hasChanges = true;
          }
        });

        if (hasChanges) {
          const wrapper = document.createElement('span');
          wrapper.innerHTML = content;
          textNode.parentNode.replaceChild(wrapper, textNode);
        }
      });
    },

    setupCreationHandlers() {
      // Add new subclass
      JdrApp.utils.events.register('click', '.add-subclass-btn', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!this.isDevMode) {
          return;
        }
        
        this.addNewSubclass(e.target);
      });

      // Delete subclass
      JdrApp.utils.events.register('click', '.delete-subclass-btn', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!this.isDevMode) {
          return;
        }
        
        this.deleteSubclass(e.target);
      });
    },

    addNewSubclass(button) {
      // Find the parent class article
      const article = button.closest('article');
      if (!article) return;
      
      // Try to get class name from article attributes or from URL
      let className = article.dataset.class;
      if (!className) {
        const currentHash = window.location.hash;
        const match = currentHash.match(/#\/([^\/]+)/);
        if (match) {
          className = match[1].charAt(0).toUpperCase() + match[1].slice(1);
        }
      }
      
      if (!className || !window.CLASSES) return;
      
      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe) return;
      
      // Create new subclass with default values including proper labels
      const newSubclass = {
        nom: "Nouvelle sous-classe",
        base: {
          Force: 3,
          Agilit√©: 3,
          Endurance: 3,
          Intelligence: 3,
          Volont√©: 3,
          Chance: 3
        },
        progression: "<strong>üìà Progression par niveau:</strong> +1 Force üí™, +1 Agilit√© üèÉ",
        capacites: [
          "<em>Capacit√© unique</em>: Description de la capacit√© sp√©ciale de cette sous-classe."
        ]
      };
      
      // Add to the class
      if (!classe.sousClasses) {
        classe.sousClasses = [];
      }
      classe.sousClasses.push(newSubclass);
      
      // Save immediately
      this.saveChangesToStorage();
      
      // Refresh the current page to show the new subclass
      window.location.reload();
    },

    deleteSubclass(button) {
      const className = button.dataset.className;
      const subclassName = button.dataset.subclassName;
      
      if (!className || !subclassName) {
        console.error('‚ùå Missing class or subclass name');
        return;
      }

      // Confirm deletion
      if (!confirm(`√ätes-vous s√ªr de vouloir supprimer la sous-classe "${subclassName}" ?`)) {
        return;
      }

      if (!window.CLASSES) {
        console.error('‚ùå No CLASSES data');
        return;
      }

      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe || !classe.sousClasses) {
        console.error('‚ùå Class or subclasses not found');
        return;
      }

      // Find and remove the subclass
      const subclassIndex = classe.sousClasses.findIndex(sc => sc.nom === subclassName);
      if (subclassIndex === -1) {
        console.error('‚ùå Subclass not found');
        return;
      }

      classe.sousClasses.splice(subclassIndex, 1);

      // Save immediately
      this.saveChangesToStorage();

      // Refresh the current page
      window.location.reload();
    },

    setupImageHandlers() {
      // Image upload
      JdrApp.utils.events.register('change', '.illus input[type="file"]', (e) => {
        this.handleImageUpload(e);
      });

      // Image removal
      JdrApp.utils.events.register('click', '.illus .rm', (e) => {
        this.handleImageRemoval(e);
      });

      // Image enlargement
      JdrApp.utils.events.register('click', '.illus img', (e) => {
        this.toggleImageEnlargement(e.target);
      });
    },

    handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const illus = event.target.closest('.illus');
        const img = illus.querySelector('img');
        const rmButton = illus.querySelector('.rm');
        const illusKey = illus.dataset.illusKey;

        // Set image source and display
        img.src = e.target.result;
        img.style.display = 'block';
        if (rmButton) rmButton.style.display = 'block';

        // Save to images module if available
        if (JdrApp.modules.images && JdrApp.modules.images.setImageUrl) {
          JdrApp.modules.images.setImageUrl(illusKey, e.target.result);
        } else {
          // Fallback: save to localStorage with quota management
          try {
            localStorage.setItem(`illustration:${illusKey}`, e.target.result);
          } catch (error) {
            if (error.name === 'QuotaExceededError') {
              this.clearOldImages();
              
              // Try again after clearing
              try {
                localStorage.setItem(`illustration:${illusKey}`, e.target.result);
              } catch (secondError) {
                alert('Espace de stockage insuffisant. Veuillez supprimer quelques images pour continuer.');
                // Reset image display
                img.src = '';
                img.style.display = 'none';
                if (rmButton) rmButton.style.display = 'none';
                return;
              }
            } else {
              throw error;
            }
          }
        }
      };
      
      reader.onerror = (e) => {
        alert('Erreur lors de la lecture du fichier image');
      };
      
      reader.readAsDataURL(file);
    },

    handleImageRemoval(event) {
      const illus = event.target.closest('.illus');
      const img = illus.querySelector('img');
      const rmButton = illus.querySelector('.rm');
      const illusKey = illus.dataset.illusKey;

      // Remove image display
      img.src = '';
      img.style.display = 'none';
      if (rmButton) rmButton.style.display = 'none';

      // Remove from images module if available
      if (JdrApp.modules.images && JdrApp.modules.images.removeImage) {
        JdrApp.modules.images.removeImage(illusKey);
      } else {
        // Fallback: remove from localStorage
        localStorage.removeItem(`illustration:${illusKey}`);
      }
    },

    toggleImageEnlargement(img) {
      if (img.classList.contains('enlarged')) {
        img.classList.remove('enlarged');
        this.removeImageBackdrop();
      } else {
        img.classList.add('enlarged');
        this.createImageBackdrop();
      }
    },

    createImageBackdrop() {
      let backdrop = document.querySelector('.image-backdrop');
      if (!backdrop) {
        backdrop = document.createElement('div');
        backdrop.className = 'image-backdrop';
        document.body.appendChild(backdrop);
      }
      
      backdrop.classList.add('visible');
      
      // Click to close
      backdrop.onclick = () => {
        JdrApp.utils.dom.$('img.enlarged').forEach(img => {
          img.classList.remove('enlarged');
        });
        this.removeImageBackdrop();
      };
    },

    removeImageBackdrop() {
      const backdrop = document.querySelector('.image-backdrop');
      if (backdrop) {
        backdrop.classList.remove('visible');
      }
    },

    // Clear old images from localStorage to free space
    clearOldImages() {
      const illustrationKeys = [];
      
      // Find all illustration keys in localStorage
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('illustration:')) {
          illustrationKeys.push(key);
        }
      }
      
      // Sort by key (oldest first, roughly)
      illustrationKeys.sort();
      
      // Remove the oldest half
      const toRemove = Math.ceil(illustrationKeys.length / 2);
      for (let i = 0; i < toRemove; i++) {
        localStorage.removeItem(illustrationKeys[i]);
      }
    },

    forceCollectAllEdits() {
      this.saveAllEdits();
      
      // All data is already updated in global structures during editing
      // No need to process modifiedElements again since updateGlobalData
      // is called immediately when each edit is saved
      
      return this.editedData;
    },

    // Ultra-simple generic method - just save text as-is
    updateGlobalData(element, content, editType) {
      try {
        // Find the target in global data and update it directly with the raw content
        this.updateDataByPath(element, content);
      } catch (error) {
        // Silently handle errors
      }
    },

    // Ultra-simple method to save any text content to the right place
    updateDataByPath(element, content) {
      const editType = element.dataset.editType;
      
      // SPELLS
      if (element.dataset.editSpell) {
        let property = editType.replace('spell-', '');
        this.saveToSpell(element.dataset.editSpell, property, content);
        return;
      }
      
      // DONS
      if (element.dataset.editDon) {
        this.saveToDon(element.dataset.editDon, editType.replace('don-', ''), content);
        return;
      }
      
      // CLASSES/SUBCLASSES
      if (element.dataset.editSection && (element.dataset.editSection.includes('-') || editType.startsWith('subclass-'))) {
        this.saveToSubclass(element.dataset.editSection, editType, content);
        return;
      }
      
      if (element.dataset.editClass) {
        this.saveToClass(element.dataset.editClass, editType, content);
        return;
      }
      
      // STATIC PAGES
      this.updateStaticPageDataByEditType(element, content);
    },

    // Simple save methods - just store text as-is
    saveToSpell(spellName, property, content) {
      if (!window.SORTS) return;
      
      for (const category of window.SORTS) {
        const spell = category.sorts.find(s => s.nom === spellName);
        if (spell) {
          const propertyMap = {
            'name': 'nom', 
            'description': 'description', 
            'prerequis': 'prerequis',
            'portee': 'portee', 
            'mana': 'coutMana', 
            'temps-incantation': 'tempsIncantation',
            'duree': 'duree',
            'resistance': 'resistance', 
            'effect-normal': 'effetNormal',
            'effect-critical': 'effetCritique', 
            'effect-failure': 'effetEchec'
          };
          const targetProperty = propertyMap[property] || property;
          spell[targetProperty] = content;
          return true;
        }
      }
      
      return false;
    },

    saveToDon(donName, property, content) {
      if (!window.DONS) return;
      for (const category of window.DONS) {
        const don = category.dons.find(d => d.nom === donName);
        if (don) {
          const propertyMap = { 'name': 'nom', 'description': 'description', 'prerequis': 'prerequis', 'cout': 'cout' };
          don[propertyMap[property] || property] = content;
          break;
        }
      }
    },

    saveToClass(className, editType, content) {
      if (!window.CLASSES) return;
      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe) return;
      
      if (editType === 'resume') {
        classe.resume = content;
      } else if (editType === 'capacites') {
        classe.capacites = this.parseListContent(content);
      }
    },

    saveToSubclass(editSection, editType, content) {
      if (!editSection || !window.CLASSES) return;
      
      const parts = editSection.split('-');
      if (parts.length < 2) return;
      
      const className = parts[0];
      const subClassName = parts.slice(1).join('-');
      
      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe || !classe.sousClasses) return;
      
      const sousClasse = classe.sousClasses.find(sc => sc.nom === subClassName);
      if (!sousClasse) return;
      
      if (editType === 'subclass-progression') {
        sousClasse.progression = content;
      } else if (editType === 'subclass-capacites') {
        sousClasse.capacites = this.parseListContent(content);
      } else if (editType === 'subclass-stats') {
        sousClasse.base = this.parseStatsContent(content);
      }
    },

    // Helper methods for parsing content (only when needed)
    parseListContent(content) {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = content;
      const listItems = tempDiv.querySelectorAll('li');
      return Array.from(listItems).map(li => li.innerHTML);
    },

    parseStatsContent(content) {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = content;
      const chips = tempDiv.querySelectorAll('.chip');
      const stats = {};
      
      chips.forEach(chip => {
        const text = chip.textContent.trim();
        const match = text.match(/(.+?):\s*(.+)/);
        if (match) {
          const statName = match[1].replace(/^[^\w]+/, '').trim(); // Remove emoji
          const statValue = match[2].trim();
          stats[statName] = statValue;
        }
      });
      
      return stats;
    },

    // Update individual list item in static pages
    updateListItem(element, content) {
      const editSection = element.dataset.editSection;
      const editIndex = parseInt(element.dataset.editIndex);
      
      if (!window.STATIC_PAGES) {
        return false;
      }
      
      const article = element.closest('article[data-static-page="true"]');
      if (!article) {
        return false;
      }
      
      const pageId = article.dataset.page;
      const pageData = window.STATIC_PAGES[pageId];
      
      if (!pageData || !pageData.sections) {
        return false;
      }
      
      // Find the list in the page data
      for (let i = 0; i < pageData.sections.length; i++) {
        const section = pageData.sections[i];
        
        if (section.type === 'card' && section.content) {
          if (section.content.type === 'ordered_list' && section.content.editType === editSection) {
            section.content.items[editIndex] = content;
            return true;
          }
          
          if (section.content.type === 'list' && section.content.editType === editSection) {
            section.content.items[editIndex] = content;
            return true;
          }
        }
      }
      
      // List not found
      return false;
    },

    // Normalize HTML content to ensure consistency across browsers and editing
    normalizeHTMLContent(html) {
      // Create a temporary div to parse and normalize the HTML
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;
      
      // Remove any contenteditable artifacts
      this.removeContentEditableArtifacts(tempDiv);
      
      // Normalize whitespace and formatting
      let normalized = tempDiv.innerHTML;
      
      // Preserve important HTML entities and structure
      normalized = this.preserveHTMLStructure(normalized);
      
      return normalized.trim();
    },

    // Remove contenteditable artifacts that browsers might add
    removeContentEditableArtifacts(container) {
      // Remove any empty text nodes or unnecessary spans
      const walker = document.createTreeWalker(
        container,
        NodeFilter.SHOW_ALL,
        null,
        false
      );

      const nodesToRemove = [];
      let node;
      
      while (node = walker.nextNode()) {
        // Remove empty text nodes with only whitespace
        if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() === '') {
          // But preserve intentional &nbsp; and single spaces in specific contexts
          if (node.textContent !== '\u00a0' && node.parentNode.tagName !== 'SPAN') {
            nodesToRemove.push(node);
          }
        }
        
        // Remove empty spans without attributes or with only style="font-weight: normal" etc.
        if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'SPAN') {
          if (!node.hasAttributes() && node.textContent.trim() === '') {
            nodesToRemove.push(node);
          }
        }
        
        // Remove Firefox/Chrome artifacts like <div><br></div>
        if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'DIV') {
          if (node.innerHTML === '<br>' || node.innerHTML === '<br/>') {
            // Replace with just <br>
            const br = document.createElement('br');
            node.parentNode.replaceChild(br, node);
          }
        }
      }
      
      // Remove identified nodes
      nodesToRemove.forEach(node => {
        if (node.parentNode) {
          node.parentNode.removeChild(node);
        }
      });
    },

    // Preserve important HTML structure and entities
    preserveHTMLStructure(html) {
      // Ensure consistent formatting for common patterns
      
      // Normalize <br> tags (some browsers use <br/>, others <br>)
      html = html.replace(/<br\s*\/?>/gi, '<br>');
      
      // Preserve color styling (ensure it's properly formatted)
      html = html.replace(/style\s*=\s*["']([^"']*color\s*:\s*[^;"']+[^"']*)["']/gi, (match, styleContent) => {
        // Clean up the style content
        const cleanStyle = styleContent.trim().replace(/\s+/g, ' ');
        return `style="${cleanStyle}"`;
      });
      
      // Preserve &nbsp; entities
      html = html.replace(/\u00a0/g, '&nbsp;');
      
      // Ensure consistent quote usage in attributes
      html = html.replace(/(\w+)\s*=\s*'([^']*)'/g, '$1="$2"');
      
      return html;
    },

    // Save changes to localStorage immediately when edits are made
    saveChangesToStorage() {
      try {
        // Save only edited data overlay (not full data)
        localStorage.setItem('jdr-bab-edits', JSON.stringify(this.editedData));
        
        // Save timestamp of last modification
        localStorage.setItem('jdr-bab-last-modified', Date.now().toString());
        
        
      } catch (error) {
        console.error('‚ùå Failed to save changes to localStorage:', error);
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - UI MODULE
// ============================================================================

(() => {
  "use strict";


  // ========================================
  // UI INTERACTIONS MODULE
  // ========================================
  JdrApp.modules.ui = {
    
    init() {
      
      // Set up search functionality
      this.setupSearch();
      
      // Set up modal handlers
      this.setupModals();
      
      // Set up content creation handlers
      this.setupContentCreation();
      
      // Set up resource tools
      this.setupResourceTools();
      
      // Set up responsive handlers
      this.setupResponsive();
    },

    setupSearch() {
      const searchInput = JdrApp.utils.dom.$('#search');
      const clearButton = JdrApp.utils.dom.$('#clear');
      
      if (searchInput) {
        // Search as you type
        JdrApp.utils.events.register('input', '#search', (e) => {
          this.performSearch(e.target.value);
        });
        
        // Enter key
        JdrApp.utils.events.register('keydown', '#search', (e) => {
          if (e.key === 'Enter') {
            this.performSearch(e.target.value);
          }
        });
      }
      
      if (clearButton) {
        JdrApp.utils.events.register('click', '#clear', () => {
          if (searchInput) {
            searchInput.value = '';
            this.performSearch('');
          }
        });
      }
    },

    performSearch(query) {
      const normalizedQuery = query.toLowerCase().trim();
      
      if (!normalizedQuery) {
        // Show all content
        JdrApp.utils.dom.$('article, .toc a').forEach(el => {
          el.style.display = '';
        });
        return;
      }

      // Search in TOC
      JdrApp.utils.dom.$('.toc a').forEach(link => {
        const text = link.textContent.toLowerCase();
        const isMatch = text.includes(normalizedQuery);
        link.style.display = isMatch ? '' : 'none';
        
        // Expand parent category if child matches
        if (isMatch) {
          const category = link.closest('.toc-category');
          if (category) {
            category.classList.remove('collapsed');
          }
        }
      });

      // Search in article content
      JdrApp.utils.dom.$('article').forEach(article => {
        const text = article.textContent.toLowerCase();
        const isMatch = text.includes(normalizedQuery);
        
        if (isMatch) {
          // Highlight search terms
          this.highlightSearchTerms(article, normalizedQuery);
        }
      });
    },

    highlightSearchTerms(container, query) {
      // Simple highlighting implementation
      const walker = document.createTreeWalker(
        container,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );

      const textNodes = [];
      let node;
      while (node = walker.nextNode()) {
        if (node.textContent.toLowerCase().includes(query)) {
          textNodes.push(node);
        }
      }

      textNodes.forEach(textNode => {
        const regex = new RegExp(`(${query})`, 'gi');
        const content = textNode.textContent;
        
        if (regex.test(content)) {
          const highlightedContent = content.replace(regex, '<mark>$1</mark>');
          const wrapper = document.createElement('span');
          wrapper.innerHTML = highlightedContent;
          textNode.parentNode.replaceChild(wrapper, textNode);
        }
      });
    },

    setupModals() {
      // Generic modal close handler
      JdrApp.utils.events.register('click', '.modal-overlay, .modal-close', (e) => {
        const modal = e.target.closest('.modal') || document.querySelector('.modal.visible');
        if (modal) {
          this.closeModal(modal);
        }
      });

      // Prevent modal close when clicking inside modal content
      JdrApp.utils.events.register('click', '.modal-content', (e) => {
        e.stopPropagation();
      });

      // Escape key to close modals
      JdrApp.utils.events.register('keydown', 'body', (e) => {
        if (e.key === 'Escape') {
          const openModal = document.querySelector('.modal.visible');
          if (openModal) {
            this.closeModal(openModal);
          }
        }
      });
    },

    openModal(modalId) {
      const modal = JdrApp.utils.dom.$(`#${modalId}`);
      if (modal) {
        modal.classList.add('visible');
        modal.style.display = 'flex';
        
        // Focus first input if available
        const firstInput = modal.querySelector('input, textarea, select');
        if (firstInput) {
          firstInput.focus();
        }
      }
    },

    closeModal(modal) {
      if (modal) {
        modal.classList.remove('visible');
        modal.style.display = 'none';
        
        // Clear form if present
        const form = modal.querySelector('form');
        if (form) {
          form.reset();
        }
      }
    },

    setupContentCreation() {
      // Add spell handlers
      JdrApp.utils.events.register('click', '.spell-add', (e) => {
        const categoryName = e.target.dataset.categoryName;
        this.addNewSpell(categoryName);
      });

      // Delete spell handlers
      JdrApp.utils.events.register('click', '.spell-delete', (e) => {
        const categoryName = e.target.dataset.categoryName;
        const spellName = e.target.dataset.spellName;
        this.deleteSpell(categoryName, spellName);
      });

      // Add don handlers
      JdrApp.utils.events.register('click', '.don-add', (e) => {
        const categoryName = e.target.dataset.categoryName;
        this.addNewDon(categoryName);
      });

      // Delete don handlers
      JdrApp.utils.events.register('click', '.don-delete', (e) => {
        const categoryName = e.target.dataset.categoryName;
        const donName = e.target.dataset.donName;
        this.deleteDon(categoryName, donName);
      });

      // Move don handlers
      JdrApp.utils.events.register('click', '.don-move-up', (e) => {
        const categoryName = e.target.dataset.categoryName;
        const donName = e.target.dataset.donName;
        const index = parseInt(e.target.dataset.donIndex);
        this.moveDon(categoryName, donName, index, -1);
      });

      JdrApp.utils.events.register('click', '.don-move-down', (e) => {
        const categoryName = e.target.dataset.categoryName;
        const donName = e.target.dataset.donName;
        const index = parseInt(e.target.dataset.donIndex);
        this.moveDon(categoryName, donName, index, 1);
      });

      // Add paragraph handlers
      JdrApp.utils.events.register('click', '.add-paragraph-btn', (e) => {
        const target = e.target.dataset.target;
        this.addParagraph(target, e.target);
      });
    },

    addNewSpell(categoryName) {
      const category = JdrApp.utils.data.getSpellCategory(categoryName);
      if (!category) return;

      const newSpell = {
        nom: "Nouveau Sort",
        description: "Lance une boule de Feu sur un adversaire.",
        categorie: categoryName,
        prerequis: "üìã <strong>Pr√©requis:</strong> Niveau 1",
        portee: "üéØ <strong>Port√©e:</strong> 20m",
        tempsIncantation: "‚è∞ <strong>Temps d'incantation:</strong> 1 tour",
        coutMana: "üîµ <strong>Co√ªt mana:</strong> 3",
        resistance: "<strong>Sans effet si:</strong> Esquive.",
        effetNormal: "<strong>Effet:</strong> Inflige 5 d√©gats de <span style=\"color: #e25822; font-weight: bold;\">Feu</span> √† la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les d√©gats de 1.",
        effetCritique: "<strong>Coup Critique:&nbsp;</strong>&nbsp;Double les d√©g√¢ts et enflamme la cible, infligeant 2 d√©gats de Feu au prochain tour du lanceur.",
        effetEchec: "<strong>√âchec Critique:&nbsp;</strong>Le sort inflige ses d√©gats √† un alli√© dans la trajectoire."
      };

      category.sorts.push(newSpell);
      
      // Re-render the category page
      JdrApp.modules.renderer.renderSortCategory(`sorts-${JdrApp.utils.data.sanitizeId(categoryName)}`);
      
      this.showNotification('üîÆ Nouveau sort ajout√©');
    },

    deleteSpell(categoryName, spellName) {
      if (!confirm(`Supprimer le sort "${spellName}" ?`)) return;

      const category = JdrApp.utils.data.getSpellCategory(categoryName);
      if (!category) return;

      const index = category.sorts.findIndex(s => s.nom === spellName);
      if (index !== -1) {
        category.sorts.splice(index, 1);
        
        // Re-render the category page
        JdrApp.modules.renderer.renderSortCategory(`sorts-${JdrApp.utils.data.sanitizeId(categoryName)}`);
        
        this.showNotification('üóë Sort supprim√©');
      }
    },

    addNewDon(categoryName) {
      const category = JdrApp.utils.data.getDonCategory(categoryName);
      if (!category) return;

      const newDon = {
        nom: "Nouveau Don",
        description: "Description du don.",
        prerequis: "Aucun pr√©requis",
        cout: "1 point de don"
      };

      category.dons.push(newDon);
      
      // Re-render the category page
      JdrApp.modules.renderer.renderDonCategory(`dons-${JdrApp.utils.data.sanitizeId(categoryName)}`);
      
      this.showNotification('üéñÔ∏è Nouveau don ajout√©');
    },

    deleteDon(categoryName, donName) {
      if (!confirm(`Supprimer le don "${donName}" ?`)) return;

      const category = JdrApp.utils.data.getDonCategory(categoryName);
      if (!category) return;

      const index = category.dons.findIndex(d => d.nom === donName);
      if (index !== -1) {
        category.dons.splice(index, 1);
        
        // Re-render the category page
        JdrApp.modules.renderer.renderDonCategory(`dons-${JdrApp.utils.data.sanitizeId(categoryName)}`);
        
        this.showNotification('üóë Don supprim√©');
      }
    },

    moveDon(categoryName, donName, currentIndex, direction) {
      const category = JdrApp.utils.data.getDonCategory(categoryName);
      if (!category) return;

      const newIndex = currentIndex + direction;
      if (newIndex < 0 || newIndex >= category.dons.length) return;

      // Swap positions
      const temp = category.dons[currentIndex];
      category.dons[currentIndex] = category.dons[newIndex];
      category.dons[newIndex] = temp;
      
      // Re-render the category page
      JdrApp.modules.renderer.renderDonCategory(`dons-${JdrApp.utils.data.sanitizeId(categoryName)}`);
      
      this.showNotification(`üîÑ Don ${direction > 0 ? 'descendu' : 'mont√©'}`);
    },

    addParagraph(target, button) {
      const newParagraph = JdrApp.utils.dom.create('p', 'editable', 'Nouveau paragraphe.', {
        'data-edit-type': 'custom',
        'data-edit-section': target
      });
      
      button.parentNode.insertBefore(newParagraph, button);
      
      // Make it immediately editable
      if (JdrApp.modules.editor.isDevMode) {
        JdrApp.modules.editor.makeEditable(newParagraph);
      }
    },

    setupResourceTools() {
      // Elements button
      JdrApp.utils.events.register('click', '#elementsBtn', () => {
        this.showElementsModal();
      });

      // Icons button
      JdrApp.utils.events.register('click', '#showIcons', () => {
        this.showIconsModal();
      });
    },

    showElementsModal() {
      // Create elements modal if it doesn't exist
      let modal = JdrApp.utils.dom.$('#elementsModal');
      if (!modal) {
        modal = this.createElementsModal();
        document.body.appendChild(modal);
      }
      
      this.openModal('elementsModal');
    },

    createElementsModal() {
      const elements = [
        { name: 'Feu', color: '#ff6b35', icon: 'üî•' },
        { name: 'Air', color: '#87ceeb', icon: 'üí®' },
        { name: 'Eau', color: '#4682b4', icon: 'üíß' },
        { name: 'Terre', color: '#8b7355', icon: 'üåç' },
        { name: 'Divin', color: '#ffd700', icon: '‚ú®' },
        { name: 'Mal√©fique', color: '#8b008b', icon: 'üíÄ' }
      ];

      const elementsHTML = elements.map(element => `
        <div class="element-item" data-element="${element.name}" data-color="${element.color}">
          <div class="element-icon" style="background: ${element.color};">${element.icon}</div>
          <div class="element-name">${element.name}</div>
          <div class="copy-indicator">Copi√©!</div>
        </div>
      `).join('');

      const modal = JdrApp.utils.dom.create('div', 'modal elements-modal', `
        <div class="modal-content elements-modal-content">
          <h3>üé® √âl√©ments</h3>
          <p>Cliquez sur un √©l√©ment pour copier sa balise HTML color√©e.</p>
          <div class="elements-list">
            ${elementsHTML}
          </div>
          <button class="modal-close btn">Fermer</button>
        </div>
      `, { id: 'elementsModal' });

      // Add click handlers for elements
      modal.addEventListener('click', (e) => {
        const elementItem = e.target.closest('.element-item');
        if (elementItem) {
          const elementName = elementItem.dataset.element;
          const color = elementItem.dataset.color;
          const html = `<span style="color: ${color}; font-weight: bold;">${elementName}</span>`;
          
          this.copyToClipboard(html);
          
          // Show copied indicator
          elementItem.classList.add('copied');
          setTimeout(() => {
            elementItem.classList.remove('copied');
          }, 1000);
        }
      });

      return modal;
    },

    showIconsModal() {
      this.showNotification('üî• Fonctionnalit√© des ic√¥nes √† impl√©menter', 'info');
    },

    copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        this.showNotification('üìã Copi√© dans le presse-papiers', 'success');
      }).catch(() => {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        this.showNotification('üìã Copi√© dans le presse-papiers', 'success');
      });
    },

    setupResponsive() {
      // Menu toggle for mobile
      JdrApp.utils.events.register('click', '#menuToggle', () => {
        const sidebar = JdrApp.utils.dom.$('#sidebar');
        const backdrop = JdrApp.utils.dom.$('#backdrop');
        
        if (sidebar && backdrop) {
          sidebar.classList.toggle('mobile-open');
          backdrop.hidden = !sidebar.classList.contains('mobile-open');
        }
      });

      // Close sidebar when clicking backdrop
      JdrApp.utils.events.register('click', '#backdrop', () => {
        const sidebar = JdrApp.utils.dom.$('#sidebar');
        const backdrop = JdrApp.utils.dom.$('#backdrop');
        
        if (sidebar && backdrop) {
          sidebar.classList.remove('mobile-open');
          backdrop.hidden = true;
        }
      });
    },

    showNotification(message, type = 'info') {
      // Reuse the storage module's notification system
      if (JdrApp.modules.storage.showNotification) {
        JdrApp.modules.storage.showNotification(message, type);
      } else {
        // Fallback: simple console log
      }
    }
  };

})();

</script>
</body>
</html>