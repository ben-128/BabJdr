<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta name="referrer" content="no-referrer-when-downgrade">
<!-- Generated on 2025-08-26T20:31:19.079Z by JdrBab Build System -->
<title>JDR‑BAB — Livret de règles</title>
<meta content="Livret web multipages des règles JDR‑BAB, thème parchemin, illustrations par catégorie/classe/sous‑classe, export HTML autonome." name="description">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&amp;family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600&amp;display=swap" rel="stylesheet">
<style>
/* —— Thème Heroic Fantasy - Enhanced Parchment —— */
:root{
  --paper:#f4f0e6;        /* parchemin ancien */
  --paper-ink:#2c1810;    /* encre noire profonde */
  --paper-muted:#8b6f47;  /* bronze ancien */
  --accent:#d4af37;       /* accent doré pour backgrounds */
  --accent-ink:#4a2c17;   /* titres sombres */
  --rule:#d4c4a8;         /* bordures dorées */
  --card:#faf6ee;         /* cartes parchemin */
  --link:#8b4513;         /* liens cuivre */
  --gold:#d4af37;         /* or */
  --bronze:#cd7f32;       /* bronze */
  --shadow:0 8px 32px rgba(0,0,0,.15), 0 2px 8px rgba(139,69,19,.1);
  --card-shadow:0 6px 20px rgba(0,0,0,.1), 0 2px 6px rgba(139,69,19,.08);
  --image-border:3px solid #8b4513;
  --image-shadow:0 4px 12px rgba(0,0,0,.2), inset 0 1px 2px rgba(212,175,55,.3);
  
  /* Enhanced Parchment Textures */
  --parchment-texture: 
    radial-gradient(circle at 20% 80%, rgba(139,69,19,.03) 0%, transparent 50%),
    radial-gradient(circle at 80% 20%, rgba(212,175,55,.02) 0%, transparent 50%),
    radial-gradient(circle at 40% 40%, rgba(139,69,19,.01) 0%, transparent 30%),
    linear-gradient(45deg, rgba(139,69,19,.005) 25%, transparent 25%),
    linear-gradient(-45deg, rgba(212,175,55,.005) 25%, transparent 25%);
    
  --parchment-border:
    linear-gradient(45deg, 
      rgba(139,69,19,.8) 0%, 
      rgba(212,175,55,.6) 25%, 
      rgba(139,69,19,.4) 50%, 
      rgba(212,175,55,.6) 75%, 
      rgba(139,69,19,.8) 100%);
      
  --aged-paper: 
    radial-gradient(ellipse at top left, rgba(139,69,19,.04), transparent 60%),
    radial-gradient(ellipse at top right, rgba(212,175,55,.03), transparent 60%),
    radial-gradient(ellipse at bottom left, rgba(139,69,19,.02), transparent 60%),
    radial-gradient(ellipse at bottom right, rgba(212,175,55,.025), transparent 60%);
  
  /* Enhanced Element Colors System - Improved Contrast & Accessibility */
  --feu:#e63946; --feu-bg:rgba(230,57,70,.12); --feu-border:rgba(230,57,70,.4);
  --air:#457b9d; --air-bg:rgba(69,123,157,.12); --air-border:rgba(69,123,157,.4);
  --eau:#1d3557; --eau-bg:rgba(29,53,87,.12); --eau-border:rgba(29,53,87,.4);
  --terre:#6f4e37; --terre-bg:rgba(111,78,55,.12); --terre-border:rgba(111,78,55,.4);
  --divin:#f1c40f; --divin-bg:rgba(241,196,15,.12); --divin-border:rgba(241,196,15,.4);
  --malefique:#6a2c70; --malefique-bg:rgba(106,44,112,.12); --malefique-border:rgba(106,44,112,.4);
  
  /* Spacing system */
  --space-xs:4px; --space-sm:6px; --space-md:8px; --space-lg:12px; --space-xl:16px; --space-2xl:24px;
  
  /* Common transitions */
  --transition-fast:.2s ease; --transition-normal:.3s ease; --transition-slow:.5s ease;
}

/* Enhanced Accessibility & High Contrast Support */
@media (prefers-color-scheme: dark) { 
  :root{ 
    --paper:#f4f0e6; /* Keep light theme for fantasy aesthetic */
    --card:#faf6ee; 
    --paper-ink:#2c1810; 
  } 
}

@media (prefers-contrast: high) {
  :root {
    --paper-ink: #000000;
    --accent-ink: #1a0d08;
    --bronze: #8b4513;
    --gold: #b8860b;
    --rule: #8b4513;
  }
  
  .card, .card-base {
    border-width: 3px;
  }
  
  .btn-base {
    border-width: 3px;
  }
}

/* Base styles */
html,body{height:100%}
body{
  margin:0;
  background:
    radial-gradient(1600px 800px at 50% -10%, rgba(212,175,55,.08), transparent 45%),
    radial-gradient(1400px 700px at 120% 10%, rgba(139,69,19,.06), transparent 40%),
    radial-gradient(800px 400px at 20% 80%, rgba(205,127,50,.04), transparent 30%),
    repeating-linear-gradient(90deg, rgba(74,44,23,.02) 0 1px, transparent 1px 3px),
    repeating-linear-gradient(0deg, rgba(139,69,19,.015) 0 1px, transparent 1px 4px),
    var(--paper);
  color:var(--paper-ink); 
  font:17px/1.65 "Source Serif Pro", "Cinzel", ui-serif, Georgia, Cambria, "Times New Roman", Times, serif; 
  -webkit-font-smoothing:antialiased; 
  text-rendering:optimizeLegibility;
}

/* ═══════════════════════════════════════════════════════════════════════════════════════
   🎨 ENHANCED TYPOGRAPHY SYSTEM - Centered & Harmonized
   ═══════════════════════════════════════════════════════════════════════════════════════ */

/* Link Styling */
a {
  color: var(--link);
  text-decoration: none;
  transition: all var(--transition-fast);
  position: relative;
}

a:hover {
  text-decoration: underline;
  color: var(--gold);
  text-shadow: 0 1px 3px rgba(212,175,55,0.3);
}

/* Text Emphasis */
strong, b {
  font-weight: 700;
  font-family: "Source Serif Pro", serif;
  color: var(--accent-ink);
  text-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

em, i {
  font-style: italic;
  font-weight: 400;
  color: var(--bronze);
}

/* Enhanced Headings System */
h1, h2, h3, h4, h5, h6 {
  font-family: "Cinzel", "Trajan Pro", ui-serif, Georgia, Cambria, Times, serif;
  color: var(--accent-ink);
  text-shadow: 2px 2px 4px rgba(0,0,0,.1);
  text-align: center;
  margin: 1.5rem auto 1rem;
  position: relative;
  line-height: 1.2;
  letter-spacing: 0.02em;
}

/* Main Title */
h1 {
  font-size: clamp(28px, 4.5vw, 48px);
  letter-spacing: 0.05em;
  margin: 2rem auto 1.5rem;
  font-weight: 700;
  background: linear-gradient(135deg, var(--gold), var(--bronze), var(--gold));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-shadow: none;
  position: relative;
}

h1::before {
  content: '◆';
  position: absolute;
  left: -20px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--gold);
  font-size: 0.6em;
  opacity: 0.7;
}

h1::after {
  content: '◆';
  position: absolute;
  right: -20px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--gold);
  font-size: 0.6em;
  opacity: 0.7;
}

/* Section Headings */
h2 {
  font-size: clamp(22px, 3.2vw, 32px);
  margin: 1.8rem auto 1.2rem;
  font-weight: 600;
  color: var(--bronze);
  position: relative;
}

h2::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 80px;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--bronze), transparent);
  opacity: 0.8;
}

/* Subsection Headings */
h3 {
  font-size: clamp(18px, 2.4vw, 26px);
  margin: 1.5rem auto 1rem;
  font-weight: 500;
  color: var(--accent-ink);
  position: relative;
}

h3::before {
  content: '※';
  position: absolute;
  left: -15px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--bronze);
  font-size: 0.8em;
  opacity: 0.6;
}

h3::after {
  content: '※';
  position: absolute;
  right: -15px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--bronze);
  font-size: 0.8em;
  opacity: 0.6;
}

/* Smaller Headings */
h4 {
  font-size: clamp(16px, 2vw, 20px);
  margin: 1.2rem auto 0.8rem;
  font-weight: 500;
  color: var(--paper-muted);
}

h5, h6 {
  font-size: clamp(14px, 1.8vw, 18px);
  margin: 1rem auto 0.6rem;
  font-weight: 500;
  color: var(--paper-muted);
}

/* Text Utilities */
.muted {
  color: var(--paper-muted);
  font-style: italic;
}

.lead {
  font-size: 18px;
  line-height: 1.6;
  text-align: center;
  margin: 1.5rem auto;
  color: var(--accent-ink);
  font-weight: 400;
}

/* Enhanced Separator Rule */
.rule {
  height: 3px;
  background: linear-gradient(90deg, 
    transparent, 
    var(--bronze), 
    var(--gold), 
    var(--bronze), 
    transparent);
  margin: 2rem auto;
  border-radius: 2px;
  opacity: 0.8;
  position: relative;
}

.rule::before {
  content: '❋';
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  background: var(--paper);
  color: var(--gold);
  padding: 0 8px;
  font-size: 14px;
}

/* Decorative Separators */
.separator-ornate {
  text-align: center;
  margin: 2.5rem auto;
  font-size: 1.5em;
  color: var(--gold);
  opacity: 0.7;
}

.separator-ornate::before {
  content: '◆ ❋ ◆';
}

/* Centered Text Blocks */
.text-center {
  text-align: center;
}

.text-center-block {
  text-align: center;
  margin: 1.5rem auto;
  max-width: 800px;
}

/* Mobile Typography Adjustments */
@media (max-width: 480px) {
  h1::before, h1::after,
  h3::before, h3::after {
    display: none;
  }
  
  .rule::before {
    font-size: 12px;
    padding: 0 6px;
  }
  
  .lead {
    font-size: 16px;
    margin: 1rem auto;
  }
}
/* === UTILITY CLASSES === */

/* Spacing utilities */
.m-0{margin:0} .m-1{margin:var(--space-xs)} .m-2{margin:var(--space-md)} .m-3{margin:var(--space-lg)} .m-4{margin:var(--space-xl)}
.mt-0{margin-top:0} .mt-1{margin-top:var(--space-xs)} .mt-2{margin-top:var(--space-md)} .mt-3{margin-top:var(--space-lg)}
.mb-0{margin-bottom:0} .mb-1{margin-bottom:var(--space-xs)} .mb-2{margin-bottom:var(--space-md)} .mb-3{margin-bottom:var(--space-lg)}
.p-0{padding:0} .p-1{padding:var(--space-xs)} .p-2{padding:var(--space-md)} .p-3{padding:var(--space-lg)} .p-4{padding:var(--space-xl)}

/* Flex utilities */
.flex{display:flex} .flex-col{flex-direction:column} .flex-wrap{flex-wrap:wrap}
.items-center{align-items:center} .items-start{align-items:flex-start} .items-end{align-items:flex-end}
.justify-center{justify-content:center} .justify-start{justify-content:flex-start} .justify-end{justify-content:flex-end}
.gap-1{gap:var(--space-xs)} .gap-2{gap:var(--space-md)} .gap-3{gap:var(--space-lg)}

/* Element color utilities */
.text-feu{color:var(--feu)} .text-air{color:var(--air)} .text-eau{color:var(--eau)} .text-terre{color:var(--terre)} .text-divin{color:var(--divin)} .text-malefique{color:var(--malefique)}
.bg-feu{background:var(--feu-bg);border-color:var(--feu-border)} .bg-air{background:var(--air-bg);border-color:var(--air-border)}
.bg-eau{background:var(--eau-bg);border-color:var(--eau-border)} .bg-terre{background:var(--terre-bg);border-color:var(--terre-border)}
.bg-divin{background:var(--divin-bg);border-color:var(--divin-border)} .bg-malefique{background:var(--malefique-bg);border-color:var(--malefique-border)}

/* Grid utilities */
.grid{display:grid;gap:var(--space-lg)}
.cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}
.cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}
@media (max-width: 900px){ .cols-3{grid-template-columns:1fr} }
@media (max-width: 768px){ .cols-2{grid-template-columns:1fr !important} }

/* Misc utilities */
.subclass-stack{display:flex;flex-direction:column;gap:var(--space-lg)}
.chip{font-size:14px;border:2px solid var(--rule);border-radius:999px;padding:6px 12px;background:rgba(155,107,47,.12);font-weight:600;box-shadow:0 2px 6px rgba(0,0,0,.1)}
.chips{display:flex;flex-wrap:wrap;gap:8px;justify-content:center}
/* ═══════════════════════════════════════════════════════════════════════════════════════
   🏗️ LAYOUT SYSTEM - Enhanced Responsive Design
   ═══════════════════════════════════════════════════════════════════════════════════════ */

/* Main Shell Layout */
.shell {
  display: grid;
  grid-template-rows: 1fr auto;
  min-height: 100svh;
  position: relative;
}

/* Main Content Area - Enhanced Parchment Background */
.page {
  position: relative;
  min-height: 100vh;
  padding: 18px 18px 18px 368px;
  transition: padding var(--transition-normal);
  background: 
    var(--parchment-texture),
    var(--aged-paper),
    var(--paper);
}

/* Content Container - Enhanced Centering */
#views {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 var(--space-lg);
  animation: fadeInUp 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

/* Mobile Responsiveness */
@media (max-width: 980px) { 
  .page {
    padding: 12px;
    background: var(--paper);
  }
  
  #views {
    padding: 0 var(--space-md);
    max-width: 100%;
  }
}

/* ─────────────────────────── Enhanced Sidebar Navigation ─────────────────────────── */
.sidebar {
  position: fixed;
  top: 0;
  left: 0;
  width: 350px;
  height: 100vh;
  overflow-y: auto;
  overflow-x: hidden;
  z-index: 100;
  background: 
    var(--parchment-texture),
    linear-gradient(180deg, var(--paper), rgba(244,240,230,0.95)),
    var(--aged-paper);
  backdrop-filter: blur(8px);
  border-right: 4px solid transparent;
  border-image: var(--parchment-border) 1;
  box-shadow: 
    4px 0 20px rgba(0,0,0,0.08),
    inset -1px 0 0 rgba(212,175,55,0.1);
  transition: transform var(--transition-normal);
}

.sidebar::before {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  width: 2px;
  height: 100%;
  background: linear-gradient(180deg, 
    var(--gold) 0%, 
    var(--bronze) 50%, 
    var(--gold) 100%);
  opacity: 0.6;
}

/* Mobile Sidebar with Collapsible Navigation */
@media (max-width: 980px) { 
  .sidebar {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: auto;
    max-height: 80vh;
    background: 
      linear-gradient(135deg, var(--card), rgba(244,240,230,0.98)),
      radial-gradient(circle at 50% 30%, rgba(212,175,55,0.05), transparent 70%);
    border-right: none;
    border-bottom: 3px solid var(--rule);
    backdrop-filter: blur(8px);
    box-shadow: 
      0 8px 32px rgba(0,0,0,0.15),
      inset 0 -1px 0 rgba(212,175,55,0.1);
    transform: translateY(-100%);
    transition: transform var(--transition-normal);
    z-index: 200;
    overflow-y: auto;
  }
  
  .sidebar.mobile-open {
    transform: translateY(0);
  }
  
  /* Adjust page layout for mobile */
  .page {
    padding: 80px 12px 12px 12px; /* Top padding for mobile nav button */
  }
  
  .sidebar::before {
    display: none;
  }
  
  /* Mobile Navigation Toggle Button */
  .mobile-nav-toggle {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 300;
    background: linear-gradient(135deg, var(--gold), var(--bronze));
    color: white;
    border: 2px solid var(--rule);
    border-radius: 12px;
    padding: 12px 16px;
    cursor: pointer;
    box-shadow: 
      0 6px 20px rgba(0,0,0,.15),
      inset 0 1px 0 rgba(255,255,255,.2);
    transition: all var(--transition-fast);
    font-family: 'Cinzel', serif;
    font-weight: 600;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 44px;
    min-height: 44px;
    justify-content: center;
  }
  
  .mobile-nav-toggle:hover {
    transform: scale(1.05);
    box-shadow: 
      0 8px 25px rgba(0,0,0,.2),
      inset 0 1px 0 rgba(255,255,255,.3);
  }
  
  .mobile-nav-toggle:active {
    transform: scale(0.98);
  }
  
  .mobile-nav-toggle .icon {
    font-size: 16px;
    transition: transform var(--transition-fast);
  }
  
  .mobile-nav-toggle.open .icon {
    transform: rotate(180deg);
  }
  
  /* Hide toggle on desktop */
  @media (min-width: 981px) {
    .mobile-nav-toggle {
      display: none;
    }
  }
}
/* ─────────────────────────── Enhanced Panel System ─────────────────────────── */
.panel {
  background: 
    linear-gradient(135deg, var(--card), rgba(250,246,238,0.9)),
    radial-gradient(circle at 20% 30%, rgba(212,175,55,0.03), transparent 70%);
  border: 2px solid var(--rule);
  border-radius: 18px;
  box-shadow: 
    var(--card-shadow),
    inset 0 1px 0 rgba(255,255,255,0.1);
  padding: 18px;
  position: relative;
  overflow: hidden;
  margin: 12px;
  transition: all var(--transition-normal);
  backdrop-filter: blur(2px);
}

.panel::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, 
    transparent, 
    var(--gold), 
    var(--bronze), 
    var(--gold), 
    transparent);
  opacity: .6;
}

.panel::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--bronze), transparent);
  opacity: .3;
}

.panel:hover {
  transform: translateY(-1px);
  box-shadow: 
    0 8px 32px rgba(0,0,0,.12),
    0 2px 8px rgba(139,69,19,.1),
    inset 0 1px 0 rgba(255,255,255,.15);
}

/* Table of Contents */
.toc {
  max-height: calc(100vh - 150px);
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-width: thin;
  scrollbar-color: var(--bronze) transparent;
}

.toc::-webkit-scrollbar {
  width: 6px;
}

.toc::-webkit-scrollbar-track {
  background: transparent;
}

.toc::-webkit-scrollbar-thumb {
  background: var(--bronze);
  border-radius: 3px;
}

.toc::-webkit-scrollbar-thumb:hover {
  background: var(--gold);
}

/* ─────────────────────────── Enhanced TOC Styling ─────────────────────────── */
.toc h4 {
  margin: 8px 10px 12px;
  color: var(--bronze);
  text-transform: uppercase;
  font-size: 13px;
  letter-spacing: 0.15em;
  font-weight: 700;
  font-family: 'Cinzel', serif;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
  position: relative;
  padding-bottom: 6px;
  text-align: center;
}

.toc h4::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 2px;
  background: linear-gradient(90deg, var(--bronze), transparent);
  border-radius: 1px;
}

/* Hierarchical TOC Sections */
.toc-section {
  margin-bottom: 8px;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid rgba(139,69,19,0.1);
  background: linear-gradient(135deg, 
    rgba(255,248,220,0.3) 0%, 
    rgba(212,175,55,0.05) 100%);
}

.toc-section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 12px;
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.15) 0%, 
    rgba(139,69,19,0.08) 100%);
  cursor: pointer;
  transition: all var(--transition-normal);
  border-bottom: 1px solid rgba(139,69,19,0.1);
}

.toc-section-header:hover {
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.25) 0%, 
    rgba(139,69,19,0.15) 100%);
  transform: translateY(-1px);
}

.toc-section-title {
  font-weight: 600;
  font-family: 'Cinzel', serif;
  color: var(--bronze);
  font-size: 14px;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
}

.toc-section-toggle {
  color: var(--bronze);
  font-size: 12px;
  transition: transform var(--transition-normal);
  opacity: 0.7;
}

.toc-section.collapsed .toc-section-toggle {
  transform: rotate(-90deg);
}

.toc-section-content {
  padding: 6px;
  max-height: none; /* Permettre l'expansion automatique par défaut */
  overflow: visible;
  transition: max-height var(--transition-normal), opacity var(--transition-normal);
}

.toc-section-content .toc-category {
  /* Remove scroll limits - let everything be visible naturally */
  max-height: none;
  overflow: visible;
}

.toc-section.collapsed .toc-section-content {
  max-height: 0 !important;
  opacity: 0 !important;
  padding-top: 0;
  padding-bottom: 0;
  overflow: hidden;
}
.toc a {
  display: flex;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 12px;
  color: inherit;
  border: 2px solid transparent;
  transition: all var(--transition-normal);
  position: relative;
  overflow: hidden;
  font-weight: 500;
  margin: 2px 0;
  backdrop-filter: blur(1px);
}
.toc a::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, 
    transparent, 
    rgba(212,175,55,.2), 
    rgba(139,69,19,.1), 
    transparent);
  transition: left 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  z-index: 0;
}
.toc a:hover {
  transform: translateX(6px) scale(1.02);
  background: 
    linear-gradient(135deg, rgba(212,175,55,.12), rgba(139,69,19,.08));
  border-color: rgba(139,69,19,.4);
  box-shadow: 
    0 6px 20px rgba(139,69,19,.2),
    inset 0 1px 3px rgba(212,175,55,.25),
    inset 0 -1px 1px rgba(139,69,19,.1);
  color: var(--accent-ink);
}

.toc a:hover::before {
  left: 100%;
}
.toc a > *{position:relative; z-index:1}
.toc a.active {
  background: linear-gradient(135deg, 
    rgba(212,175,55,.18), 
    rgba(139,69,19,.12));
  border-color: var(--gold);
  box-shadow: 
    inset 0 2px 6px rgba(212,175,55,.3),
    inset 0 -1px 2px rgba(139,69,19,.2),
    0 2px 8px rgba(139,69,19,.1);
  transform: translateX(4px) scale(1.01);
  color: var(--accent-ink);
  font-weight: 600;
}
.toc-category{margin:0}
.toc-category > a{position:relative; cursor:pointer}
.toc-category > a::after{content:'▼'; position:absolute; right:8px; top:50%; transform:translateY(-50%); 
                         font-size:10px; transition:transform .3s ease; color:var(--bronze)}
.toc-category.collapsed > a::after{transform:translateY(-50%) rotate(-90deg)}
.toc-sub{margin-left:24px;border-left:2px solid var(--rule);padding-left:8px; 
         overflow:hidden; transition:all .3s ease}
.toc-category.collapsed .toc-sub{max-height:0; opacity:0; padding-top:0; padding-bottom:0; margin-top:0; margin-bottom:0}
.toc-category:not(.collapsed) .toc-sub{max-height: none; opacity:1}
.toc-sub a{font-size:14px;padding:6px 8px; margin-left:4px}
.toc-sub a:hover{transform:translateX(6px); margin-left:0}

/* Outils latéraux */
.tools{display:flex;gap:var(--space-md);flex-wrap:wrap;margin:var(--space-md) 0}

/* Article and section layout */
article{display:none}
article.active{display:block}
section{background:var(--card);border:1px solid var(--rule);border-radius:14px;box-shadow:var(--shadow);padding:18px;margin:0 0 14px}

/* Footer */
footer{padding:24px;text-align:center;color:var(--paper-muted)}

/* Print styles */
@media print{ 
  .sidebar, .tools{display:none} 
  .page{grid-template-columns:1fr;padding:0} 
  section{break-inside:avoid;box-shadow:none} 
}

/* ─────────────────────────── Enhanced Mobile & Tablet Responsiveness ─────────────────────────── */

/* Tablet Landscape (1024px and below) */
@media (max-width: 1024px) {
  .sidebar {
    width: 320px;
  }
  
  .page {
    padding-left: 340px;
  }
  
  #views {
    max-width: 100%;
    padding: 0 var(--space-md);
  }
}

/* Tablet Portrait (768px and below) */
@media (max-width: 768px) {
  .illus .thumb { 
    width: 100%; 
    max-width: 280px; 
    height: auto; 
  }
  
  .card, .card-base {
    margin: 1rem 0;
    padding: 16px;
  }
  
  .btn-base {
    padding: var(--space-sm) var(--space-md);
    font-size: 0.9em;
  }
  
  .filter-chips {
    gap: 0.5rem;
  }
  
  .filter-chip {
    padding: 6px 12px;
    font-size: 0.85em;
  }
}

/* Mobile (480px and below) - Standalone Version Optimized */
@media (max-width: 480px) {
  .page {
    padding: 8px;
  }
  
  #views {
    padding: 0 var(--space-sm);
  }
  
  .panel {
    margin: 8px;
    padding: 12px;
    border-radius: 12px;
  }
  
  .card, .card-base {
    padding: 12px;
    margin: 0.8rem 0;
    border-radius: 12px;
  }
  
  .spell-title {
    font-size: clamp(1rem, 3vw, 1.2rem) !important;
    margin: 0 0 0.8rem 0 !important;
  }
  
  .btn-base {
    padding: var(--space-sm);
    font-size: 0.85em;
    gap: var(--space-sm);
  }
  
  .filter-chips {
    gap: 0.4rem;
  }
  
  .filter-chip {
    padding: 4px 8px;
    font-size: 0.8em;
    border-radius: 16px;
  }
  
  /* Mobile-optimized images */
  .illus img {
    max-width: 100% !important;
    width: auto !important;
    height: auto !important;
  }
  
  .illus-spell img,
  .card .illus img {
    max-width: 240px !important;
    max-height: 180px !important;
  }
  
  /* Mobile TOC enhancements */
  .toc a {
    padding: 8px 10px;
    font-size: 0.9em;
  }
  
  .toc-sub a {
    padding: 6px 8px;
    font-size: 0.85em;
  }
  
  /* Mobile search optimizations */
  .searchbar {
    flex-direction: column;
    gap: var(--space-sm);
  }
  
  .searchbar input {
    width: 100%;
    font-size: 16px; /* Prevents zoom on iOS */
  }
  
  .search-results-grid {
    grid-template-columns: 1fr;
    gap: var(--space-md);
  }
  
  .search-result-card {
    min-height: 120px;
    padding: var(--space-md);
  }
}
/* ═══════════════════════════════════════════════════════════════════════════════════════
   🎨 COMPONENT SYSTEM - Modern Heroic Fantasy Design
   ═══════════════════════════════════════════════════════════════════════════════════════ */

/* ─────────────────────────── Typography Components ─────────────────────────── */
.spell-title {
  font-family: "Cinzel", serif !important;
  font-size: clamp(1.2rem, 2.5vw, 1.4rem) !important;
  background: linear-gradient(135deg, var(--gold), var(--bronze), var(--gold)) !important;
  -webkit-background-clip: text !important;
  -webkit-text-fill-color: transparent !important;
  background-clip: text !important;
  font-weight: 600 !important;
  text-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
  letter-spacing: 0.8px !important;
  text-transform: uppercase !important;
  text-align: center !important;
  margin: 0 0 1rem 0 !important;
  position: relative !important;
}

.spell-title::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 60px;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--gold), transparent);
  opacity: 0.7;
}

/* ─────────────────────────── Card System Enhanced - Authentic Parchment ─────────────────────────── */
.card,
.card-base {
  background: 
    var(--parchment-texture),
    var(--aged-paper),
    var(--card);
  border: 3px solid transparent;
  border-image: var(--parchment-border) 1;
  border-radius: 16px;
  box-shadow: 
    0 8px 32px rgba(139,69,19,.2),
    0 2px 8px rgba(139,69,19,.15),
    inset 0 1px 0 rgba(255,255,255,.2),
    inset 0 -1px 0 rgba(139,69,19,.08);
  padding: 20px;
  position: relative;
  overflow: hidden;
  transition: all var(--transition-normal);
  backdrop-filter: blur(1px);
}

.card::before,
.card-base::before {
  content: '';
  position: absolute;
  top: 2px;
  left: 2px;
  right: 2px;
  bottom: 2px;
  border: 1px solid rgba(139,69,19,.15);
  border-radius: 13px;
  pointer-events: none;
}

.card::after,
.card-base::after {
  content: '';
  position: absolute;
  top: 4px;
  left: 4px;
  right: 4px;
  height: 2px;
  background: 
    radial-gradient(ellipse at center, rgba(212,175,55,.3) 0%, transparent 60%),
    linear-gradient(90deg, transparent, rgba(139,69,19,.2), transparent);
  opacity: .6;
}

.card:hover,
.card-base:hover {
  transform: translateY(-3px) scale(1.01);
  box-shadow: 
    0 16px 48px rgba(139,69,19,.25),
    0 6px 16px rgba(139,69,19,.18),
    inset 0 1px 0 rgba(255,255,255,.3),
    inset 0 -1px 0 rgba(139,69,19,.12);
}

/* ─────────────────────────── Button System Enhanced ─────────────────────────── */
.btn-base {
  display: inline-flex;
  gap: var(--space-md);
  align-items: center;
  background: linear-gradient(135deg, var(--card), rgba(244,240,230,0.8));
  border: 2px solid var(--rule);
  border-radius: 12px;
  padding: var(--space-md) var(--space-lg);
  box-shadow: 
    0 4px 16px rgba(0,0,0,.08),
    0 2px 4px rgba(139,69,19,.1),
    inset 0 1px 0 rgba(255,255,255,.2);
  cursor: pointer;
  transition: all var(--transition-fast);
  font-weight: 500;
  font-family: "Source Serif Pro", serif;
  text-transform: capitalize;
  position: relative;
  overflow: hidden;
}

.btn-base::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(212,175,55,.15), transparent);
  transition: left var(--transition-normal);
}

.btn-base:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow: 
    0 8px 32px rgba(0,0,0,.15),
    0 4px 8px rgba(139,69,19,.12),
    inset 0 1px 0 rgba(255,255,255,.3);
  border-color: var(--bronze);
}

.btn-base:hover::before {
  left: 100%;
}

.btn-base:active {
  transform: translateY(-1px) scale(1.01);
  transition: all 0.1s ease;
}

.btn-small {
  padding: var(--space-sm) var(--space-md);
  font-size: 0.9em;
}

/* ─────────────────────────── Card Variants ─────────────────────────── */
.card-enhanced {
  margin: 1.5rem 0;
  animation: cardEntry 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.card.spell-card {
  border-left: 4px solid var(--feu);
  background: linear-gradient(135deg, var(--card), rgba(255,107,53,0.02));
}

.card.don-card {
  border-left: 4px solid var(--bronze);
  background: linear-gradient(135deg, var(--card), rgba(205,127,50,0.02));
}

.card.class-card {
  border-left: 4px solid var(--gold);
  background: linear-gradient(135deg, var(--card), rgba(212,175,55,0.02));
}

@keyframes cardEntry {
  0% {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* ─────────────────────────── Enhanced Tags & Filters ─────────────────────────── */
.tag-filters {
  margin: 1.5rem 0;
  padding: 1.5rem;
  background: 
    linear-gradient(135deg, var(--card), rgba(244,240,230,0.9)),
    radial-gradient(circle at 20% 50%, rgba(212,175,55,0.05), transparent),
    radial-gradient(circle at 80% 50%, rgba(139,69,19,0.03), transparent);
  border: 2px solid var(--rule);
  border-radius: 16px;
  box-shadow: 
    0 4px 20px rgba(0,0,0,.08),
    inset 0 1px 0 rgba(255,255,255,.1);
  position: relative;
  overflow: hidden;
}

.tag-filters::before {
  content: '🏷️ Filtres';
  position: absolute;
  top: -1px;
  left: 20px;
  background: var(--card);
  padding: 4px 12px;
  font-size: 0.85em;
  font-weight: 600;
  color: var(--bronze);
  border: 2px solid var(--rule);
  border-top: none;
  border-radius: 0 0 8px 8px;
  font-family: "Cinzel", serif;
}

.filter-chips {
  display: flex;
  gap: 0.75rem;
  flex-wrap: wrap;
  margin-top: 0.5rem;
}

.filter-chip {
  padding: 8px 16px;
  background: linear-gradient(135deg, var(--bronze), rgba(205,127,50,0.9));
  color: white;
  border-radius: 20px;
  font-size: 0.9em;
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition-fast);
  border: 2px solid transparent;
  box-shadow: 
    0 2px 8px rgba(0,0,0,.1),
    inset 0 1px 0 rgba(255,255,255,.2);
  position: relative;
  overflow: hidden;
}

.filter-chip::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,.2), transparent);
  transition: left var(--transition-fast);
}

.filter-chip:hover {
  background: linear-gradient(135deg, var(--gold), rgba(212,175,55,0.9));
  transform: translateY(-2px) scale(1.05);
  box-shadow: 
    0 6px 20px rgba(0,0,0,.15),
    inset 0 1px 0 rgba(255,255,255,.3);
}

.filter-chip:hover::before {
  left: 100%;
}

.filter-chip.active {
  background: linear-gradient(135deg, var(--accent-ink), rgba(74,44,23,0.9));
  border-color: var(--gold);
  transform: scale(1.02);
  box-shadow: 
    0 4px 16px rgba(0,0,0,.2),
    inset 0 1px 0 rgba(255,255,255,.1);
}

.tag-chip {
  display: inline-block;
  padding: 2px 8px;
  background: var(--bronze);
  color: white;
  border-radius: 8px;
  font-size: 0.8em;
  font-weight: 500;
  margin: 2px;
}

/* Gestionnaire de filtres */
.filter-manager-btn {
  background: var(--bronze) !important;
  color: white !important;
}

.filter-manager-btn:hover {
  background: var(--accent) !important;
}

.modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);z-index:999999;display:flex;align-items:center;justify-content:center}
.modal-base{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);z-index:99999;display:none;align-items:center;justify-content:center}
.modal-base.visible{display:flex}
.modal-content-base{background:var(--card);border:2px solid var(--rule);border-radius:16px;padding:var(--space-2xl);box-shadow:var(--shadow);position:relative}

/* Legacy Cards - Enhanced with Modern Styling */
.card{
  border:2px solid var(--rule);
  border-radius:16px;
  padding:20px;
  background:linear-gradient(145deg, #faf7f0, var(--card), #f8f4e8);
  box-shadow:
    0 8px 32px rgba(0,0,0,.12),
    0 2px 8px rgba(139,69,19,.08),
    inset 0 1px 0 rgba(255,255,255,.1);
  position:relative;
  overflow:hidden;
  transition: all var(--transition-normal);
  backdrop-filter: blur(1px);
}

.card::before{
  content:'';
  position:absolute;
  top:0;
  left:0;
  right:0;
  height:3px;
  background:linear-gradient(90deg, transparent, var(--gold), var(--bronze), var(--gold), transparent);
  opacity:.8;
}

.card::after{
  content:'';
  position:absolute;
  bottom:0;
  left:0;
  right:0;
  height:1px;
  background:linear-gradient(90deg, transparent, var(--bronze), transparent);
  opacity:.5;
}

.card:hover {
  transform: translateY(-2px);
  box-shadow: 
    0 12px 48px rgba(0,0,0,.15),
    0 4px 12px rgba(139,69,19,.12),
    inset 0 1px 0 rgba(255,255,255,.15);
  border-color: var(--gold);
}
.card ul, ul{padding-left:35px !important;margin-left:0 !important}

/* Buttons */
.btn{display:inline-flex;gap:var(--space-md);align-items:center;background:var(--card);border:2px solid var(--rule);border-radius:12px;padding:var(--space-md) var(--space-lg);box-shadow:var(--card-shadow);cursor:pointer;
     transition:var(--transition-fast); font-weight:500}
.btn:hover{transform:translateY(-1px); box-shadow:0 8px 25px rgba(0,0,0,.15); border-color:var(--bronze)}
.btn.small{padding:var(--space-sm) var(--space-md)}

/* Search bar */
.searchbar{display:flex;gap:var(--space-md);align-items:center}
.searchbar input{flex:1 1 auto;max-width:100%;height:38px;font-size:15px;padding:var(--space-md) 10px;border-radius:10px;border:1px solid var(--rule);background:#fff6e8;color:inherit}
.searchbar button{height:38px}

/* Search results */
.search-results-container {
  font-size: 14px;
  line-height: 1.4;
}

.search-results-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: var(--gold);
  color: #4a4a4a;
  font-weight: 500;
  border-bottom: 1px solid var(--bronze);
}

.search-close {
  background: none;
  border: none;
  font-size: 16px;
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 4px;
  transition: background-color 0.2s;
}

.search-close:hover {
  background: rgba(0,0,0,0.1);
}

.search-results-list {
  max-height: 320px;
  overflow-y: auto;
}

.search-result-item {
  padding: 10px 12px;
  border-bottom: 1px solid #f0f0f0;
  cursor: pointer;
  transition: background-color 0.2s;
}

.search-result-item:hover {
  background: #f8f4e8;
}

.search-result-item:last-child {
  border-bottom: none;
}

.search-result-summary {
  font-weight: 500;
  color: #333;
  margin-bottom: 2px;
}

.search-result-category {
  font-size: 12px;
  color: #666;
  opacity: 0.8;
}

.search-no-results {
  padding: 20px;
  text-align: center;
  color: #666;
}

.search-no-results p {
  margin: 0;
  font-style: italic;
}

/* Search results page */
.search-page {
  padding: var(--space-lg);
}

.search-page-header {
  margin-bottom: var(--space-xl);
  text-align: center;
  border-bottom: 2px solid var(--rule);
  padding-bottom: var(--space-lg);
}

.search-page-header h1 {
  color: var(--gold);
  margin-bottom: var(--space-md);
  font-family: var(--font-title);
}

.search-results-count {
  color: #666;
  margin-bottom: var(--space-lg);
  font-style: italic;
}

.search-results-grid {
  display: grid;
  gap: var(--space-lg);
  max-width: 800px;
  margin: 0 auto;
  grid-template-columns: 1fr;
}

.search-result-card {
  cursor: pointer;
  transition: all 0.2s ease;
  border: 2px solid var(--rule);
  background: var(--card);
  padding: var(--space-lg);
  border-radius: 14px;
  box-shadow: var(--card-shadow);
  /* Force visibility */
  display: block !important;
  visibility: visible !important;
  opacity: 1 !important;
  min-height: 150px;
}

.search-result-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(0,0,0,0.15);
  border-color: var(--bronze);
}

.search-result-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: var(--space-md);
}

.search-result-header h3 {
  margin: 0;
  color: var(--bronze);
  font-size: 1.2em;
  text-align: center;
}

.search-result-type {
  background: var(--gold);
  color: #4a4a4a;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 0.8em;
  font-weight: 500;
}

.search-result-content {
  margin-bottom: var(--space-lg);
}

.search-result-summary {
  font-weight: 500;
  margin-bottom: var(--space-md);
  color: #333;
  font-size: 1.05em;
  padding: var(--space-sm);
  background: linear-gradient(90deg, var(--gold), transparent);
  border-radius: 4px;
  opacity: 0.9;
}

.search-result-category {
  font-size: 0.9em;
  color: #666;
  margin-bottom: var(--space-md);
}

.search-result-preview {
  background: #f8f4e8;
  padding: var(--space-md);
  border-radius: 8px;
  border-left: 3px solid var(--bronze);
}

.preview-field {
  margin-bottom: var(--space-sm);
  line-height: 1.4;
  font-size: 0.9em;
  padding: var(--space-sm);
  background: rgba(0,0,0,0.02);
  border-left: 3px solid var(--gold);
  border-radius: 0 4px 4px 0;
}

.preview-field:last-child {
  margin-bottom: 0;
}

.preview-field strong {
  color: var(--bronze);
  font-weight: 600;
}

.search-result-footer {
  text-align: right;
  padding-top: var(--space-md);
  border-top: 1px solid #eee;
}

.search-result-btn {
  background: var(--bronze);
  color: white;
  border-color: var(--bronze);
}

.search-result-btn:hover {
  background: #b8860b;
  border-color: #b8860b;
}

/* Force search results visibility */
.search-page .search-results-grid .search-result-card {
  display: block !important;
  visibility: visible !important;
  opacity: 1 !important;
  height: auto !important;
  min-height: 150px !important;
  background: var(--card) !important;
  border: 2px solid var(--bronze) !important;
  margin-bottom: var(--space-lg) !important;
}

/* ─────────────────────────── Advanced Animations & Transitions ─────────────────────────── */

/* Page Transitions */
@keyframes pageSlideIn {
  0% {
    opacity: 0;
    transform: translateX(30px);
  }
  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes pageSlideInFromTop {
  0% {
    opacity: 0;
    transform: translateY(-20px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Content Animation */
article {
  animation: pageSlideIn 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

article.active {
  animation: pageSlideInFromTop 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

/* Staggered Entry Animation for Lists */
.staggered-entry > * {
  opacity: 0;
  animation: staggeredEntry 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}

.staggered-entry > *:nth-child(1) { animation-delay: 0.1s; }
.staggered-entry > *:nth-child(2) { animation-delay: 0.2s; }
.staggered-entry > *:nth-child(3) { animation-delay: 0.3s; }
.staggered-entry > *:nth-child(4) { animation-delay: 0.4s; }
.staggered-entry > *:nth-child(5) { animation-delay: 0.5s; }
.staggered-entry > *:nth-child(n+6) { animation-delay: 0.6s; }

@keyframes staggeredEntry {
  0% {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* Loading Animation */
@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.loading-shimmer {
  position: relative;
  overflow: hidden;
  background: linear-gradient(90deg, #f0f0f0, #e0e0e0, #f0f0f0);
  animation: shimmer 1.5s infinite linear;
}

.loading-shimmer::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
  animation: shimmer 1.5s infinite linear;
}

/* Floating Elements Animation */
@keyframes float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}

.floating {
  animation: float 3s ease-in-out infinite;
}

.floating:nth-child(2n) {
  animation-delay: 1s;
}

.floating:nth-child(3n) {
  animation-delay: 2s;
}

/* Pulse Animation for Important Elements */
@keyframes pulse {
  0%, 100% { 
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(212, 175, 55, 0.4);
  }
  50% { 
    transform: scale(1.02);
    box-shadow: 0 0 0 10px rgba(212, 175, 55, 0);
  }
}

.pulse-attention {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Text Glow Effect */
@keyframes textGlow {
  0%, 100% {
    text-shadow: 
      0 0 5px rgba(212, 175, 55, 0.2),
      0 0 10px rgba(212, 175, 55, 0.1);
  }
  50% {
    text-shadow: 
      0 0 10px rgba(212, 175, 55, 0.4),
      0 0 20px rgba(212, 175, 55, 0.2),
      0 0 30px rgba(212, 175, 55, 0.1);
  }
}

.text-glow {
  animation: textGlow 3s ease-in-out infinite;
}

/* Enhanced Hover Transitions */
.interactive-element {
  transition: 
    transform var(--transition-fast),
    box-shadow var(--transition-fast),
    background-color var(--transition-fast),
    border-color var(--transition-fast),
    color var(--transition-fast);
}

.interactive-element:hover {
  transform: translateY(-2px) scale(1.02);
}

/* Magical Sparkle Effect */
@keyframes sparkle {
  0%, 100% { opacity: 0; transform: scale(0); }
  50% { opacity: 1; transform: scale(1); }
}

.sparkle-effect::before {
  content: '✨';
  position: absolute;
  top: -5px;
  right: -5px;
  font-size: 0.8em;
  animation: sparkle 2s ease-in-out infinite;
  animation-delay: 0.5s;
}

.sparkle-effect::after {
  content: '⭐';
  position: absolute;
  bottom: -5px;
  left: -5px;
  font-size: 0.6em;
  animation: sparkle 2s ease-in-out infinite;
  animation-delay: 1.5s;
}

/* Smooth Content Transitions */
.content-transition {
  transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

.content-fade-in {
  animation: fadeInUp 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

@keyframes fadeInUp {
  0% {
    opacity: 0;
    transform: translateY(30px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Clean up card styling */

/* Illustrations */
.illus{display:flex;gap:12px;align-items:center;justify-content:center;flex-wrap:wrap;margin:.6rem 0}
.illus img{max-width:100%;height:auto;border-radius:12px; transition:all .3s ease}
.illus img.enlarged{transition:none !important}
.illus .thumb{max-width:500px;max-height:300px;width:auto;height:auto;object-fit:contain}

/* Images avec cadres - système unifié */
.illus-spell, .illus-class, .illus-subclass, .illus-don,
article[data-page="guerrier"] .illus,
article[data-page="mage"] .illus,
article[data-page="pretre"] .illus,
article[data-page="rodeur"] .illus,
article[data-page="enchanteur"] .illus,
.illus[data-illus-key^="class:"],
.illus[data-illus-key^="subclass:"],
.illus[data-illus-key^="spell:"],
.illus[data-illus-key^="sort:"],
.illus[data-illus-key^="spellcategory:"],
.illus[data-illus-key^="don:"] {
  display:flex !important; flex-direction:column !important; align-items:center !important;
  justify-content:center !important; margin:1rem auto !important;
}

.illus-spell img, .illus-class img, .illus-subclass img, .illus-don img,
article[data-page="guerrier"] .illus img,
article[data-page="mage"] .illus img,
article[data-page="pretre"] .illus img,
article[data-page="rodeur"] .illus img,
article[data-page="enchanteur"] .illus img,
.illus[data-illus-key^="class:"] img,
.illus[data-illus-key^="subclass:"] img,
.illus[data-illus-key^="spell:"] img,
.illus[data-illus-key^="sort:"] img,
.illus[data-illus-key^="spellcategory:"] img,
.illus[data-illus-key^="don:"] img {
  border:var(--image-border) !important; 
  box-shadow:var(--image-shadow) !important;
  padding:4px !important; 
  background:transparent !important;
  border-radius:16px !important; 
  max-width:fit-content !important;
  width:auto !important;
  cursor:pointer !important;
}

.illus-spell img:hover, .illus-class img:hover, .illus-subclass img:hover, .illus-don img:hover,
article[data-page="guerrier"] .illus img:hover,
article[data-page="mage"] .illus img:hover,
article[data-page="pretre"] .illus img:hover,
article[data-page="rodeur"] .illus img:hover,
article[data-page="enchanteur"] .illus img:hover,
.illus[data-illus-key^="class:"] img:hover,
.illus[data-illus-key^="subclass:"] img:hover,
.illus[data-illus-key^="spell:"] img:hover,
.illus[data-illus-key^="sort:"] img:hover,
.illus[data-illus-key^="spellcategory:"] img:hover,
.illus[data-illus-key^="don:"] img:hover {
  transform:scale(1.03) !important; 
  box-shadow:var(--image-shadow), 0 8px 25px rgba(139,69,19,.25) !important;
}

/* Variantes de taille d'images */
.illus-small img { max-width: 150px !important; }
.illus-large img { max-width: 400px !important; }

/* Style spécial pour les sorts - cadre doré et taille augmentée */
.illus-spell img,
.card .illus img {
  border: 3px solid var(--gold) !important;
  box-shadow: var(--image-shadow), 0 0 10px rgba(212,175,55,.3) !important;
  max-width: 350px !important;
  max-height: 250px !important;
  object-fit: contain !important;
}

/* Style spécial pour les sous-classes - 2 images centrées et collées */
.subclass-images {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0;
  margin: 0.6rem 0;
}

.subclass-images .illus {
  margin: 0;
  flex: 0 0 auto;
}

.subclass-images .illus img {
  max-width: 400px !important;
  max-height: 300px !important;
  object-fit: contain !important;
  border-radius: 12px 0 0 12px !important;
}

.subclass-images .illus:last-child img {
  border-radius: 0 12px 12px 0 !important;
}

/* Mobile: Stack subclass images vertically */
@media (max-width: 980px) {
  .subclass-images {
    flex-direction: column !important;
    gap: 8px !important;
  }
  
  .subclass-images .illus img {
    border-radius: 12px !important;
    max-width: 100% !important;
    width: 100% !important;
  }
  
  /* Réduire l'espace des cadres d'images sur mobile */
  .illus-spell img, .illus-class img, .illus-subclass img, .illus-don img,
  article[data-page="guerrier"] .illus img,
  article[data-page="mage"] .illus img,
  article[data-page="pretre"] .illus img,
  article[data-page="rodeur"] .illus img,
  article[data-page="enchanteur"] .illus img,
  .illus[data-illus-key^="class:"] img,
  .illus[data-illus-key^="subclass:"] img,
  .illus[data-illus-key^="spell:"] img,
  .illus[data-illus-key^="sort:"] img,
  .illus[data-illus-key^="spellcategory:"] img,
  .illus[data-illus-key^="don:"] img {
    padding: 2px !important; /* Réduire le padding de 4px à 2px */
    border-width: 2px !important; /* Réduire l'épaisseur des bordures */
    max-width: 100% !important;
    width: auto !important;
    height: auto !important;
    object-fit: contain !important;
  }
  
  /* Réduire l'espace entre les images de classe et sous-classe */
  .illus {
    gap: 4px !important; /* Réduire de 12px à 4px */
    margin: 0.3rem 0 !important; /* Réduire les marges */
  }
  
  /* Images de sorts plus compactes sur mobile */
  .illus-spell img,
  .card .illus img {
    max-width: 100% !important;
    max-height: 180px !important; /* Réduire de 250px à 180px */
    border-width: 2px !important; /* Bordure plus fine */
  }
  
  .subclass-images .illus:last-child img {
    border-radius: 12px !important;
  }
}

/* Style spécial pour les titres de sous-classes */
.subclass-title {
  font-size: 2.2rem !important;
  font-weight: 800 !important;
  text-align: center !important;
  margin: 0 0 1.5rem 0 !important;
  color: var(--accent-ink) !important;
  font-family: 'Cinzel', serif !important;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.2) !important;
  letter-spacing: 0.8px !important;
}

/* Style spécial pour les descriptions de sous-classes */
.card[data-section-type="subclass"] .editable[data-edit-section*="description"] {
  text-align: center !important;
  color: var(--paper-ink) !important;
}

.card[data-section-type="subclass"] .editable[data-edit-section*="description"] em,
.card[data-section-type="subclass"] .editable[data-edit-section*="description"] i {
  color: var(--paper-ink) !important;
}

/* ═══════════════════════════════════════════════════════════════════════════════════════
   📱 MOBILE & TOUCH OPTIMIZATION - Final Enhancements
   ═══════════════════════════════════════════════════════════════════════════════════════ */

/* Touch-friendly interactions for mobile devices */
@media (hover: none) and (pointer: coarse) {
  .btn-base, .filter-chip, .toc a, .card {
    min-height: 44px; /* iOS/Android minimum touch target */
    min-width: 44px;
  }
  
  .toc a {
    padding: 12px;
    margin: 4px 0;
  }
  
  .filter-chip {
    padding: 8px 16px;
    margin: 2px;
  }
  
  /* Disable hover effects on touch devices */
  .card:hover, .btn-base:hover, .filter-chip:hover, .toc a:hover {
    transform: none;
    box-shadow: initial;
    background: initial;
    border-color: initial;
  }
  
  /* Add tap feedback instead */
  .btn-base:active, .filter-chip:active, .toc a:active, .card:active {
    transform: scale(0.98);
    transition: transform 0.1s ease;
    opacity: 0.8;
  }
}

/* Reduce animation complexity on low-performance devices */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
  
  .floating, .pulse-attention, .text-glow, 
  .shimmer-effect, .sparkle-effect {
    animation: none !important;
  }
  
  .card, .btn-base, .filter-chip {
    transition: none !important;
  }
}

/* Mobile-specific improvements */
@media (max-width: 480px) {
  /* Improve text readability on small screens */
  body {
    font-size: 16px;
    line-height: 1.6;
    -webkit-text-size-adjust: 100%;
  }
  
  /* Ensure images don't break layout */
  img {
    max-width: 100% !important;
    height: auto !important;
  }
  
  /* Optimize cards for mobile */
  .card, .card-base {
    border-radius: 12px;
    box-shadow: 0 4px 16px rgba(0,0,0,.1);
  }
  
  /* Mobile-friendly buttons */
  .btn-base {
    border-radius: 8px;
    font-size: 16px; /* Prevent iOS zoom */
  }
  
  /* Improve modal sizing on mobile */
  .modal-content-base {
    margin: 10px;
    max-width: calc(100vw - 20px);
    max-height: calc(100vh - 20px);
    overflow-y: auto;
  }
  
  /* Mobile search optimization */
  .searchbar input {
    font-size: 16px; /* Prevents zoom on iOS */
    padding: 12px;
    border-radius: 8px;
  }
}

/* ═══════════════════════════════════════════════════════════════════════════════════════
   📄 SECTION SELECTION MODAL
   ═══════════════════════════════════════════════════════════════════════════════════════ */

.section-selection-modal {
  z-index: 999999 !important;
}

.section-selection-modal .modal-content {
  max-width: 500px;
  padding: 2rem;
}

.sections-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin: 1.5rem 0;
}

.section-option {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  border: 2px solid var(--rule);
  border-radius: 12px;
  cursor: pointer;
  transition: all var(--transition-normal);
  background: var(--card);
}

.section-option:hover {
  border-color: var(--bronze);
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.1) 0%, 
    rgba(139,69,19,0.05) 100%);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(139,69,19,0.15);
}

.section-option.selected {
  border-color: var(--gold);
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.2) 0%, 
    rgba(139,69,19,0.1) 100%);
  box-shadow: 
    0 0 0 2px rgba(212,175,55,0.3),
    0 4px 16px rgba(139,69,19,0.2);
}

.section-icon {
  font-size: 2rem;
  width: 60px;
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 12px;
  background: linear-gradient(135deg, var(--bronze), var(--gold));
  color: white;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
}

.section-info {
  flex: 1;
}

.section-title {
  font-weight: 600;
  font-size: 1.1em;
  color: var(--accent-ink);
  margin-bottom: 0.25rem;
  font-family: 'Cinzel', serif;
}

.section-description {
  color: var(--paper-muted);
  font-size: 0.9em;
  line-height: 1.4;
}

.page-details {
  padding: 1.5rem;
  background: var(--paper-soft);
  border: 1px solid var(--rule);
  border-radius: 12px;
  margin: 1rem 0;
}

.form-group {
  margin-bottom: 1rem;
}

.form-group:last-child {
  margin-bottom: 0;
}

.form-group label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 600;
  color: var(--accent-ink);
}

.form-group input {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid var(--rule);
  border-radius: 8px;
  font-size: 1em;
  background: var(--card);
  color: var(--paper-ink);
}

.form-group input:focus {
  outline: none;
  border-color: var(--bronze);
  box-shadow: 0 0 0 2px rgba(212,175,55,0.2);
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 1rem;
  margin-top: 1.5rem;
}

.btn-primary {
  background: var(--bronze) !important;
  color: white !important;
  border-color: var(--bronze) !important;
}

.btn-primary:hover {
  background: var(--gold) !important;
  border-color: var(--gold) !important;
}

/* Mobile optimization for section selection modal */
@media (max-width: 480px) {
  .section-selection-modal .modal-content {
    padding: 1rem;
    margin: 1rem;
  }
  
  .section-option {
    padding: 0.75rem;
    gap: 0.75rem;
  }
  
  .section-icon {
    width: 48px;
    height: 48px;
    font-size: 1.5rem;
  }
  
  .modal-actions {
    flex-direction: column;
  }
  
  .modal-actions .btn {
    width: 100%;
  }
}
/* Editor and Dev Mode styles */

/* === HIDE ALL EDITING ELEMENTS IN STANDALONE MODE === */
/* Hide all editing elements when dev mode is OFF */

/* ULTRA NUCLEAR OPTION - Hide ALL editing buttons when dev mode is OFF */
/* This rule will override ANY other CSS that might be showing edit buttons */
body.dev-off button[title*="✏️"],
body.dev-off *[class*="edit"],
body.dev-off *[class*="Edit"],

body.dev-off button[data-category-name],
body.dev-off button[data-spell-name], 
body.dev-off button[data-don-name],
body.dev-off button[data-section-name],
body.dev-off button[data-section-type],
body.dev-off .btn:is([class*="add"], [class*="delete"], [class*="remove"], [class*="move"], [class*="edit"]),
body.dev-off .add-paragraph-btn,
body.dev-off .section-delete,
body.dev-off .spell-delete,
body.dev-off .don-delete,
body.dev-off .objet-delete,
body.dev-off .spell-category-delete,
body.dev-off .don-category-delete,
body.dev-off .objet-category-delete,
body.dev-off .don-move-up,
body.dev-off .don-move-down,
body.dev-off .remove-section-btn,
body.dev-off .illus .up,
body.dev-off .illus .rm,
body.dev-off .illus label.up,
body.dev-off .illus button.rm,
body.dev-off .illus label,
body.dev-off .illus input[type="file"],
body.dev-off button[class*="add"]:not(.menu-toggle),
body.dev-off button[class*="delete"],
body.dev-off button[class*="remove"],
body.dev-off button[class*="move"],
body.dev-off button[class*="edit"],
body.dev-off .spell-add,
body.dev-off .don-add,
body.dev-off .objet-add,
body.dev-off .category-add,
body.dev-off .add-*,
body.dev-off [data-bound] .up,
body.dev-off [data-bound] .rm,
body.dev-off [data-bound] label,
body.dev-off [data-bound] button,
body.dev-off .illus[data-bound] .up,
body.dev-off .illus[data-bound] .rm,
body.dev-off .illus[data-bound] label,
body.dev-off .illus[data-bound] button,
body.dev-off .illus[data-bound] input[type="file"],
body.dev-off [data-dev-only],
body.dev-off div[data-dev-only],
body.dev-off .dev-mode-buttons,
body.dev-off .manage-tags-btn,
body.dev-off .add-monster-btn,
body.dev-off button[data-content-type],
body.dev-off .tags-manager-btn,
body.dev-off .filter-manager-btn,
body.dev-off button[class*="tags"],
body.dev-off button[class*="manage"],
/* Specific button selectors */
body.dev-off button[data-category-name],
body.dev-off button[data-spell-name],
body.dev-off button[data-don-name],
body.dev-off button[data-section-name],
body.dev-off button[data-section-type],
/* Input file upload elements */
body.dev-off input[type="file"],
body.dev-off label[for*="file"],
/* Additional specific selectors */
body.dev-off .add-subclass-btn,
body.dev-off .add-new-section,
/* COMPREHENSIVE EDIT BUTTON HIDING */
body.dev-off .edit-btn,
body.dev-off .edit-title-btn,
body.dev-off .edit-paragraph-btn,
body.dev-off .edit-list-btn,
body.dev-off .edit-field-btn,
body.dev-off .edit-effect-btn,
body.dev-off .edit-stats-btn,
body.dev-off .edit-section-btn,
body.dev-off button.edit-btn,
body.dev-off button.edit-title-btn,
body.dev-off button.edit-paragraph-btn,
body.dev-off button.edit-list-btn,
body.dev-off button.edit-field-btn,
body.dev-off button.edit-effect-btn,
body.dev-off button.edit-stats-btn,
body.dev-off button.edit-section-btn,
body.dev-off .editable-section .edit-btn,
body.dev-off .editable-section button[class*="edit"],
body.dev-off .card .edit-btn,
body.dev-off .card button[class*="edit"],
body.dev-off .editable-item .edit-btn,
body.dev-off .editable-item button[class*="edit"],
body.dev-off [data-section-type] .edit-btn,
body.dev-off [data-section-type] button[class*="edit"],
body.dev-off .add-*-btn,
/* Very specific selectors for inline styled buttons */
body.dev-off button[style*="background: #ff6b6b"],
body.dev-off button[style*="background: var(--bronze)"],
body.dev-off button[style*="background: #dc2626"],
body.dev-off button[style*="background: var(--accent)"],
/* Target buttons by text content patterns */
body.dev-off .btn.small[data-category-name],
body.dev-off .btn.small[data-spell-name],  
body.dev-off .btn.small[data-don-name],
body.dev-off .btn.small[data-section-name],
body.dev-off .btn.small[data-don-index],
/* ULTRA FORCÉ - Cacher TOUS les boutons de gestion des tags */
/* ULTRA-SPECIFIC RULES FOR IMAGE UPLOAD BUTTONS */
body.dev-off .illus label.up,
body.dev-off .illus button.rm,
body.dev-off label:contains("📷"),
body.dev-off label:contains("Ajouter"),
body.dev-off button:contains("🗑"),
body.dev-off button:contains("Retirer"),
body.dev-off .card .illus .up,
body.dev-off .card .illus .rm,
body.dev-off .card .illus label,
body.dev-off .card .illus button,
body.dev-off .card [data-bound] .up,
body.dev-off .card [data-bound] .rm,
/* ULTRA-SPECIFIC RULES FOR TAG MANAGER BUTTONS */
body.dev-off button.manage-tags-btn,
body.dev-off button.tags-manager-btn,
body.dev-off .btn.manage-tags-btn,
body.dev-off .btn.tags-manager-btn,
body.dev-off button[data-content-type="monster"],
body.dev-off button[data-content-type="objet"],
body.dev-off .dev-mode-buttons button,
body.dev-off div[data-dev-only] button,
body.dev-off .btn.btn-small.manage-tags-btn,
body.dev-off button.btn.btn-small.manage-tags-btn,
body.dev-off .dev-mode-buttons .manage-tags-btn,
body.dev-off [data-dev-only] .manage-tags-btn,
body.dev-off .add-monster-btn,
body.dev-off .btn.add-monster-btn,
body.dev-off .tags-manager-btn,
body.dev-off .filter-manager-btn,
body.dev-off button[title*="Gérer les tags"],
body.dev-off button[title*="gérer les tags"],
body.dev-off button[onclick*="showTagsManagementModal"],
body.dev-off button[onclick*="showMonsterTagsManagement"],
/* Additional super specific selectors for any possible generated button */
html body.dev-off button.manage-tags-btn,
html body.dev-off button.tags-manager-btn,
html body.dev-off .btn.manage-tags-btn,
html body.dev-off .btn.tags-manager-btn,
/* Text content matching */
body.dev-off button:contains("🏷️ Gérer les tags"),
body.dev-off button:contains("Gérer les tags") {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  position: absolute !important;
  left: -9999px !important;
  width: 0 !important;
  height: 0 !important;
  overflow: hidden !important;
  pointer-events: none !important;
}

/* Element selectors for spells and monsters - Solution ultra-forcée */
.spell-element-selector,
.spell-element-selector *,
div.spell-element-selector,
.card .spell-element-selector,
.monster-element-selector,
.monster-element-selector *,
div.monster-element-selector,
.card .monster-element-selector {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  position: absolute !important;
  left: -9999px !important;
  width: 0 !important;
  height: 0 !important;
  overflow: hidden !important;
}

/* Modal buttons should always be visible */
dialog .delete-monster-tag-btn,
dialog .btn,
dialog button {
  display: inline-flex !important;
  visibility: visible !important;
  opacity: 1 !important;
  pointer-events: auto !important;
  position: static !important;
  left: auto !important;
  width: auto !important;
  height: auto !important;
  overflow: visible !important;
}

/* SEULEMENT visible en mode dev */
body.dev-on .spell-element-selector,
body.dev-on .spell-element-selector *,
body.dev-on div.spell-element-selector,
body.dev-on .card .spell-element-selector,
body.dev-on .monster-element-selector,
body.dev-on .monster-element-selector *,
body.dev-on div.monster-element-selector,
body.dev-on .card .monster-element-selector {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  position: static !important;
  left: auto !important;
  width: auto !important;
  height: auto !important;
  overflow: visible !important;
}

body.dev-off .spell-element-display,
body.dev-off .monster-element-display {
  display: block !important;
}

body.dev-on .spell-element-display,
body.dev-on .monster-element-display {
  display: none !important;
}

/* COMPREHENSIVE SHOW RULES FOR DEV MODE - High specificity to override dev-off hiding */
body.dev-on .edit-btn,
body.dev-on button.edit-btn,
body.dev-on button[class*="edit"],
body.dev-on button[class*="add"]:not(.menu-toggle),
body.dev-on button[class*="delete"],
body.dev-on button[class*="remove"],
body.dev-on button[class*="move"],
body.dev-on .section-delete,
body.dev-on .spell-delete,
body.dev-on .don-delete,
body.dev-on .add-subclass-btn,
body.dev-on .delete-subclass-btn,
body.dev-on .add-paragraph-btn,
body.dev-on .remove-section-btn,
body.dev-on .illus .up,
body.dev-on .illus .rm,
body.dev-on .illus label,
body.dev-on .illus input[type="file"],
body.dev-on button[data-category-name],
body.dev-on button[data-spell-name],
body.dev-on button[data-don-name],
body.dev-on button[data-section-name],
body.dev-on button[data-section-type],
/* Extra specific selectors to match the hiding rules exactly */
body.dev-on .spell-add,
body.dev-on .don-add,
body.dev-on .objet-add,
body.dev-on .category-add,
body.dev-on .spell-category-delete,
body.dev-on .don-category-delete,
body.dev-on .objet-category-delete,
body.dev-on .don-move-up,
body.dev-on .don-move-down,
body.dev-on button[title*="Éditer"],
body.dev-on button[title*="Edit"],
body.dev-on button[title*="Supprimer"],
body.dev-on button[title*="Ajouter"],
body.dev-on [data-dev-only],
body.dev-on .dev-mode-buttons,
body.dev-on .manage-tags-btn,
body.dev-on .add-monster-btn,
body.dev-on .tags-manager-btn {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  pointer-events: auto !important;
  position: relative !important;
}

/* ULTIMATE SOLUTION: Force dimensions to prevent 0x0 collapse */
html body.dev-on .edit-btn,
html body.dev-on button[class*="edit"],
html body.dev-on button[class*="add"],
html body.dev-on button[class*="delete"],
html body.dev-on .section-delete,
html body.dev-on .add-paragraph-btn {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  width: 28px !important;
  height: 28px !important;
  min-width: 28px !important;
  min-height: 28px !important;
  background: rgba(139,69,19,0.1) !important;
  border: 1px solid var(--bronze) !important;
  border-radius: 6px !important;
  color: var(--bronze) !important;
  font-size: 14px !important;
  padding: 4px !important;
  margin-left: 8px !important;
  box-sizing: border-box !important;
  line-height: 1 !important;
  cursor: pointer !important;
  position: relative !important;
  top: 0 !important;
  left: 0 !important;
  transform: none !important;
  z-index: 10 !important;
}
/* Target specific button classes from renderer */
body.dev-off .spell-add,
body.dev-off .don-add,
body.dev-off .objet-add,
body.dev-off .spell-delete,
body.dev-off .don-delete,
body.dev-off .objet-delete,
body.dev-off .spell-category-delete,
body.dev-off .don-category-delete,
body.dev-off .objet-category-delete,
body.dev-off .don-move-up,
body.dev-off .don-move-down,
body.dev-off .section-delete,
body.dev-off .remove-section-btn,
/* Universal button selectors with edit-related titles */
body.dev-off button[title*="diter"],
body.dev-off button[title*="Edit"],
body.dev-off button[title*="Supprimer"],
body.dev-off button[title*="Ajouter"],
body.dev-off button[title*="Haut"],
body.dev-off button[title*="Bas"],
/* AJOUT: Sélecteurs pour les boutons add/delete */
body.dev-off button[class*="add"],
body.dev-off button[class*="delete"],
body.dev-off button[class*="remove"],
body.dev-off button[class*="move"],
body.dev-off button[class*="upload"],
body.dev-off button[class*="edit"] {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  pointer-events: none !important;
}

/* SPÉCIFIQUE: Règles avec spécificité maximale pour forcer le masquage */
body.dev-off button.spell-add.btn,
body.dev-off button.don-add.btn,
body.dev-off button.objet-add.btn,
body.dev-off button.spell-category-delete.btn,
body.dev-off button.don-category-delete.btn,
body.dev-off button.objet-category-delete.btn,
/* ULTRA-SPÉCIFIQUE: Tags manager buttons */
body.dev-off button.tags-manager-btn.btn,
body.dev-off button.filter-manager-btn.btn,
html body.dev-off .tags-manager-btn,
html body.dev-off .filter-manager-btn,
html body.dev-off button.tags-manager-btn,
html body.dev-off button.filter-manager-btn {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  pointer-events: none !important;
}

/* Ancien système d'agrandissement - désactivé */
.illus img.enlarged {
  /* Plus de style ici - géré par JavaScript modal */
}

/* Forcer l'état stable sur hover pour les images agrandies */
.illus img.enlarged:hover,
article[data-page="guerrier"] .illus img.enlarged:hover,
article[data-page="mage"] .illus img.enlarged:hover,
article[data-page="pretre"] .illus img.enlarged:hover,
article[data-page="rodeur"] .illus img.enlarged:hover,
article[data-page="enchanteur"] .illus img.enlarged:hover,
.illus[data-illus-key^="class:"] img.enlarged:hover,
article[data-page="sorts-mage"] .illus img.enlarged:hover,
article[data-page="sorts-pretre"] .illus img.enlarged:hover,
article[data-page="sorts-enchanteur"] .illus img.enlarged:hover,
.illus[data-illus-key^="spellcategory:"] img.enlarged:hover {
  transform:translate(-50%, -50%) !important;
  transition:none !important;
}

/* Ancien backdrop - plus utilisé */
.image-backdrop {
  display: none !important;
}

/* Interactive buttons */
.btn-action{display:inline-flex;gap:var(--space-sm);align-items:center;padding:var(--space-sm) 10px;border-radius:10px;cursor:pointer;border:1px solid}
.btn-upload{border-color:rgba(0,0,0,.25);border-style:dashed;background:#fff8ee}
.btn-remove{border-color:rgba(120,0,0,.25);background:#fee2e2}
.btn-add{border-color:rgba(0,120,0,.25);background:#f0fff4;margin-bottom:10px}
.btn-delete{padding:var(--space-xs) var(--space-md);border-radius:6px;font-size:12px;margin-left:10px}
.illus .up{border-color:rgba(0,0,0,.25);border-style:dashed;background:#fff8ee}
.illus .rm, .spell-delete{border-color:rgba(120,0,0,.25);background:#fee2e2}
.spell-add{border-color:rgba(0,120,0,.25);background:#f0fff4;margin-bottom:10px}
.spell-delete{padding:var(--space-xs) var(--space-md);border-radius:6px;font-size:12px;margin-left:10px}

/* Bouton d'ajout de paragraphe - seulement dans les articles */
.add-paragraph-btn {
  display:none !important;
}
/* Masquer explicitement dans la sidebar et le sommaire */
.sidebar .add-paragraph-btn,
.toc .add-paragraph-btn,
#toc .add-paragraph-btn {
  display:none !important;
  visibility:hidden !important;
}
/* Afficher SEULEMENT dans les articles actifs en mode dev */
body.dev-on article.active .add-paragraph-btn {
  display:block !important; margin:10px 0; padding:8px 12px; background:var(--card); 
  border:2px dashed var(--bronze); border-radius:8px; cursor:pointer;
  color:var(--bronze); text-align:center; transition:all .2s ease;
}
body.dev-on article.active .add-paragraph-btn:hover {
  background:rgba(139,69,19,.08); border-color:var(--gold);
  color:var(--gold);
}

/* Bouton d'ajout de sous-classe */
.add-subclass-btn {
  display:none; margin:12px 0 4px 0; padding:8px 12px; background:var(--card);
  border:1px dashed var(--bronze); border-radius:8px; cursor:pointer;
  color:var(--bronze); text-align:center; font-size:13px;
  transition:all .2s ease; width:100%;
}
/* Afficher dans les pages de classes en mode dev */
body.dev-on article[data-page="guerrier"] .add-subclass-btn,
body.dev-on article[data-page="mage"] .add-subclass-btn,
body.dev-on article[data-page="pretre"] .add-subclass-btn,
body.dev-on article[data-page="rodeur"] .add-subclass-btn,
body.dev-on article[data-page="enchanteur"] .add-subclass-btn {
  display:block !important;
}
body.dev-on article[data-page="guerrier"] .add-subclass-btn:hover,
body.dev-on article[data-page="mage"] .add-subclass-btn:hover,
body.dev-on article[data-page="pretre"] .add-subclass-btn:hover,
body.dev-on article[data-page="rodeur"] .add-subclass-btn:hover,
body.dev-on article[data-page="enchanteur"] .add-subclass-btn:hover {
  background:rgba(139,69,19,.08); border-color:var(--gold);
  color:var(--gold); transform:translateY(-1px);
  box-shadow:0 4px 8px rgba(0,0,0,.1);
}

/* Modales */
.category-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.category-modal.visible {
  display:flex;
}
.category-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:500px; width:90%; box-shadow:var(--shadow);
  position:relative;
}

/* Modal pour les icônes */
.icons-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.icons-modal.visible {
  display:flex;
}
.icons-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:600px; width:90%; max-height:80vh; overflow-y:auto;
  box-shadow:var(--shadow); position:relative;
}
.icons-grid {
  display:grid; grid-template-columns:repeat(auto-fill, minmax(60px, 1fr));
  gap:var(--space-md); margin:var(--space-xl) 0; max-height:400px; overflow-y:auto;
  border:1px solid var(--rule); border-radius:var(--space-md); padding:var(--space-xl);
}
.icon-item {
  display:flex; align-items:center; justify-content:center;
  padding:var(--space-lg); border:1px solid var(--rule); border-radius:var(--space-md);
  cursor:pointer; transition:var(--transition-fast); font-size:24px;
  background:var(--paper);
}
.icon-item:hover {
  background:var(--bronze); color:white; transform:scale(1.1);
  box-shadow:0 4px 8px rgba(0,0,0,.2);
}
.icon-item.copied {
  background:var(--gold); color:white; animation:copyFlash .5s ease;
}
@keyframes copyFlash {
  0% { transform:scale(1.1); }
  50% { transform:scale(1.3); }
  100% { transform:scale(1.1); }
}

/* Modal pour les éléments */
.elements-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:2147483647; display:none; align-items:center; justify-content:center;
}
.elements-modal.visible {
  display:flex;
}
.elements-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:400px; width:90%; 
  box-shadow:var(--shadow); position:relative;
}
.elements-list {
  display:flex; flex-direction:column; gap:var(--space-md); margin:var(--space-xl) 0;
}
.element-item {
  display:flex; align-items:center; gap:var(--space-md); padding:var(--space-md);
  border:2px solid var(--rule); border-radius:var(--space-md); cursor:pointer;
  transition:var(--transition-fast); background:var(--card);
}
.element-item:hover {
  background:var(--paper); border-color:var(--bronze); transform:translateY(-2px);
  box-shadow:0 4px 12px rgba(0,0,0,.1);
}
.element-item:active {
  transform:translateY(0) scale(0.98);
}
.element-icon {
  width:24px; height:24px; border-radius:50%; flex-shrink:0;
}
.element-name {
  font-weight:600; flex-grow:1;
}
.copy-indicator {
  font-size:12px; color:var(--paper-muted); opacity:0;
  transition:opacity 0.3s ease;
}
.element-item.copied .copy-indicator {
  opacity:1;
}

/* États modal styles */
.etats-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:2147483647; display:none; align-items:center; justify-content:center;
}
.etats-modal.visible {
  display:flex;
}
.etats-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:500px; width:90%; 
  box-shadow:var(--shadow); position:relative; max-height:80vh; overflow-y:auto;
}
.etats-list {
  display:flex; flex-direction:column; gap:var(--space-md); margin:var(--space-xl) 0;
}
.etat-item {
  display:flex; align-items:flex-start; gap:var(--space-md); padding:var(--space-md);
  border:2px solid var(--rule); border-radius:var(--space-md); cursor:pointer;
  transition:var(--transition-fast); background:var(--card); position:relative;
}
.etat-content {
  flex:1; display:flex; flex-direction:column;
}
.etat-item:hover {
  background:var(--paper); border-color:var(--bronze); transform:translateY(-2px);
  box-shadow:0 4px 12px rgba(0,0,0,.1);
}
.etat-item:active {
  transform:translateY(0) scale(0.98);
}
.etat-icon {
  width:24px; height:24px; border-radius:50%; flex-shrink:0;
  background:var(--bronze); color:white; display:flex; align-items:center;
  justify-content:center; font-size:14px;
}
.etat-name {
  font-weight:600; color:var(--accent-ink); margin-bottom:4px;
}
.etat-description {
  font-size:12px; color:var(--paper-muted); line-height:1.4;
}
.etat-item .copy-indicator {
  position:absolute; top:50%; right:var(--space-md); transform:translateY(-50%);
  font-size:12px; color:var(--bronze); opacity:0; font-weight:600;
  transition:opacity 0.3s ease;
}
.etat-item.copied .copy-indicator {
  opacity:1;
}

/* Styles pour les tooltips d'états */
span[title] {
  cursor: help;
  border-bottom: 2px solid var(--bronze);
  position: relative;
  display: inline-block;
  background: linear-gradient(135deg, rgba(205,127,50,0.1), rgba(212,175,55,0.05));
  padding: 2px 4px;
  border-radius: 3px;
  font-weight: 700;
}

/* Styles pour les liens de sorts */
.spell-link {
  color: #ea7332 !important; /* Orange au lieu du jaune */
  cursor: pointer;
  text-decoration: underline;
  font-weight: 600;
  transition: color 0.2s ease;
}

.spell-link:hover {
  color: var(--bronze) !important;
}

/* Styles pour les liens d'états */
.etat-link {
  color: #ea7332 !important; /* Orange au lieu du jaune */
  cursor: pointer;
  text-decoration: underline;
  font-weight: 600;
  transition: color 0.2s ease;
}

.etat-link:hover {
  color: var(--bronze) !important;
}

/* Modal des liens de sorts */
.spell-links-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  z-index: 2147483647;
  display: none;
  align-items: center;
  justify-content: center;
}

.spell-links-modal.visible {
  display: flex;
}

.spell-links-modal-content {
  background: var(--card);
  border: 2px solid var(--rule);
  border-radius: 16px;
  padding: var(--space-2xl);
  max-width: 600px;
  width: 90%;
  box-shadow: var(--shadow);
  position: relative;
  max-height: 80vh;
  overflow-y: auto;
}

.spell-item {
  display: flex;
  align-items: flex-start;
  gap: var(--space-md);
  padding: var(--space-md);
  border: 2px solid var(--rule);
  border-radius: var(--space-md);
  cursor: pointer;
  transition: var(--transition-fast);
  background: var(--card);
  position: relative;
  margin-bottom: 8px;
}

.spell-item:hover {
  background: var(--paper);
  border-color: var(--bronze);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.spell-item:active {
  transform: translateY(0) scale(0.98);
}

.spell-info {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.spell-name {
  font-weight: 600;
  margin-bottom: 4px;
  font-size: 14px;
}

.spell-meta {
  font-size: 12px;
  color: var(--paper-muted);
  margin-bottom: 6px;
}

.spell-description {
  font-size: 14px;
  color: var(--paper-muted);
  line-height: 1.4;
}

.spell-item .copy-indicator {
  position: absolute;
  top: 50%;
  right: var(--space-md);
  transform: translateY(-50%);
  font-size: 12px;
  color: var(--bronze);
  opacity: 0;
  font-weight: 600;
  transition: opacity 0.3s ease;
}

.spell-item.copied .copy-indicator {
  opacity: 1;
}

/* Popup de prévisualisation des sorts */
.spell-preview-popup {
  position: fixed;
  z-index: 10001;
  background: var(--card);
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  max-width: 400px;
  max-height: 500px;
  overflow-y: auto;
  font-family: 'Roboto', sans-serif;
  line-height: 1.4;
}

.spell-preview-content {
  padding: 0;
}

.spell-preview-header {
  padding: 16px;
  background: var(--paper);
  border-radius: 8px 8px 0 0;
  position: relative;
  border-left: 4px solid var(--accent);
}

.spell-title {
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 4px;
  font-family: 'Cinzel', serif;
}

/* Règle générale pour spell-element dans les cartes */
.card .spell-element {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  /* Pas de couleur par défaut - utilise les couleurs inline des éléments */
}

/* Couleur de fallback uniquement si aucune couleur inline n'est définie */
.card .spell-element:not([style*="color"]) {
  color: var(--paper-muted);
}

/* Badge d'élément avec texte noir pour lisibilité */
.element-badge {
  color: var(--paper-ink) !important;
  text-shadow: none !important;
}

/* S'assurer que la toolbox dev reste cliquable même avec modale ouverte */
#devToggle,
#devToolbox,
.tools,
.dev-toolbox {
  position: relative;
  z-index: 999999 !important;
}

/* Boutons de la toolbox dev toujours cliquables */
body.dev-on #devToggle,
body.dev-on #devToolbox *,
body.dev-on .tools *,
body.dev-on .dev-toolbox * {
  z-index: 999999 !important;
  pointer-events: auto !important;
}

/* Z-index maximum pour l'interface dev au-dessus des modales et dialogues */
.tools button,
.dev-toolbox button,
#devToggle,
#devToolbox button {
  z-index: 9999999 !important;
  position: relative;
}

/* Conteneur principal des outils dev */
.tools,
.dev-toolbox {
  z-index: 9999999 !important;
  position: relative;
}

/* Forcer les modales toolbox à apparaître devant les dialogues d'édition HTML */
.elements-modal,
.etats-modal, 
.spell-links-modal {
  z-index: 2147483647 !important; /* Maximum z-index possible */
}

.elements-modal-content,
.etats-modal-content,
.spell-links-modal-content {
  z-index: 2147483647 !important;
  position: relative;
}

/* Règle spécifique pour spell-element dans les popups de prévisualisation */
.spell-preview-popup .spell-element {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  /* Pas de couleur définie ici - elle sera définie en inline */
}

/* Force les couleurs des éléments - spécificité maximale */
.spell-links-modal .spell-meta[style*="color"],
.spell-preview-popup .spell-element[style*="color"] {
  color: var(--accent-ink) !important;
}

/* Règles pour les nouveaux attributs de données */
[data-element-display],
[data-spell-meta] {
  color: inherit !important;
  font-weight: 600;
}

/* Alternative: couleurs directes par élément */
.spell-preview-popup .spell-element[style*="#e25822"] { color: #e25822 !important; }
.spell-preview-popup .spell-element[style*="#2563eb"] { color: #2563eb !important; }
.spell-preview-popup .spell-element[style*="#92400e"] { color: #92400e !important; }
.spell-preview-popup .spell-element[style*="#059669"] { color: #059669 !important; }
.spell-preview-popup .spell-element[style*="#d97706"] { color: #d97706 !important; }
.spell-preview-popup .spell-element[style*="#6b21a8"] { color: #6b21a8 !important; }
.spell-preview-popup .spell-element[style*="#7c2d12"] { color: #7c2d12 !important; }
.spell-preview-popup .spell-element[style*="#7c3aed"] { color: #7c3aed !important; }

.spell-links-modal .spell-meta[style*="#e25822"] { color: #e25822 !important; }
.spell-links-modal .spell-meta[style*="#2563eb"] { color: #2563eb !important; }
.spell-links-modal .spell-meta[style*="#92400e"] { color: #92400e !important; }
.spell-links-modal .spell-meta[style*="#059669"] { color: #059669 !important; }
.spell-links-modal .spell-meta[style*="#d97706"] { color: #d97706 !important; }
.spell-links-modal .spell-meta[style*="#6b21a8"] { color: #6b21a8 !important; }
.spell-links-modal .spell-meta[style*="#7c2d12"] { color: #7c2d12 !important; }
.spell-links-modal .spell-meta[style*="#7c3aed"] { color: #7c3aed !important; }

.spell-preview-close {
  position: absolute;
  top: 12px;
  right: 12px;
  background: none;
  border: none;
  font-size: 16px;
  cursor: pointer;
  color: var(--paper-muted);
  padding: 4px;
  border-radius: 4px;
  transition: all 0.2s ease;
}

.spell-preview-close:hover {
  background: var(--rule);
  color: var(--accent-ink);
}

.spell-preview-body {
  padding: 16px;
}

/* États preview popup */
.etat-preview-popup {
  position: fixed;
  z-index: 10001;
  background: var(--card);
  border: 2px solid #7c2d12;
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.3);
  max-width: 300px;
  padding: 1rem;
  font-size: 14px;
  line-height: 1.4;
  color: var(--paper-ink);
  pointer-events: auto;
}

.etat-preview-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--rule);
}

.etat-title {
  font-weight: 600;
  font-size: 16px;
  color: #7c2d12;
}

.etat-preview-close {
  background: none;
  border: none;
  font-size: 16px;
  cursor: pointer;
  color: var(--paper-muted);
  padding: 4px;
  border-radius: 4px;
  transition: all 0.2s ease;
}

.etat-preview-close:hover {
  background: var(--rule);
  color: var(--accent-ink);
}

.etat-preview-body {
  margin-top: 0.5rem;
}

.etat-description {
  white-space: pre-line;
}

.spell-field {
  margin-bottom: 12px;
  font-size: 14px;
  line-height: 1.5;
}

.spell-field:last-child {
  margin-bottom: 0;
}

.spell-description {
  margin-bottom: 16px;
  font-style: italic;
  color: var(--paper-muted);
  font-size: 14px;
}

/* Responsive pour mobile */
@media (max-width: 768px) {
  .spell-preview-popup {
    max-width: calc(100vw - 16px);
    max-height: calc(100vh - 32px);
    left: 8px !important;
    top: 16px !important;
  }
  
  .spell-links-modal-content {
    max-width: calc(100vw - 16px);
    padding: 16px;
  }
}

span[title]:hover {
  border-bottom-color: var(--gold);
  border-bottom-width: 3px;
  background: linear-gradient(135deg, rgba(212,175,55,0.2), rgba(205,127,50,0.1));
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* Tooltip personnalisé pour une meilleure visibilité */
span[title]:hover::after {
  content: attr(title);
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: var(--accent-ink);
  color: white;
  padding: 10px 15px;
  border-radius: 8px;
  font-size: 13px;
  white-space: pre-line;
  z-index: 999999;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  pointer-events: none;
  min-width: 200px;
  max-width: 320px;
  text-align: center;
  line-height: 1.5;
  animation: tooltipFadeIn 0.3s ease;
  border: 2px solid var(--gold);
  word-wrap: break-word;
}

span[title]:hover::before {
  content: '';
  position: absolute;
  bottom: calc(100% + 2px);
  left: 50%;
  transform: translateX(-50%);
  border: 6px solid transparent;
  border-top-color: var(--accent-ink);
  z-index: 999999;
  pointer-events: none;
}

/* Forcer l'overflow visible pour les tooltips */
.card:has(span[title]:hover),
.editable:has(span[title]:hover),
article:has(span[title]:hover) {
  overflow: visible !important;
}

/* Fallback pour navigateurs sans :has() */
.card,
.editable,
article {
  position: relative;
}

.card span[title]:hover::after,
.editable span[title]:hover::after,
article span[title]:hover::after {
  z-index: 99999 !important;
}

@keyframes tooltipFadeIn {
  from { opacity: 0; transform: translateX(-50%) translateY(5px); }
  to { opacity: 1; transform: translateX(-50%) translateY(0); }
}

/* === UNIFIED EDIT BUTTONS FOR ALL SECTIONS === */
.editable-section {
  position: relative;
  margin: 8px 0;
}

.edit-btn {
  background: var(--bronze);
  color: white;
  border: none;
  border-radius: 6px;
  padding: 4px 8px;
  cursor: pointer;
  font-size: 12px;
  opacity: 0.7;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.edit-btn:hover {
  opacity: 1;
  transform: scale(1.05);
  background: var(--gold);
}

/* Inline edit buttons (titles, etc.) */
.edit-btn.edit-title-btn,
.edit-btn.edit-paragraph-btn {
  position: relative;
  margin-left: 8px;
}

/* Section edit buttons (absolute positioning) */
.editable-section .edit-btn.edit-section-btn,
[style*="position:relative"] .edit-btn.edit-section-btn {
  position: absolute;
  right: 8px;
  top: 8px;
  z-index: 10;
}

.editable-section:hover .edit-btn {
  opacity: 1;
  transform: scale(1.05);
  background: var(--gold);
}

.editable-section .edit-btn:hover {
  background: var(--gold) !important;
  transform: scale(1.1) !important;
  box-shadow: 0 3px 8px rgba(0,0,0,0.2);
}

.editable-section .edit-btn:active {
  transform: scale(0.95) !important;
}

/* Special positioning for different types */
.editable-list-container .edit-btn {
  right: 16px;
  top: 16px;
}

.editable-section[data-section-type="intro"] .edit-btn {
  right: 12px;
  top: 12px;
}

/* Title edit buttons */
.edit-title-btn {
  position: relative !important;
  right: auto !important;
  top: auto !important;
  margin-left: 12px;
  transform: none !important;
}

.edit-title-btn:hover {
  transform: scale(1.1) !important;
}

/* When editing, hide the button and expand content */
.editable-section[data-editing="true"] .edit-btn {
  display: none;
}

/* Visual feedback for editable sections */
.editable-section:hover {
  background: rgba(184, 134, 11, 0.05);
  border-radius: 8px;
  transition: background 0.2s ease;
}

.editable-section[data-editing="true"] {
  background: rgba(255, 255, 0, 0.1);
  border: 1px dashed var(--bronze);
  border-radius: 8px;
  padding: 8px;
}

/* Legacy support for old list items */
.editable-item {
  position: relative;
  padding-right: 40px;
}

.editable-content {
  display: block;
  margin-right: 35px;
}
</style>
</head>
<body class="dev-off">

<div class="shell">
  <button aria-controls="sidebar" aria-expanded="false" aria-label="Ouvrir le sommaire" class="menu-toggle" id="menuToggle" style="display:none">☰ Sommaire</button>
  <div class="backdrop" hidden="" id="backdrop"></div>
  
  <main class="page">
    <aside class="sidebar" id="sidebar">
      <div class="panel">
        <div class="searchbar">
          <input autocomplete="off" id="search" placeholder="Rechercher une règle, une classe…">
          <button class="btn" id="clear" title="Effacer">✖</button>
        </div>
        <div class="tools">
          <!-- Dev mode disabled in standalone version -->
        </div>
        <div class="toc" id="toc">
          <!-- Table of contents will be generated by JavaScript -->
        </div>
      </div>
    </aside>
    
    <div id="views">
      <!-- Main content will be generated by JavaScript -->
      <div id="app-loading">Chargement...</div>
    </div>
  </main>
  
  <footer>
    <p>JDR‑BAB — Règles et contenus sous licence libre</p>
  </footer>
</div>

<script>

    // Ensure window object exists
    window = window || {};
    
    // Global data from modular files
    window.SORTS = [
  {
    "nom": "Sorts de Mage",
    "description": "Sorts de destruction.",
    "sorts": [
      {
        "nom": "Boule de Feu",
        "element": "Feu",
        "description": "Lance une boule de feu sur un adversaire, qui peut s'enflammer.",
        "categorie": "Mage",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> 20m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 3",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige 5 dégats de <span style=\"color: #e25822; font-weight: bold;\">Feu</span> à la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Les dégats passent à 7 et la cible s'enflamme, infligeant 5 dégats de feu au prochain tour du lanceur."
      },
      {
        "nom": "Éclair",
        "element": "Air",
        "description": "Frappe instantannément une cible avec un éclair électrique, ne laissant aucune chance à l'esquive.",
        "categorie": "Mage",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 2",
        "portee": "🎯 <strong>Portée:</strong> 10m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 5",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> &nbsp;Inflige 6 dégats d'<span style=\"color: #22c55e; font-weight: bold;\">Air</span> à la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> Les dégâts passent à 10 et ils sont aussi infligé à un ennemi à moins de 5m de la cible."
      },
      {
        "nom": "Vague déferlante",
        "element": "Eau",
        "description": "Une puissante vague d'eau s'abat sur vos ennemis et les repousse.",
        "categorie": "Sorts de Mage",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 3",
        "portee": "🎯 <strong>Portée:</strong> 5m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 6",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> Volant.",
        "effetNormal": "<strong>Effet:</strong> &nbsp;Inflige 6 dégats d'<span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span> aux créature devant le lanceur (largeur 2m distance 5m) et les repousse jusqu'à 5m.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> les dégats passent à 10 et les enemis sont touchés/repoussés à 10m."
      },
      {
        "nom": "Volée de pierres",
        "element": "Terre",
        "description": "Invoque une volée de pierres qui tournoient autour du lanceur, puis qui sont éjectées devant lui.",
        "categorie": "Sorts de Mage",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 4",
        "portee": "🎯 <strong>Portée:</strong> 10m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 10",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige 7 dégats de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> aux créatures autour du lanceur (3m). <br>Puis inflige le même montant aux créatures devant le lanceur sur 10m.<br><br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Les dégats passent à 12. Les cibles non volantes et de taille moyennes sont <span title=\"Ne peut plus faire d'actions.\n Ne peut plus esquiver.\n Doit dépenser une action secondaire pour se relever.\">A terre</span> pendant 1 tour."
      }
    ]
  },
  {
    "nom": "Sorts de Prêtre",
    "description": "Sorts de soutiens et anti mort-vivants.",
    "sorts": [
      {
        "nom": "Châtiment",
        "element": "Divin",
        "description": "Invoque un magie divine qui blesse les morts-vivants",
        "categorie": "Anti-mort-vivant",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 3",
        "portee": "🎯 <strong>Portée:</strong> 20m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 3",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> &nbsp;<br>- Non mort-vivant <br>- Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige *Intelligence* dégâts <span style=\"color: #d0d0d0; font-weight: bold; background: rgba(0, 0, 0, 0.4); padding: 2px 4px; border-radius: 3px;\">Divin</span> à la cible.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>Double dégâts."
      },
      {
        "nom": "Soin mineur",
        "element": "Divin",
        "description": "Une magie divine soigne les blessures du héros ou d'un allié proche.",
        "categorie": "Sorts de Prêtre",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> 3m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 5",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> &nbsp;mort-vivant.",
        "effetNormal": "<strong>Effet:</strong> Soigne la cible de 5 points de vie. Tous les 5 points d'intelligence, augmente le soin de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>Double le soin."
      },
      {
        "nom": "Protection",
        "element": "Lumière",
        "description": "Protège le lanceur ou un allié.",
        "categorie": "Sorts de Prêtre",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 2",
        "portee": "🎯 <strong>Portée:</strong> 3m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 5",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Augmente l'armure de 2 pendant 5 tours.<br> Tous les 5 d'Intelligence, augmente l'armure de 1 supplémentaire.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> L'armure est augmentée de 4."
      },
      {
        "nom": "Arme de lumière",
        "element": "Lumière",
        "description": "Une lumière destructrice s'imprègne de l'arme du prêtre.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> -",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 5",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> L'arme du prêtre infligera 2 dégats de lumière à chaque coup, pendant 4 tours.<br> Tous les 5 d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Les dégats passent à 4."
      }
    ]
  },
  {
    "nom": "Sorts d'Enchanteur",
    "description": "Sorts d'amélioration et d'affaiblissement.",
    "sorts": [
      {
        "nom": "Accroche terrestre",
        "element": "Terre",
        "description": "Le sol se soulève et s'agrippe aux jambes de la cible, alourdissant ses pas d'une étreinte de pierre vivante.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> 30m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 3",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> <br>- Résistance altérations &gt; Intelligence du lanceur<br>- Lévitation ou Volant.",
        "effetNormal": "<strong>Effet:</strong>&nbsp;La cible contracte l'état <span class=\"etat-link\" data-etat=\"Ralenti\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Ralenti</span> pendant 5 tours.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>La cible ne peut plus effectuer de déplacement pendant la durée du sort."
      },
      {
        "nom": "Accélération",
        "element": "Air",
        "description": "Une magie des vents accélère un allié ou le lanceur.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> 5m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 4",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> Aucune",
        "effetNormal": "<strong>Effet:</strong> &nbsp;La vitesse de déplacement de la cible est augmentée de 50% pendant 5 tours. Non Cumulable.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> La vitesse est augmentée de 100%."
      },
      {
        "nom": "Sommeil",
        "element": "Nuit",
        "description": "Un voile d'ombre caresse la cible, l'enveloppant dans un sommeil surnaturel.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 2",
        "portee": "🎯 <strong>Portée:</strong> 5m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 8",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> <br>- Résistance altérations &gt; Intelligence du lanceur<br>- Element <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span>",
        "effetNormal": "<strong>Effet:</strong> La cible passe dans l'état <span class=\"etat-link\" data-etat=\"Endormi/assomé/Effrayé\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Endormi</span> pendant ses 2 prochains tours.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> L'effet dure 4 tours."
      }
    ]
  },
  {
    "nom": "Sorts de Monstres",
    "description": "Sorts divers de monstres.",
    "sorts": []
  }
];
    window.CLASSES = [
  {
    "nom": "Guerrier",
    "resume": "Héros sans égal au combat au corp à corp.",
    "capacites": "<ul><li><em>Expert de l'équipement</em> : Toutes les armes, armures (légères/lourdes), bouclier.</li><li><em>Hardiesse</em> : Gagne la compétence Hardiesse rang 1.</li></ul>",
    "sousClasses": [
      {
        "nom": "Nain des montagnes",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>5</strong></span><span class=\"chip\">🏃 Agilité: <strong>1</strong></span><span class=\"chip\">🛡️ Endurance: <strong>7</strong></span><span class=\"chip\">🧠 Intelligence: <strong>1</strong></span><span class=\"chip\">⚡ Volonté: <strong>5</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Force 💪, +3 Endurance 🛡️, +1 Volonté⚡   <strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Brise rocher</em>: Gagne 1 de compétence sur les tests de compétence Hardiesse pour une destruction d'objet.</li><li><em>Volonté inflexible</em>: Les nains possèdent une volonté inflexible qui les rendent résistants aux sortilèges (caractéristique Volonté élevée).</li></ul>",
        "description": "<i>Race robuste et inflexible, dotée d’une endurance exceptionnelle. Forgés par la roche et les sommets, ils résistent aux épreuves et possèdent une force colossale capable de briser murs, armures et créatures cuirassées.</i>"
      },
      {
        "nom": "Berserker",
        "base": {
          "Force": 5,
          "Agilité": 4,
          "Endurance": 5,
          "Intelligence": 1,
          "Volonté": 1,
          "Chance": 1
        },
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Force 💪, +1 Agilité 🏃, +2 Endurance 🛡️<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Tourbillon de rage</em>: Sur un critique au corps à corps, touche aussi tous les adversaires à moins de 2m.</li><li><em>Risque sauvage</em>: +1 chance de critique physique s'il ne porte pas de bouclier.</li></ul>",
        "description": "<i>Combattant sauvage, maître des armes à deux mains. Sa rage décuple sa force, lui permettant d’abattre ses ennemis dans un déchaînement de puissance brute et de coups imparables.</i>"
      },
      {
        "nom": "Aventurier",
        "description": "Héros polyvalent et ingénieux, il affronte l’inconnu avec courage, et manie tous les outils à sa portée pour triompher.",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>5</strong></span><span class=\"chip\">🏃 Agilité: <strong>2</strong></span><span class=\"chip\">🛡️ Endurance: <strong>5</strong></span><span class=\"chip\">🧠 Intelligence: <strong>1</strong></span><span class=\"chip\">⚡ Volonté: <strong>1</strong></span><span class=\"chip\">🍀 Chance: <strong>5</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Force 💪, +2 Endurance 🛡️, +1 Chance 🍀, <strong> +2 Au choix</strong>",
        "capacites": "<ul><em>Passé glorieux</em> : Gagne la compétence Eloquence rang 1.<br><em>Sans failles</em> : Dispose d'un Effort supplémentaire maximum.<br><em>Épaules d’acier</em> : Peut porter jusqu’à cinq consommables de plus que la limite habituelle.</ul>"
      }
    ]
  },
  {
    "nom": "Mage",
    "resume": "Spécialiste de la magie destructrice.",
    "capacites": "<ul><li><em>Équipement de mage</em> : bâtons, robes.</li><li><em>Sorts de mage</em> : Apprend et lance des sorts de mage.</li></ul>",
    "sousClasses": [
      {
        "nom": "Érudit",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>1</strong></span><span class=\"chip\">🏃 Agilité: <strong>1</strong></span><span class=\"chip\">🛡️ Endurance: <strong>1</strong></span><span class=\"chip\">🧠 Intelligence: <strong>6</strong></span><span class=\"chip\">⚡ Volonté: <strong>3</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +3 Intelligence 🧠, +2 Volonté ⚡<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Instruit</em> : Gagne la compétence Réflexion rang 1.</li><li><em>Apprentissage accéléré</em> : Le niveau de l'érudit est considéré comme deux fois plus élevé pour les prérequis d'apprentissage de sorts.</li></ul>",
        "description": "<i>Mage avide de savoir, doté d’une mémoire prodigieuse. Il assimile les arcanes avec une rapidité fulgurante et maîtrise de nouveaux sorts bien plus vite que ses pairs.</i>"
      },
      {
        "nom": "Elfe",
        "base": {
          "Force": 2,
          "Agilité": 2,
          "Endurance": 3,
          "Intelligence": 3,
          "Volonté": 2,
          "Chance": 1
        },
        "progression": "<strong>📈 Progression par niveau:</strong> +1 Force 💪, +1 Agilité 🏃, +1 Endurance 🛡️, +1 Intelligence 🧠, +1 Volonté ⚡<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Instinct elfique</em> : Gagne la compétence Coordination rang 1.</li><li><em>Équipement d'elfe</em> : Epées à une main, armures légères.</li><li><em>Briseur de sceaux</em> : Gagne 1 de compétence sur les tests de compétence pour comprendre ou ouvrir une porte scellée magiquement</li></ul>",
        "description": "<i>Guerrier-mage polyvalent, aussi agile qu’élégant. Maître des arcanes comme du combat rapproché, il allie puissance magique et adresse martiale avec une grâce inégalée.</i>"
      }
    ]
  },
  {
    "nom": "Prêtre",
    "resume": "Spécialiste de la magie de soutien et anti morts-vivants.",
    "capacites": "<ul><li><em>Équipement de prêtre</em> : bâtons, robes.</li><li><em>Sorts de prêtre</em> : Apprend et lance des sorts de Prêtre.</li><li><em>Eloquence</em> : Gagne la compétence Eloquence rang 1.</li></ul>",
    "sousClasses": [
      {
        "nom": "Inquisiteur",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>3</strong></span><span class=\"chip\">🏃 Agilité: <strong>1</strong></span><span class=\"chip\">🛡️ Endurance: <strong>4</strong></span><span class=\"chip\">🧠 Intelligence: <strong>3</strong></span><span class=\"chip\">⚡ Volonté: <strong>5</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +1 Force 💪, +1 Intelligence 🧠, +2 Volonté ⚡, +1 Endurance 🛡️<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Equipement d'inquisiteur</em> : Peut s'équiper d'armures légères et de boucliers.</li><li><em>Fléau des morts-vivants</em> : Les sorts visant les morts-vivants ne ratent jamais.</li><li><em>Lumière purificatrice</em> : Double l'effet de l'intelligence sur les dégats des sorts d'élément <span style=\"color: #ffd700; font-weight: bold;\">Lumière</span> ou <span style=\"color: #f5f5f5; font-weight: bold; background: rgba(100, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;\">Divin</span>.</li></ul>",
        "description": "<i>Champion de la foi, il renforce ses alliés par la magie sacrée et traque sans relâche les morts-vivants. Quand la lumière seule ne suffit plus, il n’hésite pas à prendre les armes et combattre en première ligne.</i>"
      },
      {
        "nom": "Clerc Divin",
        "base": {
          "Force": 1,
          "Agilité": 1,
          "Endurance": 2,
          "Intelligence": 3,
          "Volonté": 5,
          "Chance": 5
        },
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Intelligence 🧠, +2 Volonté ⚡, +1 Chance 🍀<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Maître des soins</em> : Double l'effet de l'intelligence sur les sorts de soins.</li><li><em> Pieu </em>:  Gagne 1 de compétence sur les tests de compétence Reflexion sur un dieu ou une religion.</li><li><em> Protection divine </em>:  Dispose d'une armure élementaire <span style=\"color: #f5f5f5; font-weight: bold; background: rgba(100, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;\">Divin</span> de 10.</li></ul>",
        "description": "<i>Serviteur sacré, maître des arts de guérison. Sa puissante magie de soins protège ses alliés et les relève même aux portes de la mort.</i>"
      }
    ]
  },
  {
    "nom": "Rôdeur",
    "resume": "Héros très agile.",
    "capacites": "<ul><li><em>Équipement de rôdeur</em> : armures légères, dagues.</li><li><em>Coordination</em> : Gagne la compétence Coordination rang 1.</li></ul>",
    "sousClasses": [
      {
        "nom": "Voleur",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>3</strong></span><span class=\"chip\">🏃 Agilité: <strong>5</strong></span><span class=\"chip\">🛡️ Endurance: <strong>2</strong></span><span class=\"chip\">🧠 Intelligence: <strong>2</strong></span><span class=\"chip\">⚡ Volonté: <strong>2</strong></span><span class=\"chip\">🍀 Chance: <strong>5</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Agilité 🏃, +2 Force 💪, +1 Endurance 🛡️<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Mains expertes</em> : Gagne la compétence Finesse rang 1.</li><li><em>Sprint</em> : Peut utiliser une action secondaire pour doubler sa vitesse.</li><li><em>Vicieux</em> : Une fois par tour, permet d'effectuer une action secondaire supplémentaire aprés un coup critique d'une attaque physique au corps à corps.</li></ul>",
        "description": "<i>Maître de la finesse et de l’agilité, il se déplace avec rapidité fulgurante et frappe là où ça fait le plus mal. </i>"
      },
      {
        "nom": "Chasseur",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>3</strong></span><span class=\"chip\">🏃 Agilité: <strong>5</strong></span><span class=\"chip\">🛡️ Endurance: <strong>2</strong></span><span class=\"chip\">🧠 Intelligence: <strong>4</strong></span><span class=\"chip\">⚡ Volonté: <strong>2</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Agilité 🏃, +1 Force 💪, +1 Endurance 🛡️, +1 Intelligence 🧠<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Armes du Chasseur</em> : Peut utiliser les arcs.</li><li><em>Cueillette</em> : Une fois par jour, lors d’un repos, le personnage peut récolter 5 plantes locales (au choix du MJ). Leur efficacité dépend de l’Intelligence de l’utilisateur.</li><li><em>Connaissance de la faune et la flore</em> : Gagne 1 de compétence sur les tests de Réflexion lié à animal, un monstre ou une plante.</li></ul>",
        "description": "<i>Précis et agile, il complète son art de l’arc par la science des herbes anciennes.</i>"
      }
    ]
  },
  {
    "nom": "Enchanteur",
    "resume": "Détenteur d'une magie singulière, qui fait de lui un allié précieux.",
    "capacites": "<ul><li><em>Équipement d'enchanteur</em> : Robes, bâtons, dagues.</li><li><em>Sorts d'enchanteur</em> : Apprend et lance des sorts d'Enchanteur.</li></ul>",
    "sousClasses": [
      {
        "nom": "Esprit de la grande Fée",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>1</strong></span><span class=\"chip\">🏃 Agilité: <strong>5</strong></span><span class=\"chip\">🛡️ Endurance: <strong>2</strong></span><span class=\"chip\">🧠 Intelligence: <strong>5</strong></span><span class=\"chip\">⚡ Volonté: <strong>2</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +1 Agilité 🏃, +1 Intelligence 🧠, +1 Endurance 🛡️, +1 Volonté ⚡, +1 Chance 🍀<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Tatillon</em> : Gagne la compétence Finesse rang 1.</li><li><em>Lévitation</em> : Ignore dégâts/ralentissements venant du sol.</li><li><em>Rayon de l'Amitié</em> : Par une action secondaire, peut répéter sur une autre cible à portée un sort bénéfique qui a ciblé un allié se tour ci, sans coût en mana supplémentaire.</li></ul>",
        "description": "<i>Être mystique qui flotte au-dessus du sol, il invoque des sorts imprévisibles pour soutenir ses alliés.</i>"
      },
      {
        "nom": "Lutin",
        "base": {
          "Force": 1,
          "Agilité": 1,
          "Endurance": 1,
          "Intelligence": 5,
          "Volonté": 2,
          "Chance": 5
        },
        "progression": "<strong>📈 Progression par niveau:</strong> +1 Intelligence 🧠, +2 Volonté ⚡, +2 Chance 🍀<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Secrets bien gardés</em> : Gagne la compétence Reflexion rang 1.</li><li><em>Expert des baguettes</em> : Sur un critique à la baguette, la charge n'est pas consommée.</li><li><em>Rire malicieux</em> : Par une action secondaire, peut répéter sur une autre cible à portée un sort d'altération qui a ciblé un enemi ce tour ci, sans coût en mana supplémentaire.</li></ul>",
        "description": "<i>Esprit espiègle et rusé, passé maître dans l’art des altérations magiques. </i>"
      }
    ]
  }
];
    window.DONS = [
  {
    "nom": "Generaux",
    "description": "Dons accessibles à toutes les classes.",
    "dons": [
      {
        "nom": "Doué",
        "description": "Gagne une compétence rang 1.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 points de don"
      },
      {
        "nom": "Toujours pret",
        "description": "Le maximum d'efforts passe à 4.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Brillant",
        "description": "Gagne une compétence rang 2.",
        "prerequis": "<strong> Prérequis :</strong> La compétence rang 1.",
        "cout": "2 points de don"
      },
      {
        "nom": "Prodigieux",
        "description": "Gagne une compétence rang 3.",
        "prerequis": "<strong> Prérequis :</strong> La compétence rang 2.",
        "cout": "3 point de don"
      },
      {
        "nom": "Hyperactif",
        "description": "Le héros dispose maintenant de deux actions secondaires par tour.",
        "prerequis": "<strong> Prérequis :</strong> Niveau 3",
        "cout": "2 points de don"
      },
      {
        "nom": "Equitation",
        "description": "Permet de monter à cheval ou équivalent.",
        "prerequis": "<strong> Prérequis :</strong> Niveau 5",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Guerrier",
    "description": "Dons accessibles aux guerriers.",
    "dons": [
      {
        "nom": "Expertise du bouclier",
        "description": "Si le héros a un bouclier équipé, il peut utiliser une action secondaire pour doubler l'armure physique du bouclier jusqu'au prochain tour.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Charge",
        "description": "Une fois par combat, peut utiliser une action secondaire pour doubler sa vitesse de déplacement et forcer un coup critique sur la prochaine attaque physique de ce tour (si elle réussie).",
        "prerequis": "<strong> Prérequis :</strong> 🏃Agilité 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Volonté de fer",
        "description": "Une fois par jour, le héros peut utiliser une action secondaire pour se débarasser de toutes ses alterations magiques.",
        "prerequis": "<strong> Prérequis :</strong> ⚡Volonté 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Coup de bouclier",
        "description": "Si le héros a un bouclier équipé, lorsque le héros subit des dégats aux corps à corps, il peut choisir d'utiliser une action secondaire pour infliger à l'attaquant des dégats équivalents à l'armure du bouclier.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Coup de pommeau",
        "description": "Description du don.",
        "prerequis": "Aucun prérequis",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Rôdeur",
    "description": "Dons accessibles aux rodeurs.",
    "dons": [
      {
        "nom": "Croche-patte",
        "description": "Peut utiliser une action secondaire pour mettre un adversaire au corp à corp, de moins de 2m, dans l'état <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span>.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Chasse et pêche",
        "description": "Le héros n'as plus besoin de sa ratio de nourriture quotidienne.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Attaque d'opportunité",
        "description": "Description du don.",
        "prerequis": "Aucun prérequis",
        "cout": "1 point de don"
      },
      {
        "nom": "D",
        "description": "Description du don.",
        "prerequis": "Aucun prérequis",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Mage",
    "description": "Description de cette catégorie de dons.",
    "dons": [
      {
        "nom": "Gemme de mana",
        "description": "Une fois par jour, le héros peut récupérer l'intégralité de son Mana en utilisant une action secondaire.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Resistance élémentaire 1",
        "description": "Le héros gagne 5 d'armure élémentaire de <span style=\"color: #e25822; font-weight: bold;\">Feu</span>, <span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span>, <span style=\"color: #8b5e34; font-weight: bold;\">Terre</span>, <span style=\"color: #22c55e; font-weight: bold;\">Air</span>.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Resistance magique 1",
        "description": "Le héros gagne 5 d'armure élémentaire de <span style=\"color: #ffd700; font-weight: bold;\">Lumière</span>, <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span>, <span style=\"color: #d0d0d0; font-weight: bold; background: rgba(0, 0, 0, 0.4); padding: 2px 4px; border-radius: 3px;\">Divin</span>, <span style=\"color: #a855f7; font-weight: bold;\">Maléfique</span>.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Spécialisation élémentaire 1",
        "description": "Le héros peut choisir un élément et augmenter de 5 les dégats infligés avec les sorts de cet élément.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Infusion élémentaire",
        "description": "Aprés avoir lancé un sort, le héros peut, en utilisant une action secondaire, imprégner son arme de l'élément du sort. Elle infligera à sa prochaine attaque des dégats de cet élément équivalents au niveau du sort.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Polyglotte",
        "description": "Peut lire et parler toutes les langues.",
        "prerequis": "<strong> Prérequis :</strong> Reflexion rang 2.",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Pretre",
    "description": "Description de cette catégorie de dons.",
    "dons": [
      {
        "nom": "Mécréants",
        "description": "Les dégats physiques infligés aux créatures de l'élément <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span> ou <span style=\"color: #a855f7; font-weight: bold;\">Maléfique</span> sont doublés.",
        "prerequis": "<strong> Prérequis :</strong>-",
        "cout": "1 point de don"
      },
      {
        "nom": "Au milieu du combat",
        "description": "Permet de porter une armure légère.",
        "prerequis": "<strong> Prérequis :</strong>💪Force 5",
        "cout": "2 point de don"
      },
      {
        "nom": "Jugement éclair",
        "description": "Si le Prêtre a effectué un sort ce tour ci, il peut effectuer une attaque au corp à corp avec une action secondaire.",
        "prerequis": "<strong> Prérequis :</strong>💪Force 3",
        "cout": "1 point de don"
      },
      {
        "nom": "Musique",
        "description": "Permet d'apprendre un instrument de musique (ou de savoir chanter) au choix, gagnant 2 de compétences sur les tests de compétence éloquence le nécéssitant.",
        "prerequis": "<strong> Prérequis :</strong>-",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Enchanteur",
    "description": "Dons accessibles aux enchanteurs.",
    "dons": [
      {
        "nom": "Réparateur de baguettes",
        "description": "Permet de regagner une charge de baguette, une fois par jour.",
        "prerequis": "<strong> Prérequis :</strong>-",
        "cout": "1 point de don"
      },
      {
        "nom": "Magie aléatoire destructrice",
        "description": "Permet de choisir et d'apprendre un sort de mage et de pouvoir le lancer à volonté. Le sort ne peut pas être changé par la suite.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Magie aléatoire de soutien",
        "description": "Permet de choisir et d'apprendre un sort de prêtre et de pouvoir le lancer à volonté. Le sort ne peut pas être changé par la suite.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Alteration risquée",
        "description": "Lorsque un sort d'alteration magique est effectué alors que la cible est au corps à corps, ses chances de critiques sont doublées.",
        "prerequis": "<strong> Prérequis :</strong>-",
        "cout": "1 point de don"
      }
    ]
  }
];
    window.OBJETS = {
  "objets": [
    {
      "nom": "Espadon",
      "numero": 1,
      "image": "",
      "description": "<i>Longue épée à deux mains, lourde mais puissante.</i>",
      "tags": [
        "Départ",
        "Arme",
        "Épée",
        "Deux mains"
      ],
      "effet": "<strong>Dégâts: </strong> Inflige (5  + Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 35",
      "poids": "⚖️ <strong>Poids:</strong> 2"
    },
    {
      "nom": "Simple épée",
      "numero": 2,
      "image": "",
      "description": "<i>Arme droite et équilibrée, conçue pour être maniée d’une seule main</i>",
      "tags": [
        "Départ",
        "Arme",
        "Épée",
        "Une main"
      ],
      "effet": "<span style=\"font-weight: 700; font-family: \" source=\"\" serif=\"\" pro\",=\"\" serif;=\"\" color:=\"\" rgb(74,=\"\" 44,=\"\" 23);=\"\" text-shadow:=\"\" rgba(0,=\"\" 0,=\"\" 0.05)=\"\" 0px=\"\" 1px=\"\" 2px;\"=\"\">Dégâts: </span> Inflige (2  + Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 20",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Dague en fer",
      "numero": 3,
      "image": "",
      "description": "<i>Petite lame simple, légère et maniable.</i>",
      "tags": [
        "Départ",
        "Arme",
        "Une main",
        "Dague"
      ],
      "effet": "<strong>Dégâts: </strong> Inflige (1  + Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Bâton en bois",
      "numero": 4,
      "image": "",
      "description": "<i>Long bâton solide, utilisé comme arme et appui.</i>",
      "tags": [
        "Départ",
        "Arme",
        "Deux mains",
        "Baton"
      ],
      "effet": "<strong>Dégâts: </strong> Inflige (2  + Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 5",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Gourdin",
      "numero": 5,
      "image": "",
      "description": "<i>Arme rudimentaire faite de bois dur. </i>",
      "tags": [
        "Départ",
        "Arme",
        "Une main",
        "Baton"
      ],
      "effet": "<strong>Dégâts: </strong> Inflige (1  + Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Arc simple",
      "numero": 6,
      "image": "",
      "description": "<i>Arc basique en bois, sans ornement.</i>",
      "tags": [
        "Départ",
        "Arme",
        "Deux mains",
        "Arc"
      ],
      "effet": "<strong>Portée: </strong> 15m.<br>\n<strong>Dégâts: </strong> Inflige (Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 30",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Bouclier en bois",
      "numero": 7,
      "image": "",
      "description": "<i>Un bouclier grossier taillé dans des planches épaisses, marqué de cicatrices de bataille.</i>",
      "tags": [
        "Départ",
        "Bouclier"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 2.",
      "prix": "🔷 <strong>Prix:</strong> 15",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Robe simple",
      "numero": 8,
      "image": "",
      "description": "<i>Une robe de toile modeste, aux plis fatigués mais encore emplis de dignité.</i>",
      "tags": [
        "Départ",
        "Armure",
        "Robe"
      ],
      "effet": "<strong>Effet:</strong> Augmente la Volonté de 1.",
      "prix": "🔷 <strong>Prix:</strong> 20",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Armure de cuir",
      "numero": 9,
      "image": "",
      "description": "<i>Une armure souple en cuir tanné, taillée pour offrir une protection rudimentaire.</i>",
      "tags": [
        "Départ",
        "Armure",
        "Armure légère"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 1.",
      "prix": "🔷 <strong>Prix:</strong> 30",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Armure en maille",
      "numero": 10,
      "image": "",
      "description": "<i>Une cotte de mailles dont chaque anneau forgé promet résistance et endurance au combat.</i>",
      "tags": [
        "Départ",
        "Armure",
        "Armure lourde"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 3.",
      "prix": "🔷 <strong>Prix:</strong> 65",
      "poids": "⚖️ <strong>Poids:</strong> 2"
    },
    {
      "nom": "Armure de plaque",
      "numero": 11,
      "image": "",
      "description": "<i>Une imposante armure de métal poli, dont les plaques luisantes forment une carapace presque impénétrable.</i>",
      "tags": [
        "Armure",
        "Armure lourde"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 6.",
      "prix": "🔷 <strong>Prix:</strong> 200",
      "poids": "⚖️ <strong>Poids:</strong> 2"
    },
    {
      "nom": "Petite potion de vie",
      "numero": 12,
      "image": "",
      "description": "<i>Une fiole écarlate dont le liquide vif régénère les blessures et ranime les forces vitales.</i>",
      "tags": [
        "Départ",
        "Consommable"
      ],
      "effet": "<strong>Effet:</strong> Rend 15 (critique : 25) points de vie au héros.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Petite potion de mana",
      "numero": "13",
      "image": "",
      "description": "<i>Une essence azur miroitante qui restaure l’énergie magique et ravive le flux des arcanes.</i>",
      "tags": [
        "Départ",
        "Consommable"
      ],
      "effet": "<strong>Effet:</strong> Rend 20 (critique : 35) points de mana au héros.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Baguette de boule de feu",
      "numero": 14,
      "image": "",
      "description": "<i>Une fine tige runique qui libère des flammes brûlantes au commandement de son porteur.</i>",
      "tags": [
        "Départ",
        "Consommable",
        "Catalyseur"
      ],
      "effet": "<strong>Effet:</strong> Remplace votre prochaine action principale par le sort de mage <span class=\"spell-link\" data-spell=\"Boule de Feu\" data-category=\"Sorts de Mage\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Boule de Feu</span>. <br><i>Les prérequis pour le sort ne sont pas requis mais le mana et l'intelligence du héros sont utilisés.</i>\n    <br><br><strong>Charges :</strong> 3",
      "prix": "🔷 <strong>Prix:</strong> 25",
      "poids": ""
    },
    {
      "nom": "Feuilleclaire",
      "numero": 15,
      "image": "",
      "description": "<i>Herbe des forêts profondes, aux feuilles luisantes et aux petites fleurs rosées. Appliquée directement sur la peau, elle referme les plaies et apaise la douleur presque instantanément.</i>",
      "tags": [
        "Départ",
        "Consommable",
        "Plante"
      ],
      "effet": "<strong>Effet:</strong> Rend 10 (critique : 20) points de vie au héros ou à une cible proche.\n<br>Tous les 5 points d'intelligence, augmente les soins de 1.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Nocteline",
      "numero": 16,
      "image": "",
      "description": "<i>une plante sombre aux fleurs violettes dont l’essence neutralise les venins et purifie le sang.</i>",
      "tags": [
        "Départ",
        "Consommable",
        "Plante"
      ],
      "effet": "<strong>Prérequis:</strong> Intelligence 5.<br>\n<strong>Effet:</strong> Soigne le héros ou une cible proche du poison.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Baguette de Sommeil",
      "numero": 17,
      "image": "",
      "description": "Description de l'objet.",
      "tags": [
        "Départ"
      ],
      "effet": "<strong>Effet:</strong> Description de l'effet de l'objet.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Baguette de sommeil",
      "numero": 18,
      "image": "",
      "description": "<i>Une tige sombre incrustée de gemmes lunaires, qui libère une aura ténébreuse plongeant ses cibles dans un profond sommeil enchanté.</i>",
      "tags": [
        "Départ",
        "Consommable",
        "Catalyseur"
      ],
      "effet": "<strong>Effet:</strong> Remplace votre prochaine action principale par le sort d'enchanteur <span class=\"spell-link\" data-spell=\"Sommeil\" data-category=\"Sorts d'Enchanteur\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Sommeil</span>. <br><i>Les prérequis pour le sort ne sont pas requis mais le mana et l'intelligence du héros sont utilisés.</i>\n    <br><br><strong>Charges :</strong> 3",
      "prix": "🔷 <strong>Prix:</strong> 30",
      "poids": ""
    }
  ],
  "filterSettings": {
    "visibleTags": [
      "Arme"
    ],
    "displayedFilterButtons": [
      "Arme",
      "Armure",
      "Consommable",
      "Bouclier"
    ]
  },
  "categoryDescription": "Équipements, armes, armures et objets divers que peuvent posséder les personnages.",
  "description": "Pour éviter le <strong>spoil</strong>, seuls les objets de départs sont visibles sans le <strong>mode maître de jeu</strong> d'actif. <br>Vous pouvez par contre rechercher un <strong>objet par ID</strong> quand le MJ vous indique que votre héros a trouvé un nouvel objet."
};
    window.MONSTRES = [
  {
    "nom": "Araignée Géante",
    "tags": [
      "Forêt"
    ],
    "image": "data/images/Monstres/foret/Monstre_Forêt_AraignéeGéante.png",
    "element": "Nuit",
    "pointsDeVie": 15,
    "armurePhysique": "0",
    "esquive": "2",
    "coupCritique": "1",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "3",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": "2",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": "5",
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Morsure venimeuse:</strong> Inflige 5 dégâts Physiques. <br> Si (resistance altérations &lt; 3)  + <span class=\"etat-link\" data-etat=\"Empoisonné\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Empoisonné</span> 1 pendant 5 tours.<br><br><strong>Toile:</strong> Portée 10m. <span class=\"etat-link\" data-etat=\"Entravé/Entoilé/Embourbé\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Entoile</span> la cible pendant 2 tour.",
    "butin": "<strong>Butin:</strong>",
    "monster-abilites": "AAAAAAAA",
    "monster-armurephysique": "0",
    "monster-coupcritique": "1",
    "monster-esquive": "2",
    "monster-resistancealterations": "3",
    "monster-coupcritiquesorts": "0",
    "monster-armureterre": "2",
    "monster-armureobscurite": "5"
  },
  {
    "nom": "Crabe des Bois",
    "tags": [
      "Forêt"
    ],
    "image": "data/images/Monstres/foret/Monstre_Forêt_CrabedesBois.png",
    "element": "Eau",
    "pointsDeVie": "30",
    "armurePhysique": "5",
    "esquive": "0",
    "coupCritique": "1",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "5",
    "armureFeu": 0,
    "armureEau": "5",
    "armureTerre": "2",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "Attaque deux fois<br>  <strong>Pinces acérées:</strong> Inflige 7 dégâts",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "Groink",
    "tags": [
      "Forêt"
    ],
    "image": "data/images/Monstres/foret/Monstre_Forêt_Groink.png",
    "element": "Terre",
    "pointsDeVie": "15",
    "armurePhysique": "0",
    "esquive": "1",
    "coupCritique": "0",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": 3,
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": "3",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": "2",
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Charge brutale:</strong> Fonce et Inflige 5 dégâts. Critique : <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span><br><strong>Lance rocher:</strong> Portée 15m,  4 dégats physiques.",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "Groinka",
    "tags": [
      "Forêt"
    ],
    "image": "data/images/Monstres/foret/Monstre_Forêt_Groinka.png",
    "element": "Terre",
    "pointsDeVie": "15",
    "armurePhysique": "0",
    "esquive": "0",
    "coupCritique": "0",
    "coupCritiqueSorts": "1",
    "resistanceAlterations": "4",
    "armureFeu": "0",
    "armureEau": "0",
    "armureTerre": "3",
    "armureAir": "0",
    "armureLumiere": 0,
    "armureObscurite": 2,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "Attaque : <span class=\"spell-link\" data-spell=\"Volée de pierres\" data-category=\"Sorts de Mage\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Volée de pierres</span>  <br>Soin : <span class=\"spell-link\" data-spell=\"Soin mineur\" data-category=\"Sorts de Prêtre\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Soin mineur</span> <br> Alteration: \n<span class=\"spell-link\" data-spell=\"Accroche terrestre\" data-category=\"Sorts d'Enchanteur\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Accroche terrestre</span>",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "Guêpe Géante",
    "tags": [
      "Forêt"
    ],
    "image": "data/images/Monstres/foret/Monstre_Forêt_GuêpeGéante.png",
    "element": "Air",
    "pointsDeVie": "15",
    "armurePhysique": 0,
    "esquive": "5",
    "coupCritique": "3",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "3",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": 0,
    "armureAir": "5",
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Volant</strong>: Necessite de sauter pour attaque au corps à corps.<br><strong>Dard: </strong> Inflige 5 degats physiques + 3 <span style=\"color: #22c55e; font-weight: bold;\">Air</span>. Critique : <span class=\"etat-link\" data-etat=\"Empoisonné\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Empoisonné</span> 1 , 5 tours",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "Ours des Bois",
    "tags": [
      "Forêt",
      "Boss"
    ],
    "image": "data/images/Monstres/foret/Monstre_Forêt_OursdesBois.png",
    "element": "Terre",
    "pointsDeVie": 60,
    "armurePhysique": 4,
    "esquive": 4,
    "coupCritique": 12,
    "coupCritiqueSorts": 6,
    "resistanceAlterations": 8,
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": 2,
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 1,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Griffes dévastatrices:</strong> Inflige 12 dégâts physiques à une cible.<br><strong>Rugissement:</strong> Terrorise tous les ennemis pendant 2 tours.<br><strong>Charge écrasante:</strong> Inflige 15 dégâts et étourdit pendant 1 tour.",
    "butin": "<strong>Butin:</strong> 80-150 pièces d'or, fourrure d'ours, griffes acérées."
  },
  {
    "nom": "Pouple de la forêt",
    "tags": [
      "Forêt"
    ],
    "image": "",
    "element": "Eau",
    "pointsDeVie": "10",
    "armurePhysique": "0",
    "esquive": "0",
    "coupCritique": "0",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "0",
    "armureFeu": 0,
    "armureEau": "5",
    "armureTerre": 0,
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Accroche:</strong> Inflige 4 dégâts physiques. S'attache à la cible.",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "Serpent de la forêt",
    "tags": [
      "Forêt"
    ],
    "image": "",
    "element": "Terre",
    "pointsDeVie": 20,
    "armurePhysique": "0",
    "esquive": 5,
    "coupCritique": "2",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": 3,
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": "5",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Morsure venimeuse:</strong> Inflige 5 dégâts Physiques. <br> Si (resistance altérations &lt; 3)  + <span title=\"Des dégats sont appliqués à chaque début de tour du lanceur, réduits ni par l'armure physique ni par l'armure élémentaire.\">Empoisonné</span>2 pendant 5 tours.<br><br>",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "Scarabée géant",
    "tags": [
      "Forêt"
    ],
    "image": "",
    "element": "Air",
    "pointsDeVie": 20,
    "armurePhysique": "3",
    "esquive": "0",
    "coupCritique": "0",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "5",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": 0,
    "armureAir": "5",
    "armureLumiere": 0,
    "armureObscurite": "5",
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Volant</strong>: Necessite de sauter pour attaque au corps à corps.<br><strong>Morsure: </strong> inflige 5 physique.",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "Boss Forêt",
    "tags": [
      "Forêt"
    ],
    "image": "",
    "element": "Terre",
    "pointsDeVie": "200",
    "armurePhysique": "3",
    "esquive": "0",
    "coupCritique": "2",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "10",
    "armureFeu": 0,
    "armureEau": "0",
    "armureTerre": "10",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": "5",
    "armureDivin": 0,
    "armureMalefique": "5",
    "abilites": "Double attaque.<br><strong>Attaque basique:</strong> Inflige 10 dégâts physiques. <br><strong>Hurlement:</strong> Tous les adversaires à 15m, avec Resistance altération &lt; 6, sont <span class=\"etat-link\" data-etat=\"Affaibli\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Affaibli</span>.  \n<br><b>Repoussoir</b>: Repousse une une cible à 10m. Inflige 5 dégats.\n<br><b>Appel </b>: Hurle et fait venir 2 Groinkas.",
    "butin": "<strong>Butin:</strong>"
  }
];
    window.IMAGES = {
  "images": {
    "subclass:Guerrier:Nain des montagnes": "https://i.ibb.co/Zpv02X9p/e8c10c36dc90.jpg",
    "subclass:Guerrier:Berserker": "https://i.ibb.co/DPYjyGVd/b85000c2afa4.jpg",
    "subclass:Mage:Érudit": "https://i.ibb.co/M5pcNmF9/05fa4e535010.jpg",
    "subclass:Mage:Elfe": "https://i.ibb.co/K1SMkgb/d738588e0528.jpg",
    "subclass:Prêtre:Inquisiteur": "https://i.ibb.co/dJ02RNMc/c9cd3553df7e.jpg",
    "subclass:Prêtre:Clerc Divin": "https://i.ibb.co/8gFGZYqJ/698304cc75ee.jpg",
    "subclass:Rôdeur:Voleur": "https://i.ibb.co/q3jSxDnQ/90e89c692b47.jpg",
    "subclass:Rôdeur:Chasseur": "https://i.ibb.co/70wP75z/53de7da9e55c.jpg",
    "subclass:Enchanteur:Esprit de la grande Fée": "https://i.ibb.co/Cswfsyzz/9920a4e75242.jpg",
    "subclass:Enchanteur:Lutin": "https://i.ibb.co/Fbspq9hP/dd5e7b366e0f.jpg",
    "sort:Sorts de Mage:Boule de Feu": "https://i.ibb.co/vCWmgrQ5/Boule-De-Feu.png",
    "sort:Sorts de Mage:Éclair": "https://i.ibb.co/h194qhvd/Eclair.png",
    "sort:Sorts de Mage:Vague déferlante": "https://i.ibb.co/BSHtL8K/Vague.png",
    "sort:Sorts de Prêtre:Châtiment": "https://i.ibb.co/JRPyXx1L/Chatiment-Sacr.png",
    "sort:Sorts de Prêtre:Soin mineur": "https://i.ibb.co/YBC2HSnK/Soin-Mineur.png",
    "sort:Sorts d'Enchanteur:Accroche terrestre": "https://i.ibb.co/27W4NtSQ/Accroche-Terre.png",
    "sort:Sorts d'Enchanteur:Accélération": "https://i.ibb.co/Vc072qQB/Acceleration.png",
    "sort:Sorts d'Enchanteur:Sommeil": "https://i.ibb.co/rKyTh27C/Sleep.png",
    "sort:Sorts de Prêtre:Nouveau Sort": "https://i.ibb.co/cXh57Pdn/ArmeLum.png",
    "sort:Sorts de Prêtre:Protection": "https://i.ibb.co/QvK52kxH/Protection.png",
    "subclass:Guerrier:Nain des montagnes:1": "https://i.ibb.co/FL9m5HJn/Nain.png",
    "subclass:Guerrier:Nain des montagnes:2": "https://i.ibb.co/wNnJxSbj/NaineF.png",
    "subclass:Guerrier:Berserker:1": "https://i.ibb.co/YBWFbTKv/berseker.png",
    "subclass:Guerrier:Berserker:2": "https://i.ibb.co/20b74x2R/Berseker-F.png",
    "subclass:Mage:Érudit:1": "https://i.ibb.co/N8qT2Hf/Mage.png",
    "subclass:Mage:Érudit:2": "https://i.ibb.co/LdcPDSJQ/MageF.png",
    "subclass:Mage:Elfe:2": "https://i.ibb.co/VWDTjY8H/ElfeF.png",
    "subclass:Mage:Elfe:1": "https://i.ibb.co/gFVKrTcV/Elfe.png",
    "subclass:Prêtre:Inquisiteur:1": "https://i.ibb.co/tMcsCB8s/Inquisiteur.png",
    "subclass:Prêtre:Clerc Divin:1": "https://i.ibb.co/209W4ZHW/Pr-tre.png",
    "subclass:Rôdeur:Voleur:1": "https://i.ibb.co/NghMq11n/Voleur-min.png",
    "subclass:Rôdeur:Voleur:2": "https://i.ibb.co/h1BtkGMX/VoleurF.png",
    "subclass:Rôdeur:Chasseur:1": "https://i.ibb.co/yF8jrJYr/Chasseur-min.png",
    "subclass:Rôdeur:Chasseur:2": "https://i.ibb.co/3mQjLJbp/Chasseur-F.png",
    "subclass:Enchanteur:Esprit de la grande Fée:1": "https://i.ibb.co/VY9cQHNh/F-eM.png",
    "subclass:Enchanteur:Esprit de la grande Fée:2": "https://i.ibb.co/pjxDfXBC/F-e.png",
    "subclass:Enchanteur:Lutin:1": "https://i.ibb.co/6cxkMW1d/Lutin.png",
    "subclass:Enchanteur:Lutin:2": "https://i.ibb.co/qLbjJhxw/LutinF.png",
    "subclass:Prêtre:Inquisiteur:2": "https://i.ibb.co/LXwmWYR3/Inquisiteur-F.png",
    "subclass:Prêtre:Clerc Divin:2": "https://i.ibb.co/HfBVNLM3/PretreF.png",
    "sort:Sorts de Prêtre:Arme de lumière": "https://i.ibb.co/cXh57Pdn/ArmeLum.png",
    "objet:Épée Longue": "https://i.ibb.co/35rpP6ZS/Epee2M1.png",
    "objet:Espadon": "https://i.ibb.co/35rpP6ZS/Epee2M1.png",
    "objet:Simple épée": "https://i.ibb.co/PsSXvSXx/Epee1.png",
    "objet:Dague en fer": "https://i.ibb.co/1fCwy6cR/Dague1.png",
    "objet:Bâton en bois": "https://i.ibb.co/PsyCNw86/Baton1.png",
    "objet:Gourdin": "https://i.ibb.co/whZCKww0/Baton2.png",
    "objet:Arc simple": "https://i.ibb.co/cKb1JKZQ/Arc1.png",
    "objet:Bouclier en bois": "https://i.ibb.co/67bK4Bw8/Bouclier1.png",
    "objet:Robe simple": "https://i.ibb.co/VYFpnz8h/Robe1.png",
    "objet:Armure de cuir": "https://i.ibb.co/9Hkw2VFb/Armure-Cuir1.png",
    "objet:Armure en maille": "https://i.ibb.co/cXtwzw5b/Armure-Lourde1.png",
    "objet:Armure de plaque": "https://i.ibb.co/fVg5Fp6h/Armure-Lourde2.png",
    "subclass:Guerrier:Aventurier:1": "https://i.ibb.co/9HcQkbb2/Aventurier.png",
    "subclass:Guerrier:Aventurier:2": "https://i.ibb.co/nH8Yj3h/Aventurier-F.png",
    "objet:Petite potion de vie": "https://i.ibb.co/Mw2Qb8Y/LifePot1.png",
    "objet:Petite potion de mana": "https://i.ibb.co/MkwzbQ3S/Potion-Mana1.png",
    "objet:Baguette de boule de feu": "https://i.ibb.co/JwXs3k2V/Baguette-Feu.png",
    "objet:Feuilleclaire": "https://i.ibb.co/bMDstDVV/Herb1.png",
    "objet:Nocteline": "https://i.ibb.co/7JpQ7Kr7/Herb2.png",
    "objet:Nouvel Objet": "https://i.ibb.co/bMXNS4gy/Baguette-Nuit.png",
    "objet:Baguette de sommeil": "https://i.ibb.co/bMXNS4gy/Baguette-Nuit.png",
    "monster:Araignée Géante": "https://i.ibb.co/b0XHjQJ/Monstre-For-t-Araign-e.png",
    "monster:Crabe des Bois": "https://i.ibb.co/7dY3GgJS/Monstre-For-t-Crab.png",
    "monster:Groink": "https://i.ibb.co/MDngQGcS/Monstre-For-t-Groink.png",
    "monster:Groinka": "https://i.ibb.co/YThB7Q29/Monstre-For-t-Groink-Chaman.png",
    "monster:Guêpe Géante": "https://i.ibb.co/bjSq3pPj/Monstre-For-t-Guepe-Geante.png",
    "monster:Ours des Bois": "https://i.ibb.co/N2NcD6n2/Monstre-For-t-Ours.png",
    "monster:Pouple de la forêt": "https://i.ibb.co/0jG2WLsv/Monstre-For-t-Poulpe.png",
    "monster:Serpent de la forêt": "https://i.ibb.co/svhHLvKZ/Monstre-For-t-Serpent.png",
    "monster:Scarabée géant": "https://i.ibb.co/wF5bRvts/Monstre-For-t-Scarabe-Geant.png",
    "monster:Boss Forêt": "https://i.ibb.co/1JR11CC7/Monstre-For-t-Boss.png",
    "sort:Sorts de Mage:Volée de pierres": "https://i.ibb.co/GfPFdZPG/Volee-Pierre.png"
  },
  "meta": {
    "total_images": 73,
    "exported_date": "2025-08-26",
    "note": "Ces images incluent les nouvelles images uploadées"
  }
};
    
    // TOC Structure for advanced navigation
    window.TOC_STRUCTURE = {
  "sections": [
    {
      "id": "heros",
      "title": "🦸 Héros",
      "icon": "🦸",
      "description": "Création et développement des personnages",
      "collapsed": false,
      "items": [
        {
          "type": "page",
          "id": "creation",
          "title": "Création d'un personnage",
          "icon": "🎭"
        },
        {
          "type": "category",
          "id": "classes",
          "title": "Classes",
          "icon": "⚔️",
          "items": "CLASSES"
        },
        {
          "type": "category",
          "id": "dons",
          "title": "Dons",
          "icon": "🎖️",
          "items": "DONS"
        }
      ]
    },
    {
      "id": "arsenal",
      "title": "⚔️ Arsenal",
      "icon": "⚔️",
      "description": "Sorts, objets et équipements",
      "collapsed": false,
      "items": [
        {
          "type": "category",
          "id": "sorts",
          "title": "Sorts",
          "icon": "🔮",
          "items": "SORTS"
        },
        {
          "type": "page",
          "id": "objets",
          "title": "Objets",
          "icon": "📦"
        }
      ]
    },
    {
      "id": "regles",
      "title": "📚 Règles",
      "icon": "📚",
      "description": "Mécaniques de jeu et références",
      "collapsed": false,
      "items": [
        {
          "type": "page",
          "id": "elements",
          "title": "Éléments",
          "icon": "🌟"
        },
        {
          "type": "page",
          "id": "stats",
          "title": "Statistiques",
          "icon": "📊"
        },
        {
          "type": "page",
          "id": "competences-tests",
          "title": "Compétences & Tests",
          "icon": "🎯"
        },
        {
          "type": "page",
          "id": "etats",
          "title": "États",
          "icon": "⚡"
        },
        {
          "type": "page",
          "id": "combat",
          "title": "Combat",
          "icon": "⚔️"
        },
        {
          "type": "page",
          "id": "gestion-des-ressources",
          "title": "Gestion des ressources",
          "icon": "💎"
        }
      ]
    },
    {
      "id": "maitre-de-jeu",
      "title": "🎭 Maître de jeu",
      "icon": "🎭",
      "description": "Outils et ressources pour le Maître de jeu",
      "collapsed": false,
      "requiresMJ": true,
      "items": [
        {
          "type": "page",
          "id": "monstres",
          "title": "Monstres",
          "icon": "👹"
        }
      ]
    },
    {
      "id": "monde",
      "title": "🌍 Monde",
      "icon": "🌍",
      "description": "Univers et connaissances du monde",
      "collapsed": false,
      "items": [
        {
          "type": "page",
          "id": "histoire",
          "title": "Histoire",
          "icon": "📜"
        },
        {
          "type": "page",
          "id": "dieux",
          "title": "Dieux",
          "icon": "🏛️"
        },
        {
          "type": "page",
          "id": "geographie",
          "title": "Geographie",
          "icon": "📜"
        }
      ]
    }
  ]
};
    
    // Build STATIC_PAGES correctly by combining individual page data
    window.STATIC_PAGES = {
      'creation': {
  "page": "creation",
  "title": "Création d'un personnage",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "",
      "id": "section-0"
    },
    {
      "type": "card",
      "id": "etapes-creation",
      "title": "Étapes de création",
      "content": "<ol><li>Choisir une <strong>classe</strong> puis une <strong>sous‑classe</strong>.</li><li>Choisir un <strong>élément</strong> d'affiliation.</li><li>Choisir les <strong>dons</strong> (avec 2 points de dons).</li><li>Choisir l'<strong>équipement</strong> de départ (avec 100 éclats).</li><li>Définir le <strong>nom</strong>, l'<strong>histoire</strong> et l'<strong>apparence</strong>.</li><li>Remplir sa feuille de personnage.</li></ol>",
      "deletable": true,
      "sectionName": "Étapes de création"
    }
  ]
},
      'elements': {
  "page": "elements",
  "title": "Elements",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "elements-system",
      "title": "Système d'éléments",
      "content": "<p>Il existe huit éléments, chacun ayant un opposé. Chaqué Héros où monstre possède un élément d'affiliation.<br><br> Une créature affiliée à un élément :<br> - Reçoit <strong>deux fois moins </strong>de dégats venant des sorts et attaques de cet élément, et ne peut pas recevoir d'effet critique d'une alteration magique de cet élément.<br>- Recevra systématiquement des <strong>effets critiques</strong> venant des sorts et altérations de l'élément opposé. Les dégats élémentaires d'une attaque physique (venant d'un objet ou sort) voit ses dégats doublés s'il est d'un élément opposé.</p>"
    },
    {
      "type": "card",
      "id": "element-pairs",
      "title": "Paires opposées",
      "content": "<div class=\"element-pairs\"><div class=\"pair\">🔥 <span style=\"color: #ff6b35; font-weight: bold;\">Feu</span> ⟷ 💧 <span style=\"color: #4682b4; font-weight: bold;\">Eau</span></div><div class=\"pair\">🤎 <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> ⟷ 🟢 <span style=\"color: #22c55e; font-weight: bold;\">Air</span></div><div class=\"pair\">☀️ <span style=\"color: #ffd700; font-weight: bold;\">Lumière</span> ⟷ ⚫ <span style=\"color: #1a1a1a; font-weight: bold;\">Nuit</span></div><div class=\"pair\">⚪ <span style=\"color: #f5f5f5; font-weight: bold; background: rgba(100, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;\">Divin</span> ⟷ 🟣 <span style=\"color: #8b5cf6; font-weight: bold;\">Maléfique</span></div></div>"
    },
    {
      "type": "grid",
      "cols": 2,
      "content": [
        {
          "type": "card",
          "id": "element-defense",
          "title": "Défense",
          "content": "<p>Certaines armures/objets/bonus peuvent procurer une armure spécifique à un élément. Il faudra alors déduire au resultat final. Le calcul de dégats se fait dans cet ordre :</p><div><strong>Dégats → critique → ×0.5 si affiliation élément → réduction de l'armure</strong></div>",
          "deletable": true,
          "sectionName": "Défense"
        },
        {
          "type": "card",
          "id": "element-attack",
          "title": "Attaque",
          "content": "<p>Une attaque ne peut avoir qu'<strong>un seul élément</strong> (en plus d'éventuels dégats physiques). Si plusieurs sorts/équipements/bonus donnent un élément à l'attaque, le héros devra choisir quel est l'élément utilisé.</p> <br> Plusieurs bonus d'un même élément peuvent se cumuler.",
          "deletable": true,
          "sectionName": "Attaque"
        }
      ]
    }
  ]
},
      'stats': {
  "page": "stats",
  "title": "Statistiques",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "stats-base",
      "title": "Statistiques de base",
      "content": "<hr><div class=\"stats-grid\"><div class=\"stat-card\"><h4>💪 Force</h4><p>Améliore les dégâts physiques.</p></div><hr><div class=\"stat-card\"><h4>🛡️ Endurance</h4><p>Les points de vie maximum sont de : <strong>(10 + 2 x Endurance)</strong></p><p>Un repos régénère des points de vie égaux à l'endurance</p></div><hr><div class=\"stat-card\"><h4>🏃 Agilité</h4><p>Chaque 5 points ajoutent <strong>+1</strong> aux jets d'esquive et de critique physique.</p></div><hr><div class=\"stat-card\"><h4>🧠 Intelligence</h4><p>Détermine la puissance des sorts.</p></div><hr><div class=\"stat-card\"><h4>⚡ Volonté</h4><p>Le mana maximum est de : <strong>(20 + 2 x Volonté)</strong></p><p>Augmente la Résistance altérations.</p></div><hr><div class=\"stat-card\"><h4>🍀 Chance</h4><p>Améliore la Fortune d'autant.</p><p>De plus, chaque 5 points ajoutent <strong>+1</strong> aux chances de coup critique avec les sorts et les consommables.</p></div></div>",
      "deletable": true,
      "sectionName": "Statistiques de base"
    },
    {
      "type": "card",
      "id": "stats-new-3-1755784997112",
      "title": "Statistiques secondaires",
      "content": "<hr><br><br><strong>Chance de coup critique </strong> : blabla.<br><hr><br><strong>Esquive </strong> : blablabla.<br><hr><br><strong>Résistance altérations </strong> : blablabla.<br><hr><br><strong>Armure physique </strong> : blablabla.<br><hr><br><strong>Armure élémentaire </strong> : blablabla.<br><hr><br><strong>Mana </strong> : blablabla.<br><hr><br><strong>Vie </strong> : blablabla.<br><hr><br><strong>Fortune</strong> : blablabla.<br><hr><br>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'competences-tests': {
  "page": "competences-tests",
  "title": "Compétences & Tests",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "grid",
      "cols": 2,
      "content": [
        {
          "type": "card",
          "id": "efforts",
          "title": "Efforts",
          "content": "<ul><li>Chaque héros dispose de 3 Efforts maximum.</li><li>Les héros récupèrent des efforts lors de repos courts ou longs.</li><li>Les Efforts peuvent être dépensés pour améliorer un test de compétence.</li></ul>",
          "deletable": true,
          "sectionName": "Efforts"
        },
        {
          "type": "card",
          "id": "competences-list",
          "title": "Compétences",
          "content": "<ul><li><em>Hardiesse</em>: Pousser, casser, sauter…</li><li><em>Finesse</em>: Crocheter, fabriquer, être discret…</li><li><em>Coordination</em>: Percevoir, équilibre, piloter…</li><li><em>Réflexion</em>: Savoir, comprendre, deviner…</li><li><em>Éloquence</em>: Persuader, mentir, intimider…</li></ul>",
          "deletable": true,
          "sectionName": "Compétences"
        }
      ]
    },
    {
      "type": "card",
      "id": "tests",
      "title": "Tests de compétences",
      "content": "<p>Quand un MJ annonce un test de compétence, un héros peut choisir de dépenser des efforts pour booster sa compétence. La difficulté d'un test est seule connue du MJ, et est entre 1 et 5 (Exigeant, Complexe , Éprouvant, Prodigieux , <strong>Impossible</strong>).</p><p>Une fois le test résolu, le Maître de Jeu annonce le résultat. Si le joueur a dépensé plus d'Efforts que nécessaire, l'excédent est perdu.</p><br> A noter que certaines actions sont impossibles à réaliser et un héros peut alors s'épuiser pour rien, s'il n'a pas bien évalué la difficulté de la tâche. A l'inverse, les tâches simples ne demandent pas de test de compétences.",
      "deletable": true,
      "sectionName": "Tests de compétences"
    }
  ]
},
      'etats': {
  "page": "etats",
  "title": "Etats",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "Lorsque un joueur subit un état, vous pouvez prendre une carte ou note pour avoir un rappel de l'effet. De plus, si c'est un état à durée limité, vous pouvez prendre un dé et le placer face au nombre de tour restant (en oubliant pas de changer sa valeur chaque début de tour).<br> Quand vous infligez des effets/alterations à un monstre, vous pouvez également utiliser un dé pour rappel (potentiellement d'une autre couleur, pour aider).\n<br>"
    },
    {
      "type": "card",
      "id": "a-terre",
      "title": "A terre",
      "content": "<p>Ne peut plus faire d'actions.</p><p> Ne peut plus esquiver.</p><p> Doit dépenser une action secondaire pour se relever.</p>",
      "deletable": true,
      "sectionName": "A terre"
    },
    {
      "type": "card",
      "id": "endormi-effraye",
      "title": "Endormi/assomé/Effrayé",
      "content": "<p>Ne peut plus faire d'actions.</p><p> Ne peut plus esquiver.</p><p> Des dégats infligés à la créature la sort de son état.</p>",
      "deletable": true,
      "sectionName": "Endormi/assomé/Effrayé"
    },
    {
      "type": "card",
      "id": "etats-new-4-1755725440741",
      "title": "Ralenti",
      "content": "Vitesse de déplacement réduite de moitié.<br> Impossible de sauter ou d'esquiver.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-5-1755762657383",
      "title": "Empoisonné",
      "content": "Des dégats sont appliqués à chaque début de tour du lanceur, réduits ni par l'armure physique ni par l'armure élémentaire.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-6-1755762796465",
      "title": "Entravé/Entoilé/Embourbé",
      "content": "<p>Ne peut plus faire d'actions.</p><p>Ne peut plus esquiver.</p> Le héros ou un allié peut sortir le héros de l'état via un test de compétence hardiesse.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-7-1755762977439",
      "title": "Affaibli",
      "content": "Les dégats physiques effectués sont réduits de moitiés. Les tests de hardiesse ont une difficulté de 2 plus élevés.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-para-8-1755891140510",
      "title": "Nouveau paragraphe",
      "content": "<p>Contenu du nouveau paragraphe.</p>",
      "deletable": true,
      "sectionName": "Nouveau paragraphe"
    }
  ]
}
    };
    
    // Static pages configuration
    window.STATIC_PAGES_CONFIG = {};
    
    // Mark as standalone version for renderer
    window.STANDALONE_VERSION = true;
    
    // Initialize app when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      // Ensure dev mode is off
      document.body.className = 'dev-off';
      
      // Wait a bit to ensure all modules are loaded
      setTimeout(function() {
        // Initialize JdrApp if it exists
        if (window.JdrApp && window.JdrApp.init) {
          console.log('Initializing JdrApp...');
          window.JdrApp.init();
        } else {
          console.error('JdrApp not found!', window.JdrApp);
        }
      }, 100);
    });
  
// ============================================================================
// JDR-BAB APPLICATION - CORE MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // MAIN APPLICATION NAMESPACE
  // ========================================
  window.JdrApp = {
    // Core data
    data: {
      SORTS: null,
      CLASSES: null,
      DONS: null,
      OBJETS: null,
      MONSTRES: null,
      STATIC_PAGES: {},
      editedData: {}
    },
    
    // Application state
    state: {
      isMJ: false // Boolean pour contrôler l'accès MJ
    },
    
    // Core modules
    modules: {
      router: {},
      renderer: {},
      editor: {},
      storage: {},
      images: {}
    },
    
    // Utilities
    utils: {
      dom: {},
      events: {},
      data: {}
    },

    // Initialization
    async init() {
      try {
        await this.loadData();
        await this.loadContent();
        this.initializeModules();
        
        // Execute data validation after all modules are loaded
        setTimeout(() => {
          this.validateDataIntegrity();
        }, 500);
      } catch (error) {
        console.error('Failed to initialize JdrApp:', error);
      }
    },

    async loadData() {
      try {
        // Check if we're in standalone mode (data already injected)
        if (window.SORTS && window.CLASSES && window.DONS && window.OBJETS && window.STATIC_PAGES) {
          const sorts = window.SORTS;
          const classes = window.CLASSES;
          const dons = window.DONS;
          const objets = window.OBJETS;
          let monstres = window.MONSTRES || [];
          
          // Safety check - if MONSTRES is not an array, it might be page config
          if (!Array.isArray(monstres)) {
            console.warn('window.MONSTRES is not an array, clearing corrupted data:', monstres);
            this.clearCorruptedMonsterData();
            monstres = [];
          }
          
          const staticPagesData = window.STATIC_PAGES;
          const staticPagesConfig = window.STATIC_PAGES_CONFIG || {};
          
          this.data.SORTS = sorts;
          this.data.CLASSES = classes;
          this.data.DONS = dons;
          this.data.OBJETS = objets;
          this.data.MONSTRES = monstres;
          this.data.STATIC_PAGES = staticPagesData;
          this.data.STATIC_PAGES_CONFIG = staticPagesConfig;
          
          window.SORTS = sorts;
          window.CLASSES = classes;
          window.DONS = dons;
          window.OBJETS = objets;
          window.MONSTRES = monstres;
          window.STATIC_PAGES = staticPagesData;
          window.STATIC_PAGES_CONFIG = staticPagesConfig;
          
          // Load stored edits AFTER setting up the data structure
          this.loadStoredEditsEarly();
          
          // Initialize default filters for objects
          this.initializeDefaultFilters();
          return;
        }
        
        // Development mode - fetch files
        const [sorts, classes, dons, objets, monstres, staticPagesConfig, tocStructure] = await Promise.all([
          fetch('data/sorts.json').then(r => r.json()),
          fetch('data/classes.json').then(r => r.json()),
          fetch('data/dons.json').then(r => r.json()),
          fetch('data/objets.json').then(r => r.json()),
          fetch('data/monstres.json').then(r => r.json()),
          fetch('data/static-pages-config.json').then(r => r.json()),
          fetch('data/toc-structure.json').then(r => r.json())
        ]);

        const staticPagesData = {};
        const activePages = staticPagesConfig.pages.filter(page => page.active);
        
        for (const pageConfig of activePages) {
          try {
            const pageData = await fetch(`data/${pageConfig.file}`).then(r => r.json());
            staticPagesData[pageConfig.id] = pageData;
          } catch (error) {
            console.warn(`Failed to load static page ${pageConfig.id}:`, error);
          }
        }

        this.data.SORTS = sorts;
        this.data.CLASSES = classes;
        this.data.DONS = dons;
        this.data.OBJETS = objets;
        this.data.MONSTRES = monstres;
        this.data.STATIC_PAGES = staticPagesData;
        this.data.STATIC_PAGES_CONFIG = staticPagesConfig;
        this.data.TOC_STRUCTURE = tocStructure;

        window.SORTS = sorts;
        window.CLASSES = classes;
        window.DONS = dons;
        window.OBJETS = objets;
        window.MONSTRES = monstres;
        window.STATIC_PAGES = this.data.STATIC_PAGES;
        window.STATIC_PAGES_CONFIG = this.data.STATIC_PAGES_CONFIG;
        window.TOC_STRUCTURE = this.data.TOC_STRUCTURE;
        
        // Load stored edits in development mode (after data is loaded)
        this.loadStoredEditsEarly();
        
        // Initialize default filters for objects
        this.initializeDefaultFilters();
      } catch (error) {
        console.error('Failed to load data:', error);
        throw error;
      }
    },

    async loadContent() {
      try {
        const viewsDiv = document.getElementById('views');
        if (viewsDiv) {
          const loadingDiv = document.getElementById('app-loading');
          if (loadingDiv) {
            loadingDiv.innerHTML = '<!-- Content will be generated by renderer -->';
          }
        } else {
          const contentHTML = await this.getContentHTML();
          const loadingDiv = document.getElementById('app-loading');
          if (loadingDiv) {
            loadingDiv.outerHTML = contentHTML;
          }
        }
      } catch (error) {
        console.error('Failed to load content:', error);
        throw error;
      }
    },

    async getContentHTML() {
      // This would ideally load from a separate HTML file
      // For now, we'll return the content structure
      return `
        <div class="shell">
          <button aria-controls="sidebar" aria-expanded="false" aria-label="Ouvrir le sommaire" class="menu-toggle" id="menuToggle" style="display:none">☰ Sommaire</button>
          <div class="backdrop" hidden="" id="backdrop"></div>
          <main class="page">
            <aside class="sidebar" id="sidebar">
              <div class="panel">
                <div class="searchbar">
                  <input autocomplete="off" id="search" placeholder="Rechercher une règle, une classe…">
                  <button class="btn" id="clear" title="Effacer">✖</button>
                </div>
                <div class="tools">
                  <button class="btn small" id="devToggle" title="Activer/désactiver le mode développeur">🛠 Dev Mode: OFF</button>
                </div>
                <div class="dev-toolbox" id="devToolbox" style="display: none;">
                  <!-- Dev toolbox content will be injected here -->
                </div>
                <div class="toc" id="toc">
                  <!-- Table of contents will be injected here -->
                </div>
              </div>
            </aside>
            <div id="views">
              <!-- Dynamic content will be injected here -->
            </div>
          </main>
          <footer></footer>
        </div>
      `;
    },

    // Load stored edits early in the loading process (before rendering)
    loadStoredEditsEarly() {
      // Ne plus charger automatiquement le localStorage
      // Laisser les JSON files être la source de vérité
    },

    initializeModules() {
      if (this.utils.events.init) this.utils.events.init();
      if (this.utils.dom.init) this.utils.dom.init();
      if (this.modules.images.init) this.modules.images.init();
      if (this.modules.renderer.init) this.modules.renderer.init();
      if (this.modules.router.init) this.modules.router.init();
      if (this.modules.editor.init) this.modules.editor.init();
      if (this.modules.storage.init) this.modules.storage.init();
      if (this.modules.ui.init) this.modules.ui.init();
    },

    // Force reload JSON data (clear localStorage cache)
    forceReloadData() {
      // Effacer seulement les éditions temporaires
      localStorage.removeItem('jdr-bab-edits');
      localStorage.removeItem('jdr-bab-last-modified');
      window.location.reload();
    },

    // Clear corrupted localStorage data specifically for monsters
    clearCorruptedMonsterData() {
      console.log('Clearing corrupted monster data from localStorage');
      const edits = JSON.parse(localStorage.getItem('jdr-bab-edits') || '{}');
      
      // Remove any MONSTRES data that might be corrupted
      if (edits.MONSTRES) {
        delete edits.MONSTRES;
        localStorage.setItem('jdr-bab-edits', JSON.stringify(edits));
        console.log('Removed corrupted MONSTRES from localStorage');
      }
      
      // Also clear any other monster-related storage
      if (edits.monster) {
        delete edits.monster;
        localStorage.setItem('jdr-bab-edits', JSON.stringify(edits));
        console.log('Removed corrupted monster data from localStorage');
      }
    },

    // Public method to manually clear storage via console
    clearMonsterStorage() {
      this.clearCorruptedMonsterData();
      this.forceReloadData();
    },

    // Initialize default filters for objects on page load
    initializeDefaultFilters() {
      try {
        // Only initialize if OBJETS exists and ContentTypes is available
        if (window.OBJETS && window.ContentTypes?.objet?.filterConfig) {
          const defaultTags = window.ContentTypes.objet.filterConfig.defaultVisibleTags || [];
          
          // Initialize filterSettings only if it doesn't exist or is empty
          if (!window.OBJETS.filterSettings || !window.OBJETS.filterSettings.visibleTags) {
            window.OBJETS.filterSettings = {
              visibleTags: [...defaultTags], // Active filters (defaults only)
              displayedFilterButtons: [...defaultTags] // Displayed filter buttons (defaults initially)
            };
          }
          
          // Ensure displayedFilterButtons exists even if visibleTags already existed
          if (!window.OBJETS.filterSettings.displayedFilterButtons) {
            window.OBJETS.filterSettings.displayedFilterButtons = [...defaultTags];
          }
          
        }
      } catch (error) {
        console.error('Error initializing default filters:', error);
      }
    },

    // Validate data integrity on application startup
    validateDataIntegrity() {
      // console.log('🔍 Validating data integrity on startup...');
      
      try {
        // Validate monster data if available
        if (window.MONSTRES && Array.isArray(window.MONSTRES) && JdrApp.modules.images) {
          // Force sync monster images and paths
          const correctedCount = JdrApp.modules.images.forceSyncMonsterImages();
          
          if (correctedCount > 0) {
            // console.log(`✅ Startup validation: ${correctedCount} monster image paths corrected`);
          }
        }
        
        // Validate UnifiedEditor if available
        if (JdrApp.modules.editor && JdrApp.modules.editor.validateAndRepairMonsterData) {
          JdrApp.modules.editor.validateAndRepairMonsterData();
        }
        
        // console.log('✅ Data integrity validation completed');
        
      } catch (error) {
        console.error('❌ Error during data integrity validation:', error);
      }
    }
  };

  // Auto-initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => window.JdrApp.init());
  } else {
    window.JdrApp.init();
  }

})();
// ============================================================================
// JDR-BAB APPLICATION - CONTENT TYPES CONFIGURATION
// ============================================================================

(() => {
  "use strict";

  window.ContentTypes = {
    spell: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        element: { type: 'select', label: 'Élément', required: true, options: ['Feu', 'Eau', 'Terre', 'Air', 'Lumière', 'Nuit', 'Divin', 'Maléfique'] },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'Prérequis', required: true },
        portee: { type: 'richtext', label: 'Portée', required: true },
        tempsIncantation: { type: 'richtext', label: "Temps d'incantation", required: true },
        coutMana: { type: 'richtext', label: 'Coût mana', required: true },
        resistance: { type: 'richtext', label: 'Résistance', required: true },
        effetNormal: { type: 'richtext', label: 'Effet normal', required: true },
        effetCritique: { type: 'richtext', label: 'Effet critique', required: false }
      },
      editMapping: {
        'spell-name': 'nom',
        'spell-element': 'element',
        'spell-description': 'description',
        'spell-prerequis': 'prerequis',
        'spell-portee': 'portee',
        'spell-mana': 'coutMana',
        'spell-temps-incantation': 'tempsIncantation',
        'spell-resistance': 'resistance',
        'spell-effect-normal': 'effetNormal',
        'spell-effect-critical': 'effetCritique'
      },
      identifiers: {
        name: 'nom',
        category: 'sorts'
      },
      template: 'spell-card',
      container: 'sorts',
      dataKey: 'SORTS',
      icons: { 
        category: '🔮', 
        item: '✨',
        add: '➕',
        delete: '🗑️'
      },
      defaultValues: {
        nom: "Nouveau Sort",
        element: "Feu",
        description: "Lance une boule de Feu sur un adversaire.",
        prerequis: "📋 <strong>Prérequis:</strong> Niveau 1",
        portee: "🎯 <strong>Portée:</strong> 20m",
        tempsIncantation: "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        coutMana: "🔵 <strong>Coût mana:</strong> 3",
        resistance: "<strong>Sans effet si:</strong> Esquive.",
        effetNormal: "<strong>Effet:</strong> Inflige 5 dégats de <span style='color: #e25822; font-weight: bold;'>Feu</span> à la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        effetCritique: "<strong>Coup Critique:&nbsp;</strong>&nbsp;Double les dégâts et enflamme la cible."
      }
    },

    don: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'Prérequis', required: true },
        cout: { type: 'richtext', label: 'Coût', required: true }
      },
      editMapping: {
        'don-name': 'nom',
        'don-description': 'description',
        'don-prerequis': 'prerequis',
        'don-cout': 'cout'
      },
      identifiers: {
        name: 'nom',
        category: 'dons'
      },
      template: 'don-card',
      container: 'dons',
      dataKey: 'DONS',
      icons: { 
        category: '🎖️', 
        item: '🏆',
        add: '➕',
        delete: '🗑️'
      },
      defaultValues: {
        nom: "Nouveau Don",
        description: "Description du don.",
        prerequis: "Aucun prérequis",
        cout: "1 point de don"
      }
    },

    class: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        resume: { type: 'textarea', label: 'Résumé', required: true },
        capacites: { type: 'list', label: 'Capacités', required: true }
      },
      editMapping: {
        'class-name': 'nom',
        'class-resume': 'resume',
        'class-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: null
      },
      template: 'class-page',
      container: 'classes',
      dataKey: 'CLASSES',
      icons: { 
        category: '⚔️', 
        item: '🛡️',
        add: '➕',
        delete: '🗑️'
      }
    },

    subclass: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        base: { type: 'stats', label: 'Statistiques de base', required: true },
        progression: { type: 'richtext', label: 'Progression', required: true },
        capacites: { type: 'list', label: 'Capacités', required: true }
      },
      editMapping: {
        'subclass-name': 'nom',
        'subclass-description': 'description',
        'subclass-stats': 'base',
        'subclass-progression': 'progression',
        'subclass-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: 'sousClasses',
        parent: 'class'
      },
      template: 'subclass-card',
      icons: { 
        item: '⚡',
        add: '➕',
        delete: '🗑️'
      },
      defaultValues: {
        nom: "Nouvelle sous-classe",
        description: "Description de la sous-classe",
        base: {
          Force: 3,
          Agilité: 3,
          Endurance: 3,
          Intelligence: 3,
          Volonté: 3,
          Chance: 3
        },
        progression: "<strong>📈 Progression par niveau:</strong> +1 Force 💪, +1 Agilité 🏃",
        capacites: [
          "<em>Capacité unique</em>: Description de la capacité spéciale de cette sous-classe."
        ]
      }
    },

    objet: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        numero: { type: 'number', label: 'Numéro', required: true },
        image: { type: 'text', label: 'Image', required: false },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        effet: { type: 'richtext', label: 'Effet', required: true },
        prix: { type: 'richtext', label: 'Prix', required: true },
        poids: { type: 'richtext', label: 'Poids', required: true }
      },
      editMapping: {
        'objet-name': 'nom',
        'objet-numero': 'numero',
        'objet-image': 'image',
        'objet-description': 'description',
        'objet-tags': 'tags',
        'objet-effet': 'effet',
        'objet-prix': 'prix',
        'objet-poids': 'poids'
      },
      identifiers: {
        name: 'nom',
        category: 'objets'
      },
      template: 'objet-card',
      container: 'objets',
      dataKey: 'OBJETS',
      pageType: 'single', // Page unique avec filtres
      icons: { 
        category: '📦', 
        item: '🎒',
        add: '➕',
        delete: '🗑️'
      },
      // Configuration des filtres disponibles (MISE À JOUR AUTOMATIQUE)
      filterConfig: {
        availableTags: [
          "Départ",
          "Arme",
          "Armure",
          "Consommable",
          "Bouclier",
          "Épée",
          "Arme exotique",
          "Une main",
          "Deux mains",
          "Baton",
          "Dague",
          "Arc",
          "Armure lourde",
          "Armure légère",
          "Robe",
          "Plante",
          "Catalyseur"
],
        defaultVisibleTags: [
          "Arme"
] // Filtres affichés par défaut
      },
      defaultValues: {
        nom: "Nouvel Objet",
        numero: 1,
        image: "",
        description: "Description de l'objet.",
        tags: ["Arme"],
        effet: "<strong>Effet:</strong> Description de l'effet de l'objet.",
        prix: "🔷 <strong>Prix:</strong> 10",
        poids: "⚖️ <strong>Poids:</strong> 1"
      }
    },

    monster: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        image: { type: 'text', label: 'Image', required: false },
        element: { 
          type: 'select', 
          label: "Élément d'affiliation", 
          required: true,
          options: [
            { value: 'Feu', label: '🔥 Feu' },
            { value: 'Eau', label: '💧 Eau' },
            { value: 'Terre', label: '🤎 Terre' },
            { value: 'Air', label: '🟢 Air' },
            { value: 'Lumiere', label: '☀️ Lumière' },
            { value: 'Nuit', label: '⚫ Nuit' },
            { value: 'Divin', label: '⚪ Divin' },
            { value: 'Malefique', label: '🟣 Maléfique' }
          ]
        },
        pointsDeVie: { type: 'number', label: 'Points de vie', required: true },
        armurePhysique: { type: 'number', label: 'Armure physique', required: true },
        esquive: { type: 'number', label: 'Esquive', required: true },
        coupCritique: { type: 'number', label: 'Coup critique', required: true },
        coupCritiqueSorts: { type: 'number', label: 'Critique sorts', required: true },
        resistanceAlterations: { type: 'number', label: 'Résistance altérations', required: true },
        armureFeu: { type: 'number', label: 'Armure Feu', required: true },
        armureEau: { type: 'number', label: 'Armure Eau', required: true },
        armureTerre: { type: 'number', label: 'Armure Terre', required: true },
        armureAir: { type: 'number', label: 'Armure Air', required: true },
        armureLumiere: { type: 'number', label: 'Armure Lumière', required: true },
        armureObscurite: { type: 'number', label: 'Armure Obscurité', required: true },
        armureDivin: { type: 'number', label: 'Armure Divin', required: true },
        armureMalefique: { type: 'number', label: 'Armure Maléfique', required: true },
        abilites: { type: 'richtext', label: 'Abilités', required: false },
        butin: { type: 'richtext', label: 'Butin', required: false }
      },
      editMapping: {
        'monster-name': 'nom',
        'monster-tags': 'tags',
        'monster-image': 'image',
        'monster-element': 'element',
        // Stats principaux
        'monster-pointsdevie': 'pointsDeVie',
        'monster-armurephysique': 'armurePhysique', 
        'monster-esquive': 'esquive',
        'monster-coupcritique': 'coupCritique',
        'monster-coupcritiquesorts': 'coupCritiqueSorts',
        'monster-resistancealterations': 'resistanceAlterations',
        // Armures élémentaires
        'monster-armurefeu': 'armureFeu',
        'monster-armureeau': 'armureEau',
        'monster-armureterre': 'armureTerre',
        'monster-armureair': 'armureAir',
        'monster-armurelumiere': 'armureLumiere',
        'monster-armureobscurite': 'armureObscurite',
        'monster-armuredivin': 'armureDivin',
        'monster-armuremalefique': 'armureMalefique',
        // Contenu narratif
        'monster-abilites': 'abilites',
        'monster-butin': 'butin'
      },
      identifiers: {
        name: 'nom',
        category: 'monstres'
      },
      template: 'monster-card',
      container: 'monstres',
      dataKey: 'MONSTRES',
      pageType: 'single',
      filterMode: 'AND',
      icons: { 
        category: '🐲', 
        item: '👾',
        add: '➕',
        delete: '🗑️'
      },
      filterConfig: {
        availableTags: [
          "Forêt",
          "Boss"
],
        defaultVisibleTags: [
          "Forêt"
]
      },
      defaultValues: {
        nom: "Nouveau Monstre",
        tags: ["Forêt"],
        image: "",
        element: "Feu",
        pointsDeVie: 20,
        armurePhysique: 2,
        esquive: 5,
        coupCritique: 10,
        coupCritiqueSorts: 8,
        resistanceAlterations: 3,
        armureFeu: 0,
        armureEau: 0,
        armureTerre: 0,
        armureAir: 0,
        armureLumiere: 0,
        armureObscurite: 0,
        armureDivin: 0,
        armureMalefique: 0,
        abilites: "<strong>Attaque basique:</strong> Inflige 5 dégâts physiques.",
        butin: "<strong>Butin:</strong> 10-50 pièces d'or."
      }
    },

    staticPage: {
      fields: {
        title: { type: 'text', label: 'Titre', required: true },
        sections: { type: 'sections', label: 'Sections', required: true }
      },
      template: 'static-page',
      icons: { 
        category: '📄', 
        item: '📝'
      }
    }
  };

  window.StatIcons = {
    'Force': '💪',
    'Agilité': '🏃',
    'Endurance': '🛡️',
    'Intelligence': '🧠',
    'Volonté': '⚡',
    'Chance': '🍀'
  };

  window.ElementColors = {
    'Feu': { color: '#ff6b35', weight: 'bold' },
    'Eau': { color: '#4682b4', weight: 'bold' },
    'Terre': { color: '#8b4513', weight: 'bold' },
    'Air': { color: '#22c55e', weight: 'bold' },
    'Lumière': { color: '#ffd700', weight: 'bold' },
    'Nuit': { color: '#1a1a1a', weight: 'bold' },
    'Divin': { color: '#f5f5f5', weight: 'bold', background: 'rgba(100, 100, 100, 0.3)', padding: '2px 4px', borderRadius: '3px' },
    'Maléfique': { color: '#8b5cf6', weight: 'bold' }
  };

  window.ElementIcons = {
    'Feu': '🔥',
    'Eau': '💧',
    'Terre': '🤎',
    'Air': '🟢',
    'Lumière': '☀️',
    'Nuit': '⚫',
    'Divin': '⚪',
    'Maléfique': '🟣'
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - EVENT BUS
// ============================================================================

(() => {
  "use strict";

  class EventBus {
    constructor() {
      this.listeners = new Map();
    }

    static getInstance() {
      if (!EventBus.instance) {
        EventBus.instance = new EventBus();
      }
      return EventBus.instance;
    }

    on(eventType, callback) {
      if (!this.listeners.has(eventType)) {
        this.listeners.set(eventType, []);
      }
      this.listeners.get(eventType).push(callback);
      return () => this.off(eventType, callback);
    }

    off(eventType, callback) {
      const callbacks = this.listeners.get(eventType);
      if (callbacks) {
        const index = callbacks.indexOf(callback);
        if (index > -1) {
          callbacks.splice(index, 1);
        }
      }
    }

    emit(eventType, payload = {}) {
      const callbacks = this.listeners.get(eventType);
      if (callbacks) {
        callbacks.forEach(callback => {
          try {
            callback(payload);
          } catch (error) {
            console.error(`Error in event callback for ${eventType}:`, error);
          }
        });
      }
    }

    once(eventType, callback) {
      const unsubscribe = this.on(eventType, (payload) => {
        callback(payload);
        unsubscribe();
      });
      return unsubscribe;
    }
  }

  window.EventBus = EventBus.getInstance();

  window.Events = {
    CONTENT_ADD: 'content:add',
    CONTENT_DELETE: 'content:delete',
    CONTENT_UPDATE: 'content:update',
    CONTENT_MOVE: 'content:move',
    PAGE_RENDER: 'page:render',
    EDITOR_TOGGLE: 'editor:toggle',
    IMAGE_UPLOAD: 'image:upload',
    IMAGE_DELETE: 'image:delete',
    STORAGE_SAVE: 'storage:save',
    SEARCH_PERFORM: 'search:perform',
    MODAL_OPEN: 'modal:open',
    MODAL_CLOSE: 'modal:close',
    NOTIFICATION_SHOW: 'notification:show'
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - BASE ENTITY
// ============================================================================

(() => {
  "use strict";

  class BaseEntity {
    constructor(type, dataArray) {
      this.type = type;
      this.data = dataArray || [];
      this.config = window.ContentTypes[type];
      
      // Handle special case for objects with new structure
      if (type === 'objet' && this.data && !Array.isArray(this.data) && this.data.objets) {
        // Convert to pseudo-category structure for compatibility
        this.objectsData = this.data; // Keep reference to original structure
        this.data = [{ nom: 'objets', objets: this.data.objets }]; // Wrap in array format
      }
    }

    getAll() {
      return this.data;
    }

    findCategory(categoryName) {
      return this.data.find(category => category.nom === categoryName);
    }

    findItem(itemName, categoryName = null) {
      if (categoryName) {
        const category = this.findCategory(categoryName);
        if (!category || !category[this.getItemsProperty()]) return null;
        
        const item = category[this.getItemsProperty()].find(item => item.nom === itemName);
        return item ? { item, category: category.nom } : null;
      }

      for (const category of this.data) {
        if (!category[this.getItemsProperty()]) continue;
        const item = category[this.getItemsProperty()].find(item => item.nom === itemName);
        if (item) {
          return { item, category: category.nom };
        }
      }
      return null;
    }

    addItem(categoryName, itemData) {
      const category = this.findCategory(categoryName);
      if (!category) return false;

      const itemsProperty = this.getItemsProperty();
      if (!category[itemsProperty]) {
        category[itemsProperty] = [];
      }

      const defaultValues = this.config?.defaultValues || {};
      const newItem = { ...defaultValues, ...itemData };
      category[itemsProperty].push(newItem);

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_ADD, {
        type: this.type,
        category: categoryName,
        item: newItem
      });

      return newItem;
    }

    deleteItem(categoryName, itemName) {
      const category = this.findCategory(categoryName);
      if (!category) return false;

      const itemsProperty = this.getItemsProperty();
      const items = category[itemsProperty];
      if (!items) return false;

      const index = items.findIndex(item => item.nom === itemName);
      if (index === -1) return false;

      const deletedItem = items.splice(index, 1)[0];

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_DELETE, {
        type: this.type,
        category: categoryName,
        item: deletedItem
      });

      return true;
    }

    updateItem(categoryName, itemName, property, value) {
      const result = this.findItem(itemName, categoryName);
      if (!result) return false;

      const { item } = result;
      
      if (property === 'capacites' && Array.isArray(value)) {
        item[property] = value;
      } else if (property === 'base' && typeof value === 'object') {
        item[property] = { ...item[property], ...value };
      } else {
        item[property] = value;
      }

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_UPDATE, {
        type: this.type,
        category: categoryName,
        item: item,
        property: property,
        value: value
      });

      return true;
    }

    moveItem(categoryName, itemName, direction) {
      const category = this.findCategory(categoryName);
      if (!category) return false;

      const itemsProperty = this.getItemsProperty();
      const items = category[itemsProperty];
      if (!items) return false;

      const currentIndex = items.findIndex(item => item.nom === itemName);
      if (currentIndex === -1) return false;

      const newIndex = currentIndex + direction;
      if (newIndex < 0 || newIndex >= items.length) return false;

      [items[currentIndex], items[newIndex]] = [items[newIndex], items[currentIndex]];

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_MOVE, {
        type: this.type,
        category: categoryName,
        itemName: itemName,
        direction: direction
      });

      return true;
    }

    getItemsProperty() {
      switch (this.type) {
        case 'spell': return 'sorts';
        case 'don': return 'dons';
        case 'objet': return 'objets';
        case 'class': return 'sousClasses';
        default: return 'items';
      }
    }

    search(query) {
      const results = [];
      const normalizedQuery = query.toLowerCase().trim();

      this.data.forEach(category => {
        const itemsProperty = this.getItemsProperty();
        if (!category[itemsProperty]) return;

        category[itemsProperty].forEach(item => {
          const searchableText = Object.values(item).join(' ').toLowerCase();
          if (searchableText.includes(normalizedQuery)) {
            results.push({
              item,
              category: category.nom,
              type: this.type
            });
          }
        });
      });

      return results;
    }

    // Sync changes back to original objects data structure
    syncObjectsData() {
      // Sync objects data
      if (this.type === 'objet' && this.objectsData && this.data.length > 0) {
        const objectsCategory = this.data[0];
        if (objectsCategory && objectsCategory.objets) {
          this.objectsData.objets = objectsCategory.objets;
        }
      }
      
      // Sync monsters data - CRITICAL for preventing data reversion
      if (this.type === 'monster' && window.MONSTRES && Array.isArray(this.data)) {
        // Ensure window.MONSTRES stays synchronized with our internal data
        window.MONSTRES.length = 0; // Clear array
        window.MONSTRES.push(...this.data); // Replace with current data
        
        // Also sync image mappings
        if (JdrApp.modules.images && typeof JdrApp.modules.images.ensureMonsterImageMappings === 'function') {
          JdrApp.modules.images.ensureMonsterImageMappings();
        }
      }
    }
  }

  window.BaseEntity = BaseEntity;

})();
// ============================================================================
// JDR-BAB APPLICATION - CONTENT FACTORY
// ============================================================================

(() => {
  "use strict";

  class ContentFactory {
    constructor() {
      this.entities = new Map();
      this.initialize();
    }

    static getInstance() {
      if (!ContentFactory.instance) {
        ContentFactory.instance = new ContentFactory();
      }
      return ContentFactory.instance;
    }

    initialize() {
      // Lazy initialization - only create entities when data is available
      if (window.SORTS) {
        this.entities.set('spell', new BaseEntity('spell', window.SORTS));
      }
      if (window.DONS) {
        this.entities.set('don', new BaseEntity('don', window.DONS));
      }
      if (window.CLASSES) {
        this.entities.set('class', new BaseEntity('class', window.CLASSES));
      }
      if (window.OBJETS) {
        this.entities.set('objet', new BaseEntity('objet', window.OBJETS));
      }
      if (window.MONSTRES) {
        this.entities.set('monster', new BaseEntity('monster', window.MONSTRES));
      }
    }

    getEntity(type) {
      // Ensure entity exists, create if data is available but entity is missing
      if (!this.entities.has(type)) {
        this.initializeEntity(type);
      }
      return this.entities.get(type);
    }

    initializeEntity(type) {
      switch (type) {
        case 'spell':
          if (window.SORTS) {
            this.entities.set('spell', new BaseEntity('spell', window.SORTS));
          }
          break;
        case 'don':
          if (window.DONS) {
            this.entities.set('don', new BaseEntity('don', window.DONS));
          }
          break;
        case 'class':
          if (window.CLASSES) {
            this.entities.set('class', new BaseEntity('class', window.CLASSES));
          }
          break;
        case 'objet':
          if (window.OBJETS) {
            this.entities.set('objet', new BaseEntity('objet', window.OBJETS));
          }
          break;
        case 'monster':
          if (window.MONSTRES) {
            this.entities.set('monster', new BaseEntity('monster', window.MONSTRES));
          }
          break;
      }
    }

    getSpells() {
      return this.getEntity('spell');
    }

    getDons() {
      return this.getEntity('don');
    }

    getClasses() {
      return this.getEntity('class');
    }

    getObjets() {
      return this.getEntity('objet');
    }

    getMonsters() {
      return this.getEntity('monster');
    }

    findItem(type, itemName, categoryName = null) {
      const entity = this.getEntity(type);
      return entity ? entity.findItem(itemName, categoryName) : null;
    }

    addItem(type, categoryName, itemData) {
      const entity = this.getEntity(type);
      return entity ? entity.addItem(categoryName, itemData) : false;
    }

    deleteItem(type, categoryName, itemName) {
      const entity = this.getEntity(type);
      return entity ? entity.deleteItem(categoryName, itemName) : false;
    }

    updateItem(type, categoryName, itemName, property, value) {
      const entity = this.getEntity(type);
      return entity ? entity.updateItem(categoryName, itemName, property, value) : false;
    }

    moveItem(type, categoryName, itemName, direction) {
      const entity = this.getEntity(type);
      return entity ? entity.moveItem(categoryName, itemName, direction) : false;
    }

    searchAll(query) {
      const allResults = [];
      
      this.entities.forEach((entity, type) => {
        const results = entity.search(query);
        allResults.push(...results);
      });

      return allResults;
    }

    refreshData() {
      this.entities.clear();
      this.initialize();
    }

    getConfig(type) {
      return window.ContentTypes[type];
    }

    createDefaultItem(type, overrides = {}) {
      const config = this.getConfig(type);
      if (!config?.defaultValues) return {};

      return { ...config.defaultValues, ...overrides };
    }
  }

  window.ContentFactory = ContentFactory.getInstance();

})();
// ============================================================================
// JDR-BAB APPLICATION - CARD BUILDER
// ============================================================================

(() => {
  "use strict";

  class CardBuilder {
    constructor(type, data, categoryName = null, index = null) {
      this.type = type;
      this.data = data;
      this.categoryName = categoryName;
      this.index = index;
      this.config = window.ContentTypes[type];
    }

    static create(type, data, categoryName = null, index = null) {
      return new CardBuilder(type, data, categoryName, index);
    }

    // Simple unified dev mode check
    get shouldShowEditButtons() {
      return JdrApp.utils.isDevMode();
    }

    build() {
      switch (this.type) {
        case 'spell':
          return this.buildSpellCard();
        case 'don':
          return this.buildDonCard();
        case 'subclass':
          return this.buildSubclassCard();
        case 'objet':
          return this.buildObjetCard();
        case 'monster':
          return this.buildMonsterCard();
        default:
          return this.buildGenericCard();
      }
    }

    buildSpellCard() {
      return `
        <div class="card editable-section" data-section-type="spell" data-spell-name="${this.data.nom}" data-spell-index="${this.index}" data-category-name="${this.categoryName}">
          ${this.buildEditableTitle(this.data.nom, 'spell-name')}
          ${this.buildSpellElement()}
          ${this.buildIllustration(`sort:${this.categoryName}:${this.data.nom}`, this.data.nom)}
          ${this.buildEditableField(this.data.description, 'spell-description', 'Description', { style: 'text-align: center; font-style: italic; margin: 1rem 0;' })}
          <hr style="margin: 1rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.6;">
          ${this.buildEditableField(this.data.prerequis, 'spell-prerequis', 'Prérequis')}
          ${this.buildEditableField(this.data.portee, 'spell-portee', 'Portée')}
          ${this.buildEditableField(this.data.coutMana, 'spell-mana', 'Coût mana')}
          ${this.buildEditableField(this.data.tempsIncantation, 'spell-temps-incantation', 'Temps d\'incantation')}
          <hr style="margin: 0.5rem 0; border: none; border-top: 1px solid var(--rule);">
          ${this.buildEditableField(this.data.resistance, 'spell-resistance', 'Résistance')}
          ${this.buildEditableEffect(this.data.effetNormal, 'spell-effect-normal', 'Effet normal')}
          <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
          ${this.data.effetCritique ? this.buildEditableEffect(this.data.effetCritique, 'spell-effect-critical', 'Effet critique') : ''}
          ${this.buildDeleteButton('spell')}
        </div>
      `;
    }

    buildDonCard() {
      const index = this.index !== null ? this.index : (this.categoryName ? this.getCategoryData().dons?.indexOf(this.data) || 0 : 0);
      const totalItems = this.categoryName ? this.getCategoryData().dons?.length || 1 : 1;

      return `
        <div class="card editable-section" data-section-type="don" data-don-name="${this.data.nom}" data-don-index="${this.index}" data-category-name="${this.categoryName}">
          ${this.buildEditableTitle(this.data.nom, 'don-name')}
          ${this.buildIllustration(`don:${this.data.nom}`, this.data.nom)}
          ${this.buildEditableField(this.data.description, 'don-description', 'Description')}
          ${this.buildEditableField(this.data.prerequis, 'don-prerequis', 'Prérequis')}
          ${this.buildEditableField(this.data.cout, 'don-cout', 'Coût', { style: 'color: var(--bronze); font-weight: 600;' })}
          ${this.buildMoveButtons('don', index, totalItems)}
        </div>
      `;
    }

    buildSubclassCard() {
      return `
        <div class="card editable-section" data-section-type="subclass" data-class-name="${this.categoryName}" data-subclass-name="${this.data.nom}">
          ${this.buildEditableTitle(this.data.nom, 'subclass-name')}
          ${this.buildEditableField(this.data.description || 'Description de la sous-classe', 'subclass-description', 'Description', { style: 'text-align: center; color: inherit;' })}
          ${this.buildSubclassImages()}
          <div style="margin-bottom: 1rem;">
            ${this.buildStatsSection()}
          </div>
          ${this.buildEditableField(this.data.progression, 'subclass-progression', 'Progression')}
          <div class="rule" style="margin: 1.5rem auto; height: 2px; background: linear-gradient(90deg, transparent, var(--bronze), transparent); opacity: 0.6;"></div>
          ${this.buildEditableList(this.data.capacites, 'subclass-capacites', 'Capacités')}
          ${this.buildDeleteButton('subclass')}
        </div>
      `;
    }

    buildObjetCard() {
      // Pour les objets en page unique, l'index est basé sur tous les objets
      const allObjects = window.OBJETS?.objets || [];
      const index = allObjects.indexOf(this.data) || 0;
      const totalItems = allObjects.length;
      
      // Construire l'affichage des tags
      const tagsDisplay = this.data.tags && this.data.tags.length > 0 
        ? this.data.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';

      return `
        <div class="card editable-section" data-section-type="objet" data-objet-name="${this.data.nom}" data-category-name="${this.categoryName}">
          ${this.buildEditableTitle(this.data.nom, 'objet-name')}
          ${this.buildIllustration(`objet:${this.data.nom}`, this.data.nom)}
          <div style="display: flex; justify-content: space-between; align-items: center; margin: 0.5rem 0; font-size: 0.9em; color: var(--bronze);">
            ${this.buildEditableField(`N°${this.data.numero}`, 'objet-numero', 'Numéro', { style: 'font-weight: bold;' })}
            <div style="flex: 1; text-align: right;">
              <div style="margin: 2px 0;">
                ${this.buildEditableTagsField(tagsDisplay, 'objet-tags', 'Tags')}
              </div>
            </div>
          </div>
          ${this.buildEditableField(this.data.description, 'objet-description', 'Description')}
          <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
          ${this.buildEditableField(this.data.effet, 'objet-effet', 'Effet')}
          <div style="display: flex; justify-content: space-between; gap: 1rem; margin: 0.5rem 0;">
            <div style="flex: 1;">${this.buildEditableField(this.data.prix, 'objet-prix', 'Prix')}</div>
            <div style="flex: 1;">${this.buildEditableField(this.data.poids, 'objet-poids', 'Poids')}</div>
          </div>
        </div>
      `;
    }

    buildMonsterCard() {
      const allMonsters = window.MONSTRES || [];
      const index = allMonsters.indexOf(this.data) || 0;
      const totalItems = allMonsters.length;
      
      // Construire l'affichage des tags
      const tagsDisplay = this.data.tags && this.data.tags.length > 0 
        ? this.data.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';

      return `
        <div class="card editable-section" data-section-type="monster" data-monster-name="${this.data.nom}">
          ${this.buildEditableTitle(this.data.nom, 'monster-name')}
          ${this.buildIllustration(`monster:${this.data.nom}`, this.data.nom)}
          
          <div style="display: flex; justify-content: space-between; align-items: flex-start; margin: 0.5rem 0; gap: 1rem;">
            <div style="flex: 1;">
              ${this.buildEditableTagsField(tagsDisplay, 'monster-tags', 'Tags')}
            </div>
            <div style="flex-shrink: 0;">
              ${this.buildMonsterElement()}
            </div>
          </div>
          
          <!-- Séparation avant les stats principales -->
          <hr style="margin: 1.5rem 0 1rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.3;">
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin: 1rem 0; font-size: 0.9em;">
            <div>${this.buildEditableStatField('❤️ PV', this.data.pointsDeVie, 'monster-pointsdevie', 'Points de vie')}</div>
            <div>${this.buildEditableStatField('🛡️ Armure', this.data.armurePhysique, 'monster-armurephysique', 'Armure physique')}</div>
            <div>${this.buildEditableStatField('⚡ Critique', this.data.coupCritique, 'monster-coupcritique', 'Coup critique')}</div>
            <div>${this.buildEditableStatField('🏃 Esquive', this.data.esquive, 'monster-esquive', 'Esquive')}</div>
            <div>${this.buildEditableStatField('🔮 Crit. Sorts', this.data.coupCritiqueSorts, 'monster-coupcritiquesorts', 'Critique sorts')}</div>
            <div>${this.buildEditableStatField('🛡️ Rés. Alt.', this.data.resistanceAlterations, 'monster-resistancealterations', 'Résistance altérations')}</div>
          </div>

          <!-- Séparation après les stats principales -->
          <hr style="margin: 1rem 0 1.5rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.3;">

          <div style="margin: 1rem 0;">
            <strong>🌟 Armures Élémentaires:</strong>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 0.25rem; font-size: 0.8em; margin-top: 0.5rem;">
              <div>${this.buildEditableStatField(this.getElementIcon('Feu'), this.data.armureFeu, 'monster-armurefeu', 'Armure Feu')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Eau'), this.data.armureEau, 'monster-armureeau', 'Armure Eau')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Terre'), this.data.armureTerre, 'monster-armureterre', 'Armure Terre')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Air'), this.data.armureAir, 'monster-armureair', 'Armure Air')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Lumière'), this.data.armureLumiere, 'monster-armurelumiere', 'Armure Lumière')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Nuit'), this.data.armureObscurite, 'monster-armureobscurite', 'Armure Obscurité')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Divin'), this.data.armureDivin, 'monster-armuredivin', 'Armure Divin')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Maléfique'), this.data.armureMalefique, 'monster-armuremalefique', 'Armure Maléfique')}</div>
            </div>
          </div>

          ${this.data.abilites ? `
            <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
            ${this.buildEditableField(this.data.abilites, 'monster-abilites', 'Abilités', { style: 'margin-top: 0.5rem;' })}
          ` : ''}

          ${this.data.butin ? `
            <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
            ${this.buildEditableField(this.data.butin, 'monster-butin', 'Butin', { style: 'margin-top: 0.5rem;' })}
          ` : ''}

          ${this.buildDeleteButton('monster')}
        </div>
      `;
    }

    buildEditableTitle(content, editType, centerAlign = true) {
      const style = centerAlign ? 'margin: 0 0 1rem 0; text-align: center;' : '';
      const spellTitleClass = this.type === 'spell' ? ' spell-title' : '';
      const subclassTitleClass = this.type === 'subclass' ? ' subclass-title' : '';
      const editTypeClass = editType ? ` ${editType}` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <h4 style="${style}" class="editable editable-title${spellTitleClass}${subclassTitleClass}${editTypeClass}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}">${content}</h4>
          ${this.buildEditButton('title')}
        </div>
      `;
    }

    buildEditableField(content, editType, label, options = {}) {
      const style = options.style ? `style="${options.style}"` : '';
      const className = options.className || 'editable-field';
      
      // Add the editType as a class for reliable detection
      const editTypeClass = editType ? ` ${editType}` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable ${className}${editTypeClass}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" ${style}>
            ${content}
          </div>
          ${this.buildEditButton('field')}
        </div>
      `;
    }

    buildEditableStatField(title, value, editType, label, options = {}) {
      const style = options.style ? `style="${options.style}"` : '';
      const className = options.className || 'editable-stat';
      
      // Display the value only as editable, but show title + value visually
      return `
        <div class="editable-section" data-section-type="html">
          <div style="display: flex; align-items: center;">
            <strong style="margin-right: 0.25rem;">${title}:</strong>
            <div class="editable ${className}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" ${style}>
              ${value}
            </div>
          </div>
          ${this.buildEditButton('field')}
        </div>
      `;
    }
    
    buildEditableTagsField(content, editType, label, options = {}) {
      const style = options.style ? `style="${options.style}"` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable editable-tags" data-edit-type="tags" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" ${style}>
            ${content}
          </div>
          ${this.buildEditButton('field')}
        </div>
      `;
    }

    buildEditableEffect(content, editType, label) {
      const editTypeClass = editType ? ` ${editType}` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable editable-effect${editTypeClass}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" style="margin: 1rem 0;">
            ${content}
          </div>
          ${this.buildEditButton('effect')}
        </div>
      `;
    }

    buildEditableList(items, editType, label) {
      // Everything should be HTML format only
      let listHTML;
      if (typeof items === 'string') {
        // HTML string format
        listHTML = items;
      } else {
        // Fallback if somehow still array format - convert once
        if (Array.isArray(items)) {
          listHTML = '<ul>' + items.map(item => '<li>' + item + '</li>').join('') + '</ul>';
        } else {
          listHTML = '<ul><li>Aucune capacité définie</li></ul>';
        }
      }
      
      // Use the editType directly instead of creating compound identifier
      return `
        <h5>${label}</h5>
        <div class="editable-section" data-section-type="html">
          <div class="editable" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}">
            ${listHTML}
          </div>
          ${this.buildEditButton('list')}
        </div>
      `;
    }

    buildStatsSection() {
      // Stats are special - they remain as objects since they're structured data
      // But check if they were converted to HTML string by editing
      let statsHTML;
      
      if (typeof this.data.base === 'string') {
        // Already converted to HTML by editing
        statsHTML = this.data.base;
      } else if (typeof this.data.base === 'object') {
        // Original object format - convert to HTML
        statsHTML = '<div class="chips">' + 
          Object.entries(this.data.base).map(([stat, value]) => {
            const icon = window.StatIcons[stat] || '⚡';
            return '<span class="chip">' + icon + ' ' + stat + ': <strong>' + value + '</strong></span>';
          }).join('') + 
          '</div>';
      } else {
        statsHTML = '<div>Aucune statistique définie</div>';
      }
      
      // Use subclass-stats directly
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable editable-stats" data-edit-type="generic" data-edit-section="subclass-stats" data-item-identifier="${this.data.nom}">
            ${statsHTML}
          </div>
          ${this.buildEditButton('stats')}
        </div>
      `;
    }

    buildSubclassImages() {
      const illusKey1 = `subclass:${this.categoryName}:${this.data.nom}:1`;
      const illusKey2 = `subclass:${this.categoryName}:${this.data.nom}:2`;
      
      return `
        <div class="subclass-images">
          ${this.buildIllustration(illusKey1, `${this.data.nom} (Image 1)`, 'subclass')}
          ${this.buildIllustration(illusKey2, `${this.data.nom} (Image 2)`, 'subclass')}
        </div>
      `;
    }

    buildIllustration(illusKey, altText = '', styleType = 'default') {
      let imageUrl = '';
      let imageStyle = 'display: none;';
      let removeStyle = 'display: none;';
      
      if (window.JdrApp?.modules?.images?.getImageUrl) {
        imageUrl = window.JdrApp.modules.images.getImageUrl(illusKey);
        if (imageUrl) {
          imageUrl = window.JdrApp.modules.images.processImageUrl(imageUrl);
          imageStyle = 'display: inline-block;';
          removeStyle = 'display: inline-flex;';
        }
      }

      let containerClasses = 'illus';
      if (['spell', 'class', 'subclass', 'don', 'objet', 'monster'].includes(styleType)) {
        containerClasses += ` illus-${styleType}`;
      }

      // ALWAYS generate editing controls - CSS will control visibility based on body.dev-on/dev-off
      return `
        <div class="${containerClasses}" data-illus-key="${illusKey}" data-style-type="${styleType}" data-bound="1">
          <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
          <label class="up">📷 Ajouter<input accept="image/*" hidden="" type="file"></label>
          <button class="rm" type="button" style="${removeStyle}">🗑 Retirer</button>
        </div>
      `;
    }

    buildSpellElement() {
      return `
        <div class="spell-element-section">
          <div class="spell-element-display" style="text-align: center; margin: 0.5rem 0;">
            <span class="element-badge" style="display: inline-block; padding: 4px 12px; background: var(--accent); color: white; border-radius: 16px; font-size: 0.9em; font-weight: 600;">
              ${this.getElementIcon(this.data.element)} ${this.data.element}
            </span>
          </div>
          <div class="spell-element-selector" style="text-align: center; margin: 0.5rem 0; display: none;">
            <label for="spell-element-${this.data.nom}" style="display: block; margin-bottom: 0.25rem; font-weight: 600;">Élément:</label>
            <select id="spell-element-${this.data.nom}" class="editable" data-edit-type="select" data-edit-section="spell-element" data-item-identifier="${this.data.nom}">
              <option value="Feu" ${this.data.element === 'Feu' ? 'selected' : ''}>${this.getElementIcon('Feu')} Feu</option>
              <option value="Eau" ${this.data.element === 'Eau' ? 'selected' : ''}>${this.getElementIcon('Eau')} Eau</option>
              <option value="Terre" ${this.data.element === 'Terre' ? 'selected' : ''}>${this.getElementIcon('Terre')} Terre</option>
              <option value="Air" ${this.data.element === 'Air' ? 'selected' : ''}>${this.getElementIcon('Air')} Air</option>
              <option value="Lumière" ${this.data.element === 'Lumière' ? 'selected' : ''}>${this.getElementIcon('Lumière')} Lumière</option>
              <option value="Nuit" ${this.data.element === 'Nuit' ? 'selected' : ''}>${this.getElementIcon('Nuit')} Nuit</option>
              <option value="Divin" ${this.data.element === 'Divin' ? 'selected' : ''}>${this.getElementIcon('Divin')} Divin</option>
              <option value="Maléfique" ${this.data.element === 'Maléfique' ? 'selected' : ''}>${this.getElementIcon('Maléfique')} Maléfique</option>
            </select>
          </div>
        </div>
      `;
    }

    buildMonsterElement() {
      const elementColor = this.getElementColor(this.data.element);
      
      return `
        <div class="monster-element-section">
          <div class="monster-element-display">
            <span class="element-badge" style="
              display: inline-flex; 
              align-items: center; 
              padding: 4px 8px; 
              background: rgba(${parseInt(elementColor.slice(1,3), 16)}, ${parseInt(elementColor.slice(3,5), 16)}, ${parseInt(elementColor.slice(5,7), 16)}, 0.1); 
              border-radius: 6px; 
              border: 1px solid ${elementColor};
              font-size: 0.8em;
              font-weight: 600;
            ">
              <span style="margin-right: 4px;">${this.getElementIcon(this.data.element)}</span>
              <span style="color: ${elementColor};">${this.data.element}</span>
            </span>
          </div>
          <div class="monster-element-selector" style="margin-top: 0.5rem; display: none;">
            <select class="editable" data-edit-type="select" data-edit-section="monster-element" data-item-identifier="${this.data.nom}" style="width: 100%; padding: 4px; border: 1px solid ${elementColor}; border-radius: 4px; font-size: 0.8em;">
              <option value="Feu" ${this.data.element === 'Feu' ? 'selected' : ''}>${this.getElementIcon('Feu')} Feu</option>
              <option value="Eau" ${this.data.element === 'Eau' ? 'selected' : ''}>${this.getElementIcon('Eau')} Eau</option>
              <option value="Terre" ${this.data.element === 'Terre' ? 'selected' : ''}>${this.getElementIcon('Terre')} Terre</option>
              <option value="Air" ${this.data.element === 'Air' ? 'selected' : ''}>${this.getElementIcon('Air')} Air</option>
              <option value="Lumière" ${this.data.element === 'Lumière' ? 'selected' : ''}>${this.getElementIcon('Lumière')} Lumière</option>
              <option value="Nuit" ${this.data.element === 'Nuit' ? 'selected' : ''}>${this.getElementIcon('Nuit')} Nuit</option>
              <option value="Divin" ${this.data.element === 'Divin' ? 'selected' : ''}>${this.getElementIcon('Divin')} Divin</option>
              <option value="Maléfique" ${this.data.element === 'Maléfique' ? 'selected' : ''}>${this.getElementIcon('Maléfique')} Maléfique</option>
            </select>
          </div>
        </div>
      `;
    }

    getElementIcon(element) {
      return window.ElementIcons?.[element] || '⚡';
    }

    getElementColor(element) {
      return window.ElementColors?.[element]?.color || '#666';
    }

    buildGenericCard() {
      return `
        <div class="card">
          <h4>${this.data.nom || 'Unknown'}</h4>
          <p>Generic card for type: ${this.type}</p>
        </div>
      `;
    }

    buildEditButton(buttonType) {
      return `<button class="edit-btn" type="button" title="✏️ Éditer" data-button-type="${buttonType}">✏️</button>`;
    }

    buildDeleteButton(type) {
      const config = this.config;
      const deleteIcon = config?.icons?.delete || '🗑️';
      
      return `
        <div class="delete-button-container" style="margin-top: 1rem; text-align: center;">
          <button class="${type}-delete btn" data-${type}-name="${this.data.nom}" ${this.categoryName ? `data-category-name="${this.categoryName}"` : ''} type="button" style="background: #dc2626; color: white; border: 2px solid #b91c1c;">
            ${deleteIcon} Supprimer ${type}
          </button>
        </div>
      `;
    }

    buildMoveButtons(type, index, totalItems) {
      if (totalItems <= 1) {
        return '';
      }

      return `
        <div class="move-buttons" style="display: flex; gap: 0.5rem; justify-content: center; margin-top: 1rem;">
          <button class="${type}-move-up btn small" data-${type}-name="${this.data.nom}" data-category-name="${this.categoryName}" type="button" style="background: #3b82f6; color: white; padding: 4px 8px; font-size: 0.8em;" ${index === 0 ? 'disabled' : ''}>
            ↑ Haut
          </button>
          <button class="${type}-move-down btn small" data-${type}-name="${this.data.nom}" data-category-name="${this.categoryName}" type="button" style="background: #3b82f6; color: white; padding: 4px 8px; font-size: 0.8em;" ${index >= totalItems - 1 ? 'disabled' : ''}>
            ↓ Bas
          </button>
        </div>
      `;
    }

    getCategoryData() {
      if (this.type === 'don' && this.categoryName) {
        const categoryData = window.DONS.find(cat => cat.nom === this.categoryName);
        return categoryData || { dons: [] };
      }
      return { [this.type + 's']: [] };
    }
  }

  window.CardBuilder = CardBuilder;

})();
// ============================================================================
// JDR-BAB APPLICATION - PAGE BUILDER
// ============================================================================

(() => {
  "use strict";

  class PageBuilder {
    constructor() {
      // Will use unified dev mode check
    }

    // Simple unified dev mode check
    get shouldShowEditButtons() {
      return JdrApp.utils.isDevMode();
    }

    static getInstance() {
      if (!PageBuilder.instance) {
        PageBuilder.instance = new PageBuilder();
      }
      return PageBuilder.instance;
    }

    buildCategoryPage(type, category) {
      const config = window.ContentTypes[type];
      
      // Gestion spéciale pour les objets (page unique avec filtres)
      if (type === 'objet' && config.pageType === 'single') {
        return this.buildSingleObjectPage(category);
      }
      
      const pageId = `${config.container}-${this.sanitizeId(category.nom || 'unknown')}`;
      const itemsProperty = this.getItemsProperty(type);
      
      // Get items and sort them for spells
      let items = category[itemsProperty] || [];
      if (type === 'spell') {
        items = this.sortSpellsByLevel([...items]);
      }

      return `
        <article class="" data-page="${pageId}">
          <section>
            ${this.buildCategoryHeader(category, type)}
            ${type === 'spell' ? this.buildSpellLevelFilter() : ''}
            <div style="display: flex; gap: 8px; margin-bottom: 1rem; flex-wrap: wrap;">
              ${this.buildAddButton(type, category.nom)}
              ${this.buildDeleteCategoryButton(type, category.nom)}
            </div>
            <div class="grid cols-2" id="${config.container}-container-${this.sanitizeId(category.nom)}">
              ${items.map((item, index) => 
                CardBuilder.create(type, item, category.nom, index).build()
              ).join('')}
            </div>
            ${this.buildGeneralDonsSection(type, category.nom)}
          </section>
        </article>
      `;
    }
    
    buildSingleObjectPage(objectData) {
      const config = window.ContentTypes['objet'];
      const allObjects = objectData.objets || [];
      const filterSettings = objectData.filterSettings || {};
      const visibleTags = filterSettings.visibleTags || config.filterConfig.defaultVisibleTags;
      
      // CRITICAL: Ensure window.OBJETS.filterSettings is properly initialized with the same visibleTags
      // This fixes the sync issue between visual state and data state in standalone mode
      if (!window.OBJETS.filterSettings) {
        window.OBJETS.filterSettings = { 
          visibleTags: [...visibleTags],
          displayedFilterButtons: [...config.filterConfig.availableTags]
        };
      }
      
      // Ensure displayedFilterButtons is always initialized
      if (!window.OBJETS.filterSettings.displayedFilterButtons) {
        window.OBJETS.filterSettings.displayedFilterButtons = [...config.filterConfig.availableTags];
      }
      
      // Filtrer les objets selon les tags visibles, sauf si une recherche par ID est active
      const filteredObjects = window.activeIdSearch 
        ? allObjects // Afficher tous les objets quand une recherche par ID est active
        : visibleTags.length === 0 
          ? [] // Si aucun tag n'est visible, ne rien afficher
          : allObjects.filter(obj => {
              // Vérifier que l'objet a les tags requis pour être visible
              if (!obj.tags) return false;
              
              // L'objet doit avoir au moins un tag visible
              const hasVisibleTag = obj.tags.some(tag => visibleTags.includes(tag));
              if (!hasVisibleTag) return false;
              
              // CONDITION OBLIGATOIRE : L'objet doit avoir le tag "Départ" pour être visible
              // SAUF si mode MJ activé, dev mode activé, ou recherche par ID active
              const isMJMode = window.JdrApp?.state?.isMJ || false;
              const isDevMode = window.JdrApp?.utils?.isDevMode?.() || false;
              const bypassDepartRequirement = isMJMode || isDevMode || window.activeIdSearch;
              
              if (!bypassDepartRequirement) {
                const hasDepartTag = obj.tags.includes('Départ');
                if (!hasDepartTag) return false;
              }
              
              return true;
            });
      
      return `
        <article class="" data-page="objets">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2>📦 Objets</h2>
              ${this.buildIllustration('page:objets')}
            </div>
            
            ${this.buildObjectsCategoryDescription()}
            
            ${this.buildIdSearchFilter()}
            ${this.buildTagFilters(visibleTags, filterSettings.displayedFilterButtons || config.filterConfig.availableTags)}
            
            <div style="display: flex; gap: 8px; margin-bottom: 1rem; flex-wrap: wrap;">
              ${this.buildAddButton('objet', 'objets')}
              ${this.buildFilterManagerButton()}
              ${this.buildTagsManagerButton()}
            </div>
            
            <div class="grid cols-2" id="objets-container">
              ${filteredObjects.map((item, index) => 
                CardBuilder.create('objet', item, 'objets', index).build()
              ).join('')}
            </div>
            
            ${filteredObjects.length === 0 && !window.activeIdSearch ? '<p style="text-align: center; color: #666; margin: 2rem 0;">Aucun objet ne correspond aux filtres sélectionnés.</p>' : ''}
          </section>
        </article>
      `;
    }

    buildSingleMonsterPage(monsterData) {
      let config = window.ContentTypes?.['monster'];
      const allMonsters = monsterData || [];
      const instance = PageBuilder.getInstance(); // Créer une instance pour accéder aux méthodes
      
      // Defensive check for config with fallback
      if (!config || !config.filterConfig) {
        console.warn('Monster config not loaded, using fallback defaults');
        console.log('ContentTypes available:', window.ContentTypes ? Object.keys(window.ContentTypes) : 'undefined');
        config = {
          filterConfig: {
            defaultVisibleTags: ['Forêt'],
            availableTags: ['Forêt', 'Boss', 'Minion', 'Volant', 'Aquatique', 'Terrestre']
          }
        };
      }
      
      // Utiliser le state du filtre s'il existe, sinon les tags par défaut
      const visibleTags = window.MONSTRES_FILTER_STATE?.visibleTags || config.filterConfig.defaultVisibleTags;
      
      // Filter monsters according to visible tags (AND mode)
      const filteredMonsters = visibleTags.length === 0 
        ? [] // If no tags are visible, show nothing
        : allMonsters.filter(monster => {
            // Check that the monster has the required tags to be visible
            if (!monster.tags) return false;
            
            // In AND mode: monster must have ALL visible tags
            const hasAllVisibleTags = visibleTags.every(tag => monster.tags.includes(tag));
            if (!hasAllVisibleTags) return false;
            
            return true;
          });
      
      return `
        <article class="" data-page="monstres">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2>🐲 Monstres</h2>
              ${instance.buildIllustration('page:monstres')}
            </div>
            
            ${instance.buildTagFilters(visibleTags, config.filterConfig.availableTags, 'monster')}
            
            <div style="display: flex; gap: 8px; margin-bottom: 1rem; flex-wrap: wrap;">
              ${instance.buildAddButton('monster', 'monstres')}
              ${instance.buildTagsManagerButton()}
            </div>
            
            <div class="grid cols-2" id="monstres-container">
              ${filteredMonsters.map((item, index) => 
                CardBuilder.create('monster', item, 'monstres', index).build()
              ).join('')}
            </div>
            
            ${filteredMonsters.length === 0 ? '<p style="text-align: center; color: #666; margin: 2rem 0;">Aucun monstre ne correspond aux filtres sélectionnés.</p>' : ''}
          </section>
        </article>
      `;
    }

    buildClassPage(classData) {
      const pageId = this.sanitizeId(classData.nom);
      
      return `
        <article class="" data-page="${pageId}" data-page-title="${classData.nom}">
          <section>
            ${this.buildClassHeader(classData)}
            ${this.buildEditableSection(classData.resume, 'class-resume', 'paragraph', classData.nom)}
            <h3>Capacités de classe</h3>
            ${this.buildSimpleEditableContent(classData.capacites, 'class-capacites', classData.nom)}
            <h3>Sous-classes</h3>
            <div class="subclass-stack">
              ${classData.sousClasses ? classData.sousClasses.map(sousClasse => 
                CardBuilder.create('subclass', sousClasse, classData.nom).build()
              ).join('') : ''}
            </div>
            ${this.buildAddSubclassButton()}
          </section>
        </article>
      `;
    }

    buildStaticPage(pageId, pageData) {
      const isActive = pageId === 'creation' ? 'active' : '';
      
      return `
        <article class="${isActive}" data-page="${pageData.page}" data-static-page="true" data-page-title="${pageData.title}">
          <section>
            ${this.buildStaticPageHeader(pageData)}
            ${this.buildSections(pageData.sections)}
            ${this.buildAddSectionButton()}
          </section>
        </article>
      `;
    }

    buildCategoryHeader(category, type) {
      const config = window.ContentTypes[type];
      
      return `
        <div style="text-align:center;margin-bottom:2rem;">
          ${this.buildEditableTitle(category.nom, `${type}-category-name`)}
          ${this.buildIllustration(`${type}category:${category.nom}`)}
        </div>
        ${this.buildEditableSection(category.description, `${type}-category-description`, 'paragraph', category.nom)}
      `;
    }

    buildClassHeader(classData) {
      return `
        <div style="text-align:center;margin-bottom:2rem;">
          ${this.buildEditableTitle(classData.nom, 'class-name', classData.nom)}
          ${this.buildIllustration(`class:${classData.nom}`)}
        </div>
      `;
    }

    buildStaticPageHeader(pageData) {
      return `
        <div style="text-align:center;margin-bottom:2rem;">
          <div style="display:inline-flex;align-items:center;gap:8px;">
            <h2 class="editable editable-title" data-edit-type="generic" data-edit-section="page-title">${pageData.title}</h2>
            ${this.buildEditButton('title')}
          </div>
          ${this.buildIllustration(`page:${pageData.page}`)}
        </div>
      `;
    }

    buildEditableTitle(content, editType, editSection = null) {
      return `
        <div style="display:inline-flex;align-items:center;gap:8px;justify-content:center;">
          <h2 class="editable editable-title" data-edit-type="generic" data-edit-section="${editSection || content}">${content}</h2>
          ${this.buildEditButton('title')}
        </div>
      `;
    }

    buildEditableSection(content, editType, sectionType, editSection) {
      const className = sectionType === 'paragraph' ? 'lead editable editable-paragraph' : 'editable editable-field';
      
      return `
        <div class="editable-section" data-section-type="${editType}">
          <p class="${className}" data-edit-type="generic" data-edit-section="${editSection}">${content}</p>
          ${this.buildEditButton(sectionType)}
        </div>
      `;
    }


    buildSimpleEditableContent(content, editType, editSection) {
      // Everything should be HTML format only
      let htmlContent;
      if (typeof content === 'string') {
        htmlContent = content || '';
      } else {
        // Fallback if somehow still array format - convert once and warn
        console.warn('Found array format in buildSimpleEditableContent, converting to HTML:', content);
        if (Array.isArray(content)) {
          htmlContent = '<ul>' + content.map(item => '<li>' + item + '</li>').join('') + '</ul>';
        } else {
          htmlContent = '';
        }
      }
      
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable" data-edit-type="generic" data-edit-section="${editSection}">
            ${htmlContent}
          </div>
          ${this.buildEditButton('section')}
        </div>
      `;
    }

    buildSections(sections) {
      return sections.map((section, sectionIndex) => {
        switch (section.type) {
          case 'intro':
            return this.buildIntroSection(section, sectionIndex);
          case 'card':
            return this.buildCardSection(section, sectionIndex);
          case 'grid':
            return this.buildGridSection(section, sectionIndex);
          case 'filters':
            return this.buildFiltersSection(section, sectionIndex);
          case 'monster-list':
            return this.buildMonsterListSection(section, sectionIndex);
          default:
            return `<div><!-- Unknown section type: ${section.type} --></div>`;
        }
      }).join('');
    }

    buildIntroSection(section, sectionIndex) {
      const editSection = `intro-${sectionIndex}`;
      return `
        <div class="editable-section" data-section-type="intro" data-section-index="${sectionIndex}">
          <p class="editable editable-intro" data-edit-type="generic" data-edit-section="${editSection}">${section.content}</p>
          ${this.buildEditButton('section')}
        </div>
        ${this.buildAddParagraphButton('intro')}
      `;
    }

    buildCardSection(cardData, sectionIndex) {
      let cardHTML = `<div class="card editable-section" data-section-type="card" data-section-index="${sectionIndex}">`;
      
      if (cardData.deletable && cardData.sectionType) {
        cardHTML += `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${cardData.id}-title">${cardData.title}</h3>
            ${this.buildEditButton('title')}
            ${this.buildRemoveSectionButton(cardData.sectionType)}
          </div>
        `;
      } else {
        cardHTML += `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${cardData.id}-title">${cardData.title}</h3>
            ${this.buildEditButton('title')}
          </div>
        `;
      }

      // Handle different content formats
      let htmlContent = '';
      let editSection = cardData.id || 'card-' + sectionIndex;
      
      if (typeof cardData.content === 'string') {
        // Direct HTML string
        htmlContent = cardData.content;
      } else if (typeof cardData.content === 'object' && cardData.content?.content) {
        // Object with nested content property
        htmlContent = cardData.content.content;
        if (cardData.content.editSection) {
          editSection = cardData.content.editSection;
        }
      } else {
        htmlContent = cardData.content || '';
      }
      
      cardHTML += `
        <div style="position:relative;">
          <div class="editable" data-edit-type="generic" data-edit-section="${editSection}">${htmlContent}</div>
          ${this.buildEditButton('section')}
        </div>
      `;

      if (cardData.deletable && cardData.sectionName) {
        // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
        cardHTML += `
          <div style="margin-top: 1rem; text-align: center;">
            <button class="section-delete btn small" data-section-name="${cardData.sectionName}" type="button" style="background: #ff6b6b; color: white;">🗑 Supprimer section</button>
          </div>
        `;
      }
      
      cardHTML += `</div>`;
      return cardHTML;
    }


    buildContentItem(item) {
      if (item.type === 'paragraph') {
        const content = `
          <div class="editable-section" data-section-type="paragraph">
            <p class="editable editable-paragraph" data-edit-type="generic" data-edit-section="${item.editSection}">${item.content}</p>
            ${this.buildEditButton('paragraph')}
          </div>
        `;
        const addBtn = this.buildAddParagraphButton(item.editSection);
        return content + addBtn;
      }
      return `<div>${item.content}</div>`;
    }

    buildGridSection(gridSection, sectionIndex) {
      const items = gridSection.content || gridSection.items || [];
      if (!Array.isArray(items)) {
        return '<div><!-- Grid items is not an array --></div>';
      }

      const cols = gridSection.cols || 2;
      let gridHTML = `<div class="grid" style="display: grid; grid-template-columns: repeat(${cols}, 1fr); gap: 1rem;">`;
      
      items.forEach((item, itemIndex) => {
        gridHTML += this.buildCardSection(item, `${sectionIndex}-${itemIndex}`);
      });
      
      gridHTML += '</div>';
      return gridHTML;
    }

    buildComplexContent(content) {
      // Generic HTML content - no special processing
      return content || '';
    }


    buildIllustration(illusKey, altText = '') {
      let imageUrl = '';
      let imageStyle = 'display: none;';
      let removeStyle = 'display: none;';
      
      if (window.JdrApp?.modules?.images?.getImageUrl) {
        imageUrl = window.JdrApp.modules.images.getImageUrl(illusKey);
        if (imageUrl) {
          imageUrl = window.JdrApp.modules.images.processImageUrl(imageUrl);
          imageStyle = 'display: inline-block;';
          removeStyle = 'display: inline-flex;';
        }
      }

      if (JdrApp.utils.isDevMode()) {
        return `
          <div class="illus" data-illus-key="${illusKey}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
            <label class="up">📷 Ajouter<input accept="image/*" hidden="" type="file"></label>
            <button class="rm" type="button" style="${removeStyle}">🗑 Retirer</button>
          </div>
        `;
      }
      
      return `
        <div class="illus" data-illus-key="${illusKey}" data-bound="1">
          <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
        </div>
      `;
    }

    buildFiltersSection(section, sectionIndex) {
      const contentType = section.contentType || 'monster';
      
      // Ensure ContentTypes is loaded
      if (!window.ContentTypes) {
        console.warn('ContentTypes not loaded yet, skipping filters');
        return '';
      }
      
      let config = window.ContentTypes[contentType];
      const filterMode = section.filterMode || 'OR';
      
      // Fallback configuration for monster if not loaded
      if (!config && contentType === 'monster') {
        config = {
          filterConfig: {
            availableTags: ["Foret", "Animal", "Humanoid", "Dragon", "Faible", "Puissant", "Boss", "Feu", "Eau", "Terre", "Air", "Rapide", "Poison"],
            defaultVisibleTags: ["Foret", "Animal", "Humanoid"]
          }
        };
      }
      
      if (!config || !config.filterConfig) {
        return '';
      }
      
      const availableTags = config.filterConfig.availableTags || [];
      const defaultTags = config.filterConfig.defaultVisibleTags || [];
      
      return `
        <div class="filter-section" data-content-type="${contentType}" data-filter-mode="${filterMode}">
          <h3>🔍 Filtres (${filterMode === 'AND' ? 'ET' : 'OU'})</h3>
          <div class="filter-tags" data-default-tags='${JSON.stringify(defaultTags)}'>
            ${availableTags.map(tag => `
              <label class="filter-tag ${defaultTags.includes(tag) ? 'active' : ''}">
                <input type="checkbox" value="${tag}" ${defaultTags.includes(tag) ? 'checked' : ''}>
                <span>${tag}</span>
              </label>
            `).join('')}
          </div>
          ${this.buildDevModeButtons(contentType)}
        </div>
      `;
    }

    buildMonsterListSection(section, sectionIndex) {
      const contentType = section.contentType || 'monster';
      
      return `
        <div class="monster-list-section" data-content-type="${contentType}">
          <div class="monsters-grid" id="monsters-container">
            <!-- Les monstres seront générés par JavaScript -->
          </div>
        </div>
      `;
    }

    buildDevModeButtons(contentType) {
      // Ensure ContentTypes is loaded for proper button generation
      if (!window.ContentTypes) {
        return '';
      }
      
      // For monster type, generate buttons even if config is missing (they'll work with fallback)
      if (contentType !== 'monster' && !window.ContentTypes[contentType]) {
        return '';
      }
      
      // Use the same approach as modal buttons - conditional rendering based on dev mode
      const isDevMode = JdrApp.utils.isDevMode();
      const displayStyle = isDevMode ? 'block' : 'none';
      
      return `
        <div class="dev-mode-buttons" style="margin-top: 1rem; display: ${displayStyle};" data-dev-only="true">
          <button class="btn btn-small add-${contentType}-btn">➕ Ajouter ${contentType === 'monster' ? 'un monstre' : 'un élément'}</button>
          <button class="btn btn-small manage-tags-btn" data-content-type="${contentType}">🏷️ Gérer les tags</button>
        </div>
      `;
    }

    buildEditButton(type) {
      const titles = {
        title: 'Éditer le titre',
        paragraph: 'Éditer ce paragraphe',
        field: 'Éditer ce champ',
        list: 'Éditer cette liste',
        section: 'Éditer cette section'
      };

      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="edit-btn edit-${type}-btn" title="${titles[type] || 'Éditer'}">✏️</button>`;
    }

    buildAddButton(type, categoryName) {
      const config = window.ContentTypes[type];
      const icon = config?.icons?.add || '➕';
      
      // ALWAYS generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="${type}-add btn" data-category-name="${categoryName}" type="button" style="background: var(--accent); color: white;">${icon} Ajouter un ${type === 'spell' ? 'sort' : type === 'don' ? 'don' : type === 'monster' ? 'monstre' : 'élément'}</button>`;
    }

    buildDeleteCategoryButton(type, categoryName) {
      const config = window.ContentTypes[type];
      const deleteIcon = config?.icons?.delete || '🗑️';
      
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="${type}-category-delete btn" data-category-name="${categoryName}" data-category-type="${type}" type="button" style="background: #dc2626; color: white;">${deleteIcon} Supprimer catégorie</button>`;
    }

    buildAddSubclassButton() {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<div class="add-subclass-btn">➕ Ajouter une sous-classe</div>`;
    }

    buildAddSectionButton() {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<div class="add-paragraph-btn" data-target="section">➕ Ajouter une nouvelle section</div>`;
    }

    buildAddParagraphButton(target) {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<div class="add-paragraph-btn" data-target="${target}">➕ Ajouter un paragraphe</div>`;
    }

    buildRemoveSectionButton(sectionType) {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="remove-section-btn" data-section-type="${sectionType}" type="button" style="background: #dc2626; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 12px;">🗑 Supprimer section</button>`;
    }

    getItemsProperty(type) {
      switch (type) {
        case 'spell': return 'sorts';
        case 'don': return 'dons';
        case 'objet': return 'objets';
        case 'class': return 'sousClasses';
        default: return 'items';
      }
    }

    // Extract level number from prerequis text
    extractLevelFromPrerequisite(prerequis) {
      if (!prerequis) return 0;
      const match = prerequis.match(/Niveau (\d+)/i);
      return match ? parseInt(match[1], 10) : 0;
    }

    // Sort spells by level (prerequisite level)
    sortSpellsByLevel(spells) {
      return spells.sort((a, b) => {
        const levelA = this.extractLevelFromPrerequisite(a.prerequis);
        const levelB = this.extractLevelFromPrerequisite(b.prerequis);
        return levelA - levelB;
      });
    }

    // Build spell level filter UI
    buildSpellLevelFilter() {
      return `
        <div class="spell-level-filter" style="margin: 1rem 0; padding: 1rem; background: var(--card); border: 2px solid var(--rule); border-radius: 12px;">
          <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
            <label style="font-weight: 600; color: var(--accent-ink);">
              🎯 Filtrer par niveau maximum :
            </label>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              <input 
                type="number" 
                id="spell-level-filter" 
                min="0" 
                max="20" 
                value="20"
                style="width: 80px; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px; text-align: center; font-weight: 600;"
              >
              <button 
                id="reset-spell-filter" 
                class="btn small" 
                style="background: var(--bronze); color: white; padding: 0.5rem 1rem;"
                title="Réinitialiser le filtre"
              >
                🔄 Tout afficher
              </button>
            </div>
          </div>
        </div>
      `;
    }

    buildIdSearchFilter() {
      const isIdSearchActive = window.activeIdSearch || false;
      const searchBorderColor = isIdSearchActive ? '#16a34a' : 'var(--rule)';
      const searchBoxShadow = isIdSearchActive ? 'box-shadow: 0 0 8px rgba(22, 163, 74, 0.3);' : '';
      const searchIndicator = isIdSearchActive ? '🎯 ' : '🔍 ';
      const buttonText = isIdSearchActive ? '🔄 Affichage normal' : '🔄 Tout afficher';
      const buttonTitle = isIdSearchActive ? 'Retourner à l\'affichage normal avec filtres' : 'Effacer la recherche et afficher tous les objets';
      
      return `
        <div class="id-search-filter" style="margin: 0.5rem 0; background: var(--card); border: 2px solid ${searchBorderColor}; border-radius: 12px; display: flex; flex-direction: column; ${searchBoxShadow}">
          <div style="display: flex; align-items: center; justify-content: center; gap: 1rem; flex-wrap: wrap; padding: 0.375rem; min-height: 2.5rem;">
            <label for="id-search-input" style="font-weight: 600; color: var(--accent-ink); white-space: nowrap; display: flex; align-items: center; height: 100%;">
              ${searchIndicator}Recherche par ID :
            </label>
            <div style="display: flex; align-items: center; gap: 0.5rem; height: 100%;">
              <input 
                type="number" 
                id="id-search-input" 
                min="1" 
                placeholder="Numéro d'objet (ex: 42)"
                style="padding: 0.2rem; border: 1px solid ${searchBorderColor}; border-radius: 6px; font-size: 0.95em; width: 150px; height: 2rem; display: flex; align-items: center;"
              >
              <button 
                id="clear-id-search" 
                class="btn small" 
                style="background: var(--bronze); color: white; padding: 0.2rem 0.4rem; white-space: nowrap; font-size: 0.9em; display: flex; align-items: center; height: 2rem; justify-content: center;"
                title="${buttonTitle}"
              >
                ${buttonText}
              </button>
            </div>
          </div>
          <div id="id-search-result" style="padding: 0 0.375rem 0.375rem; font-size: 0.85em; color: var(--paper-muted); min-height: 0.5em; line-height: 1.2; text-align: center;">
            <!-- Résultat de la recherche affiché ici -->
          </div>
        </div>
      `;
    }

    buildObjectsCategoryDescription() {
      // Initialize description if it doesn't exist  
      if (!window.OBJETS.description) {
        window.OBJETS.description = "Équipements, armes, armures et objets divers que peuvent posséder les personnages.";
      }
      
      return `
        <div class="objects-category-description" style="margin: 1rem 0; padding: 1rem; background: var(--card); border-radius: 8px; border-left: 4px solid var(--bronze);">
          <div class="editable-section" data-section-type="objet-category-description">
            <p class="lead editable editable-paragraph" data-edit-type="generic" data-edit-section="description">${window.OBJETS.description}</p>
            ${this.buildEditButton('section')}
          </div>
        </div>
      `;
    }

    buildMonstersCategoryDescription() {
      // Create a description object for monsters if it doesn't exist
      if (!window.MONSTRES_PAGE_DESC) {
        window.MONSTRES_PAGE_DESC = {
          description: "Créatures, ennemis et adversaires que peuvent affronter les héros dans leurs aventures."
        };
      }
      
      return `
        <div class="monsters-category-description" style="margin: 1rem 0; padding: 1rem; background: var(--card); border-radius: 8px; border-left: 4px solid var(--bronze);">
          <div class="editable-section" data-section-type="monster-category-description">
            <p class="lead editable editable-paragraph" data-edit-type="generic" data-edit-section="description">${window.MONSTRES_PAGE_DESC.description}</p>
            ${this.buildEditButton('section')}
          </div>
        </div>
      `;
    }

    buildTagFilters(visibleTags, availableTags, context = 'objet') {
      const isIdSearchActive = window.activeIdSearch || false;
      const containerOpacity = isIdSearchActive ? '0.4' : '1';
      const containerFilter = isIdSearchActive ? 'grayscale(1)' : 'none';
      const pointerEvents = isIdSearchActive ? 'none' : 'auto';
      
      // Créer des chips pour tous les tags disponibles avec indicateur actif/inactif
      const allFilterChips = availableTags.map(tag => {
        const isActive = visibleTags.includes(tag);
        const bgColor = isActive ? '#16a34a' : '#6b7280'; // Vert pour actif, gris pour inactif
        const textColor = 'white';
        const opacity = isActive ? '1' : '0.6';
        
        return `<span class="filter-chip ${isActive ? 'active' : 'inactive'}" 
                      data-tag="${tag}" 
                      style="background: ${bgColor}; color: ${textColor}; opacity: ${opacity}; 
                             padding: 6px 12px; border-radius: 20px; font-size: 0.9em; font-weight: 500;
                             cursor: pointer; transition: all 0.2s ease; border: 2px solid transparent;
                             ${isActive ? 'box-shadow: 0 2px 4px rgba(22, 163, 74, 0.3);' : ''}"
                      title="${isActive ? 'Actif - Cliquer pour désactiver' : 'Inactif - Cliquer pour activer'}">
                  ${isActive ? '✓ ' : ''}${tag}
                </span>`;
      }).join('');
      
      // Only show "Tous" and "Aucun" buttons for objects, not for monsters
      const showSelectAllButtons = context !== 'monster';
      
      return `
        <div class="objects-tag-display" style="margin: 1rem 0; padding: 1rem; background: var(--card); border: 2px solid var(--rule); border-radius: 12px; opacity: ${containerOpacity}; filter: ${containerFilter}; pointer-events: ${pointerEvents}; transition: all 0.3s ease;">
          ${showSelectAllButtons ? `
            <div style="display: flex; justify-content: center; gap: 0.5rem; margin-bottom: 1rem;">
              <button 
                id="select-all-tags" 
                class="btn small" 
                style="background: #3b82f6; color: white; padding: 4px 8px; font-size: 0.8em; border-radius: 12px;"
                title="Activer tous les tags"
              >
                ✓ Tous
              </button>
              <button 
                id="select-no-tags" 
                class="btn small" 
                style="background: #6b7280; color: white; padding: 4px 8px; font-size: 0.8em; border-radius: 12px;"
                title="Désactiver tous les tags"
              >
                ✗ Aucun
              </button>
            </div>
          ` : ''}
          <div class="filter-chips" style="display: flex; gap: 0.5rem; flex-wrap: wrap; justify-content: center;">
            ${allFilterChips}
          </div>
        </div>
      `;
    }
    
    buildFilterManagerButton() {
      // Only show in dev mode
      if (!this.shouldShowEditButtons) {
        return '';
      }
      return `<button class="filter-manager-btn btn" type="button" style="background: var(--bronze); color: white;">⚙️ Gérer les filtres</button>`;
    }

    buildTagsManagerButton() {
      // Only show in dev mode - use direct utils check
      if (!JdrApp.utils.isDevMode()) {
        return '';
      }
      return `<button class="tags-manager-btn btn" type="button" style="background: #dc2626; color: white; border: 2px solid #b91c1c;">🏷️ Gérer les tags</button>`;
    }

    buildGeneralDonsSection(type, categoryName) {
      // Only add General Dons section for 'don' type pages, and not for the 'Generaux' category itself
      if (type !== 'don' || categoryName === 'Generaux') {
        return '';
      }

      // Find the "Generaux" category in the DONS data
      const generalCategory = window.DONS?.find(cat => cat.nom === 'Generaux');
      if (!generalCategory || !generalCategory.dons || generalCategory.dons.length === 0) {
        return '';
      }

      // Generate cards for all general dons
      const generalDonsCards = generalCategory.dons.map((don, index) => 
        CardBuilder.create('don', don, 'Generaux', index).build()
      ).join('');

      return `
        <div style="margin-top: 2rem; padding-top: 1.5rem; border-top: 2px solid var(--rule);">
          <h3 style="color: var(--bronze); margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
            🎖️ Dons Généraux
          </h3>
          <p style="margin-bottom: 1.5rem; font-style: italic; color: var(--accent-ink); opacity: 0.8;">
            Ces dons sont accessibles à toutes les classes et peuvent compléter votre build.
          </p>
          <div class="grid cols-2">
            ${generalDonsCards}
          </div>
        </div>
      `;
    }

    buildFilterManagerButton() {
      // ALWAYS generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="filter-manager-btn btn" type="button" style="background: #16a34a; color: white; border: 2px solid #15803d;">🔧 Gérer les filtres</button>`;
    }
    
    buildTagsManagerButton() {
      // ALWAYS generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="tags-manager-btn btn" type="button" style="background: #dc2626; color: white; border: 2px solid #b91c1c;">🏷️ Gérer les tags</button>`;
    }

    sanitizeId(str) {
      return str.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    }
  }

  window.PageBuilder = PageBuilder.getInstance();

})();
// ============================================================================
// JDR-BAB APPLICATION - UTILITIES MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // DEV MODE UTILITIES
  // ========================================
  JdrApp.utils.isDevMode = function() {
    // Simple check - if it's standalone, dev mode is always false
    if (window.STANDALONE_VERSION) return false;
    
    // Use the editor's actual state instead of CSS classes for reliability
    if (JdrApp.modules && JdrApp.modules.editor) {
      return JdrApp.modules.editor.isDevMode;
    }
    
    // Fallback: check body class if editor not available yet
    return document.body.classList.contains('dev-on');
  };

  // ========================================
  // CENTRALIZED EVENT MANAGEMENT
  // ========================================
  JdrApp.utils.events = {
    listeners: new Map(),
    
    // Centralized event registration
    register(type, selector, handler, options = {}) {
      const key = `${type}-${selector || 'window'}-${Date.now()}`;
      const wrapper = (e) => {
        if (!selector) {
          handler(e);
        } else {
          // Gérer les sélecteurs spéciaux comme [class$="-add"]
          if (this.matchesSelector(e.target, selector)) {
            handler(e);
          }
        }
      };
      
      if (selector) {
        document.addEventListener(type, wrapper, options);
      } else {
        window.addEventListener(type, wrapper, options);
      }
      
      this.listeners.set(key, { type, wrapper, options });
      return key;
    },

    // Helper pour matcher les sélecteurs complexes
    matchesSelector(element, selector) {
      // Gérer les sélecteurs d'attributs comme [class$="-add"]
      if (selector.startsWith('[class$="') && selector.endsWith('"]')) {
        const suffix = selector.slice(9, -2); // Extraire "-add" de '[class$="-add"]'
        return element.className && element.className.split(' ').some(cls => cls.endsWith(suffix));
      }
      
      // Gérer les sélecteurs d'attributs comme [class*="something"]
      if (selector.startsWith('[class*="') && selector.endsWith('"]')) {
        const substring = selector.slice(9, -2); // Extraire "something" 
        return element.className && element.className.includes(substring);
      }
      
      // Utiliser la méthode native pour les autres sélecteurs
      try {
        return element.matches(selector) || element.closest(selector);
      } catch (e) {
        // Fallback pour les sélecteurs invalides
        return false;
      }
    },
    
    // Delayed execution manager
    delayed: new Map(),
    timeout(key, fn, delay = 0) {
      if (this.delayed.has(key)) {
        clearTimeout(this.delayed.get(key));
      }
      const id = setTimeout(() => {
        fn();
        this.delayed.delete(key);
      }, delay);
      this.delayed.set(key, id);
    },
    
    // Common event handlers
    onDOMReady(fn) {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', fn);
      } else {
        fn();
      }
    },
    
    onHashChange(fn) {
      window.addEventListener('hashchange', fn);
    },
    
    onRouteChange(fn) {
      this.onHashChange(() => this.timeout('route-change', fn, 0));
      this.onDOMReady(() => this.timeout('dom-ready-route', fn, 0));
    }
  };

  // ========================================
  // DOM UTILITIES LIBRARY
  // ========================================
  JdrApp.utils.dom = {
    // Common selectors
    $(selector) { return document.querySelector(selector); },
    $(selector) { return document.querySelectorAll(selector); },
    
    // Element creation with common patterns
    create(tag, className = '', innerHTML = '', attributes = {}) {
      const el = document.createElement(tag);
      if (className) el.className = className;
      if (innerHTML) el.innerHTML = innerHTML;
      Object.entries(attributes).forEach(([key, value]) => {
        el.setAttribute(key, value);
      });
      return el;
    },
    
    
    // Safe innerHTML replacement
    safeSetHTML(element, html) {
      if (element) {
        element.innerHTML = html;
      }
    },
    
    // Safe text content setting
    safeSetText(element, text) {
      if (element) {
        element.textContent = text;
      }
    },
    
    // Toggle class utility
    toggleClass(element, className, force = null) {
      if (element) {
        if (force !== null) {
          element.classList.toggle(className, force);
        } else {
          element.classList.toggle(className);
        }
      }
    },
    
    // Show/hide utilities
    show(element, display = 'block') {
      if (element) {
        element.style.display = display;
      }
    },
    
    hide(element) {
      if (element) {
        element.style.display = 'none';
      }
    }
  };

  // ========================================
  // DATA UTILITIES
  // ========================================
  JdrApp.utils.data = {
    // Find spell by name across all categories
    findSpell(name) {
      if (!window.SORTS) return null;
      
      for (const category of window.SORTS) {
        const spell = category.sorts.find(s => s.nom === name);
        if (spell) return { spell, category: category.nom };
      }
      return null;
    },
    
    // Find class by name
    findClass(name) {
      if (!window.CLASSES) return null;
      return window.CLASSES.find(c => c.nom === name);
    },
    
    // Find don by name across all categories
    findDon(name) {
      if (!window.DONS) return null;
      
      for (const category of window.DONS) {
        const don = category.dons.find(d => d.nom === name);
        if (don) return { don, category: category.nom };
      }
      return null;
    },
    
    // Get spell category by name
    getSpellCategory(categoryName) {
      if (!window.SORTS) return null;
      return window.SORTS.find(cat => cat.nom === categoryName);
    },
    
    // Get don category by name
    getDonCategory(categoryName) {
      if (!window.DONS) return null;
      return window.DONS.find(cat => cat.nom === categoryName);
    },
    
    // Deep clone object
    deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    },
    
    // Sanitize string for use as identifier
    sanitizeId(str) {
      return str.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    },
    
    // Generate unique ID
    generateId(prefix = 'id') {
      return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    },
    
    // Escape HTML
    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  };

  // ========================================
  // IMAGE UTILITIES
  // ========================================
  
  // Compress image function
  JdrApp.utils.compressImage = function(file, maxWidth = 800, quality = 0.85) {
    return new Promise((resolve, reject) => {
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      img.onload = function() {
        // Calculate new dimensions
        let { width, height } = img;
        
        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }
        
        // Set canvas size
        canvas.width = width;
        canvas.height = height;
        
        // Detect if image has transparency (PNG)
        const isPNG = file.type === 'image/png' || file.name.toLowerCase().endsWith('.png');
        
        if (isPNG) {
          // For PNG, don't compress at all to preserve quality
          resolve(file);
        } else {
          // For JPEG/other formats, use white background
          ctx.fillStyle = '#FFFFFF';
          ctx.fillRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);
          
          canvas.toBlob((blob) => {
            resolve(blob);
          }, 'image/jpeg', quality);
        }
      };
      
      img.onerror = (error) => {
        reject(error);
      };
      
      img.src = URL.createObjectURL(file);
    });
  };

  // Upload to ImageBB function
  JdrApp.utils.uploadToImageBB = function(file) {
    return new Promise((resolve, reject) => {
      // ImageBB API key
      const API_KEY = '06a98f5c0c2dad952e6ab94b03040f36';
      
      const formData = new FormData();
      formData.append('image', file);
      
      fetch(`https://api.imgbb.com/1/upload?key=${API_KEY}`, {
        method: 'POST',
        body: formData
      })
      .then(response => {
        return response.json();
      })
      .then(data => {
        if (data.success) {
          resolve(data.data.url);
        } else {
          throw new Error('Upload failed: ' + (data.error ? data.error.message : 'Unknown error'));
        }
      })
      .catch(error => {
        // Fallback to local storage
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    });
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - IMAGES MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // IMAGES MANAGEMENT MODULE
  // ========================================
  JdrApp.modules.images = {
    // Store for preloaded images
    imageStore: {},
    
    async init() {
      await this.loadImageData();
      this.initImageHandlers();
      
      // Auto-sync monster images on startup to ensure consistency
      setTimeout(() => {
        this.ensureMonsterImageMappings();
      }, 1000);
    },

    // Load image data from JSON file or embedded data
    async loadImageData() {
      try {
        if (window.IMAGES) {
          this.imageStore = window.IMAGES.images || window.IMAGES || {};
          return;
        }
        
        const response = await fetch('./data/images.json');
        if (response.ok) {
          const data = await response.json();
          this.imageStore = data.images || {};
        } else {
          this.imageStore = {};
        }
      } catch (error) {
        this.imageStore = {};
      }
    },

    // Get image URL for a given key
    getImageUrl(illusKey) {
      return this.imageStore[illusKey] || null;
    },

    // Apply image to an illustration element
    applyImage(illusElement, imageUrl) {
      if (!illusElement || !imageUrl) return;

      const img = illusElement.querySelector('img.thumb');
      if (!img) return;

      // Set image source and make it visible
      img.src = this.processImageUrl(imageUrl);
      img.style.display = 'inline-block';
      img.style.opacity = '1'; // Reset opacity after upload
      
      // Show remove button if it exists
      const removeBtn = illusElement.querySelector('.rm');
      if (removeBtn) {
        removeBtn.style.display = 'inline-flex';
      }

    },

    // Process image URL to handle proxying for mobile compatibility
    processImageUrl(originalUrl) {
      // If it's an i.ibb.co URL, use proxy for better mobile compatibility
      if (originalUrl.includes('i.ibb.co') && !originalUrl.includes('images.weserv.nl')) {
        return `https://images.weserv.nl/?url=${encodeURIComponent(originalUrl)}`;
      }
      
      // For local monster paths, encode only the filename to handle French characters properly
      if (originalUrl.startsWith('data/images/Monstres/')) {
        const pathParts = originalUrl.split('/');
        const filename = pathParts[pathParts.length - 1];
        const pathWithoutFilename = pathParts.slice(0, -1).join('/');
        return `${pathWithoutFilename}/${encodeURIComponent(filename)}`;
      }
      
      return originalUrl;
    },

    autoLoadImages() {
      const illusElements = document.querySelectorAll('[data-illus-key]');
      let loadedCount = 0;

      illusElements.forEach(illusElement => {
        const illusKey = illusElement.dataset.illusKey;
        const imageUrl = this.getImageUrl(illusKey);
        
        if (imageUrl) {
          this.applyImage(illusElement, imageUrl);
          loadedCount++;
        }
      });

      return loadedCount;
    },

    // Initialize image upload handlers
    initImageHandlers() {
      // Delegate image upload handling
      document.addEventListener('change', (event) => {
        if (event.target.matches('.illus input[type="file"]')) {
          this.handleImageUpload(event.target);
        }
      });

      // Delegate image removal handling  
      document.addEventListener('click', (event) => {
        if (event.target.matches('.illus .rm')) {
          this.handleImageRemoval(event.target);
        }
      });
    },

    // Handle image upload
    async handleImageUpload(fileInput) {
      const file = fileInput.files[0];
      if (!file) return;

      const illusElement = fileInput.closest('.illus');
      if (!illusElement) return;

      const illusKey = illusElement.dataset.illusKey;
      
      try {
        // Show loading state
        const img = illusElement.querySelector('img.thumb');
        if (img) {
          img.style.opacity = '0.5';
        }

        // Compress and upload image
        const compressedFile = await JdrApp.utils.compressImage(file, 800, 0.8);
        const imageUrl = await JdrApp.utils.uploadToImageBB(compressedFile);
        
        // Apply the uploaded image
        this.applyImage(illusElement, imageUrl);
        
        // Update local store
        this.imageStore[illusKey] = imageUrl;
        
        // Auto-sync to prevent loss of image assignments
        this.autoSyncImages();
        
        
      } catch (error) {
        // Reset loading state
        const img = illusElement.querySelector('img.thumb');
        if (img) {
          img.style.opacity = '1';
        }
        
        alert('Erreur lors du téléchargement de l\'image. Veuillez réessayer.');
      }
      
      // Clear file input
      fileInput.value = '';
    },

    // Handle image removal
    handleImageRemoval(removeBtn) {
      const illusElement = removeBtn.closest('.illus');
      if (!illusElement) return;

      const illusKey = illusElement.dataset.illusKey;
      const img = illusElement.querySelector('img.thumb');
      
      if (img) {
        img.src = '';
        img.style.display = 'none';
      }
      
      removeBtn.style.display = 'none';
      
      // Remove from store
      delete this.imageStore[illusKey];
      
      // Auto-sync to update persistent storage
      this.autoSyncImages();
    },

    // Manually add/update an image
    setImage(illusKey, imageUrl) {
      this.imageStore[illusKey] = imageUrl;
      
      // Apply to any existing elements with this key
      const illusElements = document.querySelectorAll(`[data-illus-key="${illusKey}"]`);
      illusElements.forEach(element => {
        this.applyImage(element, imageUrl);
      });
      
      // Auto-sync to prevent loss
      this.autoSyncImages();
    },

    // Get all current images for export
    getAllImages() {
      return { ...this.imageStore };
    },

    // Import images from external data
    importImages(imageData) {
      if (typeof imageData === 'object' && imageData !== null) {
        Object.assign(this.imageStore, imageData);
        this.autoLoadImages();
      }
    },

    // Auto-sync images to prevent data loss
    autoSyncImages() {
      // Ensure we have monster image mappings for all existing monsters
      this.ensureMonsterImageMappings();
      
      // Trigger auto-save if available
      if (JdrApp.modules.storage && JdrApp.modules.storage.saveChanges) {
        JdrApp.modules.storage.saveChanges(true); // Silent save
      }
    },

    // Ensure all monsters have image mappings in images.json structure
    ensureMonsterImageMappings() {
      if (!window.MONSTRES || !Array.isArray(window.MONSTRES)) {
        return;
      }

      let hasUpdates = false;

      window.MONSTRES.forEach(monster => {
        const imageKey = `monster:${monster.nom}`;
        
        // If monster has no image mapping in store, create one
        if (!this.imageStore[imageKey]) {
          // Check if monster has a valid image path
          if (monster.image && monster.image.trim()) {
            this.imageStore[imageKey] = monster.image;
            hasUpdates = true;
            console.log(`📷 Auto-synced image for monster: ${monster.nom}`);
          }
        }
        
        // Also validate that the image file exists
        this.validateMonsterImagePath(monster);
      });

      if (hasUpdates) {
        console.log('✅ Auto-synced monster image mappings');
      }
    },

    // Validate and fix monster image paths
    validateMonsterImagePath(monster) {
      if (!monster.image || !monster.nom) {
        return false;
      }

      // Extract filename from current path
      const currentPath = monster.image;
      const filename = currentPath.split('/').pop();
      
      // Check if path follows correct format
      const expectedPattern = /^data\/images\/Monstres\/foret\/Monstre_Forêt_\w+\.png$/;
      
      if (!expectedPattern.test(currentPath)) {
        // Try to fix common issues
        let correctedPath = null;
        
        // Map common filename patterns to correct paths
        const filenameMap = {
          'araignee-geante.png': 'Monstre_Forêt_Araignée.png',
          'crabe-des-bois.png': 'Monstre_Forêt_Crab.png',  
          'groink.png': 'Monstre_Forêt_Groink.png',
          'groink-chaman.png': 'Monstre_Forêt_Groink_Chaman.png',
          'guepe-geante.png': 'Monstre_Forêt_GuepeGeante.png',
          'ours-des-bois.png': 'Monstre_Forêt_Ours.png'
        };

        if (filenameMap[filename]) {
          correctedPath = `data/images/Monstres/foret/${filenameMap[filename]}`;
        } else if (!filename.startsWith('Monstre_Forêt_')) {
          // Try to construct path from monster name
          const safeName = monster.nom.replace(/[^a-zA-Z0-9àâäéèêëïîôùûüÿçÀÂÄÉÈÊËÏÎÔÙÛÜŸÇ_]/g, '');
          correctedPath = `data/images/Monstres/foret/Monstre_Forêt_${safeName}.png`;
        }

        if (correctedPath && correctedPath !== currentPath) {
          console.log(`🔧 Auto-correcting image path for ${monster.nom}:`);
          console.log(`   From: ${currentPath}`);
          console.log(`   To: ${correctedPath}`);
          
          // Update monster data
          monster.image = correctedPath;
          
          // Update image mapping
          const imageKey = `monster:${monster.nom}`;
          this.imageStore[imageKey] = correctedPath;
          
          return true;
        }
      }
      
      return false;
    },

    // Force synchronization of all monster data
    forceSyncMonsterImages() {
      // console.log('🔄 Force syncing monster images...');
      
      let syncCount = 0;
      
      if (window.MONSTRES && Array.isArray(window.MONSTRES)) {
        window.MONSTRES.forEach(monster => {
          const corrected = this.validateMonsterImagePath(monster);
          if (corrected) {
            syncCount++;
          }
        });
      }
      
      this.ensureMonsterImageMappings();
      
      // console.log(`✅ Force sync completed. ${syncCount} paths corrected.`);
      
      // Save changes
      if (JdrApp.modules.storage && JdrApp.modules.storage.saveChanges) {
        JdrApp.modules.storage.saveChanges(true);
      }
      
      return syncCount;
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - STORAGE MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // STORAGE MODULE
  // ========================================
  JdrApp.modules.storage = {
    
    init() {
      
      // Clear localStorage on startup - JSON files are always source of truth
      this.clearStorageOnStartup();
      
      // Set up save handlers
      JdrApp.utils.events.register('click', '#saveAndExport', () => this.saveAndExportZip());
      
      
      
      // Auto-save functionality
      this.setupAutoSave();
    },

    setupAutoSave() {
      // Auto-save disabled - we save immediately on each edit instead
      // Previously: Auto-save every 30 seconds if in dev mode
    },

    clearStorageOnStartup() {
      // Clear all localStorage data on page load - JSON files are source of truth
      localStorage.removeItem('jdr-bab-edits');
      localStorage.removeItem('jdr-bab-static-pages');
      localStorage.removeItem('jdr-bab-last-modified');
    },

    saveChanges(silent = false) {
      try {
        // Force collect all pending edits
        const editedData = JdrApp.modules.editor ? JdrApp.modules.editor.forceCollectAllEdits() : {};
        
        // Data is already saved in memory (window.STATIC_PAGES, window.SORTS, etc.)
        // No localStorage persistence needed - JSON files are source of truth
        
        if (!silent) {
          this.showNotification('💾 Modifications sauvegardées en mémoire', 'success');
        }
        
      } catch (error) {
        console.error('❌ Failed to save changes:', error);
        if (!silent) {
          this.showNotification('❌ Erreur lors de la sauvegarde', 'error');
        }
      }
    },

    async saveAndExportZip() {
      try {
        this.showNotification('📦 Création de l\'archive ZIP...', 'info');
        
        // Force collect all pending edits
        JdrApp.modules.editor.forceCollectAllEdits();
        
        // Check if JSZip is available
        if (typeof JSZip === 'undefined') {
          await this.loadJSZip();
        }
        
        const zip = new JSZip();
        
        // Add main HTML file
        const mainHTML = await this.getMainHTML();
        zip.file('index.html', mainHTML);
        
        // Add CSS files
        const cssFiles = ['theme.css', 'utilities.css', 'components.css', 'layout.css', 'editor.css'];
        for (const cssFile of cssFiles) {
          const cssContent = await this.fetchFileContent(`css/${cssFile}`);
          if (cssContent) {
            zip.file(`css/${cssFile}`, cssContent);
          }
        }
        
        // Add JS files
        const jsFiles = ['core.js', 'utils.js', 'router.js', 'renderer.js', 'editor.js', 'storage.js', 'ui.js'];
        for (const jsFile of jsFiles) {
          const jsContent = await this.fetchFileContent(`js/${jsFile}`);
          if (jsContent) {
            zip.file(`js/${jsFile}`, jsContent);
          }
        }
        
        // Add modules
        const moduleFiles = ['images.js'];
        for (const moduleFile of moduleFiles) {
          const moduleContent = await this.fetchFileContent(`js/modules/${moduleFile}`);
          if (moduleContent) {
            zip.file(`js/modules/${moduleFile}`, moduleContent);
          }
        }
        
        // Add data files with current edits
        zip.file('data/sorts.json', JSON.stringify(window.SORTS, null, 2));
        zip.file('data/classes.json', JSON.stringify(window.CLASSES, null, 2));
        zip.file('data/dons.json', JSON.stringify(window.DONS, null, 2));
        zip.file('data/objets.json', JSON.stringify(window.OBJETS, null, 2));
        
        // Add monsters data with current edits
        if (window.MONSTRES) {
          zip.file('data/monstres.json', JSON.stringify(window.MONSTRES, null, 2));
        }
        
        // Add TOC structure with new pages
        if (window.TOC_STRUCTURE) {
          zip.file('data/toc-structure.json', JSON.stringify(window.TOC_STRUCTURE, null, 2));
        }
        
        // Add ContentTypes configuration (includes availableTags modifications)
        if (window.ContentTypes) {
          const updatedContentTypesJS = this.generateContentTypesJS(window.ContentTypes);
          zip.file('js/config/contentTypes.js', updatedContentTypesJS);
        }
        
        // Add static pages config and data
        if (window.STATIC_PAGES_CONFIG) {
          zip.file('data/static-pages-config.json', JSON.stringify(window.STATIC_PAGES_CONFIG, null, 2));
        }
        
        if (window.STATIC_PAGES) {
          for (const [pageId, pageData] of Object.entries(window.STATIC_PAGES)) {
            zip.file(`data/${pageId}.json`, JSON.stringify(pageData, null, 2));
          }
        }
        
        // Note: All static pages are now handled via window.STATIC_PAGES above
        
        // Add current images (including newly uploaded ones)
        if (JdrApp.modules.images && JdrApp.modules.images.getAllImages) {
          const currentImages = JdrApp.modules.images.getAllImages();
          const imagesData = {
            images: currentImages,
            meta: {
              total_images: Object.keys(currentImages).length,
              exported_date: new Date().toISOString().slice(0, 10),
              note: "Ces images incluent les nouvelles images uploadées"
            }
          };
          zip.file('data/images.json', JSON.stringify(imagesData, null, 2));
        }
        
        // Add package.json and other config files
        const configFiles = ['package.json'];
        for (const configFile of configFiles) {
          const configContent = await this.fetchFileContent(configFile);
          if (configContent) {
            zip.file(configFile, configContent);
          }
        }
        
        // Generate and download ZIP
        const zipBlob = await zip.generateAsync({type: 'blob'});
        const timestamp = new Date().toISOString().slice(0, 16).replace(/[:-]/g, '');
        this.downloadFile(`JdrBab-${timestamp}.zip`, zipBlob, 'application/zip');
        
        this.showNotification('📦 Archive ZIP créée et téléchargée!', 'success');
        
      } catch (error) {
        console.error('❌ Failed to create ZIP:', error);
        this.showNotification('❌ Erreur lors de la création du ZIP', 'error');
      }
    },

    generateContentTypesJS(contentTypes) {
      // Generate the updated contentTypes.js file with current availableTags
      const availableTags = contentTypes.objet?.filterConfig?.availableTags || [];
      const defaultVisibleTags = contentTypes.objet?.filterConfig?.defaultVisibleTags || [];
      
      // Get monster tags configuration
      const monsterAvailableTags = contentTypes.monster?.filterConfig?.availableTags || [];
      const monsterDefaultVisibleTags = contentTypes.monster?.filterConfig?.defaultVisibleTags || [];
      
      return `// ============================================================================
// JDR-BAB APPLICATION - CONTENT TYPES CONFIGURATION
// ============================================================================

(() => {
  "use strict";

  window.ContentTypes = {
    spell: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        element: { type: 'select', label: 'Élément', required: true, options: ['Feu', 'Eau', 'Terre', 'Air', 'Lumière', 'Nuit', 'Divin', 'Maléfique'] },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'Prérequis', required: true },
        portee: { type: 'richtext', label: 'Portée', required: true },
        tempsIncantation: { type: 'richtext', label: "Temps d'incantation", required: true },
        coutMana: { type: 'richtext', label: 'Coût mana', required: true },
        resistance: { type: 'richtext', label: 'Résistance', required: true },
        effetNormal: { type: 'richtext', label: 'Effet normal', required: true },
        effetCritique: { type: 'richtext', label: 'Effet critique', required: false }
      },
      editMapping: {
        'spell-name': 'nom',
        'spell-element': 'element',
        'spell-description': 'description',
        'spell-prerequis': 'prerequis',
        'spell-portee': 'portee',
        'spell-mana': 'coutMana',
        'spell-temps-incantation': 'tempsIncantation',
        'spell-resistance': 'resistance',
        'spell-effect-normal': 'effetNormal',
        'spell-effect-critical': 'effetCritique'
      },
      identifiers: {
        name: 'nom',
        category: 'sorts'
      },
      template: 'spell-card',
      container: 'sorts',
      dataKey: 'SORTS',
      icons: { 
        category: '🔮', 
        item: '✨',
        add: '➕',
        delete: '🗑️'
      },
      defaultValues: {
        nom: "Nouveau Sort",
        element: "Feu",
        description: "Lance une boule de Feu sur un adversaire.",
        prerequis: "📋 <strong>Prérequis:</strong> Niveau 1",
        portee: "🎯 <strong>Portée:</strong> 20m",
        tempsIncantation: "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        coutMana: "🔵 <strong>Coût mana:</strong> 3",
        resistance: "<strong>Sans effet si:</strong> Esquive.",
        effetNormal: "<strong>Effet:</strong> Inflige 5 dégats de <span style='color: #e25822; font-weight: bold;'>Feu</span> à la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        effetCritique: "<strong>Coup Critique:&nbsp;</strong>&nbsp;Double les dégâts et enflamme la cible."
      }
    },

    don: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'Prérequis', required: true },
        cout: { type: 'richtext', label: 'Coût', required: true }
      },
      editMapping: {
        'don-name': 'nom',
        'don-description': 'description',
        'don-prerequis': 'prerequis',
        'don-cout': 'cout'
      },
      identifiers: {
        name: 'nom',
        category: 'dons'
      },
      template: 'don-card',
      container: 'dons',
      dataKey: 'DONS',
      icons: { 
        category: '🎖️', 
        item: '🏆',
        add: '➕',
        delete: '🗑️'
      },
      defaultValues: {
        nom: "Nouveau Don",
        description: "Description du don.",
        prerequis: "Aucun prérequis",
        cout: "1 point de don"
      }
    },

    class: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        resume: { type: 'textarea', label: 'Résumé', required: true },
        capacites: { type: 'list', label: 'Capacités', required: true }
      },
      editMapping: {
        'class-name': 'nom',
        'class-resume': 'resume',
        'class-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: null
      },
      template: 'class-page',
      container: 'classes',
      dataKey: 'CLASSES',
      icons: { 
        category: '⚔️', 
        item: '🛡️',
        add: '➕',
        delete: '🗑️'
      }
    },

    subclass: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        base: { type: 'stats', label: 'Statistiques de base', required: true },
        progression: { type: 'richtext', label: 'Progression', required: true },
        capacites: { type: 'list', label: 'Capacités', required: true }
      },
      editMapping: {
        'subclass-name': 'nom',
        'subclass-description': 'description',
        'subclass-stats': 'base',
        'subclass-progression': 'progression',
        'subclass-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: 'sousClasses',
        parent: 'class'
      },
      template: 'subclass-card',
      icons: { 
        item: '⚡',
        add: '➕',
        delete: '🗑️'
      },
      defaultValues: {
        nom: "Nouvelle sous-classe",
        description: "Description de la sous-classe",
        base: {
          Force: 3,
          Agilité: 3,
          Endurance: 3,
          Intelligence: 3,
          Volonté: 3,
          Chance: 3
        },
        progression: "<strong>📈 Progression par niveau:</strong> +1 Force 💪, +1 Agilité 🏃",
        capacites: [
          "<em>Capacité unique</em>: Description de la capacité spéciale de cette sous-classe."
        ]
      }
    },

    objet: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        numero: { type: 'number', label: 'Numéro', required: true },
        image: { type: 'text', label: 'Image', required: false },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        effet: { type: 'richtext', label: 'Effet', required: true },
        prix: { type: 'richtext', label: 'Prix', required: true },
        poids: { type: 'richtext', label: 'Poids', required: true }
      },
      editMapping: {
        'objet-name': 'nom',
        'objet-numero': 'numero',
        'objet-image': 'image',
        'objet-description': 'description',
        'objet-tags': 'tags',
        'objet-effet': 'effet',
        'objet-prix': 'prix',
        'objet-poids': 'poids'
      },
      identifiers: {
        name: 'nom',
        category: 'objets'
      },
      template: 'objet-card',
      container: 'objets',
      dataKey: 'OBJETS',
      pageType: 'single', // Page unique avec filtres
      icons: { 
        category: '📦', 
        item: '🎒',
        add: '➕',
        delete: '🗑️'
      },
      // Configuration des filtres disponibles (MISE À JOUR AUTOMATIQUE)
      filterConfig: {
        availableTags: ${JSON.stringify(availableTags, null, 10)},
        defaultVisibleTags: ${JSON.stringify(defaultVisibleTags, null, 10)} // Filtres affichés par défaut
      },
      defaultValues: {
        nom: "Nouvel Objet",
        numero: 1,
        image: "",
        description: "Description de l'objet.",
        tags: ["Arme"],
        effet: "<strong>Effet:</strong> Description de l'effet de l'objet.",
        prix: "🔷 <strong>Prix:</strong> 10",
        poids: "⚖️ <strong>Poids:</strong> 1"
      }
    },

    monster: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        image: { type: 'text', label: 'Image', required: false },
        element: { 
          type: 'select', 
          label: "Élément d'affiliation", 
          required: true,
          options: [
            { value: 'Feu', label: '🔥 Feu' },
            { value: 'Eau', label: '💧 Eau' },
            { value: 'Terre', label: '🤎 Terre' },
            { value: 'Air', label: '🟢 Air' },
            { value: 'Lumiere', label: '☀️ Lumière' },
            { value: 'Nuit', label: '⚫ Nuit' },
            { value: 'Divin', label: '⚪ Divin' },
            { value: 'Malefique', label: '🟣 Maléfique' }
          ]
        },
        pointsDeVie: { type: 'number', label: 'Points de vie', required: true },
        armurePhysique: { type: 'number', label: 'Armure physique', required: true },
        esquive: { type: 'number', label: 'Esquive', required: true },
        coupCritique: { type: 'number', label: 'Coup critique', required: true },
        coupCritiqueSorts: { type: 'number', label: 'Critique sorts', required: true },
        resistanceAlterations: { type: 'number', label: 'Résistance altérations', required: true },
        armureFeu: { type: 'number', label: 'Armure Feu', required: true },
        armureEau: { type: 'number', label: 'Armure Eau', required: true },
        armureTerre: { type: 'number', label: 'Armure Terre', required: true },
        armureAir: { type: 'number', label: 'Armure Air', required: true },
        armureLumiere: { type: 'number', label: 'Armure Lumière', required: true },
        armureObscurite: { type: 'number', label: 'Armure Obscurité', required: true },
        armureDivin: { type: 'number', label: 'Armure Divin', required: true },
        armureMalefique: { type: 'number', label: 'Armure Maléfique', required: true },
        abilites: { type: 'richtext', label: 'Abilités', required: false },
        butin: { type: 'richtext', label: 'Butin', required: false }
      },
      editMapping: {
        'monster-name': 'nom',
        'monster-tags': 'tags',
        'monster-image': 'image',
        'monster-element': 'element',
        // Stats principaux
        'monster-pointsdevie': 'pointsDeVie',
        'monster-armurephysique': 'armurePhysique', 
        'monster-esquive': 'esquive',
        'monster-coupcritique': 'coupCritique',
        'monster-coupcritiquesorts': 'coupCritiqueSorts',
        'monster-resistancealterations': 'resistanceAlterations',
        // Armures élémentaires
        'monster-armurefeu': 'armureFeu',
        'monster-armureeau': 'armureEau',
        'monster-armureterre': 'armureTerre',
        'monster-armureair': 'armureAir',
        'monster-armurelumiere': 'armureLumiere',
        'monster-armureobscurite': 'armureObscurite',
        'monster-armuredivin': 'armureDivin',
        'monster-armuremalefique': 'armureMalefique',
        // Contenu narratif
        'monster-abilites': 'abilites',
        'monster-butin': 'butin'
      },
      identifiers: {
        name: 'nom',
        category: 'monstres'
      },
      template: 'monster-card',
      container: 'monstres',
      dataKey: 'MONSTRES',
      pageType: 'single',
      filterMode: 'AND',
      icons: { 
        category: '🐲', 
        item: '👾',
        add: '➕',
        delete: '🗑️'
      },
      filterConfig: {
        availableTags: ${JSON.stringify(monsterAvailableTags, null, 10)},
        defaultVisibleTags: ${JSON.stringify(monsterDefaultVisibleTags, null, 10)}
      },
      defaultValues: {
        nom: "Nouveau Monstre",
        tags: ["Forêt"],
        image: "",
        element: "Feu",
        pointsDeVie: 20,
        armurePhysique: 2,
        esquive: 5,
        coupCritique: 10,
        coupCritiqueSorts: 8,
        resistanceAlterations: 3,
        armureFeu: 0,
        armureEau: 0,
        armureTerre: 0,
        armureAir: 0,
        armureLumiere: 0,
        armureObscurite: 0,
        armureDivin: 0,
        armureMalefique: 0,
        abilites: "<strong>Attaque basique:</strong> Inflige 5 dégâts physiques.",
        butin: "<strong>Butin:</strong> 10-50 pièces d'or."
      }
    },

    staticPage: {
      fields: {
        title: { type: 'text', label: 'Titre', required: true },
        sections: { type: 'sections', label: 'Sections', required: true }
      },
      template: 'static-page',
      icons: { 
        category: '📄', 
        item: '📝'
      }
    }
  };

  window.StatIcons = {
    'Force': '💪',
    'Agilité': '🏃',
    'Endurance': '🛡️',
    'Intelligence': '🧠',
    'Volonté': '⚡',
    'Chance': '🍀'
  };

  window.ElementColors = {
    'Feu': { color: '#ff6b35', weight: 'bold' },
    'Eau': { color: '#4682b4', weight: 'bold' },
    'Terre': { color: '#8b4513', weight: 'bold' },
    'Air': { color: '#22c55e', weight: 'bold' },
    'Lumière': { color: '#ffd700', weight: 'bold' },
    'Nuit': { color: '#1a1a1a', weight: 'bold' },
    'Divin': { color: '#f5f5f5', weight: 'bold', background: 'rgba(100, 100, 100, 0.3)', padding: '2px 4px', borderRadius: '3px' },
    'Maléfique': { color: '#8b5cf6', weight: 'bold' }
  };

  window.ElementIcons = {
    'Feu': '🔥',
    'Eau': '💧',
    'Terre': '🤎',
    'Air': '🟢',
    'Lumière': '☀️',
    'Nuit': '⚫',
    'Divin': '⚪',
    'Maléfique': '🟣'
  };

})();`;
    },

    async loadJSZip() {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    },

    async fetchFileContent(filePath) {
      try {
        const response = await fetch(filePath);
        if (response.ok) {
          return await response.text();
        }
        // Could not fetch file
        return null;
      } catch (error) {
        // Error fetching file
        return null;
      }
    },

    async getMainHTML() {
      // Get the current index.html content or reconstruct it
      try {
        const response = await fetch('index.html');
        if (response.ok) {
          return await response.text();
        }
      } catch (error) {
        // Could not fetch index.html, generating from current state
      }
      
      // Fallback: generate HTML from current document state
      return `<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta name="referrer" content="no-referrer-when-downgrade">
<title>JDR‑BAB — Livret de règles</title>
<meta content="Livret web multipages des règles JDR‑BAB, thème parchemin, illustrations par catégorie/classe/sous‑classe, export HTML autonome." name="description">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&amp;family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600&amp;display=swap" rel="stylesheet">

<!-- CSS Modulaire -->
<link rel="stylesheet" href="css/theme.css">
<link rel="stylesheet" href="css/utilities.css">
<link rel="stylesheet" href="css/components.css">
<link rel="stylesheet" href="css/layout.css">
<link rel="stylesheet" href="css/editor.css">
</head>
<body class="dev-off" style="">

<!-- Le contenu HTML complet sera injecté ici par le JavaScript -->
<div id="app-loading">Chargement...</div>

<!-- JavaScript Modulaire -->
</body>
</html>`;
    },


    downloadJSON(filename, data) {
      const json = JSON.stringify(data, null, 2);
      this.downloadFile(filename, json, 'application/json');
    },

    downloadFile(filename, content, mimeType = 'text/html') {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.style.display = 'none';
      
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      URL.revokeObjectURL(url);
    },

    showNotification(message, type = 'info') {
      // Simple notification system
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${type === 'success' ? '#10B981' : type === 'error' ? '#EF4444' : '#3B82F6'};
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        font-weight: 500;
        z-index: 10000;
        animation: slideIn 0.3s ease;
      `;
      
      // Add animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      notification.textContent = message;
      document.body.appendChild(notification);
      
      // Auto-remove after 3 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    },

    // Load edits from localStorage on startup
    loadStoredEdits() {
      try {
        const storedEdits = localStorage.getItem('jdr-bab-edits');
        
        if (storedEdits && JdrApp.modules.editor) {
          JdrApp.modules.editor.editedData = JSON.parse(storedEdits);
        }
        
        // Load stored static pages data (includes dynamically created sections)
        const storedStaticPages = localStorage.getItem('jdr-bab-static-pages');
        if (storedStaticPages) {
          const staticPagesData = JSON.parse(storedStaticPages);
          
          // Merge with existing STATIC_PAGES data
          if (window.STATIC_PAGES) {
            Object.assign(window.STATIC_PAGES, staticPagesData);
          } else {
            window.STATIC_PAGES = staticPagesData;
          }
          
          console.log('Restored static pages data from localStorage:', Object.keys(staticPagesData));
        }
        
        // Ne plus charger jdr-bab-data - laisser les JSON être la source de vérité
        
      } catch (error) {
        console.warn('Failed to load stored edits:', error);
      }
    },

    // Handle ZIP file import
    async handleZipImport(event) {
      const file = event.target.files[0];
      if (!file || file.type !== 'application/zip') {
        this.showNotification('❌ Veuillez sélectionner un fichier ZIP', 'error');
        return;
      }

      try {
        this.showNotification('📥 Import en cours...', 'info');

        // Check if JSZip is available
        if (typeof JSZip === 'undefined') {
          await this.loadJSZip();
        }

        const zip = new JSZip();
        const contents = await zip.loadAsync(file);

        // Import data files
        const dataFiles = ['sorts.json', 'classes.json', 'dons.json', 'objets.json', 'monstres.json'];
        for (const dataFile of dataFiles) {
          const zipFile = contents.file(`data/${dataFile}`);
          if (zipFile) {
            const content = await zipFile.async('text');
            const data = JSON.parse(content);
            
            if (dataFile === 'sorts.json') {
              window.SORTS = data;
            } else if (dataFile === 'classes.json') {
              window.CLASSES = data;
            } else if (dataFile === 'dons.json') {
              window.DONS = data;
            } else if (dataFile === 'objets.json') {
              window.OBJETS = data;
            } else if (dataFile === 'monstres.json') {
              window.MONSTRES = data;
            }
          }
        }

        // Import static pages config
        const configFile = contents.file('data/static-pages-config.json');
        if (configFile) {
          const configContent = await configFile.async('text');
          window.STATIC_PAGES_CONFIG = JSON.parse(configContent);
        }

        // Import static pages data
        if (window.STATIC_PAGES_CONFIG && window.STATIC_PAGES_CONFIG.pages) {
          window.STATIC_PAGES = {};
          for (const pageConfig of window.STATIC_PAGES_CONFIG.pages) {
            if (pageConfig.active) {
              const pageFile = contents.file(`data/${pageConfig.file}`);
              if (pageFile) {
                const pageContent = await pageFile.async('text');
                window.STATIC_PAGES[pageConfig.id] = JSON.parse(pageContent);
              }
            }
          }
        }

        // Import images
        const imagesFile = contents.file('data/images.json');
        if (imagesFile && JdrApp.modules.images && JdrApp.modules.images.importImages) {
          const imagesContent = await imagesFile.async('text');
          const imagesData = JSON.parse(imagesContent);
          if (imagesData.images) {
            JdrApp.modules.images.importImages(imagesData.images);
          }
        }

        // Save imported data to localStorage
        this.saveChanges(true);

        this.showNotification('✅ Import réussi! Rechargement...', 'success');

        // Reload page to show imported data
        setTimeout(() => {
          window.location.reload();
        }, 1000);

      } catch (error) {
        this.showNotification('❌ Erreur lors de l\'import', 'error');
      }

      // Reset file input
      event.target.value = '';
    },


  };

})();
// ============================================================================
// JDR-BAB APPLICATION - ROUTER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // ROUTING SYSTEM
  // ========================================
  JdrApp.modules.router = {
    currentRoute: '',
    
    init() {
      
      // Set up route change listeners
      JdrApp.utils.events.onHashChange(() => this.parseRoute());
      JdrApp.utils.events.onDOMReady(() => this.parseRoute());
    },
    
    parseRoute() {
      const hash = location.hash.replace('#/', '');
      const page = hash || 'creation';
      const exists = JdrApp.utils.dom.$(`article[data-page="${page}"]`);
      
      this.currentRoute = page;
      
      // Handle dynamic category routing
      if (!exists) {
        if (this.handleDynamicRoute(page)) {
          return; // Route was handled dynamically
        }
      }
      
      this.show(exists ? page : 'creation');
    },

    handleDynamicRoute(page) {
      // Handle sorts-* routes
      if (page.startsWith('sorts-')) {
        return this.renderDynamicCategory('sorts', 'spell', page);
      }
      
      // Handle dons-* routes  
      if (page.startsWith('dons-')) {
        return this.renderDynamicCategory('dons', 'don', page);
      }
      
      // Handle single objets page (objects now use unified page with tag filtering)
      if (page === 'objets') {
        return this.renderObjectsPage();
      }
      
      // Handle single monstres page (monsters now use unified page with tag filtering)
      if (page === 'monstres') {
        return this.renderMonstersPage();
      }
      
      return false; // Route not handled
    },

    renderDynamicCategory(prefix, type, page) {
      const categoryId = page.replace(`${prefix}-`, '');
      const dataKey = prefix.toUpperCase();
      const dataSource = window[dataKey];
      
      if (!dataSource) return false;
      
      const category = dataSource.find(cat => 
        JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
      );
      
      if (category) {
        // Render the category page dynamically
        JdrApp.modules.renderer.renderCategoryPage(type, category);
        
        // Update active states
        this.updateActiveStates(page);
        
        return true;
      }
      
      return false;
    },

    updateActiveStates(page) {
      // Remove active class from all articles and links
      document.querySelectorAll('article').forEach(a => a.classList.remove('active'));
      document.querySelectorAll('.toc a').forEach(a => a.classList.remove('active'));
      
      // Set active link in TOC
      const activeLink = document.querySelector(`a[href="#/${page}"]`);
      if (activeLink) {
        activeLink.classList.add('active');
        
        // Expand parent category if needed
        const category = activeLink.closest('.toc-category');
        if (category) {
          category.classList.remove('collapsed');
        }
      }
    },
    
    show(page) {
      document.querySelectorAll('article').forEach(a => a.classList.remove('active'));
      const target = document.querySelector(`article[data-page="${page}"]`);
      if (target) target.classList.add('active');
      
      document.querySelectorAll('.toc a').forEach(a => a.classList.remove('active'));
      const activeLink = document.querySelector(`a[href="#/${page}"]`);
      if (activeLink) activeLink.classList.add('active');

      
      // Ensure edit buttons state is properly applied after navigation
      if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
        setTimeout(() => {
          if (JdrApp.modules.editor.isDevMode) {
            JdrApp.modules.editor.forceShowAllEditButtons();
          } else {
            JdrApp.modules.editor.forceHideAllEditButtons();
          }
        }, 50);
      }
    },
    
    navigate(route) {
      location.hash = `#/${route}`;
      // Force parseRoute() in case hashchange event doesn't fire
      setTimeout(() => {
        this.parseRoute();
      }, 10);
    },
    
    getCurrentRoute() {
      return this.currentRoute;
    },
    
    // Generate table of contents based on hierarchical structure
    generateTOC() {
      const tocContainer = document.querySelector('#toc');
      if (!tocContainer) return;

      if (!window.TOC_STRUCTURE) {
        console.warn('TOC_STRUCTURE not loaded, falling back to basic TOC');
        this.generateBasicTOC();
        return;
      }

      const tocHTML = `
        <h4>Sommaire</h4>
        ${window.TOC_STRUCTURE.sections
          .filter(section => !section.requiresMJ || window.JdrApp.state.isMJ)
          .map(section => this.generateTOCSection(section)).join('')}
        <div class="mj-toggle-container" style="margin: 1rem 0; text-align: center; border-top: 2px solid var(--rule); padding-top: 1rem;">
          <button id="mjToggleBtn" class="btn-base btn-small" style="background: var(--bronze); color: white; border-color: var(--bronze); position: relative;">
            🎭 Maître de jeu
            <span id="mjStatusIndicator" style="position: absolute; top: -5px; right: -5px; width: 12px; height: 12px; border-radius: 50%; background: #dc2626; border: 2px solid white; display: none;"></span>
          </button>
        </div>
      `;
      
      tocContainer.innerHTML = tocHTML;
      
      // Attacher les événements directement aux éléments après création
      this.attachFoldoutEvents();
      
      // Initialiser les hauteurs dynamiques pour toutes les sections ouvertes
      this.initializeDynamicHeights();
      
      // Ajouter l'event listener pour le bouton MJ
      this.setupMJToggle();
    },

    initializeDynamicHeights() {
      // Calculer et appliquer les hauteurs dynamiques pour toutes les sections non-collapsées
      document.querySelectorAll('.toc-section:not(.collapsed) .toc-section-content').forEach(content => {
        const childCount = content.querySelectorAll('a, .toc-category').length;
        const itemHeight = 50; // Hauteur approximative par élément
        const baseHeight = 100; // Hauteur de base pour le padding
        const dynamicHeight = Math.max(500, (childCount * itemHeight) + baseHeight);
        
        content.style.maxHeight = `${dynamicHeight}px`;
      });
    },

    setupMJToggle() {
      const mjBtn = document.getElementById('mjToggleBtn');
      if (!mjBtn) return;

      // Initialize visual state based on current MJ status
      this.updateMJButtonVisual();

      const handleMJToggle = () => {
        if (window.JdrApp.state.isMJ) {
          // Déjà en mode MJ, désactiver
          window.JdrApp.state.isMJ = false;
          this.updateMJButtonVisual();
          this.generateTOC(); // Régénérer le TOC pour cacher les sections MJ
          
          // Refresh objects display if currently on objects page
          this.refreshObjectsPageIfActive();
        } else {
          // Demander confirmation avant d'activer le mode MJ
          this.showMJConfirmation(() => {
            window.JdrApp.state.isMJ = true;
            this.updateMJButtonVisual();
            this.generateTOC(); // Régénérer le TOC pour afficher les sections MJ
            
            // Refresh objects display if currently on objects page
            this.refreshObjectsPageIfActive();
          });
        }
      };

      // Ajouter support tactile pour mobile
      mjBtn.addEventListener('click', handleMJToggle);
      mjBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleMJToggle();
      });
    },

    attachFoldoutEvents() {
      // Attacher les événements directement aux headers de section
      document.querySelectorAll('.toc-section-header').forEach(header => {
        header.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const section = header.closest('.toc-section');
          if (section) {
            const wasCollapsed = section.classList.contains('collapsed');
            section.classList.toggle('collapsed');
            const isCollapsed = section.classList.contains('collapsed');
            
            const toggle = section.querySelector('.toc-section-toggle');
            if (toggle) {
              toggle.textContent = isCollapsed ? '▶' : '▼';
            }
            
            const content = section.querySelector('.toc-section-content');
            if (content) {
              // Force les styles directement en JavaScript pour compatibilité standalone
              if (isCollapsed) {
                content.style.maxHeight = '0px';
                content.style.opacity = '0';
                content.style.paddingTop = '0';
                content.style.paddingBottom = '0';
                content.style.overflow = 'hidden';
              } else {
                // Calculer dynamiquement la hauteur nécessaire en fonction du contenu
                const childCount = content.querySelectorAll('a, .toc-category').length;
                const itemHeight = 50; // Hauteur approximative par élément (incluant padding et marge)
                const baseHeight = 100; // Hauteur de base pour le padding
                const dynamicHeight = Math.max(500, (childCount * itemHeight) + baseHeight);
                
                content.style.maxHeight = `${dynamicHeight}px`;
                content.style.opacity = '1';
                content.style.paddingTop = '';
                content.style.paddingBottom = '';
                content.style.overflow = 'visible';
              }
            }
          }
        });
      });

      // Attacher les événements aux liens de catégorie
      document.querySelectorAll('.toc-category > a').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const category = link.closest('.toc-category');
          if (category) {
            category.classList.toggle('collapsed');
          }
        });
      });

      // Attacher les événements aux liens de navigation normaux
      document.querySelectorAll('.toc a:not(.toc-category > a)').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const route = link.getAttribute('data-route');
          if (route) {
            // Special handling for objects page - force refresh when navigating to it
            if (route === 'objets') {
              // Set a flag to force refresh objects page after navigation
              JdrApp.modules.router._forceObjectsRefresh = true;
            }
            JdrApp.modules.router.navigate(route);
          }
        });
      });
    },

    updateMJButtonVisual() {
      const mjBtn = document.getElementById('mjToggleBtn');
      const mjIndicator = document.getElementById('mjStatusIndicator');
      
      if (!mjBtn) return;
      
      if (window.JdrApp.state.isMJ) {
        // Mode MJ activé - bouton doré avec indicateur vert
        mjBtn.style.background = 'var(--gold)';
        mjBtn.style.borderColor = 'var(--gold)';
        mjBtn.innerHTML = '🎭 Mode MJ activé <span id="mjStatusIndicator" style="position: absolute; top: -5px; right: -5px; width: 12px; height: 12px; border-radius: 50%; background: #16a34a; border: 2px solid white; display: inline-block;"></span>';
      } else {
        // Mode normal - bouton bronze sans indicateur
        mjBtn.style.background = 'var(--bronze)';
        mjBtn.style.borderColor = 'var(--bronze)';
        mjBtn.innerHTML = '🎭 Maître de jeu <span id="mjStatusIndicator" style="position: absolute; top: -5px; right: -5px; width: 12px; height: 12px; border-radius: 50%; background: #dc2626; border: 2px solid white; display: none;"></span>';
      }
    },

    showMJConfirmation(onConfirm) {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0,0,0,0.7);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
      `;
      
      modal.innerHTML = `
        <div style="
          background: var(--card);
          border: 3px solid var(--bronze);
          border-radius: 16px;
          padding: 2rem;
          max-width: 500px;
          margin: 1rem;
          text-align: center;
          box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        ">
          <h3 style="color: var(--bronze); margin-top: 0;">⚠️ Mode Maître de jeu</h3>
          <p style="margin: 1.5rem 0; line-height: 1.6;">
            Êtes-vous sûr de vouloir activer le mode Maître de jeu?<br><br>
            <strong style="color: var(--bronze);">Si vous êtes juste un joueur, vous risquez d'être spoilé!</strong>
          </p>
          <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 2rem;">
            <button id="mjConfirmYes" class="btn-base" style="background: var(--bronze); color: white; border-color: var(--bronze);">
              Oui, je suis MJ
            </button>
            <button id="mjConfirmNo" class="btn-base" style="background: var(--rule); color: var(--accent-ink); border-color: var(--rule);">
              Non, annuler
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      modal.querySelector('#mjConfirmYes').addEventListener('click', () => {
        document.body.removeChild(modal);
        onConfirm();
      });
      
      modal.querySelector('#mjConfirmNo').addEventListener('click', () => {
        document.body.removeChild(modal);
      });
      
      // Fermer en cliquant sur le fond
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
        }
      });
    },

    generateTOCSection(section) {
      const sectionClass = section.collapsed ? 'toc-section collapsed' : 'toc-section';
      const toggleIcon = section.collapsed ? '▶' : '▼';
      
      return `
        <div class="${sectionClass}" data-section="${section.id}">
          <div class="toc-section-header">
            <span class="toc-section-title">${section.title}</span>
            <span class="toc-section-toggle">${toggleIcon}</span>
          </div>
          <div class="toc-section-content">
            ${section.items.map(item => this.generateTOCItem(item)).join('')}
          </div>
        </div>
      `;
    },

    generateTOCItem(item) {
      if (item.type === 'page') {
        return `<a data-route="${item.id}" href="#/${item.id}" class="">${item.icon} ${item.title}</a>`;
      } else if (item.type === 'category') {
        return this.generateTOCCategory(item);
      }
      return '';
    },

    generateTOCCategory(item) {
      const dataSource = window[item.items]; // CLASSES, SORTS, DONS
      if (!dataSource) return '';

      if (item.id === 'classes') {
        return `
          <div class="toc-category">
            <a data-route="classes" href="#/classes" class="">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource.map(classe => 
                `<a data-route="${JdrApp.utils.data.sanitizeId(classe.nom)}" href="#/${JdrApp.utils.data.sanitizeId(classe.nom)}" class="">${this.getClassIcon(classe.nom)} ${classe.nom}</a>`
              ).join('')}
            </div>
          </div>
        `;
      } else if (item.id === 'sorts') {
        return `
          <div class="toc-category">
            <a data-route="sorts" href="#/sorts">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource.map(category => 
                `<a data-route="sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getSortCategoryIcon(category.nom)} ${category.nom}</a>`
              ).join('')}
            </div>
          </div>
        `;
      } else if (item.id === 'dons') {
        return `
          <div class="toc-category">
            <a data-route="dons" href="#/dons" class="">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource.map(category => 
                `<a data-route="dons-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/dons-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getDonCategoryIcon(category.nom)} ${category.nom}</a>`
              ).join('')}
            </div>
          </div>
        `;
      }

      return '';
    },

    generateBasicTOC() {
      const tocContainer = document.querySelector('#toc');
      if (!tocContainer) return;

      const tocHTML = `
        <h4>Sommaire</h4>
        <a class="" data-route="creation" href="#/creation">🧙‍♂️ Création d'un personnage</a>
        
        <div class="toc-category">
          <a data-route="classes" href="#/classes" class="">⚔️ Classes</a>
          <div class="toc-sub">
            ${window.CLASSES ? window.CLASSES.map(classe => 
              `<a data-route="${JdrApp.utils.data.sanitizeId(classe.nom)}" href="#/${JdrApp.utils.data.sanitizeId(classe.nom)}" class="">${this.getClassIcon(classe.nom)} ${classe.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <div class="toc-category">
          <a data-route="sorts" href="#/sorts">🔮 Sorts</a>
          <div class="toc-sub">
            ${window.SORTS ? window.SORTS.map(category => 
              `<a data-route="sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getSortCategoryIcon(category.nom)} ${category.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <div class="toc-category">
          <a data-route="dons" href="#/dons" class="">🎖️ Dons</a>
          <div class="toc-sub">
            ${window.DONS ? window.DONS.map(category => 
              `<a data-route="dons-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/dons-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getDonCategoryIcon(category.nom)} ${category.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <a data-route="objets" href="#/objets" class="">📦 Objets</a>
        
        <a data-route="elements" href="#/elements" class="">🌟 Éléments</a>
        <a data-route="stats" href="#/stats" class="">📊 Statistiques</a>
        <a data-route="competences-tests" href="#/competences-tests" class="">🎯 Compétences & Tests</a>
        <a data-route="etats" href="#/etats" class="">⚡ Etats</a>
      `;
      
      tocContainer.innerHTML = tocHTML;
    },
    
    renderObjectsPage() {
      if (!window.OBJETS) return false;
      
      // Ensure the page is shown as active first
      this.show('objets');
      
      // Force complete regeneration if coming from navigation or MJ mode change
      const shouldForceRefresh = this._forceObjectsRefresh || false;
      this._forceObjectsRefresh = false; // Reset the flag
      
      // Force complete regeneration of the objects page content
      // This ensures that objects filtered out by MJ restrictions are now properly generated in the DOM
      setTimeout(() => {
        if (JdrApp.modules.renderer && JdrApp.modules.renderer.regenerateCurrentPage) {
          JdrApp.modules.renderer.regenerateCurrentPage();
        }
      }, shouldForceRefresh ? 100 : 50); // Slightly longer delay when forced refresh
      
      return true;
    },


    // Helper method to refresh objects page if currently active
    refreshObjectsPageIfActive() {
      const currentHash = window.location.hash;
      if (currentHash === '#/objets' || currentHash === '#objets') {
        setTimeout(() => {
          // Force full page regeneration to ensure objects filtered by MJ mode are now visible
          // This calls renderObjectsPage() which will regenerate the entire page with current filters
          this.renderObjectsPage();
        }, 150); // Slightly longer delay to ensure MJ state is updated
      }
    },
    
    getClassIcon(className) {
      const icons = {
        'Guerrier': '🗡️',
        'Mage': '🔮',
        'Prêtre': '⛪',
        'Rôdeur': '🏃',
        'Enchanteur': '✨'
      };
      return icons[className] || '⚔️';
    },
    
    getSortCategoryIcon(categoryName) {
      const icons = {
        'Sorts de Mage': '🔮',
        'Sorts de Prêtre': '⛪',
        'Sorts d\'Enchanteur': '✨',
        'Sorts de Monstres': '💀'
      };
      return icons[categoryName] || '🔮';
    },
    
    getDonCategoryIcon(categoryName) {
      const icons = {
        'Guerrier': '🗡️',
        'Mage': '🔮',
        'Pretre': '⛪',  // Sans accent comme dans les données
        'Prêtre': '⛪',  // Avec accent au cas où
        'Rôdeur': '🏃',
        'Enchanteur': '✨',
        'Généraux': '🎖️',
        'Generaux': '🎖️'  // Sans accent comme dans les données
      };
      return icons[categoryName] || '🎖️';
    },

    getMonstreCategoryIcon(categoryName) {
      const icons = {
        'Forêt': '🌲',
        'Foret': '🌲',  // Sans accent
        'Donjon': '🏰',
        'Dragons': '🐉',
        'Mort-vivants': '💀',
        'Démons': '👹',
        'Demons': '👹',  // Sans accent
        'Animaux': '🦁',
        'Humanoïdes': '🧌',
        'Humanoïdes': '🧌'  // Sans accent
      };
      return icons[categoryName] || '👹';
    },
    
    getObjetCategoryIcon(categoryName) {
      const icons = {
        'Armes': '⚔️',
        'Armures': '🛡️',
        'Potions': '🧪',
        'Herbes Magiques': '🌿',
        'Objets Magiques': '✨',
        'Accessoires': '💍',
        'Consommables': '🍞',
        'Composants': '🔮',
        'Outils': '🔨'
      };
      return icons[categoryName] || '📦';
    },

    renderObjectsPage() {
      // Use PageBuilder to generate the objets page dynamically
      JdrApp.modules.renderer.renderUnifiedContentPage('objet', window.OBJETS || []);
      this.updateActiveStates('objets');
      this.show('objets'); // Activer la page
      return true;
    },

    renderMonstersPage() {
      // Use PageBuilder to generate the monstres page dynamically
      JdrApp.modules.renderer.renderUnifiedContentPage('monster', window.MONSTRES || []);
      this.updateActiveStates('monstres');
      this.show('monstres'); // Activer la page
      return true;
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - RENDERER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // CONTENT RENDERER MODULE
  // ========================================
  JdrApp.modules.renderer = {
    currentSearch: '',
    
    init() {
      // Delay content generation to ensure all configurations are loaded
      setTimeout(() => {
        this.generateContent();
        this.autoLoadImages();
      }, 10);
      this.setupEventListeners();
    },

    setupEventListeners() {
      EventBus.on(Events.PAGE_RENDER, (payload) => {
        if (payload.type === 'category') {
          this.renderCategoryPage(payload.categoryType, payload.category);
        }
      });

      EventBus.on(Events.CONTENT_ADD, () => {
        setTimeout(() => this.autoLoadImages(), 100);
      });
    },

    generateContent() {
      JdrApp.modules.router.generateTOC.call(JdrApp.modules.router);
      this.generateArticles();
      this.generateDevToolbox();
      
      if (JdrApp.modules.editor) {
        setTimeout(() => {
          if (JdrApp.modules.editor.isDevMode) {
            JdrApp.modules.editor.forceShowAllEditButtons();
          } else {
            JdrApp.modules.editor.forceHideAllEditButtons();
          }
        }, 100);
      }
    },

    generateArticles() {
      const viewsContainer = document.querySelector('#views');
      if (!viewsContainer) return;

      let articlesHTML = '';
      articlesHTML += this.generateStaticPages();
      articlesHTML += this.generateClassPages();
      articlesHTML += this.generateCategoryPages();

      viewsContainer.innerHTML = articlesHTML;
      setTimeout(() => {
        this.autoLoadImages();
        // Reapply dev mode state to new elements
        this.applyDevModeToNewContent();
        // Attach image events for standalone compatibility
        if (JdrApp.modules.editor && JdrApp.modules.editor.attachImageEvents) {
          JdrApp.modules.editor.attachImageEvents();
        }
        // Create proxy buttons for new content
        if (JdrApp.modules.editor && JdrApp.modules.editor.isDevMode) {
          setTimeout(() => JdrApp.modules.editor.createProxyButtons(), 100);
        }
        // Auto-populate monsters page if it exists
        if (document.getElementById('monsters-container')) {
          setTimeout(() => this.populateMonstersPage(), 50);
        }
      }, 100);
    },

    applyDevModeToNewContent() {
      if (JdrApp.modules.editor) {
        if (JdrApp.utils.isDevMode()) {
          JdrApp.modules.editor.forceShowAllEditButtons();
        } else {
          JdrApp.modules.editor.forceHideAllEditButtons();
        }
      }
    },


    generateStaticPages() {
      let html = '';
      if (window.STATIC_PAGES) {
        Object.entries(window.STATIC_PAGES).forEach(([pageId, pageData]) => {
          html += PageBuilder.buildStaticPage(pageId, pageData);
        });
      }
      return html;
    },


    generateClassPages() {
      if (!window.CLASSES) return '';
      
      return window.CLASSES.map(classe => 
        PageBuilder.buildClassPage(classe)
      ).join('');
    },

    generateCategoryPages() {
      let html = '';
      
      if (window.SORTS) {
        html += window.SORTS.map(category => 
          PageBuilder.buildCategoryPage('spell', category)
        ).join('');
      }

      if (window.DONS) {
        html += window.DONS.map(category => 
          PageBuilder.buildCategoryPage('don', category)
        ).join('');
      }

      // Generate single objects page (different from category pages)
      if (window.OBJETS) {
        html += PageBuilder.buildSingleObjectPage(window.OBJETS);
      }

      return html;
    },

    renderCategoryPage(type, category) {
      const config = window.ContentTypes[type];
      
      // Handle special case for objects (single page, no category name)
      let pageId;
      if (type === 'objet') {
        pageId = 'objets'; // Objects use fixed page ID
      } else {
        pageId = `${config.container}-${JdrApp.utils.data.sanitizeId(category.nom)}`;
      }
      
      let article = document.querySelector(`article[data-page="${pageId}"]`);
      
      // Create article if it doesn't exist (for dynamically created categories)
      if (!article) {
        article = document.createElement('article');
        article.setAttribute('data-page', pageId);
        article.className = 'active'; // Make it active since we're showing it
        
        const viewsContainer = document.querySelector('#views');
        if (viewsContainer) {
          viewsContainer.appendChild(article);
        } else {
          console.warn('Views container not found');
          return;
        }
      }
      
      const newContent = PageBuilder.buildCategoryPage(type, category);
      const parser = new DOMParser();
      const newDoc = parser.parseFromString(newContent, 'text/html');
      const newArticle = newDoc.querySelector('article');
      
      if (newArticle) {
        article.innerHTML = newArticle.innerHTML;
        
        // Make sure only this article is active
        document.querySelectorAll('article').forEach(a => a.classList.remove('active'));
        article.classList.add('active');
        
        // Plus simple et plus fiable
        this.autoLoadImages();
        
        // Attach image events for standalone compatibility
        if (JdrApp.modules.editor && JdrApp.modules.editor.attachImageEvents) {
          JdrApp.modules.editor.attachImageEvents();
        }
        
        // Ensure dev mode state is applied after content change
        setTimeout(() => {
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          }
        }, 50);
      }
    },

    renderSortCategory(page) {
      const categoryId = page.replace('sorts-', '');
      const category = window.SORTS?.find(cat => 
        JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
      );
      
      if (category) {
        this.renderCategoryPage('spell', category);
      }
    },

    generateDevToolbox() {
      const devToolbox = JdrApp.utils.dom.$('#devToolbox');
      if (!devToolbox) return;

      const toolboxHTML = `
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--rule);">
          <span style="font-size: 18px;">🛠</span>
          <strong style="color: var(--accent-ink); font-family: 'Cinzel', serif;">Outils de développement</strong>
        </div>
        
        <div style="margin-bottom: 12px;">
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">✏️ Édition</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="saveAndExport" title="Sauvegarder et exporter tout en ZIP">💾 Export ZIP</button>
          </div>
        </div>
        
        <div style="margin-bottom: 12px;">
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">📝 Création</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="addCategory" title="Créer une nouvelle catégorie/page">📄 Nouvelle page</button>
            <button class="btn small" id="addSpellCategory" title="Créer une nouvelle catégorie de sorts">🔮 Catégorie de sorts</button>
            <button class="btn small" id="addDonCategory" title="Créer une nouvelle catégorie de dons">🎖️ Catégorie de dons</button>
          </div>
        </div>
        
        <div>
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">🎭 Ressources</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="elementsBtn" title="Choisir un élément pour copier sa balise HTML colorée">🎨 Éléments</button>
            <button class="btn small" id="etatsBtn" title="Choisir un état pour copier sa balise HTML avec tooltip">⚡ États</button>
            <button class="btn small" id="spellLinksBtn" title="Créer un lien vers un sort avec aperçu">🔮 Liens sorts</button>
          </div>
        </div>
      `;

      devToolbox.innerHTML = toolboxHTML;
    },

    autoLoadImages() {
      if (JdrApp.modules.images) {
        return JdrApp.modules.images.autoLoadImages();
      }
      return 0;
    },

    regenerateCurrentPage() {
      // Find the currently active article
      const activeArticle = document.querySelector('article.active');
      if (!activeArticle) return;

      const pageId = activeArticle.dataset.page;
      if (!pageId) return;

      // Determine what type of page it is and regenerate only that page
      if (pageId.startsWith('sorts-')) {
        const categoryId = pageId.replace('sorts-', '');
        const category = window.SORTS?.find(cat => 
          JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
        );
        if (category) {
          this.renderCategoryPage('spell', category);
        }
      } else if (pageId.startsWith('dons-')) {
        const categoryId = pageId.replace('dons-', '');
        const category = window.DONS?.find(cat => 
          JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
        );
        if (category) {
          this.renderCategoryPage('don', category);
        }
      } else if (pageId === 'objets') {
        // Regenerate objects page using the generic approach
        const newHTML = this.generatePageContent(pageId);
        if (newHTML) {
          activeArticle.innerHTML = newHTML;
          this.autoLoadImages();
          
          // Apply dev mode state immediately
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          }
        }
      } else {
        // For class pages, static pages, etc. - regenerate the specific content
        const newHTML = this.generatePageContent(pageId);
        if (newHTML) {
          activeArticle.innerHTML = newHTML;
          this.autoLoadImages();
          
          // Apply dev mode state immediately
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          }
        }
      }
    },

    generatePageContent(pageId) {
      // Generate content for a specific page without affecting navigation
      if (window.CLASSES) {
        const classe = window.CLASSES.find(c => JdrApp.utils.data.sanitizeId(c.nom) === pageId);
        if (classe) {
          const content = PageBuilder.buildClassPage(classe);
          const parser = new DOMParser();
          const doc = parser.parseFromString(content, 'text/html');
          const article = doc.querySelector('article');
          return article ? article.innerHTML : null;
        }
      }

      if (window.STATIC_PAGES && window.STATIC_PAGES[pageId]) {
        const content = PageBuilder.buildStaticPage(pageId, window.STATIC_PAGES[pageId]);
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        const article = doc.querySelector('article');
        return article ? article.innerHTML : null;
      }

      // Handle objects page
      if (pageId === 'objets' && window.OBJETS) {
        const content = PageBuilder.buildSingleObjectPage(window.OBJETS);
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        const article = doc.querySelector('article');
        return article ? article.innerHTML : null;
      }

      return null;
    },

    renderUnifiedContentPage(contentType, data) {
      // This method dynamically creates a unified content page (like objets or monstres)
      // using the PageBuilder with the appropriate build method
      let content = '';
      let pageId = '';
      
      if (contentType === 'objet' && data) {
        content = PageBuilder.buildSingleObjectPage(data);
        pageId = 'objets';
      } else if (contentType === 'monster' && data) {
        content = PageBuilder.buildSingleMonsterPage(data);
        pageId = 'monstres';
      }
      
      if (content && pageId) {
        // Find or create the specific article element in #views
        const viewsContainer = document.querySelector('#views');
        if (viewsContainer) {
          // Remove existing article for this page if it exists
          const existingArticle = document.querySelector(`article[data-page="${pageId}"]`);
          if (existingArticle) {
            existingArticle.remove();
          }
          
          // Add the new content to the views container
          viewsContainer.insertAdjacentHTML('beforeend', content);
          
          this.autoLoadImages();
          
          // Apply dev mode state
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          }
        }
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - UNIFIED EDITOR SYSTEM
// ============================================================================

(() => {
  "use strict";

  class UnifiedEditor {
    constructor() {
      this.currentEditSession = null;
    }

    /*
     * IMPORTANT: Content Restoration Best Practices
     * =============================================
     * ALWAYS use restoreElementContent() for any content that has been edited
     * NEVER directly assign to innerHTML in editing contexts
     * This prevents HTML tags from being displayed as visible text
     */

    static getInstance() {
      if (!UnifiedEditor.instance) {
        UnifiedEditor.instance = new UnifiedEditor();
      }
      return UnifiedEditor.instance;
    }

    // Parse edit context from DOM element
    parseEditContext(element) {
      // Force reset any stuck elements FIRST
      this.forceResetAllEditingElements();
      
      const editableElement = element.classList.contains('editable-section') 
        ? element.querySelector('.editable') 
        : element;

      if (!editableElement) {
        return null;
      }

      const editType = editableElement.dataset.editType;
      const editSection = editableElement.dataset.editSection;
      
      // For simplified HTML editing, everything is treated as HTML content
      if (editType === 'html') {
        return this.parseHtmlEditContext(element, editSection);
      }
      
      // Generic editing - use contextual detection, don't force type
      if (editType === 'generic') {
        // Use the full parsing logic and keep the detected contentType
        return this.parseHtmlEditContext(element, editSection);
      }

      // Tags editing for objects
      if (editType === 'tags') {
        return this.parseTagsEditContext(element, editSection);
      }

      // Select element editing (for dropdowns like monster elements)
      if (editType === 'select') {
        return this.parseSelectEditContext(element, editSection);
      }

      // All legacy edit types have been migrated to 'generic'
      console.warn('Unexpected edit type in parseEditContext:', editType);
      return null;
    }

    parseHtmlEditContext(element, editSection) {
      // Detect context automatically based on page structure
      // Order matters: check most specific first (spells, dons, classes, then static pages)
      
      // Check if we're in a spell card first (most specific)
      const spellCard = element.closest('.card[data-spell-name]');
      if (spellCard) {
        const spellName = spellCard.dataset.spellName;
        const spellIndex = spellCard.dataset.spellIndex;
        const categoryName = spellCard.dataset.categoryName;
        
        // Use class-based detection for spell sections to avoid index mismatches
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        // Detect the spell property from the element's classes or data attributes
        let spellEditSection = 'description'; // default fallback
        
        // Check for specific section classes to determine the property
        if (editableElement.classList.contains('spell-name') || editableElement.dataset.editSection === 'spell-name') {
          spellEditSection = 'nom';
        } else if (editableElement.classList.contains('spell-description') || editableElement.dataset.editSection === 'spell-description') {
          spellEditSection = 'description';
        } else if (editableElement.classList.contains('spell-prerequis') || editableElement.dataset.editSection === 'spell-prerequis') {
          spellEditSection = 'prerequis';
        } else if (editableElement.classList.contains('spell-portee') || editableElement.dataset.editSection === 'spell-portee') {
          spellEditSection = 'portee';
        } else if (editableElement.classList.contains('spell-mana') || editableElement.dataset.editSection === 'spell-mana') {
          spellEditSection = 'coutMana';
        } else if (editableElement.classList.contains('spell-temps-incantation') || editableElement.dataset.editSection === 'spell-temps-incantation') {
          spellEditSection = 'tempsIncantation';
        } else if (editableElement.classList.contains('spell-resistance') || editableElement.dataset.editSection === 'spell-resistance') {
          spellEditSection = 'resistance';
        } else if (editableElement.classList.contains('spell-effect-normal') || editableElement.dataset.editSection === 'spell-effect-normal') {
          spellEditSection = 'effetNormal';
        } else if (editableElement.classList.contains('spell-effect-critical') || editableElement.dataset.editSection === 'spell-effect-critical') {
          spellEditSection = 'effetCritique';
        }
        
        return {
          contentType: 'spell',
          itemIdentifier: spellName,
          itemIndex: spellIndex,
          categoryName: categoryName,
          property: 'html',
          editType: 'html',
          editSection: spellEditSection,
          config: window.ContentTypes.spell,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a don card
      const donCard = element.closest('.card[data-don-name]');
      if (donCard) {
        const donName = donCard.dataset.donName;
        const donIndex = donCard.dataset.donIndex;
        const categoryName = donCard.dataset.categoryName;
        
        // Use index-based detection for don sections
        const allEditables = Array.from(donCard.querySelectorAll('.editable'));
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const currentIndex = allEditables.indexOf(editableElement);
        
        // Map index to don property based on CardBuilder order
        // 0=nom, 1=description, 2=prerequis, 3=cout
        const donSections = ['nom', 'description', 'prerequis', 'cout'];
        const donEditSection = donSections[currentIndex] || 'description';
        
        return {
          contentType: 'don',
          itemIdentifier: donName,
          itemIndex: donIndex,
          categoryName: categoryName,
          property: 'html',
          editType: 'html',
          editSection: donEditSection,
          config: window.ContentTypes.don,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in an objet card
      const objetCard = element.closest('.card[data-objet-name]');
      if (objetCard) {
        const objetName = objetCard.dataset.objetName;
        const categoryName = objetCard.dataset.categoryName;
        
        // Use index-based detection for objet sections
        const allEditables = Array.from(objetCard.querySelectorAll('.editable'));
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const currentIndex = allEditables.indexOf(editableElement);
        
        // Map index to objet property based on CardBuilder order
        // 0=nom, 1=numero, 2=tags, 3=description, 4=effet, 5=prix, 6=poids
        const objetSections = ['nom', 'numero', 'tags', 'description', 'effet', 'prix', 'poids'];
        const objetEditSection = objetSections[currentIndex] || 'description';
        
        return {
          contentType: 'objet',
          itemIdentifier: objetName,
          categoryName: categoryName,
          property: 'html',
          editType: 'html',
          editSection: objetEditSection,
          config: window.ContentTypes.objet,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        // Use data-item-identifier if available, otherwise fall back to monsterName
        const itemIdentifier = editableElement?.dataset?.itemIdentifier || monsterName;
        
        // Use editSection directly (new format: "monster-fieldName")
        const editSection = editableElement?.dataset?.editSection || 'abilites';
        
        return {
          contentType: 'monster',
          itemIdentifier: itemIdentifier,
          categoryName: categoryName || 'monstres',
          property: 'html',
          editType: 'html', 
          editSection: editSection,
          config: window.ContentTypes.monster,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a class page (before static pages!)
      // IMPORTANT: Exclude static pages even if they have data-page-title
      const classArticle = element.closest('article[data-page-title]:not([data-static-page="true"])');
      if (classArticle) {
        const className = classArticle.dataset.pageTitle;
        
        // Check if we're editing a subclass (look for subclass card)
        const subclassCard = element.closest('.card[data-subclass-name]');
        if (subclassCard) {
          // Determine what part of the subclass we're editing
          let subclassEditSection = 'content';
          
          const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
          
          if (editableElement) {
            const parentSection = editableElement.closest('.editable-section');
            
            // Use index-based detection for subclasses
            const subclassCard = editableElement.closest('.card[data-subclass-name]');
            const allEditables = subclassCard ? Array.from(subclassCard.querySelectorAll('.editable')) : [];
            const currentIndex = allEditables.indexOf(editableElement);
            
            // Map index to property based on subclass structure  
            // UPDATED ORDER: Index 0 = nom (title), Index 1 = description, Index 2 = base (stats), Index 3 = progression, Index 4+ = capacites
            if (element.closest('.stats-grid') || currentIndex === 2) {
              subclassEditSection = 'base';
            } else if (currentIndex === 0) {
              subclassEditSection = 'nom';
            } else if (currentIndex === 1) {
              subclassEditSection = 'description';
            } else if (currentIndex === 3) {
              subclassEditSection = 'progression';  
            } else if (currentIndex >= 4) {
              subclassEditSection = 'capacites';
            }
          }
          
          return {
            contentType: 'subclass',
            itemIdentifier: subclassCard.dataset.subclassName,
            categoryName: className,
            property: 'html',
            editType: 'html',
            editSection: subclassEditSection,
            config: window.ContentTypes.subclass,
            element: element.classList.contains('editable-section') ? element.querySelector('.editable') : element,
            container: element
          };
        }
        
        // Otherwise it's a class - determine what part of the class we're editing
        let classEditSection = 'content';
        
        // More specific detection based on parent elements and content
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        if (editableElement) {
          const parentCard = editableElement.closest('.card');
          const parentSection = editableElement.closest('.editable-section');
          
          // Use index-based detection instead of content analysis
          const classArticle = editableElement.closest('article[data-page-title]');
          const allEditables = classArticle ? Array.from(classArticle.querySelectorAll('.editable')) : [];
          const currentIndex = allEditables.indexOf(editableElement);
          
          // Map index to property based on class structure
          // Index 0 = resume (first editable in class)
          // Index 1+ = capacites (subsequent editables are class capabilities)
          if (currentIndex === 0) {
            classEditSection = 'resume';
          } else if (currentIndex >= 1) {
            classEditSection = 'capacites';
          }
        }
        
        return {
          contentType: 'class',
          itemIdentifier: className,
          categoryName: null,
          property: 'html',
          editType: 'html',
          editSection: classEditSection,
          config: window.ContentTypes.class,
          element: element.classList.contains('editable-section') ? element.querySelector('.editable') : element,
          container: element
        };
      }
      
      // Check if we're editing a category description (spell/don category pages)
      const editableSection = element.closest('.editable-section[data-section-type*="-category-description"]');
      if (editableSection) {
        const sectionType = editableSection.dataset.sectionType;
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const editSection = editableElement ? editableElement.dataset.editSection : '';
        
        // Determine the category type (spell/don/etc) and category name
        let contentType = 'spell'; // default
        if (sectionType.includes('spell')) {
          contentType = 'spell';
        } else if (sectionType.includes('don')) {
          contentType = 'don';
        }
        
        return {
          contentType: 'category',
          itemIdentifier: editSection, // This is the category name
          categoryName: editSection,
          property: 'description',
          editType: 'html',
          editSection: 'description',
          categoryType: contentType,
          config: window.ContentTypes[contentType],
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a static page (LAST, as fallback)
      // Now we include ALL static pages, regardless of data-page-title
      const staticPageArticle = element.closest('article[data-static-page="true"]');
      if (staticPageArticle) {
        const pageName = staticPageArticle.dataset.page;
        
        // Enhanced page detection with ID-based fallback
        let actualPageName = pageName;
        const elementEditSection = element.dataset?.editSection || 'none';
        
        // If the element's edit section contains a page prefix, use that instead
        if (elementEditSection !== 'none' && elementEditSection.includes('-')) {
          const possiblePageId = elementEditSection.split('-')[0];
          // Check if this matches a known static page
          if (window.STATIC_PAGES && window.STATIC_PAGES[possiblePageId]) {
            actualPageName = possiblePageId;
          }
        }
        
        // Use the corrected page name
        const finalPageName = actualPageName;
        
        // Use index-based detection for static page sections
        const allEditables = Array.from(staticPageArticle.querySelectorAll('.editable'));
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const currentIndex = allEditables.indexOf(editableElement);
        
        // For static pages, use the actual edit section from the element's data attribute
        const actualEditSection = elementEditSection !== 'none' ? elementEditSection : `section-${currentIndex}`;
        
        return {
          contentType: 'staticPage',
          itemIdentifier: finalPageName,  // Use corrected page name
          categoryName: null,
          property: 'html',
          editType: 'html',
          editSection: actualEditSection,  // Use actual edit section ID
          config: window.ContentTypes.staticPage,
          element: editableElement,
          container: element
        };
      }
      
      // Default fallback
      return {
        contentType: 'unknown',
        itemIdentifier: editSection || 'content',
        categoryName: null,
        property: 'html',
        editType: 'html',
        editSection,
        config: { fields: {} },
        element: element.classList.contains('editable-section') ? element.querySelector('.editable') : element,
        container: element
      };
    }

    parseTagsEditContext(element, editSection) {
      // Check if we're in an object card
      const objetCard = element.closest('.card[data-objet-name]');
      if (objetCard) {
        const objetName = objetCard.dataset.objetName;
        const categoryName = objetCard.dataset.categoryName;
        
        return {
          contentType: 'objet',
          itemIdentifier: objetName,
          categoryName: categoryName,
          property: 'tags',
          editType: 'tags',
          editSection: editSection,
          config: window.ContentTypes.objet,
          element: element.classList.contains('editable') ? element : element.querySelector('.editable'),
          container: element
        };
      }
      
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        return {
          contentType: 'monster',
          itemIdentifier: monsterName,
          categoryName: categoryName || 'monstres',
          property: 'tags',
          editType: 'tags',
          editSection: editSection,
          config: window.ContentTypes.monster,
          element: element.classList.contains('editable') ? element : element.querySelector('.editable'),
          container: element
        };
      }
      
      return null;
    }

    parseSelectEditContext(element, editSection) {
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        return {
          contentType: 'monster',
          itemIdentifier: monsterName,
          categoryName: categoryName || 'monstres',
          property: 'element',
          editType: 'select',
          editSection: editSection,
          config: window.ContentTypes.monster,
          element: element,
          container: element.closest('.monster-element-section')
        };
      }
      
      // Check if we're in a spell card
      const spellCard = element.closest('.card[data-spell-name]');
      if (spellCard) {
        const spellName = spellCard.dataset.spellName;
        const spellIndex = spellCard.dataset.spellIndex;
        const categoryName = spellCard.dataset.categoryName;
        
        return {
          contentType: 'spell',
          itemIdentifier: spellName,
          itemIndex: spellIndex,
          categoryName: categoryName,
          property: 'element',
          editType: 'select',
          editSection: editSection,
          config: window.ContentTypes.spell,
          element: element,
          container: element.closest('.spell-element-section')
        };
      }
      
      return null;
    }

    makeElementEditable(editableElement, container) {
      const originalHtml = editableElement.innerHTML;
      container.dataset.originalContent = originalHtml;
      container.dataset.editing = 'true';

      // Decode any encoded HTML before showing for editing
      const decodedHtml = this.decodeHtmlEntities(originalHtml);
      editableElement.innerHTML = decodedHtml;
      editableElement.contentEditable = true;
      editableElement.style.cssText += `
        background-color: rgba(255, 255, 0, 0.1);
        border: 1px dashed var(--bronze);
        border-radius: 4px;
        padding: 4px;
        font-family: monospace;
        white-space: pre-wrap;
      `;
      editableElement.focus();

      const range = document.createRange();
      range.selectNodeContents(editableElement);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
    }

    makeTagsEditable(editableElement, container) {
      console.log('🔍 DEBUG: makeTagsEditable called');
      console.log('🔍 DEBUG: editableElement:', editableElement);
      console.log('🔍 DEBUG: container:', container);
      console.log('🔍 DEBUG: currentEditSession:', this.currentEditSession);
      
      const originalHtml = editableElement.innerHTML;
      container.dataset.originalContent = originalHtml;
      container.dataset.editing = 'true';

      // Get current tags from the object
      const objetName = this.currentEditSession.itemIdentifier;
      console.log('🔍 DEBUG: objetName:', objetName);
      
      const objet = window.OBJETS?.objets?.find(obj => obj.nom === objetName);
      console.log('🔍 DEBUG: found objet:', objet);
      
      const currentTags = objet?.tags || [];
      const availableTags = window.ContentTypes.objet.filterConfig.availableTags;
      console.log('🔍 DEBUG: currentTags:', currentTags);
      console.log('🔍 DEBUG: availableTags:', availableTags);

      // Create and show modal instead of inline editor
      this.showTagsModal(objetName, currentTags, availableTags);
    }

    showTagsModal(objetName, currentTags, availableTags) {
      console.log('🔍 DEBUG: showTagsModal called for object:', objetName);
      console.log('🔍 DEBUG: currentTags:', currentTags);
      console.log('🔍 DEBUG: availableTags:', availableTags);
      
      // Remove any existing tags modal
      const existingModal = document.querySelector('#tagsEditModal');
      if (existingModal) {
        console.log('🔍 DEBUG: Removing existing modal');
        existingModal.remove();
      }

      // Log DOM structure before creating modal
      console.log('🔍 DEBUG: Current body children count:', document.body.children.length);
      console.log('🔍 DEBUG: Body z-index elements:', Array.from(document.body.children).map(el => ({
        tagName: el.tagName,
        className: el.className,
        zIndex: window.getComputedStyle(el).zIndex,
        position: window.getComputedStyle(el).position
      })));

      // Use native HTML5 dialog element for proper z-index handling
      const modal = document.createElement('dialog');
      modal.id = 'tagsEditModal';
      modal.style.cssText = `
        max-width: 500px !important;
        width: 90% !important;
        padding: 0 !important;
        border: none !important;
        border-radius: 12px !important;
        background: transparent !important;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5) !important;
      `;
      
      console.log('🔍 DEBUG: Created dialog element:', modal);

      const checkboxesHTML = availableTags.map(tag => `
        <div style="display: flex; align-items: center; gap: 0.5rem; margin: 0.5rem 0; padding: 0.5rem; background: #f5f5f5; border-radius: 8px;">
          <input 
            type="checkbox" 
            id="modal-tag-${tag}" 
            value="${tag}" 
            ${currentTags.includes(tag) ? 'checked' : ''}
            style="margin: 0;"
          >
          <label for="modal-tag-${tag}" style="flex: 1; cursor: pointer; font-weight: 500;">
            <span style="background: #8B4513; color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 0.5rem;">${tag}</span>
            ${tag}
          </label>
        </div>
      `).join('');

      modal.innerHTML = `
        <div style="
          background: white; 
          border-radius: 12px; 
          padding: 1.5rem; 
          border: 3px solid #8B4513;
          font-family: inherit;
          font-size: 16px;
          color: #333;
        ">
          <h3 style="margin: 0 0 1rem 0; color: #8B4513; font-size: 1.2em;">🏷️ Éditer les tags de "${objetName}"</h3>
          <p style="margin: 0 0 1rem 0; color: #666; font-size: 0.9em;">Sélectionnez les tags à assigner à cet objet :</p>
          
          <div id="tagsCheckboxes" style="margin: 1rem 0;">
            ${checkboxesHTML}
          </div>
          
          <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem;">
            <button type="button" class="btn-cancel-tags-modal" style="
              background: #666; 
              color: white; 
              border: none; 
              padding: 8px 16px; 
              border-radius: 6px; 
              cursor: pointer;
              font-weight: 500;
              font-size: 14px;
            ">
              ❌ Annuler
            </button>
            <button type="button" class="btn-save-tags-modal" style="
              background: #8B4513; 
              color: white; 
              border: none; 
              padding: 8px 16px; 
              border-radius: 6px; 
              cursor: pointer;
              font-weight: 500;
              font-size: 14px;
            ">
              💾 Sauvegarder
            </button>
          </div>
        </div>
      `;

      // Append to body and show modal using native dialog API
      console.log('🔍 DEBUG: Adding modal to body');
      document.body.appendChild(modal);
      
      console.log('🔍 DEBUG: Modal added to DOM, calling showModal()');
      console.log('🔍 DEBUG: Modal computed styles before showModal:', {
        display: window.getComputedStyle(modal).display,
        position: window.getComputedStyle(modal).position,
        zIndex: window.getComputedStyle(modal).zIndex,
        visibility: window.getComputedStyle(modal).visibility
      });
      
      // Use showModal() for proper top-level display
      try {
        modal.showModal();
        console.log('🔍 DEBUG: showModal() called successfully');
        
        console.log('🔍 DEBUG: Modal computed styles after showModal:', {
          display: window.getComputedStyle(modal).display,
          position: window.getComputedStyle(modal).position,
          zIndex: window.getComputedStyle(modal).zIndex,
          visibility: window.getComputedStyle(modal).visibility
        });
        
        console.log('🔍 DEBUG: Modal bounding rect:', modal.getBoundingClientRect());
        
        // Log all body children with their z-index after modal is shown
        console.log('🔍 DEBUG: All body children after modal shown:', Array.from(document.body.children).map(el => ({
          tagName: el.tagName,
          id: el.id,
          className: el.className,
          zIndex: window.getComputedStyle(el).zIndex,
          position: window.getComputedStyle(el).position,
          display: window.getComputedStyle(el).display
        })));
        
      } catch (error) {
        console.error('🔍 DEBUG: Error calling showModal():', error);
      }

      // Set up event handlers
      modal.querySelector('.btn-save-tags-modal').addEventListener('click', () => {
        this.saveTagsFromModal(modal);
      });

      modal.querySelector('.btn-cancel-tags-modal').addEventListener('click', () => {
        this.cancelTagsModal(modal);
      });

      // Native dialog handles backdrop clicks and ESC automatically
      modal.addEventListener('cancel', (e) => {
        this.cancelTagsModal(modal);
      });

      // Close on backdrop click (for dialog elements)
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.cancelTagsModal(modal);
        }
      });
    }

    saveTagsFromModal(modal) {
      if (!this.currentEditSession) return false;

      const checkboxes = modal.querySelectorAll('input[type="checkbox"]:checked');
      const selectedTags = Array.from(checkboxes).map(cb => cb.value);

      if (selectedTags.length === 0) {
        alert('Veuillez sélectionner au moins un tag');
        return false;
      }

      // Update data based on content type
      const itemName = this.currentEditSession.itemIdentifier;
      let targetItem = null;
      
      if (this.currentEditSession.contentType === 'objet') {
        // Update the object data
        targetItem = window.OBJETS?.objets?.find(obj => obj.nom === itemName);
      } else if (this.currentEditSession.contentType === 'monster') {
        // Update the monster data
        targetItem = window.MONSTRES?.find(monster => monster.nom === itemName);
      }
      
      if (targetItem) {
        targetItem.tags = selectedTags;
        
        // Update the display
        const tagsDisplay = selectedTags.map(tag => 
          `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`
        ).join('');
        
        // Restore the element and update its content
        this.resetEditingState(this.currentEditSession.container);
        this.restoreElementContent(this.currentEditSession, tagsDisplay);
        
        // Save to storage
        EventBus.emit(Events.STORAGE_SAVE);
        
        // Close modal and clear edit session
        modal.close();
        modal.remove();
        this.currentEditSession = null;
        
        // Show success notification
        JdrApp.modules.ui.showNotification(`🏷️ Tags mis à jour : ${selectedTags.join(', ')}`, 'success');
        
        return true;
      }
      
      return false;
    }

    cancelTagsModal(modal) {
      // Close modal without saving
      modal.close();
      modal.remove();
      
      // Cancel the edit session
      this.cancelCurrentEdit();
    }

    // Save current editing session
    saveCurrentEdit() {
      if (!this.currentEditSession) return false;

      const session = this.currentEditSession;
      // Get the edited HTML content from innerHTML (user edited the rendered content)
      const newContent = session.element.innerHTML.trim();
      const normalizedContent = this.normalizeHTMLContent(newContent);

      // Reset editing state first to avoid interfering with content restoration
      this.resetEditingState(session.container);

      if (normalizedContent !== session.originalContent) {
        const success = this.saveContent(session, normalizedContent);
        if (success) {
          // Convert back from text to rendered HTML
          this.restoreElementContent(session, normalizedContent);
          
          EventBus.emit(Events.CONTENT_UPDATE, {
            contentType: session.contentType,
            itemIdentifier: session.itemIdentifier,
            property: session.property,
            value: normalizedContent
          });
        } else {
          // If save failed, restore original content
          this.restoreElementContent(session, session.originalContent);
        }
      } else {
        // Even if no changes, restore HTML rendering
        this.restoreElementContent(session, session.originalContent);
      }

      this.currentEditSession = null;
      return true;
    }

    // Update content in data structure - unified method for all content types
    updateContentInDataStructure(session, content) {
      try {
        switch (session.contentType) {
          case 'spell':
            return this.updateSpellData(session, content);
          case 'don':
            return this.updateDonData(session, content);
          case 'objet':
            return this.updateObjetData(session, content);
          case 'monster':
            return this.updateMonsterData(session, content);
          case 'category':
            return this.updateCategoryData(session, content);
          case 'subclass':
            return this.updateSubclassData(session, content);
          case 'class':
            return this.updateClassData(session, content);
          case 'staticPage':
            return this.updateStaticPageData(session, content);
          default:
            console.error('Unknown content type for update:', session.contentType);
            return false;
        }
      } catch (error) {
        console.error('Error updating content:', error, session);
        return false;
      }
    }

    // Update spell data
    updateSpellData(session, content) {
      const category = window.SORTS?.find(cat => cat.nom === session.categoryName);
      if (!category) return false;
      
      const spell = category.sorts?.find(s => s.nom === session.itemIdentifier);
      if (!spell) return false;
      
      spell[session.editSection] = content;
      return true;
    }

    // Update don data
    updateDonData(session, content) {
      const category = window.DONS?.find(cat => cat.nom === session.categoryName);
      if (!category) return false;
      
      const don = category.dons?.find(d => d.nom === session.itemIdentifier);
      if (!don) return false;
      
      don[session.editSection] = content;
      return true;
    }

    // Update objet data
    updateObjetData(session, content) {
      const objet = window.OBJETS?.objets?.find(o => o.nom === session.itemIdentifier);
      if (!objet) return false;
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.objet;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      objet[propertyName] = content;
      return true;
    }

    // Update monster data
    updateMonsterData(session, content) {
      const monster = window.MONSTRES?.find(m => m.nom === session.itemIdentifier);
      if (!monster) {
        console.error('Monster not found:', session.itemIdentifier, 'Available monsters:', window.MONSTRES?.map(m => m.nom));
        return false;
      }
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.monster;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // Backup current value for rollback capability
      const originalValue = monster[propertyName];
      
      console.log('🔍 DEBUG: Updating monster', monster.nom, 'property', propertyName, 'from', originalValue, 'to', content);
      
      try {
        // Update the monster property
        monster[propertyName] = content;
        
        // Force synchronization using ContentFactory to prevent data reversion
        const contentFactory = window.ContentFactory?.getInstance ? window.ContentFactory.getInstance() : null;
        if (contentFactory && contentFactory.updateItem) {
          // Use ContentFactory to ensure proper data synchronization
          contentFactory.updateItem('monster', null, monster.nom, propertyName, content);
        }
        
        // Additional safety: ensure image mapping is maintained
        if (propertyName === 'image' && JdrApp.modules.images) {
          const imageKey = `monster:${monster.nom}`;
          JdrApp.modules.images.setImage(imageKey, content);
          console.log('📷 Updated image mapping for monster:', monster.nom);
        }
        
        // Create backup for crash recovery
        this.createMonsterBackup(monster);
        
        console.log('✅ Monster update successful:', monster);
        return true;
        
      } catch (error) {
        // Rollback on error
        console.error('❌ Error updating monster, rolling back:', error);
        monster[propertyName] = originalValue;
        return false;
      }
    }

    // Update category data (generic for all category types)
    updateCategoryData(session, content) {
      // Handle different category types generically
      if (session.categoryType === 'don') {
        const category = window.DONS?.find(cat => cat.nom === session.categoryName);
        if (category && session.editSection === 'description') {
          category.description = content;
          return true;
        }
      } else if (session.categoryType === 'spell') {
        const category = window.SORTS?.find(cat => cat.nom === session.categoryName);
        if (category && session.editSection === 'description') {
          category.description = content;
          return true;
        }
      }
      
      // Simple fallback - if we're editing description and nothing else matched, 
      // and we have OBJETS, assume it's the objects category
      if (session.editSection === 'description' && window.OBJETS) {
        window.OBJETS.description = content;
        return true;
      }
      
      return false;
    }

    // Update subclass data
    updateSubclassData(session, content) {
      const classe = window.CLASSES?.find(c => c.nom === session.categoryName);
      if (!classe) return false;
      
      const subclass = classe.sousClasses?.find(sc => sc.nom === session.itemIdentifier);
      if (!subclass) return false;
      
      subclass[session.editSection] = content;
      return true;
    }

    // Update class data
    updateClassData(session, content) {
      const classe = window.CLASSES?.find(c => c.nom === session.itemIdentifier);
      if (!classe) return false;
      
      classe[session.editSection] = content;
      return true;
    }

    // Update static page data
    updateStaticPageData(session, content) {
      const pageKey = session.itemIdentifier;
      const pageData = window.STATIC_PAGES?.[pageKey];
      
      if (!pageData) return false;
      
      // Handle page title
      if (session.editSection === 'page-title') {
        pageData.title = content;
        return true;
      }
      
      // Handle sections
      return this.updateStaticPageSection(pageData, session, content);
    }

    // Update specific section in static page data
    updateStaticPageSection(pageData, session, content) {
      if (!pageData.sections) return false;
      
      const sections = pageData.sections;
      
      // Find section by ID or type
      for (let i = 0; i < sections.length; i++) {
        const section = sections[i];
        
        // Direct ID match
        if (section.id === session.editSection) {
          section.content = content;
          return true;
        }
        
        // Handle title updates (ID + "-title")
        if (session.editSection.endsWith('-title')) {
          const sectionId = session.editSection.replace('-title', '');
          if (section.id === sectionId) {
            section.title = content;
            return true;
          }
        }
        
        // Handle intro sections
        if (section.type === 'intro' && session.editSection.includes('intro')) {
          section.content = content;
          return true;
        }
        
        // Handle card sections
        if (section.type === 'card' && section.id === session.editSection) {
          section.content = content;
          return true;
        }
      }
      
      // If no existing section found, check if we need to create one for intro
      if (session.editSection === 'intro' || session.editSection.includes('intro')) {
        const introSection = sections.find(s => s.type === 'intro');
        if (introSection) {
          introSection.content = content;
          return true;
        }
      }
      
      return false;
    }

    // Save content using unified system
    saveContent(session, content) {
      try {
        // Determine which JSON category to save to
        let jsonCategory;
        
        switch (session.contentType) {
          case 'spell':
            jsonCategory = 'SORTS';
            break;
          case 'don':
            jsonCategory = 'DONS';
            break;
          case 'class':
            jsonCategory = 'CLASSES';
            break;
          case 'subclass':
            jsonCategory = 'CLASSES';  // Subclasses are stored within CLASSES
            break;
          case 'category':
            // Category descriptions can be in SORTS, DONS, or OBJETS
            if (session.categoryType === 'don') {
              jsonCategory = 'DONS';
            } else if (session.categoryType === 'spell') {
              jsonCategory = 'SORTS';
            } else {
              // Default to OBJETS for other category descriptions
              jsonCategory = 'OBJETS';
            }
            break;
          case 'objet':
            jsonCategory = 'OBJETS';
            break;
          case 'monster':
            jsonCategory = 'MONSTRES';
            break;
          case 'staticPage':
          case 'generic':
            jsonCategory = 'STATIC_PAGES';
            break;
          default:
            console.warn('Unknown content type:', session.contentType);
            return false;
        }
        
        return this.saveToJson(session, content, jsonCategory);
      } catch (error) {
        console.error('Save error:', error);
        return false;
      }
    }

    // Unified save method that takes a JSON category parameter
    saveToJson(session, content, jsonCategory) {
      const jsonData = window[jsonCategory];
      if (!jsonData) {
        console.error(`JSON category ${jsonCategory} not found`);
        return false;
      }


      // Generic save - find the target object and save the content
      let targetObject = null;
      
      if (session.contentType === 'spell' || session.contentType === 'don') {
        // Find in category -> items structure
        for (const category of jsonData) {
          if (category.nom === session.categoryName) {
            const itemsKey = session.contentType === 'spell' ? 'sorts' : 'dons';
            // Use index-based identification if available, fallback to name-based
            if (session.itemIndex !== undefined && session.itemIndex !== null) {
              const index = parseInt(session.itemIndex, 10);
              targetObject = category[itemsKey]?.[index];
            } else {
              targetObject = category[itemsKey]?.find(item => item.nom === session.itemIdentifier);
            }
            break;
          }
        }
      } else if (session.contentType === 'class') {
        // Find class directly
        targetObject = jsonData.find(c => c.nom === session.itemIdentifier);
      } else if (session.contentType === 'subclass') {
        // Find subclass within a class
        const parentClass = jsonData.find(c => c.nom === session.categoryName);
        if (parentClass?.sousClasses) {
          targetObject = parentClass.sousClasses.find(sc => sc.nom === session.itemIdentifier);
        }
      } else if (session.contentType === 'objet') {
        // Find object directly in the objets array
        targetObject = jsonData.objets?.find(obj => obj.nom === session.itemIdentifier);
      } else if (session.contentType === 'monster') {
        // Find monster directly in the array
        targetObject = jsonData?.find(monster => monster.nom === session.itemIdentifier);
      } else if (session.contentType === 'category') {
        // Find category by name and update its description
        targetObject = jsonData.find(category => category.nom === session.categoryName);
      } else if (session.contentType === 'staticPage' || session.contentType === 'generic') {
        return this.saveStaticPageToJson(jsonData, session, content);
      }
      
      if (targetObject) {
        targetObject[session.editSection] = content;
        return true;
      } else {
        return false;
      }
    }


    saveStaticPageToJson(jsonData, session, content) {
      const pageData = jsonData[session.itemIdentifier];
      if (!pageData?.sections) {
        console.warn('Page data or sections not found for:', session.itemIdentifier);
        return false;
      }


      // Generic search by section ID or special cases
      const updateSection = (sections) => {
        for (const section of sections) {
          // Direct ID match for content
          if (section.id === session.editSection) {
            section.content = content;
            return true;
          }
          
          // Handle title updates (ID + "-title")
          if (session.editSection.endsWith('-title')) {
            const sectionId = session.editSection.replace('-title', '');
            if (section.id === sectionId) {
              section.title = content;
              return true;
            }
          }
          
          // Handle page title
          if (session.editSection === 'page-title') {
            // Page title is stored in the page data, not sections
            // This will be handled at page level
            return false;
          }
          
          // Handle intro sections
          if (section.type === 'intro' && session.editSection === 'intro') {
            section.content = content;
            return true;
          }

          // Handle nested content arrays (for grid sections)
          if (section.content && Array.isArray(section.content)) {
            if (updateSection(section.content)) {
              return true;
            }
          }
        }
        return false;
      };

      // Special handling for page title
      if (session.editSection === 'page-title') {
        pageData.title = content;
        return true;
      }

      if (updateSection(pageData.sections)) {
        return true;
      }

      console.warn('Section not found for editSection:', session.editSection);
      return false;
    }

    // No special processing - everything is just HTML now
    processContentByType(content, fieldConfig) {
      return content;
    }

    // UNIFIED CONTENT RESTORATION - USE THIS FOR ALL CONTENT TYPES
    // This method ensures that HTML content is always properly rendered
    // and prevents HTML tags from being displayed as visible text
    restoreElementContent(session, content) {
      // IMPORTANT: Always use innerHTML to render HTML content properly
      // Never use textContent for edited content as it will show HTML tags
      session.element.innerHTML = content;
      
      // NOTE FOR DEVELOPERS: 
      // - For ANY new content type, use this method instead of direct innerHTML assignment
      // - This prevents the recurring issue of visible HTML tags after editing
      // - ALL content types (static pages, spells, classes, dons) go through this
    }

    resetEditingState(container) {
      const editableElement = container.querySelector('.editable') || container;
      
      // Standard editing cleanup (modal is handled separately)
      editableElement.contentEditable = false;
      editableElement.style.cssText = editableElement.style.cssText
        .replace(/background-color[^;]*;?/g, '')
        .replace(/border[^;]*;?/g, '')
        .replace(/padding[^;]*;?/g, '')
        .replace(/font-family[^;]*;?/g, '')
        .replace(/white-space[^;]*;?/g, '');
      
      // Reset both container and editable element attributes
      container.dataset.editing = 'false';
      delete container.dataset.originalContent;
      
      // Also reset on the editable element itself in case it's the same
      if (editableElement !== container) {
        editableElement.dataset.editing = 'false';
        delete editableElement.dataset.originalContent;
      }
    }


    decodeHtmlEntities(html) {
      // Decode HTML entities step by step to prevent double-encoding
      let decoded = html
        .replace(/&amp;lt;/g, '<')  // &amp;lt; -> <
        .replace(/&amp;gt;/g, '>')  // &amp;gt; -> >
        .replace(/&lt;/g, '<')     // &lt; -> <
        .replace(/&gt;/g, '>')     // &gt; -> >
        .replace(/&quot;/g, '"')   // &quot; -> "
        .replace(/&#39;/g, "'")    // &#39; -> '
        .replace(/&amp;/g, '&');   // &amp; -> & (do this last)
      return decoded;
    }

    normalizeHTMLContent(html) {
      // First, unescape any already escaped HTML to prevent double-escaping
      let cleanHtml = html
        .replace(/&amp;lt;/g, '<')  // Handle double-escaped &amp;lt; -> &lt; -> <
        .replace(/&amp;gt;/g, '>')  // Handle double-escaped &amp;gt; -> &gt; -> >
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'");
      
      // Create temp div to parse and clean the HTML
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = cleanHtml;
      
      // Clean up any problematic div elements
      tempDiv.querySelectorAll('div').forEach(div => {
        if (div.innerHTML === '<br>' || div.innerHTML === '<br/>') {
          div.outerHTML = '<br>';
        }
      });
      
      // Return the cleaned HTML
      return tempDiv.innerHTML.trim()
        .replace(/<br\s*\/?>/gi, '<br>')
        .replace(/\u00a0/g, '&nbsp;')
        .replace(/(\w+)\s*=\s*'([^']*)'/g, '$1="$2"');
    }

    // Cancel current edit
    cancelCurrentEdit() {
      if (!this.currentEditSession) return false;

      const session = this.currentEditSession;
      // Reset editing state first to avoid interfering with content restoration
      this.resetEditingState(session.container);
      // Restore original content
      this.restoreElementContent(session, session.originalContent);
      this.currentEditSession = null;
      return true;
    }

    // Check if element is currently being edited
    isEditing(element) {
      return element.dataset.editing === 'true';
    }

    // Save all active edits
    saveAllEdits() {
      if (this.currentEditSession) {
        this.saveCurrentEdit();
      }

      // Handle any remaining editing elements
      document.querySelectorAll('[data-editing="true"]').forEach(element => {
        if (!this.isValidForEdit(element)) {
          this.resetEditingState(element);
        }
      });
    }

    isValidForEdit(element) {
      const context = this.parseEditContext(element);
      return context !== null;
    }

    // Handle tags editing context
    parseTagsEditContext(element, editSection) {
      // Check if we're in an objet card
      const objetCard = element.closest('.card[data-objet-name]');
      if (objetCard) {
        const objetName = objetCard.dataset.objetName;
        const categoryName = objetCard.dataset.categoryName;
        
        return {
          contentType: 'objet',
          itemIdentifier: objetName,
          categoryName: categoryName,
          property: 'tags',
          editType: 'tags',
          editSection: 'tags',
          config: window.ContentTypes.objet,
          element: element.classList.contains('editable-tags') ? element : element.querySelector('.editable-tags'),
          container: element
        };
      }
      
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        const editableElement = element.classList.contains('editable-tags') ? element : element.querySelector('.editable-tags');
        
        // Use data-item-identifier if available, otherwise fall back to monsterName
        const itemIdentifier = editableElement?.dataset?.itemIdentifier || monsterName;
        
        return {
          contentType: 'monster',
          itemIdentifier: itemIdentifier,
          categoryName: categoryName || 'monstres',
          property: 'tags',
          editType: 'tags',
          editSection: 'tags',
          config: window.ContentTypes.monster,
          element: editableElement,
          container: element
        };
      }
      
      return null;
    }

    // Force reset of all elements that might be stuck in editing mode
    forceResetAllEditingElements() {
      // Reset any elements with contenteditable=true
      const editableElements = document.querySelectorAll('[contenteditable="true"]');
      editableElements.forEach(element => {
        element.contentEditable = false;
        element.style.background = '';
        element.style.border = '';
        element.style.padding = '';
        element.style.borderRadius = '';
        element.style.fontFamily = '';
        element.style.whiteSpace = '';
      });
      
      // Reset any containers with data-editing=true
      const editingContainers = document.querySelectorAll('[data-editing="true"]');
      editingContainers.forEach(container => {
        container.dataset.editing = 'false';
        delete container.dataset.originalContent;
      });
      
      // Clear any current edit session
      this.currentEditSession = null;
    }

    // Main entry point for starting edit
    startEdit(element) {
      // Force reset of any stuck editing elements first
      this.forceResetAllEditingElements();
      
      // Cancel any existing edit first
      if (this.currentEditSession) {
        this.saveCurrentEdit();
      }

      const context = this.parseEditContext(element);
      if (!context) {
        console.warn('Unable to parse edit context for element:', element);
        return false;
      }

      // Handle tags editing differently - show modal instead of inline editing
      if (context.editType === 'tags') {
        this.startTagsEdit(context);
        return true;
      }

      // Handle select editing differently - show dropdown instead of inline editing
      if (context.editType === 'select') {
        this.startSelectEdit(context);
        return true;
      }

      // Start normal inline editing
      return this.startInlineEdit(context);
    }

    // Start inline editing (for non-tags content)
    startInlineEdit(context) {
      const element = context.element;
      const container = context.container;

      // Store original content
      const originalContent = element.innerHTML;
      
      // Create edit session
      this.currentEditSession = {
        ...context,
        originalContent: originalContent
      };

      // Set up editing state
      container.dataset.editing = 'true';
      container.dataset.originalContent = originalContent;
      
      // Decode any encoded HTML before showing for editing
      const decodedHtml = this.decodeHtmlEntities(originalContent);
      element.innerHTML = decodedHtml;
      
      // Instead of contentEditable, show rendered content for editing
      // The user should see the formatted text, not the HTML tags
      
      // Create a temporary textarea for HTML editing if needed
      const useTextareaForHTML = decodedHtml.includes('<') && decodedHtml.includes('>');
      
      if (useTextareaForHTML) {
        // For HTML content, show a modal with textarea
        this.showHTMLEditModal(element, decodedHtml);
      } else {
        // For simple text, use contentEditable
        element.contentEditable = true;
        element.style.background = 'rgba(255, 255, 0, 0.1)';
        element.style.border = '2px solid var(--accent)';
        element.style.padding = '8px';
        element.style.borderRadius = '4px';
        element.style.fontFamily = 'inherit';
        element.style.whiteSpace = 'pre-wrap';
        
        // Focus and select all content
        element.focus();
      }
      
      // Select all text
      const range = document.createRange();
      range.selectNodeContents(element);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);

      return true;
    }

    // Save current edit
    saveCurrentEdit() {
      if (!this.currentEditSession) return false;

      const session = this.currentEditSession;
      const element = session.element;
      const newContent = element.innerHTML.trim();
      
      // Normalize and clean HTML content
      const processedContent = this.normalizeHTMLContent(newContent);
      
      // Apply changes to data structure
      const success = this.updateContentInDataStructure(session, processedContent);
      
      if (success) {
        // Update display
        this.restoreElementContent(session, processedContent);
        
        // Emit storage save event
        EventBus.emit(Events.STORAGE_SAVE);
        
        // Show success notification
        if (JdrApp.modules.ui?.showNotification) {
          JdrApp.modules.ui.showNotification('💾 Modification sauvegardée', 'success');
        }
      } else {
        console.error('Failed to save edit:', session);
      }
      
      // Reset editing state
      this.resetEditingState(session.container);
      this.currentEditSession = null;
      
      return success;
    }

    // Show modal for editing HTML content
    showHTMLEditModal(element, htmlContent) {
      // Store the current edit session for later use
      const editSession = this.currentEditSession;
      
      const modal = document.createElement('dialog');
      modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 0;
        border: none;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        max-width: 80vw;
        max-height: 80vh;
        z-index: 1000000 !important;
        background: transparent;
      `;

      // Créer un backdrop manuel
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999999 !important;
        backdrop-filter: blur(4px);
      `;

      modal.innerHTML = `
        <div style="background: var(--paper); border-radius: 12px; padding: 1.5rem; border: 2px solid var(--rule);">
          <h3 style="margin: 0 0 1rem 0; color: var(--accent-ink);">Édition du contenu</h3>
          
          <div style="margin-bottom: 1rem;">
            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Aperçu du rendu:</label>
            <div id="preview" style="border: 1px solid var(--rule); padding: 1rem; border-radius: 6px; background: var(--card); min-height: 60px;">
              ${htmlContent}
            </div>
          </div>
          
          <div style="margin-bottom: 1rem;">
            <label for="htmlEditor" style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Code HTML:</label>
            <textarea 
              id="htmlEditor" 
              style="width: 100%; height: 200px; padding: 1rem; border: 1px solid var(--rule); border-radius: 6px; font-family: monospace; font-size: 14px; resize: vertical;"
              placeholder="Entrez le HTML ici..."
            >${htmlContent}</textarea>
          </div>
          
          <div style="margin-bottom: 1rem;">
            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 0.5rem;">
              <button id="elementsBtn" class="btn" style="background: #059669; color: white; font-size: 12px;">🔥 Éléments</button>
              <button id="etatsBtn" class="btn" style="background: #7c2d12; color: white; font-size: 12px;">⚡ États</button>
              <button id="spellLinksBtn" class="btn" style="background: #6b21a8; color: white; font-size: 12px;">🔗 Liens Sorts</button>
            </div>
            <div style="font-size: 12px; color: var(--paper-muted); line-height: 1.4;">
              💡 <strong>Astuce:</strong> Utilisez ces boutons pour insérer rapidement des éléments, états et liens vers les sorts dans votre contenu HTML.
            </div>
          </div>
          
          <div style="display: flex; gap: 1rem; justify-content: flex-end;">
            <button id="cancelEdit" class="btn" style="background: #6b7280; color: white;">Annuler</button>
            <button id="saveEdit" class="btn" style="background: var(--accent); color: white;">💾 Sauvegarder</button>
          </div>
        </div>
      `;

      document.body.appendChild(backdrop);
      document.body.appendChild(modal);
      modal.show();

      const textarea = modal.querySelector('#htmlEditor');
      const preview = modal.querySelector('#preview');
      const saveBtn = modal.querySelector('#saveEdit');
      const cancelBtn = modal.querySelector('#cancelEdit');
      const elementsBtn = modal.querySelector('#elementsBtn');
      const etatsBtn = modal.querySelector('#etatsBtn');
      const spellLinksBtn = modal.querySelector('#spellLinksBtn');

      // Helper function to insert text at cursor position in textarea
      const insertTextAtCursor = (text) => {
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const currentValue = textarea.value;
        
        textarea.value = currentValue.substring(0, start) + text + currentValue.substring(end);
        textarea.selectionStart = textarea.selectionEnd = start + text.length;
        textarea.focus();
        
        // Update preview
        try {
          preview.innerHTML = textarea.value;
        } catch (e) {
          preview.textContent = 'Aperçu invalide: ' + e.message;
        }
      };

      // Store the insertTextAtCursor function globally so modals can access it
      window.editorInsertTextAtCursor = insertTextAtCursor;

      // Toolbox buttons handlers
      if (elementsBtn) {
        elementsBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showElementsModal) {
            JdrApp.modules.ui.showElementsModal();
          }
        });
      }

      if (etatsBtn) {
        etatsBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showEtatsModal) {
            JdrApp.modules.ui.showEtatsModal();
          }
        });
      }

      if (spellLinksBtn) {
        spellLinksBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showSpellLinksModal) {
            JdrApp.modules.ui.showSpellLinksModal();
          }
        });
      }

      // Live preview update
      textarea.addEventListener('input', () => {
        try {
          preview.innerHTML = textarea.value;
        } catch (e) {
          preview.textContent = 'Aperçu invalide: ' + e.message;
        }
      });

      // Save handler
      saveBtn.addEventListener('click', () => {
        const newContent = textarea.value.trim();
        const normalizedContent = this.normalizeHTMLContent(newContent);
        
        // Update the element content
        element.innerHTML = normalizedContent;
        
        // Update in data structure using stored session
        const success = this.updateContentInDataStructure(editSession, normalizedContent);
        
        if (success) {
          EventBus.emit(Events.STORAGE_SAVE);
          if (JdrApp.modules.ui?.showNotification) {
            JdrApp.modules.ui.showNotification('💾 Modification sauvegardée', 'success');
          }
        }
        
        // Clean up
        this.resetEditingState(editSession.container);
        this.currentEditSession = null;
        window.editorInsertTextAtCursor = null;
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Cancel handler
      cancelBtn.addEventListener('click', () => {
        this.resetEditingState(editSession.container);
        this.currentEditSession = null;
        window.editorInsertTextAtCursor = null;
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Close on backdrop click
      backdrop.addEventListener('click', () => {
        this.resetEditingState(editSession.container);
        this.currentEditSession = null;
        window.editorInsertTextAtCursor = null;
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Focus textarea
      textarea.focus();
      textarea.select();
    }

    // Handle select editing by toggling display/selector visibility
    startSelectEdit(context) {
      const element = context.element;
      const container = context.container;

      // Store the current edit session
      this.currentEditSession = {
        ...context,
        originalContent: element.value // For select, we store the value, not innerHTML
      };

      // Find the display and selector sections
      const sectionContainer = element.closest('.monster-element-section, .spell-element-section');
      if (!sectionContainer) {
        console.warn('Could not find element section container');
        return false;
      }

      const displaySection = sectionContainer.querySelector('.monster-element-display, .spell-element-display');
      const selectorSection = sectionContainer.querySelector('.monster-element-selector, .spell-element-selector');
      
      if (!displaySection || !selectorSection) {
        console.warn('Could not find display or selector sections');
        return false;
      }

      // Toggle visibility
      displaySection.style.display = 'none';
      selectorSection.style.display = 'block';

      // Set up change listener for the select element
      const selectElement = selectorSection.querySelector('select');
      if (selectElement) {
        selectElement.focus();
        
        // Add event listener for changes
        const changeHandler = () => {
          this.saveSelectEdit(selectElement);
          selectElement.removeEventListener('change', changeHandler);
          selectElement.removeEventListener('blur', blurHandler);
        };

        const blurHandler = () => {
          this.cancelSelectEdit(sectionContainer);
          selectElement.removeEventListener('change', changeHandler);
          selectElement.removeEventListener('blur', blurHandler);
        };

        selectElement.addEventListener('change', changeHandler);
        selectElement.addEventListener('blur', blurHandler);
      }

      return true;
    }

    // Save select edit
    saveSelectEdit(selectElement) {
      if (!this.currentEditSession) return false;

      const newValue = selectElement.value;
      const session = this.currentEditSession;

      // Update the data structure
      const success = this.updateContentInDataStructure(session, newValue);

      if (success) {
        // Update the display immediately
        this.updateElementDisplay(session, newValue);
        
        // Emit storage save event
        EventBus.emit(Events.STORAGE_SAVE);
        
        // Show success notification
        if (JdrApp.modules.ui?.showNotification) {
          JdrApp.modules.ui.showNotification('💾 Élément mis à jour', 'success');
        }
      }

      // Hide selector and show display
      this.resetSelectEdit();
      this.currentEditSession = null;
      return success;
    }

    // Cancel select edit
    cancelSelectEdit(sectionContainer) {
      this.resetSelectEdit();
      this.currentEditSession = null;
    }

    // Reset select edit UI state
    resetSelectEdit() {
      if (!this.currentEditSession) return;

      const element = this.currentEditSession.element;
      const sectionContainer = element.closest('.monster-element-section, .spell-element-section');
      if (!sectionContainer) return;

      const displaySection = sectionContainer.querySelector('.monster-element-display, .spell-element-display');
      const selectorSection = sectionContainer.querySelector('.monster-element-selector, .spell-element-selector');
      
      if (displaySection && selectorSection) {
        displaySection.style.display = 'block';
        selectorSection.style.display = 'none';
      }
    }

    // Update element display after selection change
    updateElementDisplay(session, newValue) {
      const element = session.element;
      const sectionContainer = element.closest('.monster-element-section, .spell-element-section');
      if (!sectionContainer) return;

      const displaySection = sectionContainer.querySelector('.monster-element-display, .spell-element-display');
      const badge = displaySection?.querySelector('.element-badge');
      
      if (badge) {
        // Get element icon and color
        const icon = window.ElementIcons?.[newValue] || '⚡';
        const color = window.ElementColors?.[newValue]?.color || '#666';
        
        // Update the badge content and style
        if (session.contentType === 'monster') {
          // For monsters, we need to update the complete badge styling
          const iconSpan = badge.querySelector('span:first-child');
          const textSpan = badge.querySelector('span:last-child');
          if (iconSpan && textSpan) {
            iconSpan.textContent = icon;
            textSpan.textContent = newValue;
            textSpan.style.color = color;
            
            // Update the complete badge background and border
            const hexColor = color;
            const rgbMatch = hexColor.match(/^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
            if (rgbMatch) {
              const r = parseInt(rgbMatch[1], 16);
              const g = parseInt(rgbMatch[2], 16);
              const b = parseInt(rgbMatch[3], 16);
              badge.style.background = `rgba(${r}, ${g}, ${b}, 0.1)`;
              badge.style.border = `1px solid ${hexColor}`;
            }
          }
        } else if (session.contentType === 'spell') {
          // Update spell badge
          badge.innerHTML = `${icon} ${newValue}`;
        }
      }
    }

    // Handle tags editing by showing modal
    startTagsEdit(context) {
      // For tags, we don't do inline editing, we show a modal
      this.showTagsModal(context);
    }

    // Show tags editing modal
    showTagsModal(context) {
      // Find the target item (object or monster)
      let targetItem = null;
      let availableTags = [];
      
      if (context.contentType === 'objet') {
        const allObjects = window.OBJETS?.objets || [];
        targetItem = allObjects.find(o => o.nom === context.itemIdentifier);
        availableTags = window.ContentTypes.objet.filterConfig.availableTags || [];
      } else if (context.contentType === 'monster') {
        const allMonsters = window.MONSTRES || [];
        targetItem = allMonsters.find(m => m.nom === context.itemIdentifier);
        availableTags = window.ContentTypes.monster.filterConfig.availableTags || [];
      }
      
      if (!targetItem) {
        console.error('Item not found for tags editing:', context.itemIdentifier, 'Type:', context.contentType);
        return;
      }

      const itemTags = targetItem.tags || [];

      // Remove existing modal if any
      const existingModal = document.querySelector('#tagsEditModal');
      if (existingModal) {
        existingModal.remove();
      }

      // Create modal
      const modal = document.createElement('dialog');
      modal.id = 'tagsEditModal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        padding: 0;
        border: none;
        border-radius: 12px;
        background: transparent;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      `;
      
      const tagsCheckboxes = availableTags.map(tag => {
        const isSelected = itemTags.includes(tag);
        return `
          <div style="display: flex; align-items: center; gap: 0.5rem; margin: 0.5rem 0; padding: 0.5rem; background: var(--card); border-radius: 8px;">
            <input 
              type="checkbox" 
              id="tag-${tag}" 
              value="${tag}" 
              ${isSelected ? 'checked' : ''}
              style="margin: 0;"
            >
            <label for="tag-${tag}" style="flex: 1; cursor: pointer; font-weight: 500;">
              <span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 0.5rem;">${tag}</span>
              ${tag}
            </label>
          </div>
        `;
      }).join('');

      modal.innerHTML = `
        <div style="background: var(--paper); border-radius: 12px; padding: 1.5rem; border: 2px solid var(--rule);">
          <h3 style="margin: 0 0 1rem 0; color: var(--accent-ink);">Édition des tags - ${targetItem.nom}</h3>
          <p style="margin: 0 0 1rem 0; color: var(--paper-muted);">Sélectionnez les tags pour cet objet :</p>
          <div id="tagsCheckboxes" style="margin: 1rem 0; max-height: 300px; overflow-y: auto;">
            ${tagsCheckboxes}
          </div>
          <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem;">
            <button class="btn" id="saveTagsBtn" style="background: var(--accent); color: white;">
              💾 Sauvegarder
            </button>
            <button class="btn modal-close" style="background: #666; color: white;">
              ❌ Annuler
            </button>
          </div>
        </div>
      `;

      // Add event listeners
      modal.addEventListener('click', (e) => {
        if (e.target.id === 'saveTagsBtn') {
          this.saveTagsFromModal(modal, targetItem, context);
        } else if (e.target.classList.contains('modal-close')) {
          modal.close();
          modal.remove();
        }
      });

      // Handle dialog close events
      modal.addEventListener('cancel', () => {
        modal.close();
        modal.remove();
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.close();
          modal.remove();
        }
      });

      document.body.appendChild(modal);
      modal.showModal();
    }

    // Save tags from modal
    saveTagsFromModal(modal, obj, context) {
      // Get selected tags
      const checkboxes = modal.querySelectorAll('input[type="checkbox"]:checked');
      const selectedTags = Array.from(checkboxes).map(cb => cb.value);

      if (selectedTags.length === 0) {
        JdrApp.modules.ui.showNotification('❌ Veuillez sélectionner au moins un tag', 'error');
        return;
      }

      // Update tags for the target item (works for both objects and monsters)
      obj.tags = selectedTags;

      // Update the display immediately
      const tagDisplay = context.element;
      if (tagDisplay) {
        const tagsDisplayHTML = selectedTags.map(tag => 
          `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`
        ).join('');
        tagDisplay.innerHTML = tagsDisplayHTML;
      }

      // Trigger save to storage
      EventBus.emit(Events.STORAGE_SAVE);
      
      // Close modal
      modal.close();
      modal.remove();
      
      JdrApp.modules.ui.showNotification(`💾 Tags sauvegardés pour "${obj.nom}"`, 'success');
    }

    // Create backup of monster data for recovery
    createMonsterBackup(monster) {
      try {
        if (!window.MonsterBackups) {
          window.MonsterBackups = new Map();
        }
        
        // Keep only last 5 backups per monster
        const backupKey = monster.nom;
        const currentBackups = window.MonsterBackups.get(backupKey) || [];
        
        const backup = {
          timestamp: Date.now(),
          data: JSON.parse(JSON.stringify(monster)) // Deep copy
        };
        
        currentBackups.push(backup);
        if (currentBackups.length > 5) {
          currentBackups.shift(); // Remove oldest
        }
        
        window.MonsterBackups.set(backupKey, currentBackups);
        
      } catch (error) {
        console.warn('Failed to create monster backup:', error);
      }
    }

    // Recover monster from backup
    recoverMonsterFromBackup(monsterName, backupIndex = 0) {
      try {
        if (!window.MonsterBackups || !window.MonsterBackups.has(monsterName)) {
          console.error('No backup found for monster:', monsterName);
          return false;
        }
        
        const backups = window.MonsterBackups.get(monsterName);
        const backup = backups[backups.length - 1 - backupIndex]; // Get latest by default
        
        if (!backup) {
          console.error('Backup index out of range for monster:', monsterName);
          return false;
        }
        
        // Find monster in current data
        const monster = window.MONSTRES?.find(m => m.nom === monsterName);
        if (!monster) {
          console.error('Monster not found in current data:', monsterName);
          return false;
        }
        
        // Restore data
        Object.assign(monster, backup.data);
        
        // Force sync
        const contentFactory = window.ContentFactory?.getInstance ? window.ContentFactory.getInstance() : null;
        if (contentFactory && contentFactory.refreshData) {
          contentFactory.refreshData();
        }
        
        console.log('✅ Monster recovered from backup:', monsterName, backup.timestamp);
        return true;
        
      } catch (error) {
        console.error('Failed to recover monster from backup:', error);
        return false;
      }
    }

    // Global validation and repair of monster data
    validateAndRepairMonsterData() {
      if (!window.MONSTRES || !Array.isArray(window.MONSTRES)) {
        console.warn('No monster data to validate');
        return 0;
      }
      
      let repairCount = 0;
      const contentTypes = window.ContentTypes?.monster;
      
      window.MONSTRES.forEach((monster, index) => {
        // Ensure required properties exist
        if (!monster.nom) {
          monster.nom = `Monstre ${index + 1}`;
          repairCount++;
        }
        
        // Validate numeric properties
        if (contentTypes && contentTypes.fields) {
          Object.entries(contentTypes.fields).forEach(([fieldName, fieldConfig]) => {
            if (fieldConfig.type === 'number') {
              if (typeof monster[fieldName] !== 'number' || isNaN(monster[fieldName])) {
                const defaultValue = contentTypes.defaultValues?.[fieldName] || 0;
                console.warn(`🔧 Repairing ${monster.nom}.${fieldName}: ${monster[fieldName]} -> ${defaultValue}`);
                monster[fieldName] = defaultValue;
                repairCount++;
              }
            }
          });
        }
        
        // Ensure image path exists and is valid
        if (!monster.image || typeof monster.image !== 'string') {
          monster.image = `data/images/Monstres/foret/Monstre_Forêt_${monster.nom.replace(/[^a-zA-Z0-9]/g, '')}.png`;
          repairCount++;
        }
        
        // Validate image mapping exists
        if (JdrApp.modules.images) {
          const imageKey = `monster:${monster.nom}`;
          if (!JdrApp.modules.images.getImageUrl(imageKey)) {
            JdrApp.modules.images.setImage(imageKey, monster.image);
          }
        }
      });
      
      if (repairCount > 0) {
        console.log(`🔧 Repaired ${repairCount} monster data issues`);
        
        // Save repaired data
        if (JdrApp.modules.storage && JdrApp.modules.storage.saveChanges) {
          JdrApp.modules.storage.saveChanges(true);
        }
      }
      
      return repairCount;
    }
  }

  window.UnifiedEditor = UnifiedEditor.getInstance();

})();
// ============================================================================
// JDR-BAB APPLICATION - EDITOR MODULE (REFACTORED)
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // EDITOR MODULE - Now uses UnifiedEditor
  // ========================================
  JdrApp.modules.editor = {
    editedData: {},
    isDevMode: false,

    init() {
      this.setupEventListeners();
      this.setupEditableHandlers();
      this.setupCreationHandlers();
      this.setupImageHandlers();
      this.updateDevModeState();
    },

    setupEventListeners() {
      JdrApp.utils.events.register('click', '#devToggle', () => this.toggleDevMode());

      EventBus.on(Events.EDITOR_TOGGLE, (payload) => {
        this.isDevMode = payload.enabled;
        this.updateDevModeState();
      });

      EventBus.on(Events.CONTENT_UPDATE, () => {
        this.saveChangesToStorage();
      });

    },

    toggleDevMode() {
      if (window.STANDALONE_VERSION) return;
      
      this.isDevMode = !this.isDevMode;
      EventBus.emit(Events.EDITOR_TOGGLE, { enabled: this.isDevMode });
    },

    updateDevModeState() {
      if (window.STANDALONE_VERSION) {
        document.body.className = 'dev-off';
        this.forceHideAllEditButtons();
        return;
      }
      
      document.body.classList.toggle('dev-on', this.isDevMode);
      document.body.classList.toggle('dev-off', !this.isDevMode);
      
      const devToggle = document.querySelector('#devToggle');
      const devToolbox = document.querySelector('#devToolbox');
      
      if (devToggle) {
        devToggle.textContent = `🛠 Dev Mode: ${this.isDevMode ? 'ON' : 'OFF'}`;
      }
      
      if (devToolbox) {
        devToolbox.style.display = this.isDevMode ? 'block' : 'none';
      }
      
      // Update dev-only containers visibility - same approach as modal buttons
      const devOnlyElements = document.querySelectorAll('[data-dev-only]');
      devOnlyElements.forEach(element => {
        element.style.display = this.isDevMode ? 'block' : 'none';
      });
      
      if (this.isDevMode) {
        this.forceShowAllEditButtons();
      } else {
        this.forceHideAllEditButtons();
      }

      // Regenerate monsters page if currently viewing it
      const currentPage = window.location.hash.replace('#/', '');
      if (currentPage === 'monstres' && JdrApp.modules.renderer && JdrApp.modules.renderer.populateMonstersPage) {
        setTimeout(() => {
          JdrApp.modules.renderer.populateMonstersPage();
        }, 100);
      }
    },

    forceHideAllEditButtons() {
      if (this.isDevMode) {
        return;
      }
      
      const selectors = [
        '.edit-btn', '[class$="-add"]', '[class$="-delete"]', '[class*="-move-"]',
        '.section-delete', '.remove-section-btn', '.add-paragraph-btn', 
        '.add-subclass-btn', '.delete-subclass-btn',
        '.spell-delete', '.don-delete', // Explicit delete buttons
        '.illus .up', '.illus .rm', '.illus label', '.illus input[type="file"]',
        '.tags-manager-btn', '.filter-manager-btn' // Tags and filter manager buttons
      ];
      
      selectors.forEach(selector => {
        document.querySelectorAll(selector).forEach(element => {
          element.style.display = 'none';
          element.style.visibility = 'hidden';
          element.setAttribute('aria-hidden', 'true');
        });
      });
    },
    
    forceShowAllEditButtons() {
      if (!this.isDevMode) return;
      
      // Ensure body has the correct classes
      document.body.classList.add('dev-on');
      document.body.classList.remove('dev-off');
      
      // Force reset all CSS properties that might be causing 0x0 dimensions
      const selectors = [
        '.edit-btn', '[class$="-add"]', '[class$="-delete"]', '[class*="-move-"]',
        '.section-delete', '.remove-section-btn', '.add-paragraph-btn', 
        '.add-subclass-btn', '.delete-subclass-btn',
        '.spell-delete', '.don-delete', '.objet-delete',
        '.spell-add', '.don-add', '.objet-add',
        '.illus .up', '.illus .rm', '.illus label', '.illus input[type="file"]',
        '.tags-manager-btn', '.filter-manager-btn' // Tags and filter manager buttons
      ];
      
      selectors.forEach(selector => {
        document.querySelectorAll(selector).forEach(element => {
          // Force reset all dimension properties
          element.style.removeProperty('display');
          element.style.removeProperty('visibility');
          element.style.removeProperty('opacity');
          element.style.removeProperty('width');
          element.style.removeProperty('height');
          element.style.removeProperty('min-width');
          element.style.removeProperty('min-height');
          element.style.removeProperty('pointer-events');
          element.removeAttribute('aria-hidden');
          
          // Let CSS handle the styling
          element.style.display = '';
          element.style.visibility = '';
        });
      });
    },

    setupEditableHandlers() {
      // Unified edit button handler
      JdrApp.utils.events.register('click', '.edit-btn', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!this.isDevMode) return;
        
        // Find the editable element near the button
        let editableElement = e.target.previousElementSibling;
        
        // If not found as previous sibling, look in parent
        if (!editableElement || !editableElement.classList.contains('editable')) {
          const parent = e.target.parentElement;
          editableElement = parent.querySelector('.editable');
        }
        
        // Fallback: look for closest editable element
        if (!editableElement || !editableElement.classList.contains('editable')) {
          editableElement = e.target.closest('.editable-section')?.querySelector('.editable') ||
                           e.target.closest('.card')?.querySelector('.editable');
        }
        
        if (editableElement && editableElement.classList.contains('editable')) {
          UnifiedEditor.startEdit(editableElement);
        } else {
          console.warn('No editable element found for edit button');
        }
      });

      // Handle select element changes directly
      JdrApp.utils.events.register('change', '.editable[data-edit-type="select"]', (e) => {
        if (!this.isDevMode) return;
        
        const selectElement = e.target;
        const newValue = selectElement.value;
        
        // Parse context and save immediately
        const context = UnifiedEditor.parseEditContext(selectElement);
        if (context) {
          // Update the data structure
          const success = UnifiedEditor.updateContentInDataStructure(context, newValue);
          if (success) {
            // Update display
            UnifiedEditor.updateElementDisplay(context, newValue);
            
            // Save to storage
            EventBus.emit(Events.STORAGE_SAVE);
            
            // Show notification
            if (JdrApp.modules.ui?.showNotification) {
              JdrApp.modules.ui.showNotification('💾 Élément mis à jour', 'success');
            }
          }
        }
      });

      // Click outside to save
      JdrApp.utils.events.register('click', 'body', (e) => {
        if (!e.target.closest('.editable') && !e.target.matches('.edit-btn')) {
          UnifiedEditor.saveAllEdits();
        }
      });

      // Keyboard shortcuts
      JdrApp.utils.events.register('keydown', '.editable', (e) => {
        if ((e.key === 'Enter' && !e.shiftKey) || e.key === 'Escape') {
          e.preventDefault();
          UnifiedEditor.saveCurrentEdit();
        }
      });

      // Prevent double-click editing (force button-only editing)
      JdrApp.utils.events.register('dblclick', '.editable', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      });
    },

    setupCreationHandlers() {
      // Unified subclass management
      JdrApp.utils.events.register('click', '.add-subclass-btn', (e) => {
        if (!this.isDevMode) return;
        this.addNewSubclass(e.target);
      });

      JdrApp.utils.events.register('click', '.delete-subclass-btn', (e) => {
        if (!this.isDevMode) return;
        this.deleteSubclass(e.target);
      });
    },

    addNewSubclass(button) {
      const article = button.closest('article');
      if (!article) return;
      
      let className = article.dataset.pageTitle;
      if (!className) {
        const hash = window.location.hash.match(/#\/([^\/]+)/);
        if (hash) {
          className = hash[1].charAt(0).toUpperCase() + hash[1].slice(1);
        }
      }
      
      console.log('Adding subclass to class:', className);
      
      if (!className || !window.CLASSES) {
        console.log('Missing className or CLASSES:', { className, hasClasses: !!window.CLASSES });
        return;
      }
      
      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe) {
        console.log('Class not found:', className);
        console.log('Available classes:', window.CLASSES.map(c => c.nom));
        return;
      }
      
      const config = window.ContentTypes.subclass;
      const newSubclass = { ...config.defaultValues };
      
      console.log('Creating new subclass:', newSubclass);
      
      if (!classe.sousClasses) classe.sousClasses = [];
      classe.sousClasses.push(newSubclass);
      
      console.log('Class after adding subclass:', classe);
      
      EventBus.emit(Events.CONTENT_ADD, {
        type: 'subclass',
        category: className,
        item: newSubclass
      });
      
      // Recharger juste le contenu de l'article au lieu de toute la page
      this.reloadClassPage(className);
    },

    deleteSubclass(button) {
      const className = button.dataset.className;
      const subclassName = button.dataset.subclassName;
      
      if (!className || !subclassName) return;
      if (!confirm(`Êtes-vous sûr de vouloir supprimer la sous-classe "${subclassName}" ?`)) return;

      const classe = window.CLASSES?.find(c => c.nom === className);
      if (!classe?.sousClasses) return;

      const index = classe.sousClasses.findIndex(sc => sc.nom === subclassName);
      if (index === -1) return;

      const deletedSubclass = classe.sousClasses.splice(index, 1)[0];
      
      EventBus.emit(Events.CONTENT_DELETE, {
        type: 'subclass',
        category: className,
        item: deletedSubclass
      });
      
      // Recharger juste le contenu de l'article au lieu de toute la page  
      this.reloadClassPage(className);
    },

    reloadClassPage(className) {
      // Trouver l'article de la classe
      const article = document.querySelector(`article[data-page-title="${className}"]`);
      if (!article) return;

      // Régénérer le contenu de la classe
      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe) return;

      // Vérifier que PageBuilder existe
      if (!window.PageBuilder) {
        console.error('PageBuilder not available, falling back to page reload');
        window.location.reload();
        return;
      }

      // Utiliser PageBuilder pour régénérer le contenu
      const newContent = window.PageBuilder.buildClassPage(classe);
      const parser = new DOMParser();
      const newDoc = parser.parseFromString(newContent, 'text/html');
      const newArticle = newDoc.querySelector('article');
      
      if (newArticle) {
        article.innerHTML = newArticle.innerHTML;
        
        // Réappliquer les images et l'état de dev mode
        setTimeout(() => {
          if (JdrApp.modules.renderer?.autoLoadImages) {
            JdrApp.modules.renderer.autoLoadImages();
          }
          // Apply dev mode state properly
          if (this.isDevMode) {
            this.forceShowAllEditButtons();
          } else {
            this.forceHideAllEditButtons();
          }
        }, 50);
      }
    },

    setupImageHandlers() {
      // Fonction pour attacher les événements aux images existantes
      this.attachImageEvents();
      
      // Observer pour attacher les événements aux nouvelles images créées dynamiquement
      if (typeof MutationObserver !== 'undefined') {
        const observer = new MutationObserver(() => {
          this.attachImageEvents();
        });
        observer.observe(document.body, { childList: true, subtree: true });
      }
    },

    attachImageEvents() {
      // Attacher aux inputs de fichier
      document.querySelectorAll('.illus input[type="file"]').forEach(input => {
        if (!input.hasAttribute('data-events-attached')) {
          input.addEventListener('change', (e) => this.handleImageUpload(e));
          input.setAttribute('data-events-attached', 'true');
        }
      });

      // Attacher aux boutons de suppression
      document.querySelectorAll('.illus .rm').forEach(button => {
        if (!button.hasAttribute('data-events-attached')) {
          button.addEventListener('click', (e) => this.handleImageRemoval(e));
          button.setAttribute('data-events-attached', 'true');
        }
      });

      // Attacher aux images pour agrandissement - toutes les images, pas seulement celles dans .illus
      document.querySelectorAll('img').forEach(img => {
        // Éviter les images dans les éditeurs ou les inputs
        if (!img.closest('.editor-content') && !img.hasAttribute('data-events-attached')) {
          // Ajouter support tactile pour mobile
          img.addEventListener('click', (e) => this.toggleImageEnlargement(e.target));
          img.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.toggleImageEnlargement(e.target);
          });
          img.setAttribute('data-events-attached', 'true');
          img.style.cursor = 'zoom-in';
        }
      });
    },

    handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const illus = event.target.closest('.illus');
        const img = illus.querySelector('img');
        const rmButton = illus.querySelector('.rm');
        const illusKey = illus.dataset.illusKey;

        img.src = e.target.result;
        img.style.display = 'block';
        if (rmButton) rmButton.style.display = 'block';

        if (JdrApp.modules.images?.setImageUrl) {
          JdrApp.modules.images.setImageUrl(illusKey, e.target.result);
        }

        EventBus.emit(Events.IMAGE_UPLOAD, { 
          illusKey, 
          src: e.target.result 
        });
      };
      
      reader.readAsDataURL(file);
    },

    handleImageRemoval(event) {
      const illus = event.target.closest('.illus');
      const img = illus.querySelector('img');
      const rmButton = illus.querySelector('.rm');
      const illusKey = illus.dataset.illusKey;

      img.src = '';
      img.style.display = 'none';
      if (rmButton) rmButton.style.display = 'none';

      if (JdrApp.modules.images?.removeImage) {
        JdrApp.modules.images.removeImage(illusKey);
      }

      EventBus.emit(Events.IMAGE_DELETE, { illusKey });
    },

    toggleImageEnlargement(img) {
      if (img.classList.contains('enlarged')) {
        this.closeEnlargedImage();
      } else {
        this.showEnlargedImage(img);
      }
    },

    showEnlargedImage(img) {
      // Fermer toute image déjà ouverte
      this.closeEnlargedImage();
      
      // Créer un conteneur modal complet
      const modal = document.createElement('div');
      modal.id = 'image-enlargement-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0,0,0,0.8);
        z-index: 2147483647;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: zoom-out;
      `;
      
      // Créer une copie de l'image
      const enlargedImg = img.cloneNode(true);
      enlargedImg.style.cssText = `
        max-width: 90vw;
        max-height: 90vh;
        width: auto;
        height: auto;
        object-fit: contain;
        border: 3px solid var(--gold);
        border-radius: 8px;
        background: white;
        box-shadow: 0 20px 60px rgba(0,0,0,.8), 0 0 20px rgba(212,175,55,.3);
        cursor: zoom-out;
      `;
      
      modal.appendChild(enlargedImg);
      document.body.appendChild(modal);
      
      // Fermer au clic et au touch pour mobile
      modal.onclick = () => this.closeEnlargedImage();
      modal.addEventListener('touchend', (e) => {
        if (e.target === modal) {
          e.preventDefault();
          this.closeEnlargedImage();
        }
      });
      
      // Fermer avec Échap
      const escapeHandler = (e) => {
        if (e.key === 'Escape') {
          this.closeEnlargedImage();
          document.removeEventListener('keydown', escapeHandler);
        }
      };
      document.addEventListener('keydown', escapeHandler);
      
      // Marquer l'image originale comme agrandie
      img.classList.add('enlarged');
    },

    closeEnlargedImage() {
      const modal = document.getElementById('image-enlargement-modal');
      if (modal) {
        modal.remove();
      }
      
      // Retirer la classe de toutes les images
      document.querySelectorAll('img.enlarged').forEach(img => {
        img.classList.remove('enlarged');
      });
      
      // Nettoyer les anciens backdrops
      const oldBackdrop = document.querySelector('.image-backdrop');
      if (oldBackdrop) {
        oldBackdrop.remove();
      }
    },

    createImageBackdrop() {
      // Méthode obsolète - redirigée vers la nouvelle approche
      console.warn('createImageBackdrop is deprecated, use showEnlargedImage instead');
    },

    removeImageBackdrop() {
      // Méthode obsolète - redirigée vers la nouvelle approche
      this.closeEnlargedImage();
    },

    saveChangesToStorage() {
      try {
        localStorage.setItem('jdr-bab-edits', JSON.stringify(this.editedData));
        localStorage.setItem('jdr-bab-last-modified', Date.now().toString());
        EventBus.emit(Events.STORAGE_SAVE);
      } catch (error) {
        console.error('Failed to save changes:', error);
      }
    },

    forceCollectAllEdits() {
      UnifiedEditor.saveAllEdits();
      return this.editedData;
    },

    // Legacy methods for backward compatibility
    makeEditableSection(element) {
      return UnifiedEditor.startEdit(element);
    },

    saveAllEdits() {
      return UnifiedEditor.saveAllEdits();
    },

    regenerateCurrentPage() {
      // Force regeneration of only the current page content (not all pages)
      if (JdrApp.modules.renderer && JdrApp.modules.renderer.regenerateCurrentPage) {
        JdrApp.modules.renderer.regenerateCurrentPage();
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - SPELL FILTER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // SPELL FILTER MODULE
  // ========================================
  const SpellFilter = {
    
    init() {
      this.setupEventListeners();
    },

    setupEventListeners() {
      // Use direct event delegation on document to catch dynamically added elements
      document.addEventListener('input', (e) => {
        if (e.target && e.target.id === 'spell-level-filter') {
          this.filterSpellsByLevel(parseInt(e.target.value, 10));
        }
      });

      document.addEventListener('click', (e) => {
        if (e.target && e.target.id === 'reset-spell-filter') {
          e.preventDefault();
          this.resetFilter();
        }
      });

      // Setup when page changes (router events)
      if (window.EventBus && window.Events) {
        EventBus.on(Events.PAGE_RENDER, (payload) => {
          if (payload.type === 'category' && payload.categoryType === 'spell') {
            // Re-setup filter after page render
            setTimeout(() => this.initializeFilter(), 200);
          }
        });
      }

      // Also listen to hash changes for direct navigation
      window.addEventListener('hashchange', () => {
        setTimeout(() => this.initializeFilter(), 200);
      });
    },

    initializeFilter() {
      const filterInput = document.querySelector('#spell-level-filter');
      if (!filterInput) return;
      
      
      // Set initial value and apply filter
      const initialValue = parseInt(filterInput.value, 10) || 20;
      this.filterSpellsByLevel(initialValue);
    },

    filterSpellsByLevel(maxLevel) {
      
      // Get current page from URL hash
      const currentHash = window.location.hash.replace('#/', '');
      
      if (!currentHash.startsWith('sorts-')) {
        return;
      }
      
      // Find all spell cards in the current page
      const spellCards = document.querySelectorAll('.card[data-spell-name]');
      
      if (spellCards.length === 0) return;

      let visibleCount = 0;

      spellCards.forEach((card) => {
        const spellName = card.dataset.spellName;
        const categoryName = card.dataset.categoryName;
        
        // Find the spell data to get its level
        const spellLevel = this.getSpellLevel(spellName, categoryName);
        
        if (spellLevel <= maxLevel) {
          card.style.display = '';
          visibleCount++;
        } else {
          card.style.display = 'none';
        }
      });

      
      // Update filter display with count
      this.updateFilterDisplay(maxLevel, visibleCount, spellCards.length);
    },

    getSpellLevel(spellName, categoryName) {
      if (!window.SORTS) return 0;

      // Find the category
      const category = window.SORTS.find(cat => cat.nom === categoryName);
      if (!category || !category.sorts) return 0;

      // Find the spell
      const spell = category.sorts.find(sort => sort.nom === spellName);
      if (!spell || !spell.prerequis) return 0;

      // Extract level from prerequisite
      const match = spell.prerequis.match(/Niveau (\d+)/i);
      return match ? parseInt(match[1], 10) : 0;
    },

    updateFilterDisplay(maxLevel, visibleCount, totalCount) {
      const filterContainer = document.querySelector('.spell-level-filter');
      if (!filterContainer) return;

      // Remove existing count display
      let countDisplay = filterContainer.querySelector('.filter-count');
      if (countDisplay) {
        countDisplay.remove();
      }

      // Add new count display
      const countText = `📊 ${visibleCount}/${totalCount} sorts affichés (niveau ≤ ${maxLevel})`;
      countDisplay = document.createElement('div');
      countDisplay.className = 'filter-count';
      countDisplay.style.cssText = 'margin-top: 0.5rem; font-size: 0.9rem; color: var(--bronze); font-weight: 500;';
      countDisplay.textContent = countText;
      
      filterContainer.appendChild(countDisplay);
    },

    resetFilter() {
      const filterInput = document.querySelector('#spell-level-filter');
      if (filterInput) {
        filterInput.value = '20';
        this.filterSpellsByLevel(20);
      }
    }
  };

  // Initialize the spell filter when the app is ready
  function initializeSpellFilter() {
    
    if (window.JdrApp) {
      if (JdrApp.modules) {
        JdrApp.modules.spellFilter = SpellFilter;
      }
    }
    
    // Initialize the filter
    SpellFilter.init();
    
    // Try to initialize the filter after a delay to ensure DOM is ready
    setTimeout(() => {
      if (window.location.hash.includes('sorts-')) {
        SpellFilter.initializeFilter();
      }
    }, 500);
  }

  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeSpellFilter);
  } else {
    // DOM is already ready
    initializeSpellFilter();
  }

  window.SpellFilter = SpellFilter;

})();
// ============================================================================
// JDR-BAB APPLICATION - UI MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // UI INTERACTIONS MODULE
  // ========================================
  JdrApp.modules.ui = {
    _initialized: false,
    
    init() {
      // Prevent multiple initialization to avoid duplicate event listeners
      if (this._initialized) {
        console.log('🚫 UI module already initialized, skipping');
        return;
      }
      
      this.setupEventListeners();
      this.setupSearch();
      this.setupModals();
      this.setupResponsive();
      this.setupNewPageHandler();
      this._initialized = true;
    },

    setupEventListeners() {
      // Content management via EventBus
      EventBus.on(Events.CONTENT_ADD, (payload) => {
        this.handleContentAdd(payload.type, payload.category, payload.item);
      });

      EventBus.on(Events.CONTENT_DELETE, (payload) => {
        this.handleContentDelete(payload.type, payload.category, payload.item);
      });

      EventBus.on(Events.CONTENT_MOVE, (payload) => {
        this.handleContentMove(payload.type, payload.category, payload.itemName, payload.direction);
      });

      // UI event handlers
      this.setupContentHandlers();
      this.setupTagsManagement();
    },

    setupContentHandlers() {
      // Generic content addition
      JdrApp.utils.events.register('click', '[class$="-add"]', (e) => {
        const type = this.extractTypeFromClass(e.target.className);
        const categoryName = e.target.dataset.categoryName;
        
        if (type && categoryName) {
          this.addContent(type, categoryName);
        }
      });

      // Generic content deletion - using multiple specific selectors
      JdrApp.utils.events.register('click', '.spell-delete, .don-delete, .delete-subclass-btn, .objet-delete, .monster-delete', (e) => {
        const type = this.extractTypeFromClass(e.target.className);
        const categoryName = e.target.dataset.categoryName;
        
        // Handle different dataset attribute naming patterns
        let itemName;
        if (type === 'spell') {
          itemName = e.target.dataset.spellName;
        } else if (type === 'don') {
          itemName = e.target.dataset.donName;
        } else if (type === 'objet') {
          itemName = e.target.dataset.objetName;
        } else if (type === 'monster') {
          itemName = e.target.dataset.monsterName;
        } else if (type === 'class') {
          itemName = e.target.dataset.className || e.target.dataset.subclassName;
        } else {
          itemName = e.target.dataset[`${type}Name`];
        }
        
        if (type && categoryName && itemName) {
          this.deleteContent(type, categoryName, itemName);
        }
      });

      // Generic content movement
      JdrApp.utils.events.register('click', '[class*="-move-"]', (e) => {
        const type = this.extractTypeFromClass(e.target.className);
        const categoryName = e.target.dataset.categoryName;
        
        // Handle different dataset attribute naming patterns
        let itemName;
        if (type === 'spell') {
          itemName = e.target.dataset.spellName;
        } else if (type === 'don') {
          itemName = e.target.dataset.donName;
        } else if (type === 'class') {
          itemName = e.target.dataset.className || e.target.dataset.subclassName;
        } else {
          itemName = e.target.dataset[`${type}Name`];
        }
        
        const direction = e.target.className.includes('move-up') ? -1 : 1;
        
        if (type && categoryName && itemName) {
          this.moveContent(type, categoryName, itemName, direction);
        }
      });

      // Filter manager button for objects
      JdrApp.utils.events.register('click', '.filter-manager-btn', () => {
        this.showFilterManagementModal();
      });

      // Tags manager button for objects
      JdrApp.utils.events.register('click', '.tags-manager-btn', () => {
        this.showTagsManagementModal();
      });

      // Filter chip toggle for objects
      JdrApp.utils.events.register('click', '.filter-chip', (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.toggleFilter(e.target);
      });

      // Select all tags button
      JdrApp.utils.events.register('click', '#select-all-tags', () => {
        this.selectAllTags();
      });

      // Select no tags button
      JdrApp.utils.events.register('click', '#select-no-tags', () => {
        this.selectNoTags();
      });

      // ID search functionality (only on Enter key or button click)
      JdrApp.utils.events.register('keydown', '#id-search-input', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          this.performIdSearch(e.target.value);
        } else if (e.key === 'Escape') {
          e.target.value = '';
          this.clearIdSearch();
        }
      });

      JdrApp.utils.events.register('click', '#clear-id-search', () => {
        this.clearIdSearch();
      });

      // Spell element change
      JdrApp.utils.events.register('change', '.spell-element-selector select', (e) => {
        this.updateSpellElement(e.target);
      });

      // Paragraph addition
      JdrApp.utils.events.register('click', '.add-paragraph-btn', (e) => {
        const target = e.target.dataset.target;
        this.addParagraph(target, e.target);
      });

      // Section deletion for static pages
      JdrApp.utils.events.register('click', '.section-delete', (e) => {
        const sectionName = e.target.dataset.sectionName;
        if (sectionName && confirm(`Supprimer la section "${sectionName}" ?`)) {
          this.deleteSection(sectionName, e.target);
        }
      });

      // Dev toolbox category creation buttons
      JdrApp.utils.events.register('click', '#addSpellCategory', () => {
        this.createNewCategory('spell');
      });

      JdrApp.utils.events.register('click', '#addDonCategory', () => {
        this.createNewCategory('don');
      });

      // Category deletion buttons
      JdrApp.utils.events.register('click', '[class$="-category-delete"]', (e) => {
        const categoryName = e.target.dataset.categoryName;
        const categoryType = e.target.dataset.categoryType;
        
        if (categoryName && categoryType) {
          this.deleteCategory(categoryType, categoryName);
        }
      });

      // Filter management for objects page
      JdrApp.utils.events.register('click', '.filter-manager-btn', (e) => {
        this.showFilterManagementModal();
      });

      // Filter chip toggling (REMOVED - duplicate listener that was causing double toggle)

      // Element selector for spells (dev mode)
      JdrApp.utils.events.register('change', '.spell-element-selector', (e) => {
        this.updateSpellElement(e.target);
      });
    },

    setupTagsManagement() {
      // Handle manage tags button clicks
      JdrApp.utils.events.register('click', '.manage-tags-btn', (e) => {
        const contentType = e.target.dataset.contentType;
        if (contentType === 'monster') {
          this.showMonsterTagsManagement();
        }
      });
    },

    showMonsterTagsManagement() {
      const config = window.ContentTypes.monster;
      if (!config || !config.filterConfig) {
        this.showNotification('Configuration des tags monstres non trouvée', 'error');
        return;
      }

      // Remove existing modal if any
      const existingModal = document.querySelector('#monsterTagsModal');
      if (existingModal) {
        existingModal.remove();
      }

      const availableTags = config.filterConfig.availableTags || [];
      const modal = this.createMonsterTagsModal(availableTags);
      document.body.appendChild(modal);
      
      // Use native dialog showModal for proper z-index
      modal.showModal();
    },

    createMonsterTagsModal(availableTags) {
      const modal = document.createElement('dialog');
      modal.id = 'monsterTagsModal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        padding: 0;
        border: none;
        border-radius: 12px;
        background: transparent;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      `;
      
      modal.innerHTML = `
        <div style="background: var(--paper); padding: 24px; border-radius: 12px; border: 3px solid var(--bronze);">
          <h3 style="margin: 0 0 16px 0; color: var(--bronze); display: flex; align-items: center; gap: 8px;">
            🏷️ Gérer les tags - Monstres
          </h3>
          <p style="margin: 0 0 20px 0; color: var(--text-muted);">
            Ajoutez, modifiez ou supprimez les tags disponibles pour le filtrage des monstres.
          </p>
          
          <div class="current-tags" style="margin-bottom: 20px;">
            <h4 style="margin: 0 0 12px 0; color: var(--bronze);">Tags actuels:</h4>
            <div class="tags-list" style="display: flex; flex-wrap: wrap; gap: 12px;">
              ${availableTags.map(tag => `
                <div class="tag-item" style="display: flex; align-items: center; background: #f5f5f5; border: 2px solid #ddd; border-radius: 8px; padding: 8px 12px;">
                  <span class="tag-name" style="margin-right: 12px; font-weight: 600; color: #333;">${tag}</span>
                  <button 
                    class="delete-monster-tag-btn" 
                    data-tag="${tag}" 
                    type="button"
                    style="background: #dc2626; color: white; border: none; padding: 6px 10px; font-size: 14px; border-radius: 4px; cursor: pointer;"
                    title="Supprimer ${tag}"
                  >🗑️</button>
                </div>
              `).join('')}
            </div>
          </div>

          <div class="add-tag-section" style="margin-bottom: 20px;">
            <h4 style="margin: 0 0 12px 0; color: var(--bronze);">Ajouter un nouveau tag:</h4>
            <div style="display: flex; gap: 8px; align-items: center;">
              <input type="text" id="new-monster-tag-input" placeholder="Nom du nouveau tag" style="flex: 1; padding: 8px 12px; border: 2px solid var(--rule); border-radius: 6px; font-size: 14px;">
              <button class="btn btn-primary" id="add-monster-tag-btn" style="padding: 8px 16px; background: var(--bronze); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">➕ Ajouter</button>
            </div>
          </div>
          
          <div style="text-align: right; padding-top: 20px; border-top: 2px solid var(--rule);">
            <button type="button" class="btn modal-close" style="padding: 8px 16px; background: var(--paper-light); border: 2px solid var(--rule); border-radius: 6px; cursor: pointer;">Fermer</button>
          </div>
        </div>
      `;

      // Setup event handlers for this modal
      this.setupMonsterTagsModalEvents(modal, availableTags);

      return modal;
    },

    setupMonsterTagsModalEvents(modal, availableTags) {
      // Close modal
      modal.querySelector('.modal-close').addEventListener('click', () => {
        modal.close();
      });

      // Add new tag
      const addBtn = modal.querySelector('#add-monster-tag-btn');
      const newTagInput = modal.querySelector('#new-monster-tag-input');
      
      const addTag = () => {
        const newTag = newTagInput.value.trim();
        if (newTag && !availableTags.includes(newTag)) {
          window.ContentTypes.monster.filterConfig.availableTags.push(newTag);
          modal.close();
          this.showMonsterTagsManagement(); // Refresh modal
          this.showNotification(`Tag "${newTag}" ajouté avec succès`, 'success');
        } else if (newTag && availableTags.includes(newTag)) {
          this.showNotification('Ce tag existe déjà', 'error');
        }
      };

      addBtn.addEventListener('click', addTag);
      newTagInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          addTag();
        }
      });

      // Delete tag buttons using event delegation
      modal.addEventListener('click', (e) => {        
        // Check if the clicked element is a delete button
        if (e.target && (e.target.classList.contains('delete-monster-tag-btn') || 
            e.target.closest('.delete-monster-tag-btn'))) {
          
          e.preventDefault();
          e.stopPropagation();
          
          // Get the button element (might be clicked on emoji inside)
          const button = e.target.classList.contains('delete-monster-tag-btn') ? 
                        e.target : e.target.closest('.delete-monster-tag-btn');
          
          const tagToDelete = button.dataset.tag;
          
          if (!tagToDelete) {
            console.error('No tag found on delete button:', button);
            this.showNotification('❌ Erreur: tag non trouvé', 'error');
            return;
          }
          
          const config = window.ContentTypes.monster;
          if (!config || !config.filterConfig || !config.filterConfig.availableTags) {
            console.error('Monster config not found or invalid');
            this.showNotification('❌ Configuration des monstres non trouvée', 'error');
            return;
          }
          
          const index = config.filterConfig.availableTags.indexOf(tagToDelete);
          
          if (index > -1) {
            // Confirm deletion
            if (confirm(`Êtes-vous sûr de vouloir supprimer le tag "${tagToDelete}" ?\n\nCela supprimera aussi ce tag de tous les monstres qui l'utilisent.`)) {
              // Remove from available tags
              config.filterConfig.availableTags.splice(index, 1);
              
              // Remove the tag from all monsters
              if (window.MONSTRES && Array.isArray(window.MONSTRES)) {
                window.MONSTRES.forEach(monster => {
                  if (monster.tags && monster.tags.includes(tagToDelete)) {
                    monster.tags = monster.tags.filter(tag => tag !== tagToDelete);
                    // Ensure monster has at least one tag if possible
                    if (monster.tags.length === 0 && config.filterConfig.availableTags.length > 0) {
                      monster.tags = [config.filterConfig.availableTags[0]];
                    }
                  }
                });
              }
              
              // Update filter state to remove deleted tag
              if (window.MONSTRES_FILTER_STATE && window.MONSTRES_FILTER_STATE.visibleTags) {
                window.MONSTRES_FILTER_STATE.visibleTags = 
                  window.MONSTRES_FILTER_STATE.visibleTags.filter(tag => tag !== tagToDelete);
                // Ensure at least one visible tag remains
                if (window.MONSTRES_FILTER_STATE.visibleTags.length === 0 && 
                    config.filterConfig.availableTags.length > 0) {
                  window.MONSTRES_FILTER_STATE.visibleTags = [config.filterConfig.availableTags[0]];
                }
              }
              
              // Save the updated availableTags in the monster data for persistence
              if (window.MONSTRES && Array.isArray(window.MONSTRES)) {
                // Store availableTags in the first monster's metadata or create a special entry
                if (!window.MONSTRES._metadata) {
                  window.MONSTRES._metadata = {};
                }
                window.MONSTRES._metadata.availableTags = [...config.filterConfig.availableTags];
              }
              
              // Save changes to storage
              EventBus.emit(Events.STORAGE_SAVE);
              
              // Refresh modal and monsters page
              modal.close();
              this.showMonsterTagsManagement();
              
              // Force complete page reload for monsters page to update filters
              const currentPage = window.location.hash.replace('#/', '');
              if (currentPage === 'monstres') {
                // Trigger router to completely rebuild the page
                setTimeout(() => {
                  if (JdrApp.modules.router && JdrApp.modules.router.show) {
                    JdrApp.modules.router.show('monstres');
                  }
                }, 100);
              }
              
              this.showNotification(`✅ Tag "${tagToDelete}" supprimé avec succès`, 'success');
            }
          } else {
            console.error(`Tag "${tagToDelete}" not found in available tags`);
            this.showNotification(`❌ Tag "${tagToDelete}" non trouvé`, 'error');
          }
        }
      });
    },

    extractTypeFromClass(className) {
      if (className.includes('spell')) return 'spell';
      if (className.includes('don')) return 'don';
      if (className.includes('class')) return 'class';
      if (className.includes('objet')) return 'objet';
      if (className.includes('monster')) return 'monster';
      return null;
    },

    deleteContent(type, categoryName, itemName) {
      if (!confirm(`Supprimer "${itemName}" ?`)) return;

      const success = ContentFactory.deleteItem(type, categoryName, itemName);
      
      if (success) {
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: type,
          category: ContentFactory.getEntity(type).findCategory(categoryName)
        });
        
        this.showNotification('🗑 Élément supprimé');
      }
    },

    moveContent(type, categoryName, itemName, direction) {
      const success = ContentFactory.moveItem(type, categoryName, itemName, direction);
      
      if (success) {
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: type,
          category: ContentFactory.getEntity(type).findCategory(categoryName)
        });
        
        const directionText = direction > 0 ? 'descendu' : 'monté';
        this.showNotification(`🔄 Élément ${directionText}`);
      }
    },

    addParagraph(target, button) {
      // Handle different types of additions based on target
      if (target === 'section') {
        this.addNewSection(button);
      } else {
        this.addParagraphToSection(target, button);
      }
    },

    addNewSection(button) {
      // Generate a unique but readable ID
      const pageId = this.getCurrentPageId();
      const sectionCount = this.countExistingSections();
      const sectionId = `${pageId}-new-${sectionCount + 1}-${Date.now()}`;
      
      const newSection = document.createElement('div');
      newSection.className = 'card editable-section';
      newSection.dataset.sectionType = 'card';
      newSection.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${sectionId}-title">Nouvelle section</h3>
            <button class="edit-btn edit-title-btn" title="Éditer le titre">✏️</button>
          </div>
        </div>
        <div style="position:relative;">
          <div class="editable" data-edit-type="generic" data-edit-section="${sectionId}">
            <p>Contenu de la nouvelle section.</p>
          </div>
          <button class="edit-btn edit-section-btn" title="Éditer cette section">✏️</button>
        </div>
        <div style="margin-top: 1rem; text-align: center;">
          <button class="section-delete btn small" data-section-name="Nouvelle section" type="button" style="background: #ff6b6b; color: white;">🗑 Supprimer section</button>
        </div>
      `;
      
      button.parentNode.insertBefore(newSection, button);
      
      // Immediately save the new section to JSON
      this.saveNewSectionToJSON(sectionId, "Nouvelle section", "<p>Contenu de la nouvelle section.</p>");
      
      // No need to recalculate indices - unique IDs prevent conflicts
      // this.recalculateSectionIndices();
      
      // Trigger persistent storage save
      this.triggerDataSave();
      
      this.showNotification('➕ Nouvelle section ajoutée et sauvegardée');
    },

    addParagraphToSection(target, button) {
      // Generate a unique but readable ID
      const pageId = this.getCurrentPageId();
      const sectionCount = this.countExistingSections();
      const paragraphId = `${pageId}-para-${sectionCount + 1}-${Date.now()}`;
      
      const container = document.createElement('div');
      container.className = 'editable-paragraph card';
      container.dataset.sectionType = 'card';
      container.style.position = 'relative';
      container.style.marginTop = '1rem';
      
      container.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${paragraphId}-title">Nouveau paragraphe</h3>
            <button class="edit-btn edit-title-btn" title="Éditer le titre">✏️</button>
          </div>
        </div>
        <div style="position:relative;">
          <div class="editable" data-edit-type="generic" data-edit-section="${paragraphId}">
            <p>Contenu du nouveau paragraphe.</p>
          </div>
          <button class="edit-btn edit-section-btn" title="Éditer cette section">✏️</button>
        </div>
        <div style="margin-top: 1rem; text-align: center;">
          <button class="section-delete btn small" data-section-name="Nouveau paragraphe" type="button" style="background: #ff6b6b; color: white;">🗑 Supprimer section</button>
        </div>
      `;
      
      button.parentNode.insertBefore(container, button);
      
      // Immediately save the new paragraph as a section to JSON
      this.saveNewSectionToJSON(paragraphId, "Nouveau paragraphe", "<p>Contenu du nouveau paragraphe.</p>");
      
      // No need to recalculate indices - unique IDs prevent conflicts
      // this.recalculateSectionIndices();
      
      // Trigger persistent storage save
      this.triggerDataSave();
      
      this.showNotification('➕ Paragraphe ajouté et sauvegardé');
    },

    deleteSection(sectionName, button) {
      // Find and remove the section
      const section = button.closest('.card');
      if (section) {
        // Extract the section ID from the editable elements
        const editableElement = section.querySelector('[data-edit-section]');
        let sectionId = null;
        if (editableElement) {
          sectionId = editableElement.dataset.editSection;
          // Remove "-title" suffix if present to get base ID
          if (sectionId.endsWith('-title')) {
            sectionId = sectionId.replace('-title', '');
          }
        }
        
        section.remove();
        
        // Save the deletion to JSON
        if (sectionId) {
          this.deleteSectionFromJSON(sectionId);
        }
        
        // Recalculate all section indices after deletion
        this.recalculateSectionIndices();
        
        // Trigger persistent storage save
        this.triggerDataSave();
        
        this.showNotification(`🗑️ Section "${sectionName}" supprimée et mise à jour JSON`);
      }
    },

    // ========================================
    // CONTENT MANIPULATION METHODS 
    // ========================================
    
    addContent(type, categoryName) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`❌ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Create new item with default values
      const defaultItem = ContentFactory.createDefaultItem(type);
      
      // Special handling for objects and monsters (add to single array)
      if (type === 'objet') {
        if (!window.OBJETS.objets) {
          window.OBJETS.objets = [];
        }
        
        // Get next number
        const existingNumbers = window.OBJETS.objets.map(obj => obj.numero || 0);
        const nextNumber = existingNumbers.length > 0 ? Math.max(...existingNumbers) + 1 : 1;
        defaultItem.numero = nextNumber;
        
        window.OBJETS.objets.push(defaultItem);
        this.refreshObjectsPage();
      } else if (type === 'monster') {
        if (!window.MONSTRES) {
          window.MONSTRES = [];
        }
        
        window.MONSTRES.push(defaultItem);
        this.refreshMonstersPage();
      } else {
        // Standard category-based addition
        const success = ContentFactory.addItem(type, categoryName, defaultItem);
        if (success) {
          EventBus.emit(Events.CONTENT_ADD, {
            type: type,
            category: categoryName,
            item: defaultItem
          });
          
          EventBus.emit(Events.PAGE_RENDER, {
            type: 'category',
            categoryType: type,
            category: ContentFactory.getEntity(type).findCategory(categoryName)
          });
        }
      }
      
      EventBus.emit(Events.STORAGE_SAVE);
      this.showNotification(`${config.icons.add} Nouvel élément ajouté`, 'success');
    },

    deleteContent(type, categoryName, itemName) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`❌ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      if (!confirm(`Supprimer "${itemName}" ?`)) {
        return;
      }

      // Special handling for objects and monsters
      if (type === 'objet') {
        if (window.OBJETS?.objets) {
          const itemIndex = window.OBJETS.objets.findIndex(obj => obj.nom === itemName);
          if (itemIndex >= 0) {
            window.OBJETS.objets.splice(itemIndex, 1);
            this.refreshObjectsPage();
          }
        }
      } else if (type === 'monster') {
        if (window.MONSTRES) {
          const itemIndex = window.MONSTRES.findIndex(monster => monster.nom === itemName);
          if (itemIndex >= 0) {
            window.MONSTRES.splice(itemIndex, 1);
            this.refreshMonstersPage();
          }
        }
      } else {
        // Standard category-based deletion
        const success = ContentFactory.deleteItem(type, categoryName, itemName);
        if (success) {
          EventBus.emit(Events.CONTENT_DELETE, {
            type: type,
            category: categoryName,
            item: itemName
          });
          
          EventBus.emit(Events.PAGE_RENDER, {
            type: 'category',
            categoryType: type,
            category: ContentFactory.getEntity(type).findCategory(categoryName)
          });
        }
      }
      
      EventBus.emit(Events.STORAGE_SAVE);
      this.showNotification(`${config.icons.delete} "${itemName}" supprimé`, 'success');
    },

    moveContent(type, categoryName, itemName, direction) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`❌ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Special handling for objects
      if (type === 'objet') {
        if (window.OBJETS?.objets) {
          const itemIndex = window.OBJETS.objets.findIndex(obj => obj.nom === itemName);
          if (itemIndex >= 0) {
            const newIndex = itemIndex + direction;
            if (newIndex >= 0 && newIndex < window.OBJETS.objets.length) {
              const item = window.OBJETS.objets.splice(itemIndex, 1)[0];
              window.OBJETS.objets.splice(newIndex, 0, item);
              this.refreshObjectsPage();
            }
          }
        }
      } else {
        // Standard category-based movement
        const success = ContentFactory.moveItem(type, categoryName, itemName, direction);
        if (success) {
          EventBus.emit(Events.CONTENT_MOVE, {
            type: type,
            category: categoryName,
            itemName: itemName,
            direction: direction
          });
          
          EventBus.emit(Events.PAGE_RENDER, {
            type: 'category',
            categoryType: type,
            category: ContentFactory.getEntity(type).findCategory(categoryName)
          });
        }
      }
      
      EventBus.emit(Events.STORAGE_SAVE);
      const directionText = direction > 0 ? 'descendu' : 'monté';
      this.showNotification(`🔄 "${itemName}" ${directionText}`, 'success');
    },

    handleContentAdd(type, category, item) {
      // Additional handling after content is added
      setTimeout(() => {
        if (JdrApp.modules.renderer?.autoLoadImages) {
          JdrApp.modules.renderer.autoLoadImages();
        }
      }, 100);
    },

    handleContentDelete(type, category, item) {
      // Cleanup after content deletion
    },

    handleContentMove(type, category, itemName, direction) {
      // Additional handling after content is moved
    },

    setupSearch() {
      const searchInput = JdrApp.utils.dom.$('#search');
      const clearButton = JdrApp.utils.dom.$('#clear');
      let searchTimeout;
      
      if (searchInput) {
        // Only search on Enter key press
        JdrApp.utils.events.register('keydown', '#search', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            const query = e.target.value.trim();
            if (query.length > 0) {
              this.performSearch(query);
            } else {
              this.clearMainSearchResults();
            }
          } else if (e.key === 'Escape') {
            this.clearMainSearchResults();
            e.target.value = '';
            e.target.blur();
          }
        });
      }
      
      if (clearButton) {
        JdrApp.utils.events.register('click', '#clear', () => {
          if (searchInput) {
            searchInput.value = '';
            this.clearMainSearchResults();
          }
        });
      }

      // Remove click outside handler since we're not using dropdown anymore
      // JdrApp.utils.events.register('click', 'body', (e) => {
      //   if (!e.target.closest('.searchbar') && !e.target.closest('#search-results')) {
      //     this.hideSearchResults();
      //   }
      // });

      // Remove EventBus listener that may cause issues
      // EventBus.on(Events.SEARCH_PERFORM, (payload) => {
      //   this.performSearch(payload.query);
      // });
    },

    performSearch(query) {
      const normalizedQuery = query.toLowerCase().trim();
      
      if (!normalizedQuery) {
        this.showAllContent();
        this.clearMainSearchResults();
        return;
      }

      // Search without minimum character limit since user has to press Enter
      const results = this.searchInData(normalizedQuery);
      this.displaySearchResultsInMain(results, normalizedQuery);
      
      // Keep existing TOC search for compatibility
      this.searchInTOC(normalizedQuery);
    },

    searchInData(query) {
      const results = [];
      
      // Search in SORTS
      if (window.SORTS) {
        window.SORTS.forEach(category => {
          if (category.sorts) {
            category.sorts.forEach(sort => {
              if (this.matchesSearch(sort, query)) {
                const url = `#/sorts-${JdrApp.utils.data.sanitizeId(category.nom)}`;
                
                results.push({
                  type: 'spell',
                  category: category.nom,
                  item: sort,
                  url: url,
                  summary: this.generateSpellSummary(sort)
                });
              }
            });
          }
        });
      }

      // Search in DONS
      if (window.DONS) {
        window.DONS.forEach(category => {
          if (category.dons) {
            category.dons.forEach(don => {
              if (this.matchesSearch(don, query)) {
                results.push({
                  type: 'don',
                  category: category.nom,
                  item: don,
                  url: `#/dons-${JdrApp.utils.data.sanitizeId(category.nom)}`,
                  summary: this.generateDonSummary(don)
                });
              }
            });
          }
        });
      }

      // Search in CLASSES
      if (window.CLASSES) {
        window.CLASSES.forEach(classe => {
          if (this.matchesSearch(classe, query)) {
            results.push({
              type: 'class',
              category: null,
              item: classe,
              url: `#/${JdrApp.utils.data.sanitizeId(classe.nom)}`,
              summary: this.generateClassSummary(classe)
            });
          }
          
          // Search in subclasses
          if (classe.sousClasses) {
            classe.sousClasses.forEach(sousClasse => {
              if (this.matchesSearch(sousClasse, query)) {
                results.push({
                  type: 'subclass',
                  category: classe.nom,
                  item: sousClasse,
                  url: `#/${JdrApp.utils.data.sanitizeId(classe.nom)}`,
                  summary: this.generateSubclassSummary(sousClasse, classe.nom)
                });
              }
            });
          }
        });
      }

      // Search in static pages
      this.searchInStaticPages(query, results);
      
      return results.slice(0, 10); // Limit to 10 results
    },

    searchInStaticPages(query, results) {
      // Search in static pages data
      if (window.STATIC_PAGES) {
        Object.keys(window.STATIC_PAGES).forEach(pageId => {
          const pageData = window.STATIC_PAGES[pageId];
          if (this.matchesStaticPage(pageData, query)) {
            results.push({
              type: 'staticPage',
              category: null,
              item: pageData,
              url: `#/${pageId}`,
              summary: this.generateStaticPageSummary(pageData)
            });
          }
        });
      }

      // Also search in static page config if available
      if (window.STATIC_PAGE_CONFIG?.pages) {
        window.STATIC_PAGE_CONFIG.pages.forEach(pageConfig => {
          if (pageConfig.active && this.matchesPageConfig(pageConfig, query)) {
            // Only add if we haven't already found this page
            const alreadyExists = results.some(r => 
              r.type === 'staticPage' && r.url === `#/${pageConfig.id}`
            );
            
            if (!alreadyExists) {
              results.push({
                type: 'staticPage',
                category: null,
                item: { 
                  title: pageConfig.title, 
                  page: pageConfig.id,
                  description: `Page sur ${pageConfig.title.toLowerCase()}`
                },
                url: `#/${pageConfig.id}`,
                summary: this.generatePageConfigSummary(pageConfig)
              });
            }
          }
        });
      }
    },

    matchesStaticPage(pageData, query) {
      const searchText = [
        pageData.title || '',
        pageData.page || '',
        this.extractStaticPageContent(pageData.sections || [])
      ].join(' ').toLowerCase();
      
      return searchText.includes(query);
    },

    matchesPageConfig(pageConfig, query) {
      const searchText = [
        pageConfig.title || '',
        pageConfig.id || ''
      ].join(' ').toLowerCase();
      
      return searchText.includes(query);
    },

    extractStaticPageContent(sections) {
      return sections.map(section => {
        let content = '';
        if (section.content) {
          if (typeof section.content === 'string') {
            content += section.content;
          } else if (section.content.content) {
            // New HTML format: extract text from HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = section.content.content;
            content += tempDiv.textContent || tempDiv.innerText || '';
          } else if (section.content.items && Array.isArray(section.content.items)) {
            // Legacy format
            content += section.content.items.join(' ');
          }
        }
        return content;
      }).join(' ');
    },

    matchesSearch(item, query) {
      // Fonction pour nettoyer le HTML et extraire le texte
      const stripHtml = (text) => {
        if (!text) return '';
        if (typeof text !== 'string') text = String(text);
        return text.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
      };

      // Fonction pour traiter les listes/arrays
      const processArray = (arr) => {
        if (!arr) return '';
        if (Array.isArray(arr)) {
          return arr.map(item => stripHtml(item)).join(' ');
        }
        return stripHtml(arr);
      };

      // Collecter TOUS les champs textuels possibles
      const searchFields = [
        // Champs communs
        item.nom,
        item.description,
        item.prerequis,
        item.resume,
        
        // Champs spécifiques aux sorts
        item.element,
        item.portee,
        item.tempsIncantation,
        item.coutMana,
        item.resistance,
        item.effetNormal,
        item.effetCritique,
        
        // Champs spécifiques aux dons
        item.cout,
        
        // Champs spécifiques aux classes/sous-classes
        item.progression,
        processArray(item.capacites),
        
        // Champs spécifiques aux objets
        item.effet,
        item.prix,
        item.poids,
        item.tags ? item.tags.join(' ') : '',
        
        // Champs de statistiques (si c'est un objet)
        item.base ? Object.entries(item.base || {}).map(([key, value]) => `${key} ${value}`).join(' ') : '',
        
        // Autres champs possibles
        item.title,
        item.content,
        item.type
      ];

      // Joindre tous les champs et nettoyer
      const searchText = searchFields
        .filter(field => field !== null && field !== undefined)
        .map(field => stripHtml(field))
        .join(' ')
        .toLowerCase();
      
      // Chercher chaque mot de la requête
      const queryWords = query.toLowerCase().split(/\s+/).filter(word => word.length > 0);
      
      // Tous les mots doivent être trouvés (recherche ET logique)
      return queryWords.every(word => searchText.includes(word));
    },

    generateSpellSummary(spell) {
      // Strip HTML tags from fields to avoid breaking template
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `🔮 ${stripHtml(spell.nom)} - ${stripHtml(spell.prerequis || 'Aucun prérequis')} | ${stripHtml(spell.coutMana || 'Coût inconnu')}`;
    },

    generateDonSummary(don) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `🏆 ${stripHtml(don.nom)} - ${stripHtml(don.prerequis || 'Aucun prérequis')} | ${stripHtml(don.cout || 'Coût inconnu')}`;
    },

    generateClassSummary(classe) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `⚔️ ${stripHtml(classe.nom)} - ${stripHtml(classe.resume || 'Classe de combat')}`;
    },

    generateSubclassSummary(sousClasse, parentClass) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `⚡ ${stripHtml(sousClasse.nom)} (${stripHtml(parentClass)}) - Sous-classe spécialisée`;
    },

    generateStaticPageSummary(pageData) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `📄 ${stripHtml(pageData.title)} - ${stripHtml(pageData.description || 'Page d\'information du jeu')}`;
    },

    generatePageConfigSummary(pageConfig) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `📄 ${stripHtml(pageConfig.title)} - Guide et informations sur ${stripHtml(pageConfig.title.toLowerCase())}`;
    },

    slugify(text) {
      return text.toLowerCase()
        .replace(/[àáâãäå]/g, 'a')
        .replace(/[èéêë]/g, 'e')
        .replace(/[ìíîï]/g, 'i')
        .replace(/[òóôõö]/g, 'o')
        .replace(/[ùúûü]/g, 'u')
        .replace(/[ç]/g, 'c')
        .replace(/[^a-z0-9]/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '');
    },

    showAllContent() {
      JdrApp.utils.dom.$('article, .toc a').forEach(el => {
        el.style.display = '';
      });
    },

    displaySearchResultsInMain(results, query) {
      const main = document.querySelector('main');
      if (!main) return;

      // Create search results page content
      const searchPageHTML = this.generateSearchResultsPage(results, query);
      
      // Replace main content with search results
      main.innerHTML = searchPageHTML;
      
      // Quick debug to see card dimensions
      setTimeout(() => {
        const cards = main.querySelectorAll('.search-result-card');
        console.log('Cards found:', cards.length);
        cards.forEach((card, i) => {
          console.log(`Card ${i+1} dimensions:`, {
            height: card.offsetHeight,
            width: card.offsetWidth,
            display: getComputedStyle(card).display,
            visibility: getComputedStyle(card).visibility
          });
        });
      }, 100);
      
      // Setup click handlers for results
      this.setupMainSearchHandlers();
      
      // Also setup direct handlers as fallback
      this.setupDirectHandlers();
    },

    generateSearchResultsPage(results, query) {
      if (results.length === 0) {
        return `
          <div class="search-page">
            <div class="search-page-header">
              <h1>🔍 Recherche: "${query}"</h1>
              <p class="search-no-results">Aucun résultat trouvé</p>
              <button class="btn small" onclick="JdrApp.modules.ui.clearMainSearchResults()">
                ← Retour au sommaire
              </button>
            </div>
          </div>
        `;
      }
      
      let resultsHTML = '';
      
      try {
        resultsHTML = results.map((result, index) => {
          const itemName = result.item.nom || result.item.title || 'Sans nom';
          
          
          // Generate preview safely
          let preview;
          try {
            preview = this.generatePreview(result.item, result.type);
          } catch (previewError) {
            console.error('Preview error:', previewError);
            preview = '<div class="preview-field">Erreur dans l\'aperçu</div>';
          }
          
          // Escape potentially problematic text
          const escapeAttr = (text) => {
            if (!text) return '';
            return String(text).replace(/"/g, '&quot;');
          };
          
          const escapeText = (text) => {
            if (!text) return '';
            return String(text)
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;');
          };

          const cardHTML = `
            <article class="search-result-card" data-url="${result.url}">
              <div class="search-result-header">
                <h3>${this.getTypeIcon(result.type)} ${itemName}</h3>
                <div class="search-result-type">${this.getTypeName(result.type)}</div>
              </div>
              <div class="search-result-content">
                <div class="search-result-summary">${escapeText(result.summary || 'Pas de résumé')}</div>
                ${result.category ? `<div class="search-result-category">📂 Catégorie: ${escapeText(result.category)}</div>` : ''}
                <div class="search-result-preview">
                  ${preview}
                </div>
              </div>
              <div class="search-result-footer">
                <button class="btn small search-result-btn" data-url="${result.url}">
                  Voir la page →
                </button>
              </div>
            </article>
          `;
          
          return cardHTML;
        }).join('');
      } catch (error) {
        console.error('Error generating results HTML:', error);
        resultsHTML = '<div class="error">Erreur lors de la génération des résultats</div>';
      }

      const finalHTML = `
        <div class="search-page">
          <div class="search-page-header">
            <h1>🔍 Recherche: "${query}"</h1>
            <p class="search-results-count">${results.length} résultat${results.length > 1 ? 's' : ''} trouvé${results.length > 1 ? 's' : ''}</p>
            <button class="btn small" onclick="JdrApp.modules.ui.clearMainSearchResults()">
              ← Retour au sommaire
            </button>
          </div>
          <div class="search-results-grid">
            ${resultsHTML}
          </div>
        </div>
      `;
      
      return finalHTML;
    },

    getTypeIcon(type) {
      const icons = {
        'spell': '🔮',
        'don': '🏆', 
        'class': '⚔️',
        'subclass': '⚡',
        'staticPage': '📄'
      };
      return icons[type] || '📄';
    },

    getTypeName(type) {
      const names = {
        'spell': 'Sort',
        'don': 'Don',
        'class': 'Classe',
        'subclass': 'Sous-classe',
        'staticPage': 'Page'
      };
      return names[type] || 'Contenu';
    },

    generatePreview(item, type) {
      // Strip all HTML and clean text completely
      const cleanText = (text) => {
        if (!text) return '';
        return String(text)
          .replace(/<[^>]*>/g, '') // Remove HTML tags
          .replace(/&[^;]+;/g, ' ') // Remove HTML entities
          .replace(/\s+/g, ' ') // Normalize whitespace
          .trim()
          .substring(0, 100); // Limit length
      };

      switch (type) {
        case 'spell':
          const desc = cleanText(item.description || 'Non spécifiée');
          const portee = cleanText(item.portee || 'Non spécifiée');
          return `<div class="preview-field">Description: ${desc}</div><div class="preview-field">Portée: ${portee}</div>`;
          
        case 'don':
          const donDesc = cleanText(item.description || 'Non spécifiée');
          return `<div class="preview-field">Description: ${donDesc}</div>`;
          
        case 'class':
          const resume = cleanText(item.resume || 'Non spécifié');
          return `<div class="preview-field">Résumé: ${resume}</div>`;
          
        case 'subclass':
          const progression = cleanText(item.progression || 'Non spécifiée');
          return `<div class="preview-field">Progression: ${progression}</div>`;
          
        case 'staticPage':
          const content = this.extractStaticPageContent(item.sections || []);
          const preview = cleanText(content || 'Page d\'information');
          return `<div class="preview-field">Contenu: ${preview}</div>`;
          
        default:
          return '<div class="preview-field">Aperçu non disponible</div>';
      }
    },

    setupMainSearchHandlers() {
      // Handle click on entire card
      JdrApp.utils.events.register('click', '.search-result-card', (e) => {
        console.log('Card clicked, currentTarget:', e.currentTarget);
        if (e.target.closest('.search-result-btn')) return; // Let button handle it
        
        const url = e.currentTarget ? e.currentTarget.dataset.url : null;
        console.log('Card URL:', url);
        
        if (url && url !== '#test') {
          console.log('Navigating to:', url);
          window.location.hash = url;
          // Force page reload to trigger router
          window.location.reload();
        } else {
          console.warn('No valid URL found on card');
        }
      });

      // Handle button clicks
      JdrApp.utils.events.register('click', '.search-result-btn', (e) => {
        console.log('Button clicked, target:', e.target);
        e.stopPropagation();
        
        const url = e.target ? e.target.dataset.url : null;
        console.log('Button URL:', url);
        
        if (url && url !== '#test') {
          console.log('Navigating to:', url);
          window.location.hash = url;
          // Force page reload to trigger router
          window.location.reload();
        } else {
          console.warn('No valid URL found on button');
        }
      });
    },

    setupDirectHandlers() {
      // Direct event listeners on the elements themselves
      setTimeout(() => {
        const cards = document.querySelectorAll('.search-result-card');
        const buttons = document.querySelectorAll('.search-result-btn');
        
        console.log('Setting up direct handlers for', cards.length, 'cards and', buttons.length, 'buttons');
        
        cards.forEach((card, index) => {
          const url = card.dataset.url;
          console.log(`Card ${index + 1} URL:`, url);
          
          card.addEventListener('click', (e) => {
            if (e.target.closest('.search-result-btn')) return;
            console.log('Direct card click, URL:', url);
            if (url && url !== '#test') {
              window.location.hash = url;
              window.location.reload();
            }
          });
        });
        
        buttons.forEach((button, index) => {
          const url = button.dataset.url;
          console.log(`Button ${index + 1} URL:`, url);
          
          button.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log('Direct button click, URL:', url);
            if (url && url !== '#test') {
              window.location.hash = url;
              window.location.reload();
            }
          });
        });
      }, 200);
    },

    clearMainSearchResults() {
      // Reload the current page or go back to homepage
      if (window.location.hash && window.location.hash !== '#/') {
        window.location.reload();
      } else {
        window.location.hash = '#/creation';
      }
    },

    searchInTOC(query) {
      JdrApp.utils.dom.$('.toc a').forEach(link => {
        const text = link.textContent.toLowerCase();
        const isMatch = text.includes(query);
        link.style.display = isMatch ? '' : 'none';
        
        if (isMatch) {
          const category = link.closest('.toc-category');
          if (category) {
            category.classList.remove('collapsed');
          }
        }
      });
    },

    searchInContent(query) {
      JdrApp.utils.dom.$('article').forEach(article => {
        const text = article.textContent.toLowerCase();
        const isMatch = text.includes(query);
        
        if (isMatch) {
          this.highlightSearchTerms(article, query);
        }
      });
    },

    highlightSearchTerms(container, query) {
      const walker = document.createTreeWalker(
        container,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );

      const textNodes = [];
      let node;
      while (node = walker.nextNode()) {
        if (node.textContent.toLowerCase().includes(query)) {
          textNodes.push(node);
        }
      }

      textNodes.forEach(textNode => {
        const regex = new RegExp(`(${query})`, 'gi');
        const content = textNode.textContent;
        
        if (regex.test(content)) {
          const highlightedContent = content.replace(regex, '<mark>$1</mark>');
          const wrapper = document.createElement('span');
          wrapper.innerHTML = highlightedContent;
          textNode.parentNode.replaceChild(wrapper, textNode);
        }
      });
    },

    setupModals() {
      JdrApp.utils.events.register('click', '.modal-overlay, .modal-close', (e) => {
        const modal = e.target.closest('.modal') || document.querySelector('.modal.visible');
        if (modal) {
          this.closeModal(modal);
        }
      });

      JdrApp.utils.events.register('click', '.modal-content', (e) => {
        e.stopPropagation();
      });

      JdrApp.utils.events.register('keydown', 'body', (e) => {
        if (e.key === 'Escape') {
          const openModal = document.querySelector('.modal.visible');
          if (openModal) {
            this.closeModal(openModal);
          }
        }
      });

      // Resource tools
      JdrApp.utils.events.register('click', '#elementsBtn', () => {
        this.showElementsModal();
      });

      JdrApp.utils.events.register('click', '#etatsBtn', () => {
        this.showEtatsModal();
      });

      JdrApp.utils.events.register('click', '#spellLinksBtn', () => {
        this.showSpellLinksModal();
      });

      // Gestionnaire pour les liens de sorts dans le contenu
      JdrApp.utils.events.register('click', '.spell-link', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const spellName = e.target.dataset.spell;
        const categoryName = e.target.dataset.category;
        this.showSpellPreview(spellName, categoryName, e.target);
      });

      // Gestionnaire pour les liens d'états dans le contenu
      JdrApp.utils.events.register('click', '.etat-link', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const etatName = e.target.dataset.etat;
        
        // Récupérer dynamiquement la description depuis les données statiques
        let etatDescription = '';
        if (window.STATIC_PAGES?.etats?.sections) {
          const etatSection = window.STATIC_PAGES.etats.sections.find(section => 
            section.type === 'card' && section.title === etatName
          );
          if (etatSection) {
            // Convertir le HTML en texte propre
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = etatSection.content;
            tempDiv.innerHTML = tempDiv.innerHTML
              .replace(/<\/p>/gi, '\n')
              .replace(/<br\s*\/?>/gi, '\n')
              .replace(/<\/li>/gi, '\n')
              .replace(/<\/div>/gi, '\n');
            etatDescription = (tempDiv.textContent || tempDiv.innerText || etatSection.content)
              .replace(/\n\s*\n/g, '\n')
              .trim();
          }
        }
        
        this.showEtatPreview(etatName, etatDescription, e.target);
      });

      EventBus.on(Events.MODAL_OPEN, (payload) => {
        this.openModal(payload.modalId);
      });

      EventBus.on(Events.MODAL_CLOSE, (payload) => {
        const modal = payload.modal || document.querySelector('.modal.visible');
        if (modal) {
          this.closeModal(modal);
        }
      });
    },

    openModal(modalId) {
      const modal = JdrApp.utils.dom.$(`#${modalId}`);
      if (modal) {
        if (modal.tagName === 'DIALOG') {
          modal.showModal();
        } else {
          modal.classList.add('visible');
          modal.style.display = 'flex';
        }
        
        const firstInput = modal.querySelector('input, textarea, select');
        if (firstInput) {
          firstInput.focus();
        }
      }
    },

    closeModal(modal) {
      if (modal) {
        modal.classList.remove('visible');
        modal.style.display = 'none';
        
        const form = modal.querySelector('form');
        if (form) {
          form.reset();
        }
      }
    },

    showElementsModal() {
      let modal = JdrApp.utils.dom.$('#elementsModal');
      if (!modal) {
        modal = this.createElementsModal();
        document.body.appendChild(modal);
      }
      
      this.openModal('elementsModal');
    },

    createElementsModal() {
      const elements = Object.entries(window.ElementColors).map(([name, config]) => ({
        name,
        color: config.color,
        icon: this.getElementIcon(name)
      }));

      const elementsHTML = elements.map(element => `
        <div class="element-item" data-element="${element.name}" data-color="${element.color}">
          <div class="element-icon" style="background: ${element.color};">${element.icon}</div>
          <div class="element-name">${element.name}</div>
          <div class="copy-indicator">Copié!</div>
        </div>
      `).join('');

      const modal = JdrApp.utils.dom.create('div', 'modal elements-modal', `
        <div class="modal-content elements-modal-content">
          <div style="position: relative;">
            <button class="modal-close-x" style="position: absolute; top: 0; right: 0; background: none; border: none; font-size: 20px; cursor: pointer; color: var(--paper-muted); padding: 4px 8px; border-radius: 4px; transition: all 0.2s ease;" onmouseover="this.style.background='var(--rule)'; this.style.color='var(--accent-ink)';" onmouseout="this.style.background='none'; this.style.color='var(--paper-muted)';">×</button>
            <h3>🎨 Éléments</h3>
          </div>
          <p>Cliquez sur un élément pour copier sa balise HTML colorée.</p>
          <div class="elements-list">
            ${elementsHTML}
          </div>
          <button class="modal-close btn">Fermer</button>
        </div>
      `, { id: 'elementsModal' });

      modal.addEventListener('click', (e) => {
        const elementItem = e.target.closest('.element-item');
        if (elementItem) {
          const elementName = elementItem.dataset.element;
          
          // Get the full style configuration from ElementColors
          const style = window.ElementColors[elementName];
          if (style) {
            // Build the complete style string
            let styleString = `color: ${style.color}; font-weight: ${style.weight || 'bold'};`;
            if (style.background) styleString += ` background: ${style.background};`;
            if (style.padding) styleString += ` padding: ${style.padding};`;
            if (style.borderRadius) styleString += ` border-radius: ${style.borderRadius};`;
            
            const html = `<span style="${styleString}">${elementName}</span>`;
            this.copyToClipboard(html);
          } else {
            // Fallback for elements not found
            const html = `<span style="color: ${elementItem.dataset.color}; font-weight: bold;">${elementName}</span>`;
            this.copyToClipboard(html);
          }
          
          elementItem.classList.add('copied');
          
          // Fermer la modale après un court délai pour voir l'effet "Copié!"
          setTimeout(() => {
            this.closeModal(modal);
          }, 500);
        }
      });

      // Gestionnaire pour le bouton X de fermeture
      const closeBtn = modal.querySelector('.modal-close-x');
      if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.closeModal(modal);
        });
      }

      return modal;
    },

    getElementIcon(elementName) {
      const icons = {
        'Feu': '🔥',
        'Air': '💨',
        'Eau': '💧',
        'Terre': '🌍',
        'Divin': '✨',
        'Lumière': '☀️',
        'Maléfique': '💀'
      };
      return icons[elementName] || '⚡';
    },

    showEtatsModal() {
      // TOUJOURS recréer la modal pour avoir les données à jour
      let modal = JdrApp.utils.dom.$('#etatsModal');
      if (modal) {
        document.body.removeChild(modal);
      }
      
      modal = this.createEtatsModal();
      document.body.appendChild(modal);
      
      this.openModal('etatsModal');
    },

    createEtatsModal() {
      // Récupérer les données d'états depuis window.STATIC_PAGES.etats
      const etatsData = window.STATIC_PAGES?.etats;
      const etats = [];
      
      if (etatsData?.sections) {
        etatsData.sections.forEach(section => {
          if (section.type === 'card' && section.title && section.content) {
            // Convertir le HTML en texte en préservant les sauts de ligne
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = section.content;
            
            // Remplacer les balises de saut de ligne par des \n avant d'extraire le texte
            tempDiv.innerHTML = tempDiv.innerHTML
              .replace(/<\/p>/gi, '\n')
              .replace(/<br\s*\/?>/gi, '\n')
              .replace(/<\/li>/gi, '\n')
              .replace(/<\/div>/gi, '\n');
            
            const description = (tempDiv.textContent || tempDiv.innerText || section.content)
              .replace(/\n\s*\n/g, '\n') // Supprimer les doubles sauts de ligne
              .trim();
            
            etats.push({
              name: section.title,
              description: description
            });
          }
        });
      }

      const etatsHTML = etats.map(etat => `
        <div class="etat-item" data-etat-name="${etat.name}" data-etat-description="${etat.description}">
          <div class="etat-icon">⚡</div>
          <div class="etat-content">
            <div class="etat-name">${etat.name}</div>
            <div class="etat-description">${etat.description.length > 60 ? etat.description.substring(0, 60) + '...' : etat.description}</div>
          </div>
          <div class="copy-indicator">Copié!</div>
        </div>
      `).join('');

      const modal = JdrApp.utils.dom.create('div', 'modal etats-modal', `
        <div class="modal-content etats-modal-content">
          <div style="position: relative;">
            <button class="modal-close-x" style="position: absolute; top: 0; right: 0; background: none; border: none; font-size: 20px; cursor: pointer; color: var(--paper-muted); padding: 4px 8px; border-radius: 4px; transition: all 0.2s ease;" onmouseover="this.style.background='var(--rule)'; this.style.color='var(--accent-ink)';" onmouseout="this.style.background='none'; this.style.color='var(--paper-muted)';">×</button>
            <h3>⚡ États</h3>
          </div>
          <p>Cliquez sur un état pour copier un lien avec prévisualisation dans le presse-papiers.</p>
          <div class="etats-list">
            ${etatsHTML || '<div style="text-align: center; color: #666; padding: 2rem;">Aucun état trouvé</div>'}
          </div>
          <button class="modal-close btn">Fermer</button>
        </div>
      `, { id: 'etatsModal' });

      modal.addEventListener('click', (e) => {
        const etatItem = e.target.closest('.etat-item');
        if (etatItem) {
          const etatName = etatItem.dataset.etatName;
          const etatDescription = etatItem.dataset.etatDescription;
          
          // Créer un lien cliquable simple avec prévisualisation (description récupérée dynamiquement)
          const etatLink = `<span class="etat-link" data-etat="${etatName}" style="color: #ea7332; cursor: pointer; text-decoration: underline;">${etatName}</span>`;
          
          // Toujours copier dans le presse-papiers
          this.copyToClipboard(etatLink);
          
          etatItem.classList.add('copied');
          
          // Fermer la modale après un court délai pour voir l'effet "Copié!"
          setTimeout(() => {
            this.closeModal(modal);
          }, 500);
        }
      });

      // Gestionnaire pour le bouton X de fermeture
      const closeBtn = modal.querySelector('.modal-close-x');
      if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.closeModal(modal);
        });
      }

      return modal;
    },

    showSpellLinksModal() {
      let modal = JdrApp.utils.dom.$('#spellLinksModal');
      if (modal) {
        document.body.removeChild(modal);
      }
      
      modal = this.createSpellLinksModal();
      document.body.appendChild(modal);

      
      this.openModal('spellLinksModal');
    },

    createSpellLinksModal() {
      // Récupérer tous les sorts depuis window.SORTS
      const spells = [];
      
      if (window.SORTS && Array.isArray(window.SORTS)) {
        window.SORTS.forEach(category => {
          if (category.sorts && Array.isArray(category.sorts)) {
            category.sorts.forEach(spell => {
              spells.push({
                name: spell.nom,
                category: category.nom,
                element: spell.element,
                description: spell.description || ''
              });
            });
          }
        });
      }

      const spellsHTML = spells.map(spell => `
        <div class="spell-item" data-spell-name="${spell.name}" data-spell-category="${spell.category}">
          <div class="spell-info">
            <div class="spell-name" style="color: ${this.getElementColor(spell.element)}; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">${spell.name}</div>
            <span data-spell-meta style="color: ${this.getElementColor(spell.element)} !important; font-size: 12px; margin-bottom: 6px; display: block;">${this.getElementIcon(spell.element)} ${spell.element} • ${spell.category}</span>
            <div class="spell-description">${spell.description.length > 80 ? spell.description.substring(0, 80) + '...' : spell.description}</div>
          </div>
          <div class="copy-indicator">Copié!</div>
        </div>
      `).join('');

      const modal = JdrApp.utils.dom.create('div', 'modal spell-links-modal', `
        <div class="modal-content spell-links-modal-content">
          <div style="position: relative;">
            <button class="modal-close-x" style="position: absolute; top: 0; right: 0; background: none; border: none; font-size: 20px; cursor: pointer; color: var(--paper-muted); padding: 4px 8px; border-radius: 4px; transition: all 0.2s ease;" onmouseover="this.style.background='var(--rule)'; this.style.color='var(--accent-ink)';" onmouseout="this.style.background='none'; this.style.color='var(--paper-muted)';">×</button>
            <h3>🔮 Liens vers les sorts</h3>
          </div>
          <p>Cliquez sur un sort pour copier un lien avec aperçu interactif.</p>
          <div class="spells-search">
            <input type="text" id="spellSearchInput" placeholder="Rechercher un sort..." style="width: 100%; padding: 8px; margin-bottom: 12px; border: 1px solid var(--rule); border-radius: 4px;">
          </div>
          <div class="spells-list" style="max-height: 400px; overflow-y: auto;">
            ${spellsHTML || '<div style="text-align: center; color: #666; padding: 2rem;">Aucun sort trouvé</div>'}
          </div>
          <button class="modal-close btn">Fermer</button>
        </div>
      `, { id: 'spellLinksModal' });

      // Recherche dans la modal
      const searchInput = modal.querySelector('#spellSearchInput');
      if (searchInput) {
        searchInput.addEventListener('input', (e) => {
          const searchTerm = e.target.value.toLowerCase();
          const spellItems = modal.querySelectorAll('.spell-item');
          
          spellItems.forEach(item => {
            const spellName = item.querySelector('.spell-name').textContent.toLowerCase();
            const spellCategory = item.querySelector('.spell-meta').textContent.toLowerCase();
            
            if (spellName.includes(searchTerm) || spellCategory.includes(searchTerm)) {
              item.style.display = '';
            } else {
              item.style.display = 'none';
            }
          });
        });
      }

      // Clic sur un sort
      modal.addEventListener('click', (e) => {
        const spellItem = e.target.closest('.spell-item');
        if (spellItem) {
          const spellName = spellItem.dataset.spellName;
          const spellCategory = spellItem.dataset.spellCategory;
          
          // Créer le lien HTML avec les attributs nécessaires
          const spellLink = `<span class="spell-link" data-spell="${spellName}" data-category="${spellCategory}" style="color: var(--accent); cursor: pointer; text-decoration: underline;">${spellName}</span>`;
          
          this.copyToClipboard(spellLink);
          
          spellItem.classList.add('copied');
          
          // Fermer la modale après un court délai pour voir l'effet "Copié!"
          setTimeout(() => {
            this.closeModal(modal);
          }, 500);
        }
      });

      // Gestionnaire pour le bouton X de fermeture
      const closeBtn = modal.querySelector('.modal-close-x');
      if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.closeModal(modal);
        });
      }

      return modal;
    },

    getElementColor(element) {
      // Couleurs optimisées pour la lisibilité sur fond clair et foncé
      const colorMap = {
        'Feu': '#e25822',        // Rouge-orange vif
        'Eau': '#2563eb',        // Bleu vif
        'Terre': '#92400e',      // Marron foncé
        'Air': '#059669',        // Vert émeraude
        'Lumière': '#d97706',    // Orange doré (au lieu du jaune pâle)
        'Nuit': '#6b21a8',       // Violet foncé (au lieu du noir)
        'Divin': '#7c2d12',      // Marron doré (au lieu du blanc)
        'Maléfique': '#7c3aed'   // Violet intense
      };
      
      return colorMap[element] || '#666666';
    },

    getElementIcon(element) {
      const icons = window.ElementIcons || {};
      return icons[element] || '⚡';
    },

    showSpellPreview(spellName, categoryName, triggerElement) {
      // Trouver le sort dans les données
      let spellData = null;
      
      if (window.SORTS && Array.isArray(window.SORTS)) {
        for (const category of window.SORTS) {
          if (category.nom === categoryName && category.sorts) {
            spellData = category.sorts.find(spell => spell.nom === spellName);
            if (spellData) break;
          }
        }
      }

      if (!spellData) {
        this.showNotification(`❌ Sort "${spellName}" non trouvé`, 'error');
        return;
      }

      // Fermer toute preview existante
      const existingPreview = document.querySelector('.spell-preview-popup');
      if (existingPreview) {
        existingPreview.remove();
      }

      // Calculer la position de la popup
      const rect = triggerElement.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      
      // Créer la popup de preview
      const popup = document.createElement('div');
      popup.className = 'spell-preview-popup';
      
      const elementColor = this.getElementColor(spellData.element);
      
      popup.innerHTML = `
        <div class="spell-preview-content">
          <div class="spell-preview-header" style="border-left: 4px solid ${elementColor};">
            <div class="spell-title" style="color: ${elementColor}; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">${spellData.nom}</div>
            <span data-element-display style="color: ${elementColor} !important; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">${this.getElementIcon(spellData.element)} ${spellData.element} • ${categoryName}</span>
            <button class="spell-preview-close">✕</button>
          </div>
          <div class="spell-preview-body">
            ${spellData.description ? `<div class="spell-description">${spellData.description}</div>` : ''}
            ${spellData.prerequis ? `<div class="spell-field">${spellData.prerequis}</div>` : ''}
            ${spellData.portee ? `<div class="spell-field">${spellData.portee}</div>` : ''}
            ${spellData.tempsIncantation ? `<div class="spell-field">${spellData.tempsIncantation}</div>` : ''}
            ${spellData.coutMana ? `<div class="spell-field">${spellData.coutMana}</div>` : ''}
            ${spellData.resistance ? `<div class="spell-field">${spellData.resistance}</div>` : ''}
            ${spellData.effetNormal ? `<div class="spell-field">${spellData.effetNormal}</div>` : ''}
            ${spellData.effetCritique ? `<div class="spell-field">${spellData.effetCritique}</div>` : ''}
          </div>
        </div>
      `;

      // Styles de la popup
      popup.style.cssText = `
        position: fixed;
        z-index: 10000;
        background: var(--card);
        border: 2px solid ${elementColor};
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        max-width: 400px;
        max-height: 500px;
        overflow-y: auto;
        font-family: 'Roboto', sans-serif;
        line-height: 1.4;
      `;

      document.body.appendChild(popup);

      // FORCE les couleurs avec JavaScript après ajout au DOM
      setTimeout(() => {
        const elementDisplay = popup.querySelector('[data-element-display]');
        if (elementDisplay) {
          elementDisplay.style.setProperty('color', elementColor, 'important');
        }
      }, 10);

      // Positionner la popup
      const popupRect = popup.getBoundingClientRect();
      let left = rect.left + rect.width / 2 - popupRect.width / 2;
      let top = rect.bottom + 8;

      // Ajustements si la popup sort de l'écran
      if (left < 8) left = 8;
      if (left + popupRect.width > viewportWidth - 8) left = viewportWidth - popupRect.width - 8;
      if (top + popupRect.height > viewportHeight - 8) top = rect.top - popupRect.height - 8;
      if (top < 8) top = 8;

      popup.style.left = `${left}px`;
      popup.style.top = `${top}px`;

      // Gestionnaires d'événements
      popup.querySelector('.spell-preview-close').addEventListener('click', () => {
        popup.remove();
      });

      // Fermer en cliquant à l'extérieur
      const handleOutsideClick = (e) => {
        if (!popup.contains(e.target) && e.target !== triggerElement) {
          popup.remove();
          document.removeEventListener('click', handleOutsideClick);
        }
      };
      
      setTimeout(() => {
        document.addEventListener('click', handleOutsideClick);
      }, 100);

      // Fermer avec Escape
      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          popup.remove();
          document.removeEventListener('keydown', handleEscape);
        }
      };
      document.addEventListener('keydown', handleEscape);
    },

    showEtatPreview(etatName, etatDescription, triggerElement) {
      // Fermer toute preview existante
      const existingPreview = document.querySelector('.etat-preview-popup');
      if (existingPreview) {
        existingPreview.remove();
      }

      // Calculer la position de la popup
      const rect = triggerElement.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      
      // Créer la popup de preview
      const popup = document.createElement('div');
      popup.className = 'etat-preview-popup';
      
      popup.innerHTML = `
        <div class="etat-preview-content">
          <div class="etat-preview-header">
            <div class="etat-title">⚡ ${etatName}</div>
            <button class="etat-preview-close">✕</button>
          </div>
          <div class="etat-preview-body">
            <div class="etat-description">${etatDescription}</div>
          </div>
        </div>
      `;

      // Styles de la popup
      popup.style.cssText = `
        position: fixed;
        z-index: 10000;
        background: var(--card);
        border: 2px solid #7c2d12;
        border-radius: 12px;
        box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        max-width: 300px;
        padding: 1rem;
        font-size: 14px;
        line-height: 1.4;
        color: var(--paper-ink);
        pointer-events: auto;
      `;

      document.body.appendChild(popup);

      // Positionner la popup
      setTimeout(() => {
        const popupRect = popup.getBoundingClientRect();
        let left = rect.left + rect.width / 2 - popupRect.width / 2;
        let top = rect.bottom + 8;

        // Ajustements si la popup sort de l'écran
        if (left < 8) left = 8;
        if (left + popupRect.width > viewportWidth - 8) left = viewportWidth - popupRect.width - 8;
        if (top + popupRect.height > viewportHeight - 8) top = rect.top - popupRect.height - 8;
        if (top < 8) top = 8;

        popup.style.left = `${left}px`;
        popup.style.top = `${top}px`;
      }, 10);

      // Gestionnaires d'événements
      popup.querySelector('.etat-preview-close').addEventListener('click', () => {
        popup.remove();
      });

      // Fermer en cliquant à l'extérieur
      const handleOutsideClick = (e) => {
        if (!popup.contains(e.target) && e.target !== triggerElement) {
          popup.remove();
          document.removeEventListener('click', handleOutsideClick);
        }
      };
      
      setTimeout(() => {
        document.addEventListener('click', handleOutsideClick);
      }, 100);

      // Fermer avec Escape
      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          popup.remove();
          document.removeEventListener('keydown', handleEscape);
        }
      };
      document.addEventListener('keydown', handleEscape);
    },

    copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        this.showNotification('📋 Copié dans le presse-papiers', 'success');
      }).catch(() => {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        this.showNotification('📋 Copié dans le presse-papiers', 'success');
      });
    },

    setupResponsive() {
      this.setupMobileNavigation();
      this.setupLegacyResponsive();
    },

    setupMobileNavigation() {
      // Create mobile navigation toggle button immediately and on resize
      this.createMobileNavToggle();
      
      // Handle mobile nav toggle with delegation
      document.addEventListener('click', (e) => {
        if (e.target.closest('.mobile-nav-toggle')) {
          e.preventDefault();
          this.toggleMobileNav();
        }
      });

      // Auto-close navigation when selecting a page
      document.addEventListener('click', (e) => {
        if (e.target.closest('.toc a') && window.innerWidth <= 980) {
          this.closeMobileNav();
        }
      });

      // Handle window resize
      window.addEventListener('resize', () => {
        if (window.innerWidth <= 980) {
          this.createMobileNavToggle();
        } else {
          this.closeMobileNav();
          const existingButton = document.querySelector('.mobile-nav-toggle');
          if (existingButton) {
            existingButton.remove();
          }
        }
      });
      
      // Also create on DOM content loaded
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          this.createMobileNavToggle();
        });
      }
    },

    createMobileNavToggle() {
      // Only create if it doesn't exist and we're on mobile
      if (window.innerWidth <= 980 && !document.querySelector('.mobile-nav-toggle')) {
        const toggleButton = document.createElement('button');
        toggleButton.className = 'mobile-nav-toggle';
        toggleButton.innerHTML = `
          <span class="icon">📜</span>
          <span class="text">Menu</span>
        `;
        toggleButton.setAttribute('aria-label', 'Ouvrir/fermer le menu de navigation');
        toggleButton.setAttribute('title', 'Navigation');
        toggleButton.type = 'button';
        
        // Insert at the beginning of body
        if (document.body) {
          document.body.insertBefore(toggleButton, document.body.firstChild);
        }
      }
    },

    toggleMobileNav() {
      const sidebar = document.querySelector('.sidebar');
      const toggleButton = document.querySelector('.mobile-nav-toggle');
      
      if (sidebar && toggleButton) {
        const isOpen = sidebar.classList.contains('mobile-open');
        
        if (isOpen) {
          this.closeMobileNav();
        } else {
          this.openMobileNav();
        }
      }
    },

    openMobileNav() {
      const sidebar = document.querySelector('.sidebar');
      const toggleButton = document.querySelector('.mobile-nav-toggle');
      
      if (sidebar && toggleButton) {
        sidebar.classList.add('mobile-open');
        toggleButton.classList.add('open');
        
        const textSpan = toggleButton.querySelector('.text');
        if (textSpan) {
          textSpan.textContent = 'Fermer';
        }
        
        // Add event listener to close on outside click
        setTimeout(() => {
          document.addEventListener('click', this.handleOutsideClick);
        }, 100);
      }
    },

    closeMobileNav() {
      const sidebar = document.querySelector('.sidebar');
      const toggleButton = document.querySelector('.mobile-nav-toggle');
      
      if (sidebar && toggleButton) {
        sidebar.classList.remove('mobile-open');
        toggleButton.classList.remove('open');
        
        const textSpan = toggleButton.querySelector('.text');
        if (textSpan) {
          textSpan.textContent = 'Menu';
        }
        
        // Remove outside click listener
        document.removeEventListener('click', this.handleOutsideClick);
      }
    },

    handleOutsideClick: (e) => {
      const sidebar = document.querySelector('.sidebar');
      const toggleButton = document.querySelector('.mobile-nav-toggle');
      
      // Close if clicking outside sidebar and toggle button
      if (sidebar && toggleButton && 
          !sidebar.contains(e.target) && 
          !toggleButton.contains(e.target)) {
        JdrApp.modules.ui.closeMobileNav();
      }
    },

    setupLegacyResponsive() {
      // Keep existing responsive handlers for compatibility
      JdrApp.utils.events.register('click', '#menuToggle', () => {
        const sidebar = JdrApp.utils.dom.$('#sidebar');
        const backdrop = JdrApp.utils.dom.$('#backdrop');
        
        if (sidebar && backdrop) {
          sidebar.classList.toggle('mobile-open');
          backdrop.hidden = !sidebar.classList.contains('mobile-open');
        }
      });

      JdrApp.utils.events.register('click', '#backdrop', () => {
        const sidebar = JdrApp.utils.dom.$('#sidebar');
        const backdrop = JdrApp.utils.dom.$('#backdrop');
        
        if (sidebar && backdrop) {
          sidebar.classList.remove('mobile-open');
          backdrop.hidden = true;
        }
      });
    },

    showNotification(message, type = 'info') {
      EventBus.emit(Events.NOTIFICATION_SHOW, { message, type });
      
      // Fallback notification if storage module is not available
      if (!JdrApp.modules.storage?.showNotification) {
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: ${type === 'success' ? '#10B981' : type === 'error' ? '#EF4444' : '#3B82F6'};
          color: white;
          padding: 12px 16px;
          border-radius: 8px;
          font-weight: 500;
          z-index: 10000;
          animation: slideIn 0.3s ease;
        `;
        
        notification.textContent = message;
        document.body.appendChild(notification);
        
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 3000);
      } else {
        JdrApp.modules.storage.showNotification(message, type);
      }
    },

    // Get current page ID from DOM
    getCurrentPageId() {
      // Find the currently visible article (not hidden)
      const articles = document.querySelectorAll('article[data-static-page="true"]');
      let visibleArticle = null;
      
      for (const article of articles) {
        const style = window.getComputedStyle(article);
        if (style.display !== 'none' && style.visibility !== 'hidden') {
          visibleArticle = article;
          break;
        }
      }
      
      // Fallback: find by active class or current hash
      if (!visibleArticle) {
        const hash = window.location.hash.replace('#/', '');
        if (hash) {
          visibleArticle = document.querySelector(`article[data-page="${hash}"]`);
        }
      }
      
      // Last fallback: any visible article
      if (!visibleArticle) {
        visibleArticle = document.querySelector('article[data-static-page="true"]:not([style*="display: none"])');
      }
      
      const pageId = visibleArticle ? visibleArticle.dataset.page : null;
      console.log('🔍 DEBUG getCurrentPageId: Found visible article:', !!visibleArticle);
      console.log('🔍 DEBUG getCurrentPageId: Page ID:', pageId);
      if (visibleArticle) {
        console.log('🔍 DEBUG getCurrentPageId: Article attributes:', {
          'data-static-page': visibleArticle.dataset.staticPage,
          'data-page': visibleArticle.dataset.page,
          'data-page-title': visibleArticle.dataset.pageTitle
        });
      }
      return pageId;
    },

    // Count existing sections for unique ID generation
    countExistingSections() {
      const pageId = this.getCurrentPageId();
      if (!pageId || !window.STATIC_PAGES || !window.STATIC_PAGES[pageId]) {
        return 0;
      }
      const pageData = window.STATIC_PAGES[pageId];
      return pageData.sections ? pageData.sections.length : 0;
    },

    // Save new section to JSON data
    saveNewSectionToJSON(sectionId, title, content) {
      const pageId = this.getCurrentPageId();
      console.log('🔍 DEBUG SAVE: getCurrentPageId() returned:', pageId);
      console.log('🔍 DEBUG SAVE: Available pages in STATIC_PAGES:', Object.keys(window.STATIC_PAGES || {}));
      
      if (!pageId || !window.STATIC_PAGES || !window.STATIC_PAGES[pageId]) {
        console.warn('Cannot save new section - page not found:', pageId);
        console.warn('window.STATIC_PAGES exists:', !!window.STATIC_PAGES);
        console.warn('pageId exists in STATIC_PAGES:', pageId && window.STATIC_PAGES && !!window.STATIC_PAGES[pageId]);
        return false;
      }

      const pageData = window.STATIC_PAGES[pageId];
      
      // Create new section object
      const newSection = {
        type: "card",
        id: sectionId,
        title: title,
        content: content,
        deletable: true,
        sectionName: title
      };

      // Add to sections array
      if (!pageData.sections) {
        pageData.sections = [];
      }
      
      pageData.sections.push(newSection);
      
      return true;
    },

    // Delete section from JSON data
    deleteSectionFromJSON(sectionId) {
      const pageId = this.getCurrentPageId();
      if (!pageId || !window.STATIC_PAGES || !window.STATIC_PAGES[pageId]) {
        console.warn('Cannot delete section - page not found:', pageId);
        return false;
      }

      const pageData = window.STATIC_PAGES[pageId];
      if (!pageData.sections) {
        console.warn('No sections found in page data');
        return false;
      }

      console.log(`🗑️ SUPPRESSION JSON: Tentative de suppression "${sectionId}" de ${pageId}.json`);
      console.log('📊 État JSON avant suppression:', {
        pageId,
        totalSections: pageData.sections.length,
        sectionIds: pageData.sections.map(s => s.id)
      });

      // Remove section by ID
      const initialLength = pageData.sections.length;
      pageData.sections = pageData.sections.filter(section => section.id !== sectionId);
      
      // Check if section was found and removed
      const removed = pageData.sections.length < initialLength;
      if (removed) {
        console.log(`✅ SUPPRESSION JSON: Section "${sectionId}" supprimée de ${pageId}.json`);
        console.log('📊 État JSON après suppression:', {
          pageId,
          totalSections: pageData.sections.length,
          sectionIds: pageData.sections.map(s => s.id)
        });
        return true;
      } else {
        // Try to find in nested grid content
        for (let section of pageData.sections) {
          if (section.type === 'grid' && section.content) {
            const gridInitialLength = section.content.length;
            section.content = section.content.filter(item => item.id !== sectionId);
            if (section.content.length < gridInitialLength) {
              console.log(`✅ SUPPRESSION JSON: Section "${sectionId}" supprimée de grille dans ${pageId}.json`);
              return true;
            }
          }
        }
        
        console.error(`❌ ERREUR: Section "${sectionId}" introuvable pour suppression`);
        console.log('🔍 Sections disponibles:', pageData.sections.map(s => ({id: s.id, title: s.title})));
        return false;
      }
    },

    // Recalculate all section indices in the current page to prevent conflicts
    recalculateSectionIndices() {
      // Disable index recalculation for now - it causes ID mismatches
      // The current approach of using timestamp-based unique IDs is more stable
      console.log('Index recalculation disabled - using stable unique IDs');
      return true;
    },

    // OLD VERSION - kept for reference but disabled
    _recalculateSectionIndicesOld() {
      const pageId = this.getCurrentPageId();
      if (!pageId) {
        console.warn('Cannot recalculate indices - no current page');
        return false;
      }

      // Update DOM data-edit-section attributes to match JSON structure
      const article = document.querySelector('article[data-static-page="true"]');
      if (!article) {
        console.warn('No static page article found');
        return false;
      }

      // Get the JSON data for this page
      const pageData = window.STATIC_PAGES?.[pageId];
      if (!pageData?.sections) {
        console.warn('No page data found for recalculation');
        return false;
      }

      // Build a mapping of DOM sections to JSON sections
      const sections = article.querySelectorAll('.editable-section, .card');
      let sectionIndex = 0;

      sections.forEach((domSection, domIndex) => {
        // Skip sections that don't have editable content
        const editableElements = domSection.querySelectorAll('[data-edit-section]');
        if (editableElements.length === 0) return;

        // Find corresponding JSON section
        let jsonSection = null;
        let jsonIndex = sectionIndex;

        // Try to match by existing ID first
        const firstEditable = editableElements[0];
        let currentId = firstEditable.dataset.editSection;
        if (currentId.endsWith('-title')) {
          currentId = currentId.replace('-title', '');
        }

        // Look for matching JSON section
        for (let i = 0; i < pageData.sections.length; i++) {
          const section = pageData.sections[i];
          if (section.id === currentId || section.type === 'intro') {
            jsonSection = section;
            jsonIndex = i;
            break;
          }
        }

        // If no match found, assign next available index
        if (!jsonSection && sectionIndex < pageData.sections.length) {
          jsonSection = pageData.sections[sectionIndex];
          jsonIndex = sectionIndex;
        }

        if (jsonSection) {
          // Update DOM attributes to match JSON structure
          editableElements.forEach(editable => {
            const currentEditSection = editable.dataset.editSection;
            
            // Determine the new ID based on JSON section
            let newEditSection;
            if (currentEditSection.endsWith('-title')) {
              newEditSection = `${jsonSection.id}-title`;
            } else {
              newEditSection = jsonSection.id;
            }

            // Update the data attribute
            editable.dataset.editSection = newEditSection;
            
            console.log(`Updated section ${domIndex}: ${currentEditSection} → ${newEditSection}`);
          });

          sectionIndex++;
        }
      });

      // Also update section indices in JSON to ensure consistency
      pageData.sections.forEach((section, index) => {
        // Ensure each section has a proper ID
        if (!section.id || section.id.startsWith('section-')) {
          // Generate a stable ID based on title or position
          const baseId = section.title ? 
            section.title.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '') :
            `section-${index}`;
          section.id = baseId;
        }
      });

      console.log(`Recalculated indices for ${sectionIndex} sections in page ${pageId}`);
      return true;
    },

    // Trigger data save to localStorage/persistent storage
    triggerDataSave() {
      // Data is already saved in window.STATIC_PAGES in memory
    },

    createNewCategory(type) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`❌ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Demander le nom de la catégorie
      const categoryName = prompt(`Nom de la nouvelle catégorie de ${config.container} :`);
      if (!categoryName || !categoryName.trim()) {
        return;
      }

      const trimmedName = categoryName.trim();

      // Vérifier que la catégorie n'existe pas déjà
      const entity = ContentFactory.getEntity(type);
      if (entity && entity.findCategory(trimmedName)) {
        this.showNotification(`❌ Une catégorie "${trimmedName}" existe déjà`, 'error');
        return;
      }

      // Demander la description et spoilAlert pour les objets
      let description = prompt(`Description de la catégorie "${trimmedName}" :`);
      if (!description) description = '';

      let spoilAlert = false;
      if (type === 'objet') {
        spoilAlert = confirm('Cette catégorie contient-elle des éléments de spoil ?');
      }

      // Créer la nouvelle catégorie
      const newCategory = {
        nom: trimmedName,
        description: description.trim(),
        [config.identifiers.category]: []
      };

      // Ajouter spoilAlert pour les objets
      if (type === 'objet') {
        newCategory.spoilAlert = spoilAlert;
      }

      // Ajouter à la structure de données
      const dataKey = config.dataKey;
      if (!window[dataKey]) {
        window[dataKey] = [];
      }

      window[dataKey].push(newCategory);

      // Rafraîchir ContentFactory
      ContentFactory.refreshData();

      // Rafraîchir le router TOC
      if (JdrApp.modules.router && JdrApp.modules.router.generateTOC) {
        JdrApp.modules.router.generateTOC();
      }

      // Naviguer vers la nouvelle catégorie
      const categoryRoute = `${config.container}-${JdrApp.utils.data.sanitizeId(trimmedName)}`;
      JdrApp.modules.router.navigate(categoryRoute);

      this.showNotification(`${config.icons.category} Catégorie "${trimmedName}" créée avec succès!`, 'success');
    },

    deleteCategory(type, categoryName) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`❌ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Confirmation avec détails
      const entity = ContentFactory.getEntity(type);
      const category = entity?.findCategory(categoryName);
      
      if (!category) {
        this.showNotification(`❌ Catégorie "${categoryName}" introuvable`, 'error');
        return;
      }

      const itemsProperty = this.getItemsProperty(type);
      const itemCount = category[itemsProperty]?.length || 0;
      
      const confirmMessage = itemCount > 0 
        ? `Supprimer la catégorie "${categoryName}" et ses ${itemCount} éléments ?`
        : `Supprimer la catégorie vide "${categoryName}" ?`;
        
      if (!confirm(confirmMessage)) {
        return;
      }

      // Supprimer de la structure de données
      const dataKey = config.dataKey;
      if (window[dataKey]) {
        const categoryIndex = window[dataKey].findIndex(cat => cat.nom === categoryName);
        
        if (categoryIndex >= 0) {
          window[dataKey].splice(categoryIndex, 1);
          
          // Rafraîchir ContentFactory
          ContentFactory.refreshData();

          // Rafraîchir le router TOC
          if (JdrApp.modules.router && JdrApp.modules.router.generateTOC) {
            JdrApp.modules.router.generateTOC();
          }

          // Naviguer vers la page principale du type
          JdrApp.modules.router.navigate(config.container);

          this.showNotification(`${config.icons.delete} Catégorie "${categoryName}" supprimée`, 'success');
        } else {
          this.showNotification(`❌ Erreur lors de la suppression`, 'error');
        }
      }
    },

    getItemsProperty(type) {
      switch (type) {
        case 'spell': return 'sorts';
        case 'don': return 'dons';
        case 'objet': return 'objets';
        case 'class': return 'sousClasses';
        default: return 'items';
      }
    },

    // ==== FILTER MANAGEMENT METHODS ====

    showFilterManagementModal() {
      if (!window.OBJETS || !window.ContentTypes.objet) return;
      
      const config = window.ContentTypes.objet.filterConfig;
      const currentSettings = window.OBJETS.filterSettings || { visibleTags: config.defaultVisibleTags };
      
      // Remove existing modal if any
      const existingModal = document.querySelector('#filterModal');
      if (existingModal) {
        existingModal.remove();
      }
      
      const modal = this.createFilterModal();
      document.body.appendChild(modal);
      
      // Update modal content with current settings
      this.updateFilterModalContent(modal, config, currentSettings);
      
      // Use native dialog showModal for proper z-index
      modal.showModal();
    },

    createFilterModal() {
      const modal = document.createElement('dialog');
      modal.id = 'filterModal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        padding: 0;
        border: none;
        border-radius: 12px;
        background: transparent;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      `;
      modal.innerHTML = `
        <div style="background: var(--paper); border-radius: 12px; padding: 1.5rem; border: 2px solid var(--rule);">
          <h3 style="margin: 0 0 1rem 0; color: var(--accent-ink);">Gestion des filtres d'objets</h3>
          <p style="margin: 0 0 1rem 0; color: var(--paper-muted);">Choisissez quels tags d'objets afficher sur la page :</p>
          <div id="filterCheckboxes" style="margin: 1rem 0;">
            <!-- Content will be populated by updateFilterModalContent -->
          </div>
          <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem;">
            <button class="btn" id="resetFiltersBtn" style="background: var(--bronze); color: white;">
              🔄 Réinitialiser
            </button>
            <button class="btn" id="saveFiltersBtn" style="background: var(--accent); color: white;">
              💾 Sauvegarder
            </button>
            <button class="btn modal-close" style="background: #666; color: white;">
              ❌ Annuler
            </button>
          </div>
        </div>
      `;

      // Add event listeners
      modal.addEventListener('click', (e) => {
        if (e.target.id === 'saveFiltersBtn') {
          this.saveFilterSettings(modal);
        } else if (e.target.id === 'resetFiltersBtn') {
          this.resetFilterSettings(modal);
        } else if (e.target.classList.contains('modal-close')) {
          modal.close();
          modal.remove();
        } else if (e.target.classList.contains('move-tag-up')) {
          this.moveTagInModal(modal, e.target.dataset.tag, -1);
        } else if (e.target.classList.contains('move-tag-down')) {
          this.moveTagInModal(modal, e.target.dataset.tag, 1);
        }
      });

      // Handle dialog close events
      modal.addEventListener('cancel', () => {
        modal.close();
        modal.remove();
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.close();
          modal.remove();
        }
      });

      return modal;
    },

    updateFilterModalContent(modal, config, currentSettings) {
      const checkboxContainer = modal.querySelector('#filterCheckboxes');
      if (!checkboxContainer) return;

      const checkboxHTML = config.availableTags.map(tag => {
        const isVisible = currentSettings.displayedFilterButtons ? currentSettings.displayedFilterButtons.includes(tag) : currentSettings.visibleTags.includes(tag);
        const isDefault = config.defaultVisibleTags.includes(tag);
        
        return `
          <div class="tag-row" data-tag="${tag}" style="display: flex; align-items: center; gap: 0.5rem; margin: 0.5rem 0; padding: 0.5rem; background: var(--card); border-radius: 8px;">
            <input 
              type="checkbox" 
              id="filter-${tag}" 
              value="${tag}" 
              ${isVisible ? 'checked' : ''}
              style="margin: 0;"
            >
            <label for="filter-${tag}" style="flex: 1; cursor: pointer; font-weight: 500;">
              <span class="tag-chip" style="margin-right: 0.5rem;">${tag}</span>
              ${tag}
            </label>
            <input 
              type="checkbox" 
              id="default-${tag}" 
              value="${tag}" 
              ${isDefault ? 'checked' : ''}
              style="margin: 0;"
              title="Filtre par défaut au chargement du site"
            >
            <div style="display: flex; flex-direction: column; gap: 2px;">
              <button type="button" class="move-tag-up" data-tag="${tag}" style="background: #ff8c00; color: white; border: none; border-radius: 3px; padding: 2px 6px; font-size: 12px; cursor: pointer;" title="Monter dans l'ordre">↑</button>
              <button type="button" class="move-tag-down" data-tag="${tag}" style="background: #ff8c00; color: white; border: none; border-radius: 3px; padding: 2px 6px; font-size: 12px; cursor: pointer;" title="Descendre dans l'ordre">↓</button>
            </div>
          </div>
        `;
      }).join('');

      checkboxContainer.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 0.5rem; border-bottom: 1px solid var(--rule);">
          <span style="font-weight: 600; color: var(--accent-ink);">Tag visible</span>
          <span style="font-weight: 600; color: var(--accent-ink);">Défaut</span>
        </div>
        <div id="sortable-tags-list">
          ${checkboxHTML}
        </div>
        <div style="margin-top: 1rem; padding-top: 0.5rem; border-top: 1px solid var(--rule); font-size: 0.85em; color: var(--paper-muted);">
          ℹ️ <strong>Visible</strong> : Tags affichés actuellement<br>
          🏠 <strong>Par défaut</strong> : Tags automatiquement activés au chargement du site<br>
          ↕️ <strong>Ordre</strong> : Utilisez les flèches pour réorganiser l'affichage
        </div>
      `;
    },

    saveFilterSettings(modal) {
      // Get visible tags (currently active)
      const visibleCheckboxes = modal.querySelectorAll('input[id^="filter-"]:checked');
      const visibleTags = Array.from(visibleCheckboxes).map(cb => cb.value);

      // Get default tags (active by default on site load)
      const defaultCheckboxes = modal.querySelectorAll('input[id^="default-"]:checked');
      const defaultTags = Array.from(defaultCheckboxes).map(cb => cb.value);

      if (visibleTags.length === 0) {
        this.showNotification('❌ Veuillez sélectionner au moins un tag visible', 'error');
        return;
      }

      if (defaultTags.length === 0) {
        this.showNotification('❌ Veuillez sélectionner au moins un tag par défaut', 'error');
        return;
      }

      // Update displayed filter buttons and current visible tags in OBJETS
      if (!window.OBJETS.filterSettings) {
        window.OBJETS.filterSettings = {};
      }
      window.OBJETS.filterSettings.displayedFilterButtons = visibleTags;
      // Set active filters to default tags only (not all displayed buttons)
      window.OBJETS.filterSettings.visibleTags = [...defaultTags];

      // Update default tags in ContentTypes configuration
      // Note: availableTags order has already been updated by moveTagInModal()
      if (window.ContentTypes.objet?.filterConfig) {
        window.ContentTypes.objet.filterConfig.defaultVisibleTags = defaultTags;
      }

      // Trigger page re-render
      this.refreshObjectsPage();
      
      // Save to storage (will include the updated order and defaultVisibleTags in export)
      EventBus.emit(Events.STORAGE_SAVE);
      
      // Close modal and show notification
      modal.close();
      modal.remove();
      this.showNotification(`🏷️ Filtres mis à jour : ${visibleTags.length} visible(s), ${defaultTags.length} par défaut`, 'success');
    },

    resetFilterSettings(modal) {
      const config = window.ContentTypes.objet.filterConfig;
      const defaultSettings = { visibleTags: config.defaultVisibleTags };
      
      this.updateFilterModalContent(modal, config, defaultSettings);
      this.showNotification('🔄 Filtres réinitialisés aux valeurs par défaut', 'info');
    },

    moveTagInModal(modal, tagName, direction) {
      // Get current configuration
      const config = window.ContentTypes.objet.filterConfig;
      const currentIndex = config.availableTags.indexOf(tagName);
      
      if (currentIndex === -1) return; // Tag not found
      
      const newIndex = currentIndex + direction;
      
      // Check bounds
      if (newIndex < 0 || newIndex >= config.availableTags.length) return;
      
      // Swap tags in the array
      const temp = config.availableTags[currentIndex];
      config.availableTags[currentIndex] = config.availableTags[newIndex];
      config.availableTags[newIndex] = temp;
      
      // Refresh the modal display
      const currentSettings = window.OBJETS?.filterSettings || { visibleTags: config.defaultVisibleTags };
      this.updateFilterModalContent(modal, config, currentSettings);
      
      this.showNotification(`📊 "${tagName}" ${direction > 0 ? 'descendu' : 'monté'} dans l'ordre`, 'info');
    },


    refreshObjectsPage() {
      // Check if we're currently on the objects page
      if (window.location.hash === '#/objets' || window.location.hash === '#/objet') {
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: 'objet',
          category: window.OBJETS
        });
      }
    },

    refreshMonstersPage() {
      // Check if we're currently on the monsters page
      if (window.location.hash === '#/monstres' || window.location.hash === '#/monstre') {
        // Use the router to refresh the monsters page
        if (JdrApp.modules.router && JdrApp.modules.router.renderMonstersPage) {
          JdrApp.modules.router.renderMonstersPage();
        }
      }
    },

    // ==== SPELL ELEMENT MANAGEMENT ====

    updateSpellElement(selectElement) {
      // Get the selected element
      const newElement = selectElement.value;
      const spellName = selectElement.dataset.spellName;
      const categoryName = selectElement.dataset.categoryName;

      if (!newElement || !spellName || !categoryName) {
        this.showNotification('❌ Erreur : données du sort manquantes', 'error');
        return;
      }

      // Find and update the spell data
      const spellEntity = ContentFactory.getEntity('spell');
      const category = spellEntity?.findCategory(categoryName);
      
      if (!category) {
        this.showNotification(`❌ Catégorie "${categoryName}" introuvable`, 'error');
        return;
      }

      const spell = category.sorts?.find(s => s.nom === spellName);
      if (!spell) {
        this.showNotification(`❌ Sort "${spellName}" introuvable`, 'error');
        return;
      }

      // Update the spell element
      spell.element = newElement;

      // Save the changes to storage
      EventBus.emit(Events.STORAGE_SAVE);

      // Update the visual display
      const spellCard = selectElement.closest('.card');
      if (spellCard) {
        const elementDisplay = spellCard.querySelector('.spell-element-selector').parentNode;
        if (elementDisplay) {
          // Find the icon and colors for the new element
          const icon = window.ElementIcons ? window.ElementIcons[newElement] : '🔥';
          const colors = window.ElementColors ? window.ElementColors[newElement] : { color: '#ff6b35', weight: 'bold' };
          
          // Build style string
          let style = `color: ${colors.color}; font-weight: ${colors.weight};`;
          if (colors.background) style += ` background: ${colors.background};`;
          if (colors.padding) style += ` padding: ${colors.padding};`;
          if (colors.borderRadius) style += ` border-radius: ${colors.borderRadius};`;
          
          // Update the dropdown options to reflect the selection
          const options = Object.keys(window.ElementIcons || {});
          const optionsHTML = options.map(elem => 
            `<option value="${elem}" ${elem === newElement ? 'selected' : ''}>${window.ElementIcons[elem]} ${elem}</option>`
          ).join('');
          
          selectElement.innerHTML = optionsHTML;
        }
      }

      // Trigger page re-render to update all spell displays
      EventBus.emit(Events.PAGE_RENDER, {
        type: 'category',
        categoryType: 'spell',
        category: category
      });

      // Show success notification
      const elementIcon = window.ElementIcons ? window.ElementIcons[newElement] : '🔥';
      this.showNotification(`${elementIcon} Élément du sort "${spellName}" mis à jour : ${newElement}`, 'success');
    },

    // ========================================
    // NEW PAGE CREATION WITH SECTION SELECTION
    // ========================================
    setupNewPageHandler() {
      // Set up event listener for "Nouvelle page" button
      document.addEventListener('click', (e) => {
        if (e.target && e.target.id === 'addCategory') {
          e.preventDefault();
          this.showSectionSelectionModal();
        }
      });
    },

    showSectionSelectionModal() {
      const modal = this.createSectionSelectionModal();
      document.body.appendChild(modal);
      this.openModal('sectionSelectionModal');
    },

    createSectionSelectionModal() {
      // Get available sections from TOC structure
      const sections = window.TOC_STRUCTURE?.sections || [
        { id: 'heros', title: '🦸 Héros', icon: '🦸' },
        { id: 'arsenal', title: '⚔️ Arsenal', icon: '⚔️' },
        { id: 'regles', title: '📚 Règles', icon: '📚' }
      ];

      // Filter sections based on MJ access if needed
      const availableSections = sections.filter(section => 
        !section.requiresMJ || window.JdrApp?.state?.isMJ
      );

      const sectionsHTML = availableSections.map(section => `
        <div class="section-option" data-section-id="${section.id}">
          <div class="section-icon">${section.icon}</div>
          <div class="section-info">
            <div class="section-title">${section.title}</div>
            <div class="section-description">${section.description || 'Section de contenu'}</div>
          </div>
        </div>
      `).join('');

      const modal = document.createElement('div');
      modal.className = 'modal section-selection-modal';
      modal.id = 'sectionSelectionModal';
      modal.innerHTML = `
        <div class="modal-overlay"></div>
        <div class="modal-content">
          <h3>📄 Nouvelle page</h3>
          <p>Dans quelle section souhaitez-vous créer la nouvelle page ?</p>
          
          <div class="sections-list">
            ${sectionsHTML}
          </div>
          
          <div class="page-details" style="display: none;">
            <div class="form-group">
              <label for="pageTitle">Titre de la page :</label>
              <input type="text" id="pageTitle" placeholder="Nom de la nouvelle page" required>
            </div>
            <div class="form-group">
              <label for="pageIcon">Icône (optionnel) :</label>
              <select id="pageIcon">
                <option value="📄">📄 Page</option>
                <option value="⚔️">⚔️ Combat</option>
                <option value="🔮">🔮 Magie</option>
                <option value="🏛️">🏛️ Lieu</option>
                <option value="👥">👥 Personnages</option>
                <option value="📚">📚 Règles</option>
                <option value="🗡️">🗡️ Armes</option>
                <option value="🛡️">🛡️ Armures</option>
                <option value="💰">💰 Économie</option>
                <option value="🌟">🌟 Éléments</option>
                <option value="📊">📊 Statistiques</option>
                <option value="🎯">🎯 Compétences</option>
                <option value="⚡">⚡ États</option>
                <option value="📜">📜 Histoire</option>
                <option value="🗺️">🗺️ Géographie</option>
                <option value="👹">👹 Monstres</option>
                <option value="🎭">🎭 Culture</option>
                <option value="🏰">🏰 Royaumes</option>
                <option value="⭐">⭐ Important</option>
                <option value="💎">💎 Trésors</option>
              </select>
            </div>
          </div>
          
          <div class="modal-actions">
            <button type="button" class="btn modal-close">Annuler</button>
            <button type="button" class="btn btn-primary" id="createPageBtn" style="display: none;">Créer la page</button>
          </div>
        </div>
      `;

      // Set up event handlers
      this.setupSectionSelectionHandlers(modal);

      return modal;
    },

    setupSectionSelectionHandlers(modal) {
      let selectedSectionId = null;

      // Section selection
      modal.addEventListener('click', (e) => {
        const sectionOption = e.target.closest('.section-option');
        if (sectionOption) {
          // Remove previous selection
          modal.querySelectorAll('.section-option').forEach(opt => opt.classList.remove('selected'));
          
          // Select this section
          sectionOption.classList.add('selected');
          selectedSectionId = sectionOption.dataset.sectionId;
          
          // Show page details form
          const pageDetails = modal.querySelector('.page-details');
          const createBtn = modal.querySelector('#createPageBtn');
          pageDetails.style.display = 'block';
          createBtn.style.display = 'inline-block';
          
          // Focus on title input
          modal.querySelector('#pageTitle').focus();
        }
      });

      // Create page button
      modal.querySelector('#createPageBtn').addEventListener('click', () => {
        const titleInput = modal.querySelector('#pageTitle');
        const iconInput = modal.querySelector('#pageIcon');
        
        const pageTitle = titleInput.value.trim();
        const pageIcon = iconInput.value || '📄';
        
        if (!pageTitle) {
          this.showNotification('Veuillez saisir un titre pour la page', 'error');
          titleInput.focus();
          return;
        }

        if (!selectedSectionId) {
          this.showNotification('Veuillez sélectionner une section', 'error');
          return;
        }

        this.createNewPage(selectedSectionId, pageTitle, pageIcon);
        this.closeModal(modal);
      });

      // Handle Enter key in form
      modal.querySelector('#pageTitle').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && selectedSectionId) {
          modal.querySelector('#createPageBtn').click();
        }
      });
    },

    createNewPage(sectionId, pageTitle, pageIcon) {
      // Generate page ID from title
      const pageId = this.slugify(pageTitle);
      
      // Create new page object
      const newPage = {
        type: 'page',
        id: pageId,
        title: pageTitle,
        icon: pageIcon
      };

      // Add to TOC structure
      if (window.TOC_STRUCTURE) {
        const section = window.TOC_STRUCTURE.sections.find(s => s.id === sectionId);
        if (section) {
          section.items.push(newPage);
          
          // Create default page data
          const defaultPageData = {
            page: pageId,
            title: pageTitle,
            sections: [
              {
                type: 'intro',
                content: `Contenu de la page ${pageTitle}. Vous pouvez éditer ce texte en mode développement.`
              }
            ]
          };

          // Add to static pages
          if (!window.STATIC_PAGES) {
            window.STATIC_PAGES = {};
          }
          window.STATIC_PAGES[pageId] = defaultPageData;

          // Add to static pages config
          if (!window.STATIC_PAGES_CONFIG) {
            window.STATIC_PAGES_CONFIG = { pages: [] };
          }
          const newPageConfig = {
            id: pageId,
            title: pageTitle,
            file: `${pageId}.json`,
            active: true,
            order: window.STATIC_PAGES_CONFIG.pages.length + 1
          };
          window.STATIC_PAGES_CONFIG.pages.push(newPageConfig);

          // Create the article element for the new page
          this.createPageArticle(pageId, pageTitle, defaultPageData);

          // Regenerate TOC to include new page
          if (JdrApp.modules.router) {
            JdrApp.modules.router.generateTOC();
          }

          // Save changes
          if (JdrApp.modules.storage) {
            JdrApp.modules.storage.saveChanges(true);
          }

          // Navigate to new page
          window.location.hash = `#/${pageId}`;

          this.showNotification(`📄 Page "${pageTitle}" créée avec succès dans la section ${this.getSectionTitle(sectionId)}`, 'success');
        }
      }
    },

    createPageArticle(pageId, pageTitle, pageData) {
      // Force the renderer to generate the page content immediately
      if (JdrApp.modules.renderer && JdrApp.modules.renderer.generatePageContent) {
        const content = JdrApp.modules.renderer.generatePageContent(pageId);
        if (content) {
          // Create the article if it doesn't exist
          let article = document.querySelector(`article[data-page="${pageId}"]`);
          if (!article) {
            article = document.createElement('article');
            article.setAttribute('data-page', pageId);
            article.style.display = 'none';
            const viewsContainer = document.getElementById('views');
            if (viewsContainer) {
              viewsContainer.appendChild(article);
            }
          }
          // Set the content
          article.innerHTML = content;
        }
      }
    },

    getSectionTitle(sectionId) {
      if (window.TOC_STRUCTURE) {
        const section = window.TOC_STRUCTURE.sections.find(s => s.id === sectionId);
        return section ? section.title : sectionId;
      }
      return sectionId;
    },

    // ==== GLOBAL TAGS MANAGEMENT ====

    showTagsManagementModal() {
      // Déterminer le type de contenu basé sur la page actuelle
      const currentPage = window.location.hash.replace('#/', '') || 'creation';
      let contentType = 'objet'; // par défaut
      let config = null;
      
      if (currentPage === 'monstres' && window.ContentTypes.monster?.filterConfig) {
        contentType = 'monster';
        config = window.ContentTypes.monster.filterConfig;
      } else if (window.ContentTypes.objet?.filterConfig) {
        contentType = 'objet';
        config = window.ContentTypes.objet.filterConfig;
      }
      
      if (!config) {
        this.showNotification('❌ Configuration des tags non trouvée', 'error');
        return;
      }

      // Remove any existing modal
      const existingModal = document.querySelector('#tagsManagementModal');
      if (existingModal) {
        existingModal.remove();
      }

      const modal = this.createTagsManagementModal(config, contentType);
      document.body.appendChild(modal);
      
      // Use native dialog showModal for proper z-index
      modal.showModal();
    },

    createTagsManagementModal(config, contentType = 'objet') {
      const modal = document.createElement('dialog');
      modal.id = 'tagsManagementModal';
      modal.style.cssText = `
        max-width: 600px;
        width: 90%;
        padding: 0;
        border: none;
        border-radius: 12px;
        background: transparent;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      `;

      const tagsListHTML = config.availableTags.map((tag, index) => `
        <div class="tag-item" data-tag-index="${index}" data-tag-name="${tag}">
          <span class="tag-chip" style="background: var(--bronze); color: white; padding: 4px 8px; border-radius: 8px; margin-right: 0.5rem;">${tag}</span>
          <input type="text" value="${tag}" class="tag-input" style="flex: 1; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 4px; margin-right: 0.5rem;">
          <button type="button" class="btn small delete-tag-btn" data-tag-name="${tag}" style="background: #dc2626 !important; color: white !important; padding: 0.25rem 0.5rem !important; display: inline-block !important; opacity: 1 !important; visibility: visible !important;">
            🗑️
          </button>
        </div>
      `).join('');

      modal.innerHTML = `
        <div style="background: var(--paper); border-radius: 12px; padding: 1.5rem; border: 2px solid var(--rule);">
          <h3 style="margin: 0 0 1rem 0; color: var(--accent-ink);">🏷️ Gestion des tags globaux</h3>
          <p style="margin: 0 0 1rem 0; color: var(--paper-muted);">Gérez la liste principale des tags disponibles pour les ${contentType === 'monster' ? 'monstres' : 'objets'}.</p>
          
          <div style="margin: 1rem 0;">
            <h4 style="margin: 0 0 0.5rem 0; color: var(--accent-ink);">Tags existants :</h4>
            <div id="tagsManagementList" style="max-height: 300px; overflow-y: auto;">
              ${tagsListHTML}
            </div>
          </div>
          
          <div style="margin: 1rem 0; padding: 1rem; background: var(--card); border-radius: 8px;">
            <h4 style="margin: 0 0 0.5rem 0; color: var(--accent-ink);">Ajouter un nouveau tag :</h4>
            <div style="display: flex; gap: 0.5rem; align-items: center;">
              <input type="text" id="newTagInput" placeholder="Nom du nouveau tag" style="flex: 1; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 4px;">
              <button type="button" id="addTagBtn" class="btn" style="background: var(--accent); color: white;">
                ➕ Ajouter
              </button>
            </div>
          </div>
          
          <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem;">
            <button type="button" class="btn modal-close" style="background: #666; color: white;">
              ❌ Annuler
            </button>
            <button type="button" id="saveTagsManagementBtn" class="btn" style="background: var(--accent); color: white;">
              💾 Sauvegarder
            </button>
          </div>
        </div>
      `;

      this.setupTagsManagementHandlers(modal, config, contentType);
      return modal;
    },

    setupTagsManagementHandlers(modal, config, contentType = 'objet') {
      // Add new tag
      modal.querySelector('#addTagBtn').addEventListener('click', () => {
        const input = modal.querySelector('#newTagInput');
        const newTag = input.value.trim();
        
        if (!newTag) {
          this.showNotification('❌ Veuillez saisir un nom de tag', 'error');
          return;
        }
        
        if (config.availableTags.includes(newTag)) {
          this.showNotification(`❌ Le tag "${newTag}" existe déjà`, 'error');
          return;
        }
        
        // Add to temporary config (will be saved when user clicks save)
        config.availableTags.push(newTag);
        
        // Update the modal display
        this.refreshTagsManagementModal(modal, config);
        
        // Clear input
        input.value = '';
        this.showNotification(`➕ Tag "${newTag}" ajouté à la liste`, 'success');
      });

      // Handle Enter key in new tag input
      modal.querySelector('#newTagInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          modal.querySelector('#addTagBtn').click();
        }
      });

      // Delete tag
      modal.addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-tag-btn')) {
          const tagName = e.target.dataset.tagName;
          
          if (config.availableTags.length <= 1) {
            this.showNotification('❌ Impossible de supprimer le dernier tag', 'error');
            return;
          }
          
          if (confirm(`Supprimer le tag "${tagName}" ?\nAttention: il sera retiré de tous les objets qui l'utilisent.`)) {
            // Remove from config
            config.availableTags = config.availableTags.filter(tag => tag !== tagName);
            
            // Remove from all items that use this tag
            if (contentType === 'monster' && Array.isArray(window.MONSTRES)) {
              window.MONSTRES.forEach(monster => {
                if (monster.tags && monster.tags.includes(tagName)) {
                  monster.tags = monster.tags.filter(tag => tag !== tagName);
                  // Ensure monster has at least one tag if possible
                  if (monster.tags.length === 0 && config.availableTags.length > 0) {
                    monster.tags = [config.availableTags[0]];
                  }
                }
              });
              
              // Update filter settings to remove deleted tag for monsters
              if (window.MONSTRES_FILTER_STATE?.visibleTags) {
                window.MONSTRES_FILTER_STATE.visibleTags = window.MONSTRES_FILTER_STATE.visibleTags.filter(tag => tag !== tagName);
                // Ensure at least one visible tag remains
                if (window.MONSTRES_FILTER_STATE.visibleTags.length === 0 && config.availableTags.length > 0) {
                  window.MONSTRES_FILTER_STATE.visibleTags = [config.availableTags[0]];
                }
              }
            } else if (contentType === 'objet' && window.OBJETS?.objets) {
              window.OBJETS.objets.forEach(obj => {
                if (obj.tags && obj.tags.includes(tagName)) {
                  obj.tags = obj.tags.filter(tag => tag !== tagName);
                  // Ensure object has at least one tag if possible
                  if (obj.tags.length === 0 && config.availableTags.length > 0) {
                    obj.tags = [config.availableTags[0]];
                  }
                }
              });
              
              // Update filter settings to remove deleted tag for objects
              if (window.OBJETS?.filterSettings?.visibleTags) {
                window.OBJETS.filterSettings.visibleTags = window.OBJETS.filterSettings.visibleTags.filter(tag => tag !== tagName);
                // Ensure at least one visible tag remains
                if (window.OBJETS.filterSettings.visibleTags.length === 0 && config.availableTags.length > 0) {
                  window.OBJETS.filterSettings.visibleTags = [config.availableTags[0]];
                }
              }
            }
            
            // Update modal display
            this.refreshTagsManagementModal(modal, config);
            this.showNotification(`🗑️ Tag "${tagName}" supprimé`, 'success');
          }
        }
      });

      // Save all changes
      modal.querySelector('#saveTagsManagementBtn').addEventListener('click', () => {
        // Collect all tag renames
        const tagItems = modal.querySelectorAll('.tag-item');
        const renames = [];
        
        tagItems.forEach(item => {
          const originalName = item.dataset.tagName;
          const newName = item.querySelector('.tag-input').value.trim();
          
          if (newName && newName !== originalName) {
            renames.push({ old: originalName, new: newName });
          }
        });
        
        // Apply renames to config
        renames.forEach(rename => {
          const index = config.availableTags.indexOf(rename.old);
          if (index >= 0) {
            config.availableTags[index] = rename.new;
            
            // Update all items that use this tag
            if (contentType === 'monster' && Array.isArray(window.MONSTRES)) {
              window.MONSTRES.forEach(monster => {
                if (monster.tags && monster.tags.includes(rename.old)) {
                  const tagIndex = monster.tags.indexOf(rename.old);
                  monster.tags[tagIndex] = rename.new;
                }
              });
            } else if (contentType === 'objet' && window.OBJETS?.objets) {
              window.OBJETS.objets.forEach(obj => {
                if (obj.tags && obj.tags.includes(rename.old)) {
                  const tagIndex = obj.tags.indexOf(rename.old);
                  obj.tags[tagIndex] = rename.new;
                }
              });
              
              // Update filter settings for objects
              if (window.OBJETS?.filterSettings?.visibleTags) {
                const visibleIndex = window.OBJETS.filterSettings.visibleTags.indexOf(rename.old);
                if (visibleIndex >= 0) {
                  window.OBJETS.filterSettings.visibleTags[visibleIndex] = rename.new;
                }
              }
            }
          }
        });
        
        // Save to storage
        EventBus.emit(Events.STORAGE_SAVE);
        
        // Refresh current page if it matches the content type
        if (contentType === 'monster') {
          this.refreshMonstersPage();
        } else {
          this.refreshObjectsPage();
        }
        
        // Close modal
        modal.close();
        modal.remove();
        
        const changesCount = renames.length;
        if (changesCount > 0) {
          this.showNotification(`💾 ${changesCount} modification(s) sauvegardée(s)`, 'success');
        } else {
          this.showNotification('💾 Tags sauvegardés', 'success');
        }
      });

      // Close modal events
      modal.querySelector('.modal-close').addEventListener('click', () => {
        modal.close();
        modal.remove();
      });

      modal.addEventListener('cancel', () => {
        modal.close();
        modal.remove();
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.close();
          modal.remove();
        }
      });
    },

    refreshTagsManagementModal(modal, config) {
      const container = modal.querySelector('#tagsManagementList');
      if (!container) return;

      const tagsListHTML = config.availableTags.map((tag, index) => `
        <div class="tag-item" data-tag-index="${index}" data-tag-name="${tag}">
          <span class="tag-chip" style="background: var(--bronze); color: white; padding: 4px 8px; border-radius: 8px; margin-right: 0.5rem;">${tag}</span>
          <input type="text" value="${tag}" class="tag-input" style="flex: 1; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 4px; margin-right: 0.5rem;">
          <button type="button" class="btn small delete-tag-btn" data-tag-name="${tag}" style="background: #dc2626; color: white; padding: 0.25rem 0.5rem;">
            🗑️
          </button>
        </div>
      `).join('');

      container.innerHTML = tagsListHTML;
    },

    // ==== ID SEARCH FUNCTIONALITY ====

    performIdSearch(searchValue) {
      const searchId = searchValue.trim();
      const resultDiv = document.querySelector('#id-search-result');
      
      if (!searchId) {
        this.clearIdSearch();
        return;
      }

      const searchNumber = parseInt(searchId, 10);
      if (isNaN(searchNumber)) {
        if (resultDiv) {
          resultDiv.innerHTML = '❌ Veuillez saisir un numéro valide';
          resultDiv.style.color = '#dc2626';
        }
        return;
      }

      // Find object by number
      const allObjects = window.OBJETS?.objets || [];
      const foundObject = allObjects.find(obj => obj.numero === searchNumber);

      if (!foundObject) {
        if (resultDiv) {
          resultDiv.innerHTML = `❌ Aucun objet trouvé avec l'ID ${searchNumber}`;
          resultDiv.style.color = '#dc2626';
        }
        // Hide all objects
        this.hideAllObjects();
        return;
      }

      // Set global flag BEFORE regenerating page
      window.activeIdSearch = true;

      // Force regenerate page with all objects AND visual feedback
      if (JdrApp.modules.renderer?.regenerateCurrentPage) {
        JdrApp.modules.renderer.regenerateCurrentPage();
      }

      // Show success message
      if (resultDiv) {
        resultDiv.innerHTML = `✅ Objet trouvé : "${foundObject.nom}" (ID: ${searchNumber})`;
        resultDiv.style.color = '#16a34a';
      }

      // Show only the found object (after page regeneration)
      setTimeout(() => {
        this.showOnlyObjectById(searchNumber);
        
        // Restore the search value in the input field
        const searchInput = document.querySelector('#id-search-input');
        if (searchInput) {
          searchInput.value = searchNumber;
        }
      }, 100);
    },

    clearIdSearch() {
      const input = document.querySelector('#id-search-input');
      const resultDiv = document.querySelector('#id-search-result');
      
      if (input) {
        input.value = '';
      }
      
      if (resultDiv) {
        resultDiv.innerHTML = '';
        resultDiv.style.color = '';
      }

      // Clear global flag for active ID search
      window.activeIdSearch = false;

      // Regenerate page to update visual feedback and return to normal display
      if (JdrApp.modules.renderer?.regenerateCurrentPage) {
        JdrApp.modules.renderer.regenerateCurrentPage();
      }
    },

    hideAllObjects() {
      const container = document.querySelector('#objets-container');
      if (container) {
        const allCards = container.querySelectorAll('.card');
        allCards.forEach(card => {
          card.style.display = 'none';
        });
      }
    },

    showOnlyObjectById(objectId) {
      console.log('🔍 showOnlyObjectById called with ID:', objectId);
      const container = document.querySelector('#objets-container');
      if (!container) {
        console.log('🔍 No objets-container found');
        return;
      }

      const allCards = container.querySelectorAll('.card');
      console.log('🔍 Found', allCards.length, 'cards in container');
      let foundCard = null;

      allCards.forEach((card, index) => {
        const objetName = card.dataset.objetName;
        console.log(`🔍 Card ${index}: objetName = "${objetName}"`);
        if (objetName) {
          // Find the object by name to get its number
          const obj = window.OBJETS?.objets?.find(o => o.nom === objetName);
          console.log(`🔍 Found object:`, obj);
          if (obj && obj.numero === objectId) {
            console.log('🔍 MATCH! Showing card for:', objetName);
            card.style.display = '';
            foundCard = card;
          } else {
            card.style.display = 'none';
          }
        }
      });

      console.log('🔍 foundCard:', foundCard);

      // Scroll to the found card if it exists
      if (foundCard) {
        setTimeout(() => {
          foundCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Brief highlight effect
          foundCard.style.transition = 'all 0.3s ease';
          foundCard.style.boxShadow = '0 0 20px rgba(22, 163, 74, 0.5)';
          foundCard.style.transform = 'scale(1.02)';
          
          setTimeout(() => {
            foundCard.style.boxShadow = '';
            foundCard.style.transform = '';
          }, 1500);
        }, 100);
      }
    },

    showAllObjectsWithTagFilters() {
      // Restore normal tag filtering behavior
      const currentSettings = window.OBJETS?.filterSettings || { 
        visibleTags: window.ContentTypes.objet.filterConfig.defaultVisibleTags 
      };
      
      const container = document.querySelector('#objets-container');
      if (!container) return;

      const allCards = container.querySelectorAll('.card');
      allCards.forEach(card => {
        const objetName = card.dataset.objetName;
        if (objetName) {
          // Find the object and check if it has visible tags
          const obj = window.OBJETS?.objets?.find(o => o.nom === objetName);
          if (obj && obj.tags) {
            const hasVisibleTag = obj.tags.some(tag => currentSettings.visibleTags.includes(tag));
            card.style.display = hasVisibleTag ? '' : 'none';
          } else {
            card.style.display = 'none';
          }
        }
      });
    },

    // Toggle individual filter tag
    toggleFilter(chipElement) {
      const tag = chipElement.dataset.tag;
      if (!tag) return;

      // GUARD: Prevent rapid double clicks (debounce)
      if (this._toggleInProgress) {
        return;
      }
      this._toggleInProgress = true;
      
      // Release the lock after a short delay
      setTimeout(() => {
        this._toggleInProgress = false;
      }, 100);

      // Déterminer le type de contenu basé sur la page actuelle
      const currentPage = window.location.hash.replace('#/', '') || 'creation';
      let contentType = 'objet'; // par défaut
      let dataObject = null;
      let visibleTags = null;
      
      if (currentPage === 'monstres') {
        contentType = 'monster';
        // Pour les monstres, on utilise une structure simplifiée dans window.MONSTRES_FILTER_STATE
        if (!window.MONSTRES_FILTER_STATE) {
          window.MONSTRES_FILTER_STATE = { visibleTags: [...window.ContentTypes.monster.filterConfig.defaultVisibleTags] };
        }
        visibleTags = window.MONSTRES_FILTER_STATE.visibleTags;
      } else {
        // Pour les objets (comportement existant)
        if (!window.OBJETS.filterSettings) {
          window.OBJETS.filterSettings = { visibleTags: [...window.ContentTypes.objet.filterConfig.defaultVisibleTags] };
        }
        visibleTags = window.OBJETS.filterSettings.visibleTags;
      }
      
      // IMPORTANT: Track state BEFORE modification to know if we need full regeneration
      const wasEmpty = visibleTags.length === 0;
      
      // SIMPLE LOGIC: Check visual state directly and toggle
      const isVisuallyActive = chipElement.classList.contains('active');
      

      if (isVisuallyActive) {
        // DEACTIVATE - remove from visible tags
        const tagIndex = visibleTags.indexOf(tag);
        if (tagIndex > -1) {
          visibleTags.splice(tagIndex, 1);
        }
        chipElement.classList.remove('active');
        chipElement.classList.add('inactive');
        chipElement.style.background = '#6b7280';
        chipElement.style.opacity = '0.6';
        chipElement.style.boxShadow = '';
        this.showNotification(`🏷️ Tag "${tag}" masqué`, 'info');
      } else {
        // ACTIVATE - add to visible tags
        if (!visibleTags.includes(tag)) {
          visibleTags.push(tag);
        }
        chipElement.classList.add('active');
        chipElement.classList.remove('inactive');
        chipElement.style.background = '#16a34a';
        chipElement.style.opacity = '1';
        chipElement.style.boxShadow = '0 2px 4px rgba(22, 163, 74, 0.3)';
        this.showNotification(`🏷️ Tag "${tag}" affiché`, 'info');
      }


      // Check if we need a full page regeneration vs just visibility update
      const nowHasTags = visibleTags.length > 0;
      
      if (contentType === 'monster') {
        // For monsters, ALWAYS refresh because they use AND logic
        // Any change in tags can reveal/hide different monsters
        this.refreshCurrentPage(contentType);
      } else {
        // Original logic for objects
        if (wasEmpty && nowHasTags) {
          // If we went from no tags to having tags, we need full regeneration
          // because buildSingleObjectPage returns [] when visibleTags.length === 0
          this._needsRegenerationAfterEmpty = true;
          this.refreshCurrentPage(contentType);
        } else if (this._needsRegenerationAfterEmpty && !isVisuallyActive) {
          // If we're adding more tags after having started from empty, keep regenerating
          this.refreshCurrentPage(contentType);
        } else if (!isVisuallyActive) {
          // CRITICAL FIX: When activating a new tag, always regenerate the page
          // This ensures objects with the new tag appear in the DOM, not just get unhidden
          // The issue was that updateObjectVisibility() can only show/hide existing DOM elements,
          // but objects filtered out during initial page generation don't exist in DOM at all
          this.refreshCurrentPage(contentType);
        } else {
          // Reset the flag if we're deactivating a tag (we have a complete DOM now)
          this._needsRegenerationAfterEmpty = false;
          // When deactivating, we can just hide existing elements
          this.updateContentVisibility(contentType);
        }
      }

      // Save changes to storage
      EventBus.emit(Events.STORAGE_SAVE);
    },

    refreshCurrentPage(contentType) {
      if (contentType === 'monster') {
        this.refreshMonstersPage();
      } else {
        this.refreshObjectsPage();
      }
    },

    updateContentVisibility(contentType) {
      if (contentType === 'monster') {
        this.updateMonstersVisibility();
      } else {
        this.updateObjectVisibility();
      }
    },

    updateMonstersVisibility() {
      if (!window.MONSTRES_FILTER_STATE) return;
      
      const visibleTags = window.MONSTRES_FILTER_STATE.visibleTags;
      const allMonsterCards = document.querySelectorAll('#monstres-container .card');
      
      allMonsterCards.forEach(card => {
        const monsterName = card.dataset.monsterName || card.querySelector('[data-edit-section*="nom"]')?.textContent;
        if (!monsterName) return;
        
        // Trouver le monstre correspondant dans les données
        const monster = window.MONSTRES.find(m => m.nom === monsterName);
        if (!monster || !monster.tags) return;
        
        // En mode "ET" : le monstre doit avoir TOUS les tags visibles
        const shouldShow = visibleTags.length === 0 || 
                          visibleTags.every(tag => monster.tags.includes(tag));
        
        card.style.display = shouldShow ? '' : 'none';
      });
    },

    // Update object visibility based on current filter settings
    updateObjectVisibility() {
      const allObjects = document.querySelectorAll('.card[data-objet-name]');
      const visibleTags = window.OBJETS.filterSettings?.visibleTags || [];
      
      allObjects.forEach(card => {
        const objetName = card.dataset.objetName;
        const objet = window.OBJETS.objets?.find(o => o.nom === objetName);
        
        if (objet && objet.tags) {
          // Check if object should be visible based on current filter settings
          const hasVisibleTag = objet.tags.some(tag => visibleTags.includes(tag));
          
          // Apply same logic as PageBuilder for "Départ" tag requirement
          const isMJMode = window.JdrApp?.state?.isMJ || false;
          const isDevMode = window.JdrApp?.utils?.isDevMode?.() || false;
          const bypassDepartRequirement = isMJMode || isDevMode || window.activeIdSearch;
          
          let shouldShow = hasVisibleTag && visibleTags.length > 0;
          
          // CONDITION OBLIGATOIRE : L'objet doit avoir le tag "Départ" pour être visible
          // SAUF si mode MJ activé, dev mode activé, ou recherche par ID active
          if (shouldShow && !bypassDepartRequirement) {
            const hasDepartTag = objet.tags.includes('Départ');
            if (!hasDepartTag) {
              shouldShow = false;
            }
          }
          
          if (shouldShow) {
            card.style.display = '';
          } else {
            card.style.display = 'none';
          }
        }
      });
      
      // Update filter count display if it exists
      const filterCount = document.querySelector('.filter-count');
      if (filterCount) {
        const visibleCount = Array.from(allObjects).filter(card => card.style.display !== 'none').length;
        filterCount.textContent = `${visibleCount} objet(s) affiché(s)`;
      }
    },

    // Select all tags
    selectAllTags() {
      if (!window.OBJETS.filterSettings) {
        window.OBJETS.filterSettings = { visibleTags: [] };
      }

      // Get all available tags and set them as visible
      const availableTags = window.ContentTypes.objet.filterConfig.availableTags || [];
      window.OBJETS.filterSettings.visibleTags = [...availableTags];

      // Reset regeneration flag since we're doing a full reset
      this._needsRegenerationAfterEmpty = false;

      // Save changes to storage
      EventBus.emit(Events.STORAGE_SAVE);
      
      // Regenerate the objects page to reflect changes
      this.refreshObjectsPage();
    },

    // Select no tags (allow having no tags active)
    selectNoTags() {
      if (!window.OBJETS.filterSettings) {
        window.OBJETS.filterSettings = { visibleTags: [] };
      }

      // Clear all visible tags
      window.OBJETS.filterSettings.visibleTags = [];

      // Reset regeneration flag since we're starting fresh
      this._needsRegenerationAfterEmpty = false;

      // Save changes to storage
      EventBus.emit(Events.STORAGE_SAVE);
      
      // Regenerate the objects page to reflect changes
      this.refreshObjectsPage();
    },

    // Refresh the objects page after filter changes
    refreshObjectsPage() {
      // Clean up active tags that are not in displayed buttons
      this.cleanupActiveFilters();
      
      // Don't regenerate if an ID search is active
      if (window.activeIdSearch) {
        // Just show notification, keep current display
        const tagCount = window.OBJETS.filterSettings?.visibleTags?.length || 0;
        this.showNotification(`🏷️ Filtres mis à jour (${tagCount} tag${tagCount > 1 ? 's' : ''} actif${tagCount > 1 ? 's' : ''}) - Recherche par ID active`, 'success');
        return;
      }

      // Regenerate and update the objects page
      if (JdrApp.modules.renderer?.regenerateCurrentPage) {
        JdrApp.modules.renderer.regenerateCurrentPage();
      }
      
      // Show notification
      const tagCount = window.OBJETS.filterSettings?.visibleTags?.length || 0;
      this.showNotification(`🏷️ Filtres mis à jour (${tagCount} tag${tagCount > 1 ? 's' : ''} actif${tagCount > 1 ? 's' : ''})`, 'success');
    },

    // Clean up active filters to ensure only displayed buttons can be active
    cleanupActiveFilters() {
      if (!window.OBJETS?.filterSettings) return;
      
      const displayedButtons = window.OBJETS.filterSettings.displayedFilterButtons || [];
      const activeFilters = window.OBJETS.filterSettings.visibleTags || [];
      
      // Remove any active filters that are not in displayed buttons
      const cleanedActiveFilters = activeFilters.filter(tag => displayedButtons.includes(tag));
      
      // Update if something was cleaned
      if (cleanedActiveFilters.length !== activeFilters.length) {
        window.OBJETS.filterSettings.visibleTags = cleanedActiveFilters;
        const removedCount = activeFilters.length - cleanedActiveFilters.length;
      }
    }
  };

})();

</script>
</body>
</html>