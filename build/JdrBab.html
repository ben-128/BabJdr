<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta name="referrer" content="no-referrer-when-downgrade">
<!-- Generated on 2025-09-03T11:52:32.448Z by JdrBab Build System -->
<title>JDR‑BAB — Livret de règles</title>
<meta content="Livret web multipages des règles JDR‑BAB, thème parchemin, illustrations par catégorie/classe/sous‑classe, export HTML autonome." name="description">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&amp;family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600&amp;display=swap" rel="stylesheet">
<style>
/* —— Thème Heroic Fantasy - Enhanced Parchment —— */
:root{
  --paper:#f4f0e6;        /* parchemin ancien */
  --paper-ink:#2c1810;    /* encre noire profonde */
  --paper-muted:#8b6f47;  /* bronze ancien */
  --accent:#d4af37;       /* accent doré pour backgrounds */
  --accent-ink:#4a2c17;   /* titres sombres */
  --rule:#d4c4a8;         /* bordures dorées */
  --card:#faf6ee;         /* cartes parchemin */
  --link:#8b4513;         /* liens cuivre */
  --gold:#d4af37;         /* or */
  --bronze:#cd7f32;       /* bronze */
  --shadow:0 8px 32px rgba(0,0,0,.15), 0 2px 8px rgba(139,69,19,.1);
  --card-shadow:0 6px 20px rgba(0,0,0,.1), 0 2px 6px rgba(139,69,19,.08);
  --image-border:3px solid #8b4513;
  --image-shadow:0 4px 12px rgba(0,0,0,.2), inset 0 1px 2px rgba(212,175,55,.3);
  
  /* Enhanced Parchment Textures */
  --parchment-texture: 
    radial-gradient(circle at 20% 80%, rgba(139,69,19,.03) 0%, transparent 50%),
    radial-gradient(circle at 80% 20%, rgba(212,175,55,.02) 0%, transparent 50%),
    radial-gradient(circle at 40% 40%, rgba(139,69,19,.01) 0%, transparent 30%),
    linear-gradient(45deg, rgba(139,69,19,.005) 25%, transparent 25%),
    linear-gradient(-45deg, rgba(212,175,55,.005) 25%, transparent 25%);
    
  --parchment-border:
    linear-gradient(45deg, 
      rgba(139,69,19,.8) 0%, 
      rgba(212,175,55,.6) 25%, 
      rgba(139,69,19,.4) 50%, 
      rgba(212,175,55,.6) 75%, 
      rgba(139,69,19,.8) 100%);
      
  --aged-paper: 
    radial-gradient(ellipse at top left, rgba(139,69,19,.04), transparent 60%),
    radial-gradient(ellipse at top right, rgba(212,175,55,.03), transparent 60%),
    radial-gradient(ellipse at bottom left, rgba(139,69,19,.02), transparent 60%),
    radial-gradient(ellipse at bottom right, rgba(212,175,55,.025), transparent 60%);
  
  /* Enhanced Element Colors System - Improved Contrast & Accessibility */
  --feu:#e63946; --feu-bg:rgba(230,57,70,.12); --feu-border:rgba(230,57,70,.4);
  --air:#457b9d; --air-bg:rgba(69,123,157,.12); --air-border:rgba(69,123,157,.4);
  --eau:#1d3557; --eau-bg:rgba(29,53,87,.12); --eau-border:rgba(29,53,87,.4);
  --terre:#6f4e37; --terre-bg:rgba(111,78,55,.12); --terre-border:rgba(111,78,55,.4);
  --divin:#f1c40f; --divin-bg:rgba(241,196,15,.12); --divin-border:rgba(241,196,15,.4);
  --malefique:#6a2c70; --malefique-bg:rgba(106,44,112,.12); --malefique-border:rgba(106,44,112,.4);
  
  /* Spacing system */
  --space-xs:4px; --space-sm:6px; --space-md:8px; --space-lg:12px; --space-xl:16px; --space-2xl:24px;
  
  /* Common transitions */
  --transition-fast:.2s ease; --transition-normal:.3s ease; --transition-slow:.5s ease;
}

/* Enhanced Accessibility & High Contrast Support */
@media (prefers-color-scheme: dark) { 
  :root{ 
    --paper:#f4f0e6; /* Keep light theme for fantasy aesthetic */
    --card:#faf6ee; 
    --paper-ink:#2c1810; 
  } 
}

@media (prefers-contrast: high) {
  :root {
    --paper-ink: #000000;
    --accent-ink: #1a0d08;
    --bronze: #8b4513;
    --gold: #b8860b;
    --rule: #8b4513;
  }
  
  .card, .card-base {
    border-width: 3px;
  }
  
  .btn-base {
    border-width: 3px;
  }
}

/* Base styles */
html,body{height:100%}
body{
  margin:0;
  background:
    radial-gradient(1600px 800px at 50% -10%, rgba(212,175,55,.08), transparent 45%),
    radial-gradient(1400px 700px at 120% 10%, rgba(139,69,19,.06), transparent 40%),
    radial-gradient(800px 400px at 20% 80%, rgba(205,127,50,.04), transparent 30%),
    repeating-linear-gradient(90deg, rgba(74,44,23,.02) 0 1px, transparent 1px 3px),
    repeating-linear-gradient(0deg, rgba(139,69,19,.015) 0 1px, transparent 1px 4px),
    var(--paper);
  color:var(--paper-ink); 
  font:17px/1.65 "Source Serif Pro", "Cinzel", ui-serif, Georgia, Cambria, "Times New Roman", Times, serif; 
  -webkit-font-smoothing:antialiased; 
  text-rendering:optimizeLegibility;
}

/* ═══════════════════════════════════════════════════════════════════════════════════════
   🎨 ENHANCED TYPOGRAPHY SYSTEM - Centered & Harmonized
   ═══════════════════════════════════════════════════════════════════════════════════════ */

/* Link Styling */
a {
  color: var(--link);
  text-decoration: none;
  transition: all var(--transition-fast);
  position: relative;
}

a:hover {
  text-decoration: underline;
  color: var(--gold);
  text-shadow: 0 1px 3px rgba(212,175,55,0.3);
}

/* Text Emphasis */
strong, b {
  font-weight: 700;
  font-family: "Source Serif Pro", serif;
  color: var(--accent-ink);
  text-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

em, i {
  font-style: italic;
  font-weight: 400;
  color: var(--bronze);
}

/* Enhanced Headings System */
h1, h2, h3, h4, h5, h6 {
  font-family: "Cinzel", "Trajan Pro", ui-serif, Georgia, Cambria, Times, serif;
  color: var(--accent-ink);
  text-shadow: 2px 2px 4px rgba(0,0,0,.1);
  text-align: center;
  margin: 1.5rem auto 1rem;
  position: relative;
  line-height: 1.2;
  letter-spacing: 0.02em;
}

/* Main Title */
h1 {
  font-size: clamp(28px, 4.5vw, 48px);
  letter-spacing: 0.05em;
  margin: 2rem auto 1.5rem;
  font-weight: 700;
  background: linear-gradient(135deg, var(--gold), var(--bronze), var(--gold));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-shadow: none;
  position: relative;
}

h1::before {
  content: '◆';
  position: absolute;
  left: -20px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--gold);
  font-size: 0.6em;
  opacity: 0.7;
}

h1::after {
  content: '◆';
  position: absolute;
  right: -20px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--gold);
  font-size: 0.6em;
  opacity: 0.7;
}

/* Section Headings */
h2 {
  font-size: clamp(22px, 3.2vw, 32px);
  margin: 1.8rem auto 1.2rem;
  font-weight: 600;
  color: var(--bronze);
  position: relative;
}

h2::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 80px;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--bronze), transparent);
  opacity: 0.8;
}

/* Subsection Headings */
h3 {
  font-size: clamp(18px, 2.4vw, 26px);
  margin: 1.5rem auto 1rem;
  font-weight: 500;
  color: var(--accent-ink);
  position: relative;
}

h3::before {
  content: '※';
  position: absolute;
  left: -15px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--bronze);
  font-size: 0.8em;
  opacity: 0.6;
}

h3::after {
  content: '※';
  position: absolute;
  right: -15px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--bronze);
  font-size: 0.8em;
  opacity: 0.6;
}

/* Smaller Headings */
h4 {
  font-size: clamp(16px, 2vw, 20px);
  margin: 1.2rem auto 0.8rem;
  font-weight: 500;
  color: var(--paper-muted);
}

h5, h6 {
  font-size: clamp(14px, 1.8vw, 18px);
  margin: 1rem auto 0.6rem;
  font-weight: 500;
  color: var(--paper-muted);
}

/* Text Utilities */
.muted {
  color: var(--paper-muted);
  font-style: italic;
}

.lead {
  font-size: 18px;
  line-height: 1.6;
  text-align: center;
  margin: 1.5rem auto;
  color: var(--accent-ink);
  font-weight: 400;
}

/* Enhanced Separator Rule */
.rule {
  height: 3px;
  background: linear-gradient(90deg, 
    transparent, 
    var(--bronze), 
    var(--gold), 
    var(--bronze), 
    transparent);
  margin: 2rem auto;
  border-radius: 2px;
  opacity: 0.8;
  position: relative;
}

.rule::before {
  content: '❋';
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  background: var(--paper);
  color: var(--gold);
  padding: 0 8px;
  font-size: 14px;
}

/* Decorative Separators */
.separator-ornate {
  text-align: center;
  margin: 2.5rem auto;
  font-size: 1.5em;
  color: var(--gold);
  opacity: 0.7;
}

.separator-ornate::before {
  content: '◆ ❋ ◆';
}

/* Centered Text Blocks */
.text-center {
  text-align: center;
}

.text-center-block {
  text-align: center;
  margin: 1.5rem auto;
  max-width: 800px;
}

/* Mobile Typography Adjustments */
@media (max-width: 480px) {
  h1::before, h1::after,
  h3::before, h3::after {
    display: none;
  }
  
  .rule::before {
    font-size: 12px;
    padding: 0 6px;
  }
  
  .lead {
    font-size: 16px;
    margin: 1rem auto;
  }
}
/* === UTILITY CLASSES === */

/* Spacing utilities */
.m-0{margin:0} .m-1{margin:var(--space-xs)} .m-2{margin:var(--space-md)} .m-3{margin:var(--space-lg)} .m-4{margin:var(--space-xl)}
.mt-0{margin-top:0} .mt-1{margin-top:var(--space-xs)} .mt-2{margin-top:var(--space-md)} .mt-3{margin-top:var(--space-lg)}
.mb-0{margin-bottom:0} .mb-1{margin-bottom:var(--space-xs)} .mb-2{margin-bottom:var(--space-md)} .mb-3{margin-bottom:var(--space-lg)}
.p-0{padding:0} .p-1{padding:var(--space-xs)} .p-2{padding:var(--space-md)} .p-3{padding:var(--space-lg)} .p-4{padding:var(--space-xl)}

/* Flex utilities */
.flex{display:flex} .flex-col{flex-direction:column} .flex-wrap{flex-wrap:wrap}
.items-center{align-items:center} .items-start{align-items:flex-start} .items-end{align-items:flex-end}
.justify-center{justify-content:center} .justify-start{justify-content:flex-start} .justify-end{justify-content:flex-end}
.gap-1{gap:var(--space-xs)} .gap-2{gap:var(--space-md)} .gap-3{gap:var(--space-lg)}

/* Element color utilities */
.text-feu{color:var(--feu)} .text-air{color:var(--air)} .text-eau{color:var(--eau)} .text-terre{color:var(--terre)} .text-divin{color:var(--divin)} .text-malefique{color:var(--malefique)}
.bg-feu{background:var(--feu-bg);border-color:var(--feu-border)} .bg-air{background:var(--air-bg);border-color:var(--air-border)}
.bg-eau{background:var(--eau-bg);border-color:var(--eau-border)} .bg-terre{background:var(--terre-bg);border-color:var(--terre-border)}
.bg-divin{background:var(--divin-bg);border-color:var(--divin-border)} .bg-malefique{background:var(--malefique-bg);border-color:var(--malefique-border)}

/* Grid utilities */
.grid{display:grid;gap:var(--space-lg)}
.cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}
.cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}
@media (max-width: 900px){ .cols-3{grid-template-columns:1fr} }
@media (max-width: 768px){ .cols-2{grid-template-columns:1fr !important} }

/* Misc utilities */
.subclass-stack{display:flex;flex-direction:column;gap:var(--space-lg)}
.chip{font-size:14px;border:2px solid var(--rule);border-radius:999px;padding:6px 12px;background:rgba(155,107,47,.12);font-weight:600;box-shadow:0 2px 6px rgba(0,0,0,.1)}
.chips{display:flex;flex-wrap:wrap;gap:8px;justify-content:center}
/* ═══════════════════════════════════════════════════════════════════════════════════════
   🏗️ LAYOUT SYSTEM - Enhanced Responsive Design
   ═══════════════════════════════════════════════════════════════════════════════════════ */

/* Main Shell Layout */
.shell {
  display: grid;
  grid-template-rows: 1fr auto;
  min-height: 100svh;
  position: relative;
}

/* Main Content Area - Enhanced Parchment Background */
.page {
  position: relative;
  min-height: 100vh;
  padding: 18px; /* Equal padding all around */
  transition: padding var(--transition-normal);
  background: 
    var(--parchment-texture),
    var(--aged-paper),
    var(--paper);
}

/* Content Container - Dynamic Centering (handled by JavaScript) */
#views {
  max-width: 1400px;
  /* Fallback positioning - will be overridden by DynamicCentering.js */
  margin-left: 370px; /* Just clear the sidebar */
  margin-right: 20px;
  padding: 0 var(--space-lg);
  animation: fadeInUp 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

/* Mobile Responsiveness */
@media (max-width: 980px) { 
  .page {
    padding: 12px;
    background: var(--paper);
  }
  
  #views {
    margin-left: 0; /* Reset sidebar margin on mobile */
    margin-right: 0;
    padding: 0 var(--space-md);
    max-width: 100%;
  }
}

/* ─────────────────────────── Enhanced Sidebar Navigation ─────────────────────────── */
.sidebar {
  position: fixed;
  top: 0;
  left: 0;
  width: 350px;
  height: 100vh;
  overflow-y: auto;
  overflow-x: hidden;
  z-index: 100;
  background: 
    var(--parchment-texture),
    linear-gradient(180deg, var(--paper), rgba(244,240,230,0.95)),
    var(--aged-paper);
  backdrop-filter: blur(8px);
  border-right: 4px solid transparent;
  border-image: var(--parchment-border) 1;
  box-shadow: 
    4px 0 20px rgba(0,0,0,0.08),
    inset -1px 0 0 rgba(212,175,55,0.1);
  transition: transform var(--transition-normal);
}

.sidebar::before {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  width: 2px;
  height: 100%;
  background: linear-gradient(180deg, 
    var(--gold) 0%, 
    var(--bronze) 50%, 
    var(--gold) 100%);
  opacity: 0.6;
}

/* Mobile Sidebar with Collapsible Navigation */
@media (max-width: 980px) { 
  .sidebar {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: auto;
    max-height: 80vh;
    background: 
      linear-gradient(135deg, var(--card), rgba(244,240,230,0.98)),
      radial-gradient(circle at 50% 30%, rgba(212,175,55,0.05), transparent 70%);
    border-right: none;
    border-bottom: 3px solid var(--rule);
    backdrop-filter: blur(8px);
    box-shadow: 
      0 8px 32px rgba(0,0,0,0.15),
      inset 0 -1px 0 rgba(212,175,55,0.1);
    transform: translateY(-100%);
    transition: transform var(--transition-normal);
    z-index: 200;
    overflow-y: auto;
  }
  
  .sidebar.mobile-open {
    transform: translateY(0);
  }
  
  /* Adjust page layout for mobile */
  .page {
    padding: 80px 12px 12px 12px; /* Top padding for mobile nav button */
  }
  
  .sidebar::before {
    display: none;
  }
  
  /* Mobile Navigation Toggle Button */
  .mobile-nav-toggle {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 300;
    background: linear-gradient(135deg, var(--gold), var(--bronze));
    color: white;
    border: 2px solid var(--rule);
    border-radius: 12px;
    padding: 12px 16px;
    cursor: pointer;
    box-shadow: 
      0 6px 20px rgba(0,0,0,.15),
      inset 0 1px 0 rgba(255,255,255,.2);
    transition: all var(--transition-fast);
    font-family: 'Cinzel', serif;
    font-weight: 600;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 44px;
    min-height: 44px;
    justify-content: center;
  }
  
  .mobile-nav-toggle:hover {
    transform: scale(1.05);
    box-shadow: 
      0 8px 25px rgba(0,0,0,.2),
      inset 0 1px 0 rgba(255,255,255,.3);
  }
  
  .mobile-nav-toggle:active {
    transform: scale(0.98);
  }
  
  .mobile-nav-toggle .icon {
    font-size: 16px;
    transition: transform var(--transition-fast);
  }
  
  .mobile-nav-toggle.open .icon {
    transform: rotate(180deg);
  }
  
  /* Hide toggle on desktop */
  @media (min-width: 981px) {
    .mobile-nav-toggle {
      display: none;
    }
  }
}
/* ─────────────────────────── Enhanced Panel System ─────────────────────────── */
.panel {
  background: 
    linear-gradient(135deg, var(--card), rgba(250,246,238,0.9)),
    radial-gradient(circle at 20% 30%, rgba(212,175,55,0.03), transparent 70%);
  border: 2px solid var(--rule);
  border-radius: 18px;
  box-shadow: 
    var(--card-shadow),
    inset 0 1px 0 rgba(255,255,255,0.1);
  padding: 18px;
  position: relative;
  overflow: hidden;
  margin: 12px;
  transition: all var(--transition-normal);
  backdrop-filter: blur(2px);
}

.panel::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, 
    transparent, 
    var(--gold), 
    var(--bronze), 
    var(--gold), 
    transparent);
  opacity: .6;
}

.panel::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--bronze), transparent);
  opacity: .3;
}

.panel:hover {
  transform: translateY(-1px);
  box-shadow: 
    0 8px 32px rgba(0,0,0,.12),
    0 2px 8px rgba(139,69,19,.1),
    inset 0 1px 0 rgba(255,255,255,.15);
}

/* Table of Contents */
.toc {
  max-height: calc(100vh - 150px);
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-width: thin;
  scrollbar-color: var(--bronze) transparent;
}

.toc::-webkit-scrollbar {
  width: 6px;
}

.toc::-webkit-scrollbar-track {
  background: transparent;
}

.toc::-webkit-scrollbar-thumb {
  background: var(--bronze);
  border-radius: 3px;
}

.toc::-webkit-scrollbar-thumb:hover {
  background: var(--gold);
}

/* ─────────────────────────── Enhanced TOC Styling ─────────────────────────── */
.toc h4 {
  margin: 8px 10px 12px;
  color: var(--bronze);
  text-transform: uppercase;
  font-size: 13px;
  letter-spacing: 0.15em;
  font-weight: 700;
  font-family: 'Cinzel', serif;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
  position: relative;
  padding-bottom: 6px;
  text-align: center;
}

.toc h4::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 2px;
  background: linear-gradient(90deg, var(--bronze), transparent);
  border-radius: 1px;
}

/* Hierarchical TOC Sections */
.toc-section {
  margin-bottom: 8px;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid rgba(139,69,19,0.1);
  background: linear-gradient(135deg, 
    rgba(255,248,220,0.3) 0%, 
    rgba(212,175,55,0.05) 100%);
}

.toc-section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 12px;
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.15) 0%, 
    rgba(139,69,19,0.08) 100%);
  cursor: pointer;
  transition: all var(--transition-normal);
  border-bottom: 1px solid rgba(139,69,19,0.1);
}

.toc-section-header:hover {
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.25) 0%, 
    rgba(139,69,19,0.15) 100%);
  transform: translateY(-1px);
}

.toc-section-title {
  font-weight: 600;
  font-family: 'Cinzel', serif;
  color: var(--bronze);
  font-size: 14px;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
}

.toc-section-toggle {
  color: var(--bronze);
  font-size: 12px;
  transition: transform var(--transition-normal);
  opacity: 0.7;
}

.toc-section.collapsed .toc-section-toggle {
  transform: rotate(-90deg);
}

.toc-section-content {
  padding: 6px;
  max-height: none; /* Permettre l'expansion automatique par défaut */
  overflow: visible;
  transition: max-height var(--transition-normal), opacity var(--transition-normal);
}

.toc-section-content .toc-category {
  /* Remove scroll limits - let everything be visible naturally */
  max-height: none;
  overflow: visible;
}

.toc-section.collapsed .toc-section-content {
  max-height: 0 !important;
  opacity: 0 !important;
  padding-top: 0;
  padding-bottom: 0;
  overflow: hidden;
}
.toc a {
  display: flex;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 12px;
  color: inherit;
  border: 2px solid transparent;
  transition: all var(--transition-normal);
  position: relative;
  overflow: hidden;
  font-weight: 500;
  margin: 2px 0;
  backdrop-filter: blur(1px);
}
.toc a::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, 
    transparent, 
    rgba(212,175,55,.2), 
    rgba(139,69,19,.1), 
    transparent);
  transition: left 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  z-index: 0;
}
.toc a:hover {
  transform: translateX(6px) scale(1.02);
  background: 
    linear-gradient(135deg, rgba(212,175,55,.12), rgba(139,69,19,.08));
  border-color: rgba(139,69,19,.4);
  box-shadow: 
    0 6px 20px rgba(139,69,19,.2),
    inset 0 1px 3px rgba(212,175,55,.25),
    inset 0 -1px 1px rgba(139,69,19,.1);
  color: var(--accent-ink);
}

.toc a:hover::before {
  left: 100%;
}
.toc a > *{position:relative; z-index:1}
.toc a.active {
  background: linear-gradient(135deg, 
    rgba(212,175,55,.18), 
    rgba(139,69,19,.12));
  border-color: var(--gold);
  box-shadow: 
    inset 0 2px 6px rgba(212,175,55,.3),
    inset 0 -1px 2px rgba(139,69,19,.2),
    0 2px 8px rgba(139,69,19,.1);
  transform: translateX(4px) scale(1.01);
  color: var(--accent-ink);
  font-weight: 600;
}
.toc-category{margin:0}
.toc-category > a{position:relative; cursor:pointer}
.toc-category > a::after{content:'▼'; position:absolute; right:8px; top:50%; transform:translateY(-50%); 
                         font-size:10px; transition:transform .3s ease; color:var(--bronze)}
.toc-category.collapsed > a::after{transform:translateY(-50%) rotate(-90deg)}
.toc-sub{margin-left:24px;border-left:2px solid var(--rule);padding-left:8px; 
         overflow:hidden; transition:all .3s ease}
.toc-category.collapsed .toc-sub{max-height:0; opacity:0; padding-top:0; padding-bottom:0; margin-top:0; margin-bottom:0}
.toc-category:not(.collapsed) .toc-sub{max-height: none; opacity:1}
.toc-sub a{font-size:14px;padding:6px 8px; margin-left:4px}
.toc-sub a:hover{transform:translateX(6px); margin-left:0}

/* Outils latéraux */
.tools{display:flex;gap:var(--space-md);flex-wrap:wrap;margin:var(--space-md) 0}

/* Article and section layout */
article{display:none}
article.active{display:block}
section{background:var(--card);border:1px solid var(--rule);border-radius:14px;box-shadow:var(--shadow);padding:18px;margin:0 0 14px}

/* Footer */
footer{padding:24px;text-align:center;color:var(--paper-muted)}

/* Print styles */
@media print{ 
  .sidebar, .tools{display:none} 
  .page{grid-template-columns:1fr;padding:0} 
  section{break-inside:avoid;box-shadow:none} 
}

/* ─────────────────────────── Enhanced Mobile & Tablet Responsiveness ─────────────────────────── */

/* Tablet Landscape (1024px and below) */
@media (max-width: 1024px) {
  .sidebar {
    width: 320px;
  }
  
  .page {
    padding-left: 340px;
  }
  
  #views {
    margin-left: 340px; /* Adjust for smaller sidebar */
    margin-right: 0;
    max-width: 100%;
    padding: 0 var(--space-md);
  }
}

/* Tablet Portrait (768px and below) */
@media (max-width: 768px) {
  #views {
    margin-left: 0; /* Reset margins for tablet portrait */
    margin-right: 0;
  }
  
  .illus .thumb { 
    width: 100%; 
    max-width: 280px; 
    height: auto; 
  }
  
  .card, .card-base {
    margin: 1rem 0;
    padding: 16px;
  }
  
  .btn-base {
    padding: var(--space-sm) var(--space-md);
    font-size: 0.9em;
  }
  
  .filter-chips {
    gap: 0.5rem;
  }
  
  .filter-chip {
    padding: 6px 12px;
    font-size: 0.85em;
  }
}

/* Mobile (480px and below) - Standalone Version Optimized */
@media (max-width: 480px) {
  .page {
    padding: 8px;
  }
  
  #views {
    padding: 0 var(--space-sm);
  }
  
  .panel {
    margin: 8px;
    padding: 12px;
    border-radius: 12px;
  }
  
  .card, .card-base {
    padding: 12px;
    margin: 0.8rem 0;
    border-radius: 12px;
  }
  
  .spell-title {
    font-size: clamp(1rem, 3vw, 1.2rem) !important;
    margin: 0 0 0.8rem 0 !important;
  }
  
  .btn-base {
    padding: var(--space-sm);
    font-size: 0.85em;
    gap: var(--space-sm);
  }
  
  .filter-chips {
    gap: 0.4rem;
  }
  
  .filter-chip {
    padding: 4px 8px;
    font-size: 0.8em;
    border-radius: 16px;
  }
  
  /* Mobile-optimized images */
  .illus img {
    max-width: 100% !important;
    width: auto !important;
    height: auto !important;
  }
  
  .illus-spell img,
  .card .illus img {
    max-width: 240px !important;
    max-height: 180px !important;
  }
  
  /* Mobile TOC enhancements */
  .toc a {
    padding: 8px 10px;
    font-size: 0.9em;
  }
  
  .toc-sub a {
    padding: 6px 8px;
    font-size: 0.85em;
  }
  
  /* Mobile search optimizations */
  .searchbar {
    flex-direction: column;
    gap: var(--space-sm);
  }
  
  .searchbar input {
    width: 100%;
    font-size: 16px; /* Prevents zoom on iOS */
  }
  
  .search-results-grid {
    grid-template-columns: 1fr;
    gap: var(--space-md);
  }
  
  .search-result-card {
    min-height: 120px;
    padding: var(--space-md);
  }
}
/* ═══════════════════════════════════════════════════════════════════════════════════════
   🎨 COMPONENT SYSTEM - Modern Heroic Fantasy Design
   ═══════════════════════════════════════════════════════════════════════════════════════ */

/* ─────────────────────────── Typography Components ─────────────────────────── */
.spell-title {
  font-family: "Cinzel", serif !important;
  font-size: clamp(1.2rem, 2.5vw, 1.4rem) !important;
  background: linear-gradient(135deg, var(--gold), var(--bronze), var(--gold)) !important;
  -webkit-background-clip: text !important;
  -webkit-text-fill-color: transparent !important;
  background-clip: text !important;
  font-weight: 600 !important;
  text-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
  letter-spacing: 0.8px !important;
  text-transform: uppercase !important;
  text-align: center !important;
  margin: 0 0 1rem 0 !important;
  position: relative !important;
}

.spell-title::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 60px;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--gold), transparent);
  opacity: 0.7;
}

/* ─────────────────────────── Page Header Components ─────────────────────────── */
.page-header {
  text-align: center;
  margin: 2rem auto;
  max-width: 1200px;
  padding: 0 var(--space-lg);
}

.page-header h1 {
  color: var(--gold);
  font-family: "Cinzel", serif;
  font-size: 2.5rem;
  margin-bottom: 1rem;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}

/* Content centering for all page types */
.page-content {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 var(--space-lg);
}

/* Fallback centering for collections and similar content without specific containers */
.editable-section {
  max-width: 1200px;
  margin-left: auto;
  margin-right: auto;
}

/* ─────────────────────────── Collections Page Components ─────────────────────────── */
.collections-search {
  margin: 2rem auto;
  text-align: center;
  max-width: 1200px;
  padding: 0 var(--space-lg);
}

.search-container {
  display: flex;
  gap: 1rem;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
}

.search-input {
  padding: 12px 16px;
  font-size: 1.1rem;
  border: 2px solid var(--bronze);
  border-radius: 8px;
  background: var(--card);
  color: var(--text);
  min-width: 300px;
  font-family: "Source Serif Pro", serif;
}

.search-input:focus {
  outline: none;
  border-color: var(--gold);
  box-shadow: 0 0 8px rgba(212, 175, 55, 0.3);
}

.search-button {
  padding: 12px 20px;
  background: linear-gradient(135deg, var(--gold), var(--bronze));
  color: var(--dark-text);
  border: none;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  font-size: 1rem;
  transition: all 0.3s ease;
}

.search-button:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(212, 175, 55, 0.4);
}

.collections-grid {
  display: grid;
  gap: 1.5rem; /* Balanced gap */
  margin: 2rem auto;
  max-width: 1400px; /* More space = more columns possible */
  justify-content: center;
  
  /* Use auto-fit with smaller minmax - collections can be smaller */
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
}

.collection-card {
  background: var(--card);
  border: 2px solid var(--bronze);
  border-radius: 12px;
  padding: 1.5rem;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  width: 100%; /* Take full column width */
  margin: 0; /* No margin, use grid gap */
  box-sizing: border-box; /* Include padding and border in width */
}

.collection-card:hover {
  transform: translateY(-2px);
  border-color: var(--gold);
  box-shadow: 0 8px 20px rgba(212, 175, 55, 0.2);
}

.collection-icon {
  font-size: 3rem;
  margin-bottom: 1rem;
}

.collection-card h3 {
  color: var(--gold);
  font-family: "Cinzel", serif;
  margin: 0.5rem 0;
  font-size: 1.3rem;
}

.collection-card p {
  color: var(--text-muted);
  font-size: 0.95rem;
  line-height: 1.4;
  margin: 0;
}

.collection-error {
  background: linear-gradient(135deg, #fee2e2 0%, #fef2f2 100%);
  border: 2px solid #f87171;
  border-radius: 12px;
  padding: 2rem;
  text-align: center;
  margin: 1rem 0;
  animation: fadeIn 0.5s ease;
}

.collection-error h2 {
  color: #dc2626;
  font-family: "Cinzel", serif;
  margin: 0 0 1rem 0;
  font-size: 1.5rem;
}

.collection-error p {
  color: #7f1d1d;
  font-size: 1rem;
  line-height: 1.6;
  margin: 0.5rem 0;
}

.collection-error strong {
  color: #b91c1c;
  font-weight: 600;
}

/* Collection Development Controls */
.collection-dev-controls {
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid var(--bronze);
  display: flex;
  gap: 0.5rem;
  justify-content: center;
}

.collection-dev-actions {
  text-align: center;
  margin: 1rem 0;
}

.edit-object-btn {
  background: var(--gold);
  color: var(--bg);
  border: none;
  padding: 0.4rem 0.8rem;
  border-radius: 6px;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.edit-object-btn:hover {
  background: #c9a96e;
  transform: translateY(-1px);
}

.delete-object-btn {
  background: #ef4444;
  color: white;
  border: none;
  padding: 0.4rem 0.8rem;
  border-radius: 6px;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.delete-object-btn:hover {
  background: #dc2626;
  transform: translateY(-1px);
}

.remove-from-collection-btn {
  background: #f59e0b;
  color: white;
  border: none;
  padding: 0.4rem 0.8rem;
  border-radius: 6px;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.remove-from-collection-btn:hover {
  background: #d97706;
  transform: translateY(-1px);
}

.add-object-btn {
  background: #10B981;
  color: white;
  border: none;
  padding: 0.6rem 1rem;
  border-radius: 8px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
  font-weight: 500;
}

.add-object-btn:hover {
  background: #059669;
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
}

/* New collection card styling */
.new-collection-card {
  border: 2px dashed var(--bronze) !important;
  background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%) !important;
}

.new-collection-card:hover {
  border-color: var(--gold) !important;
  background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%) !important;
}

.create-collection-btn {
  background: var(--gold);
  color: var(--bg);
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 6px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
  font-weight: 500;
  margin-top: 0.5rem;
}

.create-collection-btn:hover {
  background: #c9a96e;
  transform: translateY(-1px);
}

/* Hide dev controls in dev-off mode */
body.dev-off .collection-dev-controls,
body.dev-off .collection-dev-actions,
body.dev-off .new-collection-card {
  display: none !important;
}

.collection-results {
  margin: 2rem 0;
}

.collection-header {
  text-align: center;
  margin-bottom: 2rem;
  padding: 1.5rem;
  background: var(--accent-bg);
  border-radius: 12px;
  border: 2px solid var(--gold);
}

.collection-header h2 {
  color: var(--gold);
  font-family: "Cinzel", serif;
  margin: 0 0 0.5rem 0;
  font-size: 1.8rem;
}

.back-button {
  background: var(--secondary-bg);
  color: var(--text);
  border: 1px solid var(--bronze);
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.9rem;
  margin-top: 1rem;
  transition: all 0.3s ease;
}

.back-button:hover {
  background: var(--bronze);
  color: white;
}

.tag-filters {
  margin: 1.5rem 0;
  text-align: center;
}

.tag-filters h3 {
  color: var(--text);
  font-family: "Cinzel", serif;
  margin-bottom: 1rem;
  font-size: 1.2rem;
}

.tag-buttons {
  display: flex;
  gap: 0.5rem;
  justify-content: center;
  flex-wrap: wrap;
}

.tag-filter-btn {
  padding: 8px 16px;
  background: var(--secondary-bg);
  color: var(--text);
  border: 1px solid var(--bronze);
  border-radius: 20px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: all 0.3s ease;
}

.tag-filter-btn:hover,
.tag-filter-btn.active {
  background: var(--gold);
  color: var(--dark-text);
  border-color: var(--gold);
}

.collection-items {
  display: grid;
  gap: 1.5rem; /* Balanced gap */
  margin: 2rem auto;
  max-width: 1400px; /* More space = more columns possible */
  justify-content: center;
  
  /* Use auto-fit with smaller minmax to allow more columns */
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
}

/* Consistent sizing for object cards within collections */
.collection-items .card {
  width: 100%; /* Take full column width */
  margin: 0; /* Remove default margin, use grid gap instead */
  box-sizing: border-box; /* Include padding and border in width calculation */
}

/* Objects page container optimization for better space usage */
#objets-container {
  display: grid;
  gap: 1.5rem;
  justify-content: center;
  align-items: start;
  padding: 0;
  margin: 2rem auto;
  max-width: 1400px; /* Increase max width for better space usage */
  
  /* Responsive grid: 1 to 4 objects per row based on screen size */
  grid-template-columns: 1fr;
}

/* 2 objects per row on small tablets */
@media (min-width: 640px) {
  #objets-container {
    grid-template-columns: repeat(2, 1fr);
  }
}

/* 3 objects per row on tablets/small desktop */
@media (min-width: 960px) {
  #objets-container {
    grid-template-columns: repeat(3, 1fr);
  }
}

/* 4 objects per row on large desktop */
@media (min-width: 1280px) {
  #objets-container {
    grid-template-columns: repeat(4, 1fr);
  }
}

/* 5 objects per row on extra large desktop */
@media (min-width: 1600px) {
  #objets-container {
    grid-template-columns: repeat(5, 1fr);
    max-width: 1600px;
  }
}

/* Object cards sizing optimization */
#objets-container .card {
  min-width: 280px;
  max-width: 350px;
  width: 100%;
  margin: 0; /* Remove default margin, use grid gap instead */
}

/* Mobile optimization for objects page */
@media (max-width: 640px) {
  #objets-container {
    padding: 0 1rem;
    gap: 1rem;
  }
  
  #objets-container .card {
    min-width: auto;
    max-width: none;
  }
}

/* ─────────────────────────── Card System Enhanced - Authentic Parchment ─────────────────────────── */
.card,
.card-base {
  background: 
    var(--parchment-texture),
    var(--aged-paper),
    var(--card);
  border: 3px solid transparent;
  border-image: var(--parchment-border) 1;
  border-radius: 16px;
  box-shadow: 
    0 8px 32px rgba(139,69,19,.2),
    0 2px 8px rgba(139,69,19,.15),
    inset 0 1px 0 rgba(255,255,255,.2),
    inset 0 -1px 0 rgba(139,69,19,.08);
  padding: 20px;
  position: relative;
  overflow: hidden;
  transition: all var(--transition-normal);
  backdrop-filter: blur(1px);
}

.card::before,
.card-base::before {
  content: '';
  position: absolute;
  top: 2px;
  left: 2px;
  right: 2px;
  bottom: 2px;
  border: 1px solid rgba(139,69,19,.15);
  border-radius: 13px;
  pointer-events: none;
}

.card::after,
.card-base::after {
  content: '';
  position: absolute;
  top: 4px;
  left: 4px;
  right: 4px;
  height: 2px;
  background: 
    radial-gradient(ellipse at center, rgba(212,175,55,.3) 0%, transparent 60%),
    linear-gradient(90deg, transparent, rgba(139,69,19,.2), transparent);
  opacity: .6;
}

.card:hover,
.card-base:hover {
  transform: translateY(-3px) scale(1.01);
  box-shadow: 
    0 16px 48px rgba(139,69,19,.25),
    0 6px 16px rgba(139,69,19,.18),
    inset 0 1px 0 rgba(255,255,255,.3),
    inset 0 -1px 0 rgba(139,69,19,.12);
}

/* ─────────────────────────── Button System Enhanced ─────────────────────────── */
.btn-base {
  display: inline-flex;
  gap: var(--space-md);
  align-items: center;
  background: linear-gradient(135deg, var(--card), rgba(244,240,230,0.8));
  border: 2px solid var(--rule);
  border-radius: 12px;
  padding: var(--space-md) var(--space-lg);
  box-shadow: 
    0 4px 16px rgba(0,0,0,.08),
    0 2px 4px rgba(139,69,19,.1),
    inset 0 1px 0 rgba(255,255,255,.2);
  cursor: pointer;
  transition: all var(--transition-fast);
  font-weight: 500;
  font-family: "Source Serif Pro", serif;
  text-transform: capitalize;
  position: relative;
  overflow: hidden;
}

.btn-base::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(212,175,55,.15), transparent);
  transition: left var(--transition-normal);
}

.btn-base:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow: 
    0 8px 32px rgba(0,0,0,.15),
    0 4px 8px rgba(139,69,19,.12),
    inset 0 1px 0 rgba(255,255,255,.3);
  border-color: var(--bronze);
}

.btn-base:hover::before {
  left: 100%;
}

.btn-base:active {
  transform: translateY(-1px) scale(1.01);
  transition: all 0.1s ease;
}

.btn-small {
  padding: var(--space-sm) var(--space-md);
  font-size: 0.9em;
}

/* ─────────────────────────── Card Variants ─────────────────────────── */
.card-enhanced {
  margin: 1.5rem 0;
  animation: cardEntry 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.card.spell-card {
  border-left: 4px solid var(--feu);
  background: linear-gradient(135deg, var(--card), rgba(255,107,53,0.02));
}

.card.don-card {
  border-left: 4px solid var(--bronze);
  background: linear-gradient(135deg, var(--card), rgba(205,127,50,0.02));
}

.card.class-card {
  border-left: 4px solid var(--gold);
  background: linear-gradient(135deg, var(--card), rgba(212,175,55,0.02));
}

@keyframes cardEntry {
  0% {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* ─────────────────────────── Enhanced Tags & Filters ─────────────────────────── */
.tag-filters {
  margin: 1.5rem 0;
  padding: 1.5rem;
  background: 
    linear-gradient(135deg, var(--card), rgba(244,240,230,0.9)),
    radial-gradient(circle at 20% 50%, rgba(212,175,55,0.05), transparent),
    radial-gradient(circle at 80% 50%, rgba(139,69,19,0.03), transparent);
  border: 2px solid var(--rule);
  border-radius: 16px;
  box-shadow: 
    0 4px 20px rgba(0,0,0,.08),
    inset 0 1px 0 rgba(255,255,255,.1);
  position: relative;
  overflow: hidden;
}

.tag-filters::before {
  content: '🏷️ Filtres';
  position: absolute;
  top: -1px;
  left: 20px;
  background: var(--card);
  padding: 4px 12px;
  font-size: 0.85em;
  font-weight: 600;
  color: var(--bronze);
  border: 2px solid var(--rule);
  border-top: none;
  border-radius: 0 0 8px 8px;
  font-family: "Cinzel", serif;
}

.filter-chips {
  display: flex;
  gap: 0.75rem;
  flex-wrap: wrap;
  margin-top: 0.5rem;
}

.filter-chip {
  padding: 8px 16px;
  background: linear-gradient(135deg, var(--bronze), rgba(205,127,50,0.9));
  color: white;
  border-radius: 20px;
  font-size: 0.9em;
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition-fast);
  border: 2px solid transparent;
  box-shadow: 
    0 2px 8px rgba(0,0,0,.1),
    inset 0 1px 0 rgba(255,255,255,.2);
  position: relative;
  overflow: hidden;
}

.filter-chip::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,.2), transparent);
  transition: left var(--transition-fast);
}

.filter-chip:hover {
  background: linear-gradient(135deg, var(--gold), rgba(212,175,55,0.9));
  transform: translateY(-2px) scale(1.05);
  box-shadow: 
    0 6px 20px rgba(0,0,0,.15),
    inset 0 1px 0 rgba(255,255,255,.3);
}

.filter-chip:hover::before {
  left: 100%;
}

.filter-chip.active {
  background: linear-gradient(135deg, var(--accent-ink), rgba(74,44,23,0.9));
  border-color: var(--gold);
  transform: scale(1.02);
  box-shadow: 
    0 4px 16px rgba(0,0,0,.2),
    inset 0 1px 0 rgba(255,255,255,.1);
}

.tag-chip {
  display: inline-block;
  padding: 2px 8px;
  background: var(--bronze);
  color: white;
  border-radius: 8px;
  font-size: 0.8em;
  font-weight: 500;
  margin: 2px;
}

/* Gestionnaire de filtres */
.filter-manager-btn {
  background: var(--bronze) !important;
  color: white !important;
}

.filter-manager-btn:hover {
  background: var(--accent) !important;
}

.modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);z-index:999999;display:flex;align-items:center;justify-content:center}
.modal-base{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);z-index:99999;display:none;align-items:center;justify-content:center}
.modal-base.visible{display:flex}
.modal-content-base{background:var(--card);border:2px solid var(--rule);border-radius:16px;padding:var(--space-2xl);box-shadow:var(--shadow);position:relative}

/* Legacy Cards - Enhanced with Modern Styling */
.card{
  border:2px solid var(--rule);
  border-radius:16px;
  padding:20px;
  background:linear-gradient(145deg, #faf7f0, var(--card), #f8f4e8);
  box-shadow:
    0 8px 32px rgba(0,0,0,.12),
    0 2px 8px rgba(139,69,19,.08),
    inset 0 1px 0 rgba(255,255,255,.1);
  position:relative;
  overflow:hidden;
  transition: all var(--transition-normal);
  backdrop-filter: blur(1px);
}

.card::before{
  content:'';
  position:absolute;
  top:0;
  left:0;
  right:0;
  height:3px;
  background:linear-gradient(90deg, transparent, var(--gold), var(--bronze), var(--gold), transparent);
  opacity:.8;
}

.card::after{
  content:'';
  position:absolute;
  bottom:0;
  left:0;
  right:0;
  height:1px;
  background:linear-gradient(90deg, transparent, var(--bronze), transparent);
  opacity:.5;
}

.card:hover {
  transform: translateY(-2px);
  box-shadow: 
    0 12px 48px rgba(0,0,0,.15),
    0 4px 12px rgba(139,69,19,.12),
    inset 0 1px 0 rgba(255,255,255,.15);
  border-color: var(--gold);
}
.card ul, ul{padding-left:35px !important;margin-left:0 !important}

/* Buttons */
.btn{display:inline-flex;gap:var(--space-md);align-items:center;background:var(--card);border:2px solid var(--rule);border-radius:12px;padding:var(--space-md) var(--space-lg);box-shadow:var(--card-shadow);cursor:pointer;
     transition:var(--transition-fast); font-weight:500}
.btn:hover{transform:translateY(-1px); box-shadow:0 8px 25px rgba(0,0,0,.15); border-color:var(--bronze)}
.btn.small{padding:var(--space-sm) var(--space-md)}

/* Search bar */
.searchbar{display:flex;gap:var(--space-md);align-items:center}
.searchbar input{flex:1 1 auto;max-width:100%;height:38px;font-size:15px;padding:var(--space-md) 10px;border-radius:10px;border:1px solid var(--rule);background:#fff6e8;color:inherit}
.searchbar button{height:38px}

/* Search results */
.search-results-container {
  font-size: 14px;
  line-height: 1.4;
}

.search-results-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: var(--gold);
  color: #4a4a4a;
  font-weight: 500;
  border-bottom: 1px solid var(--bronze);
}

.search-close {
  background: none;
  border: none;
  font-size: 16px;
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 4px;
  transition: background-color 0.2s;
}

.search-close:hover {
  background: rgba(0,0,0,0.1);
}

.search-results-list {
  max-height: 320px;
  overflow-y: auto;
}

.search-result-item {
  padding: 10px 12px;
  border-bottom: 1px solid #f0f0f0;
  cursor: pointer;
  transition: background-color 0.2s;
}

.search-result-item:hover {
  background: #f8f4e8;
}

.search-result-item:last-child {
  border-bottom: none;
}

.search-result-summary {
  font-weight: 500;
  color: #333;
  margin-bottom: 2px;
}

.search-result-category {
  font-size: 12px;
  color: #666;
  opacity: 0.8;
}

.search-no-results {
  padding: 20px;
  text-align: center;
  color: #666;
}

.search-no-results p {
  margin: 0;
  font-style: italic;
}

/* Search results page */
.search-page {
  padding: var(--space-lg);
}

.search-page-header {
  margin-bottom: var(--space-xl);
  text-align: center;
  border-bottom: 2px solid var(--rule);
  padding-bottom: var(--space-lg);
}

.search-page-header h1 {
  color: var(--gold);
  margin-bottom: var(--space-md);
  font-family: var(--font-title);
}

.search-results-count {
  color: #666;
  margin-bottom: var(--space-lg);
  font-style: italic;
}

.search-results-grid {
  display: grid;
  gap: var(--space-lg);
  max-width: 800px;
  margin: 0 auto;
  grid-template-columns: 1fr;
}

.search-result-card {
  cursor: pointer;
  transition: all 0.2s ease;
  border: 2px solid var(--rule);
  background: var(--card);
  padding: var(--space-lg);
  border-radius: 14px;
  box-shadow: var(--card-shadow);
  /* Force visibility */
  display: block !important;
  visibility: visible !important;
  opacity: 1 !important;
  min-height: 150px;
}

.search-result-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(0,0,0,0.15);
  border-color: var(--bronze);
}

.search-result-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: var(--space-md);
}

.search-result-header h3 {
  margin: 0;
  color: var(--bronze);
  font-size: 1.2em;
  text-align: center;
}

.search-result-type {
  background: var(--gold);
  color: #4a4a4a;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 0.8em;
  font-weight: 500;
}

.search-result-content {
  margin-bottom: var(--space-lg);
}

.search-result-summary {
  font-weight: 500;
  margin-bottom: var(--space-md);
  color: #333;
  font-size: 1.05em;
  padding: var(--space-sm);
  background: linear-gradient(90deg, var(--gold), transparent);
  border-radius: 4px;
  opacity: 0.9;
}

.search-result-category {
  font-size: 0.9em;
  color: #666;
  margin-bottom: var(--space-md);
}

.search-result-preview {
  background: #f8f4e8;
  padding: var(--space-md);
  border-radius: 8px;
  border-left: 3px solid var(--bronze);
}

.preview-field {
  margin-bottom: var(--space-sm);
  line-height: 1.4;
  font-size: 0.9em;
  padding: var(--space-sm);
  background: rgba(0,0,0,0.02);
  border-left: 3px solid var(--gold);
  border-radius: 0 4px 4px 0;
}

.preview-field:last-child {
  margin-bottom: 0;
}

.preview-field strong {
  color: var(--bronze);
  font-weight: 600;
}

.search-result-footer {
  text-align: right;
  padding-top: var(--space-md);
  border-top: 1px solid #eee;
}

.search-result-btn {
  background: var(--bronze);
  color: white;
  border-color: var(--bronze);
}

.search-result-btn:hover {
  background: #b8860b;
  border-color: #b8860b;
}

/* Force search results visibility */
.search-page .search-results-grid .search-result-card {
  display: block !important;
  visibility: visible !important;
  opacity: 1 !important;
  height: auto !important;
  min-height: 150px !important;
  background: var(--card) !important;
  border: 2px solid var(--bronze) !important;
  margin-bottom: var(--space-lg) !important;
}

/* ─────────────────────────── Advanced Animations & Transitions ─────────────────────────── */

/* Page Transitions */
@keyframes pageSlideIn {
  0% {
    opacity: 0;
    transform: translateX(30px);
  }
  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes pageSlideInFromTop {
  0% {
    opacity: 0;
    transform: translateY(-20px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Content Animation */
article {
  animation: pageSlideIn 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

article.active {
  animation: pageSlideInFromTop 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

/* Staggered Entry Animation for Lists */
.staggered-entry > * {
  opacity: 0;
  animation: staggeredEntry 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}

.staggered-entry > *:nth-child(1) { animation-delay: 0.1s; }
.staggered-entry > *:nth-child(2) { animation-delay: 0.2s; }
.staggered-entry > *:nth-child(3) { animation-delay: 0.3s; }
.staggered-entry > *:nth-child(4) { animation-delay: 0.4s; }
.staggered-entry > *:nth-child(5) { animation-delay: 0.5s; }
.staggered-entry > *:nth-child(n+6) { animation-delay: 0.6s; }

@keyframes staggeredEntry {
  0% {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* Loading Animation */
@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.loading-shimmer {
  position: relative;
  overflow: hidden;
  background: linear-gradient(90deg, #f0f0f0, #e0e0e0, #f0f0f0);
  animation: shimmer 1.5s infinite linear;
}

.loading-shimmer::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
  animation: shimmer 1.5s infinite linear;
}

/* Floating Elements Animation */
@keyframes float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}

.floating {
  animation: float 3s ease-in-out infinite;
}

.floating:nth-child(2n) {
  animation-delay: 1s;
}

.floating:nth-child(3n) {
  animation-delay: 2s;
}

/* Pulse Animation for Important Elements */
@keyframes pulse {
  0%, 100% { 
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(212, 175, 55, 0.4);
  }
  50% { 
    transform: scale(1.02);
    box-shadow: 0 0 0 10px rgba(212, 175, 55, 0);
  }
}

.pulse-attention {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Text Glow Effect */
@keyframes textGlow {
  0%, 100% {
    text-shadow: 
      0 0 5px rgba(212, 175, 55, 0.2),
      0 0 10px rgba(212, 175, 55, 0.1);
  }
  50% {
    text-shadow: 
      0 0 10px rgba(212, 175, 55, 0.4),
      0 0 20px rgba(212, 175, 55, 0.2),
      0 0 30px rgba(212, 175, 55, 0.1);
  }
}

.text-glow {
  animation: textGlow 3s ease-in-out infinite;
}

/* Enhanced Hover Transitions */
.interactive-element {
  transition: 
    transform var(--transition-fast),
    box-shadow var(--transition-fast),
    background-color var(--transition-fast),
    border-color var(--transition-fast),
    color var(--transition-fast);
}

.interactive-element:hover {
  transform: translateY(-2px) scale(1.02);
}

/* Magical Sparkle Effect */
@keyframes sparkle {
  0%, 100% { opacity: 0; transform: scale(0); }
  50% { opacity: 1; transform: scale(1); }
}

.sparkle-effect::before {
  content: '✨';
  position: absolute;
  top: -5px;
  right: -5px;
  font-size: 0.8em;
  animation: sparkle 2s ease-in-out infinite;
  animation-delay: 0.5s;
}

.sparkle-effect::after {
  content: '⭐';
  position: absolute;
  bottom: -5px;
  left: -5px;
  font-size: 0.6em;
  animation: sparkle 2s ease-in-out infinite;
  animation-delay: 1.5s;
}

/* Smooth Content Transitions */
.content-transition {
  transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

.content-fade-in {
  animation: fadeInUp 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

@keyframes fadeInUp {
  0% {
    opacity: 0;
    transform: translateY(30px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Clean up card styling */

/* Illustrations */
.illus{display:flex;gap:12px;align-items:center;justify-content:center;flex-wrap:wrap;margin:.6rem 0}
.illus img{max-width:100%;height:auto;border-radius:12px; transition:all .3s ease}
.illus img.enlarged{transition:none !important}
.illus .thumb{max-width:500px;max-height:300px;width:auto;height:auto;object-fit:contain}

/* Images avec cadres - système unifié */
.illus-spell, .illus-class, .illus-subclass, .illus-don,
article[data-page="guerrier"] .illus,
article[data-page="mage"] .illus,
article[data-page="pretre"] .illus,
article[data-page="rodeur"] .illus,
article[data-page="enchanteur"] .illus,
.illus[data-illus-key^="class:"],
.illus[data-illus-key^="subclass:"],
.illus[data-illus-key^="spell:"],
.illus[data-illus-key^="sort:"],
.illus[data-illus-key^="spellcategory:"],
.illus[data-illus-key^="don:"] {
  display:flex !important; flex-direction:column !important; align-items:center !important;
  justify-content:center !important; margin:1rem auto !important;
}

.illus-spell img, .illus-class img, .illus-subclass img, .illus-don img,
article[data-page="guerrier"] .illus img,
article[data-page="mage"] .illus img,
article[data-page="pretre"] .illus img,
article[data-page="rodeur"] .illus img,
article[data-page="enchanteur"] .illus img,
.illus[data-illus-key^="class:"] img,
.illus[data-illus-key^="subclass:"] img,
.illus[data-illus-key^="spell:"] img,
.illus[data-illus-key^="sort:"] img,
.illus[data-illus-key^="spellcategory:"] img,
.illus[data-illus-key^="don:"] img {
  border:var(--image-border) !important; 
  box-shadow:var(--image-shadow) !important;
  padding:4px !important; 
  background:transparent !important;
  border-radius:16px !important; 
  max-width:fit-content !important;
  width:auto !important;
  cursor:pointer !important;
}

.illus-spell img:hover, .illus-class img:hover, .illus-subclass img:hover, .illus-don img:hover,
article[data-page="guerrier"] .illus img:hover,
article[data-page="mage"] .illus img:hover,
article[data-page="pretre"] .illus img:hover,
article[data-page="rodeur"] .illus img:hover,
article[data-page="enchanteur"] .illus img:hover,
.illus[data-illus-key^="class:"] img:hover,
.illus[data-illus-key^="subclass:"] img:hover,
.illus[data-illus-key^="spell:"] img:hover,
.illus[data-illus-key^="sort:"] img:hover,
.illus[data-illus-key^="spellcategory:"] img:hover,
.illus[data-illus-key^="don:"] img:hover {
  transform:scale(1.03) !important; 
  box-shadow:var(--image-shadow), 0 8px 25px rgba(139,69,19,.25) !important;
}

/* Variantes de taille d'images */
.illus-small img { max-width: 150px !important; }
.illus-large img { max-width: 400px !important; }

/* Style spécial pour les sorts - cadre doré et taille augmentée */
.illus-spell img,
.card .illus img {
  border: 3px solid var(--gold) !important;
  box-shadow: var(--image-shadow), 0 0 10px rgba(212,175,55,.3) !important;
  max-width: 350px !important;
  max-height: 250px !important;
  object-fit: contain !important;
}

/* Style spécial pour les sous-classes - 2 images centrées et collées */
.subclass-images {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0;
  margin: 0.6rem 0;
}

.subclass-images .illus {
  margin: 0;
  flex: 0 0 auto;
}

.subclass-images .illus img {
  max-width: 400px !important;
  max-height: 300px !important;
  object-fit: contain !important;
  border-radius: 12px 0 0 12px !important;
}

.subclass-images .illus:last-child img {
  border-radius: 0 12px 12px 0 !important;
}

/* Mobile: Stack subclass images vertically */
@media (max-width: 980px) {
  .subclass-images {
    flex-direction: column !important;
    gap: 8px !important;
  }
  
  .subclass-images .illus img {
    border-radius: 12px !important;
    max-width: 100% !important;
    width: 100% !important;
  }
  
  /* Réduire l'espace des cadres d'images sur mobile */
  .illus-spell img, .illus-class img, .illus-subclass img, .illus-don img,
  article[data-page="guerrier"] .illus img,
  article[data-page="mage"] .illus img,
  article[data-page="pretre"] .illus img,
  article[data-page="rodeur"] .illus img,
  article[data-page="enchanteur"] .illus img,
  .illus[data-illus-key^="class:"] img,
  .illus[data-illus-key^="subclass:"] img,
  .illus[data-illus-key^="spell:"] img,
  .illus[data-illus-key^="sort:"] img,
  .illus[data-illus-key^="spellcategory:"] img,
  .illus[data-illus-key^="don:"] img {
    padding: 2px !important; /* Réduire le padding de 4px à 2px */
    border-width: 2px !important; /* Réduire l'épaisseur des bordures */
    max-width: 100% !important;
    width: auto !important;
    height: auto !important;
    object-fit: contain !important;
  }
  
  /* Réduire l'espace entre les images de classe et sous-classe */
  .illus {
    gap: 4px !important; /* Réduire de 12px à 4px */
    margin: 0.3rem 0 !important; /* Réduire les marges */
  }
  
  /* Images de sorts plus compactes sur mobile */
  .illus-spell img,
  .card .illus img {
    max-width: 100% !important;
    max-height: 180px !important; /* Réduire de 250px à 180px */
    border-width: 2px !important; /* Bordure plus fine */
  }
  
  .subclass-images .illus:last-child img {
    border-radius: 12px !important;
  }
}

/* Style spécial pour les titres de sous-classes */
.subclass-title {
  font-size: 2.2rem !important;
  font-weight: 800 !important;
  text-align: center !important;
  margin: 0 0 1.5rem 0 !important;
  color: var(--accent-ink) !important;
  font-family: 'Cinzel', serif !important;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.2) !important;
  letter-spacing: 0.8px !important;
}

/* Style spécial pour les descriptions de sous-classes */
.card[data-section-type="subclass"] .editable[data-edit-section*="description"] {
  text-align: center !important;
  color: var(--paper-ink) !important;
}

.card[data-section-type="subclass"] .editable[data-edit-section*="description"] em,
.card[data-section-type="subclass"] .editable[data-edit-section*="description"] i {
  color: var(--paper-ink) !important;
}

/* ═══════════════════════════════════════════════════════════════════════════════════════
   📱 MOBILE & TOUCH OPTIMIZATION - Final Enhancements
   ═══════════════════════════════════════════════════════════════════════════════════════ */

/* Touch-friendly interactions for mobile devices */
@media (hover: none) and (pointer: coarse) {
  .btn-base, .filter-chip, .toc a, .card {
    min-height: 44px; /* iOS/Android minimum touch target */
    min-width: 44px;
  }
  
  .toc a {
    padding: 12px;
    margin: 4px 0;
  }
  
  .filter-chip {
    padding: 8px 16px;
    margin: 2px;
  }
  
  /* Disable hover effects on touch devices */
  .card:hover, .btn-base:hover, .filter-chip:hover, .toc a:hover {
    transform: none;
    box-shadow: initial;
    background: initial;
    border-color: initial;
  }
  
  /* Add tap feedback instead */
  .btn-base:active, .filter-chip:active, .toc a:active, .card:active {
    transform: scale(0.98);
    transition: transform 0.1s ease;
    opacity: 0.8;
  }
}

/* Reduce animation complexity on low-performance devices */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
  
  .floating, .pulse-attention, .text-glow, 
  .shimmer-effect, .sparkle-effect {
    animation: none !important;
  }
  
  .card, .btn-base, .filter-chip {
    transition: none !important;
  }
}

/* Mobile-specific improvements */
@media (max-width: 480px) {
  /* Improve text readability on small screens */
  body {
    font-size: 16px;
    line-height: 1.6;
    -webkit-text-size-adjust: 100%;
  }
  
  /* Ensure images don't break layout */
  img {
    max-width: 100% !important;
    height: auto !important;
  }
  
  /* Optimize cards for mobile */
  .card, .card-base {
    border-radius: 12px;
    box-shadow: 0 4px 16px rgba(0,0,0,.1);
  }
  
  /* Mobile-friendly buttons */
  .btn-base {
    border-radius: 8px;
    font-size: 16px; /* Prevent iOS zoom */
  }
  
  /* Improve modal sizing on mobile */
  .modal-content-base {
    margin: 10px;
    max-width: calc(100vw - 20px);
    max-height: calc(100vh - 20px);
    overflow-y: auto;
  }
  
  /* Mobile search optimization */
  .searchbar input {
    font-size: 16px; /* Prevents zoom on iOS */
    padding: 12px;
    border-radius: 8px;
  }
}

/* ═══════════════════════════════════════════════════════════════════════════════════════
   📄 SECTION SELECTION MODAL
   ═══════════════════════════════════════════════════════════════════════════════════════ */

.section-selection-modal {
  z-index: 999999 !important;
}

.section-selection-modal .modal-content {
  max-width: 500px;
  padding: 2rem;
}

.sections-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin: 1.5rem 0;
}

.section-option {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  border: 2px solid var(--rule);
  border-radius: 12px;
  cursor: pointer;
  transition: all var(--transition-normal);
  background: var(--card);
}

.section-option:hover {
  border-color: var(--bronze);
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.1) 0%, 
    rgba(139,69,19,0.05) 100%);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(139,69,19,0.15);
}

.section-option.selected {
  border-color: var(--gold);
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.2) 0%, 
    rgba(139,69,19,0.1) 100%);
  box-shadow: 
    0 0 0 2px rgba(212,175,55,0.3),
    0 4px 16px rgba(139,69,19,0.2);
}

.section-icon {
  font-size: 2rem;
  width: 60px;
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 12px;
  background: linear-gradient(135deg, var(--bronze), var(--gold));
  color: white;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
}

.section-info {
  flex: 1;
}

.section-title {
  font-weight: 600;
  font-size: 1.1em;
  color: var(--accent-ink);
  margin-bottom: 0.25rem;
  font-family: 'Cinzel', serif;
}

.section-description {
  color: var(--paper-muted);
  font-size: 0.9em;
  line-height: 1.4;
}

.page-details {
  padding: 1.5rem;
  background: var(--paper-soft);
  border: 1px solid var(--rule);
  border-radius: 12px;
  margin: 1rem 0;
}

.form-group {
  margin-bottom: 1rem;
}

.form-group:last-child {
  margin-bottom: 0;
}

.form-group label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 600;
  color: var(--accent-ink);
}

.form-group input {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid var(--rule);
  border-radius: 8px;
  font-size: 1em;
  background: var(--card);
  color: var(--paper-ink);
}

.form-group input:focus {
  outline: none;
  border-color: var(--bronze);
  box-shadow: 0 0 0 2px rgba(212,175,55,0.2);
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 1rem;
  margin-top: 1.5rem;
}

.btn-primary {
  background: var(--bronze) !important;
  color: white !important;
  border-color: var(--bronze) !important;
}

.btn-primary:hover {
  background: var(--gold) !important;
  border-color: var(--gold) !important;
}

/* Mobile optimization for section selection modal */
@media (max-width: 480px) {
  .section-selection-modal .modal-content {
    padding: 1rem;
    margin: 1rem;
  }
  
  .section-option {
    padding: 0.75rem;
    gap: 0.75rem;
  }
  
  .section-icon {
    width: 48px;
    height: 48px;
    font-size: 1.5rem;
  }
  
  .modal-actions {
    flex-direction: column;
  }
  
  .modal-actions .btn {
    width: 100%;
  }
}

/* ═══════════════════════════════════════════════════════════════════════════════════════
   🖨️ PRINT STYLES - États imprimables
   ═══════════════════════════════════════════════════════════════════════════════════════ */

.print-button {
  background: var(--bronze) !important;
  color: white !important;
  border: 2px solid var(--gold) !important;
  border-radius: 8px;
  padding: 0.5rem 1rem;
  font-family: "Cinzel", serif;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.print-button:hover {
  background: var(--gold) !important;
  border-color: var(--bronze) !important;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

/* Styles pour la version imprimable */
@media print {
  @page {
    margin: 0 !important;
    size: A4 !important;
  }
  
  html, body {
    font-family: "Times New Roman", serif !important;
    background: white !important;
    color: black !important;
    margin: 0 !important;
    padding: 0 !important;
    height: auto !important;
    overflow: visible !important;
  }
  
  .printable-states {
    display: block !important;
    padding: 15mm !important;
    margin: 0 !important;
    background: white !important;
    color: black !important;
    font-size: 10pt !important;
    line-height: 1.2 !important;
    width: 100% !important;
    height: auto !important;
    position: relative !important;
    top: 0 !important;
    left: 0 !important;
  }
  
  .printable-states h1 {
    font-size: 16pt !important;
    font-weight: bold !important;
    text-align: center !important;
    margin-bottom: 5mm !important;
    color: black !important;
    text-shadow: none !important;
    background: none !important;
    -webkit-text-fill-color: initial !important;
  }
  
  .printable-states-grid {
    display: grid !important;
    grid-template-columns: 1fr 1fr !important;
    gap: 3mm !important;
    margin: 0 !important;
  }
  
  .printable-state-item {
    background: white !important;
    border: 1pt solid #ccc !important;
    border-radius: 2mm !important;
    padding: 2mm !important;
    margin: 0 !important;
    page-break-inside: avoid !important;
    font-size: 9pt !important;
    line-height: 1.1 !important;
  }
  
  .printable-state-item h3 {
    font-size: 11pt !important;
    font-weight: bold !important;
    margin: 0 0 1mm 0 !important;
    color: black !important;
    text-shadow: none !important;
    background: none !important;
    -webkit-text-fill-color: initial !important;
  }
  
  .printable-state-item p {
    margin: 0.5mm 0 !important;
    color: black !important;
    font-size: 9pt !important;
  }
  
  /* Masquer les éléments de l'interface lors de l'impression */
  #sidebar, #views, .print-button, nav, header, footer, .edit-btn, .btn {
    display: none !important;
  }
  
  /* Afficher uniquement le contenu imprimable */
  .printable-states {
    display: block !important;
  }
  
  .printable-states-grid {
    display: grid !important;
  }
  
  .printable-state-item {
    display: block !important;
  }
  
  .printable-state-item h3 {
    display: block !important;
  }
  
  .printable-state-item div {
    display: block !important;
  }
}

/* ═══════════════════════════════════════════════════════════════════════════════════════
   🎵 AUDIO CONTROLS - Lecteur audio flottant
   ═══════════════════════════════════════════════════════════════════════════════════════ */

.audio-controls {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 1000;
  background: var(--card);
  border: 2px solid var(--bronze);
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.3);
  backdrop-filter: blur(10px);
  min-width: 280px;
  font-family: "Cinzel", serif;
}

.audio-panel {
  padding: 1rem;
}

.audio-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 0.75rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--rule);
}

.audio-icon {
  font-size: 1.2rem;
}

.audio-title {
  font-weight: 600;
  color: var(--gold);
  font-size: 0.9rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.audio-toggle-btn {
  background: none;
  border: none;
  font-size: 1.1rem;
  cursor: pointer;
  padding: 0.25rem;
  border-radius: 4px;
  transition: background 0.2s ease;
}

.audio-toggle-btn:hover {
  background: var(--rule);
}

.audio-info {
  margin-bottom: 0.75rem;
  text-align: center;
}

.playlist-name {
  font-weight: 600;
  color: var(--accent-ink);
  font-size: 0.85rem;
  margin-bottom: 0.25rem;
}

.track-name {
  font-size: 0.75rem;
  color: var(--paper-muted);
  font-style: italic;
}

.audio-controls-row {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  margin-bottom: 0.75rem;
}

.audio-btn {
  background: var(--bronze);
  border: 1px solid var(--gold);
  border-radius: 6px;
  padding: 0.5rem;
  cursor: pointer;
  font-size: 0.9rem;
  color: white;
  transition: all 0.2s ease;
  min-width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.audio-btn:hover {
  background: var(--gold);
  transform: translateY(-1px);
}

.audio-btn:active {
  transform: translateY(0);
}

.audio-volume-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.8rem;
}

.volume-icon {
  font-size: 0.9rem;
  min-width: 20px;
}

.volume-slider {
  flex: 1;
  height: 4px;
  background: var(--rule);
  border-radius: 2px;
  outline: none;
  -webkit-appearance: none;
  appearance: none;
}

.volume-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--bronze);
  cursor: pointer;
  border: 2px solid var(--gold);
}

.volume-slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--bronze);
  cursor: pointer;
  border: 2px solid var(--gold);
}

.volume-value {
  min-width: 35px;
  text-align: right;
  font-weight: 600;
  color: var(--accent-ink);
}

/* Responsive pour mobile */
@media (max-width: 480px) {
  .audio-controls {
    bottom: 10px;
    right: 10px;
    left: 10px;
    min-width: auto;
  }
  
  .audio-panel {
    padding: 0.75rem;
  }
  
  .audio-title {
    font-size: 0.8rem;
  }
  
  .audio-controls-row {
    gap: 0.75rem;
  }
  
  .audio-btn {
    min-width: 40px;
    height: 40px;
    font-size: 1rem;
  }
}

/* Masquer lors de l'impression */
@media print {
  .audio-controls {
    display: none !important;
  }
}

/* ═══════════════════════════════════════════════════════════════════════════════════════
   🔧 AUDIO PAGE CONTROLS - Boutons stables pour la page audio
   ═══════════════════════════════════════════════════════════════════════════════════════ */

.audio-control-btn {
  background: var(--bronze) !important;
  color: white !important;
  border: none !important;
  padding: 1rem 2rem !important;
  border-radius: 8px !important;
  cursor: pointer !important;
  font-family: "Cinzel", serif !important;
  font-size: 1rem !important;
  font-weight: 600 !important;
  text-transform: uppercase !important;
  letter-spacing: 0.5px !important;
  transition: none !important;
  min-width: 160px !important;
  min-height: 50px !important;
  user-select: none !important;
  -webkit-user-select: none !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  text-align: center !important;
}

.audio-control-btn:hover {
  background: var(--gold) !important;
  transform: none !important;
  box-shadow: none !important;
}

.audio-control-btn:active {
  background: var(--bronze) !important;
  transform: scale(0.98) !important;
}

.playlist-select-btn {
  background: var(--bronze) !important;
  color: white !important;
  border: none !important;
  padding: 1rem 1.5rem !important;
  border-radius: 6px !important;
  cursor: pointer !important;
  font-family: "Cinzel", serif !important;
  font-size: 0.95rem !important;
  font-weight: 600 !important;
  transition: none !important;
  min-width: 120px !important;
  min-height: 45px !important;
  user-select: none !important;
  -webkit-user-select: none !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  text-align: center !important;
}

.playlist-select-btn:hover {
  background: var(--gold) !important;
  transform: none !important;
  box-shadow: none !important;
}

.playlist-select-btn:active {
  transform: scale(0.98) !important;
}

/* Slider de volume amélioré */
#master-volume {
  -webkit-appearance: none !important;
  appearance: none !important;
  height: 6px !important;
  background: var(--rule) !important;
  border-radius: 3px !important;
  outline: none !important;
  cursor: pointer !important;
  transition: none !important;
}

#master-volume::-webkit-slider-thumb {
  -webkit-appearance: none !important;
  appearance: none !important;
  width: 20px !important;
  height: 20px !important;
  border-radius: 50% !important;
  background: var(--bronze) !important;
  cursor: pointer !important;
  border: 2px solid var(--gold) !important;
  transition: none !important;
}

#master-volume::-webkit-slider-thumb:hover {
  background: var(--gold) !important;
  border-color: var(--bronze) !important;
}

#master-volume::-moz-range-thumb {
  width: 20px !important;
  height: 20px !important;
  border-radius: 50% !important;
  background: var(--bronze) !important;
  cursor: pointer !important;
  border: 2px solid var(--gold) !important;
  transition: none !important;
}

#master-volume::-moz-range-thumb:hover {
  background: var(--gold) !important;
  border-color: var(--bronze) !important;
}


/* Editor and Dev Mode styles */

/* === HIDE ALL EDITING ELEMENTS IN STANDALONE MODE === */
/* Hide all editing elements when dev mode is OFF */

/* ULTRA NUCLEAR OPTION - Hide ALL editing buttons when dev mode is OFF */
/* This rule will override ANY other CSS that might be showing edit buttons */
body.dev-off button[title*="✏️"],
body.dev-off *[class*="edit"],
body.dev-off *[class*="Edit"],

body.dev-off button[data-category-name],
body.dev-off button[data-spell-name], 
body.dev-off button[data-don-name],
body.dev-off button[data-section-name],
body.dev-off button[data-section-type],
body.dev-off .btn:is([class*="add"], [class*="delete"], [class*="remove"], [class*="move"], [class*="edit"]),
body.dev-off .add-paragraph-btn,
body.dev-off .section-delete,
body.dev-off .spell-delete,
body.dev-off .don-delete,
body.dev-off .objet-delete,
body.dev-off .spell-category-delete,
body.dev-off .don-category-delete,
body.dev-off .objet-category-delete,
body.dev-off .don-move-up,
body.dev-off .don-move-down,
body.dev-off .remove-section-btn,
body.dev-off .illus .up,
body.dev-off .illus .rm,
body.dev-off .illus label.up,
body.dev-off .illus button.rm,
body.dev-off .illus label,
body.dev-off .illus input[type="file"],
body.dev-off button[class*="add"]:not(.menu-toggle),
body.dev-off button[class*="delete"],
body.dev-off button[class*="remove"],
body.dev-off button[class*="move"],
body.dev-off button[class*="edit"],
body.dev-off .spell-add,
body.dev-off .don-add,
body.dev-off .objet-add,
body.dev-off .category-add,
body.dev-off .add-*,
body.dev-off [data-bound] .up,
body.dev-off [data-bound] .rm,
body.dev-off [data-bound] label,
body.dev-off [data-bound] button,
body.dev-off .illus[data-bound] .up,
body.dev-off .illus[data-bound] .rm,
body.dev-off .illus[data-bound] label,
body.dev-off .illus[data-bound] button,
body.dev-off .illus[data-bound] input[type="file"],
body.dev-off [data-dev-only],
body.dev-off div[data-dev-only],
body.dev-off .dev-mode-buttons,
body.dev-off .manage-tags-btn,
body.dev-off .add-monster-btn,
body.dev-off button[data-content-type],
body.dev-off .tags-manager-btn,
body.dev-off .filter-manager-btn,
body.dev-off button[class*="tags"],
body.dev-off button[class*="manage"],
/* Specific button selectors */
body.dev-off button[data-category-name],
body.dev-off button[data-spell-name],
body.dev-off button[data-don-name],
body.dev-off button[data-section-name],
body.dev-off button[data-section-type],
/* Input file upload elements */
body.dev-off input[type="file"],
body.dev-off label[for*="file"],
/* Additional specific selectors */
body.dev-off .add-subclass-btn,
body.dev-off .add-new-section,
/* COMPREHENSIVE EDIT BUTTON HIDING */
body.dev-off .edit-btn,
body.dev-off .edit-title-btn,
body.dev-off .edit-paragraph-btn,
body.dev-off .edit-list-btn,
body.dev-off .edit-field-btn,
body.dev-off .edit-effect-btn,
body.dev-off .edit-stats-btn,
body.dev-off .edit-section-btn,
body.dev-off button.edit-btn,
body.dev-off button.edit-title-btn,
body.dev-off button.edit-paragraph-btn,
body.dev-off button.edit-list-btn,
body.dev-off button.edit-field-btn,
body.dev-off button.edit-effect-btn,
body.dev-off button.edit-stats-btn,
body.dev-off button.edit-section-btn,
body.dev-off .editable-section .edit-btn,
body.dev-off .editable-section button[class*="edit"],
body.dev-off .card .edit-btn,
body.dev-off .card button[class*="edit"],
body.dev-off .editable-item .edit-btn,
body.dev-off .editable-item button[class*="edit"],
body.dev-off [data-section-type] .edit-btn,
body.dev-off [data-section-type] button[class*="edit"],
body.dev-off .add-*-btn,
/* Very specific selectors for inline styled buttons */
body.dev-off button[style*="background: #ff6b6b"],
body.dev-off button[style*="background: var(--bronze)"],
body.dev-off button[style*="background: #dc2626"],
body.dev-off button[style*="background: var(--accent)"],
/* Target buttons by text content patterns */
body.dev-off .btn.small[data-category-name],
body.dev-off .btn.small[data-spell-name],  
body.dev-off .btn.small[data-don-name],
body.dev-off .btn.small[data-section-name],
body.dev-off .btn.small[data-don-index],
/* ULTRA FORCÉ - Cacher TOUS les boutons de gestion des tags */
/* ULTRA-SPECIFIC RULES FOR IMAGE UPLOAD BUTTONS */
body.dev-off .illus label.up,
body.dev-off .illus button.rm,
body.dev-off label:contains("📷"),
body.dev-off label:contains("Ajouter"),
body.dev-off button:contains("🗑"),
body.dev-off button:contains("Retirer"),
body.dev-off .card .illus .up,
body.dev-off .card .illus .rm,
body.dev-off .card .illus label,
body.dev-off .card .illus button,
body.dev-off .card [data-bound] .up,
body.dev-off .card [data-bound] .rm,
/* ULTRA-SPECIFIC RULES FOR OBJECTS PAGE */
body.dev-off article[data-page="objets"] .illus label.up,
body.dev-off article[data-page="objets"] .illus button.rm,
body.dev-off article[data-page="objets"] .card .illus label,
body.dev-off article[data-page="objets"] .card .illus button,
body.dev-off #objets-container .illus label.up,
body.dev-off #objets-container .illus button.rm,
body.dev-off #objets-container .card .illus label,
body.dev-off #objets-container .card .illus button,
/* RULES WITH DATA ATTRIBUTES FOR OBJECTS */
body.dev-off .card[data-type="objet"] .illus label.up,
body.dev-off .card[data-type="objet"] .illus button.rm,
body.dev-off .card[data-type="objet"] .illus label,
body.dev-off .card[data-type="objet"] .illus button,
body.dev-off .card[data-category="objets"] .illus label.up,
body.dev-off .card[data-category="objets"] .illus button.rm,
body.dev-off .card[data-category="objets"] .illus label,
body.dev-off .card[data-category="objets"] .illus button,
/* Collections d'objets page specific rules */
body.dev-off article[data-page="collections-objets"] .illus label.up,
body.dev-off article[data-page="collections-objets"] .illus button.rm,
body.dev-off article[data-page="collections-objets"] .illus label,
body.dev-off article[data-page="collections-objets"] .illus button,
body.dev-off #collection-items .illus label.up,
body.dev-off #collection-items .illus button.rm,
body.dev-off #collection-items .illus label,
body.dev-off #collection-items .illus button,
/* ULTRA-SPECIFIC RULES FOR TAG MANAGER BUTTONS */
body.dev-off button.manage-tags-btn,
body.dev-off button.tags-manager-btn,
body.dev-off .btn.manage-tags-btn,
body.dev-off .btn.tags-manager-btn,
body.dev-off button[data-content-type="monster"],
body.dev-off button[data-content-type="objet"],
body.dev-off button[data-content-type="tableTresor"],
body.dev-off .dev-mode-buttons button,
body.dev-off div[data-dev-only] button,
body.dev-off div[data-dev-only],
body.dev-off .btn.btn-small.manage-tags-btn,
body.dev-off button.btn.btn-small.manage-tags-btn,
body.dev-off .dev-mode-buttons .manage-tags-btn,
body.dev-off [data-dev-only] .manage-tags-btn,
body.dev-off .tableTresor-add,
body.dev-off .add-monster-btn,
body.dev-off .btn.add-monster-btn,
body.dev-off .tags-manager-btn,
body.dev-off .filter-manager-btn,
body.dev-off button[title*="Gérer les tags"],
body.dev-off button[title*="gérer les tags"],
body.dev-off button[onclick*="showTagsManagementModal"],
body.dev-off button[onclick*="showMonsterTagsManagement"],
/* Additional super specific selectors for any possible generated button */
html body.dev-off button.manage-tags-btn,
html body.dev-off button.tags-manager-btn,
html body.dev-off .btn.manage-tags-btn,
html body.dev-off .btn.tags-manager-btn,
/* Text content matching */
body.dev-off button:contains("🏷️ Gérer les tags"),
body.dev-off button:contains("Gérer les tags") {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  position: absolute !important;
  left: -9999px !important;
  width: 0 !important;
  height: 0 !important;
  overflow: hidden !important;
  pointer-events: none !important;
}

/* Styles for dev buttons container */
.dev-buttons-container {
  display: flex;
  gap: 8px;
  margin-bottom: 1rem;
  flex-wrap: wrap;
}

/* Hide dev buttons container completely in dev-off mode */
body.dev-off .dev-buttons-container,
body.dev-off div[data-dev-only] {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
}

/* Element selectors for spells and monsters - Solution ultra-forcée */
.spell-element-selector,
.spell-element-selector *,
div.spell-element-selector,
.card .spell-element-selector,
.monster-element-selector,
.monster-element-selector *,
div.monster-element-selector,
.card .monster-element-selector {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  position: absolute !important;
  left: -9999px !important;
  width: 0 !important;
  height: 0 !important;
  overflow: hidden !important;
}

/* Modal buttons should always be visible */
dialog .delete-monster-tag-btn,
dialog .btn,
dialog button {
  display: inline-flex !important;
  visibility: visible !important;
  opacity: 1 !important;
  pointer-events: auto !important;
  position: static !important;
  left: auto !important;
  width: auto !important;
  height: auto !important;
  overflow: visible !important;
}

/* SEULEMENT visible en mode dev */
body.dev-on .spell-element-selector,
body.dev-on .spell-element-selector *,
body.dev-on div.spell-element-selector,
body.dev-on .card .spell-element-selector,
body.dev-on .monster-element-selector,
body.dev-on .monster-element-selector *,
body.dev-on div.monster-element-selector,
body.dev-on .card .monster-element-selector {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  position: static !important;
  left: auto !important;
  width: auto !important;
  height: auto !important;
  overflow: visible !important;
}

body.dev-off .spell-element-display,
body.dev-off .monster-element-display {
  display: block !important;
}

body.dev-on .spell-element-display,
body.dev-on .monster-element-display {
  display: none !important;
}

/* COMPREHENSIVE SHOW RULES FOR DEV MODE - High specificity to override dev-off hiding */
body.dev-on .edit-btn,
body.dev-on button.edit-btn,
body.dev-on button[class*="edit"],
body.dev-on button[class*="add"]:not(.menu-toggle),
body.dev-on button[class*="delete"],
body.dev-on button[class*="remove"],
body.dev-on button[class*="move"],
body.dev-on .section-delete,
body.dev-on .spell-delete,
body.dev-on .don-delete,
body.dev-on .add-subclass-btn,
body.dev-on .delete-subclass-btn,
body.dev-on .add-paragraph-btn,
body.dev-on .remove-section-btn,
body.dev-on .illus .up,
body.dev-on .illus .rm,
body.dev-on .illus label,
body.dev-on .illus input[type="file"],
body.dev-on button[data-category-name],
body.dev-on button[data-spell-name],
body.dev-on button[data-don-name],
body.dev-on button[data-section-name],
body.dev-on button[data-section-type],
/* Extra specific selectors to match the hiding rules exactly */
body.dev-on .spell-add,
body.dev-on .don-add,
body.dev-on .objet-add,
body.dev-on .category-add,
body.dev-on .spell-category-delete,
body.dev-on .don-category-delete,
body.dev-on .objet-category-delete,
body.dev-on .don-move-up,
body.dev-on .don-move-down,
body.dev-on button[title*="Éditer"],
body.dev-on button[title*="Edit"],
body.dev-on button[title*="Supprimer"],
body.dev-on button[title*="Ajouter"],
body.dev-on [data-dev-only],
body.dev-on .dev-mode-buttons,
body.dev-on .manage-tags-btn,
body.dev-on .add-monster-btn,
body.dev-on .tags-manager-btn {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  pointer-events: auto !important;
  position: relative !important;
}

/* Limit objects to max 4 per row in dev mode */
body.dev-on #objets-container {
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  max-width: 1300px; /* Ensures max 4 columns on most screens */
}

/* Force max 4 columns on larger screens in dev mode */
@media (min-width: 1600px) {
  body.dev-on #objets-container {
    grid-template-columns: repeat(4, 1fr);
    max-width: 1300px;
  }
}

/* ULTIMATE SOLUTION: Force dimensions to prevent 0x0 collapse */
html body.dev-on .edit-btn,
html body.dev-on button[class*="edit"],
html body.dev-on button[class*="add"],
html body.dev-on button[class*="delete"],
html body.dev-on .section-delete,
html body.dev-on .add-paragraph-btn {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  width: 28px !important;
  height: 28px !important;
  min-width: 28px !important;
  min-height: 28px !important;
  background: rgba(139,69,19,0.1) !important;
  border: 1px solid var(--bronze) !important;
  border-radius: 6px !important;
  color: var(--bronze) !important;
  font-size: 14px !important;
  padding: 4px !important;
  margin-left: 8px !important;
  box-sizing: border-box !important;
  line-height: 1 !important;
  cursor: pointer !important;
  position: relative !important;
  top: 0 !important;
  left: 0 !important;
  transform: none !important;
  z-index: 10 !important;
}
/* Target specific button classes from renderer */
body.dev-off .spell-add,
body.dev-off .don-add,
body.dev-off .objet-add,
body.dev-off .spell-delete,
body.dev-off .don-delete,
body.dev-off .objet-delete,
body.dev-off .spell-category-delete,
body.dev-off .don-category-delete,
body.dev-off .objet-category-delete,
body.dev-off .don-move-up,
body.dev-off .don-move-down,
body.dev-off .section-delete,
body.dev-off .remove-section-btn,
/* Universal button selectors with edit-related titles */
body.dev-off button[title*="diter"],
body.dev-off button[title*="Edit"],
body.dev-off button[title*="Supprimer"],
body.dev-off button[title*="Ajouter"],
body.dev-off button[title*="Haut"],
body.dev-off button[title*="Bas"],
/* AJOUT: Sélecteurs pour les boutons add/delete */
body.dev-off button[class*="add"],
body.dev-off button[class*="delete"],
body.dev-off button[class*="remove"],
body.dev-off button[class*="move"],
body.dev-off button[class*="upload"],
body.dev-off button[class*="edit"] {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  pointer-events: none !important;
}

/* SPÉCIFIQUE: Règles avec spécificité maximale pour forcer le masquage */
body.dev-off button.spell-add.btn,
body.dev-off button.don-add.btn,
body.dev-off button.objet-add.btn,
body.dev-off button.spell-category-delete.btn,
body.dev-off button.don-category-delete.btn,
body.dev-off button.objet-category-delete.btn,
/* ULTRA-SPÉCIFIQUE: Tags manager buttons */
body.dev-off button.tags-manager-btn.btn,
body.dev-off button.filter-manager-btn.btn,
html body.dev-off .tags-manager-btn,
html body.dev-off .filter-manager-btn,
html body.dev-off button.tags-manager-btn,
html body.dev-off button.filter-manager-btn {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  pointer-events: none !important;
}

/* Ancien système d'agrandissement - désactivé */
.illus img.enlarged {
  /* Plus de style ici - géré par JavaScript modal */
}

/* Forcer l'état stable sur hover pour les images agrandies */
.illus img.enlarged:hover,
article[data-page="guerrier"] .illus img.enlarged:hover,
article[data-page="mage"] .illus img.enlarged:hover,
article[data-page="pretre"] .illus img.enlarged:hover,
article[data-page="rodeur"] .illus img.enlarged:hover,
article[data-page="enchanteur"] .illus img.enlarged:hover,
.illus[data-illus-key^="class:"] img.enlarged:hover,
article[data-page="sorts-mage"] .illus img.enlarged:hover,
article[data-page="sorts-pretre"] .illus img.enlarged:hover,
article[data-page="sorts-enchanteur"] .illus img.enlarged:hover,
.illus[data-illus-key^="spellcategory:"] img.enlarged:hover {
  transform:translate(-50%, -50%) !important;
  transition:none !important;
}

/* Ancien backdrop - plus utilisé */
.image-backdrop {
  display: none !important;
}

/* Interactive buttons */
.btn-action{display:inline-flex;gap:var(--space-sm);align-items:center;padding:var(--space-sm) 10px;border-radius:10px;cursor:pointer;border:1px solid}
.btn-upload{border-color:rgba(0,0,0,.25);border-style:dashed;background:#fff8ee}
.btn-remove{border-color:rgba(120,0,0,.25);background:#fee2e2}
.btn-add{border-color:rgba(0,120,0,.25);background:#f0fff4;margin-bottom:10px}
.btn-delete{padding:var(--space-xs) var(--space-md);border-radius:6px;font-size:12px;margin-left:10px}
.illus .up{border-color:rgba(0,0,0,.25);border-style:dashed;background:#fff8ee}
.illus .rm, .spell-delete{border-color:rgba(120,0,0,.25);background:#fee2e2}
.spell-add{border-color:rgba(0,120,0,.25);background:#f0fff4;margin-bottom:10px}
.spell-delete{padding:var(--space-xs) var(--space-md);border-radius:6px;font-size:12px;margin-left:10px}

/* Bouton d'ajout de paragraphe - seulement dans les articles */
.add-paragraph-btn {
  display:none !important;
}
/* Masquer explicitement dans la sidebar et le sommaire */
.sidebar .add-paragraph-btn,
.toc .add-paragraph-btn,
#toc .add-paragraph-btn {
  display:none !important;
  visibility:hidden !important;
}
/* Afficher SEULEMENT dans les articles actifs en mode dev */
body.dev-on article.active .add-paragraph-btn {
  display:block !important; margin:10px 0; padding:8px 12px; background:var(--card); 
  border:2px dashed var(--bronze); border-radius:8px; cursor:pointer;
  color:var(--bronze); text-align:center; transition:all .2s ease;
}
body.dev-on article.active .add-paragraph-btn:hover {
  background:rgba(139,69,19,.08); border-color:var(--gold);
  color:var(--gold);
}

/* Bouton d'ajout de sous-classe */
.add-subclass-btn {
  display:none; margin:12px 0 4px 0; padding:8px 12px; background:var(--card);
  border:1px dashed var(--bronze); border-radius:8px; cursor:pointer;
  color:var(--bronze); text-align:center; font-size:13px;
  transition:all .2s ease; width:100%;
}
/* Afficher dans les pages de classes en mode dev */
body.dev-on article[data-page="guerrier"] .add-subclass-btn,
body.dev-on article[data-page="mage"] .add-subclass-btn,
body.dev-on article[data-page="pretre"] .add-subclass-btn,
body.dev-on article[data-page="rodeur"] .add-subclass-btn,
body.dev-on article[data-page="enchanteur"] .add-subclass-btn {
  display:block !important;
}
body.dev-on article[data-page="guerrier"] .add-subclass-btn:hover,
body.dev-on article[data-page="mage"] .add-subclass-btn:hover,
body.dev-on article[data-page="pretre"] .add-subclass-btn:hover,
body.dev-on article[data-page="rodeur"] .add-subclass-btn:hover,
body.dev-on article[data-page="enchanteur"] .add-subclass-btn:hover {
  background:rgba(139,69,19,.08); border-color:var(--gold);
  color:var(--gold); transform:translateY(-1px);
  box-shadow:0 4px 8px rgba(0,0,0,.1);
}

/* Modales */
.category-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.category-modal.visible {
  display:flex;
}
.category-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:500px; width:90%; box-shadow:var(--shadow);
  position:relative;
}

/* Modal pour les icônes */
.icons-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.icons-modal.visible {
  display:flex;
}
.icons-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:600px; width:90%; max-height:80vh; overflow-y:auto;
  box-shadow:var(--shadow); position:relative;
}
.icons-grid {
  display:grid; grid-template-columns:repeat(auto-fill, minmax(60px, 1fr));
  gap:var(--space-md); margin:var(--space-xl) 0; max-height:400px; overflow-y:auto;
  border:1px solid var(--rule); border-radius:var(--space-md); padding:var(--space-xl);
}
.icon-item {
  display:flex; align-items:center; justify-content:center;
  padding:var(--space-lg); border:1px solid var(--rule); border-radius:var(--space-md);
  cursor:pointer; transition:var(--transition-fast); font-size:24px;
  background:var(--paper);
}
.icon-item:hover {
  background:var(--bronze); color:white; transform:scale(1.1);
  box-shadow:0 4px 8px rgba(0,0,0,.2);
}
.icon-item.copied {
  background:var(--gold); color:white; animation:copyFlash .5s ease;
}
@keyframes copyFlash {
  0% { transform:scale(1.1); }
  50% { transform:scale(1.3); }
  100% { transform:scale(1.1); }
}

/* Modal pour les éléments */
.elements-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:2147483647; display:none; align-items:center; justify-content:center;
}
.elements-modal.visible {
  display:flex;
}
.elements-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:400px; width:90%; 
  box-shadow:var(--shadow); position:relative;
}
.elements-list {
  display:flex; flex-direction:column; gap:var(--space-md); margin:var(--space-xl) 0;
}
.element-item {
  display:flex; align-items:center; gap:var(--space-md); padding:var(--space-md);
  border:2px solid var(--rule); border-radius:var(--space-md); cursor:pointer;
  transition:var(--transition-fast); background:var(--card);
}
.element-item:hover {
  background:var(--paper); border-color:var(--bronze); transform:translateY(-2px);
  box-shadow:0 4px 12px rgba(0,0,0,.1);
}
.element-item:active {
  transform:translateY(0) scale(0.98);
}
.element-icon {
  width:24px; height:24px; border-radius:50%; flex-shrink:0;
}
.element-name {
  font-weight:600; flex-grow:1;
}
.copy-indicator {
  font-size:12px; color:var(--paper-muted); opacity:0;
  transition:opacity 0.3s ease;
}
.element-item.copied .copy-indicator {
  opacity:1;
}

/* États modal styles */
.etats-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:2147483647; display:none; align-items:center; justify-content:center;
}
.etats-modal.visible {
  display:flex;
}
.etats-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:500px; width:90%; 
  box-shadow:var(--shadow); position:relative; max-height:80vh; overflow-y:auto;
}
.etats-list {
  display:flex; flex-direction:column; gap:var(--space-md); margin:var(--space-xl) 0;
}
.etat-item {
  display:flex; align-items:flex-start; gap:var(--space-md); padding:var(--space-md);
  border:2px solid var(--rule); border-radius:var(--space-md); cursor:pointer;
  transition:var(--transition-fast); background:var(--card); position:relative;
}
.etat-content {
  flex:1; display:flex; flex-direction:column;
}
.etat-item:hover {
  background:var(--paper); border-color:var(--bronze); transform:translateY(-2px);
  box-shadow:0 4px 12px rgba(0,0,0,.1);
}
.etat-item:active {
  transform:translateY(0) scale(0.98);
}
.etat-icon {
  width:24px; height:24px; border-radius:50%; flex-shrink:0;
  background:var(--bronze); color:white; display:flex; align-items:center;
  justify-content:center; font-size:14px;
}
.etat-name {
  font-weight:600; color:var(--accent-ink); margin-bottom:4px;
}
.etat-description {
  font-size:12px; color:var(--paper-muted); line-height:1.4;
}
.etat-item .copy-indicator {
  position:absolute; top:50%; right:var(--space-md); transform:translateY(-50%);
  font-size:12px; color:var(--bronze); opacity:0; font-weight:600;
  transition:opacity 0.3s ease;
}
.etat-item.copied .copy-indicator {
  opacity:1;
}

/* Styles pour les tooltips d'états */
span[title] {
  cursor: help;
  border-bottom: 2px solid var(--bronze);
  position: relative;
  display: inline-block;
  background: linear-gradient(135deg, rgba(205,127,50,0.1), rgba(212,175,55,0.05));
  padding: 2px 4px;
  border-radius: 3px;
  font-weight: 700;
}

/* Styles pour les liens de sorts */
.spell-link {
  color: #ea7332 !important; /* Orange au lieu du jaune */
  cursor: pointer;
  text-decoration: underline;
  font-weight: 600;
  transition: color 0.2s ease;
}

.spell-link:hover {
  color: var(--bronze) !important;
}

/* Styles pour les liens d'états */
.etat-link {
  color: #ea7332 !important; /* Orange au lieu du jaune */
  cursor: pointer;
  text-decoration: underline;
  font-weight: 600;
  transition: color 0.2s ease;
}

.etat-link:hover {
  color: var(--bronze) !important;
}

/* Modal des liens de sorts */
.spell-links-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  z-index: 2147483647;
  display: none;
  align-items: center;
  justify-content: center;
}

.spell-links-modal.visible {
  display: flex;
}

.spell-links-modal-content {
  background: var(--card);
  border: 2px solid var(--rule);
  border-radius: 16px;
  padding: var(--space-2xl);
  max-width: 600px;
  width: 90%;
  box-shadow: var(--shadow);
  position: relative;
  max-height: 80vh;
  overflow-y: auto;
}

.spell-item {
  display: flex;
  align-items: flex-start;
  gap: var(--space-md);
  padding: var(--space-md);
  border: 2px solid var(--rule);
  border-radius: var(--space-md);
  cursor: pointer;
  transition: var(--transition-fast);
  background: var(--card);
  position: relative;
  margin-bottom: 8px;
}

.spell-item:hover {
  background: var(--paper);
  border-color: var(--bronze);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.spell-item:active {
  transform: translateY(0) scale(0.98);
}

.spell-info {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.spell-name {
  font-weight: 600;
  margin-bottom: 4px;
  font-size: 14px;
}

.spell-meta {
  font-size: 12px;
  color: var(--paper-muted);
  margin-bottom: 6px;
}

.spell-description {
  font-size: 14px;
  color: var(--paper-muted);
  line-height: 1.4;
}

.spell-item .copy-indicator {
  position: absolute;
  top: 50%;
  right: var(--space-md);
  transform: translateY(-50%);
  font-size: 12px;
  color: var(--bronze);
  opacity: 0;
  font-weight: 600;
  transition: opacity 0.3s ease;
}

.spell-item.copied .copy-indicator {
  opacity: 1;
}

/* Popup de prévisualisation des sorts */
.spell-preview-popup {
  position: fixed;
  z-index: 10001;
  background: var(--card);
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  max-width: 400px;
  max-height: 500px;
  overflow-y: auto;
  font-family: 'Roboto', sans-serif;
  line-height: 1.4;
}

.spell-preview-content {
  padding: 0;
}

.spell-preview-header {
  padding: 16px;
  background: var(--paper);
  border-radius: 8px 8px 0 0;
  position: relative;
  border-left: 4px solid var(--accent);
}

.spell-title {
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 4px;
  font-family: 'Cinzel', serif;
}

/* Règle générale pour spell-element dans les cartes */
.card .spell-element {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  /* Pas de couleur par défaut - utilise les couleurs inline des éléments */
}

/* Couleur de fallback uniquement si aucune couleur inline n'est définie */
.card .spell-element:not([style*="color"]) {
  color: var(--paper-muted);
}

/* Badge d'élément avec texte noir pour lisibilité */
.element-badge {
  color: var(--paper-ink) !important;
  text-shadow: none !important;
}

/* S'assurer que la toolbox dev reste cliquable même avec modale ouverte */
#devToggle,
#devToolbox,
.tools,
.dev-toolbox {
  position: relative;
  z-index: 999999 !important;
}

/* Boutons de la toolbox dev toujours cliquables */
body.dev-on #devToggle,
body.dev-on #devToolbox *,
body.dev-on .tools *,
body.dev-on .dev-toolbox * {
  z-index: 999999 !important;
  pointer-events: auto !important;
}

/* Z-index maximum pour l'interface dev au-dessus des modales et dialogues */
.tools button,
.dev-toolbox button,
#devToggle,
#devToolbox button {
  z-index: 9999999 !important;
  position: relative;
}

/* Conteneur principal des outils dev */
.tools,
.dev-toolbox {
  z-index: 9999999 !important;
  position: relative;
}

/* Forcer les modales toolbox à apparaître devant les dialogues d'édition HTML */
.elements-modal,
.etats-modal, 
.spell-links-modal {
  z-index: 2147483647 !important; /* Maximum z-index possible */
}

.elements-modal-content,
.etats-modal-content,
.spell-links-modal-content {
  z-index: 2147483647 !important;
  position: relative;
}

/* Règle spécifique pour spell-element dans les popups de prévisualisation */
.spell-preview-popup .spell-element {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  /* Pas de couleur définie ici - elle sera définie en inline */
}

/* Force les couleurs des éléments - spécificité maximale */
.spell-links-modal .spell-meta[style*="color"],
.spell-preview-popup .spell-element[style*="color"] {
  color: var(--accent-ink) !important;
}

/* Règles pour les nouveaux attributs de données */
[data-element-display],
[data-spell-meta] {
  color: inherit !important;
  font-weight: 600;
}

/* Alternative: couleurs directes par élément */
.spell-preview-popup .spell-element[style*="#e25822"] { color: #e25822 !important; }
.spell-preview-popup .spell-element[style*="#2563eb"] { color: #2563eb !important; }
.spell-preview-popup .spell-element[style*="#92400e"] { color: #92400e !important; }
.spell-preview-popup .spell-element[style*="#059669"] { color: #059669 !important; }
.spell-preview-popup .spell-element[style*="#d97706"] { color: #d97706 !important; }
.spell-preview-popup .spell-element[style*="#6b21a8"] { color: #6b21a8 !important; }
.spell-preview-popup .spell-element[style*="#7c2d12"] { color: #7c2d12 !important; }
.spell-preview-popup .spell-element[style*="#7c3aed"] { color: #7c3aed !important; }

.spell-links-modal .spell-meta[style*="#e25822"] { color: #e25822 !important; }
.spell-links-modal .spell-meta[style*="#2563eb"] { color: #2563eb !important; }
.spell-links-modal .spell-meta[style*="#92400e"] { color: #92400e !important; }
.spell-links-modal .spell-meta[style*="#059669"] { color: #059669 !important; }
.spell-links-modal .spell-meta[style*="#d97706"] { color: #d97706 !important; }
.spell-links-modal .spell-meta[style*="#6b21a8"] { color: #6b21a8 !important; }
.spell-links-modal .spell-meta[style*="#7c2d12"] { color: #7c2d12 !important; }
.spell-links-modal .spell-meta[style*="#7c3aed"] { color: #7c3aed !important; }

/* Page Links Modal */
.page-links-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  z-index: 2147483647;
  display: none;
  align-items: center;
  justify-content: center;
}

.page-links-modal.visible {
  display: flex;
}

.page-links-modal-content {
  background: var(--card);
  border: 2px solid var(--rule);
  border-radius: 16px;
  padding: var(--space-2xl);
  max-width: 600px;
  width: 90%;
  box-shadow: var(--shadow);
  position: relative;
  max-height: 80vh;
  overflow-y: auto;
}

.page-item {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  padding: 12px;
  margin-bottom: 8px;
  border: 1px solid var(--rule);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  background: var(--surface);
}

.page-item:hover {
  background: var(--accent-bg);
  border-color: var(--accent);
  transform: translateX(4px);
}

.page-item.copied {
  background: rgba(34, 197, 94, 0.1);
  border-color: #22c55e;
}

.page-info {
  flex: 1;
}

.page-name {
  font-weight: 600;
  color: var(--accent-ink);
  margin-bottom: 4px;
  font-size: 14px;
}

.page-section {
  font-size: 12px;
  color: var(--paper-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.copy-indicator {
  position: absolute;
  top: 50%;
  right: 12px;
  transform: translateY(-50%);
  background: #22c55e;
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.page-item.copied .copy-indicator {
  opacity: 1;
}

@media (max-width: 768px) {
  .page-links-modal-content {
    max-width: calc(100vw - 16px);
    padding: 16px;
  }
}

.spell-preview-close {
  position: absolute;
  top: 12px;
  right: 12px;
  background: none;
  border: none;
  font-size: 16px;
  cursor: pointer;
  color: var(--paper-muted);
  padding: 4px;
  border-radius: 4px;
  transition: all 0.2s ease;
}

.spell-preview-close:hover {
  background: var(--rule);
  color: var(--accent-ink);
}

.spell-preview-body {
  padding: 16px;
}

/* États preview popup */
.etat-preview-popup {
  position: fixed;
  z-index: 10001;
  background: var(--card);
  border: 2px solid #7c2d12;
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.3);
  max-width: 300px;
  padding: 1rem;
  font-size: 14px;
  line-height: 1.4;
  color: var(--paper-ink);
  pointer-events: auto;
}

.etat-preview-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--rule);
}

.etat-title {
  font-weight: 600;
  font-size: 16px;
  color: #7c2d12;
}

.etat-preview-close {
  background: none;
  border: none;
  font-size: 16px;
  cursor: pointer;
  color: var(--paper-muted);
  padding: 4px;
  border-radius: 4px;
  transition: all 0.2s ease;
}

.etat-preview-close:hover {
  background: var(--rule);
  color: var(--accent-ink);
}

.etat-preview-body {
  margin-top: 0.5rem;
}

.etat-description {
  white-space: pre-line;
}

.spell-field {
  margin-bottom: 12px;
  font-size: 14px;
  line-height: 1.5;
}

.spell-field:last-child {
  margin-bottom: 0;
}

.spell-description {
  margin-bottom: 16px;
  font-style: italic;
  color: var(--paper-muted);
  font-size: 14px;
}

/* Responsive pour mobile */
@media (max-width: 768px) {
  .spell-preview-popup {
    max-width: calc(100vw - 16px);
    max-height: calc(100vh - 32px);
    left: 8px !important;
    top: 16px !important;
  }
  
  .spell-links-modal-content {
    max-width: calc(100vw - 16px);
    padding: 16px;
  }
}

span[title]:hover {
  border-bottom-color: var(--gold);
  border-bottom-width: 3px;
  background: linear-gradient(135deg, rgba(212,175,55,0.2), rgba(205,127,50,0.1));
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* Tooltip personnalisé pour une meilleure visibilité */
span[title]:hover::after {
  content: attr(title);
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: var(--accent-ink);
  color: white;
  padding: 10px 15px;
  border-radius: 8px;
  font-size: 13px;
  white-space: pre-line;
  z-index: 999999;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  pointer-events: none;
  min-width: 200px;
  max-width: 320px;
  text-align: center;
  line-height: 1.5;
  animation: tooltipFadeIn 0.3s ease;
  border: 2px solid var(--gold);
  word-wrap: break-word;
}

span[title]:hover::before {
  content: '';
  position: absolute;
  bottom: calc(100% + 2px);
  left: 50%;
  transform: translateX(-50%);
  border: 6px solid transparent;
  border-top-color: var(--accent-ink);
  z-index: 999999;
  pointer-events: none;
}

/* Forcer l'overflow visible pour les tooltips */
.card:has(span[title]:hover),
.editable:has(span[title]:hover),
article:has(span[title]:hover) {
  overflow: visible !important;
}

/* Fallback pour navigateurs sans :has() */
.card,
.editable,
article {
  position: relative;
}

.card span[title]:hover::after,
.editable span[title]:hover::after,
article span[title]:hover::after {
  z-index: 99999 !important;
}

@keyframes tooltipFadeIn {
  from { opacity: 0; transform: translateX(-50%) translateY(5px); }
  to { opacity: 1; transform: translateX(-50%) translateY(0); }
}

/* === UNIFIED EDIT BUTTONS FOR ALL SECTIONS === */
.editable-section {
  position: relative;
  margin: 8px 0;
}

.edit-btn {
  background: var(--bronze);
  color: white;
  border: none;
  border-radius: 6px;
  padding: 4px 8px;
  cursor: pointer;
  font-size: 12px;
  opacity: 0.7;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.edit-btn:hover {
  opacity: 1;
  transform: scale(1.05);
  background: var(--gold);
}

/* Inline edit buttons (titles, etc.) */
.edit-btn.edit-title-btn,
.edit-btn.edit-paragraph-btn {
  position: relative;
  margin-left: 8px;
}

/* Section edit buttons (absolute positioning) */
.editable-section .edit-btn.edit-section-btn,
[style*="position:relative"] .edit-btn.edit-section-btn {
  position: absolute;
  right: 8px;
  top: 8px;
  z-index: 10;
}

.editable-section:hover .edit-btn {
  opacity: 1;
  transform: scale(1.05);
  background: var(--gold);
}

.editable-section .edit-btn:hover {
  background: var(--gold) !important;
  transform: scale(1.1) !important;
  box-shadow: 0 3px 8px rgba(0,0,0,0.2);
}

.editable-section .edit-btn:active {
  transform: scale(0.95) !important;
}

/* Special positioning for different types */
.editable-list-container .edit-btn {
  right: 16px;
  top: 16px;
}

.editable-section[data-section-type="intro"] .edit-btn {
  right: 12px;
  top: 12px;
}

/* Title edit buttons */
.edit-title-btn {
  position: relative !important;
  right: auto !important;
  top: auto !important;
  margin-left: 12px;
  transform: none !important;
}

.edit-title-btn:hover {
  transform: scale(1.1) !important;
}

/* When editing, hide the button and expand content */
.editable-section[data-editing="true"] .edit-btn {
  display: none;
}

/* Visual feedback for editable sections */
.editable-section:hover {
  background: rgba(184, 134, 11, 0.05);
  border-radius: 8px;
  transition: background 0.2s ease;
}

.editable-section[data-editing="true"] {
  background: rgba(255, 255, 0, 0.1);
  border: 1px dashed var(--bronze);
  border-radius: 8px;
  padding: 8px;
}

/* Legacy support for old list items */
.editable-item {
  position: relative;
  padding-right: 40px;
}

.editable-content {
  display: block;
  margin-right: 35px;
}

/* === MJ-ONLY VISIBILITY CONTROLS === */
/* Show MJ-only elements when MJ state is active */
body.mj-on .mj-only {
  display: block !important;
}

/* Hide MJ-only elements by default and when MJ is off */
.mj-only,
body.mj-off .mj-only {
  display: none !important;
}

/* Show non-MJ elements by default and when MJ is off */
.non-mj-only,
body.mj-off .non-mj-only {
  display: block !important;
}

/* Hide non-MJ elements when MJ is on */
body.mj-on .non-mj-only {
  display: none !important;
}

/* For flex and inline-flex elements */
body.mj-on .mj-only[style*="display: flex"] {
  display: flex !important;
}

body.mj-on .mj-only[style*="display: inline-flex"] {
  display: inline-flex !important;
}

/* === DEV-ONLY VISIBILITY CONTROLS === */
/* Show dev-only elements when dev mode is active */
body.dev-on .dev-only {
  display: block !important;
}

/* Hide dev-only elements by default and when dev is off */
.dev-only,
body.dev-off .dev-only {
  display: none !important;
}

/* Show non-dev elements by default and when dev is off */
.non-dev-only,
body.dev-off .non-dev-only {
  display: block !important;
}

/* Hide non-dev elements when dev is on */
body.dev-on .non-dev-only {
  display: none !important;
}

/* For flex and inline-flex elements in dev mode */
body.dev-on .dev-only[style*="display: flex"] {
  display: flex !important;
}

body.dev-on .dev-only[style*="display: inline-flex"] {
  display: inline-flex !important;
}
</style>
</head>
<body class="dev-off">

<div class="shell">
  <button aria-controls="sidebar" aria-expanded="false" aria-label="Ouvrir le sommaire" class="menu-toggle" id="menuToggle" style="display:none">☰ Sommaire</button>
  <div class="backdrop" hidden="" id="backdrop"></div>
  
  <main class="page">
    <aside class="sidebar" id="sidebar">
      <div class="panel">
        <div class="searchbar">
          <input autocomplete="off" id="search" placeholder="Rechercher une règle, une classe…">
          <button class="btn" id="clear" title="Effacer">✖</button>
        </div>
        <div class="tools">
          <!-- Dev mode disabled in standalone version -->
        </div>
        <div class="toc" id="toc">
          <!-- Table of contents will be generated by JavaScript -->
        </div>
      </div>
    </aside>
    
    <div id="views">
      <!-- Main content will be generated by JavaScript -->
      <div id="app-loading">Chargement...</div>
    </div>
  </main>
  
  <footer></footer>
</div>

<script>

    // Ensure window object exists
    window = window || {};
    
    // Global data from modular files
    window.SORTS = [
  {
    "nom": "Sorts de Mage",
    "description": "Sorts de destruction.",
    "sorts": [
      {
        "nom": "Boule de Feu",
        "element": "Feu",
        "description": "Lance une boule de feu sur un adversaire, qui peut s'enflammer.",
        "categorie": "Mage",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> 15m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 3",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige 5 dégats de <span style=\"color: #e25822; font-weight: bold;\">Feu</span> à la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Les dégats passent à 7 et la cible s'enflamme, infligeant 5 dégats de feu au prochain tour du lanceur."
      },
      {
        "nom": "Éclair",
        "element": "Air",
        "description": "Frappe instantannément une cible avec un éclair électrique, ne laissant aucune chance à l'esquive.",
        "categorie": "Mage",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 2",
        "portee": "🎯 <strong>Portée:</strong> 12m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 5",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> &nbsp;Inflige 6 dégats d'<span style=\"color: #22c55e; font-weight: bold;\">Air</span> à la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> Les dégâts passent à 10 et ils sont aussi infligé à un ennemi à moins de 3m de la cible."
      },
      {
        "nom": "Vague déferlante",
        "element": "Eau",
        "description": "Une puissante vague d'eau s'abat sur vos ennemis et les repousse.",
        "categorie": "Sorts de Mage",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 3",
        "portee": "🎯 <strong>Portée:</strong> 6m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 6",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> Volant.",
        "effetNormal": "<strong>Effet:</strong> &nbsp;Inflige 6 dégats d'<span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span> aux créature devant le lanceur (largeur 3m distance 6m) et les repousse jusqu'à 6m.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> les dégats passent à 10 et les enemis sont touchés/repoussés à 12m."
      },
      {
        "nom": "Volée de pierres",
        "element": "Terre",
        "description": "Invoque une volée de pierres qui tournoient autour du lanceur, puis qui sont éjectées devant lui.",
        "categorie": "Sorts de Mage",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 4",
        "portee": "🎯 <strong>Portée:</strong> 6m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 10",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige 7 dégats de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> aux créatures autour du lanceur (3m). <br>Puis inflige le même montant aux créatures devant le lanceur sur 6m.<br><br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Les dégats passent à 12. Les cibles non volantes et de taille moyennes sont <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span> pendant 1 tour."
      }
    ]
  },
  {
    "nom": "Sorts de Prêtre",
    "description": "Sorts de soutiens et anti mort-vivants.",
    "sorts": [
      {
        "nom": "Châtiment",
        "element": "Divin",
        "description": "Invoque un magie divine qui blesse les morts-vivants",
        "categorie": "Anti-mort-vivant",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 3",
        "portee": "🎯 <strong>Portée:</strong> 18m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 3",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> &nbsp;<br>- Non mort-vivant <br>- Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige *Intelligence* dégâts <span style=\"color: #d0d0d0; font-weight: bold; background: rgba(0, 0, 0, 0.4); padding: 2px 4px; border-radius: 3px;\">Divin</span> à la cible.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>Double dégâts."
      },
      {
        "nom": "Refermer les blessures",
        "element": "Divin",
        "description": "Une magie divine soigne les blessures récentes du héros ou d'un allié proche.",
        "categorie": "Sorts de Prêtre",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> 3m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 5",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> &nbsp;\n<br>- Hors combat.\n<br>- La cible n'a pas été blessée pendant plus de 3 tours.",
        "effetNormal": "<strong>Effet:</strong> Soigne la cible de 5 points de vie. Tous les 5 points d'intelligence, augmente le soin de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>Double le soin."
      },
      {
        "nom": "Protection",
        "element": "Lumière",
        "description": "Protège le lanceur ou un allié.",
        "categorie": "Sorts de Prêtre",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 2",
        "portee": "🎯 <strong>Portée:</strong> 3m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 5",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Augmente l'armure de 2 pendant 5 tours.<br> Tous les 5 d'Intelligence, augmente l'armure de 1 supplémentaire.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> L'armure est augmentée de 4."
      },
      {
        "nom": "Arme de lumière",
        "element": "Lumière",
        "description": "Une lumière destructrice s'imprègne de l'arme du prêtre.",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> -",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 5",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> L'arme du prêtre infligera 2 dégats de lumière à chaque coup, pendant 4 tours.<br> Tous les 5 d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Les dégats passent à 4."
      }
    ]
  },
  {
    "nom": "Sorts d'Enchanteur",
    "description": "Sorts d'amélioration et d'affaiblissement.",
    "sorts": [
      {
        "nom": "Accroche terrestre",
        "element": "Terre",
        "description": "Le sol se soulève et s'agrippe aux jambes de la cible, alourdissant ses pas d'une étreinte de pierre vivante.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> 30m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 3",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> <br>- Résistance altérations &gt; Intelligence du lanceur<br>- Lévitation ou Volant.",
        "effetNormal": "<strong>Effet:</strong>&nbsp;La cible contracte l'état <span class=\"etat-link\" data-etat=\"Ralenti\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Ralenti</span> pendant 5 tours.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>La cible ne peut plus effectuer de déplacement pendant la durée du sort."
      },
      {
        "nom": "Accélération",
        "element": "Air",
        "description": "Une magie des vents accélère un allié ou le lanceur.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> 6m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 4",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> Aucune",
        "effetNormal": "<strong>Effet:</strong> &nbsp;La vitesse de déplacement de la cible est augmentée de 3m pendant 5 tours. Non Cumulable.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> La vitesse est augmentée de 6m."
      },
      {
        "nom": "Sommeil",
        "element": "Nuit",
        "description": "Un voile d'ombre caresse la cible, l'enveloppant dans un sommeil surnaturel.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 2",
        "portee": "🎯 <strong>Portée:</strong> 6m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 8",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> <br>- Résistance altérations &gt; Intelligence du lanceur<br>- Element <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span>",
        "effetNormal": "<strong>Effet:</strong> La cible passe dans l'état <span class=\"etat-link\" data-etat=\"Endormi/assomé/Effrayé\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Endormi</span> pendant ses 2 prochains tours.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> L'effet dure 4 tours."
      }
    ]
  }
];
    window.CLASSES = [
  {
    "nom": "Guerrier",
    "resume": "Héros sans égal au combat au corp à corp.",
    "capacites": "<ul><li><em>Expert de l'équipement</em> : Capable d'utiliser toutes les armes (épées, arcs, batons, dagues, exotiques, une main et deux mains), armures (robes, légères, lourdes), et boucliers.</li><li><em>Hardiesse</em> : Gagne la compétence Hardiesse rang 1.</li></ul>",
    "sousClasses": [
      {
        "nom": "Nain des montagnes",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>5</strong></span><span class=\"chip\">🏃 Agilité: <strong>1</strong></span><span class=\"chip\">🛡️ Endurance: <strong>7</strong></span><span class=\"chip\">🧠 Intelligence: <strong>1</strong></span><span class=\"chip\">⚡ Volonté: <strong>5</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Force 💪, +3 Endurance 🛡️, +1 Volonté⚡   <strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Brise rocher : </em> Gagne 1 de compétence sur les tests de compétence Hardiesse pour une destruction d'objet.</li><li><em>Volonté inflexible :</em> Les nains possèdent une volonté inflexible qui les rendent résistants aux sortilèges (caractéristique Volonté élevée).</li></ul>",
        "description": "<i>Race robuste et inflexible, dotée d’une endurance exceptionnelle. Forgés par la roche et les sommets, ils résistent aux épreuves et possèdent une force colossale capable de briser murs, armures et créatures cuirassées.</i>"
      },
      {
        "nom": "Berserker",
        "base": {
          "Force": 5,
          "Agilité": 4,
          "Endurance": 5,
          "Intelligence": 1,
          "Volonté": 1,
          "Chance": 1
        },
        "progression": "<strong>📈 Progression par niveau:</strong> +3 Force 💪, +1 Agilité 🏃, +1 Endurance 🛡️<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Tourbillon de rage :</em> Sur un critique au corps à corps, touche aussi tous les adversaires à moins de 3m.</li><li><em>Risque sauvage :</em> +1 chance de critique physique s'il ne porte pas de bouclier.</li></ul>",
        "description": "<i>Combattant sauvage, maître des armes à deux mains. Sa rage décuple sa force, lui permettant d’abattre ses ennemis dans un déchaînement de puissance brute et de coups imparables.</i>"
      },
      {
        "nom": "Aventurier",
        "description": "<i>Héros polyvalent et ingénieux, il affronte l’inconnu avec courage, et manie tous les outils à sa portée pour triompher.</i>",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>5</strong></span><span class=\"chip\">🏃 Agilité: <strong>2</strong></span><span class=\"chip\">🛡️ Endurance: <strong>5</strong></span><span class=\"chip\">🧠 Intelligence: <strong>1</strong></span><span class=\"chip\">⚡ Volonté: <strong>1</strong></span><span class=\"chip\">🍀 Chance: <strong>5</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Force 💪, +2 Endurance 🛡️, +1 Chance 🍀, <strong> +2 Au choix</strong>",
        "capacites": "<ul><em>Passé glorieux : </em>  Gagne la compétence Eloquence rang 1.<br><em>Sans failles :</em>  Dispose d'un Effort maximum supplémentaire .<br><em>Polyvalent : </em> Dispose d'un point de Don supplémentaire.</ul>"
      },
      {
        "nom": "Maître d’armes",
        "description": "<i>Guerrier érudit et redoutable, il manie avec aisance toutes les armes, des plus communes aux plus exotiques, transformant chaque outil de guerre en prolongement de son bras.</i>",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>5</strong></span><span class=\"chip\">🏃 Agilité: <strong>2</strong></span><span class=\"chip\">🛡️ Endurance: <strong>5</strong></span><span class=\"chip\">🧠 Intelligence: <strong>1</strong></span><span class=\"chip\">⚡ Volonté: <strong>3</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +3 Force 💪, +2 Endurance 🛡️<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Volte d’armes :</em> Peut changer d'arme sans utiliser d'action secondaire.\n</li>\n               <li><em>Expert martial :</em> Lorsqu'il utilise une arme exotique, relance le dé en cas d'echec critique.\n</li>\n   <li><em>Erudit des lames :</em> Gagne 1 de compétence sur les tests de compétence Réflexion sur l'effet ou la provenance d'une arme.\n</li>\n\n</ul>"
      }
    ]
  },
  {
    "nom": "Mage",
    "resume": "Spécialiste de la magie destructrice.",
    "capacites": "<ul><li><em>Équipement de mage</em> : bâtons (une et deux mains), robes.</li><li><em>Sorts de mage</em> : Apprend et lance des sorts de mage.</li></ul>",
    "sousClasses": [
      {
        "nom": "Érudit",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>1</strong></span><span class=\"chip\">🏃 Agilité: <strong>1</strong></span><span class=\"chip\">🛡️ Endurance: <strong>1</strong></span><span class=\"chip\">🧠 Intelligence: <strong>6</strong></span><span class=\"chip\">⚡ Volonté: <strong>3</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +3 Intelligence 🧠, +2 Volonté ⚡<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Instruit</em> : Gagne la compétence Réflexion rang 1.</li><li><em>Apprentissage accéléré</em> : Le niveau de l'érudit est considéré comme deux fois plus élevé pour les prérequis d'apprentissage de sorts.</li></ul>",
        "description": "<i>Mage avide de savoir, doté d’une mémoire prodigieuse. Il assimile les arcanes avec une rapidité fulgurante et maîtrise de nouveaux sorts bien plus vite que ses pairs.</i>"
      },
      {
        "nom": "Elfe",
        "base": {
          "Force": 2,
          "Agilité": 2,
          "Endurance": 3,
          "Intelligence": 3,
          "Volonté": 2,
          "Chance": 1
        },
        "progression": "<strong>📈 Progression par niveau:</strong> +1 Force 💪, +1 Agilité 🏃, +1 Endurance 🛡️, +1 Intelligence 🧠, +1 Volonté ⚡<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Instinct elfique</em> : Gagne la compétence Coordination rang 1.</li><li><em>Équipement d'elfe</em> : Epées à une main, armures légères.</li><li><em>Briseur de sceaux</em> : Gagne 1 de compétence sur les tests de compétence pour comprendre ou ouvrir une porte scellée magiquement</li></ul>",
        "description": "<i>Guerrier-mage polyvalent, aussi agile qu’élégant. Maître des arcanes comme du combat rapproché, il allie puissance magique et adresse martiale avec une grâce inégalée.</i>"
      }
    ]
  },
  {
    "nom": "Prêtre",
    "resume": "Spécialiste de la magie de soutien et anti morts-vivants.",
    "capacites": "<ul><li><em>Équipement de prêtre</em> : bâtons (une et deux mains), robes.</li><li><em>Sorts de prêtre</em> : Apprend et lance des sorts de Prêtre.</li><li><em>Eloquence</em> : Gagne la compétence Eloquence rang 1.</li></ul>",
    "sousClasses": [
      {
        "nom": "Inquisiteur",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>3</strong></span><span class=\"chip\">🏃 Agilité: <strong>1</strong></span><span class=\"chip\">🛡️ Endurance: <strong>4</strong></span><span class=\"chip\">🧠 Intelligence: <strong>3</strong></span><span class=\"chip\">⚡ Volonté: <strong>5</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +1 Force 💪, +1 Intelligence 🧠, +2 Volonté ⚡, +1 Endurance 🛡️<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Equipement d'inquisiteur</em> : Peut s'équiper d'armures légères et de boucliers.</li><li><em>Fléau des morts-vivants</em> : Les sorts visant les morts-vivants ne ratent jamais.</li><li><em>Lumière purificatrice</em> : Double l'effet de l'intelligence sur les dégats des sorts d'élément <span style=\"color: #ffd700; font-weight: bold;\">Lumière</span> ou <span style=\"color: #f5f5f5; font-weight: bold; background: rgba(100, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;\">Divin</span>.</li></ul>",
        "description": "<i>Champion de la foi, il renforce ses alliés par la magie sacrée et traque sans relâche les morts-vivants. Quand la lumière seule ne suffit plus, il n’hésite pas à prendre les armes et combattre en première ligne.</i>"
      },
      {
        "nom": "Clerc Divin",
        "base": {
          "Force": 1,
          "Agilité": 1,
          "Endurance": 2,
          "Intelligence": 3,
          "Volonté": 5,
          "Chance": 5
        },
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Intelligence 🧠, +2 Volonté ⚡, +1 Chance 🍀<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Maître des soins</em> : Double l'effet de l'intelligence sur les sorts de soins.</li><li><em> Pieu </em>:  Gagne 1 de compétence sur les tests de compétence Reflexion sur un dieu ou une religion.</li><li><em> Protection divine </em>:  Dispose d'une armure élementaire <span style=\"color: #f5f5f5; font-weight: bold; background: rgba(100, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;\">Divin</span> de 10.</li></ul>",
        "description": "<i>Serviteur sacré, maître des arts de guérison. Sa puissante magie de soins protège ses alliés et les relève même aux portes de la mort.</i>"
      }
    ]
  },
  {
    "nom": "Rôdeur",
    "resume": "Héros très agile.",
    "capacites": "<ul><li><em>Équipement de rôdeur</em> : Dagues, robes, armures légères.</li><li><em>Coordination</em> : Gagne la compétence Coordination rang 1.</li></ul>",
    "sousClasses": [
      {
        "nom": "Voleur",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>3</strong></span><span class=\"chip\">🏃 Agilité: <strong>5</strong></span><span class=\"chip\">🛡️ Endurance: <strong>2</strong></span><span class=\"chip\">🧠 Intelligence: <strong>2</strong></span><span class=\"chip\">⚡ Volonté: <strong>2</strong></span><span class=\"chip\">🍀 Chance: <strong>5</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Agilité 🏃, +2 Force 💪, +1 Endurance 🛡️<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Mains expertes :</em> Gagne la compétence Finesse rang 1.</li><li><em>Sprint :</em> Peut utiliser une action secondaire pour doubler sa vitesse de déplacement.</li><li><em>Vicieux :</em> Double les chances de critiques physiques sur les cibles subissant un état qui les empeche d'esquiver.</li></ul>",
        "description": "<i>Maître de la finesse et de l’agilité, il se déplace avec rapidité fulgurante et frappe là où ça fait le plus mal. </i>"
      },
      {
        "nom": "Chasseur",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>3</strong></span><span class=\"chip\">🏃 Agilité: <strong>5</strong></span><span class=\"chip\">🛡️ Endurance: <strong>2</strong></span><span class=\"chip\">🧠 Intelligence: <strong>4</strong></span><span class=\"chip\">⚡ Volonté: <strong>2</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Agilité 🏃, +1 Force 💪, +1 Endurance 🛡️, +1 Intelligence 🧠<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Armes du Chasseur</em> : Peut utiliser les arcs.</li><li><em>Cueillette</em> : Une fois par jour, lors d’un repos, le personnage peut récolter 5 plantes locales (au choix du MJ). Leur efficacité dépend de l’Intelligence de l’utilisateur.</li><li><em>Connaissance du milieu naturel</em> : Gagne 1 de compétence sur les tests de Réflexion lié à animal, un monstre, une plante, ou la découverte de passages dérobés en milieu naturel.</li></ul>",
        "description": "<i>Précis et agile, il complète son art de l’arc par la science des herbes anciennes.</i>"
      }
    ]
  },
  {
    "nom": "Enchanteur",
    "resume": "Détenteur d'une magie singulière, qui fait de lui un allié précieux.",
    "capacites": "<ul><li><em>Équipement d'enchanteur</em> : bâtons (une et deux mains), dagues, Robes.</li><li><em>Sorts d'enchanteur</em> : Apprend et lance des sorts d'Enchanteur.</li></ul>",
    "sousClasses": [
      {
        "nom": "Esprit de la grande Fée",
        "base": "<div class=\"chips\"><span class=\"chip\">💪 Force: <strong>1</strong></span><span class=\"chip\">🏃 Agilité: <strong>5</strong></span><span class=\"chip\">🛡️ Endurance: <strong>2</strong></span><span class=\"chip\">🧠 Intelligence: <strong>5</strong></span><span class=\"chip\">⚡ Volonté: <strong>2</strong></span><span class=\"chip\">🍀 Chance: <strong>1</strong></span></div>",
        "progression": "<strong>📈 Progression par niveau:</strong> +1 Agilité 🏃, +1 Intelligence 🧠, +1 Endurance 🛡️, +1 Volonté ⚡, +1 Chance 🍀<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Tatillon</em> : Gagne la compétence Finesse rang 1.</li><li><em>Lévitation</em> : Ignore dégâts/ralentissements venant du sol.</li><li><em>Rayon de l'Amitié</em> : Par une action secondaire, peut répéter sur une autre cible à portée un sort bénéfique qui a ciblé un allié se tour ci, sans coût en mana supplémentaire.</li></ul>",
        "description": "<i>Être mystique qui flotte au-dessus du sol, il invoque des sorts imprévisibles pour soutenir ses alliés.</i>"
      },
      {
        "nom": "Lutin",
        "base": {
          "Force": 1,
          "Agilité": 1,
          "Endurance": 1,
          "Intelligence": 5,
          "Volonté": 2,
          "Chance": 5
        },
        "progression": "<strong>📈 Progression par niveau:</strong> +1 Intelligence 🧠, +2 Volonté ⚡, +2 Chance 🍀<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Secrets bien gardés</em> : Gagne la compétence Reflexion rang 1.</li><li><em>Expert des baguettes</em> : Sur un critique à la baguette, la charge n'est pas consommée.</li><li><em>Rire malicieux</em> : Par une action secondaire, peut répéter sur une autre cible à portée un sort d'altération qui a ciblé un enemi ce tour ci, sans coût en mana supplémentaire.</li></ul>",
        "description": "<i>Esprit espiègle et rusé, passé maître dans l’art des altérations magiques. </i>"
      }
    ]
  }
];
    window.DONS = [
  {
    "nom": "Generaux",
    "description": "Dons accessibles à toutes les classes.",
    "dons": [
      {
        "nom": "Doué",
        "description": "Gagne une compétence rang 1.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 points de don"
      },
      {
        "nom": "Toujours pret",
        "description": "Le maximum d'efforts maximum augmente de 1.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Brillant",
        "description": "Gagne une compétence rang 2.",
        "prerequis": "<strong> Prérequis :</strong> La compétence rang 1.",
        "cout": "2 points de don"
      },
      {
        "nom": "Prodigieux",
        "description": "Gagne une compétence rang 3.",
        "prerequis": "<strong> Prérequis :</strong> La compétence rang 2.",
        "cout": "3 point de don"
      },
      {
        "nom": "Hyperactif",
        "description": "Le héros dispose maintenant de deux actions secondaires par tour.",
        "prerequis": "<strong> Prérequis :</strong> Niveau 3",
        "cout": "2 points de don"
      },
      {
        "nom": "Equitation",
        "description": "Permet de monter à cheval ou équivalent.",
        "prerequis": "<strong> Prérequis :</strong> Niveau 5",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Guerrier",
    "description": "Dons accessibles aux guerriers.",
    "dons": [
      {
        "nom": "Expertise du bouclier",
        "description": "Si le héros a un bouclier équipé, il peut utiliser une action secondaire pour doubler l'armure physique du bouclier jusqu'au prochain tour.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Charge",
        "description": "Une fois par combat, peut utiliser une action secondaire pour doubler sa vitesse de déplacement et forcer un coup critique sur la prochaine attaque physique de ce tour (si elle réussie).",
        "prerequis": "<strong> Prérequis :</strong> 🏃Agilité 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Volonté de fer",
        "description": "Une fois par jour, le héros peut utiliser une action secondaire pour se débarasser de toutes ses alterations magiques.",
        "prerequis": "<strong> Prérequis :</strong> ⚡Volonté 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Coup de bouclier",
        "description": "Si le héros a un bouclier équipé, lorsque le héros subit des dégats aux corps à corps, il peut choisir d'utiliser une action secondaire pour infliger à l'attaquant des dégats équivalents à l'armure du bouclier.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Coup de pommeau",
        "description": "Description du don.",
        "prerequis": "Aucun prérequis",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Rôdeur",
    "description": "Dons accessibles aux rodeurs.",
    "dons": [
      {
        "nom": "Croche-patte",
        "description": "Peut utiliser une action principale pour effectuer un croche- patte :\n\n\n<br><br><b>Sans effet si :</b> \n<br>- Esquive.\n<br>- Volant ou lévitant.\n<br>- Taille supérieure à Moyen.\n\n<br><br><b>Effet :</b> Inflige (Force) dégats Physiques à la cible. Met la cible dans l'état <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span>.\n✏️\n<br><br><b>Coup Critique :</b>  Les dégats sont doublés et la cible est <span class=\"etat-link\" data-etat=\"Endormi/assomé/Effrayé\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Assomé</span> 1 tour.\n\n<br><br><hr>",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Chasse et pêche",
        "description": "Le héros n'as plus besoin de sa ratio de nourriture quotidienne.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Attaque d'opportunité",
        "description": "Description du don.",
        "prerequis": "Aucun prérequis",
        "cout": "1 point de don"
      },
      {
        "nom": "D",
        "description": "Description du don.",
        "prerequis": "Aucun prérequis",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Mage",
    "description": "Description de cette catégorie de dons.",
    "dons": [
      {
        "nom": "Gemme de mana",
        "description": "Une fois par jour, le héros peut récupérer l'intégralité de son Mana en utilisant une action secondaire.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Resistance élémentaire 1",
        "description": "Le héros gagne 5 d'armure élémentaire de <span style=\"color: #e25822; font-weight: bold;\">Feu</span>, <span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span>, <span style=\"color: #8b5e34; font-weight: bold;\">Terre</span>, <span style=\"color: #22c55e; font-weight: bold;\">Air</span>.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Resistance magique 1",
        "description": "Le héros gagne 5 d'armure élémentaire de <span style=\"color: #ffd700; font-weight: bold;\">Lumière</span>, <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span>, <span style=\"color: #d0d0d0; font-weight: bold; background: rgba(0, 0, 0, 0.4); padding: 2px 4px; border-radius: 3px;\">Divin</span>, <span style=\"color: #a855f7; font-weight: bold;\">Maléfique</span>.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Spécialisation élémentaire 1",
        "description": "Le héros peut choisir un élément et augmenter de 5 les dégats infligés avec les sorts de cet élément.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Infusion élémentaire",
        "description": "Aprés avoir lancé un sort, le héros peut, en utilisant une action secondaire, imprégner son arme de l'élément du sort. Elle infligera à sa prochaine attaque physique des dégats de cet élément équivalents au niveau du sort.",
        "prerequis": "<strong> Prérequis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Polyglotte",
        "description": "Peut lire et parler toutes les langues.",
        "prerequis": "<strong> Prérequis :</strong> Reflexion rang 2.",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Pretre",
    "description": "Description de cette catégorie de dons.",
    "dons": [
      {
        "nom": "Mécréants",
        "description": "Les dégats physiques infligés aux créatures de l'élément <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span> ou <span style=\"color: #a855f7; font-weight: bold;\">Maléfique</span> sont doublés.",
        "prerequis": "<strong> Prérequis :</strong>-",
        "cout": "1 point de don"
      },
      {
        "nom": "Au milieu du combat",
        "description": "Permet d'utiliser s'équiper de dagues.",
        "prerequis": "<strong> Prérequis :</strong>🏃Agilité 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Jugement éclair",
        "description": "Si le Prêtre a effectué un sort ce tour ci, il peut effectuer une attaque au corp à corp avec une action secondaire.",
        "prerequis": "<strong> Prérequis :</strong>💪Force 3",
        "cout": "1 point de don"
      },
      {
        "nom": "Musique",
        "description": "Permet d'apprendre un instrument de musique (ou de savoir chanter) au choix, gagnant 2 de compétences sur les tests de compétence éloquence le nécéssitant.",
        "prerequis": "<strong> Prérequis :</strong>-",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Enchanteur",
    "description": "Dons accessibles aux enchanteurs.",
    "dons": [
      {
        "nom": "Réparateur de baguettes",
        "description": "Permet de regagner une charge de baguette, une fois par jour.",
        "prerequis": "<strong> Prérequis :</strong>-",
        "cout": "1 point de don"
      },
      {
        "nom": "Magie aléatoire destructrice",
        "description": "Permet de choisir et d'apprendre un sort de mage et de pouvoir le lancer à volonté. Le sort ne peut pas être changé par la suite.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Magie aléatoire de soutien",
        "description": "Permet de choisir et d'apprendre un sort de prêtre et de pouvoir le lancer à volonté. Le sort ne peut pas être changé par la suite.",
        "prerequis": "<strong> Prérequis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Alteration risquée",
        "description": "Lorsque un sort d'alteration magique est effectué alors que la cible est au corps à corps, ses chances de critiques sont doublées.",
        "prerequis": "<strong> Prérequis :</strong>-",
        "cout": "1 point de don"
      }
    ]
  }
];
    window.OBJETS = {
  "objets": [
    {
      "nom": "Espadon",
      "numero": 1,
      "image": "",
      "description": "<i>Longue épée à deux mains, lourde mais puissante.</i>",
      "tags": [
        "Arme",
        "Épée",
        "Deux mains"
      ],
      "effet": "<strong>Dégâts: </strong> Inflige (5  + Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 35",
      "poids": "⚖️ <strong>Poids:</strong> 2"
    },
    {
      "nom": "Simple épée",
      "numero": 2,
      "image": "",
      "description": "<i>Arme droite et équilibrée, conçue pour être maniée d’une seule main</i>",
      "tags": [
        "Arme",
        "Épée",
        "Une main"
      ],
      "effet": "<span style=\"font-weight: 700; font-family: \" source=\"\" serif=\"\" pro\",=\"\" serif;=\"\" color:=\"\" rgb(74,=\"\" 44,=\"\" 23);=\"\" text-shadow:=\"\" rgba(0,=\"\" 0,=\"\" 0.05)=\"\" 0px=\"\" 1px=\"\" 2px;\"=\"\">Dégâts: </span> Inflige (2  + Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 20",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Dague en fer",
      "numero": 3,
      "image": "",
      "description": "<i>Petite lame simple, légère et maniable.</i>",
      "tags": [
        "Arme",
        "Une main",
        "Dague"
      ],
      "effet": "<strong>Dégâts: </strong> Inflige (1  + Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Bâton en bois",
      "numero": 4,
      "image": "",
      "description": "<i>Long bâton solide, utilisé comme arme et appui.</i>",
      "tags": [
        "Arme",
        "Deux mains",
        "Baton"
      ],
      "effet": "<strong>Dégâts: </strong> Inflige (2  + Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 5",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Gourdin",
      "numero": 5,
      "image": "",
      "description": "<i>Arme rudimentaire faite de bois dur. </i>",
      "tags": [
        "Arme",
        "Une main",
        "Baton"
      ],
      "effet": "<strong>Dégâts: </strong> Inflige (1  + Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Arc simple",
      "numero": 6,
      "image": "",
      "description": "<i>Arc basique en bois, sans ornement.</i>",
      "tags": [
        "Arme",
        "Deux mains",
        "Arc"
      ],
      "effet": "<strong>Portée: </strong> 12m.<br>\n<strong>Dégâts: </strong> Inflige (Force) points de dégats physiques.",
      "prix": "🔷 <strong>Prix:</strong> 30",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Bouclier en bois",
      "numero": 7,
      "image": "",
      "description": "<i>Un bouclier grossier taillé dans des planches épaisses, marqué de cicatrices de bataille.</i>",
      "tags": [
        "Bouclier"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 2.",
      "prix": "🔷 <strong>Prix:</strong> 15",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Robe simple",
      "numero": 8,
      "image": "",
      "description": "<i>Une robe de toile modeste, aux plis fatigués mais encore emplis de dignité.</i>",
      "tags": [
        "Armure",
        "Robe"
      ],
      "effet": "<strong>Effet:</strong> Augmente la Volonté de 1.",
      "prix": "🔷 <strong>Prix:</strong> 20",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Armure de cuir",
      "numero": 9,
      "image": "",
      "description": "<i>Une armure souple en cuir tanné, taillée pour offrir une protection rudimentaire.</i>",
      "tags": [
        "Armure",
        "Armure légère"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 1.",
      "prix": "🔷 <strong>Prix:</strong> 30",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Armure en maille",
      "numero": 10,
      "image": "",
      "description": "<i>Une cotte de mailles dont chaque anneau forgé promet résistance et endurance au combat.</i>",
      "tags": [
        "Armure",
        "Armure lourde"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 3.",
      "prix": "🔷 <strong>Prix:</strong> 65",
      "poids": "⚖️ <strong>Poids:</strong> 2"
    },
    {
      "nom": "Armure de plaque",
      "numero": 11,
      "image": "",
      "description": "<i>Une imposante armure de métal poli, dont les plaques luisantes forment une carapace presque impénétrable.</i>",
      "tags": [
        "Armure",
        "Armure lourde"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 6.",
      "prix": "🔷 <strong>Prix:</strong> 200",
      "poids": "⚖️ <strong>Poids:</strong> 2"
    },
    {
      "nom": "Petite potion de vie",
      "numero": 12,
      "image": "",
      "description": "<i>Une fiole écarlate dont le liquide vif régénère les blessures et ranime les forces vitales.</i>",
      "tags": [
        "Consommable"
      ],
      "effet": "<strong>Effet:</strong> Rend 15 (critique : 25) points de vie au héros.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Petite potion de mana",
      "numero": 13,
      "image": "",
      "description": "<i>Une essence azur miroitante qui restaure l’énergie magique et ravive le flux des arcanes.</i>",
      "tags": [
        "Consommable"
      ],
      "effet": "<strong>Effet:</strong> Rend 20 (critique : 35) points de mana au héros.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Baguette de boule de feu",
      "numero": 14,
      "image": "",
      "description": "<i>Une fine tige runique qui libère des flammes brûlantes au commandement de son porteur.</i>",
      "tags": [
        "Consommable",
        "Catalyseur"
      ],
      "effet": "<strong>Effet:</strong> Remplace votre prochaine action principale par le sort de mage <span class=\"spell-link\" data-spell=\"Boule de Feu\" data-category=\"Sorts de Mage\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Boule de Feu</span>. <br><i>Les prérequis pour le sort ne sont pas requis mais le mana et l'intelligence du héros sont utilisés.</i>\n    <br><br><strong>Charges :</strong> 3",
      "prix": "🔷 <strong>Prix:</strong> 25",
      "poids": ""
    },
    {
      "nom": "Feuilleclaire",
      "numero": 15,
      "image": "",
      "description": "<i>Herbe des forêts profondes, aux feuilles luisantes et aux petites fleurs rosées. Appliquée directement sur la peau, elle referme les plaies et apaise la douleur presque instantanément.</i>",
      "tags": [
        "Consommable",
        "Plante"
      ],
      "effet": "<strong>Effet:</strong> Rend 10 (critique : 20) points de vie au héros ou à une cible proche.\n<br>Tous les 5 points d'intelligence, augmente les soins de 1.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Nocteline",
      "numero": 16,
      "image": "",
      "description": "<i>une plante sombre aux fleurs violettes dont l’essence neutralise les venins et purifie le sang.</i>",
      "tags": [
        "Consommable",
        "Plante"
      ],
      "effet": "<strong>Prérequis:</strong> Intelligence 5.<br>\n<strong>Effet:</strong> Soigne le héros ou une cible proche du poison.",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Baguette de d'accélération",
      "numero": 17,
      "image": "",
      "description": "<i>Une fine tige de cristal rayonnant, dont l’éclat sacré nimbe son porteur d’une aura éclatante, lui conférant une vitesse surnaturelle et des réflexes fulgurants.</i>",
      "tags": [
        "Consommable",
        "Catalyseur"
      ],
      "effet": "<strong>Effet:</strong> Remplace votre prochaine action principale par le sort d'enchanteur <span class=\"spell-link\" data-spell=\"Accélération\" data-category=\"Sorts d'Enchanteur\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Accélération</span>. <br><i>Les prérequis pour le sort ne sont pas requis mais le mana et l'intelligence du héros sont utilisés.</i>\n    <br><br><strong>Charges :</strong> 3",
      "prix": "🔷 <strong>Prix:</strong> 30",
      "poids": ""
    },
    {
      "nom": "Baguette de sommeil",
      "numero": 18,
      "image": "",
      "description": "<i>Une tige sombre incrustée de gemmes lunaires, qui libère une aura ténébreuse plongeant ses cibles dans un profond sommeil enchanté.</i>",
      "tags": [
        "Consommable",
        "Catalyseur"
      ],
      "effet": "<strong>Effet:</strong> Remplace votre prochaine action principale par le sort d'enchanteur <span class=\"spell-link\" data-spell=\"Sommeil\" data-category=\"Sorts d'Enchanteur\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Sommeil</span>. <br><i>Les prérequis pour le sort ne sont pas requis mais le mana et l'intelligence du héros sont utilisés.</i>\n    <br><br><strong>Charges :</strong> 3",
      "prix": "🔷 <strong>Prix:</strong> 30",
      "poids": ""
    },
    {
      "nom": "Ration de nourriture",
      "numero": 19,
      "image": "",
      "description": "<i>Un paquet frugal de pain sec et de viande salée.</i>",
      "tags": [
        "Nourriture"
      ],
      "effet": "Inutilisable en combat.\n<br><strong>Effet:</strong> Restore (Endurance) points de vie. <br>Couplé à un sommeil de 8h, permet d'éviter l'etat <span class=\"etat-link\" data-etat=\"Fatigué\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Fatigué</span>.",
      "prix": "🔷 <strong>Prix:</strong> 5",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Ration copieuse de nourriture",
      "numero": 20,
      "image": "",
      "description": "<i>Un coffret garni de mets fins et de vin épicé, offrant réconfort et vigueur bien au-delà de la simple survie</i>",
      "tags": [
        "Nourriture"
      ],
      "effet": "Inutilisable en combat.\n<br><strong>Effet:</strong> Restore (Endurance) points de vie. <br>Couplé à un sommeil de 8h, permet d'éviter l'etat <span class=\"etat-link\" data-etat=\"Fatigué\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Fatigué</span>.\n<br><b>Charges :</b> 3",
      "prix": "🔷 <strong>Prix:</strong> 15",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Fruits de la forêt",
      "numero": 21,
      "image": "",
      "description": "<i>Des baies juteuses et sucrées, cueillies à l’ombre des grands arbres, qui redonnent fraîcheur et énergie.</i>",
      "tags": [
        "Nourriture"
      ],
      "effet": "Inutilisable en combat.\n<br><strong>Effet:</strong> Restore (Endurance) points de vie. <br>Couplé à un sommeil, permet d'éviter l'etat <span class=\"etat-link\" data-etat=\"Fatigué\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Fatigué</span>. <br>De plus, lorsque consommé, le mangeur ne neccessite plus que 4 heures de sommeil ce jour-ci.\n<br><br><b>Charges :</b> 3",
      "prix": "🔷 <strong>Prix:</strong> 20",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Ration de survie",
      "numero": 22,
      "image": "",
      "description": "<i>Un maigre assemblage de galettes sèches, de viande fumée et d’eau amère, conçu pour soutenir la flamme vitale dans les heures les plus sombres.</i>",
      "tags": [
        "Nourriture"
      ],
      "effet": "Inutilisable en combat.\n<br><strong>Effet:</strong> Couplé à un sommeil de 8h, permet d'éviter l'etat <span class=\"etat-link\" data-etat=\"Fatigué\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Fatigué</span>.",
      "prix": "",
      "poids": "⚖️ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Flèche aiguisée",
      "numero": 23,
      "image": "",
      "description": "<i>Un trait finement taillé, dont la pointe acérée perce l’armure avec une précision mortelle.</i>",
      "tags": [
        "Consommable",
        "Flèche"
      ],
      "effet": "<b>Effet :</b> Renforce la prochaine attaque à l'arc et lui rajoute +3 points de dégats physiques en cas de réussite de l'attaque.\n\n<br><br><b>Charges :</b> 3",
      "prix": "🔷 <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Flèche de la terre",
      "numero": 24,
      "image": "",
      "description": "<i>Une flèche alourdie de pierres runiques, qui libère la force brutale de l’élément Terre à l’impact.</i>",
      "tags": [
        "Consommable",
        "Flèche"
      ],
      "effet": "<b>Effet :</b> Renforce la prochaine attaque à l'arc et lui rajoute +5 points de dégats élémentaire de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> en cas de réussite de l'attaque.\n\n<br><br><b>Charges :</b> 3",
      "prix": "🔷 <strong>Prix:</strong> 20",
      "poids": ""
    }
  ],
  "filterSettings": {
    "visibleTags": [
      "Consommable"
    ],
    "displayedFilterButtons": [
      "Arme",
      "Armure",
      "Consommable",
      "Bouclier"
    ]
  },
  "categoryDescription": "Équipements, armes, armures et objets divers que peuvent posséder les personnages.",
  "description": "Fortune + d20"
};
    window.MONSTRES = [
  {
    "nom": "Araignée Géante",
    "tags": [
      "Forêt"
    ],
    "image": "data/images/Monstres/foret/Monstre_Forêt_AraignéeGéante.png",
    "element": "Nuit",
    "pointsDeVie": 15,
    "armurePhysique": "0",
    "esquive": "2",
    "initiative": "3",
    "coupCritique": "1",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "3",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": "2",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": "5",
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Morsure venimeuse:</strong> Inflige 5 dégâts Physiques. <br> Si (resistance altérations &lt; 3)  + <span class=\"etat-link\" data-etat=\"Empoisonné\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Empoisonné</span> 1 pendant 5 tours.<br><br><strong>Toile:</strong> Portée 9m, equivable, <span class=\"etat-link\" data-etat=\"Entravé/Entoilé/Embourbé\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Entoile</span> la cible pendant 2 tour.",
    "butin": "<strong>Butin:</strong>",
    "monster-abilites": "AAAAAAAA",
    "monster-armurephysique": "0",
    "monster-coupcritique": "1",
    "monster-esquive": "2",
    "monster-resistancealterations": "3",
    "monster-coupcritiquesorts": "0",
    "monster-armureterre": "2",
    "monster-armureobscurite": "5",
    "monster-initiative": "3"
  },
  {
    "nom": "Crabe des Bois",
    "tags": [
      "Forêt"
    ],
    "image": "data/images/Monstres/foret/Monstre_Forêt_CrabedesBois.png",
    "element": "Eau",
    "pointsDeVie": "30",
    "armurePhysique": "5",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "1",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "5",
    "armureFeu": 0,
    "armureEau": "5",
    "armureTerre": "2",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "Attaque deux fois<br>  <strong>Pinces acérées:</strong> Inflige 7 dégâts",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "Groink",
    "tags": [
      "Forêt"
    ],
    "image": "data/images/Monstres/foret/Monstre_Forêt_Groink.png",
    "element": "Terre",
    "pointsDeVie": "15",
    "armurePhysique": "0",
    "esquive": "1",
    "initiative": 1,
    "coupCritique": "0",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": 3,
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": "3",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": "2",
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Charge brutale:</strong> Fonce et Inflige 5 dégâts. Critique : <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span><br><strong>Lance rocher:</strong> Portée 15m,  4 dégats physiques.",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "Groinka",
    "tags": [
      "Forêt"
    ],
    "image": "data/images/Monstres/foret/Monstre_Forêt_Groinka.png",
    "element": "Terre",
    "pointsDeVie": "15",
    "armurePhysique": "0",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "0",
    "coupCritiqueSorts": "1",
    "resistanceAlterations": "4",
    "armureFeu": "0",
    "armureEau": "0",
    "armureTerre": "3",
    "armureAir": "0",
    "armureLumiere": 0,
    "armureObscurite": 2,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "Attaque : <span class=\"spell-link\" data-spell=\"Volée de pierres\" data-category=\"Sorts de Mage\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Volée de pierres</span>  <br>Soin : <span class=\"spell-link\" data-spell=\"Soin mineur\" data-category=\"Sorts de Prêtre\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Soin mineur</span> <br> Alteration: \n<span class=\"spell-link\" data-spell=\"Accroche terrestre\" data-category=\"Sorts d'Enchanteur\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Accroche terrestre</span>",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "Guêpe Géante",
    "tags": [
      "Forêt"
    ],
    "image": "data/images/Monstres/foret/Monstre_Forêt_GuêpeGéante.png",
    "element": "Air",
    "pointsDeVie": "15",
    "armurePhysique": 0,
    "esquive": "5",
    "initiative": 1,
    "coupCritique": "3",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "3",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": 0,
    "armureAir": "5",
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Volant</strong>: Necessite de sauter pour attaque au corps à corps.<br><strong>Dard: </strong> Inflige 5 degats physiques + 3 <span style=\"color: #22c55e; font-weight: bold;\">Air</span>. Critique : <span class=\"etat-link\" data-etat=\"Empoisonné\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Empoisonné</span> 1 , 5 tours",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "5"
  },
  {
    "nom": "Ours des Bois",
    "tags": [
      "Forêt"
    ],
    "image": "data/images/Monstres/foret/Monstre_Forêt_OursdesBois.png",
    "element": "Terre",
    "pointsDeVie": "40",
    "armurePhysique": 4,
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "1",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "4",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": 2,
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 1,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Griffes dévastatrices:</strong> Inflige 7 dégâts physiques à une cible.<br><strong>Rugissement:</strong> Cible à 9m  <span class=\"etat-link\" data-etat=\"Affaibli\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Affaibli</span> , si  (resistance altérations &lt; 4)",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "1"
  },
  {
    "nom": "Pouple de la forêt",
    "tags": [
      "Forêt"
    ],
    "image": "",
    "element": "Eau",
    "pointsDeVie": "10",
    "armurePhysique": "0",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "0",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "0",
    "armureFeu": 0,
    "armureEau": "5",
    "armureTerre": 0,
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Accroche:</strong> Inflige 4 dégâts physiques. S'attache à la cible, qui devient <span class=\"etat-link\" data-etat=\"Ralenti\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Ralenti</span>.",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "2"
  },
  {
    "nom": "Serpent de la forêt",
    "tags": [
      "Forêt"
    ],
    "image": "",
    "element": "Terre",
    "pointsDeVie": 20,
    "armurePhysique": "0",
    "esquive": 5,
    "initiative": 1,
    "coupCritique": "2",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": 3,
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": "5",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Morsure venimeuse:</strong> Inflige 5 dégâts Physiques. <br> Si (resistance altérations &lt; 4)  + <span title=\"Des dégats sont appliqués à chaque début de tour du lanceur, réduits ni par l'armure physique ni par l'armure élémentaire.\">Empoisonné</span>2 pendant 5 tours.<br><br>",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "4"
  },
  {
    "nom": "Scarabée géant",
    "tags": [
      "Forêt"
    ],
    "image": "",
    "element": "Air",
    "pointsDeVie": 20,
    "armurePhysique": "3",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "0",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "5",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": 0,
    "armureAir": "5",
    "armureLumiere": 0,
    "armureObscurite": "5",
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Volant</strong>: Necessite de sauter pour attaque au corps à corps.<br><strong>Morsure: </strong> inflige 5 physique.\n<br><strong>Vent aveuglant: </strong> Portée 6m, esquivable, inflige 5 <span style=\"color: #22c55e; font-weight: bold;\">Air</span>. Si (Res Alt &lt; 4) <span class=\"etat-link\" data-etat=\"Aveuglé\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Aveuglé</span>",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "5"
  },
  {
    "nom": "Boss Forêt",
    "tags": [
      "Forêt"
    ],
    "image": "",
    "element": "Terre",
    "pointsDeVie": "200",
    "armurePhysique": "3",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "2",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "10",
    "armureFeu": 0,
    "armureEau": "0",
    "armureTerre": "10",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": "5",
    "armureDivin": 0,
    "armureMalefique": "5",
    "abilites": "Double attaque.<br><strong>Attaque basique:</strong> Inflige 10 dégâts physiques. <br><strong>Hurlement:</strong> Tous les adversaires à 15m, avec Resistance altération &lt; 6, sont <span class=\"etat-link\" data-etat=\"Affaibli\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Affaibli</span>.  \n<br><b>Repoussoir</b>: Repousse une une cible à 9m. Inflige 5 dégats.\n<br><b>Appel </b>: Hurle et fait venir 2 Groinkas.\n<br><b>Tremblement de terre </b>: Tous les adversaires à 15m, 7 dégats <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> , critique 12.",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "3"
  }
];
    window.TABLES_TRESORS = {
  "tables": [
    {
      "nom": "Monstre forêt commun",
      "description": "feffez",
      "tags": [
        "Forêt"
      ],
      "fourchettes": [
        {
          "min": 1,
          "max": 3,
          "objet": {
            "type": "reference",
            "numero": 15,
            "nom": "Feuilleclaire"
          }
        },
        {
          "min": 4,
          "max": 6,
          "objet": {
            "type": "reference",
            "numero": 16,
            "nom": "Nocteline"
          }
        },
        {
          "min": 7,
          "max": 9,
          "objet": {
            "type": "reference",
            "numero": 13,
            "nom": "Petite potion de mana"
          }
        },
        {
          "min": 10,
          "max": 12,
          "objet": {
            "type": "reference",
            "numero": 12,
            "nom": "Petite potion de vie"
          }
        },
        {
          "min": 13,
          "max": 15,
          "objet": {
            "type": "reference",
            "numero": 21,
            "nom": "Fruits de la forêt"
          }
        },
        {
          "min": 16,
          "max": 19,
          "objet": {
            "type": "reference",
            "numero": 17,
            "nom": "Baguette de d'accélération"
          }
        }
      ]
    },
    {
      "nom": "Boss forêt",
      "description": "BBB",
      "tags": [
        "Forêt",
        "Boss"
      ],
      "fourchettes": [
        {
          "min": 1,
          "max": 3,
          "objet": {
            "type": "reference",
            "numero": 21,
            "nom": "Fruits de la forêt"
          }
        },
        {
          "min": 4,
          "max": 8,
          "objet": {
            "type": "reference",
            "numero": 11,
            "nom": "Armure de plaque"
          }
        },
        {
          "min": 9,
          "max": 12,
          "objet": {
            "type": "reference",
            "numero": 18,
            "nom": "Baguette de sommeil"
          }
        },
        {
          "min": 13,
          "max": 16,
          "objet": {
            "type": "reference",
            "numero": 8,
            "nom": "Robe simple"
          }
        },
        {
          "min": 17,
          "max": 20,
          "objet": {
            "type": "reference",
            "numero": 4,
            "nom": "Bâton en bois"
          }
        }
      ]
    }
  ],
  "_metadata": {
    "availableTags": [
      "Forêt",
      "Boss",
      "Coffre"
    ]
  }
};
    window.COLLECTIONS = {
  "collections": [
    {
      "id": "d-part",
      "nom": "Départ",
      "description": "Objets disponibles à la création du personnage.",
      "icon": "📦",
      "objets": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        12,
        16,
        15,
        14,
        18,
        13,
        19,
        20,
        23
      ]
    }
  ]
};
    window.IMAGES = {
  "images": {
    "subclass:Guerrier:Nain des montagnes": "https://i.ibb.co/Zpv02X9p/e8c10c36dc90.jpg",
    "subclass:Guerrier:Berserker": "https://i.ibb.co/DPYjyGVd/b85000c2afa4.jpg",
    "subclass:Mage:Érudit": "https://i.ibb.co/M5pcNmF9/05fa4e535010.jpg",
    "subclass:Mage:Elfe": "https://i.ibb.co/K1SMkgb/d738588e0528.jpg",
    "subclass:Prêtre:Inquisiteur": "https://i.ibb.co/dJ02RNMc/c9cd3553df7e.jpg",
    "subclass:Prêtre:Clerc Divin": "https://i.ibb.co/8gFGZYqJ/698304cc75ee.jpg",
    "subclass:Rôdeur:Voleur": "https://i.ibb.co/q3jSxDnQ/90e89c692b47.jpg",
    "subclass:Rôdeur:Chasseur": "https://i.ibb.co/70wP75z/53de7da9e55c.jpg",
    "subclass:Enchanteur:Esprit de la grande Fée": "https://i.ibb.co/Cswfsyzz/9920a4e75242.jpg",
    "subclass:Enchanteur:Lutin": "https://i.ibb.co/Fbspq9hP/dd5e7b366e0f.jpg",
    "sort:Sorts de Mage:Boule de Feu": "https://i.ibb.co/vCWmgrQ5/Boule-De-Feu.png",
    "sort:Sorts de Mage:Éclair": "https://i.ibb.co/h194qhvd/Eclair.png",
    "sort:Sorts de Mage:Vague déferlante": "https://i.ibb.co/BSHtL8K/Vague.png",
    "sort:Sorts de Prêtre:Châtiment": "https://i.ibb.co/JRPyXx1L/Chatiment-Sacr.png",
    "sort:Sorts de Prêtre:Soin mineur": "https://i.ibb.co/YBC2HSnK/Soin-Mineur.png",
    "sort:Sorts d'Enchanteur:Accroche terrestre": "https://i.ibb.co/27W4NtSQ/Accroche-Terre.png",
    "sort:Sorts d'Enchanteur:Accélération": "https://i.ibb.co/Vc072qQB/Acceleration.png",
    "sort:Sorts d'Enchanteur:Sommeil": "https://i.ibb.co/rKyTh27C/Sleep.png",
    "sort:Sorts de Prêtre:Nouveau Sort": "https://i.ibb.co/cXh57Pdn/ArmeLum.png",
    "sort:Sorts de Prêtre:Protection": "https://i.ibb.co/QvK52kxH/Protection.png",
    "subclass:Guerrier:Nain des montagnes:1": "https://i.ibb.co/FL9m5HJn/Nain.png",
    "subclass:Guerrier:Nain des montagnes:2": "https://i.ibb.co/wNnJxSbj/NaineF.png",
    "subclass:Guerrier:Berserker:1": "https://i.ibb.co/YBWFbTKv/berseker.png",
    "subclass:Guerrier:Berserker:2": "https://i.ibb.co/20b74x2R/Berseker-F.png",
    "subclass:Mage:Érudit:1": "https://i.ibb.co/N8qT2Hf/Mage.png",
    "subclass:Mage:Érudit:2": "https://i.ibb.co/LdcPDSJQ/MageF.png",
    "subclass:Mage:Elfe:2": "https://i.ibb.co/VWDTjY8H/ElfeF.png",
    "subclass:Mage:Elfe:1": "https://i.ibb.co/gFVKrTcV/Elfe.png",
    "subclass:Prêtre:Inquisiteur:1": "https://i.ibb.co/tMcsCB8s/Inquisiteur.png",
    "subclass:Prêtre:Clerc Divin:1": "https://i.ibb.co/209W4ZHW/Pr-tre.png",
    "subclass:Rôdeur:Voleur:1": "https://i.ibb.co/NghMq11n/Voleur-min.png",
    "subclass:Rôdeur:Voleur:2": "https://i.ibb.co/h1BtkGMX/VoleurF.png",
    "subclass:Rôdeur:Chasseur:1": "https://i.ibb.co/yF8jrJYr/Chasseur-min.png",
    "subclass:Rôdeur:Chasseur:2": "https://i.ibb.co/3mQjLJbp/Chasseur-F.png",
    "subclass:Enchanteur:Esprit de la grande Fée:1": "https://i.ibb.co/VY9cQHNh/F-eM.png",
    "subclass:Enchanteur:Esprit de la grande Fée:2": "https://i.ibb.co/pjxDfXBC/F-e.png",
    "subclass:Enchanteur:Lutin:1": "https://i.ibb.co/6cxkMW1d/Lutin.png",
    "subclass:Enchanteur:Lutin:2": "https://i.ibb.co/qLbjJhxw/LutinF.png",
    "subclass:Prêtre:Inquisiteur:2": "https://i.ibb.co/LXwmWYR3/Inquisiteur-F.png",
    "subclass:Prêtre:Clerc Divin:2": "https://i.ibb.co/HfBVNLM3/PretreF.png",
    "sort:Sorts de Prêtre:Arme de lumière": "https://i.ibb.co/cXh57Pdn/ArmeLum.png",
    "objet:Épée Longue": "https://i.ibb.co/35rpP6ZS/Epee2M1.png",
    "objet:Espadon": "https://i.ibb.co/35rpP6ZS/Epee2M1.png",
    "objet:Simple épée": "https://i.ibb.co/PsSXvSXx/Epee1.png",
    "objet:Dague en fer": "https://i.ibb.co/1fCwy6cR/Dague1.png",
    "objet:Bâton en bois": "https://i.ibb.co/PsyCNw86/Baton1.png",
    "objet:Gourdin": "https://i.ibb.co/whZCKww0/Baton2.png",
    "objet:Arc simple": "https://i.ibb.co/cKb1JKZQ/Arc1.png",
    "objet:Bouclier en bois": "https://i.ibb.co/67bK4Bw8/Bouclier1.png",
    "objet:Robe simple": "https://i.ibb.co/VYFpnz8h/Robe1.png",
    "objet:Armure de cuir": "https://i.ibb.co/9Hkw2VFb/Armure-Cuir1.png",
    "objet:Armure en maille": "https://i.ibb.co/cXtwzw5b/Armure-Lourde1.png",
    "objet:Armure de plaque": "https://i.ibb.co/fVg5Fp6h/Armure-Lourde2.png",
    "subclass:Guerrier:Aventurier:1": "https://i.ibb.co/9HcQkbb2/Aventurier.png",
    "subclass:Guerrier:Aventurier:2": "https://i.ibb.co/nH8Yj3h/Aventurier-F.png",
    "objet:Petite potion de vie": "https://i.ibb.co/Mw2Qb8Y/LifePot1.png",
    "objet:Petite potion de mana": "https://i.ibb.co/MkwzbQ3S/Potion-Mana1.png",
    "objet:Baguette de boule de feu": "https://i.ibb.co/JwXs3k2V/Baguette-Feu.png",
    "objet:Feuilleclaire": "https://i.ibb.co/bMDstDVV/Herb1.png",
    "objet:Nocteline": "https://i.ibb.co/7JpQ7Kr7/Herb2.png",
    "objet:Nouvel Objet": "https://i.ibb.co/Py57FHy/Food0.png",
    "objet:Baguette de sommeil": "https://i.ibb.co/bMXNS4gy/Baguette-Nuit.png",
    "monster:Araignée Géante": "https://i.ibb.co/b0XHjQJ/Monstre-For-t-Araign-e.png",
    "monster:Crabe des Bois": "https://i.ibb.co/7dY3GgJS/Monstre-For-t-Crab.png",
    "monster:Groink": "https://i.ibb.co/MDngQGcS/Monstre-For-t-Groink.png",
    "monster:Groinka": "https://i.ibb.co/YThB7Q29/Monstre-For-t-Groink-Chaman.png",
    "monster:Guêpe Géante": "https://i.ibb.co/bjSq3pPj/Monstre-For-t-Guepe-Geante.png",
    "monster:Ours des Bois": "https://i.ibb.co/N2NcD6n2/Monstre-For-t-Ours.png",
    "monster:Pouple de la forêt": "https://i.ibb.co/0jG2WLsv/Monstre-For-t-Poulpe.png",
    "monster:Serpent de la forêt": "https://i.ibb.co/svhHLvKZ/Monstre-For-t-Serpent.png",
    "monster:Scarabée géant": "https://i.ibb.co/wF5bRvts/Monstre-For-t-Scarabe-Geant.png",
    "monster:Boss Forêt": "https://i.ibb.co/1JR11CC7/Monstre-For-t-Boss.png",
    "sort:Sorts de Mage:Volée de pierres": "https://i.ibb.co/GfPFdZPG/Volee-Pierre.png",
    "objet:Baguette de d'accélération": "https://i.ibb.co/zT29mKBd/Baguette-Lumiere.png",
    "objet:Ration de nourriture": "https://i.ibb.co/tT6gW6p0/Food1.png",
    "objet:Ration copieuse de nourriture": "https://i.ibb.co/7JZW2ZZT/Food2.png",
    "objet:Fruits de la forêt": "https://i.ibb.co/svC0cDH6/food3.png",
    "sort:Sorts de Prêtre:Refermer les blessures": "https://i.ibb.co/zV1rzFkd/Soin-Mineur.png",
    "objet:Ration de survie": "https://i.ibb.co/Py57FHy/Food0.png",
    "subclass:Guerrier:Nouvelle sous-classe:1": "https://i.ibb.co/dsPhMWkY/Ma-tre-d-armes.png",
    "subclass:Guerrier:Maître d’armes:1": "https://i.ibb.co/dsPhMWkY/Ma-tre-d-armes.png",
    "subclass:Guerrier:Maître d’armes:2": "https://i.ibb.co/BVD015MF/Ma-tre-d-armes-F.png",
    "objet:Flèche aiguisée": "https://i.ibb.co/4Z7qKXCx/Fleche-Aiguis-e.png",
    "objet:Flèche de la terre": "https://i.ibb.co/ZpScRTwS/Fleche-Terre.png",
    "page:geographie": "https://i.ibb.co/svmYXJbN/Carte-fantastique-d-taill-e-et-color-e.png"
  },
  "meta": {
    "total_images": 85,
    "exported_date": "2025-09-03",
    "note": "Ces images incluent les nouvelles images uploadées"
  }
};
    
    // Page descriptions
    window.MONSTRES_PAGE_DESC = {
  "description": "Créatures, ennemis et adversaires que peuvent affronter les héros dans leurs aventures."
};
    window.TABLES_TRESORS_PAGE_DESC = {
  "description": "Fortune + d20"
};
    
    // Custom page descriptions for collections and other dynamic pages
    window.CUSTOM_PAGE_DESCRIPTIONS = {
  "collections-objets": "Recherchez et explorez des collections d'objets.\n<br>Par exemple, tapez <b>Départ</b> pour voir les objets disponnibles lors de la création du personnage.\n<br>Les collections sont cachées de base pour éviter le <b>spoil</b>."
};
    
    // TOC Structure for advanced navigation
    window.TOC_STRUCTURE = {
  "sections": [
    {
      "id": "heros",
      "title": "🦸 Héros",
      "icon": "🦸",
      "description": "Création et développement des personnages",
      "collapsed": false,
      "items": [
        {
          "type": "page",
          "id": "creation",
          "title": "Création d'un personnage",
          "icon": "🎭"
        },
        {
          "type": "category",
          "id": "classes",
          "title": "Classes",
          "icon": "⚔️",
          "items": "CLASSES"
        },
        {
          "type": "category",
          "id": "dons",
          "title": "Dons",
          "icon": "🎖️",
          "items": "DONS"
        },
        {
          "type": "page",
          "id": "feuille-personnage",
          "title": "Feuille de personnage",
          "icon": "📋"
        }
      ]
    },
    {
      "id": "arsenal",
      "title": "⚔️ Arsenal",
      "icon": "⚔️",
      "description": "Sorts, objets et équipements",
      "collapsed": false,
      "items": [
        {
          "type": "category",
          "id": "sorts",
          "title": "Sorts",
          "icon": "🔮",
          "items": "SORTS"
        },
        {
          "type": "page",
          "id": "objets",
          "title": "Objets",
          "icon": "📦"
        },
        {
          "type": "page",
          "id": "collections-objets",
          "title": "Collections d'Objets",
          "icon": "📚"
        }
      ]
    },
    {
      "id": "regles",
      "title": "📚 Règles",
      "icon": "📚",
      "description": "Mécaniques de jeu et références",
      "collapsed": false,
      "items": [
        {
          "type": "page",
          "id": "elements",
          "title": "Éléments",
          "icon": "🌟"
        },
        {
          "type": "page",
          "id": "stats",
          "title": "Statistiques",
          "icon": "📊"
        },
        {
          "type": "page",
          "id": "competences-tests",
          "title": "Compétences & Tests",
          "icon": "🎯"
        },
        {
          "type": "page",
          "id": "etats",
          "title": "États",
          "icon": "⚡"
        },
        {
          "type": "page",
          "id": "combat",
          "title": "Combat",
          "icon": "⚔️"
        },
        {
          "type": "page",
          "id": "gestion-des-ressources",
          "title": "Gestion des ressources",
          "icon": "💎"
        }
      ]
    },
    {
      "id": "maitre-de-jeu",
      "title": "🎭 Maître de jeu",
      "icon": "🎭",
      "description": "Outils et ressources pour le Maître de jeu",
      "collapsed": false,
      "requiresMJ": true,
      "items": [
        {
          "type": "page",
          "id": "monstres",
          "title": "Monstres",
          "icon": "👹"
        },
        {
          "type": "page",
          "id": "tables-tresors",
          "title": "Tables de trésors",
          "icon": "💎"
        },
        {
          "type": "page",
          "id": "audio",
          "title": "Musiques d'ambiance",
          "icon": "🎵"
        },
        {
          "type": "page",
          "id": "traumas",
          "title": "Traumas",
          "icon": "🩹"
        },
        {
          "type": "page",
          "id": "campagne",
          "title": "Campagne",
          "icon": "📖"
        }
      ]
    },
    {
      "id": "monde",
      "title": "🌍 Monde",
      "icon": "🌍",
      "description": "Univers et connaissances du monde",
      "collapsed": false,
      "items": [
        {
          "type": "page",
          "id": "histoire",
          "title": "Histoire",
          "icon": "📜"
        },
        {
          "type": "page",
          "id": "dieux",
          "title": "Dieux",
          "icon": "🏛️"
        },
        {
          "type": "page",
          "id": "geographie",
          "title": "Geographie",
          "icon": "📜"
        }
      ]
    }
  ]
};
    
    // Build STATIC_PAGES dynamically from all loaded page data
    window.STATIC_PAGES = {
      'creation': {
  "page": "creation",
  "title": "Création d'un personnage",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "",
      "id": "section-0"
    },
    {
      "type": "card",
      "id": "etapes-creation",
      "title": "Étapes de création",
      "content": "<ol><li>Choisir une <strong>classe</strong> puis une <strong>sous‑classe</strong> : <a href=\"#/guerrier\" style=\"color: var(--accent); text-decoration: underline;\">Guerrier</a>.</li><li>Choisir un <strong>élément</strong> d'affiliation : <a href=\"#/elements\" style=\"color: var(--accent); text-decoration: underline;\">Éléments</a>.</li><li>Choisir les <strong>dons</strong> (avec 2 points de dons) : <a href=\"#/dons-generaux\" style=\"color: var(--accent); text-decoration: underline;\">Generaux (dons)</a>.</li><li>Choisir l'<strong>équipement</strong> de départ (avec 100 éclats) : <a href=\"#/collections-objets\" style=\"color: var(--accent); text-decoration: underline;\">Collections d'Objets</a>.</li><li>Définir le <strong>nom</strong>, l'<strong>histoire</strong> et l'<strong>apparence</strong>.</li><li>Remplir sa feuille de personnage : <a href=\"#/feuille-personnage\" style=\"color: var(--accent); text-decoration: underline;\">Feuille de personnage</a>.</li></ol>",
      "deletable": true,
      "sectionName": "Étapes de création"
    }
  ]
},
      'elements': {
  "page": "elements",
  "title": "Elements",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "elements-system",
      "title": "Système d'éléments",
      "content": "<p>Il existe huit éléments, chacun ayant un opposé. Chaqué Héros où monstre possède un élément d'affiliation.<br><br> Une créature affiliée à un élément :<br> - Reçoit <strong>deux fois moins </strong>de dégats venant des sorts et attaques de cet élément, et ne peut pas recevoir d'effet critique d'une alteration magique de cet élément.<br>- Recevra systématiquement des <strong>effets critiques</strong> venant des sorts et altérations de l'élément opposé. Les dégats élémentaires rattachés à une attaque physique (venant d'un objet ou sort) voit ses dégats doublés s'il est d'un élément opposé.</p>"
    },
    {
      "type": "card",
      "id": "element-pairs",
      "title": "Paires opposées",
      "content": "<div class=\"element-pairs\"><div class=\"pair\">🔥 <span style=\"color: #ff6b35; font-weight: bold;\">Feu</span> ⟷ 💧 <span style=\"color: #4682b4; font-weight: bold;\">Eau</span></div><div class=\"pair\">🤎 <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> ⟷ 🟢 <span style=\"color: #22c55e; font-weight: bold;\">Air</span></div><div class=\"pair\">☀️ <span style=\"color: #ffd700; font-weight: bold;\">Lumière</span> ⟷ ⚫ <span style=\"color: #1a1a1a; font-weight: bold;\">Nuit</span></div><div class=\"pair\">⚪ <span style=\"color: #f5f5f5; font-weight: bold; background: rgba(100, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;\">Divin</span> ⟷ 🟣 <span style=\"color: #8b5cf6; font-weight: bold;\">Maléfique</span></div></div>"
    },
    {
      "type": "card",
      "id": "element-defense",
      "title": "Défense",
      "content": "<p>Certaines armures/objets/bonus peuvent procurer une armure spécifique à un élément. Il faudra alors déduire au resultat final. Le calcul de dégats se fait dans cet ordre :</p><div><strong>Dégats → critique → ×0.5 si affiliation élément → réduction de l'armure</strong></div>",
      "deletable": true,
      "sectionName": "Défense"
    },
    {
      "type": "card",
      "id": "element-attack",
      "title": "Attaque",
      "content": "<p>Une attaque ne peut avoir qu'<strong>un seul élément</strong> (en plus d'éventuels dégats physiques). Si plusieurs sorts/équipements/bonus donnent un élément à l'attaque, le héros devra choisir quel est l'élément utilisé.</p> Plusieurs bonus d'un même élément peuvent se cumuler.\n<br><br> Si l'élément rattaché à une attaque physiques est opposé à l'élément d'affiliation de la cible, alors les dégats élémentaires sont doublés.",
      "deletable": true,
      "sectionName": "Attaque"
    }
  ]
},
      'stats': {
  "page": "stats",
  "title": "Statistiques",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "stats-base",
      "title": "Statistiques de base",
      "content": "<hr><div class=\"stats-grid\"><div class=\"stat-card\"><h4>💪 Force</h4><p>Améliore les dégâts physiques.</p></div><hr><div class=\"stat-card\"><h4>🛡️ Endurance</h4><p>Les points de vie maximum sont de : <strong>(10 + 2 x Endurance)</strong></p><p>Augmente les soins prodigués par la consommation de nourriture.</p></div><hr><div class=\"stat-card\">\n<h4>🏃 Agilité</h4><p>Chaque 5 points ajoutent <strong>+1</strong> aux jets d'esquive et de critique physique.<br><br>Augmente l'initiative d'autant.</p></div><hr><div class=\"stat-card\"><h4>🧠 Intelligence</h4><p>Détermine la puissance des sorts.</p></div><hr><div class=\"stat-card\"><h4>⚡ Volonté</h4><p>Le mana maximum est de : <strong>(20 + 2 x Volonté)</strong></p><p>Augmente la Résistance altérations.</p></div><hr><div class=\"stat-card\"><h4>🍀 Chance</h4><p>Améliore la Fortune d'autant.</p><p>De plus, chaque 5 points ajoutent <strong>+1</strong> aux chances de coup critique avec les sorts et les consommables.</p></div></div>",
      "deletable": true,
      "sectionName": "Statistiques de base"
    },
    {
      "type": "card",
      "id": "stats-new-3-1755784997112",
      "title": "Statistiques secondaires",
      "content": "<hr><br><br><strong>Chance de coup critique (physique) </strong> : Lors d'une attaque physique, le lanceur de l'attaque lance un d20. S'il fait 20, alors les dégats physiques (et seulement physiques) sont doublés.<br> Augmenter les chances de coup critique réduit la valeur du dé nécéssaire pour faire un critique. Par exemple, avec 3 de chance de coup critique, si le dé fait de 17 à 20, l'attaque est critique.\n\n<br><br><hr><br><strong>Chance de coup critique (sorts et consommables)</strong> : Lorsque un héros ou un monstre lance un sort ou utilise un consommable, il lance un d20. S'il fait 20, alors le sort est critique, chaque sort/consommable ayant un effet critique différent (indiqué dans sa description).<br> Augmenter les chances de coup critique des sorts et consommables réduit la valeur du dé nécéssaire pour faire un critique. Par exemple, avec 3 de chance de coup critique, si le dé fait de 17 à 20, le resultat est critique. \n\n<br><br><hr><br><strong>Esquive </strong> : Lors d'une attaque physique, ou d'un sort sans effet si esquive (indiqué dans la fiche du sort), lorsque le lanceur lance son d20, si le resultat est 1, l'attaque est sans effet. Avoir de l'esquive pour la cible de l'attaque augmente la valeur du dé jusqu'a laquelle l'attaque échoue. Par exemple, avec 3 d'esquive, si le dé fait 4 ou moins, l'attaque échoue. La valeur d'esquive ne peut jamais dépasser 9, quel que soit l'equipement ou bonus d'un joueur ou monstre.\n\n\n<br><br><hr><br><strong>Résistance altérations </strong> : Lorsqu'un lanceur de sort tente d'infliger une alteration magique à une cible, on compare la valeur de l'intelligence du lanceur à la Résistance altérations de la cible. Si l'intelligence est strictement supérieure, alors l'ateration réussit, sinon elle est sans effet.\n\n\n<br><br><hr><br><strong>Armure physique </strong> : Lorsqu'un héros ou monstre reçoit des dégats physiques, ils sont alors réduit de la valeur de l'armure physique pour savoir combien de points de vies sont retirés à la cible. Cette valeur est retiré en dernier sur les degats (aprés avoir éventuellement doublé les dégats si critique etc...)\n\n<br><br><hr><br><strong>Armure élémentaire </strong> : L'armure élémentaire est spécifique pour chaque élément, il y a donc 8 types d'armure élémentaire. Lorsqu'un héros ou monstre subit des dégats élémentaire correspondant à l'armure élémentaire, ils sont alors réduit de la valeur de l'armure pour savoir combien de points de vies sont retirés à la cible. Cette valeur est retiré en dernier sur les degats (aprés avoir éventuellement doublé les dégats si critique etc...).\n\n<br><br><hr><br><strong>Mana </strong> : Il s'agit de la ressource utilisée pour lancer des sorts. Hors combat, il revient automatiquement au maximum aprés plus d'une heure sans être en combat. En combat, il est consommé aprés le lancement de chaque sort (le coût en mana étant indiqué dans la description de chaque sort). Si un sort devait faire passer le mana d'un héros en dessous de 0, alors le sort n'est pas effectif et le héros devient <span class=\"etat-link\" data-etat=\"Endormi/assomé/Effrayé\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">paralysé</span> pendant 2 tours.\n\n<br><br><hr><br><strong>Vie </strong> : Les points de vie représentent la vitalité d’un héros ou d’un monstre, la mesure de son endurance face aux blessures. Tant qu’il lui reste des PV, le personnage peut continuer à se battre, à courir et à agir. Quand ses PV tombent à zéro, il s’effondre, mourant. Voir la page <a href=\"#/combat\" style=\"color: var(--accent); text-decoration: underline;\">Combat</a>.\nUn personnage qui effectue un repos régénère un nombre de points de vie égal à sa valeur d’Endurance.<br>\n\n<hr><br><strong>Fortune</strong> : Lorsqu’un événement fait appel à la Fortune (par exemple ouvrir un coffre et espérer y trouver un objet rare), le joueur lance un d20 et ajoute sa valeur de Fortune. Plus le total est élevé, meilleur sera le butin obtenu. \n\n<br><hr><br> <strong>Initiative</strong> : Cette valeur est comparée au début du combat avec tous les héros/monstres pour determiner l'ordre des tours de combat. Plus la valeur est élevée, plus le héros commence en premier.\n\n\n<br><hr><br> <strong>Taille </strong> : Détermine la taille d’une créature. Certains effets ne fonctionnent que sur certaines tailles :\n<ul>\n  <li><b>Petit</b> : 1 mètre ou moins</li>\n  <li><b>Moyen</b> : moins de 2 mètres</li>\n  <li><b>Grand</b> : moins de 3,5 mètres</li>\n  <li><b>Géant</b> : plus de 3,5 mètres</li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'competences-tests': {
  "page": "competences-tests",
  "title": "Compétences & Tests",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "grid",
      "cols": 2,
      "content": [
        {
          "type": "card",
          "id": "efforts",
          "title": "Efforts",
          "content": "<ul><li>Chaque héros dispose de 3 Efforts maximum.</li><li>Les héros récupèrent des efforts lors de repos courts ou longs.</li><li>Les Efforts peuvent être dépensés pour améliorer un test de compétence.</li></ul>",
          "deletable": true,
          "sectionName": "Efforts"
        },
        {
          "type": "card",
          "id": "competences-list",
          "title": "Compétences",
          "content": "<ul><li><em>Hardiesse</em>: Pousser, casser, sauter…</li><li><em>Finesse</em>: Crocheter, fabriquer, être discret…</li><li><em>Coordination</em>: Percevoir, équilibre, piloter…</li><li><em>Réflexion</em>: Savoir, comprendre, deviner…</li><li><em>Éloquence</em>: Persuader, mentir, intimider…</li></ul>",
          "deletable": true,
          "sectionName": "Compétences"
        }
      ]
    },
    {
      "type": "card",
      "id": "tests",
      "title": "Tests de compétences",
      "content": "<p>Quand un MJ annonce un test de compétence, un héros peut choisir de dépenser des efforts pour booster sa compétence. La difficulté d'un test est seule connue du MJ, et est entre 1 et 5 (Exigeant, Complexe , Éprouvant, Prodigieux , <strong>Impossible</strong>).</p><p>Une fois le test résolu, le Maître de Jeu annonce le résultat. Si le joueur a dépensé plus d'Efforts que nécessaire, l'excédent est perdu.</p><br> A noter que certaines actions sont impossibles à réaliser et un héros peut alors s'épuiser pour rien, s'il n'a pas bien évalué la difficulté de la tâche. A l'inverse, les tâches simples ne demandent pas de test de compétences.",
      "deletable": true,
      "sectionName": "Tests de compétences"
    }
  ]
},
      'etats': {
  "page": "etats",
  "title": "Etats",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "Lorsque un joueur subit un état, vous pouvez prendre une carte ou note pour avoir un rappel de l'effet. De plus, si c'est un état à durée limité, vous pouvez prendre un dé et le placer face au nombre de tour restant (en oubliant pas de changer sa valeur chaque début de tour).<br> Quand vous infligez des effets/alterations à un monstre, vous pouvez également utiliser un dé pour rappel (potentiellement d'une autre couleur, pour aider).\n<br>"
    },
    {
      "type": "card",
      "id": "a-terre",
      "title": "A terre",
      "content": "<p>Ne peut plus faire d'actions.</p><p> Ne peut plus esquiver.</p><p> Doit dépenser une action secondaire pour se relever.</p>",
      "deletable": true,
      "sectionName": "A terre"
    },
    {
      "type": "card",
      "id": "endormi-effraye",
      "title": "Endormi/assomé/Effrayé",
      "content": "<p>Ne peut plus faire d'actions.</p><p> Ne peut plus esquiver.</p><p> Des dégats infligés à la créature la sort de son état.</p>",
      "deletable": true,
      "sectionName": "Endormi/assomé/Effrayé"
    },
    {
      "type": "card",
      "id": "etats-new-4-1755725440741",
      "title": "Ralenti",
      "content": "Vitesse de déplacement réduite de 6m.<br> Impossible de sauter ou d'esquiver.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-5-1755762657383",
      "title": "Empoisonné",
      "content": "Des dégats sont appliqués à chaque début de tour du lanceur, réduits ni par l'armure physique ni par l'armure élémentaire.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-6-1755762796465",
      "title": "Entravé/Entoilé/Embourbé",
      "content": "<p>Ne peut plus faire d'actions.</p><p>Ne peut plus esquiver.</p> Le héros ou un allié peut sortir le héros de l'état via un test de compétence hardiesse.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-7-1755762977439",
      "title": "Affaibli",
      "content": "Les dégats physiques effectués sont réduits de moitiés. Les tests de hardiesse ont une difficulté de 2 plus élevés.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-para-8-1755891140510",
      "title": "Silence",
      "content": "Incapable de lancer des sorts.",
      "deletable": true,
      "sectionName": "Nouveau paragraphe"
    },
    {
      "type": "card",
      "id": "etats-new-9-1756400691334",
      "title": "Vulnérable",
      "content": "Plus aucune protection apporté par l'armure physique ou élémentaire.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-10-1756400890785",
      "title": "Confus",
      "content": "A chaque début de tour, lancez un d20. si le resultat est de 10 ou moins, passe sont tour à se déplacer et attaquer au corp à corp la cible la plus proche.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-11-1756401053782",
      "title": "Maudit",
      "content": "Impossible d'effectuer des coups critiques (physiques ou magiques), et la resistance altération est divisé par 2.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-12-1756401063266",
      "title": "Débilité",
      "content": "La cible est incpable d'effectuer la moindre action ou d'esquiver. A chaque début de tour, elle perd des points de vie, réduits ni par l'armure physique ni par l'armure élémentaire.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-13-1756408622987",
      "title": "Fatigué",
      "content": "Incapable d'utiliser des efforts. Coût en mana des sorts doublés. Dégats physiques infligés réduits de moitié.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-14-1756637917339",
      "title": "Aveuglé",
      "content": "Toutes les attaques et sorts ont une portée maximum de 3m. Incapable d'esquiver.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'combat': {
  "page": "combat",
  "title": "Combat",
  "sections": [
    {
      "type": "intro",
      "content": "Lorsqu'un combat commence, on compare l'Initiative de tous les participants (héros et monstres), et on détermine alors un ordre de tour. Celui qui a la plus grande initiative commence, puis c'est au tour du second avec la plus grande initiative , etc...\n\n<br><br>Chaque participant joue son tour (déplacement et actions), puis on passe au suivant. Lorsque tous les monstres ou tous les héros sont morts ou hors d'état de se battre, le combat s'arrète."
    },
    {
      "type": "card",
      "id": "combat-new-2-1756401371776",
      "title": "Déplacement",
      "content": "À chaque tour, un héros peut se déplacer de 9 mètres (plus s’il bénéficie de bonus), en plus de ses actions.\n<br><br>Certains terrains, comme la boue ou le sable, sont considérés comme des terrains difficiles : la vitesse y est alors réduite de moitié.\n<br><br>Un héros ou un monstre ne peut pas traverser un adversaire occupant une largeur de 3 mètres. Si plusieurs ennemis se tiennent côte à côte, ils forment un véritable mur infranchissable.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-3-1756401384086",
      "title": "Actions",
      "content": "Chaque tour, un héros dispose d'une <b>action principale</b>, pour effectuer une attaque physique ou un sort.\nElle est perdue si elle n'est pas utilisé pendant son tour. Elle permet également de faire toute action qui nécéssite un test de compétence (ouvrir une porte, casser un rocher...).\n\n<br><br>Il dispose également d'une <b>action secondaire</b>, qui permet de faire un certains nombre de choses :\n<br>- Sauter.\n<br>- Utiliser un objet.\n<br>- Changer d'arme.\n<br>Certains dons ou abilités permettent également d'effectuer d'autres choses en utilisant l'action secondaire.\n\n<br><br> Les héros peuvent effectuer leur déplacement, action principale et secondaire dans l'ordre qui leur plait.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-4-1756401409186",
      "title": "Attaques, sorts, armure",
      "content": "<b>Attaque physique</b>\n\n<ul>\n  <li>Il faut être à bonne portée (1,5 m pour une arme de mêlée, ou selon la portée indiquée sur l’arme).</li>\n  <li>Il faut effectuer un saut pour toucher un monstre volant.</li>\n</ul>\n\n<p>\nEnsuite l’attaquant lance un <b>d20</b> :\n</p>\n\n<ul>\n  <li>Si le résultat est ≤ <b>(1 + Esquive)</b> du défenseur, l’attaque rate.</li>\n  <li>Si le résultat est ≥ <b>(20 - Chance de Critique)</b> de l’attaquant, l’attaque est un <b>coup critique</b> et les dégâts physiques sont doublés.</li>\n</ul>\n\n<p>\nSi des <b>dégâts élémentaires</b> sont rattachés à l’arme (via sort, objet ou autre), ils ne sont critiques que si l’élément de l’attaque est opposé à l’élément d’affiliation de la cible.\n</p>\n\n<p>\nSi l’attaque réussit :\n</p>\n<ul>\n  <li>On soustrait l’armure physique aux dégâts physiques, puis on retire ce total aux points de vie du défenseur.</li>\n  <li>On fait de même avec les dégâts élémentaires en utilisant l’armure élémentaire correspondante.</li>\n</ul>\n\n<hr>\n\n<br><b>Lancer un sort</b>\n\n<ul>\n  <li>Le lanceur doit être à portée de la cible.</li>\n  <li>Le lanceur dépense le mana en fonction du coût du sort. S'il passe en dessous de 0, le sort échoue et le lanceur devient <span class=\"etat-link\" data-etat=\"Endormi/assomé/Effrayé\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Paralysé</span> pendant 2 tours.</li>\n</ul>\n\n<p>\nEnsuite le lanceur lance un <b>d20</b> :\n</p>\n\n<ul>\n  <li>Si le résultat est ≤ 1, le sort échoue.</li>\n  <li>Si le résultat est ≥ <b>(20 - Chance de Critique des sorts)</b> du lanceur, l’effet du sort sera <b>critique</b> (s’il réussit).</li>\n</ul>\n\n<b>Cas « Sans effet si » :</b>\n<br>Chaque sort indique sans sa decription dans quels cas le sort peut échouer.\n<ul>\n  <li>S’il est annulé en cas d’esquive, on vérifie si le résultat du dé est ≤ <b>(1 + Esquive)</b> du défenseur.</li>\n  <li>S’il n’affecte pas certaines créatures en fonction de leur élément d’assignation, le MJ indiquera si le sort est sans effet.</li>\n  <li>S’il s’agit d’un sort d’altération magique, on compare l’<b>Intelligence</b> du lanceur avec la <b>Résistance à l’altération</b> du défenseur : si elle n’est pas strictement supérieure, le sort est sans effet.</li>\n</ul>\n\n<p>\nSi aucun des cas « Sans effet si » ne s’applique, on résout le sort :\n</p>\n\n<ul>\n  <li>Si l’élément du sort est opposé à l’affiliation de la cible, l’effet est <b>forcément critique</b>.</li>\n  <li>Son effet est appliqué (en cas d'effet critique, la description du sort indique les effets).</li>\n  <li>Si le sort inflige des dégâts élémentaires, on soustrait l’armure élémentaire correspondante.</li>\n  <li>Si le sort inflige une altération, on place un dé indiquant le nombre de tours restants.</li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-5-1756401438556",
      "title": "Coup critique et esquive",
      "content": "<hr><br><br><strong>Chance de coup critique (physique) </strong> : Lors d'une attaque physique, le lanceur de l'attaque lance un d20. S'il fait 20, alors les dégats physiques (et seulement physiques) sont doublés.<br> Augmenter les chances de coup critique réduit la valeur du dé nécéssaire pour faire un critique. Par exemple, avec 3 de chance de coup critique, si le dé fait de 17 à 20, l'attaque est critique.\n\n<br><br><hr><br><strong>Chance de coup critique (sorts et consommables)</strong> : Lorsque un héros ou un monstre lance un sort ou utilise un consommable, il lance un d20. S'il fait 20, alors le sort est critique, chaque sort/consommable ayant un effet critique différent (indiqué dans sa description).<br> Augmenter les chances de coup critique des sorts et consommables réduit la valeur du dé nécéssaire pour faire un critique. Par exemple, avec 3 de chance de coup critique, si le dé fait de 17 à 20, le resultat est critique. \n\n<br><br><hr><br><strong>Esquive </strong> : Lors d'une attaque physique, ou d'un sort sans effet si esquive (indiqué dans la fiche du sort), lorsque le lanceur lance son d20, si le resultat est 1, l'attaque est sans effet. Avoir de l'esquive pour la cible de l'attaque augmente la valeur du dé jusqu'a laquelle l'attaque échoue. Par exemple, avec 3 d'esquive, si le dé fait 4 ou moins, l'attaque échoue. La valeur d'esquive ne peut jamais dépasser 9, quel que soit l'equipement ou bonus d'un joueur ou monstre.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-6-1756401461053",
      "title": "Mort",
      "content": "<p>\nLorsque les <b>points de vie</b> d’un héros passent sous la barre des 0, il devient <b>inconscient</b> jusqu’à la fin du combat. \nAprès le combat, si un allié le soigne (via objet ou sort), il redevient capable d’agir. \nCependant, il gagne <b>1 point de trauma</b>, représentant un handicap définitif en fonction de ce qui l’a abattu. \nAu bout du <b>troisième trauma</b>, le héros <b>meurt définitivement</b>.\n</p>\n\n<p>\nLe joueur devra alors créer un nouveau personnage.  \nIl se murmure que certaines <b>magies très puissantes</b> sont capables de ressusciter un héros mort, à condition qu’elles soient pratiquées rapidement après le décès.\n</p>\n\n<p>\n<b>Exemples de traumas</b>\n</p>\n<ul>\n  <li><b>Cicatrice profonde</b> : –1 en compétence Éloquence.</li>\n  <li><b>Amnésie partielle</b> : Oubli d’un sort, d’une langue ou d’une compétence.</li>\n  <li><b>Claudication</b> : Vitesse de déplacement réduite de 3 m.</li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-7-1756407955417",
      "title": "Incantation sur plusieurs tours",
      "content": "Certains sorts puissants nécéssitent plusieurs tours d'incantation.\n\n<br>Aprés avoir commencé une incantation, aucun déplacement/action n'est possible. Les effets du sort sont effectués au dernier tour de l'incantation, tour où la créature pourra de nouveau effectuer des actions/déplacement.\n<br> Les dégâts subis n’interrompent pas l’incantation, sauf en cas de mort ou d’effet particulier.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'gestion-des-ressources': {
  "page": "gestion-des-ressources",
  "title": "Gestion des ressources",
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-2-1756401478745",
      "title": "Inventaire",
      "content": "<p>Chaque héros dispose de <b>quatre inventaires</b> :</p>\n\n<ul>\n  <li>\n    <b>Équipement</b> : Toujours porté et actif, il est constitué d’une arme, d’une armure, \n    d’un éventuel bouclier et de <b>3 accessoires</b>.\n  </li>\n  <li>\n    <b>Sac de consommables</b> : Peut contenir jusqu’à <b>10 consommables</b>. Même si un héro possède plusieur fois le même consommable, ils prendront chacun une place.\n  </li>\n  <li>\n    <b>Sac général</b> : Dispose d’une capacité maximale de <b>10 points de poids</b>. \n    Chaque objet entreposé y possède une valeur de poids indiquée dans sa description.\n  </li>\n <li>\n    <b>Objets de quête</b> : Aucune limite pour ces objets, utiles pour l'aventure (clés, cartes...).\n  </li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-3-1756401493443",
      "title": "Mana",
      "content": "Il s'agit de la ressource utilisée pour lancer des sorts. Hors combat, il revient automatiquement au maximum aprés plus d'une heure sans être en combat. En combat, il est consommé aprés le lancement de chaque sort (le coût en mana étant indiqué dans la description de chaque sort). Si un sort devait faire passer le mana d'un héros en dessous de 0, alors le sort n'est pas effectif et le héros devient <span class=\"etat-link\" data-etat=\"Endormi/assomé/Effrayé\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">paralysé</span> pendant 2 tours.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-4-1756401498518",
      "title": "Vie",
      "content": "Les points de vie représentent la vitalité d’un héros ou d’un monstre, la mesure de son endurance face aux blessures. Tant qu’il lui reste des PV, le personnage peut continuer à se battre, à courir et à agir. Quand ses PV tombent à zéro, il s’effondre, mourant. Voir la page <a href=\"#/combat\" style=\"color: var(--accent); text-decoration: underline;\">Combat</a>.\nUn personnage qui effectue un repos régénère un nombre de points de vie égal à sa valeur d’Endurance.<br>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-5-1756401504961",
      "title": "Fortune",
      "content": "Lorsqu’un événement fait appel à la Fortune (par exemple ouvrir un coffre et espérer y trouver un objet rare), le joueur lance un d20 et ajoute sa valeur de Fortune. Plus le total est élevé, meilleur sera le butin obtenu.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-7-1756408519770",
      "title": "Sommeil et repas",
      "content": "Chaque jour, un héros doit manger une ration et dormir au moins 8 heures sous peine d'être dans l'état <span class=\"etat-link\" data-etat=\"Fatigué\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Fatigué</span>.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-7-1756634178476",
      "title": "Experience et niveau",
      "content": "<p>Lorsqu’un groupe trouve et utilise un <b>cristal d’expérience</b>, tous les membres du groupe <b>gagnent</b> des points d’expérience.</p>\n<p>Les <b>cristaux d’expérience</b> provenant d’un même type de monstre sont de moins en moins efficaces, car la magie qu’ils renferment a déjà été assimilée.</p>\n\n\n<p>Lorsqu’un héros atteint <b>10 points d’expérience</b>, il gagne un niveau et son expérience revient à <b>0</b>. Il obtient alors :</p>\n<ul>\n  <li><b>1 point de don</b> (qu’il peut dépenser ou cumuler).</li>\n  <li>Des <b>statistiques fixes</b> (selon la sous-classe).</li>\n  <li><b>2 points de statistiques</b> à répartir.</li>\n  <li>L’<b>accès à de nouveaux sorts</b> (pour les classes qui le peuvent).</li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-8-1756658008017",
      "title": "Equipements",
      "content": "<li>Que l'on porte une arme à une main ou à deux mains, il est uniquement possible d'être équipé d'une seule arme.\n</li><li>Lorsque on porte une arme à deux mains, il est impossible de porter un bouclier.\n</li><li>Il est possible via une action secondaire de changer l'arme active en plein combat, mais pas l'armure ou les accessoires, qui ne peuvent être changés que hors combat.</li>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'histoire': {
  "page": "histoire",
  "title": "Histoire",
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "ere-legendaire",
      "title": "",
      "content": "<b>Foresia, royaume ancien aux mille visages</b><br>\nDans les terres de <b>Foresia</b>, un royaume ancien aux mille visages, la <b>magie</b> imprègne chaque pierre et chaque souffle de vent. \nForêts luminescentes, volcans grondants, temples enfouis et ruines cyclopéennes rappellent que les dieux et les anciens peuples ont marqué cette terre de leur puissance.\n\n<br><br><b>La région de Mabresia</b><br>\nAu cœur de ce royaume s’étend la région de <b>Mabresia</b>, autrefois fertile et paisible, où se dressaient des cités marchandes prospères et des villages agricoles nourris par des rivières cristallines.\n\n<br><br><b>La malédiction des cristaux</b><br>\nMais depuis quelques décennies, un mal mystérieux s’est abattu sur la contrée. \nDes <b>cristaux magiques</b> surgis des profondeurs de la terre altèrent la nature et les êtres vivants : animaux, monstres, et même parfois les races intelligentes. \nCes cristaux provoquent des <b>mutations</b> et une <b>soif de violence</b> incontrôlable.\n\n<br><br><b>Peuples et tensions</b><br>\nLes habitants de Foresia — <b>humains</b>, <b>elfes</b>, <b>nains</b>, mais aussi des créatures plus sombres comme <b>démons</b> et <b>morts-vivants</b> — vivent désormais dans une tension permanente, oscillant entre alliances fragiles et guerres ouvertes. \nChacun cherche à <b>exploiter</b> ou <b>détruire</b> ces cristaux, selon ses croyances et ambitions.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "chronologie",
      "title": "📅 Chronologie",
      "content": "<b>Il y a 300 ans</b> – L’Empire des Anciens, peuple oublié, érige d’immenses temples et scelle dans leurs fondations des secrets de magie que nul ne comprendra jamais entièrement.<br><br>\n\n<b>Il y a 200 ans</b> – Chute de l’Empire : guerres entre dieux mineurs et rois mortels. Les temples sont abandonnés, et les ruines se couvrent de végétation.<br><br>\n\n<b>Il y a 80 ans</b> – Premiers récits d’étranges cristaux luminescents découverts dans les montagnes de Mabresia. Au début considérés comme bénédictions, certains se révèlent instables.<br><br>\n\n<b>Il y a 50 ans</b> – Des bêtes sauvages commencent à muter et deviennent plus féroces. Les premiers villages sont détruits par des créatures altérées.<br><br>\n\n<b>Il y a 30 ans</b> – Les cristaux se répandent : on les retrouve dans les forêts, les marécages et même les ruines anciennes. De plus en plus de créatures sont transformées.<br><br>\n\n<b>Il y a 20 ans</b> – Les premières guerres éclatent entre royaumes frontaliers : certains veulent s’emparer des cristaux comme armes, d’autres cherchent à les détruire.<br><br>\n\n<b>Aujourd’hui</b> – La région de Mabresia est devenue une terre sauvage, où nul n’est à l’abri : les routes sont envahies de créatures mutées, les villages se fortifient, et des aventuriers de tous horizons s’y aventurent à la recherche de gloire, de savoir… ou de pouvoir.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'dieux': {
  "page": "dieux",
  "title": "Dieux",
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "dieux-new-2-1756899335313",
      "title": "Dieu des Humains – Aedor, le Forgeron-Soleil",
      "content": "Symbole : un marteau auréolé d’un disque solaire.<br>\nDomaine : courage, guerre juste, travail artisanal.<br>\nCroyances : les humains voient en lui celui qui éclaire leur chemin et leur donne la force de bâtir des cités.<br>\nParticularité : ses prêtres prônent la discipline et la reconstruction, mais certains royaumes l’utilisent aussi pour justifier leurs conquêtes.<br><br>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "dieux-para-3-1756899336921",
      "title": "Dieu des Nains – Durnak, le Cœur-de-Pierre",
      "content": "Symbole : une enclume fissurée d’où s’écoule une lueur rouge.<br>\nDomaine : terre, montagne, persévérance, serments.<br>\nCroyances : gardien des mines et des profondeurs, il protège les clans nains et punit sévèrement ceux qui trahissent leur parole.<br>\nParticularité : les nains affirment que ses battements résonnent dans les montagnes, guidant les mineurs vers les métaux rares.<br><br>",
      "deletable": true,
      "sectionName": "Nouveau paragraphe"
    },
    {
      "type": "card",
      "id": "dieux-new-4-1756899338873",
      "title": "Déesse des Elfes – Liryel, la Dame des Brumes",
      "content": "Symbole : une feuille argentée flottant sur l’eau.<br>\nDomaine : forêts, magie ancienne, mémoire.<br>\nCroyances : les elfes la vénèrent comme gardienne du cycle de la vie et de la magie pure.<br>\nParticularité : ses temples sont souvent des clairières protégées par des enchantements, où les brumes recouvrent les intrus.<br><br>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "dieux-new-5-1756899431837",
      "title": "Dieu des Fées et des Lutins – Myrin, l’Éclat-Changeant",
      "content": "Symbole : une luciole ou une étoile facétieuse à cinq branches.<br>\nDomaine : illusions, rêves, joie, malice.<br>\nCroyances : les fées et lutins croient qu’il danse entre les mondes, semant à la fois la protection et la farce.<br>\nParticularité : ses fidèles accordent beaucoup d’importance aux fêtes, à la musique et aux pactes imprévisibles.<br><br>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'geographie': {
  "page": "geographie",
  "title": "Geographie",
  "sections": [
    {
      "type": "intro",
      "content": "Voici la carte de la région de Mabresia, dans le Royaume de Foresia"
    }
  ]
},
      'campagne': {
  "id": "campagne",
  "title": "Campagne",
  "icon": "📖",
  "sections": [
    {
      "type": "intro",
      "content": "<strong>🎭 Espace Campagne</strong><br>Créez et gérez vos campagnes avec leurs sous-pages personnalisées. Cette section est uniquement visible en mode Maître de Jeu."
    },
    {
      "type": "campaign-manager",
      "content": {
        "title": "Gestionnaire de Campagnes",
        "campaigns": {}
      }
    }
  ],
  "subPages": {
    "Classique": {
      "name": "Classique",
      "description": "",
      "subPages": {
        "Long terme": {
          "title": "Long terme",
          "content": "🕯️ Le Dieu Maléfique\n\nNerhaz, le Sépulcral\n\nSymbole : un cristal noir fendu, entouré de chaînes.\n\nDomaine : mort, corruption, secrets interdits.\n\nHistoire : banni par l’Empire des Anciens, il fut scellé dans leurs temples. Mais les cristaux magiques, instables, ont servi de réceptacles à ses murmures.\n\nParticularité : Nerhaz attire les ambitieux et les désespérés, promettant pouvoir en échange de sacrifices. Son retour progressif est lié à l’altération des créatures par les cristaux."
        },
        "Auberge": {
          "title": "Auberge",
          "content": "<p>Contenu de la sous-page...</p>"
        },
        "Forêt": {
          "title": "Forêt",
          "content": "<p>Contenu de la sous-page...</p>"
        }
      }
    }
  },
  "meta": {
    "requiresMJ": true,
    "allowSubPages": true,
    "lastModified": "2025-01-01T00:00:00.000Z"
  }
}
    };
    
    // Static pages configuration
    window.STATIC_PAGES_CONFIG = {
  "pages": [
    {
      "id": "creation",
      "title": "Création d'un personnage",
      "file": "creation.json",
      "active": true,
      "order": 1
    },
    {
      "id": "elements",
      "title": "Elements",
      "file": "elements.json",
      "active": true,
      "order": 2
    },
    {
      "id": "stats",
      "title": "Statistiques",
      "file": "stats.json",
      "active": true,
      "order": 3
    },
    {
      "id": "competences-tests",
      "title": "Compétences & Tests",
      "file": "competences-tests.json",
      "active": true,
      "order": 4
    },
    {
      "id": "etats",
      "title": "Etats",
      "file": "etats.json",
      "active": true,
      "order": 5
    },
    {
      "id": "histoire",
      "title": "Histoire",
      "file": "histoire.json",
      "active": true,
      "order": 6
    },
    {
      "id": "combat",
      "title": "Combat",
      "file": "combat.json",
      "active": true,
      "order": 7
    },
    {
      "id": "gestion-des-ressources",
      "title": "Gestion des ressources",
      "file": "gestion-des-ressources.json",
      "active": true,
      "order": 8
    },
    {
      "id": "dieux",
      "title": "Dieux",
      "file": "dieux.json",
      "active": true,
      "order": 9
    },
    {
      "id": "geographie",
      "title": "Geographie",
      "file": "geographie.json",
      "active": true,
      "order": 10
    },
    {
      "id": "audio",
      "title": "Musiques d'ambiance",
      "file": "audio.json",
      "active": true,
      "order": 11
    },
    {
      "id": "traumas",
      "title": "Traumas",
      "file": "traumas.json",
      "active": true,
      "order": 12
    },
    {
      "id": "campagne",
      "title": "Campagne",
      "file": "campagne.json",
      "active": true,
      "order": 13,
      "requiresMJ": true
    }
  ],
  "template": {
    "page": "new-page",
    "title": "Nouvelle page",
    "static": true,
    "sections": [
      {
        "type": "intro",
        "content": "Contenu de la nouvelle page."
      }
    ]
  }
};
    
    // Mark as standalone version for renderer
    window.STANDALONE_VERSION = true;
    
    // Initialize app when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      // Ensure dev mode is off
      document.body.className = 'dev-off';
      
      // Initialize in standalone mode with embedded data
      
      // Wait a bit to ensure all modules are loaded
      setTimeout(function() {
        // Initialize JdrApp if it exists
        if (window.JdrApp && window.JdrApp.init) {
          window.JdrApp.init();
        } else {
          console.error('JdrApp not found!', window.JdrApp);
        }
      }, 100);
    });
  
// ============================================================================
// JDR-BAB APPLICATION - CORE MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // MAIN APPLICATION NAMESPACE
  // ========================================
  window.JdrApp = {
    // Core data
    data: {
      SORTS: null,
      CLASSES: null,
      DONS: null,
      OBJETS: null,
      MONSTRES: null,
      STATIC_PAGES: {},
      editedData: {},
      customPageDescriptions: {
        'collections-objets': 'Recherchez et explorez des collections d\'objets organisées par thème'
      }
    },
    
    // Application state
    state: {
      isMJ: false // Boolean pour contrôler l'accès MJ
    },
    
    // Core modules
    modules: {
      router: {},
      renderer: {},
      editor: {},
      storage: {},
      images: {}
    },
    
    // Utilities
    utils: {
      dom: {},
      events: {},
      data: {}
    },

    // Initialization
    async init() {
      try {
        await this.loadData();
        await this.loadContent();
        this.initializeModules();
        
        // Execute data validation after all modules are loaded
        setTimeout(() => {
          this.validateDataIntegrity();
        }, 500);
        
        // Auto-enable MJ mode with additional delay to ensure router is ready
        setTimeout(() => {
          this.autoEnableMJModeInDevelopment();
        }, 800);
      } catch (error) {
        // Silent error handling for initialization
      }
    },

    async loadData() {
      try {
        // Check if we're in standalone mode (data already injected)
        if (window.SORTS && window.CLASSES && window.DONS && window.OBJETS && window.STATIC_PAGES) {
          const sorts = window.SORTS;
          const classes = window.CLASSES;
          const dons = window.DONS;
          const objets = window.OBJETS;
          let monstres = window.MONSTRES || [];
          let tablesTresors = window.TABLES_TRESORS || { tables: [] };
          let collections = window.COLLECTIONS || { collections: [] };
          
          // Safety check - if MONSTRES is not an array, it might be page config
          if (!Array.isArray(monstres)) {
            this.clearCorruptedMonsterData();
            monstres = [];
          }
          
          const staticPagesData = window.STATIC_PAGES;
          const staticPagesConfig = window.STATIC_PAGES_CONFIG || {};
          
          // Ensure custom page descriptions are available in standalone mode
          // In standalone mode, CUSTOM_PAGE_DESCRIPTIONS might be injected, sync with JdrApp.data
          if (window.CUSTOM_PAGE_DESCRIPTIONS) {
            this.data.customPageDescriptions = { ...this.data.customPageDescriptions, ...window.CUSTOM_PAGE_DESCRIPTIONS };
          } else {
            window.CUSTOM_PAGE_DESCRIPTIONS = { ...this.data.customPageDescriptions };
          }
          
          this.data.SORTS = sorts;
          this.data.CLASSES = classes;
          this.data.DONS = dons;
          this.data.OBJETS = objets;
          this.data.MONSTRES = monstres;
          this.data.TABLES_TRESORS = tablesTresors;
          this.data.COLLECTIONS = collections;
          this.data.STATIC_PAGES = staticPagesData;
          this.data.STATIC_PAGES_CONFIG = staticPagesConfig;
          
          window.SORTS = sorts;
          window.CLASSES = classes;
          window.DONS = dons;
          window.OBJETS = objets;
          window.MONSTRES = monstres;
          window.TABLES_TRESORS = tablesTresors;
          window.COLLECTIONS = collections;
          window.STATIC_PAGES = staticPagesData;
          window.STATIC_PAGES_CONFIG = staticPagesConfig;
          
          // Load stored edits AFTER setting up the data structure
          this.loadStoredEditsEarly();
          
          // Initialize default filters for objects
          this.initializeDefaultFilters();
          return;
        }
        
        // Development mode - fetch files
        const [sorts, classes, dons, objets, monstres, tablesTresors, collections, staticPagesConfig, tocStructure, audioConfig] = await Promise.all([
          fetch('data/sorts.json').then(r => r.json()),
          fetch('data/classes.json').then(r => r.json()),
          fetch('data/dons.json').then(r => r.json()),
          fetch('data/objets.json').then(r => r.json()),
          fetch('data/monstres.json').then(r => r.json()),
          fetch('data/tables-tresors.json').then(r => r.json()),
          fetch('data/collections.json').then(r => r.json()),
          fetch('data/static-pages-config.json').then(r => r.json()),
          fetch('data/toc-structure.json').then(r => r.json()),
          fetch('data/audio-config.json').then(r => r.json()).catch(() => null)
        ]);

        // Load page descriptions (optional, with fallbacks)
        try {
          window.MONSTRES_PAGE_DESC = await fetch('data/monstres-page-desc.json').then(r => r.json());
        } catch (error) {
          // Fallback if file doesn't exist
          window.MONSTRES_PAGE_DESC = {
            description: "Créatures, ennemis et adversaires que peuvent affronter les héros dans leurs aventures."
          };
        }

        try {
          window.TABLES_TRESORS_PAGE_DESC = await fetch('data/tables-tresors-page-desc.json').then(r => r.json());
        } catch (error) {
          // Fallback if file doesn't exist
          window.TABLES_TRESORS_PAGE_DESC = {
            description: "Tables de butin permettant de générer aléatoirement des récompenses selon les fourchettes définies. Lancez un dé 20 et consultez la table correspondante pour déterminer l'objet obtenu."
          };
        }

        // Load custom page descriptions (collections, etc.)
        try {
          const customDescriptions = await fetch('data/custom-page-descriptions.json').then(r => r.json());
          this.data.customPageDescriptions = { ...this.data.customPageDescriptions, ...customDescriptions };
          // Make it available globally for ContentFactory (keep in sync)
          window.CUSTOM_PAGE_DESCRIPTIONS = { ...this.data.customPageDescriptions };
        } catch (error) {
          // Keep default values if file doesn't exist
          window.CUSTOM_PAGE_DESCRIPTIONS = { ...this.data.customPageDescriptions };
        }

        const staticPagesData = {};
        const activePages = staticPagesConfig.pages.filter(page => page.active);
        
        for (const pageConfig of activePages) {
          try {
            const pageData = await fetch(`data/${pageConfig.file}`).then(r => r.json());
            staticPagesData[pageConfig.id] = pageData;
          } catch (error) {
            // Silent handling for missing static pages
          }
        }

        this.data.SORTS = sorts;
        this.data.CLASSES = classes;
        this.data.DONS = dons;
        this.data.OBJETS = objets;
        this.data.MONSTRES = monstres;
        this.data.TABLES_TRESORS = tablesTresors;
        this.data.COLLECTIONS = collections;
        this.data.STATIC_PAGES = staticPagesData;
        this.data.STATIC_PAGES_CONFIG = staticPagesConfig;
        this.data.AUDIO_CONFIG = audioConfig;
        this.data.TOC_STRUCTURE = tocStructure;

        window.SORTS = sorts;
        window.CLASSES = classes;
        window.DONS = dons;
        window.OBJETS = objets;
        window.MONSTRES = monstres;
        window.TABLES_TRESORS = tablesTresors;
        window.COLLECTIONS = collections;
        window.STATIC_PAGES = this.data.STATIC_PAGES;
        window.STATIC_PAGES_CONFIG = this.data.STATIC_PAGES_CONFIG;
        window.TOC_STRUCTURE = this.data.TOC_STRUCTURE;
        window.AUDIO_CONFIG = audioConfig;
        
        // Load stored edits in development mode (after data is loaded)
        this.loadStoredEditsEarly();
        
        // Initialize default filters for objects
        this.initializeDefaultFilters();
      } catch (error) {
        throw error;
      }
    },

    async loadContent() {
      try {
        // Check if we're in standalone mode (already has HTML structure)
        const viewsDiv = document.getElementById('views');
        const loadingDiv = document.getElementById('app-loading');
        
        if (viewsDiv) {
          // Standalone mode - HTML structure already exists
          if (loadingDiv) {
            loadingDiv.innerHTML = '<!-- Content will be generated by renderer -->';
          }
        } else if (loadingDiv) {
          // Development mode - need to inject HTML structure
          const contentHTML = await this.getContentHTML();
          loadingDiv.outerHTML = contentHTML;
        }
      } catch (error) {
        throw error;
      }
    },

    async getContentHTML() {
      // This would ideally load from a separate HTML file
      // For now, we'll return the content structure
      return `
        <div class="shell">
          <button aria-controls="sidebar" aria-expanded="false" aria-label="Ouvrir le sommaire" class="menu-toggle" id="menuToggle" style="display:none">☰ Sommaire</button>
          <div class="backdrop" hidden="" id="backdrop"></div>
          <main class="page">
            <aside class="sidebar" id="sidebar">
              <div class="panel">
                <div class="searchbar">
                  <input autocomplete="off" id="search" placeholder="Rechercher une règle, une classe…">
                  <button class="btn" id="clear" title="Effacer">✖</button>
                </div>
                <div class="tools">
                  <button class="btn small" id="devToggle" title="Activer/désactiver le mode développeur">🛠 Dev Mode: OFF</button>
                </div>
                <div class="dev-toolbox" id="devToolbox" style="display: none;">
                  <!-- Dev toolbox content will be injected here -->
                </div>
                <div class="toc" id="toc">
                  <!-- Table of contents will be injected here -->
                </div>
              </div>
            </aside>
            <div id="views">
              <!-- Dynamic content will be injected here -->
            </div>
          </main>
          <footer></footer>
        </div>
      `;
    },

    // Load stored edits early in the loading process (before rendering)
    loadStoredEditsEarly() {
      // Ne plus charger automatiquement le localStorage
      // Laisser les JSON files être la source de vérité
    },

    initializeModules() {
      if (this.utils.events && this.utils.events.init) this.utils.events.init();
      if (this.utils.dom && this.utils.dom.init) this.utils.dom.init();
      if (this.modules.images && this.modules.images.init) this.modules.images.init();
      if (this.modules.audio && this.modules.audio.init) this.modules.audio.init();
      if (this.modules.renderer && this.modules.renderer.init) this.modules.renderer.init();
      if (this.modules.router && this.modules.router.init) this.modules.router.init();
      if (this.modules.editor && this.modules.editor.init) this.modules.editor.init();
      if (this.modules.storage && this.modules.storage.init) this.modules.storage.init();
      if (this.modules.ui && this.modules.ui.init) this.modules.ui.init();
    },

    // Force reload JSON data (clear localStorage cache)
    forceReloadData() {
      // Effacer seulement les éditions temporaires
      localStorage.removeItem('jdr-bab-edits');
      localStorage.removeItem('jdr-bab-last-modified');
      window.location.reload();
    },

    // Clear corrupted localStorage data specifically for monsters
    clearCorruptedMonsterData() {
      const edits = JSON.parse(localStorage.getItem('jdr-bab-edits') || '{}');
      
      // Remove any MONSTRES data that might be corrupted
      if (edits.MONSTRES) {
        delete edits.MONSTRES;
        localStorage.setItem('jdr-bab-edits', JSON.stringify(edits));
      }
      
      // Also clear any other monster-related storage
      if (edits.monster) {
        delete edits.monster;
        localStorage.setItem('jdr-bab-edits', JSON.stringify(edits));
      }
    },

    // Public method to manually clear storage via console
    clearMonsterStorage() {
      this.clearCorruptedMonsterData();
      this.forceReloadData();
    },

    // Initialize default filters for objects on page load
    initializeDefaultFilters() {
      try {
        // Only initialize if OBJETS exists and ContentTypes is available
        if (window.OBJETS && window.ContentTypes?.objet?.filterConfig) {
          const defaultTags = window.ContentTypes.objet.filterConfig.defaultVisibleTags || [];
          
          // Initialize filterSettings only if it doesn't exist or is empty
          if (!window.OBJETS.filterSettings || !window.OBJETS.filterSettings.visibleTags) {
            window.OBJETS.filterSettings = {
              visibleTags: [...defaultTags], // Active filters (defaults only)
              displayedFilterButtons: [...defaultTags] // Displayed filter buttons (defaults initially)
            };
          }
          
          // Ensure displayedFilterButtons exists even if visibleTags already existed
          if (!window.OBJETS.filterSettings.displayedFilterButtons) {
            window.OBJETS.filterSettings.displayedFilterButtons = [...defaultTags];
          }
          
        }
      } catch (error) {
        // Silent error handling for filter initialization
      }
    },

    // Validate data integrity on application startup
    validateDataIntegrity() {
      try {
        // Validate monster data if available
        if (window.MONSTRES && Array.isArray(window.MONSTRES) && JdrApp.modules.images) {
          // Force sync monster images and paths
          JdrApp.modules.images.forceSyncMonsterImages();
        }
        
        // Validate UnifiedEditor if available
        if (JdrApp.modules.editor && JdrApp.modules.editor.validateAndRepairMonsterData) {
          JdrApp.modules.editor.validateAndRepairMonsterData();
        }
        
      } catch (error) {
        // Silent error handling for data validation
      }
    },

    autoEnableMJModeInDevelopment() {
      try {
        // Better detection: Check if we're in standalone mode
        // Standalone mode sets window.STANDALONE_VERSION = true in the build
        const isStandalone = window.STANDALONE_VERSION === true;
        
        
        if (!isStandalone) {
          
          // Enable MJ mode (not dev mode!) automatically in development
          if (!this.state.isMJ) {
            this.state.isMJ = true;
            
            // Update MJ button visual if available and regenerate TOC
            if (JdrApp.modules.router && JdrApp.modules.router.updateMJButtonVisual) {
              JdrApp.modules.router.updateMJButtonVisual();
              JdrApp.modules.router.generateTOC();
              
              // Refresh current page if it's tables-tresors to show edit buttons
              const currentHash = window.location.hash;
              if (currentHash === '#/tables-tresors') {
                setTimeout(() => {
                  if (JdrApp.modules.router && JdrApp.modules.router.renderTablesTresorsPage) {
                    JdrApp.modules.router.renderTablesTresorsPage();
                  }
                }, 200);
              }
              
            } else {
              // Router not ready yet, retry
              setTimeout(() => this.autoEnableMJModeInDevelopment(), 1000);
              return;
            }
            
          }
        }
      } catch (error) {
        // Retry once more after error
        setTimeout(() => this.autoEnableMJModeInDevelopment(), 2000);
      }
    }
  };

  // Auto-initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => window.JdrApp.init());
  } else {
    window.JdrApp.init();
  }

})();
// ============================================================================
// JDR-BAB APPLICATION - CONSTANTS
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // UI CONSTANTS
  // ========================================
  window.UI_CONSTANTS = {
    // Layout dimensions
    SIDEBAR_WIDTH: 350,
    SIDEBAR_WIDTH_TABLET: 320,
    
    // Image processing defaults
    IMAGE_MAX_WIDTH: 800,
    IMAGE_QUALITY: 0.85,
    
    // Timing constants (milliseconds)
    TIMEOUTS: {
      VALIDATION_DELAY: 500,
      AUTO_MJ_DELAY: 800,
      RENDER_DELAY: 100,
      ROUTER_RETRY_DELAY: 1000,
      ERROR_RETRY_DELAY: 2000,
      DYNAMIC_CENTERING_DELAY: 50
    },
    
    // Breakpoints
    BREAKPOINTS: {
      MOBILE: 480,
      TABLET_PORTRAIT: 768,
      TABLET_LANDSCAPE: 1024,
      DESKTOP: 980
    }
  };

  // ========================================
  // ELEMENT COLORS
  // ========================================
  window.ELEMENT_COLORS = {
    FEU: { color: '#ff6b35', weight: 'bold' },
    EAU: { color: '#4682b4', weight: 'bold' },
    TERRE: { color: '#8b4513', weight: 'bold' },
    AIR: { color: '#87ceeb', weight: 'bold' },
    DIVIN: { color: '#ffd700', weight: 'bold' },
    MALEFIQUE: { color: '#8b008b', weight: 'bold' },
    NEUTRE: { color: '#696969', weight: 'normal' }
  };

  // ========================================
  // STORAGE KEYS
  // ========================================
  window.STORAGE_KEYS = {
    EDITS: 'jdr-bab-edits',
    LAST_MODIFIED: 'jdr-bab-last-modified',
    MONSTER_BACKUPS: 'jdr-bab-monster-backups',
    FILTER_SETTINGS: 'jdr-bab-filter-settings'
  };

  // ========================================
  // EVENT CONSTANTS
  // ========================================
  window.Events = {
    STORAGE_SAVE: 'storage:save',
    PAGE_RENDER: 'page:render',
    CONTENT_UPDATE: 'content:update'
  };

  // ========================================
  // DEFAULT VALUES
  // ========================================
  window.DEFAULT_VALUES = {
    // Monster backup retention
    MAX_MONSTER_BACKUPS: 10,
    
    // Filter defaults
    DEFAULT_VISIBLE_TAGS: ['Arme', 'Armure', 'Bouclier', 'Consommable'],
    
    // Image defaults
    DEFAULT_MONSTER_IMAGE: 'data/images/Monstres/foret/default-monster.png',
    DEFAULT_SPELL_IMAGE: 'data/images/Sorts/default-spell.png',
    DEFAULT_CLASS_IMAGE: 'data/images/Classes/default-class.png'
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - CONTENT TYPES CONFIGURATION
// ============================================================================

(() => {
  "use strict";

  window.ContentTypes = {
    spell: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        element: { type: 'select', label: 'Élément', required: true, options: ['Feu', 'Eau', 'Terre', 'Air', 'Lumière', 'Nuit', 'Divin', 'Maléfique'] },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'Prérequis', required: true },
        portee: { type: 'richtext', label: 'Portée', required: true },
        tempsIncantation: { type: 'richtext', label: "Temps d'incantation", required: true },
        coutMana: { type: 'richtext', label: 'Coût mana', required: true },
        resistance: { type: 'richtext', label: 'Résistance', required: true },
        effetNormal: { type: 'richtext', label: 'Effet normal', required: true },
        effetCritique: { type: 'richtext', label: 'Effet critique', required: false }
      },
      editMapping: {
        'spell-name': 'nom',
        'spell-element': 'element',
        'spell-description': 'description',
        'spell-prerequis': 'prerequis',
        'spell-portee': 'portee',
        'spell-mana': 'coutMana',
        'spell-temps-incantation': 'tempsIncantation',
        'spell-resistance': 'resistance',
        'spell-effect-normal': 'effetNormal',
        'spell-effect-critical': 'effetCritique'
      },
      identifiers: {
        name: 'nom',
        category: 'sorts'
      },
      template: 'spell-card',
      container: 'sorts',
      dataKey: 'SORTS',
      icons: { 
        category: '🔮', 
        item: '✨',
        add: '➕',
        delete: '🗑️'
      },
      defaultValues: {
        nom: "Nouveau Sort",
        element: "Feu",
        description: "Lance une boule de Feu sur un adversaire.",
        prerequis: "📋 <strong>Prérequis:</strong> Niveau 1",
        portee: "🎯 <strong>Portée:</strong> 20m",
        tempsIncantation: "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        coutMana: "🔵 <strong>Coût mana:</strong> 3",
        resistance: "<strong>Sans effet si:</strong> Esquive.",
        effetNormal: "<strong>Effet:</strong> Inflige 5 dégats de <span style='color: #e25822; font-weight: bold;'>Feu</span> à la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        effetCritique: "<strong>Coup Critique:&nbsp;</strong>&nbsp;Double les dégâts et enflamme la cible."
      }
    },

    don: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'Prérequis', required: true },
        cout: { type: 'richtext', label: 'Coût', required: true }
      },
      editMapping: {
        'don-name': 'nom',
        'don-description': 'description',
        'don-prerequis': 'prerequis',
        'don-cout': 'cout'
      },
      identifiers: {
        name: 'nom',
        category: 'dons'
      },
      template: 'don-card',
      container: 'dons',
      dataKey: 'DONS',
      icons: { 
        category: '🎖️', 
        item: '🏆',
        add: '➕',
        delete: '🗑️'
      },
      defaultValues: {
        nom: "Nouveau Don",
        description: "Description du don.",
        prerequis: "Aucun prérequis",
        cout: "1 point de don"
      }
    },

    class: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        resume: { type: 'textarea', label: 'Résumé', required: true },
        capacites: { type: 'list', label: 'Capacités', required: true }
      },
      editMapping: {
        'class-name': 'nom',
        'class-resume': 'resume',
        'class-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: null
      },
      template: 'class-page',
      container: 'classes',
      dataKey: 'CLASSES',
      icons: { 
        category: '⚔️', 
        item: '🛡️',
        add: '➕',
        delete: '🗑️'
      }
    },

    subclass: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        base: { type: 'stats', label: 'Statistiques de base', required: true },
        progression: { type: 'richtext', label: 'Progression', required: true },
        capacites: { type: 'list', label: 'Capacités', required: true }
      },
      editMapping: {
        'subclass-name': 'nom',
        'subclass-description': 'description',
        'subclass-stats': 'base',
        'subclass-progression': 'progression',
        'subclass-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: 'sousClasses',
        parent: 'class'
      },
      template: 'subclass-card',
      icons: { 
        item: '⚡',
        add: '➕',
        delete: '🗑️'
      },
      defaultValues: {
        nom: "Nouvelle sous-classe",
        description: "Description de la sous-classe",
        base: {
          Force: 3,
          Agilité: 3,
          Endurance: 3,
          Intelligence: 3,
          Volonté: 3,
          Chance: 3
        },
        progression: "<strong>📈 Progression par niveau:</strong> +1 Force 💪, +1 Agilité 🏃",
        capacites: [
          "<em>Capacité unique</em>: Description de la capacité spéciale de cette sous-classe."
        ]
      }
    },

    objet: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        numero: { type: 'number', label: 'Numéro', required: true },
        image: { type: 'text', label: 'Image', required: false },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        effet: { type: 'richtext', label: 'Effet', required: true },
        prix: { type: 'richtext', label: 'Prix', required: true },
        poids: { type: 'richtext', label: 'Poids', required: true }
      },
      editMapping: {
        'objet-name': 'nom',
        'objet-numero': 'numero',
        'objet-image': 'image',
        'objet-description': 'description',
        'objet-tags': 'tags',
        'objet-effet': 'effet',
        'objet-prix': 'prix',
        'objet-poids': 'poids'
      },
      identifiers: {
        name: 'nom',
        category: 'objets'
      },
      template: 'objet-card',
      container: 'objets',
      dataKey: 'OBJETS',
      pageType: 'single', // Page unique avec filtres
      icons: { 
        category: '📦', 
        item: '🎒',
        add: '➕',
        delete: '🗑️'
      },
      // Configuration des filtres disponibles (MISE À JOUR AUTOMATIQUE)
      filterConfig: {
        availableTags: [
          "Arme",
          "Armure",
          "Consommable",
          "Bouclier",
          "Épée",
          "Arme exotique",
          "Une main",
          "Deux mains",
          "Baton",
          "Dague",
          "Arc",
          "Armure lourde",
          "Armure légère",
          "Robe",
          "Plante",
          "Catalyseur",
          "Nouvel objet",
          "Nourriture",
          "Non identifié",
          "Flèche"
],
        defaultVisibleTags: [
          "Arme"
] // Filtres affichés par défaut
      },
      defaultValues: {
        nom: "Nouvel Objet",
        numero: 1,
        image: "",
        description: "Description de l'objet.",
        tags: ["Nouvel objet"],
        effet: "<strong>Effet:</strong> Description de l'effet de l'objet.",
        prix: "🔷 <strong>Prix:</strong> 10",
        poids: "⚖️ <strong>Poids:</strong> 1"
      }
    },

    monster: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        image: { type: 'text', label: 'Image', required: false },
        element: { 
          type: 'select', 
          label: "Élément d'affiliation", 
          required: true,
          options: [
            { value: 'Feu', label: '🔥 Feu' },
            { value: 'Eau', label: '💧 Eau' },
            { value: 'Terre', label: '🤎 Terre' },
            { value: 'Air', label: '🟢 Air' },
            { value: 'Lumiere', label: '☀️ Lumière' },
            { value: 'Nuit', label: '⚫ Nuit' },
            { value: 'Divin', label: '⚪ Divin' },
            { value: 'Malefique', label: '🟣 Maléfique' }
          ]
        },
        pointsDeVie: { type: 'number', label: 'Points de vie', required: true },
        armurePhysique: { type: 'number', label: 'Armure physique', required: true },
        esquive: { type: 'number', label: 'Esquive', required: true },
        coupCritique: { type: 'number', label: 'Coup critique', required: true },
        coupCritiqueSorts: { type: 'number', label: 'Critique sorts', required: true },
        resistanceAlterations: { type: 'number', label: 'Résistance altérations', required: true },
        armureFeu: { type: 'number', label: 'Armure Feu', required: true },
        armureEau: { type: 'number', label: 'Armure Eau', required: true },
        armureTerre: { type: 'number', label: 'Armure Terre', required: true },
        armureAir: { type: 'number', label: 'Armure Air', required: true },
        armureLumiere: { type: 'number', label: 'Armure Lumière', required: true },
        armureObscurite: { type: 'number', label: 'Armure Obscurité', required: true },
        armureDivin: { type: 'number', label: 'Armure Divin', required: true },
        armureMalefique: { type: 'number', label: 'Armure Maléfique', required: true },
        abilites: { type: 'richtext', label: 'Abilités', required: false },
        butin: { type: 'richtext', label: 'Butin', required: false }
      },
      editMapping: {
        'monster-name': 'nom',
        'monster-tags': 'tags',
        'monster-image': 'image',
        'monster-element': 'element',
        // Stats principaux
        'monster-pointsdevie': 'pointsDeVie',
        'monster-armurephysique': 'armurePhysique', 
        'monster-esquive': 'esquive',
        'monster-coupcritique': 'coupCritique',
        'monster-coupcritiquesorts': 'coupCritiqueSorts',
        'monster-resistancealterations': 'resistanceAlterations',
        // Armures élémentaires
        'monster-armurefeu': 'armureFeu',
        'monster-armureeau': 'armureEau',
        'monster-armureterre': 'armureTerre',
        'monster-armureair': 'armureAir',
        'monster-armurelumiere': 'armureLumiere',
        'monster-armureobscurite': 'armureObscurite',
        'monster-armuredivin': 'armureDivin',
        'monster-armuremalefique': 'armureMalefique',
        // Contenu narratif
        'monster-abilites': 'abilites',
        'monster-butin': 'butin'
      },
      identifiers: {
        name: 'nom',
        category: 'monstres'
      },
      template: 'monster-card',
      container: 'monstres',
      dataKey: 'MONSTRES',
      pageType: 'single',
      filterMode: 'AND',
      icons: { 
        category: '🐲', 
        item: '👾',
        add: '➕',
        delete: '🗑️'
      },
      filterConfig: {
        availableTags: [
          "Forêt",
          "Boss"
],
        defaultVisibleTags: [
          "Forêt"
]
      },
      defaultValues: {
        nom: "Nouveau Monstre",
        tags: ["Forêt"],
        image: "",
        element: "Feu",
        pointsDeVie: 20,
        armurePhysique: 2,
        esquive: 5,
        coupCritique: 10,
        coupCritiqueSorts: 8,
        resistanceAlterations: 3,
        armureFeu: 0,
        armureEau: 0,
        armureTerre: 0,
        armureAir: 0,
        armureLumiere: 0,
        armureObscurite: 0,
        armureDivin: 0,
        armureMalefique: 0,
        abilites: "<strong>Attaque basique:</strong> Inflige 5 dégâts physiques.",
        butin: "<strong>Butin:</strong> 10-50 pièces d'or."
      }
    },

    tableTresor: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        fourchettes: { type: 'list', label: 'Fourchettes', required: true }
      },
      editMapping: {
        'table-tresor-name': 'nom',
        'table-tresor-description': 'description',
        'table-tresor-tags': 'tags'
      },
      identifiers: {
        name: 'nom',
        category: 'tables'
      },
      template: 'table-tresor-card',
      container: 'tables-tresors',
      dataKey: 'TABLES_TRESORS',
      pageType: 'single',
      filterMode: 'OR',
      icons: { 
        category: '💎', 
        item: '📦',
        add: '➕',
        delete: '🗑️'
      },
      filterConfig: {
        // availableTags managed dynamically via window.TABLES_TRESORS._metadata.availableTags
        defaultVisibleTags: [
          "Forêt",
          "Boss"
        ]
      },
      defaultValues: {
        nom: "Nouvelle Table de Trésor",
        description: "Table de butin pour une situation spécifique.",
        tags: ["Forêt"],
        fourchettes: [
          {
            min: 1,
            max: 10,
            objet: {
              type: "reference",
              numero: 1,
              nom: "Objet par défaut"
            }
          }
        ]
      }
    },

    staticPage: {
      fields: {
        title: { type: 'text', label: 'Titre', required: true },
        sections: { type: 'sections', label: 'Sections', required: true }
      },
      template: 'static-page',
      icons: { 
        category: '📄', 
        item: '📝'
      }
    }
  };

  window.StatIcons = {
    'Force': '💪',
    'Agilité': '🏃',
    'Endurance': '🛡️',
    'Intelligence': '🧠',
    'Volonté': '⚡',
    'Chance': '🍀'
  };

  window.ElementColors = {
    'Feu': { color: '#ff6b35', weight: 'bold' },
    'Eau': { color: '#4682b4', weight: 'bold' },
    'Terre': { color: '#8b4513', weight: 'bold' },
    'Air': { color: '#22c55e', weight: 'bold' },
    'Lumière': { color: '#ffd700', weight: 'bold' },
    'Nuit': { color: '#1a1a1a', weight: 'bold' },
    'Divin': { color: '#f5f5f5', weight: 'bold', background: 'rgba(100, 100, 100, 0.3)', padding: '2px 4px', borderRadius: '3px' },
    'Maléfique': { color: '#8b5cf6', weight: 'bold' }
  };

  window.ElementIcons = {
    'Feu': '🔥',
    'Eau': '💧',
    'Terre': '🤎',
    'Air': '🟢',
    'Lumière': '☀️',
    'Nuit': '⚫',
    'Divin': '⚪',
    'Maléfique': '🟣'
  };

  // Campaign content type
  window.ContentTypes.campaign = {
    fields: {
      name: { type: 'text', label: 'Nom', required: true },
      description: { type: 'textarea', label: 'Description', required: false }
    },
    template: 'campaign',
    container: 'campaigns',
    dataKey: 'CAMPAIGNS',
    icons: { category: '🗂️', item: '📋', add: '➕', delete: '🗑️' },
    defaultValues: {
      name: 'Nouvelle Campagne',
      description: 'Description de la campagne'
    }
  };

  // Campaign sub-page content type  
  window.ContentTypes.campaignSubPage = {
    fields: {
      title: { type: 'text', label: 'Titre', required: true },
      content: { type: 'textarea', label: 'Contenu', required: false }
    },
    template: 'campaign-subpage',
    container: 'campaign-subpages', 
    dataKey: 'CAMPAIGN_SUBPAGES',
    icons: { category: '📄', item: '📝', add: '➕', delete: '🗑️' },
    defaultValues: {
      title: 'Nouvelle sous-page',
      content: 'Contenu de la sous-page...'
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - EVENT BUS
// ============================================================================

(() => {
  "use strict";

  class EventBus {
    constructor() {
      this.listeners = new Map();
    }

    static getInstance() {
      if (!EventBus.instance) {
        EventBus.instance = new EventBus();
      }
      return EventBus.instance;
    }

    on(eventType, callback) {
      if (!this.listeners.has(eventType)) {
        this.listeners.set(eventType, []);
      }
      this.listeners.get(eventType).push(callback);
      return () => this.off(eventType, callback);
    }

    off(eventType, callback) {
      const callbacks = this.listeners.get(eventType);
      if (callbacks) {
        const index = callbacks.indexOf(callback);
        if (index > -1) {
          callbacks.splice(index, 1);
        }
      }
    }

    emit(eventType, payload = {}) {
      const callbacks = this.listeners.get(eventType);
      if (callbacks) {
        callbacks.forEach(callback => {
          try {
            callback(payload);
          } catch (error) {
            console.error(`Error in event callback for ${eventType}:`, error);
          }
        });
      }
    }

    once(eventType, callback) {
      const unsubscribe = this.on(eventType, (payload) => {
        callback(payload);
        unsubscribe();
      });
      return unsubscribe;
    }
  }

  window.EventBus = EventBus.getInstance();

  window.Events = {
    CONTENT_ADD: 'content:add',
    CONTENT_DELETE: 'content:delete',
    CONTENT_UPDATE: 'content:update',
    CONTENT_MOVE: 'content:move',
    PAGE_RENDER: 'page:render',
    EDITOR_TOGGLE: 'editor:toggle',
    IMAGE_UPLOAD: 'image:upload',
    IMAGE_DELETE: 'image:delete',
    STORAGE_SAVE: 'storage:save',
    SEARCH_PERFORM: 'search:perform',
    MODAL_OPEN: 'modal:open',
    MODAL_CLOSE: 'modal:close',
    NOTIFICATION_SHOW: 'notification:show'
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - BASE ENTITY
// ============================================================================

(() => {
  "use strict";

  class BaseEntity {
    constructor(type, dataArray) {
      this.type = type;
      this.data = dataArray || [];
      this.config = window.ContentTypes[type];
      
      // Handle special case for objects with new structure
      if (type === 'objet' && this.data && !Array.isArray(this.data) && this.data.objets) {
        // Convert to pseudo-category structure for compatibility
        this.objectsData = this.data; // Keep reference to original structure
        this.data = [{ nom: 'objets', objets: this.data.objets }]; // Wrap in array format
      }
      
      // Handle special case for treasure tables with structure: { tables: [...], _metadata: {...} }
      if (type === 'tableTresor' && this.data && !Array.isArray(this.data) && this.data.tables) {
        // Convert to pseudo-category structure for compatibility
        this.tablesData = this.data; // Keep reference to original structure
        this.data = [{ nom: 'tables', tables: this.data.tables }]; // Wrap in array format
      }
    }

    getAll() {
      return this.data;
    }

    findCategory(categoryName) {
      return this.data.find(category => category.nom === categoryName);
    }

    findItem(itemName, categoryName = null) {
      if (categoryName) {
        const category = this.findCategory(categoryName);
        if (!category || !category[this.getItemsProperty()]) return null;
        
        const item = category[this.getItemsProperty()].find(item => item.nom === itemName);
        return item ? { item, category: category.nom } : null;
      }

      for (const category of this.data) {
        if (!category[this.getItemsProperty()]) continue;
        const item = category[this.getItemsProperty()].find(item => item.nom === itemName);
        if (item) {
          return { item, category: category.nom };
        }
      }
      return null;
    }

    addItem(categoryName, itemData) {
      const category = this.findCategory(categoryName);
      if (!category) return false;

      const itemsProperty = this.getItemsProperty();
      if (!category[itemsProperty]) {
        category[itemsProperty] = [];
      }

      const defaultValues = this.config?.defaultValues || {};
      const newItem = { ...defaultValues, ...itemData };
      category[itemsProperty].push(newItem);

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_ADD, {
        type: this.type,
        category: categoryName,
        item: newItem
      });

      return newItem;
    }

    deleteItem(categoryName, itemName) {
      const category = this.findCategory(categoryName);
      if (!category) return false;

      const itemsProperty = this.getItemsProperty();
      const items = category[itemsProperty];
      if (!items) return false;

      const index = items.findIndex(item => item.nom === itemName);
      if (index === -1) return false;

      const deletedItem = items.splice(index, 1)[0];

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_DELETE, {
        type: this.type,
        category: categoryName,
        item: deletedItem
      });

      return true;
    }

    updateItem(categoryName, itemName, property, value) {
      const result = this.findItem(itemName, categoryName);
      if (!result) return false;

      const { item } = result;
      
      if (property === 'capacites' && Array.isArray(value)) {
        item[property] = value;
      } else if (property === 'base' && typeof value === 'object') {
        item[property] = { ...item[property], ...value };
      } else {
        item[property] = value;
      }

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_UPDATE, {
        type: this.type,
        category: categoryName,
        item: item,
        property: property,
        value: value
      });

      return true;
    }

    moveItem(categoryName, itemName, direction) {
      const category = this.findCategory(categoryName);
      if (!category) return false;

      const itemsProperty = this.getItemsProperty();
      const items = category[itemsProperty];
      if (!items) return false;

      const currentIndex = items.findIndex(item => item.nom === itemName);
      if (currentIndex === -1) return false;

      const newIndex = currentIndex + direction;
      if (newIndex < 0 || newIndex >= items.length) return false;

      [items[currentIndex], items[newIndex]] = [items[newIndex], items[currentIndex]];

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_MOVE, {
        type: this.type,
        category: categoryName,
        itemName: itemName,
        direction: direction
      });

      return true;
    }

    getItemsProperty() {
      switch (this.type) {
        case 'spell': return 'sorts';
        case 'don': return 'dons';
        case 'objet': return 'objets';
        case 'class': return 'sousClasses';
        case 'tableTresor': return 'tables';
        default: return 'items';
      }
    }

    search(query) {
      const results = [];
      const normalizedQuery = query.toLowerCase().trim();

      this.data.forEach(category => {
        const itemsProperty = this.getItemsProperty();
        if (!category[itemsProperty]) return;

        category[itemsProperty].forEach(item => {
          const searchableText = Object.values(item).join(' ').toLowerCase();
          if (searchableText.includes(normalizedQuery)) {
            results.push({
              item,
              category: category.nom,
              type: this.type
            });
          }
        });
      });

      return results;
    }

    // Sync changes back to original objects data structure
    syncObjectsData() {
      // Sync objects data
      if (this.type === 'objet' && this.objectsData && this.data.length > 0) {
        const objectsCategory = this.data[0];
        if (objectsCategory && objectsCategory.objets) {
          this.objectsData.objets = objectsCategory.objets;
        }
      }
      
      // Sync treasure tables data
      if (this.type === 'tableTresor' && this.tablesData && this.data.length > 0) {
        const tablesCategory = this.data[0];
        if (tablesCategory && tablesCategory.tables) {
          this.tablesData.tables = tablesCategory.tables;
        }
      }
      
      // Sync monsters data - CRITICAL for preventing data reversion
      if (this.type === 'monster' && window.MONSTRES && Array.isArray(this.data)) {
        // Ensure window.MONSTRES stays synchronized with our internal data
        window.MONSTRES.length = 0; // Clear array
        window.MONSTRES.push(...this.data); // Replace with current data
        
        // Also sync image mappings
        if (JdrApp.modules.images && typeof JdrApp.modules.images.ensureMonsterImageMappings === 'function') {
          JdrApp.modules.images.ensureMonsterImageMappings();
        }
      }
    }
  }

  window.BaseEntity = BaseEntity;

})();
// ============================================================================
// JDR-BAB APPLICATION - CONTENT FACTORY
// ============================================================================

(() => {
  "use strict";

  class ContentFactory {
    constructor() {
      this.entities = new Map();
      this.initialize();
    }

    static getInstance() {
      if (!ContentFactory.instance) {
        ContentFactory.instance = new ContentFactory();
      }
      return ContentFactory.instance;
    }

    initialize() {
      // Lazy initialization - only create entities when data is available
      if (window.SORTS) {
        this.entities.set('spell', new BaseEntity('spell', window.SORTS));
      }
      if (window.DONS) {
        this.entities.set('don', new BaseEntity('don', window.DONS));
      }
      if (window.CLASSES) {
        this.entities.set('class', new BaseEntity('class', window.CLASSES));
      }
      if (window.OBJETS) {
        this.entities.set('objet', new BaseEntity('objet', window.OBJETS));
      }
      if (window.MONSTRES) {
        this.entities.set('monster', new BaseEntity('monster', window.MONSTRES));
      }
      if (window.TABLES_TRESORS) {
        this.entities.set('tableTresor', new BaseEntity('tableTresor', window.TABLES_TRESORS));
      }
    }

    getEntity(type) {
      // Ensure entity exists, create if data is available but entity is missing
      if (!this.entities.has(type)) {
        this.initializeEntity(type);
      }
      return this.entities.get(type);
    }

    initializeEntity(type) {
      switch (type) {
        case 'spell':
          if (window.SORTS) {
            this.entities.set('spell', new BaseEntity('spell', window.SORTS));
          }
          break;
        case 'don':
          if (window.DONS) {
            this.entities.set('don', new BaseEntity('don', window.DONS));
          }
          break;
        case 'class':
          if (window.CLASSES) {
            this.entities.set('class', new BaseEntity('class', window.CLASSES));
          }
          break;
        case 'objet':
          if (window.OBJETS) {
            this.entities.set('objet', new BaseEntity('objet', window.OBJETS));
          }
          break;
        case 'monster':
          if (window.MONSTRES) {
            this.entities.set('monster', new BaseEntity('monster', window.MONSTRES));
          }
          break;
        case 'tableTresor':
          if (window.TABLES_TRESORS) {
            this.entities.set('tableTresor', new BaseEntity('tableTresor', window.TABLES_TRESORS));
          }
          break;
      }
    }

    getSpells() {
      return this.getEntity('spell');
    }

    getDons() {
      return this.getEntity('don');
    }

    getClasses() {
      return this.getEntity('class');
    }

    getObjets() {
      return this.getEntity('objet');
    }

    getMonsters() {
      return this.getEntity('monster');
    }

    getTablesTresors() {
      return this.getEntity('tableTresor');
    }

    findItem(type, itemName, categoryName = null) {
      const entity = this.getEntity(type);
      return entity ? entity.findItem(itemName, categoryName) : null;
    }

    addItem(type, categoryName, itemData) {
      const entity = this.getEntity(type);
      return entity ? entity.addItem(categoryName, itemData) : false;
    }

    deleteItem(type, categoryName, itemName) {
      const entity = this.getEntity(type);
      return entity ? entity.deleteItem(categoryName, itemName) : false;
    }

    updateItem(type, categoryName, itemName, property, value) {
      const entity = this.getEntity(type);
      return entity ? entity.updateItem(categoryName, itemName, property, value) : false;
    }

    moveItem(type, categoryName, itemName, direction) {
      const entity = this.getEntity(type);
      return entity ? entity.moveItem(categoryName, itemName, direction) : false;
    }

    searchAll(query) {
      const allResults = [];
      
      this.entities.forEach((entity, type) => {
        const results = entity.search(query);
        allResults.push(...results);
      });

      return allResults;
    }

    refreshData() {
      this.entities.clear();
      this.initialize();
    }

    // ============================================================================
    // UNIFIED PAGE DESCRIPTION SYSTEM
    // ============================================================================

    getPageDescription(type) {
      const config = window.ContentTypes[type];
      
      if (!config || !config.pageDescription) {
        return '';
      }
      
      const pageDesc = config.pageDescription;
      
      if (pageDesc.dataSource === 'external') {
        // Utilisation d'un fichier externe via dataKey
        const dataObj = window[pageDesc.dataKey];
        if (!dataObj) {
          // Créer l'objet externe s'il n'existe pas
          window[pageDesc.dataKey] = { [pageDesc.storageKey]: pageDesc.defaultValue };
          return pageDesc.defaultValue;
        }
        return dataObj[pageDesc.storageKey] || pageDesc.defaultValue;
      } else {
        // Source de données intégrée dans le dataKey principal
        const mainDataKey = config.dataKey;
        const mainData = window[mainDataKey];
        
        if (!mainData) {
          return pageDesc.defaultValue;
        }
        
        // Initialiser la description si elle n'existe pas
        if (!mainData[pageDesc.storageKey]) {
          mainData[pageDesc.storageKey] = pageDesc.defaultValue;
        }
        
        return mainData[pageDesc.storageKey];
      }
    }

    updatePageDescription(type, newDescription) {
      
      // Ensure collections type exists (fallback injection)
      if (type === 'collections' && (!window.ContentTypes || !window.ContentTypes.collections)) {
        this.ensureCollectionsType();
      }
      
      const config = window.ContentTypes[type];
      
      if (!config || !config.pageDescription) {
        // No page description config found for type
        return false;
      }
      
      const pageDesc = config.pageDescription;
      
      try {
        if (pageDesc.dataSource === 'external') {
          // Mise à jour d'un fichier externe via dataKey
          const dataObj = window[pageDesc.dataKey];
          if (!dataObj) {
            window[pageDesc.dataKey] = {};
          }
          window[pageDesc.dataKey][pageDesc.storageKey] = newDescription;
          
          // Also update JdrApp.data.customPageDescriptions for consistency with router and storage
          if (!JdrApp.data.customPageDescriptions) {
            JdrApp.data.customPageDescriptions = {};
          }
          JdrApp.data.customPageDescriptions[pageDesc.storageKey] = newDescription;
        } else {
          // Mise à jour dans le dataKey principal
          const mainDataKey = config.dataKey;
          const mainData = window[mainDataKey];
          
          if (!mainData) {
            return false;
          }
          
          mainData[pageDesc.storageKey] = newDescription;
        }
        
        // Émettre un événement pour notifier le changement
        if (window.EventBus) {
          window.EventBus.emit('pageDescriptionUpdated', { type, description: newDescription });
        }
        
        return true;
      } catch (error) {
        return false;
      }
    }

    getConfig(type) {
      return window.ContentTypes[type];
    }

    createDefaultItem(type, overrides = {}) {
      const config = this.getConfig(type);
      if (!config?.defaultValues) return {};

      return { ...config.defaultValues, ...overrides };
    }

    ensureCollectionsType() {
      if (!window.ContentTypes) {
        window.ContentTypes = {};
      }
      
      // Inject collections type if missing
      window.ContentTypes.collections = {
        fields: {
          description: { type: 'richtext', label: 'Description', required: true }
        },
        template: 'collections-page',
        container: 'collections',
        icons: { 
          category: '📚', 
          item: '📦'
        },
        pageDescription: {
          dataSource: 'external',
          dataKey: 'CUSTOM_PAGE_DESCRIPTIONS',
          storageKey: 'collections-objets',
          defaultValue: "Recherchez et explorez des collections d'objets organisées par thème"
        },
        defaultValues: {
          description: "Recherchez et explorez des collections d'objets organisées par thème"
        }
      };
      
      // Collections type injected into ContentTypes
    }
  }

  window.ContentFactory = ContentFactory.getInstance();

})();
// ============================================================================
// JDR-BAB APPLICATION - CARD BUILDER
// ============================================================================

(() => {
  "use strict";

  class CardBuilder {
    constructor(type, data, categoryName = null, index = null) {
      this.type = type;
      this.data = data;
      this.categoryName = categoryName;
      this.index = index;
      this.config = window.ContentTypes[type];
    }

    static create(type, data, categoryName = null, index = null) {
      return new CardBuilder(type, data, categoryName, index);
    }

    // Simple unified dev mode check
    get shouldShowEditButtons() {
      return JdrApp.utils.isDevMode();
    }

    build() {
      switch (this.type) {
        case 'spell':
          return this.buildSpellCard();
        case 'don':
          return this.buildDonCard();
        case 'subclass':
          return this.buildSubclassCard();
        case 'objet':
          return this.buildObjetCard();
        case 'monster':
          return this.buildMonsterCard();
        case 'tableTresor':
          return this.buildTableTresorCard();
        default:
          return this.buildGenericCard();
      }
    }

    buildSpellCard() {
      return `
        <div class="card editable-section" data-section-type="spell" data-spell-name="${this.data.nom}" data-spell-index="${this.index}" data-category-name="${this.categoryName}">
          ${this.buildEditableTitle(this.data.nom, 'spell-name')}
          ${this.buildSpellElement()}
          ${this.buildIllustration(`sort:${this.categoryName}:${this.data.nom}`, this.data.nom)}
          ${this.buildEditableField(this.data.description, 'spell-description', 'Description', { style: 'text-align: center; font-style: italic; margin: 1rem 0;' })}
          <hr style="margin: 1rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.6;">
          ${this.buildEditableField(this.data.prerequis, 'spell-prerequis', 'Prérequis')}
          ${this.buildEditableField(this.data.portee, 'spell-portee', 'Portée')}
          ${this.buildEditableField(this.data.coutMana, 'spell-mana', 'Coût mana')}
          ${this.buildEditableField(this.data.tempsIncantation, 'spell-temps-incantation', 'Temps d\'incantation')}
          <hr style="margin: 0.5rem 0; border: none; border-top: 1px solid var(--rule);">
          ${this.buildEditableField(this.data.resistance, 'spell-resistance', 'Résistance')}
          ${this.buildEditableEffect(this.data.effetNormal, 'spell-effect-normal', 'Effet normal')}
          <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
          ${this.data.effetCritique ? this.buildEditableEffect(this.data.effetCritique, 'spell-effect-critical', 'Effet critique') : ''}
          ${this.buildDeleteButton('spell')}
        </div>
      `;
    }

    buildDonCard() {
      const index = this.index !== null ? this.index : (this.categoryName ? this.getCategoryData().dons?.indexOf(this.data) || 0 : 0);
      const totalItems = this.categoryName ? this.getCategoryData().dons?.length || 1 : 1;

      return `
        <div class="card editable-section" data-section-type="don" data-don-name="${this.data.nom}" data-don-index="${this.index}" data-category-name="${this.categoryName}">
          ${this.buildEditableTitle(this.data.nom, 'don-name')}
          ${this.buildIllustration(`don:${this.data.nom}`, this.data.nom)}
          ${this.buildEditableField(this.data.description, 'don-description', 'Description')}
          ${this.buildEditableField(this.data.prerequis, 'don-prerequis', 'Prérequis')}
          ${this.buildEditableField(this.data.cout, 'don-cout', 'Coût', { style: 'color: var(--bronze); font-weight: 600;' })}
          ${this.buildMoveButtons('don', index, totalItems)}
        </div>
      `;
    }

    buildSubclassCard() {
      return `
        <div class="card editable-section" data-section-type="subclass" data-class-name="${this.categoryName}" data-subclass-name="${this.data.nom}">
          ${this.buildEditableTitle(this.data.nom, 'subclass-name')}
          ${this.buildEditableField(this.data.description || 'Description de la sous-classe', 'subclass-description', 'Description', { style: 'text-align: center; color: inherit;' })}
          ${this.buildSubclassImages()}
          <div style="margin-bottom: 1rem;">
            ${this.buildStatsSection()}
          </div>
          ${this.buildEditableField(this.data.progression, 'subclass-progression', 'Progression')}
          <div class="rule" style="margin: 1.5rem auto; height: 2px; background: linear-gradient(90deg, transparent, var(--bronze), transparent); opacity: 0.6;"></div>
          ${this.buildEditableList(this.data.capacites, 'subclass-capacites', 'Capacités')}
          ${this.buildDeleteButton('subclass')}
        </div>
      `;
    }

    buildObjetCard() {
      // Pour les objets en page unique, l'index est basé sur tous les objets
      const allObjects = window.OBJETS?.objets || [];
      const index = allObjects.indexOf(this.data) || 0;
      const totalItems = allObjects.length;
      
      // Construire l'affichage des tags
      const tagsDisplay = this.data.tags && this.data.tags.length > 0 
        ? this.data.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';

      return `
        <div class="card editable-section" data-section-type="objet" data-objet-name="${this.data.nom}" data-category-name="${this.categoryName}">
          ${this.buildEditableTitle(this.data.nom, 'objet-name')}
          ${this.buildIllustration(`objet:${this.data.nom}`, this.data.nom)}
          <div style="display: flex; justify-content: space-between; align-items: center; margin: 0.5rem 0; font-size: 0.9em; color: var(--bronze);">
            ${this.buildEditableField(`N°${this.data.numero}`, 'objet-numero', 'Numéro', { style: 'font-weight: bold;' })}
            <div style="flex: 1; text-align: right;">
              <div style="margin: 2px 0;">
                ${this.buildEditableTagsField(tagsDisplay, 'objet-tags', 'Tags')}
              </div>
            </div>
          </div>
          ${this.buildEditableField(this.data.description, 'objet-description', 'Description')}
          <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
          ${this.buildEditableField(this.data.effet, 'objet-effet', 'Effet')}
          <div style="display: flex; justify-content: space-between; gap: 1rem; margin: 0.5rem 0;">
            <div style="flex: 1;">${this.buildEditableField(this.data.prix, 'objet-prix', 'Prix')}</div>
            <div style="flex: 1;">${this.buildEditableField(this.data.poids, 'objet-poids', 'Poids')}</div>
          </div>
        </div>
      `;
    }

    buildMonsterCard() {
      const allMonsters = window.MONSTRES || [];
      const index = allMonsters.indexOf(this.data) || 0;
      const totalItems = allMonsters.length;
      
      // Construire l'affichage des tags
      const tagsDisplay = this.data.tags && this.data.tags.length > 0 
        ? this.data.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';

      return `
        <div class="card editable-section" data-section-type="monster" data-monster-name="${this.data.nom}">
          ${this.buildEditableTitle(this.data.nom, 'monster-name')}
          ${this.buildIllustration(`monster:${this.data.nom}`, this.data.nom)}
          
          <div style="display: flex; justify-content: space-between; align-items: flex-start; margin: 0.5rem 0; gap: 1rem;">
            <div style="flex: 1;">
              ${this.buildEditableTagsField(tagsDisplay, 'monster-tags', 'Tags')}
            </div>
            <div style="flex-shrink: 0;">
              ${this.buildMonsterElement()}
            </div>
          </div>
          
          <!-- Séparation avant les stats principales -->
          <hr style="margin: 1.5rem 0 1rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.3;">
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin: 1rem 0; font-size: 0.9em;">
            <div>${this.buildEditableStatField('🎯 Initiative', this.data.initiative, 'monster-initiative', 'Initiative')}</div>
            <div>${this.buildEditableStatField('❤️ PV', this.data.pointsDeVie, 'monster-pointsdevie', 'Points de vie')}</div>
            <div>${this.buildEditableStatField('⚡ Critique', this.data.coupCritique, 'monster-coupcritique', 'Coup critique')}</div>
            <div>${this.buildEditableStatField('🛡️ Armure', this.data.armurePhysique, 'monster-armurephysique', 'Armure physique')}</div>
            <div>${this.buildEditableStatField('🔮 Crit. Sorts', this.data.coupCritiqueSorts, 'monster-coupcritiquesorts', 'Critique sorts')}</div>
            <div>${this.buildEditableStatField('🏃 Esquive', this.data.esquive, 'monster-esquive', 'Esquive')}</div>
            <div></div>
            <div>${this.buildEditableStatField('✨ Rés. Alt.', this.data.resistanceAlterations, 'monster-resistancealterations', 'Résistance altérations')}</div>
          </div>

          <!-- Séparation après les stats principales -->
          <hr style="margin: 1rem 0 1.5rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.3;">

          <div style="margin: 1rem 0;">
            <strong>🌟 Armures Élémentaires:</strong>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 0.25rem; font-size: 0.8em; margin-top: 0.5rem;">
              <div>${this.buildEditableStatField(this.getElementIcon('Feu'), this.data.armureFeu, 'monster-armurefeu', 'Armure Feu')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Eau'), this.data.armureEau, 'monster-armureeau', 'Armure Eau')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Terre'), this.data.armureTerre, 'monster-armureterre', 'Armure Terre')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Air'), this.data.armureAir, 'monster-armureair', 'Armure Air')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Lumière'), this.data.armureLumiere, 'monster-armurelumiere', 'Armure Lumière')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Nuit'), this.data.armureObscurite, 'monster-armureobscurite', 'Armure Obscurité')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Divin'), this.data.armureDivin, 'monster-armuredivin', 'Armure Divin')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Maléfique'), this.data.armureMalefique, 'monster-armuremalefique', 'Armure Maléfique')}</div>
            </div>
          </div>

          ${this.data.abilites ? `
            <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
            ${this.buildEditableField(this.data.abilites, 'monster-abilites', 'Abilités', { style: 'margin-top: 0.5rem;' })}
          ` : ''}

          ${this.data.butin ? `
            <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
            ${this.buildEditableField(this.data.butin, 'monster-butin', 'Butin', { style: 'margin-top: 0.5rem;' })}
          ` : ''}

          ${this.buildDeleteButton('monster')}
        </div>
      `;
    }

    buildEditableTitle(content, editType, centerAlign = true) {
      const style = centerAlign ? 'margin: 0 0 1rem 0; text-align: center;' : '';
      const spellTitleClass = this.type === 'spell' ? ' spell-title' : '';
      const subclassTitleClass = this.type === 'subclass' ? ' subclass-title' : '';
      const editTypeClass = editType ? ` ${editType}` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <h4 style="${style}" class="editable editable-title${spellTitleClass}${subclassTitleClass}${editTypeClass}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}">${content}</h4>
          ${this.buildEditButton('title')}
        </div>
      `;
    }

    buildEditableField(content, editType, label, options = {}) {
      const style = options.style ? `style="${options.style}"` : '';
      const className = options.className || 'editable-field';
      
      // Add the editType as a class for reliable detection
      const editTypeClass = editType ? ` ${editType}` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable ${className}${editTypeClass}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" ${style}>
            ${content}
          </div>
          ${this.buildEditButton('field')}
        </div>
      `;
    }

    buildEditableStatField(title, value, editType, label, options = {}) {
      const style = options.style ? `style="${options.style}"` : '';
      const className = options.className || 'editable-stat';
      
      // Display the value only as editable, but show title + value visually
      return `
        <div class="editable-section" data-section-type="html">
          <div style="display: flex; align-items: center;">
            <strong style="margin-right: 0.25rem;">${title}:</strong>
            <div class="editable ${className}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" ${style}>
              ${value}
            </div>
          </div>
          ${this.buildEditButton('field')}
        </div>
      `;
    }
    
    buildEditableTagsField(content, editType, label, options = {}) {
      const style = options.style ? `style="${options.style}"` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable editable-tags" data-edit-type="tags" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" ${style}>
            ${content}
          </div>
          ${this.buildEditButton('field')}
        </div>
      `;
    }

    buildEditableEffect(content, editType, label) {
      const editTypeClass = editType ? ` ${editType}` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable editable-effect${editTypeClass}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" style="margin: 1rem 0;">
            ${content}
          </div>
          ${this.buildEditButton('effect')}
        </div>
      `;
    }

    buildEditableList(items, editType, label) {
      // Everything should be HTML format only
      let listHTML;
      if (typeof items === 'string') {
        // HTML string format
        listHTML = items;
      } else {
        // Fallback if somehow still array format - convert once
        if (Array.isArray(items)) {
          listHTML = '<ul>' + items.map(item => '<li>' + item + '</li>').join('') + '</ul>';
        } else {
          listHTML = '<ul><li>Aucune capacité définie</li></ul>';
        }
      }
      
      // Use the editType directly instead of creating compound identifier
      return `
        <h5>${label}</h5>
        <div class="editable-section" data-section-type="html">
          <div class="editable" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}">
            ${listHTML}
          </div>
          ${this.buildEditButton('list')}
        </div>
      `;
    }

    buildStatsSection() {
      // Stats are special - they remain as objects since they're structured data
      // But check if they were converted to HTML string by editing
      let statsHTML;
      
      if (typeof this.data.base === 'string') {
        // Already converted to HTML by editing
        statsHTML = this.data.base;
      } else if (typeof this.data.base === 'object') {
        // Original object format - convert to HTML
        statsHTML = '<div class="chips">' + 
          Object.entries(this.data.base).map(([stat, value]) => {
            const icon = window.StatIcons[stat] || '⚡';
            return '<span class="chip">' + icon + ' ' + stat + ': <strong>' + value + '</strong></span>';
          }).join('') + 
          '</div>';
      } else {
        statsHTML = '<div>Aucune statistique définie</div>';
      }
      
      // Use subclass-stats directly
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable editable-stats" data-edit-type="generic" data-edit-section="subclass-stats" data-item-identifier="${this.data.nom}">
            ${statsHTML}
          </div>
          ${this.buildEditButton('stats')}
        </div>
      `;
    }

    buildSubclassImages() {
      const illusKey1 = `subclass:${this.categoryName}:${this.data.nom}:1`;
      const illusKey2 = `subclass:${this.categoryName}:${this.data.nom}:2`;
      
      return `
        <div class="subclass-images">
          ${this.buildIllustration(illusKey1, `${this.data.nom} (Image 1)`, 'subclass')}
          ${this.buildIllustration(illusKey2, `${this.data.nom} (Image 2)`, 'subclass')}
        </div>
      `;
    }

    buildIllustration(illusKey, altText = '', styleType = 'default') {
      let imageUrl = '';
      let imageStyle = 'display: none;';
      let removeStyle = 'display: none;';
      
      if (window.JdrApp?.modules?.images?.getImageUrl) {
        imageUrl = window.JdrApp.modules.images.getImageUrl(illusKey);
        if (imageUrl) {
          imageUrl = window.JdrApp.modules.images.processImageUrl(imageUrl);
          imageStyle = 'display: inline-block;';
          removeStyle = 'display: inline-flex;';
        }
      }

      let containerClasses = 'illus';
      if (['spell', 'class', 'subclass', 'don', 'objet', 'monster'].includes(styleType)) {
        containerClasses += ` illus-${styleType}`;
      }

      // HYBRID APPROACH: Never generate buttons in standalone, always generate in dev mode
      const isStandalone = window.STANDALONE_VERSION === true;
      
      if (isStandalone) {
        // STANDALONE: Never generate image buttons at all
        return `
          <div class="${containerClasses}" data-illus-key="${illusKey}" data-style-type="${styleType}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
          </div>
        `;
      } else {
        // DEV MODE: Always generate buttons, let CSS handle visibility
        return `
          <div class="${containerClasses}" data-illus-key="${illusKey}" data-style-type="${styleType}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
            <label class="up">📷 Ajouter<input accept="image/*" hidden="" type="file"></label>
            <button class="rm" type="button" style="${removeStyle}">🗑 Retirer</button>
          </div>
        `;
      }
    }

    buildSpellElement() {
      return `
        <div class="spell-element-section">
          <div class="spell-element-display" style="text-align: center; margin: 0.5rem 0;">
            <span class="element-badge" style="display: inline-block; padding: 4px 12px; background: var(--accent); color: white; border-radius: 16px; font-size: 0.9em; font-weight: 600;">
              ${this.getElementIcon(this.data.element)} ${this.data.element}
            </span>
          </div>
          <div class="spell-element-selector" style="text-align: center; margin: 0.5rem 0; display: none;">
            <label for="spell-element-${this.data.nom}" style="display: block; margin-bottom: 0.25rem; font-weight: 600;">Élément:</label>
            <select id="spell-element-${this.data.nom}" class="editable" data-edit-type="select" data-edit-section="spell-element" data-item-identifier="${this.data.nom}">
              <option value="Feu" ${this.data.element === 'Feu' ? 'selected' : ''}>${this.getElementIcon('Feu')} Feu</option>
              <option value="Eau" ${this.data.element === 'Eau' ? 'selected' : ''}>${this.getElementIcon('Eau')} Eau</option>
              <option value="Terre" ${this.data.element === 'Terre' ? 'selected' : ''}>${this.getElementIcon('Terre')} Terre</option>
              <option value="Air" ${this.data.element === 'Air' ? 'selected' : ''}>${this.getElementIcon('Air')} Air</option>
              <option value="Lumière" ${this.data.element === 'Lumière' ? 'selected' : ''}>${this.getElementIcon('Lumière')} Lumière</option>
              <option value="Nuit" ${this.data.element === 'Nuit' ? 'selected' : ''}>${this.getElementIcon('Nuit')} Nuit</option>
              <option value="Divin" ${this.data.element === 'Divin' ? 'selected' : ''}>${this.getElementIcon('Divin')} Divin</option>
              <option value="Maléfique" ${this.data.element === 'Maléfique' ? 'selected' : ''}>${this.getElementIcon('Maléfique')} Maléfique</option>
            </select>
          </div>
        </div>
      `;
    }

    buildMonsterElement() {
      const elementColor = this.getElementColor(this.data.element);
      
      return `
        <div class="monster-element-section">
          <div class="monster-element-display">
            <span class="element-badge" style="
              display: inline-flex; 
              align-items: center; 
              padding: 4px 8px; 
              background: rgba(${parseInt(elementColor.slice(1,3), 16)}, ${parseInt(elementColor.slice(3,5), 16)}, ${parseInt(elementColor.slice(5,7), 16)}, 0.1); 
              border-radius: 6px; 
              border: 1px solid ${elementColor};
              font-size: 0.8em;
              font-weight: 600;
            ">
              <span style="margin-right: 4px;">${this.getElementIcon(this.data.element)}</span>
              <span style="color: ${elementColor};">${this.data.element}</span>
            </span>
          </div>
          <div class="monster-element-selector" style="margin-top: 0.5rem; display: none;">
            <select class="editable" data-edit-type="select" data-edit-section="monster-element" data-item-identifier="${this.data.nom}" style="width: 100%; padding: 4px; border: 1px solid ${elementColor}; border-radius: 4px; font-size: 0.8em;">
              <option value="Feu" ${this.data.element === 'Feu' ? 'selected' : ''}>${this.getElementIcon('Feu')} Feu</option>
              <option value="Eau" ${this.data.element === 'Eau' ? 'selected' : ''}>${this.getElementIcon('Eau')} Eau</option>
              <option value="Terre" ${this.data.element === 'Terre' ? 'selected' : ''}>${this.getElementIcon('Terre')} Terre</option>
              <option value="Air" ${this.data.element === 'Air' ? 'selected' : ''}>${this.getElementIcon('Air')} Air</option>
              <option value="Lumière" ${this.data.element === 'Lumière' ? 'selected' : ''}>${this.getElementIcon('Lumière')} Lumière</option>
              <option value="Nuit" ${this.data.element === 'Nuit' ? 'selected' : ''}>${this.getElementIcon('Nuit')} Nuit</option>
              <option value="Divin" ${this.data.element === 'Divin' ? 'selected' : ''}>${this.getElementIcon('Divin')} Divin</option>
              <option value="Maléfique" ${this.data.element === 'Maléfique' ? 'selected' : ''}>${this.getElementIcon('Maléfique')} Maléfique</option>
            </select>
          </div>
        </div>
      `;
    }

    getElementIcon(element) {
      return window.ElementIcons?.[element] || '⚡';
    }

    getElementColor(element) {
      return window.ElementColors?.[element]?.color || '#666';
    }

    buildTableTresorCard() {
      const tableIndex = window.TABLES_TRESORS?.tables ? window.TABLES_TRESORS.tables.indexOf(this.data) : 0;
      const totalTables = window.TABLES_TRESORS?.tables?.length || 1;
      
      // Condition améliorée pour afficher les boutons d'édition des fourchettes
      const shouldShowFourchetteButtons = this.shouldShowEditButtons || 
                                         (!window.STANDALONE_VERSION && window.location.search.includes('dev=1')) ||
                                         (document.body.classList.contains('dev-on')) ||
                                         (window.location.protocol === 'file:' && !window.STANDALONE_VERSION) ||
                                         // Condition de fallback pour le développement
                                         (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1');
      
      // Construire l'affichage des tags
      const tagsDisplay = this.data.tags && this.data.tags.length > 0 
        ? this.data.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';
      
      // Construire l'affichage des fourchettes
      const fourchetteDisplay = this.data.fourchettes?.map((fourchette, index) => {
        const objet = fourchette.objet;
        const objetLink = objet?.type === 'reference' 
          ? `<a href="#" class="object-preview-link" data-object-numero="${objet.numero}" style="color: var(--accent); text-decoration: none;" title="Cliquer pour prévisualiser l'objet #${objet.numero}">📦 ${objet.nom} (N°${objet.numero})</a>`
          : `📦 ${objet?.nom || 'Objet inconnu'}`;
        
        const editButtons = shouldShowFourchetteButtons ? `
          <div class="fourchette-actions" style="margin-left: 8px; display: flex; gap: 4px;">
            <button class="edit-fourchette-btn" data-table-name="${this.data.nom}" data-fourchette-index="${index}" title="Éditer cette fourchette" style="background: #3b82f6; color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;">✏️</button>
            <button class="delete-fourchette-btn" data-table-name="${this.data.nom}" data-fourchette-index="${index}" title="Supprimer cette fourchette" style="background: #dc2626; color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;">🗑️</button>
          </div>
        ` : '';
        
        return `
          <div class="fourchette-row" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; margin: 4px 0; background: rgba(139, 92, 23, 0.1); border-radius: 6px; border-left: 3px solid var(--bronze);">
            <div class="fourchette-range" style="font-weight: bold; color: var(--bronze); min-width: 80px;">
              🎲 ${fourchette.min}-${fourchette.max}
            </div>
            <div class="fourchette-objet" style="flex: 1; margin-left: 12px;">
              ${objetLink}
            </div>
            ${editButtons}
          </div>
        `;
      }).join('') || '<div style="font-style: italic; color: #666; text-align: center; padding: 1rem;">Aucune fourchette définie</div>';

      return `
        <div class="card editable-section" data-section-type="tableTresor" data-table-tresor-name="${this.data.nom}" data-category-name="${this.categoryName}">
          ${this.buildEditableTitle(this.data.nom, 'table-tresor-name')}
          <div style="text-align: center; margin: 0.5rem 0;">
            ${this.buildEditableTagsField(tagsDisplay, 'table-tresor-tags', 'Tags')}
          </div>
          
          <hr style="margin: 1rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.6;">
          
          <div class="fourchettes-section">
            <h4 style="color: var(--bronze); margin: 1rem 0 0.5rem 0; display: flex; align-items: center; gap: 8px;">
              🎲 Fourchettes de butin
            </h4>
            <div class="fourchettes-list">
              ${fourchetteDisplay}
            </div>
          </div>
          
          ${shouldShowFourchetteButtons ? `
            <div class="edit-actions" style="margin-top: 1rem; text-align: center; display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center;">
              <button class="table-tresor-add-fourchette btn" data-table-tresor-name="${this.data.nom}" type="button" style="background: var(--accent); color: white;">
                ➕ Ajouter fourchette
              </button>
              ${this.buildMoveButtons('table-tresor', tableIndex, totalTables)}
            </div>
            ${this.buildDeleteButton('table-tresor')}
          ` : ''}
        </div>
      `;
    }

    buildGenericCard() {
      return `
        <div class="card">
          <h4>${this.data.nom || 'Unknown'}</h4>
          <p>Generic card for type: ${this.type}</p>
        </div>
      `;
    }

    buildEditButton(buttonType) {
      return `<button class="edit-btn" type="button" title="✏️ Éditer" data-button-type="${buttonType}">✏️</button>`;
    }

    buildDeleteButton(type) {
      const config = this.config;
      const deleteIcon = config?.icons?.delete || '🗑️';
      
      return `
        <div class="delete-button-container" style="margin-top: 1rem; text-align: center;">
          <button class="${type}-delete btn" data-${type}-name="${this.data.nom}" ${this.categoryName ? `data-category-name="${this.categoryName}"` : ''} type="button" style="background: #dc2626; color: white; border: 2px solid #b91c1c;">
            ${deleteIcon} Supprimer ${type}
          </button>
        </div>
      `;
    }

    buildMoveButtons(type, index, totalItems) {
      if (totalItems <= 1) {
        return '';
      }

      return `
        <div class="move-buttons" style="display: flex; gap: 0.5rem; justify-content: center; margin-top: 1rem;">
          <button class="${type}-move-up btn small" data-${type}-name="${this.data.nom}" data-category-name="${this.categoryName}" type="button" style="background: #3b82f6; color: white; padding: 4px 8px; font-size: 0.8em;" ${index === 0 ? 'disabled' : ''}>
            ↑ Haut
          </button>
          <button class="${type}-move-down btn small" data-${type}-name="${this.data.nom}" data-category-name="${this.categoryName}" type="button" style="background: #3b82f6; color: white; padding: 4px 8px; font-size: 0.8em;" ${index >= totalItems - 1 ? 'disabled' : ''}>
            ↓ Bas
          </button>
        </div>
      `;
    }

    getCategoryData() {
      if (this.type === 'don' && this.categoryName) {
        const categoryData = window.DONS.find(cat => cat.nom === this.categoryName);
        return categoryData || { dons: [] };
      }
      return { [this.type + 's']: [] };
    }
  }

  window.CardBuilder = CardBuilder;

})();
// ============================================================================
// JDR-BAB APPLICATION - PAGE BUILDER
// ============================================================================

(() => {
  "use strict";

  class PageBuilder {
    constructor() {
      // Will use unified dev mode check
    }

    // Simple unified dev mode check
    get shouldShowEditButtons() {
      return JdrApp.utils.isDevMode();
    }

    static getInstance() {
      if (!PageBuilder.instance) {
        PageBuilder.instance = new PageBuilder();
      }
      return PageBuilder.instance;
    }

    buildCategoryPage(type, category) {
      const config = window.ContentTypes[type];
      
      // Gestion spéciale pour les objets (page unique avec filtres)
      if (type === 'objet' && config.pageType === 'single') {
        return this.buildSingleObjectPage(category);
      }
      
      // Gestion spéciale pour les tables de trésors (page unique)
      if (type === 'tableTresor' && config.pageType === 'single') {
        return this.buildSingleTableTresorPage(category);
      }
      
      const pageId = `${config.container}-${this.sanitizeId(category.nom || 'unknown')}`;
      const itemsProperty = this.getItemsProperty(type);
      
      // Get items and sort them for spells
      let items = category[itemsProperty] || [];
      if (type === 'spell') {
        items = this.sortSpellsByLevel([...items]);
      }

      return `
        <article class="" data-page="${pageId}">
          <section>
            ${this.buildCategoryHeader(category, type)}
            ${type === 'spell' ? this.buildSpellLevelFilter() : ''}
            <div style="display: flex; gap: 8px; margin-bottom: 1rem; flex-wrap: wrap;">
              ${this.buildAddButton(type, category.nom)}
              ${this.buildDeleteCategoryButton(type, category.nom)}
            </div>
            <div class="grid cols-2" id="${config.container}-container-${this.sanitizeId(category.nom)}">
              ${items.map((item, index) => 
                CardBuilder.create(type, item, category.nom, index).build()
              ).join('')}
            </div>
            ${this.buildGeneralDonsSection(type, category.nom)}
          </section>
        </article>
      `;
    }
    
    buildSingleObjectPage(objectData) {
      const config = window.ContentTypes['objet'];
      const allObjects = objectData.objets || [];
      // SIMPLIFIÉ: Système simple avec variable globale pour les tags actifs
      const availableTags = config.filterConfig.availableTags || [];
      
      // Initialiser la variable globale pour les tags actifs si elle n'existe pas
      if (!window.ACTIVE_OBJECT_TAGS) {
        window.ACTIVE_OBJECT_TAGS = []; // Aucun tag actif par défaut
      }
      const activeTags = window.ACTIVE_OBJECT_TAGS;
      
      // Filtrer les objets selon le mode actuel
      const isDevMode = JdrApp.utils.isDevMode();
      
      // console.log('🎯 Object filtering - isDevMode:', isDevMode, 'activeIdSearch:', !!window.activeIdSearch, 'activeTags:', activeTags.length);
      
      const filteredObjects = window.activeIdSearch 
        ? allObjects // TOUJOURS afficher tous les objets quand recherche par ID est active
        : !isDevMode
          ? [] // Mode dev OFF: aucun objet affiché par défaut (seule recherche ID fonctionne)
          : activeTags.length === 0 
            ? allObjects // Mode dev ON + aucun tag actif = TOUS les objets
            : allObjects.filter(obj => {
                // Mode dev ON: LOGIQUE ET - l'objet doit avoir TOUS les tags actifs
                if (!obj.tags || obj.tags.length === 0) return false;
                // Vérifier que l'objet a TOUS les tags actifs (logique AND)
                return activeTags.every(activeTag => obj.tags.includes(activeTag));
              });
      
      // console.log('📊 Filtered objects count:', filteredObjects.length, '/ Total objects:', allObjects.length);
      
      return `
        <article class="" data-page="objets">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2>📦 Objets</h2>
              ${this.buildIllustration('page:objets')}
            </div>
            
            ${this.buildPageDescription('objet')}
            
            ${this.buildIdSearchFilter()}
            ${this.buildTagFilters(activeTags, availableTags)}
            
            <div style="display: flex; gap: 8px; margin-bottom: 1rem; flex-wrap: wrap;">
              ${this.buildAddButton('objet', 'objets')}
              ${this.buildTagsManagerButton()}
            </div>
            
            <div class="grid cols-2" id="objets-container">
              ${filteredObjects.map((item, index) => 
                CardBuilder.create('objet', item, 'objets', index).build()
              ).join('')}
            </div>
            
            ${filteredObjects.length === 0 && !window.activeIdSearch ? '<p style="text-align: center; color: #666; margin: 2rem 0;">Aucun objet ne correspond aux filtres sélectionnés.</p>' : ''}
          </section>
        </article>
      `;
    }

    buildSingleMonsterPage(monsterData) {
      let config = window.ContentTypes?.['monster'];
      const allMonsters = monsterData || [];
      const instance = PageBuilder.getInstance(); // Créer une instance pour accéder aux méthodes
      
      // Defensive check for config with fallback
      if (!config || !config.filterConfig) {
        console.warn('Monster config not loaded, using fallback defaults');
        console.log('ContentTypes available:', window.ContentTypes ? Object.keys(window.ContentTypes) : 'undefined');
        config = {
          filterConfig: {
            defaultVisibleTags: ['Forêt'],
            availableTags: ['Forêt', 'Boss', 'Minion', 'Volant', 'Aquatique', 'Terrestre']
          }
        };
      }
      
      // Utiliser le state du filtre s'il existe, sinon les tags par défaut
      const visibleTags = window.MONSTRES_FILTER_STATE?.visibleTags || config.filterConfig.defaultVisibleTags;
      
      // Filter monsters according to visible tags (AND mode)
      const filteredMonsters = visibleTags.length === 0 
        ? [] // If no tags are visible, show nothing
        : allMonsters.filter(monster => {
            // Check that the monster has the required tags to be visible
            if (!monster.tags) return false;
            
            // In AND mode: monster must have ALL visible tags
            const hasAllVisibleTags = visibleTags.every(tag => monster.tags.includes(tag));
            if (!hasAllVisibleTags) return false;
            
            return true;
          });
      
      return `
        <article class="" data-page="monstres">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2>🐲 Monstres</h2>
              ${instance.buildIllustration('page:monstres')}
            </div>
            
            ${instance.buildPageDescription('monster')}
            
            ${instance.buildTagFilters(visibleTags, config.filterConfig.availableTags, 'monster')}
            
            <div style="display: flex; gap: 8px; margin-bottom: 1rem; flex-wrap: wrap;">
              ${instance.buildAddButton('monster', 'monstres')}
              ${instance.buildTagsManagerButton()}
            </div>
            
            <div class="grid cols-2" id="monstres-container">
              ${filteredMonsters.map((item, index) => 
                CardBuilder.create('monster', item, 'monstres', index).build()
              ).join('')}
            </div>
            
            ${filteredMonsters.length === 0 ? '<p style="text-align: center; color: #666; margin: 2rem 0;">Aucun monstre ne correspond aux filtres sélectionnés.</p>' : ''}
          </section>
        </article>
      `;
    }

    buildClassPage(classData) {
      const pageId = this.sanitizeId(classData.nom);
      
      return `
        <article class="" data-page="${pageId}" data-page-title="${classData.nom}">
          <section>
            ${this.buildClassHeader(classData)}
            ${this.buildEditableSection(classData.resume, 'class-resume', 'paragraph', classData.nom)}
            <h3>Capacités de classe</h3>
            ${this.buildSimpleEditableContent(classData.capacites, 'class-capacites', classData.nom)}
            <h3>Sous-classes</h3>
            <div class="subclass-stack">
              ${classData.sousClasses ? classData.sousClasses.map(sousClasse => 
                CardBuilder.create('subclass', sousClasse, classData.nom).build()
              ).join('') : ''}
            </div>
            ${this.buildAddSubclassButton()}
          </section>
        </article>
      `;
    }

    buildStaticPage(pageId, pageData) {
      const isActive = pageId === 'creation' ? 'active' : '';
      
      // Defense against missing or malformed pageData
      if (!pageData || typeof pageData !== 'object') {
        console.warn('buildStaticPage: invalid pageData', pageData);
        return `<article class="${isActive}" data-page="${pageId}"><section><h2>Page non disponible</h2><p>Les données de cette page ne sont pas disponibles.</p></section></article>`;
      }
      
      const title = pageData.title || pageId;
      const page = pageData.page || pageId;
      
      // Special handling for campaign page
      if (pageId === 'campagne') {
        return this.buildCampaignPage(pageId, pageData);
      }
      
      return `
        <article class="${isActive}" data-page="${page}" data-static-page="true" data-page-title="${title}">
          <section>
            ${this.buildStaticPageHeader(pageData)}
            ${this.buildSections(pageData.sections)}
            ${this.buildAddSectionButton()}
          </section>
        </article>
      `;
    }

    buildCategoryHeader(category, type) {
      const config = window.ContentTypes[type];
      
      return `
        <div style="text-align:center;margin-bottom:2rem;">
          ${this.buildEditableTitle(category.nom, `${type}-category-name`)}
          ${this.buildIllustration(`${type}category:${category.nom}`)}
        </div>
        ${this.buildEditableSection(category.description, `${type}-category-description`, 'paragraph', category.nom)}
      `;
    }

    buildClassHeader(classData) {
      return `
        <div style="text-align:center;margin-bottom:2rem;">
          ${this.buildEditableTitle(classData.nom, 'class-name', classData.nom)}
          ${this.buildIllustration(`class:${classData.nom}`)}
        </div>
      `;
    }

    buildStaticPageHeader(pageData) {
      const printButton = pageData.page === 'etats' ? this.buildPrintButton() : '';
      
      return `
        <div style="text-align:center;margin-bottom:2rem;">
          <div style="display:inline-flex;align-items:center;gap:8px;">
            <h2 class="editable editable-title" data-edit-type="generic" data-edit-section="page-title">${pageData.title}</h2>
            ${this.buildEditButton('title')}
          </div>
          ${this.buildIllustration(`page:${pageData.page}`)}
          ${printButton}
        </div>
      `;
    }

    buildCompactCampaignHeader(pageData) {
      return `
        <div style="text-align:center;margin-bottom:0.5rem;">
          <div style="display:inline-flex;align-items:center;gap:8px;">
            <h2 class="editable editable-title" data-edit-type="generic" data-edit-section="page-title">${pageData.title}</h2>
            ${this.buildEditButton('title')}
          </div>
        </div>
      `;
    }

    buildEditableTitle(content, editType, editSection = null) {
      return `
        <div style="display:inline-flex;align-items:center;gap:8px;justify-content:center;">
          <h2 class="editable editable-title" data-edit-type="generic" data-edit-section="${editSection || content}">${content}</h2>
          ${this.buildEditButton('title')}
        </div>
      `;
    }

    buildEditableSection(content, editType, sectionType, editSection) {
      const className = sectionType === 'paragraph' ? 'lead editable editable-paragraph' : 'editable editable-field';
      
      return `
        <div class="editable-section" data-section-type="${editType}">
          <p class="${className}" data-edit-type="generic" data-edit-section="${editSection}">${content}</p>
          ${this.buildEditButton(sectionType)}
        </div>
      `;
    }


    buildSimpleEditableContent(content, editType, editSection) {
      // Everything should be HTML format only
      let htmlContent;
      if (typeof content === 'string') {
        htmlContent = content || '';
      } else {
        // Fallback if somehow still array format - convert once and warn
        console.warn('Found array format in buildSimpleEditableContent, converting to HTML:', content);
        if (Array.isArray(content)) {
          htmlContent = '<ul>' + content.map(item => '<li>' + item + '</li>').join('') + '</ul>';
        } else {
          htmlContent = '';
        }
      }
      
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable" data-edit-type="generic" data-edit-section="${editSection}">
            ${htmlContent}
          </div>
          ${this.buildEditButton('section')}
        </div>
      `;
    }

    buildSections(sections) {
      // Defense against undefined sections
      if (!sections || !Array.isArray(sections)) {
        console.warn('buildSections: sections is not an array', sections);
        return '';
      }
      
      return sections.map((section, sectionIndex) => {
        switch (section.type) {
          case 'intro':
            return this.buildIntroSection(section, sectionIndex);
          case 'card':
            return this.buildCardSection(section, sectionIndex);
          case 'grid':
            return this.buildGridSection(section, sectionIndex);
          case 'filters':
            return this.buildFiltersSection(section, sectionIndex);
          case 'monster-list':
            return this.buildMonsterListSection(section, sectionIndex);
          default:
            return `<div><!-- Unknown section type: ${section.type} --></div>`;
        }
      }).join('');
    }

    buildIntroSection(section, sectionIndex) {
      const editSection = `intro-${sectionIndex}`;
      return `
        <div class="editable-section" data-section-type="intro" data-section-index="${sectionIndex}">
          <p class="editable editable-intro" data-edit-type="generic" data-edit-section="${editSection}">${section.content}</p>
          ${this.buildEditButton('section')}
        </div>
        ${this.buildAddParagraphButton('intro')}
      `;
    }

    buildCardSection(cardData, sectionIndex) {
      let cardHTML = `<div class="card editable-section" data-section-type="card" data-section-index="${sectionIndex}">`;
      
      if (cardData.deletable && cardData.sectionType) {
        cardHTML += `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${cardData.id}-title">${cardData.title}</h3>
            ${this.buildEditButton('title')}
            ${this.buildRemoveSectionButton(cardData.sectionType)}
          </div>
        `;
      } else {
        cardHTML += `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${cardData.id}-title">${cardData.title}</h3>
            ${this.buildEditButton('title')}
          </div>
        `;
      }

      // Handle different content formats
      let htmlContent = '';
      let editSection = cardData.id || 'card-' + sectionIndex;
      
      if (typeof cardData.content === 'string') {
        // Direct HTML string
        htmlContent = cardData.content;
      } else if (typeof cardData.content === 'object' && cardData.content?.content) {
        // Object with nested content property
        htmlContent = cardData.content.content;
        if (cardData.content.editSection) {
          editSection = cardData.content.editSection;
        }
      } else {
        htmlContent = cardData.content || '';
      }
      
      cardHTML += `
        <div style="position:relative;">
          <div class="editable" data-edit-type="generic" data-edit-section="${editSection}">${htmlContent}</div>
          ${this.buildEditButton('section')}
        </div>
      `;

      if (cardData.deletable && cardData.sectionName) {
        // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
        cardHTML += `
          <div style="margin-top: 1rem; text-align: center;">
            <button class="section-delete btn small" data-section-name="${cardData.sectionName}" type="button" style="background: #ff6b6b; color: white;">🗑 Supprimer section</button>
          </div>
        `;
      }
      
      cardHTML += `</div>`;
      return cardHTML;
    }


    buildContentItem(item) {
      if (item.type === 'paragraph') {
        const content = `
          <div class="editable-section" data-section-type="paragraph">
            <p class="editable editable-paragraph" data-edit-type="generic" data-edit-section="${item.editSection}">${item.content}</p>
            ${this.buildEditButton('paragraph')}
          </div>
        `;
        const addBtn = this.buildAddParagraphButton(item.editSection);
        return content + addBtn;
      }
      return `<div>${item.content}</div>`;
    }

    buildGridSection(gridSection, sectionIndex) {
      const items = gridSection.content || gridSection.items || [];
      if (!Array.isArray(items)) {
        return '<div><!-- Grid items is not an array --></div>';
      }

      const cols = gridSection.cols || 2;
      let gridHTML = `<div class="grid" style="display: grid; grid-template-columns: repeat(${cols}, 1fr); gap: 1rem;">`;
      
      items.forEach((item, itemIndex) => {
        gridHTML += this.buildCardSection(item, `${sectionIndex}-${itemIndex}`);
      });
      
      gridHTML += '</div>';
      return gridHTML;
    }

    buildComplexContent(content) {
      // Generic HTML content - no special processing
      return content || '';
    }


    buildIllustration(illusKey, altText = '') {
      let imageUrl = '';
      let imageStyle = 'display: none;';
      let removeStyle = 'display: none;';
      
      if (window.JdrApp?.modules?.images?.getImageUrl) {
        imageUrl = window.JdrApp.modules.images.getImageUrl(illusKey);
        if (imageUrl) {
          imageUrl = window.JdrApp.modules.images.processImageUrl(imageUrl);
          imageStyle = 'display: inline-block;';
          removeStyle = 'display: inline-flex;';
        }
      }

      // HYBRID APPROACH: Never generate buttons in standalone, always generate in dev mode
      const isStandalone = window.STANDALONE_VERSION === true;
      
      if (isStandalone) {
        // STANDALONE: Never generate image buttons at all
        return `
          <div class="illus" data-illus-key="${illusKey}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
          </div>
        `;
      } else {
        // DEV MODE: Always generate buttons, let CSS handle visibility
        return `
          <div class="illus" data-illus-key="${illusKey}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
            <label class="up">📷 Ajouter<input accept="image/*" hidden="" type="file"></label>
            <button class="rm" type="button" style="${removeStyle}">🗑 Retirer</button>
          </div>
        `;
      }
    }

    buildFiltersSection(section, sectionIndex) {
      const contentType = section.contentType || 'monster';
      
      // Ensure ContentTypes is loaded
      if (!window.ContentTypes) {
        console.warn('ContentTypes not loaded yet, skipping filters');
        return '';
      }
      
      let config = window.ContentTypes[contentType];
      const filterMode = section.filterMode || 'OR';
      
      // Fallback configuration for monster if not loaded
      if (!config && contentType === 'monster') {
        config = {
          filterConfig: {
            availableTags: ["Foret", "Animal", "Humanoid", "Dragon", "Faible", "Puissant", "Boss", "Feu", "Eau", "Terre", "Air", "Rapide", "Poison"],
            defaultVisibleTags: ["Foret", "Animal", "Humanoid"]
          }
        };
      }
      
      if (!config || !config.filterConfig) {
        return '';
      }
      
      const availableTags = config.filterConfig.availableTags || [];
      const defaultTags = config.filterConfig.defaultVisibleTags || [];
      
      return `
        <div class="filter-section" data-content-type="${contentType}" data-filter-mode="${filterMode}">
          <h3>🔍 Filtres (${filterMode === 'AND' ? 'ET' : 'OU'})</h3>
          <div class="filter-tags" data-default-tags='${JSON.stringify(defaultTags)}'>
            ${availableTags.map(tag => `
              <label class="filter-tag ${defaultTags.includes(tag) ? 'active' : ''}">
                <input type="checkbox" value="${tag}" ${defaultTags.includes(tag) ? 'checked' : ''}>
                <span>${tag}</span>
              </label>
            `).join('')}
          </div>
          ${this.buildDevModeButtons(contentType)}
        </div>
      `;
    }

    buildMonsterListSection(section, sectionIndex) {
      const contentType = section.contentType || 'monster';
      
      return `
        <div class="monster-list-section" data-content-type="${contentType}">
          <div class="monsters-grid" id="monsters-container">
            <!-- Les monstres seront générés par JavaScript -->
          </div>
        </div>
      `;
    }

    buildDevModeButtons(contentType) {
      // Ensure ContentTypes is loaded for proper button generation
      if (!window.ContentTypes) {
        return '';
      }
      
      // For monster type, generate buttons even if config is missing (they'll work with fallback)
      if (contentType !== 'monster' && !window.ContentTypes[contentType]) {
        return '';
      }
      
      // Use the same approach as modal buttons - conditional rendering based on dev mode
      const isDevMode = JdrApp.utils.isDevMode();
      const displayStyle = isDevMode ? 'block' : 'none';
      
      return `
        <div class="dev-mode-buttons" style="margin-top: 1rem; display: ${displayStyle};" data-dev-only="true">
          <button class="btn btn-small add-${contentType}-btn">➕ Ajouter ${contentType === 'monster' ? 'un monstre' : 'un élément'}</button>
          <button class="btn btn-small manage-tags-btn" data-content-type="${contentType}">🏷️ Gérer les tags</button>
        </div>
      `;
    }

    buildEditButton(type) {
      const titles = {
        title: 'Éditer le titre',
        paragraph: 'Éditer ce paragraphe',
        field: 'Éditer ce champ',
        list: 'Éditer cette liste',
        section: 'Éditer cette section'
      };

      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="edit-btn edit-${type}-btn" title="${titles[type] || 'Éditer'}">✏️</button>`;
    }

    buildAddButton(type, categoryName) {
      const config = window.ContentTypes[type];
      const icon = config?.icons?.add || '➕';
      
      // ALWAYS generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="${type}-add btn" data-category-name="${categoryName}" type="button" style="background: var(--accent); color: white;">${icon} Ajouter un ${type === 'spell' ? 'sort' : type === 'don' ? 'don' : type === 'monster' ? 'monstre' : 'élément'}</button>`;
    }

    buildDeleteCategoryButton(type, categoryName) {
      const config = window.ContentTypes[type];
      const deleteIcon = config?.icons?.delete || '🗑️';
      
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="${type}-category-delete btn" data-category-name="${categoryName}" data-category-type="${type}" type="button" style="background: #dc2626; color: white;">${deleteIcon} Supprimer catégorie</button>`;
    }

    buildAddSubclassButton() {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<div class="add-subclass-btn">➕ Ajouter une sous-classe</div>`;
    }

    buildAddSectionButton() {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<div class="add-paragraph-btn" data-target="section">➕ Ajouter une nouvelle section</div>`;
    }

    buildAddParagraphButton(target) {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<div class="add-paragraph-btn" data-target="${target}">➕ Ajouter un paragraphe</div>`;
    }

    buildRemoveSectionButton(sectionType) {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="remove-section-btn" data-section-type="${sectionType}" type="button" style="background: #dc2626; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 12px;">🗑 Supprimer section</button>`;
    }

    getItemsProperty(type) {
      switch (type) {
        case 'spell': return 'sorts';
        case 'don': return 'dons';
        case 'objet': return 'objets';
        case 'class': return 'sousClasses';
        default: return 'items';
      }
    }

    // Extract level number from prerequis text
    extractLevelFromPrerequisite(prerequis) {
      if (!prerequis) return 0;
      const match = prerequis.match(/Niveau (\d+)/i);
      return match ? parseInt(match[1], 10) : 0;
    }

    // Sort spells by level (prerequisite level)
    sortSpellsByLevel(spells) {
      return spells.sort((a, b) => {
        const levelA = this.extractLevelFromPrerequisite(a.prerequis);
        const levelB = this.extractLevelFromPrerequisite(b.prerequis);
        return levelA - levelB;
      });
    }

    // Build spell level filter UI
    buildSpellLevelFilter() {
      return `
        <div class="spell-level-filter" style="margin: 1rem 0; padding: 1rem; background: var(--card); border: 2px solid var(--rule); border-radius: 12px;">
          <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
            <label style="font-weight: 600; color: var(--accent-ink);">
              🎯 Filtrer par niveau maximum :
            </label>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              <input 
                type="number" 
                id="spell-level-filter" 
                min="0" 
                max="20" 
                value="20"
                style="width: 80px; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px; text-align: center; font-weight: 600;"
              >
              <button 
                id="reset-spell-filter" 
                class="btn small" 
                style="background: var(--bronze); color: white; padding: 0.5rem 1rem;"
                title="Réinitialiser le filtre"
              >
                🔄 Tout afficher
              </button>
            </div>
          </div>
        </div>
      `;
    }

    buildIdSearchFilter() {
      const isIdSearchActive = window.activeIdSearch || false;
      const isDevMode = JdrApp.utils.isDevMode();
      const searchBorderColor = isIdSearchActive ? '#16a34a' : 'var(--rule)';
      const searchBoxShadow = isIdSearchActive ? 'box-shadow: 0 0 8px rgba(22, 163, 74, 0.3);' : '';
      const searchIndicator = isIdSearchActive ? '🎯 ' : '🔍 ';
      const buttonText = isIdSearchActive ? '🔄 Affichage normal' : '🔄 Tout afficher';
      const buttonTitle = isIdSearchActive ? 'Retourner à l\'affichage normal avec filtres' : 'Effacer la recherche et afficher tous les objets';
      
      return `
        <div class="id-search-filter" style="margin: 0.5rem 0; background: var(--card); border: 2px solid ${searchBorderColor}; border-radius: 12px; display: flex; flex-direction: column; ${searchBoxShadow}">
          <div style="display: flex; align-items: center; justify-content: center; gap: 1rem; flex-wrap: wrap; padding: 0.375rem; min-height: 2.5rem;">
            <label for="id-search-input" style="font-weight: 600; color: var(--accent-ink); white-space: nowrap; display: flex; align-items: center; height: 100%;">
              ${searchIndicator}Recherche par ID :
            </label>
            <div style="display: flex; align-items: center; gap: 0.5rem; height: 100%;">
              <input 
                type="number" 
                id="id-search-input" 
                min="1" 
                placeholder="Numéro d'objet (ex: 42)"
                style="padding: 0.2rem; border: 1px solid ${searchBorderColor}; border-radius: 6px; font-size: 0.95em; width: 150px; height: 2rem; display: flex; align-items: center;"
              >
              <button 
                id="clear-id-search" 
                class="btn small" 
                style="background: var(--bronze); color: white; padding: 0.2rem 0.4rem; white-space: nowrap; font-size: 0.9em; display: ${!isDevMode ? 'none' : 'flex'}; align-items: center; height: 2rem; justify-content: center;"
                title="${buttonTitle}"
              >
                ${buttonText}
              </button>
            </div>
          </div>
          <div id="id-search-result" style="padding: 0 0.375rem 0.375rem; font-size: 0.85em; color: var(--paper-muted); min-height: 0.5em; line-height: 1.2; text-align: center;">
            <!-- Résultat de la recherche affiché ici -->
          </div>
        </div>
      `;
    }

    buildPageDescription(type) {
      const config = window.ContentTypes[type];
      
      if (!config || !config.pageDescription) {
        return '';
      }
      
      const pageDesc = config.pageDescription;
      
      // Obtenir la description de manière unifiée
      let description = '';
      
      if (pageDesc.dataSource === 'external') {
        // Utilisation d'un fichier externe via dataKey
        const dataObj = window[pageDesc.dataKey];
        if (!dataObj) {
          // Créer l'objet externe s'il n'existe pas
          window[pageDesc.dataKey] = { [pageDesc.storageKey]: pageDesc.defaultValue };
        }
        description = window[pageDesc.dataKey][pageDesc.storageKey] || pageDesc.defaultValue;
      } else {
        // Source de données intégrée dans le dataKey principal
        const mainDataKey = config.dataKey;
        const mainData = window[mainDataKey];
        
        if (!mainData) {
          console.warn(`Main data key ${mainDataKey} not found for type ${type}`);
          description = pageDesc.defaultValue;
        } else {
          // Initialiser la description si elle n'existe pas
          if (!mainData[pageDesc.storageKey]) {
            mainData[pageDesc.storageKey] = pageDesc.defaultValue;
          }
          description = mainData[pageDesc.storageKey];
        }
      }
      
      const cssClass = `${type}-category-description`;
      const sectionType = `${type}-category-description`;
      
      return `
        <div class="${cssClass}" style="margin: 1rem 0; padding: 1rem; background: var(--card); border-radius: 8px; border-left: 4px solid var(--bronze);">
          <div class="editable-section" data-section-type="${sectionType}">
            <p class="lead editable editable-paragraph" data-edit-type="generic" data-edit-section="${pageDesc.editSection}">${description}</p>
            ${this.buildEditButton('section')}
          </div>
        </div>
      `;
    }

    buildTagFilters(activeTags, availableTags, context = 'objet') {
      // For objects page, show tag filters ONLY in dev mode ON
      const isDevMode = JdrApp.utils.isDevMode();
      
      // console.log('🏷️ buildTagFilters - context:', context, 'isDevMode:', isDevMode, 'body class:', document.body.className);
      // console.log('🏷️ Available tags:', availableTags.length, 'Active tags:', activeTags.length);
      
      if (context === 'objet' && !isDevMode) {
        // console.log('🚫 Hiding tag filters for objects in dev mode OFF');
        return ''; // Hide tag filters in normal mode
      }
      
      // console.log('✅ Showing tag filters for objects in dev mode ON');
      
      const isIdSearchActive = window.activeIdSearch || false;
      const containerOpacity = isIdSearchActive ? '0.4' : '1';
      const containerFilter = isIdSearchActive ? 'grayscale(1)' : 'none';
      const pointerEvents = isIdSearchActive ? 'none' : 'auto';
      
      // Afficher TOUS les tags disponibles, avec ceux actifs en vert
      const allFilterChips = availableTags.map(tag => {
        const isActive = activeTags.includes(tag);
        const bgColor = isActive ? '#16a34a' : '#6b7280'; // Vert pour actif, gris pour inactif
        const textColor = 'white';
        const opacity = isActive ? '1' : '0.6';
        
        return `<button class="filter-chip ${isActive ? 'active' : 'inactive'}" 
                        data-tag="${tag}" 
                        style="background: ${bgColor}; color: ${textColor}; opacity: ${opacity}; 
                               padding: 8px 16px; border-radius: 20px; font-size: 0.9em; font-weight: 500;
                               cursor: pointer; transition: all 0.2s ease; border: none;
                               margin: 2px; ${isActive ? 'box-shadow: 0 2px 4px rgba(22, 163, 74, 0.3);' : ''}"
                        title="${isActive ? 'Actif - Cliquer pour désactiver' : 'Inactif - Cliquer pour activer'}">
                    ${isActive ? '✓ ' : ''}${tag}
                </button>`;
      }).join('');
      
      // Supprimer les boutons Tous/Aucun - les utilisateurs cliquent directement sur les tags
      
      return `
        <div class="objects-tag-display" style="margin: 1rem 0; padding: 1rem; background: var(--card); border: 2px solid var(--rule); border-radius: 12px; opacity: ${containerOpacity}; filter: ${containerFilter}; pointer-events: ${pointerEvents}; transition: all 0.3s ease;">
          <h3 style="margin: 0 0 1rem 0; text-align: center; color: var(--accent-ink);">🔍 Filtres par tag (ET)</h3>
          <p style="text-align: center; color: var(--paper-muted); font-size: 0.9em; margin: 0 0 1rem 0;">
            ${activeTags.length === 0 
              ? 'Aucun filtre actif - Tous les objets affichés' 
              : activeTags.length === 1 
                ? '1 filtre actif - Objets avec ce tag uniquement'
                : `${activeTags.length} filtres actifs - Objets avec TOUS ces tags`}
          </p>
          <div class="filter-chips" style="display: flex; gap: 0.5rem; flex-wrap: wrap; justify-content: center;">
            ${allFilterChips}
          </div>
        </div>
      `;
    }
    
    // SUPPRIMÉ: buildFilterManagerButton - fonctionnalité retirée

    buildTagsManagerButton() {
      // Only show in dev mode - use direct utils check
      if (!JdrApp.utils.isDevMode()) {
        return '';
      }
      return `<button class="tags-manager-btn btn" type="button" style="background: #dc2626; color: white; border: 2px solid #b91c1c;">🏷️ Gérer les tags</button>`;
    }

    buildGeneralDonsSection(type, categoryName) {
      // Only add General Dons section for 'don' type pages, and not for the 'Generaux' category itself
      if (type !== 'don' || categoryName === 'Generaux') {
        return '';
      }

      // Find the "Generaux" category in the DONS data
      const generalCategory = window.DONS?.find(cat => cat.nom === 'Generaux');
      if (!generalCategory || !generalCategory.dons || generalCategory.dons.length === 0) {
        return '';
      }

      // Generate cards for all general dons
      const generalDonsCards = generalCategory.dons.map((don, index) => 
        CardBuilder.create('don', don, 'Generaux', index).build()
      ).join('');

      return `
        <div style="margin-top: 2rem; padding-top: 1.5rem; border-top: 2px solid var(--rule);">
          <h3 style="color: var(--bronze); margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
            🎖️ Dons Généraux
          </h3>
          <p style="margin-bottom: 1.5rem; font-style: italic; color: var(--accent-ink); opacity: 0.8;">
            Ces dons sont accessibles à toutes les classes et peuvent compléter votre build.
          </p>
          <div class="grid cols-2">
            ${generalDonsCards}
          </div>
        </div>
      `;
    }

    // SUPPRIMÉ: buildFilterManagerButton - fonctionnalité retirée
    
    buildTagsManagerButton() {
      // ALWAYS generate the button - CSS will control visibility based on body.dev-on/dev-off  
      if (window.STANDALONE_VERSION) return '';
      
      return `<button class="tags-manager-btn btn" type="button" style="background: #dc2626; color: white; border: 2px solid #b91c1c;">🏷️ Gérer les tags</button>`;
    }

    buildPrintButton() {
      return `
        <div style="margin-top: 1rem;">
          <button id="print-etats-btn" class="print-button" type="button" title="Imprimer la liste des états">
            🖨️ Version imprimable
          </button>
        </div>
      `;
    }

    buildSingleTableTresorPage(tableData) {
      let config = window.ContentTypes?.['tableTresor'];
      const allTables = tableData.tables || [];
      const instance = PageBuilder.getInstance();
      
      // Defensive check for config with fallback
      if (!config || !config.filterConfig) {
        console.warn('TableTresor config not loaded, using fallback defaults');
        config = {
          filterConfig: {
            defaultVisibleTags: ['Commun'],
            availableTags: ['Faible', 'Commun', 'Rare', 'Épique', 'Légendaire', 'Boss', 'Humanoïde', 'Bête', 'Dragon', 'Mort-vivant', 'Élémentaire']
          }
        };
      }
      
      // Priority: Use saved metadata tags as single source of truth
      let availableTags = window.TABLES_TRESORS?._metadata?.availableTags || [];
      
      // Utiliser le state du filtre s'il existe, sinon les tags par défaut qui existent vraiment
      let defaultVisibleTags = config.filterConfig.defaultVisibleTags || [];
      // Filter defaultVisibleTags to only include tags that actually exist in metadata
      if (availableTags.length > 0) {
        defaultVisibleTags = defaultVisibleTags.filter(tag => availableTags.includes(tag));
      }
      const visibleTags = window.TABLES_TRESORS_FILTER_STATE?.visibleTags || defaultVisibleTags;
      
      
      // Filter tables according to visible tags
      const filterMode = config.filterMode || 'OR';
      const filteredTables = visibleTags.length === 0 
        ? allTables // If no tags are visible, show all tables
        : allTables.filter(table => {
            // Check that the table has tags when filtering is active
            if (!table.tags || table.tags.length === 0) return false;
            
            if (filterMode === 'AND') {
              // In AND mode: table must have ALL visible tags
              return visibleTags.every(tag => table.tags.includes(tag));
            } else {
              // In OR mode: table must have AT LEAST ONE visible tag
              return visibleTags.some(tag => table.tags.includes(tag));
            }
          });
          
      
      return `
        <article class="" data-page="tables-tresors">
          <section>
            <header class="page-header">
              <h1 class="page-title" style="display: flex; align-items: center; gap: 0.5rem;">
                💎 Tables de trésors
              </h1>
            </header>
            
            ${instance.buildPageDescription('tableTresor')}
            
            ${instance.buildTagFilters(visibleTags, availableTags, 'tableTresor')}
            
            <div data-dev-only class="dev-buttons-container">
              ${instance.buildAddButton('tableTresor', 'tables')}
              ${instance.buildTagsManagerButton()}
            </div>
            </div>
            
            <div class="grid cols-1" id="tables-tresors-container" style="gap: 1.5rem;">
              ${filteredTables.map((table, index) => 
                CardBuilder.create('tableTresor', table, 'tables', index).build()
              ).join('')}
            </div>
            
            ${filteredTables.length === 0 ? `
              <div style="text-align: center; padding: 2rem; background: var(--card); border-radius: 12px; margin: 1rem 0;">
                <p style="color: var(--accent-ink); font-size: 1.1em; margin-bottom: 1rem;">
                  💎 ${allTables.length === 0 ? 'Aucune table de trésor définie' : 'Aucune table ne correspond aux filtres sélectionnés'}
                </p>
                <p style="color: var(--paper-muted); font-style: italic;">
                  ${allTables.length === 0 
                    ? (instance.shouldShowEditButtons ? 'Utilisez le bouton "Ajouter une table de trésor" ci-dessus pour créer votre première table.' : 'Le Maître de jeu peut créer des tables de trésors en mode développement.')
                    : 'Modifiez vos filtres pour voir d\'autres tables de trésors.'
                  }
                </p>
              </div>
            ` : ''}
            
            <div style="margin-top: 1rem; padding: 1rem; background: var(--card); border-radius: 8px; border-left: 4px solid var(--bronze);">
              <p style="color: var(--accent-ink); margin: 0;">
                📊 Résultats: ${filteredTables.length} table${filteredTables.length !== 1 ? 's' : ''} affichée${filteredTables.length !== 1 ? 's' : ''} sur ${allTables.length} au total
              </p>
            </div>
          </section>
        </article>
      `;
    }

    buildCampaignPage(pageId, pageData) {
      const campaigns = pageData.subPages || {};
      const campaignList = Object.keys(campaigns);
      
      // Get current selections (default to first available or empty)
      const selectedCampaign = window.JdrApp?.state?.selectedCampaign || (campaignList.length > 0 ? campaignList[0] : null);
      const currentCampaign = selectedCampaign && campaigns[selectedCampaign] ? campaigns[selectedCampaign] : null;
      const subPageList = currentCampaign ? Object.keys(currentCampaign.subPages || {}) : [];
      const selectedSubPage = window.JdrApp?.state?.selectedSubPage || (subPageList.length > 0 ? subPageList[0] : null);
      const currentSubPage = selectedSubPage && currentCampaign?.subPages?.[selectedSubPage] ? currentCampaign.subPages[selectedSubPage] : null;
      
      return `
        <article class="" data-page="${pageId}" data-static-page="true" data-page-title="${pageData.title}">
          <section>
            ${pageId === 'campagne' ? this.buildCompactCampaignHeader(pageData) : this.buildStaticPageHeader(pageData)}
            ${pageId === 'campagne' ? '' : this.buildSections(pageData.sections)}
            
            <div class="campaign-manager" style="margin-top: 0.5rem;">
              <!-- Campaign Management Controls -->
              <div class="campaign-controls" style="background: var(--card); border-radius: 12px; padding: 1rem; margin-bottom: 0.5rem;">
                <div style="display: flex; justify-content: center; align-items: center; margin-bottom: 0.5rem;">
                  <div class="dev-buttons" style="display: flex; gap: 8px;">
                    <button class="btn primary small dev-only" onclick="JdrApp.modules.ui.addCampaign()" style="display: none;">
                      ➕ Nouvelle Campagne
                    </button>
                  </div>
                </div>
                
                ${campaignList.length === 0 ? `
                  <div style="text-align: center; padding: 2rem;">
                    <p style="color: var(--accent-ink); font-size: 1.1em; margin-bottom: 1rem;">
                      📖 Aucune campagne créée
                    </p>
                    <p style="color: var(--paper-muted); font-style: italic;">
                      <span class="dev-only" style="display: none;">Utilisez le bouton "Nouvelle Campagne" ci-dessus pour créer votre première campagne.</span>
                      <span class="non-dev-only">Le Maître de jeu peut créer des campagnes en mode développement.</span>
                    </p>
                  </div>
                ` : `
                  <!-- Campaign Selector -->
                  <div class="campaign-selector" style="margin-bottom: 0.5rem; text-align: center;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--accent-ink); text-align: center;">
                      📚 Campagne Active:
                    </label>
                    <div style="display: inline-flex; align-items: center; gap: 8px;">
                      <select id="campaignSelector" onchange="JdrApp.modules.ui.selectCampaign(this.value)" 
                              style="padding: 8px; border-radius: 6px; border: 2px solid var(--rule); background: var(--paper); font-family: inherit;">
                        ${campaignList.map(name => 
                          `<option value="${name}" ${name === selectedCampaign ? 'selected' : ''}>${name}</option>`
                        ).join('')}
                      </select>
                      <button class="btn danger small dev-only" onclick="JdrApp.modules.ui.deleteCampaign('${selectedCampaign}')" 
                              style="display: none;" ${!selectedCampaign ? 'disabled' : ''}>
                        🗑️ Supprimer
                      </button>
                    </div>
                  </div>
                `}
              </div>
              <!-- Campaign Content -->
              ${selectedCampaign && currentCampaign ? this.buildSelectedCampaignContent(selectedCampaign, currentCampaign, selectedSubPage, currentSubPage) : ''}
            </div>
            
            ${this.buildAddSectionButton()}
          </section>
        </article>
      `;
    }

    buildSelectedCampaignContent(campaignName, campaign, selectedSubPage, currentSubPage) {
      const subPageList = campaign.subPages ? Object.keys(campaign.subPages) : [];
      
      return `
        <div class="selected-campaign" style="background: var(--card); border-radius: 12px; padding: 1.5rem; border-left: 4px solid var(--bronze);">
          <!-- Campaign Header -->
          <div class="campaign-header" style="margin-bottom: 1.5rem; border-bottom: 2px solid var(--rule); padding-bottom: 1rem;">
            <div style="display: flex; align-items: center; margin-bottom: 0.5rem;">
              <h3 class="editable" data-edit-type="generic" data-edit-section="campaign-${campaignName}-name" 
                  style="margin: 0; color: var(--accent-ink); flex: 1;">
                ${campaignName}
              </h3>
              ${this.buildEditButton('title')}
            </div>
            <div style="display: flex; align-items: flex-start;">
              <p class="editable" data-edit-type="generic" data-edit-section="campaign-${campaignName}-description" 
                 style="color: var(--paper-muted); margin: 0; font-style: italic; flex: 1;">
                ${campaign.description || 'Description de la campagne'}
              </p>
              ${this.buildEditButton('section')}
            </div>
          </div>
          
          <!-- Sub-pages Section -->
          <div class="campaign-subpages">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
              <h4 style="margin: 0; color: var(--accent-ink);">📄 Sous-pages de la campagne (${subPageList.length})</h4>
              <button class="btn primary small dev-only" onclick="JdrApp.modules.ui.addCampaignSubPage('${campaignName}')" style="display: none;">
                ➕ Nouvelle Sous-page
              </button>
            </div>
            
            ${subPageList.length === 0 ? `
              <div style="text-align: center; padding: 2rem; background: var(--paper-light); border-radius: 8px; margin-bottom: 1rem;">
                <p style="color: var(--paper-muted); font-style: italic;">
                  Aucune sous-page créée pour cette campagne.
                </p>
                <p class="dev-only" style="color: var(--paper-muted); font-size: 0.9em; display: none;">
                  Utilisez le bouton "Nouvelle Sous-page" pour commencer.
                </p>
              </div>
            ` : `
              <!-- Sub-page Selector -->
              <div class="subpage-selector" style="margin-bottom: 1.5rem;">
                <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--accent-ink);">
                  📝 Sous-page Active:
                </label>
                <select id="subPageSelector" onchange="JdrApp.modules.ui.selectSubPage(this.value)" 
                        style="padding: 8px; border-radius: 6px; border: 2px solid var(--rule); background: var(--paper); font-family: inherit;">
                  ${subPageList.map(name => 
                    `<option value="${name}" ${name === selectedSubPage ? 'selected' : ''}>${name}</option>`
                  ).join('')}
                </select>
                <button class="btn danger small dev-only" onclick="JdrApp.modules.ui.deleteCampaignSubPage('${campaignName}', '${selectedSubPage}')" 
                        style="margin-left: 8px; display: none;" ${!selectedSubPage ? 'disabled' : ''}>
                  🗑️ Supprimer
                </button>
              </div>
              
              <!-- Sub-page Content -->
              ${selectedSubPage && currentSubPage ? this.buildSelectedSubPageContent(campaignName, selectedSubPage, currentSubPage) : ''}
            `}
          </div>
        </div>
      `;
    }

    buildSelectedSubPageContent(campaignName, subPageName, subPage) {
      return `
        <div class="selected-subpage" style="background: var(--paper-light); border-radius: 8px; padding: 1.5rem; border: 2px solid var(--rule);">
          <!-- Sub-page Header -->
          <div class="subpage-header" style="margin-bottom: 1rem; border-bottom: 1px solid var(--rule); padding-bottom: 0.75rem;">
            <div style="display: flex; align-items: center;">
              <h5 class="editable" data-edit-type="generic" data-edit-section="subpage-${campaignName}-${subPageName}-title" 
                  style="margin: 0; color: var(--accent-ink); font-size: 1.2em; flex: 1;">
                📄 ${subPage.title || subPageName}
              </h5>
              ${this.buildEditButton('title')}
            </div>
          </div>
          
          <!-- Sub-page Content -->
          <div style="display: flex; align-items: flex-start;">
            <div class="subpage-content editable" data-edit-type="generic" data-edit-section="subpage-${campaignName}-${subPageName}-content" 
                 style="line-height: 1.6; min-height: 200px; flex: 1;">
              ${subPage.content || '<p>Contenu de la sous-page...</p>'}
            </div>
            ${this.buildEditButton('section')}
          </div>
        </div>
      `;
    }

    buildEditButton(buttonType) {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="edit-btn" type="button" style="background: var(--accent); color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 12px; margin-left: 8px;">✏️</button>`;
    }
    

    sanitizeId(str) {
      return str.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    }
  }

  window.PageBuilder = PageBuilder.getInstance();

})();
// ============================================================================
// JDR-BAB APPLICATION - UTILITIES MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // DEV MODE UTILITIES
  // ========================================
  JdrApp.utils.isDevMode = function() {
    // Simple check - if it's standalone, dev mode is always false
    if (window.STANDALONE_VERSION) return false;
    
    // Use the editor's actual state instead of CSS classes for reliability
    if (JdrApp.modules && JdrApp.modules.editor) {
      return JdrApp.modules.editor.isDevMode;
    }
    
    // Fallback: check body class if editor not available yet
    return document.body.classList.contains('dev-on');
  };

  // ========================================
  // CENTRALIZED EVENT MANAGEMENT
  // ========================================
  JdrApp.utils.events = {
    listeners: new Map(),
    
    // Centralized event registration
    register(type, selector, handler, options = {}) {
      const key = `${type}-${selector || 'window'}-${Date.now()}`;
      const wrapper = (e) => {
        if (!selector) {
          handler(e);
        } else {
          // Gérer les sélecteurs spéciaux comme [class$="-add"]
          if (this.matchesSelector(e.target, selector)) {
            handler(e);
          }
        }
      };
      
      if (selector) {
        document.addEventListener(type, wrapper, options);
      } else {
        window.addEventListener(type, wrapper, options);
      }
      
      this.listeners.set(key, { type, wrapper, options });
      return key;
    },

    // Helper pour matcher les sélecteurs complexes
    matchesSelector(element, selector) {
      // Gérer les sélecteurs d'attributs comme [class$="-add"]
      if (selector.startsWith('[class$="') && selector.endsWith('"]')) {
        const suffix = selector.slice(9, -2); // Extraire "-add" de '[class$="-add"]'
        return element.className && element.className.split(' ').some(cls => cls.endsWith(suffix));
      }
      
      // Gérer les sélecteurs d'attributs comme [class*="something"]
      if (selector.startsWith('[class*="') && selector.endsWith('"]')) {
        const substring = selector.slice(9, -2); // Extraire "something" 
        return element.className && element.className.includes(substring);
      }
      
      // Utiliser la méthode native pour les autres sélecteurs
      try {
        return element.matches(selector) || element.closest(selector);
      } catch (e) {
        // Fallback pour les sélecteurs invalides
        return false;
      }
    },
    
    // Delayed execution manager
    delayed: new Map(),
    timeout(key, fn, delay = 0) {
      if (this.delayed.has(key)) {
        clearTimeout(this.delayed.get(key));
      }
      const id = setTimeout(() => {
        fn();
        this.delayed.delete(key);
      }, delay);
      this.delayed.set(key, id);
    },
    
    // Common event handlers
    onDOMReady(fn) {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', fn);
      } else {
        fn();
      }
    },
    
    onHashChange(fn) {
      window.addEventListener('hashchange', fn);
    },
    
    onRouteChange(fn) {
      this.onHashChange(() => this.timeout('route-change', fn, 0));
      this.onDOMReady(() => this.timeout('dom-ready-route', fn, 0));
    }
  };

  // ========================================
  // DOM UTILITIES LIBRARY
  // ========================================
  JdrApp.utils.dom = {
    // Common selectors
    $(selector) { return document.querySelector(selector); },
    $(selector) { return document.querySelectorAll(selector); },
    
    // Element creation with common patterns
    create(tag, className = '', innerHTML = '', attributes = {}) {
      const el = document.createElement(tag);
      if (className) el.className = className;
      if (innerHTML) el.innerHTML = innerHTML;
      Object.entries(attributes).forEach(([key, value]) => {
        el.setAttribute(key, value);
      });
      return el;
    },
    
    
    // Safe innerHTML replacement
    safeSetHTML(element, html) {
      if (element) {
        element.innerHTML = html;
      }
    },
    
    // Safe text content setting
    safeSetText(element, text) {
      if (element) {
        element.textContent = text;
      }
    },
    
    // Toggle class utility
    toggleClass(element, className, force = null) {
      if (element) {
        if (force !== null) {
          element.classList.toggle(className, force);
        } else {
          element.classList.toggle(className);
        }
      }
    },
    
    // Show/hide utilities
    show(element, display = 'block') {
      if (element) {
        element.style.display = display;
      }
    },
    
    hide(element) {
      if (element) {
        element.style.display = 'none';
      }
    }
  };

  // ========================================
  // DATA UTILITIES
  // ========================================
  JdrApp.utils.data = {
    // Find spell by name across all categories
    findSpell(name) {
      if (!window.SORTS) return null;
      
      for (const category of window.SORTS) {
        const spell = category.sorts.find(s => s.nom === name);
        if (spell) return { spell, category: category.nom };
      }
      return null;
    },
    
    // Find class by name
    findClass(name) {
      if (!window.CLASSES) return null;
      return window.CLASSES.find(c => c.nom === name);
    },
    
    // Find don by name across all categories
    findDon(name) {
      if (!window.DONS) return null;
      
      for (const category of window.DONS) {
        const don = category.dons.find(d => d.nom === name);
        if (don) return { don, category: category.nom };
      }
      return null;
    },
    
    // Get spell category by name
    getSpellCategory(categoryName) {
      if (!window.SORTS) return null;
      return window.SORTS.find(cat => cat.nom === categoryName);
    },
    
    // Get don category by name
    getDonCategory(categoryName) {
      if (!window.DONS) return null;
      return window.DONS.find(cat => cat.nom === categoryName);
    },
    
    // Deep clone object
    deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    },
    
    // Sanitize string for use as identifier
    sanitizeId(str) {
      return str.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    },
    
    // Generate unique ID
    generateId(prefix = 'id') {
      return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    },
    
    // Escape HTML
    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  };

  // ========================================
  // IMAGE UTILITIES
  // ========================================
  
  // Compress image function
  JdrApp.utils.compressImage = function(file, maxWidth = 800, quality = 0.85) {
    return new Promise((resolve, reject) => {
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      img.onload = function() {
        // Calculate new dimensions
        let { width, height } = img;
        
        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }
        
        // Set canvas size
        canvas.width = width;
        canvas.height = height;
        
        // Detect if image has transparency (PNG)
        const isPNG = file.type === 'image/png' || file.name.toLowerCase().endsWith('.png');
        
        if (isPNG) {
          // For PNG, don't compress at all to preserve quality
          resolve(file);
        } else {
          // For JPEG/other formats, use white background
          ctx.fillStyle = '#FFFFFF';
          ctx.fillRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);
          
          canvas.toBlob((blob) => {
            resolve(blob);
          }, 'image/jpeg', quality);
        }
      };
      
      img.onerror = (error) => {
        reject(error);
      };
      
      img.src = URL.createObjectURL(file);
    });
  };

  // Upload to ImageBB function
  JdrApp.utils.uploadToImageBB = function(file) {
    return new Promise((resolve, reject) => {
      // ImageBB API key
      const API_KEY = '06a98f5c0c2dad952e6ab94b03040f36';
      
      const formData = new FormData();
      formData.append('image', file);
      
      fetch(`https://api.imgbb.com/1/upload?key=${API_KEY}`, {
        method: 'POST',
        body: formData
      })
      .then(response => {
        return response.json();
      })
      .then(data => {
        if (data.success) {
          resolve(data.data.url);
        } else {
          throw new Error('Upload failed: ' + (data.error ? data.error.message : 'Unknown error'));
        }
      })
      .catch(error => {
        // Fallback to local storage
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    });
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - IMAGES MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // IMAGES MANAGEMENT MODULE
  // ========================================
  JdrApp.modules.images = {
    // Store for preloaded images
    imageStore: {},
    
    async init() {
      await this.loadImageData();
      this.initImageHandlers();
      
      // Auto-sync monster images on startup to ensure consistency
      setTimeout(() => {
        this.ensureMonsterImageMappings();
      }, 1000);
    },

    // Load image data from JSON file or embedded data
    async loadImageData() {
      try {
        if (window.IMAGES) {
          this.imageStore = window.IMAGES.images || window.IMAGES || {};
          return;
        }
        
        const response = await fetch('./data/images.json');
        if (response.ok) {
          const data = await response.json();
          this.imageStore = data.images || {};
        } else {
          this.imageStore = {};
        }
      } catch (error) {
        this.imageStore = {};
      }
    },

    // Get image URL for a given key
    getImageUrl(illusKey) {
      return this.imageStore[illusKey] || null;
    },

    // Apply image to an illustration element
    applyImage(illusElement, imageUrl) {
      if (!illusElement || !imageUrl) return;

      const img = illusElement.querySelector('img.thumb');
      if (!img) return;

      // Set image source and make it visible
      img.src = this.processImageUrl(imageUrl);
      img.style.display = 'inline-block';
      img.style.opacity = '1'; // Reset opacity after upload
      
      // Show remove button if it exists
      const removeBtn = illusElement.querySelector('.rm');
      if (removeBtn) {
        removeBtn.style.display = 'inline-flex';
      }

    },

    // Process image URL to handle proxying for mobile compatibility
    processImageUrl(originalUrl) {
      // If it's an i.ibb.co URL, use proxy for better mobile compatibility
      if (originalUrl.includes('i.ibb.co') && !originalUrl.includes('images.weserv.nl')) {
        return `https://images.weserv.nl/?url=${encodeURIComponent(originalUrl)}`;
      }
      
      // For local monster paths, encode only the filename to handle French characters properly
      if (originalUrl.startsWith('data/images/Monstres/')) {
        const pathParts = originalUrl.split('/');
        const filename = pathParts[pathParts.length - 1];
        const pathWithoutFilename = pathParts.slice(0, -1).join('/');
        return `${pathWithoutFilename}/${encodeURIComponent(filename)}`;
      }
      
      return originalUrl;
    },

    autoLoadImages() {
      const illusElements = document.querySelectorAll('[data-illus-key]');
      let loadedCount = 0;

      illusElements.forEach(illusElement => {
        const illusKey = illusElement.dataset.illusKey;
        const imageUrl = this.getImageUrl(illusKey);
        
        if (imageUrl) {
          this.applyImage(illusElement, imageUrl);
          loadedCount++;
        }
      });

      return loadedCount;
    },

    // Initialize image upload handlers
    initImageHandlers() {
      // Delegate image upload handling
      document.addEventListener('change', (event) => {
        if (event.target.matches('.illus input[type="file"]')) {
          this.handleImageUpload(event.target);
        }
      });

      // Delegate image removal handling  
      document.addEventListener('click', (event) => {
        if (event.target.matches('.illus .rm')) {
          this.handleImageRemoval(event.target);
        }
      });
    },

    // Handle image upload
    async handleImageUpload(fileInput) {
      const file = fileInput.files[0];
      if (!file) return;

      const illusElement = fileInput.closest('.illus');
      if (!illusElement) return;

      const illusKey = illusElement.dataset.illusKey;
      
      try {
        // Show loading state
        const img = illusElement.querySelector('img.thumb');
        if (img) {
          img.style.opacity = '0.5';
        }

        // Compress and upload image
        const compressedFile = await JdrApp.utils.compressImage(file, 800, 0.8);
        const imageUrl = await JdrApp.utils.uploadToImageBB(compressedFile);
        
        // Apply the uploaded image
        this.applyImage(illusElement, imageUrl);
        
        // Update local store
        this.imageStore[illusKey] = imageUrl;
        
        // Auto-sync to prevent loss of image assignments
        this.autoSyncImages();
        
        
      } catch (error) {
        // Reset loading state
        const img = illusElement.querySelector('img.thumb');
        if (img) {
          img.style.opacity = '1';
        }
        
        alert('Erreur lors du téléchargement de l\'image. Veuillez réessayer.');
      }
      
      // Clear file input
      fileInput.value = '';
    },

    // Handle image removal
    handleImageRemoval(removeBtn) {
      const illusElement = removeBtn.closest('.illus');
      if (!illusElement) return;

      const illusKey = illusElement.dataset.illusKey;
      const img = illusElement.querySelector('img.thumb');
      
      if (img) {
        img.src = '';
        img.style.display = 'none';
      }
      
      removeBtn.style.display = 'none';
      
      // Remove from store
      delete this.imageStore[illusKey];
      
      // Auto-sync to update persistent storage
      this.autoSyncImages();
    },

    // Manually add/update an image
    setImage(illusKey, imageUrl) {
      this.imageStore[illusKey] = imageUrl;
      
      // Apply to any existing elements with this key
      const illusElements = document.querySelectorAll(`[data-illus-key="${illusKey}"]`);
      illusElements.forEach(element => {
        this.applyImage(element, imageUrl);
      });
      
      // Auto-sync to prevent loss
      this.autoSyncImages();
    },

    // Get all current images for export
    getAllImages() {
      return { ...this.imageStore };
    },

    // Import images from external data
    importImages(imageData) {
      if (typeof imageData === 'object' && imageData !== null) {
        Object.assign(this.imageStore, imageData);
        this.autoLoadImages();
      }
    },

    // Auto-sync images to prevent data loss
    autoSyncImages() {
      // Ensure we have monster image mappings for all existing monsters
      this.ensureMonsterImageMappings();
      
      // Trigger auto-save if available
      if (JdrApp.modules.storage && JdrApp.modules.storage.saveChanges) {
        JdrApp.modules.storage.saveChanges(true); // Silent save
      }
    },

    // Ensure all monsters have image mappings in images.json structure
    ensureMonsterImageMappings() {
      if (!window.MONSTRES || !Array.isArray(window.MONSTRES)) {
        return;
      }

      let hasUpdates = false;

      window.MONSTRES.forEach(monster => {
        const imageKey = `monster:${monster.nom}`;
        
        // If monster has no image mapping in store, create one
        if (!this.imageStore[imageKey]) {
          // Check if monster has a valid image path
          if (monster.image && monster.image.trim()) {
            this.imageStore[imageKey] = monster.image;
            hasUpdates = true;
            console.log(`📷 Auto-synced image for monster: ${monster.nom}`);
          }
        }
        
        // Also validate that the image file exists
        this.validateMonsterImagePath(monster);
      });

      if (hasUpdates) {
        console.log('✅ Auto-synced monster image mappings');
      }
    },

    // Validate and fix monster image paths
    validateMonsterImagePath(monster) {
      if (!monster.image || !monster.nom) {
        return false;
      }

      // Extract filename from current path
      const currentPath = monster.image;
      const filename = currentPath.split('/').pop();
      
      // Check if path follows correct format
      const expectedPattern = /^data\/images\/Monstres\/foret\/Monstre_Forêt_\w+\.png$/;
      
      if (!expectedPattern.test(currentPath)) {
        // Try to fix common issues
        let correctedPath = null;
        
        // Map common filename patterns to correct paths
        const filenameMap = {
          'araignee-geante.png': 'Monstre_Forêt_Araignée.png',
          'crabe-des-bois.png': 'Monstre_Forêt_Crab.png',  
          'groink.png': 'Monstre_Forêt_Groink.png',
          'groink-chaman.png': 'Monstre_Forêt_Groink_Chaman.png',
          'guepe-geante.png': 'Monstre_Forêt_GuepeGeante.png',
          'ours-des-bois.png': 'Monstre_Forêt_Ours.png'
        };

        if (filenameMap[filename]) {
          correctedPath = `data/images/Monstres/foret/${filenameMap[filename]}`;
        } else if (!filename.startsWith('Monstre_Forêt_')) {
          // Try to construct path from monster name
          const safeName = monster.nom.replace(/[^a-zA-Z0-9àâäéèêëïîôùûüÿçÀÂÄÉÈÊËÏÎÔÙÛÜŸÇ_]/g, '');
          correctedPath = `data/images/Monstres/foret/Monstre_Forêt_${safeName}.png`;
        }

        if (correctedPath && correctedPath !== currentPath) {
          console.log(`🔧 Auto-correcting image path for ${monster.nom}:`);
          console.log(`   From: ${currentPath}`);
          console.log(`   To: ${correctedPath}`);
          
          // Update monster data
          monster.image = correctedPath;
          
          // Update image mapping
          const imageKey = `monster:${monster.nom}`;
          this.imageStore[imageKey] = correctedPath;
          
          return true;
        }
      }
      
      return false;
    },

    // Force synchronization of all monster data
    forceSyncMonsterImages() {
      
      let syncCount = 0;
      
      if (window.MONSTRES && Array.isArray(window.MONSTRES)) {
        window.MONSTRES.forEach(monster => {
          const corrected = this.validateMonsterImagePath(monster);
          if (corrected) {
            syncCount++;
          }
        });
      }
      
      this.ensureMonsterImageMappings();
      
      
      // Save changes
      if (JdrApp.modules.storage && JdrApp.modules.storage.saveChanges) {
        JdrApp.modules.storage.saveChanges(true);
      }
      
      return syncCount;
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - STORAGE MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // STORAGE MODULE
  // ========================================
  JdrApp.modules.storage = {
    
    init() {
      
      // Clear localStorage on startup - JSON files are always source of truth
      this.clearStorageOnStartup();
      
      // Set up save handlers
      JdrApp.utils.events.register('click', '#saveAndExport', () => this.saveAndExportZip());
      
      // Listen for storage save events
      EventBus.on(Events.STORAGE_SAVE, () => {
        this.saveChanges(true); // Silent save
      });
      
      // Auto-save functionality
      this.setupAutoSave();
    },

    setupAutoSave() {
      // Auto-save disabled - we save immediately on each edit instead
      // Previously: Auto-save every 30 seconds if in dev mode
    },

    clearStorageOnStartup() {
      // Clear all localStorage data on page load - JSON files are source of truth
      localStorage.removeItem('jdr-bab-edits');
      localStorage.removeItem('jdr-bab-static-pages');
      localStorage.removeItem('jdr-bab-last-modified');
    },

    saveChanges(silent = false) {
      try {
        // Force collect all pending edits
        const editedData = JdrApp.modules.editor ? JdrApp.modules.editor.forceCollectAllEdits() : {};
        
        // Data is already saved in memory (window.STATIC_PAGES, window.SORTS, etc.)
        // No localStorage persistence needed - JSON files are source of truth
        
        if (!silent) {
          this.showNotification('💾 Modifications sauvegardées en mémoire', 'success');
        }
        
      } catch (error) {
        console.error('❌ Failed to save changes:', error);
        if (!silent) {
          this.showNotification('❌ Erreur lors de la sauvegarde', 'error');
        }
      }
    },

    async saveAndExportZip() {
      try {
        this.showNotification('📦 Création de l\'archive ZIP...', 'info');
        
        // Force collect all pending edits
        JdrApp.modules.editor.forceCollectAllEdits();
        
        // Check if JSZip is available
        if (typeof JSZip === 'undefined') {
          await this.loadJSZip();
        }
        
        const zip = new JSZip();
        
        // Add main HTML file
        const mainHTML = await this.getMainHTML();
        zip.file('index.html', mainHTML);
        
        // Add CSS files
        const cssFiles = ['theme.css', 'utilities.css', 'components.css', 'layout.css', 'editor.css'];
        for (const cssFile of cssFiles) {
          const cssContent = await this.fetchFileContent(`css/${cssFile}`);
          if (cssContent) {
            zip.file(`css/${cssFile}`, cssContent);
          }
        }
        
        // Add JS files
        const jsFiles = ['core.js', 'utils.js', 'router.js', 'renderer.js', 'editor.js', 'storage.js', 'ui.js'];
        for (const jsFile of jsFiles) {
          const jsContent = await this.fetchFileContent(`js/${jsFile}`);
          if (jsContent) {
            zip.file(`js/${jsFile}`, jsContent);
          }
        }
        
        // Add modules
        const moduleFiles = ['images.js'];
        for (const moduleFile of moduleFiles) {
          const moduleContent = await this.fetchFileContent(`js/modules/${moduleFile}`);
          if (moduleContent) {
            zip.file(`js/modules/${moduleFile}`, moduleContent);
          }
        }
        
        // Add data files with current edits
        zip.file('data/sorts.json', JSON.stringify(window.SORTS, null, 2));
        zip.file('data/classes.json', JSON.stringify(window.CLASSES, null, 2));
        zip.file('data/dons.json', JSON.stringify(window.DONS, null, 2));
        zip.file('data/objets.json', JSON.stringify(window.OBJETS, null, 2));
        
        // Add monsters data with current edits
        if (window.MONSTRES) {
          zip.file('data/monstres.json', JSON.stringify(window.MONSTRES, null, 2));
        }
        
        // Add tables tresors data with current edits  
        if (window.TABLES_TRESORS) {
          zip.file('data/tables-tresors.json', JSON.stringify(window.TABLES_TRESORS, null, 2));
        }
        
        // Add collections data with current edits
        if (window.COLLECTIONS) {
          zip.file('data/collections.json', JSON.stringify(window.COLLECTIONS, null, 2));
        }
        
        // Add TOC structure with new pages
        if (window.TOC_STRUCTURE) {
          zip.file('data/toc-structure.json', JSON.stringify(window.TOC_STRUCTURE, null, 2));
        }
        
        // Add ContentTypes configuration (includes availableTags modifications)
        if (window.ContentTypes) {
          const updatedContentTypesJS = this.generateContentTypesJS(window.ContentTypes);
          zip.file('js/config/contentTypes.js', updatedContentTypesJS);
        }
        
        // Add static pages config and data
        if (window.STATIC_PAGES_CONFIG) {
          zip.file('data/static-pages-config.json', JSON.stringify(window.STATIC_PAGES_CONFIG, null, 2));
        }
        
        if (window.STATIC_PAGES) {
          for (const [pageId, pageData] of Object.entries(window.STATIC_PAGES)) {
            zip.file(`data/${pageId}.json`, JSON.stringify(pageData, null, 2));
          }
        }
        
        // Note: All static pages are now handled via window.STATIC_PAGES above
        
        // Add current images (including newly uploaded ones)
        if (JdrApp.modules.images && JdrApp.modules.images.getAllImages) {
          const currentImages = JdrApp.modules.images.getAllImages();
          const imagesData = {
            images: currentImages,
            meta: {
              total_images: Object.keys(currentImages).length,
              exported_date: new Date().toISOString().slice(0, 10),
              note: "Ces images incluent les nouvelles images uploadées"
            }
          };
          zip.file('data/images.json', JSON.stringify(imagesData, null, 2));
        }
        
        // Add page descriptions
        if (window.MONSTRES_PAGE_DESC) {
          zip.file('data/monstres-page-desc.json', JSON.stringify(window.MONSTRES_PAGE_DESC, null, 2));
        }
        
        if (window.TABLES_TRESORS_PAGE_DESC) {
          zip.file('data/tables-tresors-page-desc.json', JSON.stringify(window.TABLES_TRESORS_PAGE_DESC, null, 2));
        }
        
        // Add custom page descriptions (collections, etc.)
        if (JdrApp.data.customPageDescriptions) {
          zip.file('data/custom-page-descriptions.json', JSON.stringify(JdrApp.data.customPageDescriptions, null, 2));
        }
        
        // Add package.json and other config files
        const configFiles = ['package.json'];
        for (const configFile of configFiles) {
          const configContent = await this.fetchFileContent(configFile);
          if (configContent) {
            zip.file(configFile, configContent);
          }
        }
        
        // Generate and download ZIP
        const zipBlob = await zip.generateAsync({type: 'blob'});
        const timestamp = new Date().toISOString().slice(0, 16).replace(/[:-]/g, '');
        this.downloadFile(`JdrBab-${timestamp}.zip`, zipBlob, 'application/zip');
        
        this.showNotification('📦 Archive ZIP créée et téléchargée!', 'success');
        
      } catch (error) {
        console.error('❌ Failed to create ZIP:', error);
        this.showNotification('❌ Erreur lors de la création du ZIP', 'error');
      }
    },

    generateContentTypesJS(contentTypes) {
      // Generate the updated contentTypes.js file with current availableTags
      const availableTags = contentTypes.objet?.filterConfig?.availableTags || [];
      const defaultVisibleTags = contentTypes.objet?.filterConfig?.defaultVisibleTags || [];
      
      // Get monster tags configuration
      const monsterAvailableTags = contentTypes.monster?.filterConfig?.availableTags || [];
      const monsterDefaultVisibleTags = contentTypes.monster?.filterConfig?.defaultVisibleTags || [];
      
      return `// ============================================================================
// JDR-BAB APPLICATION - CONTENT TYPES CONFIGURATION
// ============================================================================

(() => {
  "use strict";

  window.ContentTypes = {
    spell: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        element: { type: 'select', label: 'Élément', required: true, options: ['Feu', 'Eau', 'Terre', 'Air', 'Lumière', 'Nuit', 'Divin', 'Maléfique'] },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'Prérequis', required: true },
        portee: { type: 'richtext', label: 'Portée', required: true },
        tempsIncantation: { type: 'richtext', label: "Temps d'incantation", required: true },
        coutMana: { type: 'richtext', label: 'Coût mana', required: true },
        resistance: { type: 'richtext', label: 'Résistance', required: true },
        effetNormal: { type: 'richtext', label: 'Effet normal', required: true },
        effetCritique: { type: 'richtext', label: 'Effet critique', required: false }
      },
      editMapping: {
        'spell-name': 'nom',
        'spell-element': 'element',
        'spell-description': 'description',
        'spell-prerequis': 'prerequis',
        'spell-portee': 'portee',
        'spell-mana': 'coutMana',
        'spell-temps-incantation': 'tempsIncantation',
        'spell-resistance': 'resistance',
        'spell-effect-normal': 'effetNormal',
        'spell-effect-critical': 'effetCritique'
      },
      identifiers: {
        name: 'nom',
        category: 'sorts'
      },
      template: 'spell-card',
      container: 'sorts',
      dataKey: 'SORTS',
      icons: { 
        category: '🔮', 
        item: '✨',
        add: '➕',
        delete: '🗑️'
      },
      defaultValues: {
        nom: "Nouveau Sort",
        element: "Feu",
        description: "Lance une boule de Feu sur un adversaire.",
        prerequis: "📋 <strong>Prérequis:</strong> Niveau 1",
        portee: "🎯 <strong>Portée:</strong> 20m",
        tempsIncantation: "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        coutMana: "🔵 <strong>Coût mana:</strong> 3",
        resistance: "<strong>Sans effet si:</strong> Esquive.",
        effetNormal: "<strong>Effet:</strong> Inflige 5 dégats de <span style='color: #e25822; font-weight: bold;'>Feu</span> à la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        effetCritique: "<strong>Coup Critique:&nbsp;</strong>&nbsp;Double les dégâts et enflamme la cible."
      }
    },

    don: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'Prérequis', required: true },
        cout: { type: 'richtext', label: 'Coût', required: true }
      },
      editMapping: {
        'don-name': 'nom',
        'don-description': 'description',
        'don-prerequis': 'prerequis',
        'don-cout': 'cout'
      },
      identifiers: {
        name: 'nom',
        category: 'dons'
      },
      template: 'don-card',
      container: 'dons',
      dataKey: 'DONS',
      icons: { 
        category: '🎖️', 
        item: '🏆',
        add: '➕',
        delete: '🗑️'
      },
      defaultValues: {
        nom: "Nouveau Don",
        description: "Description du don.",
        prerequis: "Aucun prérequis",
        cout: "1 point de don"
      }
    },

    class: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        resume: { type: 'textarea', label: 'Résumé', required: true },
        capacites: { type: 'list', label: 'Capacités', required: true }
      },
      editMapping: {
        'class-name': 'nom',
        'class-resume': 'resume',
        'class-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: null
      },
      template: 'class-page',
      container: 'classes',
      dataKey: 'CLASSES',
      icons: { 
        category: '⚔️', 
        item: '🛡️',
        add: '➕',
        delete: '🗑️'
      }
    },

    subclass: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        base: { type: 'stats', label: 'Statistiques de base', required: true },
        progression: { type: 'richtext', label: 'Progression', required: true },
        capacites: { type: 'list', label: 'Capacités', required: true }
      },
      editMapping: {
        'subclass-name': 'nom',
        'subclass-description': 'description',
        'subclass-stats': 'base',
        'subclass-progression': 'progression',
        'subclass-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: 'sousClasses',
        parent: 'class'
      },
      template: 'subclass-card',
      icons: { 
        item: '⚡',
        add: '➕',
        delete: '🗑️'
      },
      defaultValues: {
        nom: "Nouvelle sous-classe",
        description: "Description de la sous-classe",
        base: {
          Force: 3,
          Agilité: 3,
          Endurance: 3,
          Intelligence: 3,
          Volonté: 3,
          Chance: 3
        },
        progression: "<strong>📈 Progression par niveau:</strong> +1 Force 💪, +1 Agilité 🏃",
        capacites: [
          "<em>Capacité unique</em>: Description de la capacité spéciale de cette sous-classe."
        ]
      }
    },

    objet: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        numero: { type: 'number', label: 'Numéro', required: true },
        image: { type: 'text', label: 'Image', required: false },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        effet: { type: 'richtext', label: 'Effet', required: true },
        prix: { type: 'richtext', label: 'Prix', required: true },
        poids: { type: 'richtext', label: 'Poids', required: true }
      },
      editMapping: {
        'objet-name': 'nom',
        'objet-numero': 'numero',
        'objet-image': 'image',
        'objet-description': 'description',
        'objet-tags': 'tags',
        'objet-effet': 'effet',
        'objet-prix': 'prix',
        'objet-poids': 'poids'
      },
      identifiers: {
        name: 'nom',
        category: 'objets'
      },
      template: 'objet-card',
      container: 'objets',
      dataKey: 'OBJETS',
      pageType: 'single', // Page unique avec filtres
      icons: { 
        category: '📦', 
        item: '🎒',
        add: '➕',
        delete: '🗑️'
      },
      // Configuration des filtres disponibles (MISE À JOUR AUTOMATIQUE)
      filterConfig: {
        availableTags: ${JSON.stringify(availableTags, null, 10)},
        defaultVisibleTags: ${JSON.stringify(defaultVisibleTags, null, 10)} // Filtres affichés par défaut
      },
      defaultValues: {
        nom: "Nouvel Objet",
        numero: 1,
        image: "",
        description: "Description de l'objet.",
        tags: ["Nouvel objet"],
        effet: "<strong>Effet:</strong> Description de l'effet de l'objet.",
        prix: "🔷 <strong>Prix:</strong> 10",
        poids: "⚖️ <strong>Poids:</strong> 1"
      }
    },

    monster: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        image: { type: 'text', label: 'Image', required: false },
        element: { 
          type: 'select', 
          label: "Élément d'affiliation", 
          required: true,
          options: [
            { value: 'Feu', label: '🔥 Feu' },
            { value: 'Eau', label: '💧 Eau' },
            { value: 'Terre', label: '🤎 Terre' },
            { value: 'Air', label: '🟢 Air' },
            { value: 'Lumiere', label: '☀️ Lumière' },
            { value: 'Nuit', label: '⚫ Nuit' },
            { value: 'Divin', label: '⚪ Divin' },
            { value: 'Malefique', label: '🟣 Maléfique' }
          ]
        },
        pointsDeVie: { type: 'number', label: 'Points de vie', required: true },
        armurePhysique: { type: 'number', label: 'Armure physique', required: true },
        esquive: { type: 'number', label: 'Esquive', required: true },
        coupCritique: { type: 'number', label: 'Coup critique', required: true },
        coupCritiqueSorts: { type: 'number', label: 'Critique sorts', required: true },
        resistanceAlterations: { type: 'number', label: 'Résistance altérations', required: true },
        armureFeu: { type: 'number', label: 'Armure Feu', required: true },
        armureEau: { type: 'number', label: 'Armure Eau', required: true },
        armureTerre: { type: 'number', label: 'Armure Terre', required: true },
        armureAir: { type: 'number', label: 'Armure Air', required: true },
        armureLumiere: { type: 'number', label: 'Armure Lumière', required: true },
        armureObscurite: { type: 'number', label: 'Armure Obscurité', required: true },
        armureDivin: { type: 'number', label: 'Armure Divin', required: true },
        armureMalefique: { type: 'number', label: 'Armure Maléfique', required: true },
        abilites: { type: 'richtext', label: 'Abilités', required: false },
        butin: { type: 'richtext', label: 'Butin', required: false }
      },
      editMapping: {
        'monster-name': 'nom',
        'monster-tags': 'tags',
        'monster-image': 'image',
        'monster-element': 'element',
        // Stats principaux
        'monster-pointsdevie': 'pointsDeVie',
        'monster-armurephysique': 'armurePhysique', 
        'monster-esquive': 'esquive',
        'monster-coupcritique': 'coupCritique',
        'monster-coupcritiquesorts': 'coupCritiqueSorts',
        'monster-resistancealterations': 'resistanceAlterations',
        // Armures élémentaires
        'monster-armurefeu': 'armureFeu',
        'monster-armureeau': 'armureEau',
        'monster-armureterre': 'armureTerre',
        'monster-armureair': 'armureAir',
        'monster-armurelumiere': 'armureLumiere',
        'monster-armureobscurite': 'armureObscurite',
        'monster-armuredivin': 'armureDivin',
        'monster-armuremalefique': 'armureMalefique',
        // Contenu narratif
        'monster-abilites': 'abilites',
        'monster-butin': 'butin'
      },
      identifiers: {
        name: 'nom',
        category: 'monstres'
      },
      template: 'monster-card',
      container: 'monstres',
      dataKey: 'MONSTRES',
      pageType: 'single',
      filterMode: 'AND',
      icons: { 
        category: '🐲', 
        item: '👾',
        add: '➕',
        delete: '🗑️'
      },
      filterConfig: {
        availableTags: ${JSON.stringify(monsterAvailableTags, null, 10)},
        defaultVisibleTags: ${JSON.stringify(monsterDefaultVisibleTags, null, 10)}
      },
      defaultValues: {
        nom: "Nouveau Monstre",
        tags: ["Forêt"],
        image: "",
        element: "Feu",
        pointsDeVie: 20,
        armurePhysique: 2,
        esquive: 5,
        coupCritique: 10,
        coupCritiqueSorts: 8,
        resistanceAlterations: 3,
        armureFeu: 0,
        armureEau: 0,
        armureTerre: 0,
        armureAir: 0,
        armureLumiere: 0,
        armureObscurite: 0,
        armureDivin: 0,
        armureMalefique: 0,
        abilites: "<strong>Attaque basique:</strong> Inflige 5 dégâts physiques.",
        butin: "<strong>Butin:</strong> 10-50 pièces d'or."
      }
    },

    tableTresor: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        fourchettes: { type: 'list', label: 'Fourchettes', required: true }
      },
      editMapping: {
        'table-tresor-name': 'nom',
        'table-tresor-description': 'description',
        'table-tresor-tags': 'tags'
      },
      identifiers: {
        name: 'nom',
        category: 'tables'
      },
      template: 'table-tresor-card',
      container: 'tables-tresors',
      dataKey: 'TABLES_TRESORS',
      pageType: 'single',
      filterMode: 'OR',
      icons: { 
        category: '💎', 
        item: '📦',
        add: '➕',
        delete: '🗑️'
      },
      filterConfig: {
        // availableTags managed dynamically via window.TABLES_TRESORS._metadata.availableTags
        defaultVisibleTags: [
          "Forêt",
          "Boss"
        ]
      },
      defaultValues: {
        nom: "Nouvelle Table de Trésor",
        description: "Table de butin pour une situation spécifique.",
        tags: ["Forêt"],
        fourchettes: [
          {
            min: 1,
            max: 10,
            objet: {
              type: "reference",
              numero: 1,
              nom: "Objet par défaut"
            }
          }
        ]
      }
    },

    staticPage: {
      fields: {
        title: { type: 'text', label: 'Titre', required: true },
        sections: { type: 'sections', label: 'Sections', required: true }
      },
      template: 'static-page',
      icons: { 
        category: '📄', 
        item: '📝'
      }
    }
  };

  window.StatIcons = {
    'Force': '💪',
    'Agilité': '🏃',
    'Endurance': '🛡️',
    'Intelligence': '🧠',
    'Volonté': '⚡',
    'Chance': '🍀'
  };

  window.ElementColors = {
    'Feu': { color: '#ff6b35', weight: 'bold' },
    'Eau': { color: '#4682b4', weight: 'bold' },
    'Terre': { color: '#8b4513', weight: 'bold' },
    'Air': { color: '#22c55e', weight: 'bold' },
    'Lumière': { color: '#ffd700', weight: 'bold' },
    'Nuit': { color: '#1a1a1a', weight: 'bold' },
    'Divin': { color: '#f5f5f5', weight: 'bold', background: 'rgba(100, 100, 100, 0.3)', padding: '2px 4px', borderRadius: '3px' },
    'Maléfique': { color: '#8b5cf6', weight: 'bold' }
  };

  window.ElementIcons = {
    'Feu': '🔥',
    'Eau': '💧',
    'Terre': '🤎',
    'Air': '🟢',
    'Lumière': '☀️',
    'Nuit': '⚫',
    'Divin': '⚪',
    'Maléfique': '🟣'
  };

})();`;
    },

    async loadJSZip() {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    },

    async fetchFileContent(filePath) {
      try {
        const response = await fetch(filePath);
        if (response.ok) {
          return await response.text();
        }
        // Could not fetch file
        return null;
      } catch (error) {
        // Error fetching file
        return null;
      }
    },

    async getMainHTML() {
      // Get the current index.html content or reconstruct it
      try {
        const response = await fetch('index.html');
        if (response.ok) {
          return await response.text();
        }
      } catch (error) {
        // Could not fetch index.html, generating from current state
      }
      
      // Fallback: generate HTML from current document state
      return `<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta name="referrer" content="no-referrer-when-downgrade">
<title>JDR‑BAB — Livret de règles</title>
<meta content="Livret web multipages des règles JDR‑BAB, thème parchemin, illustrations par catégorie/classe/sous‑classe, export HTML autonome." name="description">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&amp;family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600&amp;display=swap" rel="stylesheet">

<!-- CSS Modulaire -->
<link rel="stylesheet" href="css/theme.css">
<link rel="stylesheet" href="css/utilities.css">
<link rel="stylesheet" href="css/components.css">
<link rel="stylesheet" href="css/layout.css">
<link rel="stylesheet" href="css/editor.css">
</head>
<body class="dev-off" style="">

<!-- Le contenu HTML complet sera injecté ici par le JavaScript -->
<div id="app-loading">Chargement...</div>

<!-- JavaScript Modulaire -->
</body>
</html>`;
    },


    downloadJSON(filename, data) {
      const json = JSON.stringify(data, null, 2);
      this.downloadFile(filename, json, 'application/json');
    },

    downloadFile(filename, content, mimeType = 'text/html') {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.style.display = 'none';
      
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      URL.revokeObjectURL(url);
    },

    showNotification(message, type = 'info') {
      // Simple notification system
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${type === 'success' ? '#10B981' : type === 'error' ? '#EF4444' : '#3B82F6'};
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        font-weight: 500;
        z-index: 10000;
        animation: slideIn 0.3s ease;
      `;
      
      // Add animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      notification.textContent = message;
      document.body.appendChild(notification);
      
      // Auto-remove after 3 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    },

    // Load edits from localStorage on startup
    loadStoredEdits() {
      try {
        const storedEdits = localStorage.getItem('jdr-bab-edits');
        
        if (storedEdits && JdrApp.modules.editor) {
          JdrApp.modules.editor.editedData = JSON.parse(storedEdits);
        }
        
        // Load stored static pages data (includes dynamically created sections)
        const storedStaticPages = localStorage.getItem('jdr-bab-static-pages');
        if (storedStaticPages) {
          const staticPagesData = JSON.parse(storedStaticPages);
          
          // Merge with existing STATIC_PAGES data
          if (window.STATIC_PAGES) {
            Object.assign(window.STATIC_PAGES, staticPagesData);
          } else {
            window.STATIC_PAGES = staticPagesData;
          }
          
          console.log('Restored static pages data from localStorage:', Object.keys(staticPagesData));
        }
        
        // Ne plus charger jdr-bab-data - laisser les JSON être la source de vérité
        
      } catch (error) {
        console.warn('Failed to load stored edits:', error);
      }
    },

    // Handle ZIP file import
    async handleZipImport(event) {
      const file = event.target.files[0];
      if (!file || file.type !== 'application/zip') {
        this.showNotification('❌ Veuillez sélectionner un fichier ZIP', 'error');
        return;
      }

      try {
        this.showNotification('📥 Import en cours...', 'info');

        // Check if JSZip is available
        if (typeof JSZip === 'undefined') {
          await this.loadJSZip();
        }

        const zip = new JSZip();
        const contents = await zip.loadAsync(file);

        // Import data files
        const dataFiles = ['sorts.json', 'classes.json', 'dons.json', 'objets.json', 'monstres.json'];
        for (const dataFile of dataFiles) {
          const zipFile = contents.file(`data/${dataFile}`);
          if (zipFile) {
            const content = await zipFile.async('text');
            const data = JSON.parse(content);
            
            if (dataFile === 'sorts.json') {
              window.SORTS = data;
              JdrApp.data.SORTS = data;
            } else if (dataFile === 'classes.json') {
              window.CLASSES = data;
              JdrApp.data.CLASSES = data;
            } else if (dataFile === 'dons.json') {
              window.DONS = data;
              JdrApp.data.DONS = data;
            } else if (dataFile === 'objets.json') {
              window.OBJETS = data;
              JdrApp.data.OBJETS = data;
            } else if (dataFile === 'monstres.json') {
              window.MONSTRES = data;
              JdrApp.data.MONSTRES = data;
            } else if (dataFile === 'tables-tresors.json') {
              window.TABLES_TRESORS = data;
              JdrApp.data.TABLES_TRESORS = data;
            } else if (dataFile === 'collections.json') {
              window.COLLECTIONS = data;
              JdrApp.data.COLLECTIONS = data;
            } else if (dataFile === 'toc-structure.json') {
              window.TOC_STRUCTURE = data;
              JdrApp.data.TOC_STRUCTURE = data;
            }
          }
        }

        // Import static pages config
        const configFile = contents.file('data/static-pages-config.json');
        if (configFile) {
          const configContent = await configFile.async('text');
          window.STATIC_PAGES_CONFIG = JSON.parse(configContent);
          JdrApp.data.STATIC_PAGES_CONFIG = JSON.parse(configContent);
        }

        // Import static pages data
        if (window.STATIC_PAGES_CONFIG && window.STATIC_PAGES_CONFIG.pages) {
          window.STATIC_PAGES = {};
          JdrApp.data.STATIC_PAGES = {};
          for (const pageConfig of window.STATIC_PAGES_CONFIG.pages) {
            if (pageConfig.active) {
              const pageFile = contents.file(`data/${pageConfig.file}`);
              if (pageFile) {
                const pageContent = await pageFile.async('text');
                const pageData = JSON.parse(pageContent);
                window.STATIC_PAGES[pageConfig.id] = pageData;
                JdrApp.data.STATIC_PAGES[pageConfig.id] = pageData;
              }
            }
          }
        }

        // Import images
        const imagesFile = contents.file('data/images.json');
        if (imagesFile && JdrApp.modules.images && JdrApp.modules.images.importImages) {
          const imagesContent = await imagesFile.async('text');
          const imagesData = JSON.parse(imagesContent);
          if (imagesData.images) {
            JdrApp.modules.images.importImages(imagesData.images);
          }
        }

        // Import custom page descriptions
        const customDescFile = contents.file('data/custom-page-descriptions.json');
        if (customDescFile) {
          const customDescContent = await customDescFile.async('text');
          const customDescData = JSON.parse(customDescContent);
          window.CUSTOM_PAGE_DESCRIPTIONS = customDescData;
          JdrApp.data.customPageDescriptions = { ...JdrApp.data.customPageDescriptions, ...customDescData };
        }

        // Save imported data to localStorage
        this.saveChanges(true);

        this.showNotification('✅ Import réussi! Rechargement...', 'success');

        // Reload page to show imported data
        setTimeout(() => {
          window.location.reload();
        }, 1000);

      } catch (error) {
        this.showNotification('❌ Erreur lors de l\'import', 'error');
      }

      // Reset file input
      event.target.value = '';
    },


  };

})();
// ============================================================================
// JDR-BAB APPLICATION - ROUTER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // ROUTING SYSTEM
  // ========================================
  JdrApp.modules.router = {
    currentRoute: '',
    
    init() {
      
      // Set up route change listeners
      JdrApp.utils.events.onHashChange(() => this.parseRoute());
      JdrApp.utils.events.onDOMReady(() => this.parseRoute());
      
      // Listen for dev mode changes to refresh objects page
      if (window.EventBus && window.Events) {
        EventBus.on(Events.EDITOR_TOGGLE, (payload) => {
          const currentHash = window.location.hash;
          // Refresh objects page specifically when dev mode changes
          if (currentHash === '#/objets') {
            setTimeout(() => {
              // Force a complete refresh by setting the flag
              this._forceObjectsRefresh = true;
              this.renderObjectsPage();
            }, 150);
          }
        });
      }
    },
    
    parseRoute() {
      const hash = location.hash.replace('#/', '');
      const page = hash || 'creation';
      const exists = JdrApp.utils.dom.$(`article[data-page="${page}"]`);
      
      
      this.currentRoute = page;
      
      // Handle dynamic category routing
      // Fix: check if exists is falsy OR empty NodeList
      const shouldUseRouter = !exists || (exists.length === 0);
      
      if (shouldUseRouter) {
        if (this.handleDynamicRoute(page)) {
          return; // Route was handled dynamically
        }
      }
      
      this.show(exists ? page : 'creation');
    },

    handleDynamicRoute(page) {
      // Handle sorts-* routes
      if (page.startsWith('sorts-')) {
        return this.renderDynamicCategory('sorts', 'spell', page);
      }
      
      // Handle dons-* routes  
      if (page.startsWith('dons-')) {
        return this.renderDynamicCategory('dons', 'don', page);
      }
      
      // Handle single objets page (objects now use unified page with tag filtering)
      if (page === 'objets') {
        return this.renderObjectsPage();
      }
      
      // Handle collections-objets page
      if (page === 'collections-objets') {
        return this.renderCollectionsObjectsPage();
      }
      
      // Handle single monstres page (monsters now use unified page with tag filtering)
      if (page === 'monstres') {
        return this.renderMonstersPage();
      }
      
      // Handle single tables-tresors page  
      if (page === 'tables-tresors') {
        return this.renderTablesTresorsPage();
      }
      
      // Handle feuille-personnage page
      if (page === 'feuille-personnage') {
        return this.renderFeuillePersonnagePage();
      }
      
      return false; // Route not handled
    },

    renderDynamicCategory(prefix, type, page) {
      const categoryId = page.replace(`${prefix}-`, '');
      const dataKey = prefix.toUpperCase();
      const dataSource = window[dataKey];
      
      if (!dataSource) return false;
      
      const category = dataSource.find(cat => 
        JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
      );
      
      if (category) {
        // Render the category page dynamically
        JdrApp.modules.renderer.renderCategoryPage(type, category);
        
        // Update active states
        this.updateActiveStates(page);
        
        return true;
      }
      
      return false;
    },

    updateActiveStates(page) {
      // Remove active class from all articles and links
      document.querySelectorAll('article').forEach(a => a.classList.remove('active'));
      document.querySelectorAll('.toc a').forEach(a => a.classList.remove('active'));
      
      // Set active link in TOC
      const activeLink = document.querySelector(`a[href="#/${page}"]`);
      if (activeLink) {
        activeLink.classList.add('active');
        
        // Expand parent category if needed
        const category = activeLink.closest('.toc-category');
        if (category) {
          category.classList.remove('collapsed');
        }
      }
    },
    
    show(page) {
      document.querySelectorAll('article').forEach(a => a.classList.remove('active'));
      const target = document.querySelector(`article[data-page="${page}"]`);
      if (target) {
        target.classList.add('active');
      }
      
      document.querySelectorAll('.toc a').forEach(a => a.classList.remove('active'));
      const activeLink = document.querySelector(`a[href="#/${page}"]`);
      if (activeLink) activeLink.classList.add('active');

      
      // Ensure edit buttons state is properly applied after navigation
      if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
        setTimeout(() => {
          if (JdrApp.modules.editor.isDevMode) {
            JdrApp.modules.editor.forceShowAllEditButtons();
          } else {
            JdrApp.modules.editor.forceHideAllEditButtons();
          }
        }, 50);
      }
    },
    
    navigate(route) {
      location.hash = `#/${route}`;
      // Force parseRoute() in case hashchange event doesn't fire
      setTimeout(() => {
        this.parseRoute();
      }, 10);
    },
    
    getCurrentRoute() {
      return this.currentRoute;
    },
    
    // Generate table of contents based on hierarchical structure
    generateTOC() {
      const tocContainer = document.querySelector('#toc');
      if (!tocContainer) return;

      if (!window.TOC_STRUCTURE) {
        console.warn('TOC_STRUCTURE not loaded, falling back to basic TOC');
        this.generateBasicTOC();
        return;
      }

      const tocHTML = `
        <h4>Sommaire</h4>
        ${window.TOC_STRUCTURE.sections
          .filter(section => !section.requiresMJ || window.JdrApp.state.isMJ)
          .map(section => this.generateTOCSection(section)).join('')}
        <div class="mj-toggle-container" style="margin: 1rem 0; text-align: center; border-top: 2px solid var(--rule); padding-top: 1rem;">
          <button id="mjToggleBtn" class="btn-base btn-small" style="background: var(--bronze); color: white; border-color: var(--bronze); position: relative;">
            🎭 Maître de jeu
            <span id="mjStatusIndicator" style="position: absolute; top: -5px; right: -5px; width: 12px; height: 12px; border-radius: 50%; background: #dc2626; border: 2px solid white; display: none;"></span>
          </button>
        </div>
      `;
      
      tocContainer.innerHTML = tocHTML;
      
      // Attacher les événements directement aux éléments après création
      this.attachFoldoutEvents();
      
      // Initialiser les hauteurs dynamiques pour toutes les sections ouvertes
      this.initializeDynamicHeights();
      
      // Ajouter l'event listener pour le bouton MJ
      this.setupMJToggle();
    },

    initializeDynamicHeights() {
      // Calculer et appliquer les hauteurs dynamiques pour toutes les sections non-collapsées
      document.querySelectorAll('.toc-section:not(.collapsed) .toc-section-content').forEach(content => {
        const childCount = content.querySelectorAll('a, .toc-category').length;
        const itemHeight = 50; // Hauteur approximative par élément
        const baseHeight = 100; // Hauteur de base pour le padding
        const dynamicHeight = Math.max(500, (childCount * itemHeight) + baseHeight);
        
        content.style.maxHeight = `${dynamicHeight}px`;
      });
    },

    setupMJToggle() {
      const mjBtn = document.getElementById('mjToggleBtn');
      if (!mjBtn) return;

      // Initialize visual state based on current MJ status
      this.updateMJButtonVisual();
      this.updateMJBodyClass();

      const handleMJToggle = () => {
        if (window.JdrApp.state.isMJ) {
          // Déjà en mode MJ, désactiver
          window.JdrApp.state.isMJ = false;
          this.updateMJButtonVisual();
          this.updateMJBodyClass();
          this.generateTOC(); // Régénérer le TOC pour cacher les sections MJ
          
          // Refresh objects display if currently on objects page
          this.refreshObjectsPageIfActive();
        } else {
          // Demander confirmation avant d'activer le mode MJ
          this.showMJConfirmation(() => {
            window.JdrApp.state.isMJ = true;
            this.updateMJButtonVisual();
            this.updateMJBodyClass();
            this.generateTOC(); // Régénérer le TOC pour afficher les sections MJ
            
            // Refresh objects display if currently on objects page
            this.refreshObjectsPageIfActive();
          });
        }
      };

      // Ajouter support tactile pour mobile
      mjBtn.addEventListener('click', handleMJToggle);
      mjBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleMJToggle();
      });
    },

    attachFoldoutEvents() {
      // Attacher les événements directement aux headers de section
      document.querySelectorAll('.toc-section-header').forEach(header => {
        header.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const section = header.closest('.toc-section');
          if (section) {
            const wasCollapsed = section.classList.contains('collapsed');
            section.classList.toggle('collapsed');
            const isCollapsed = section.classList.contains('collapsed');
            
            const toggle = section.querySelector('.toc-section-toggle');
            if (toggle) {
              toggle.textContent = isCollapsed ? '▶' : '▼';
            }
            
            const content = section.querySelector('.toc-section-content');
            if (content) {
              // Force les styles directement en JavaScript pour compatibilité standalone
              if (isCollapsed) {
                content.style.maxHeight = '0px';
                content.style.opacity = '0';
                content.style.paddingTop = '0';
                content.style.paddingBottom = '0';
                content.style.overflow = 'hidden';
              } else {
                // Calculer dynamiquement la hauteur nécessaire en fonction du contenu
                const childCount = content.querySelectorAll('a, .toc-category').length;
                const itemHeight = 50; // Hauteur approximative par élément (incluant padding et marge)
                const baseHeight = 100; // Hauteur de base pour le padding
                const dynamicHeight = Math.max(500, (childCount * itemHeight) + baseHeight);
                
                content.style.maxHeight = `${dynamicHeight}px`;
                content.style.opacity = '1';
                content.style.paddingTop = '';
                content.style.paddingBottom = '';
                content.style.overflow = 'visible';
              }
            }
          }
        });
      });

      // Attacher les événements aux liens de catégorie
      document.querySelectorAll('.toc-category > a').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const category = link.closest('.toc-category');
          if (category) {
            category.classList.toggle('collapsed');
          }
        });
      });

      // Attacher les événements aux liens de navigation normaux
      document.querySelectorAll('.toc a:not(.toc-category > a)').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const route = link.getAttribute('data-route');
          if (route) {
            // Special handling for objects page - force refresh when navigating to it
            if (route === 'objets') {
              // Set a flag to force refresh objects page after navigation
              JdrApp.modules.router._forceObjectsRefresh = true;
            }
            JdrApp.modules.router.navigate(route);
          }
        });
      });
    },

    updateMJButtonVisual() {
      const mjBtn = document.getElementById('mjToggleBtn');
      const mjIndicator = document.getElementById('mjStatusIndicator');
      
      if (!mjBtn) return;
      
      if (window.JdrApp.state.isMJ) {
        // Mode MJ activé - bouton doré avec indicateur vert
        mjBtn.style.background = 'var(--gold)';
        mjBtn.style.borderColor = 'var(--gold)';
        mjBtn.innerHTML = '🎭 Mode MJ activé <span id="mjStatusIndicator" style="position: absolute; top: -5px; right: -5px; width: 12px; height: 12px; border-radius: 50%; background: #16a34a; border: 2px solid white; display: inline-block;"></span>';
      } else {
        // Mode normal - bouton bronze sans indicateur
        mjBtn.style.background = 'var(--bronze)';
        mjBtn.style.borderColor = 'var(--bronze)';
        mjBtn.innerHTML = '🎭 Maître de jeu <span id="mjStatusIndicator" style="position: absolute; top: -5px; right: -5px; width: 12px; height: 12px; border-radius: 50%; background: #dc2626; border: 2px solid white; display: none;"></span>';
      }
    },

    updateMJBodyClass() {
      const body = document.body;
      if (window.JdrApp.state.isMJ) {
        body.classList.remove('mj-off');
        body.classList.add('mj-on');
      } else {
        body.classList.remove('mj-on');
        body.classList.add('mj-off');
      }
    },

    showMJConfirmation(onConfirm) {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0,0,0,0.7);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
      `;
      
      modal.innerHTML = `
        <div style="
          background: var(--card);
          border: 3px solid var(--bronze);
          border-radius: 16px;
          padding: 2rem;
          max-width: 500px;
          margin: 1rem;
          text-align: center;
          box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        ">
          <h3 style="color: var(--bronze); margin-top: 0;">⚠️ Mode Maître de jeu</h3>
          <p style="margin: 1.5rem 0; line-height: 1.6;">
            Êtes-vous sûr de vouloir activer le mode Maître de jeu?<br><br>
            <strong style="color: var(--bronze);">Si vous êtes juste un joueur, vous risquez d'être spoilé!</strong>
          </p>
          <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 2rem;">
            <button id="mjConfirmYes" class="btn-base" style="background: var(--bronze); color: white; border-color: var(--bronze);">
              Oui, je suis MJ
            </button>
            <button id="mjConfirmNo" class="btn-base" style="background: var(--rule); color: var(--accent-ink); border-color: var(--rule);">
              Non, annuler
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      modal.querySelector('#mjConfirmYes').addEventListener('click', () => {
        document.body.removeChild(modal);
        onConfirm();
      });
      
      modal.querySelector('#mjConfirmNo').addEventListener('click', () => {
        document.body.removeChild(modal);
      });
      
      // Fermer en cliquant sur le fond
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
        }
      });
    },

    generateTOCSection(section) {
      const sectionClass = section.collapsed ? 'toc-section collapsed' : 'toc-section';
      const toggleIcon = section.collapsed ? '▶' : '▼';
      
      return `
        <div class="${sectionClass}" data-section="${section.id}">
          <div class="toc-section-header">
            <span class="toc-section-title">${section.title}</span>
            <span class="toc-section-toggle">${toggleIcon}</span>
          </div>
          <div class="toc-section-content">
            ${section.items.map(item => this.generateTOCItem(item)).join('')}
          </div>
        </div>
      `;
    },

    generateTOCItem(item) {
      if (item.type === 'page') {
        return `<a data-route="${item.id}" href="#/${item.id}" class="">${item.icon} ${item.title}</a>`;
      } else if (item.type === 'category') {
        return this.generateTOCCategory(item);
      }
      return '';
    },

    generateTOCCategory(item) {
      const dataSource = window[item.items]; // CLASSES, SORTS, DONS
      if (!dataSource) return '';

      if (item.id === 'classes') {
        return `
          <div class="toc-category">
            <a data-route="classes" href="#/classes" class="">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource.map(classe => 
                `<a data-route="${JdrApp.utils.data.sanitizeId(classe.nom)}" href="#/${JdrApp.utils.data.sanitizeId(classe.nom)}" class="">${this.getClassIcon(classe.nom)} ${classe.nom}</a>`
              ).join('')}
            </div>
          </div>
        `;
      } else if (item.id === 'sorts') {
        return `
          <div class="toc-category">
            <a data-route="sorts" href="#/sorts">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource.map(category => 
                `<a data-route="sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getSortCategoryIcon(category.nom)} ${category.nom}</a>`
              ).join('')}
            </div>
          </div>
        `;
      } else if (item.id === 'dons') {
        return `
          <div class="toc-category">
            <a data-route="dons" href="#/dons" class="">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource.map(category => 
                `<a data-route="dons-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/dons-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getDonCategoryIcon(category.nom)} ${category.nom}</a>`
              ).join('')}
            </div>
          </div>
        `;
      }

      return '';
    },

    generateBasicTOC() {
      const tocContainer = document.querySelector('#toc');
      if (!tocContainer) return;

      const tocHTML = `
        <h4>Sommaire</h4>
        <a class="" data-route="creation" href="#/creation">🧙‍♂️ Création d'un personnage</a>
        
        <div class="toc-category">
          <a data-route="classes" href="#/classes" class="">⚔️ Classes</a>
          <div class="toc-sub">
            ${window.CLASSES ? window.CLASSES.map(classe => 
              `<a data-route="${JdrApp.utils.data.sanitizeId(classe.nom)}" href="#/${JdrApp.utils.data.sanitizeId(classe.nom)}" class="">${this.getClassIcon(classe.nom)} ${classe.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <div class="toc-category">
          <a data-route="sorts" href="#/sorts">🔮 Sorts</a>
          <div class="toc-sub">
            ${window.SORTS ? window.SORTS.map(category => 
              `<a data-route="sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getSortCategoryIcon(category.nom)} ${category.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <div class="toc-category">
          <a data-route="dons" href="#/dons" class="">🎖️ Dons</a>
          <div class="toc-sub">
            ${window.DONS ? window.DONS.map(category => 
              `<a data-route="dons-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/dons-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getDonCategoryIcon(category.nom)} ${category.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <a data-route="objets" href="#/objets" class="">📦 Objets</a>
        
        <a data-route="elements" href="#/elements" class="">🌟 Éléments</a>
        <a data-route="stats" href="#/stats" class="">📊 Statistiques</a>
        <a data-route="competences-tests" href="#/competences-tests" class="">🎯 Compétences & Tests</a>
        <a data-route="etats" href="#/etats" class="">⚡ Etats</a>
      `;
      
      tocContainer.innerHTML = tocHTML;
    },
    
    renderObjectsPage() {
      if (!window.OBJETS) return false;
      
      // Ensure the page is shown as active first
      this.show('objets');
      
      // Force complete regeneration if coming from navigation or MJ mode change
      const shouldForceRefresh = this._forceObjectsRefresh || false;
      this._forceObjectsRefresh = false; // Reset the flag
      
      // Force complete regeneration of the objects page content
      // This ensures that objects filtered out by MJ restrictions are now properly generated in the DOM
      setTimeout(() => {
        if (JdrApp.modules.renderer && JdrApp.modules.renderer.regenerateCurrentPage) {
          JdrApp.modules.renderer.regenerateCurrentPage();
        }
      }, shouldForceRefresh ? 100 : 50); // Slightly longer delay when forced refresh
      
      return true;
    },


    // Helper method to refresh objects page if currently active
    refreshObjectsPageIfActive() {
      const currentHash = window.location.hash;
      if (currentHash === '#/objets' || currentHash === '#objets') {
        setTimeout(() => {
          // Force full page regeneration to ensure objects filtered by MJ mode are now visible
          // This calls renderObjectsPage() which will regenerate the entire page with current filters
          this.renderObjectsPage();
        }, 150); // Slightly longer delay to ensure MJ state is updated
      }
    },
    
    getClassIcon(className) {
      const icons = {
        'Guerrier': '🗡️',
        'Mage': '🔮',
        'Prêtre': '⛪',
        'Rôdeur': '🏃',
        'Enchanteur': '✨'
      };
      return icons[className] || '⚔️';
    },
    
    getSortCategoryIcon(categoryName) {
      const icons = {
        'Sorts de Mage': '🔮',
        'Sorts de Prêtre': '⛪',
        'Sorts d\'Enchanteur': '✨',
        'Sorts de Monstres': '💀'
      };
      return icons[categoryName] || '🔮';
    },
    
    getDonCategoryIcon(categoryName) {
      const icons = {
        'Guerrier': '🗡️',
        'Mage': '🔮',
        'Pretre': '⛪',  // Sans accent comme dans les données
        'Prêtre': '⛪',  // Avec accent au cas où
        'Rôdeur': '🏃',
        'Enchanteur': '✨',
        'Généraux': '🎖️',
        'Generaux': '🎖️'  // Sans accent comme dans les données
      };
      return icons[categoryName] || '🎖️';
    },

    getMonstreCategoryIcon(categoryName) {
      const icons = {
        'Forêt': '🌲',
        'Foret': '🌲',  // Sans accent
        'Donjon': '🏰',
        'Dragons': '🐉',
        'Mort-vivants': '💀',
        'Démons': '👹',
        'Demons': '👹',  // Sans accent
        'Animaux': '🦁',
        'Humanoïdes': '🧌',
        'Humanoïdes': '🧌'  // Sans accent
      };
      return icons[categoryName] || '👹';
    },
    
    getObjetCategoryIcon(categoryName) {
      const icons = {
        'Armes': '⚔️',
        'Armures': '🛡️',
        'Potions': '🧪',
        'Herbes Magiques': '🌿',
        'Objets Magiques': '✨',
        'Accessoires': '💍',
        'Consommables': '🍞',
        'Composants': '🔮',
        'Outils': '🔨'
      };
      return icons[categoryName] || '📦';
    },

    renderObjectsPage() {
      // Use PageBuilder to generate the objets page dynamically
      JdrApp.modules.renderer.renderUnifiedContentPage('objet', window.OBJETS || []);
      this.updateActiveStates('objets');
      this.show('objets'); // Activer la page
      return true;
    },

    renderMonstersPage() {
      // Use PageBuilder to generate the monstres page dynamically
      JdrApp.modules.renderer.renderUnifiedContentPage('monster', window.MONSTRES || []);
      this.updateActiveStates('monstres');
      this.show('monstres'); // Activer la page
      return true;
    },
    
    renderTablesTresorsPage() {
      // Use PageBuilder to generate the tables-tresors page dynamically
      JdrApp.modules.renderer.renderUnifiedContentPage('tableTresor', window.TABLES_TRESORS || { tables: [] });
      this.updateActiveStates('tables-tresors');
      this.show('tables-tresors'); // Activer la page
      return true;
    },

    renderCollectionsObjectsPage() {
      // Safety check - if collections data is not available, try to wait a bit
      if (!window.COLLECTIONS || !window.COLLECTIONS.collections || window.COLLECTIONS.collections.length === 0) {
        setTimeout(() => this.renderCollectionsObjectsPage(), 100);
        return false;
      }
      
      // Create or find the page element
      let pageElement = document.getElementById('collections-objets');
      
      // If the page doesn't exist, create it
      if (!pageElement) {
        pageElement = document.createElement('article');
        pageElement.id = 'collections-objets';
        pageElement.setAttribute('data-page', 'collections-objets');
        pageElement.className = 'page';
        
        // Insert it into the views container
        const viewsContainer = document.querySelector('#views');
        
        if (viewsContainer) {
          viewsContainer.appendChild(pageElement);
        } else {
          console.error('Views container not found');
          return false;
        }
      }
      
      // Create the collections page content
      const collectionsContent = `
        <div class="page-header">
          <h1>📚 Collections d'Objets</h1>
          <div class="editable-section" data-section-type="pageDescription">
            <p class="editable" data-edit-type="generic" data-edit-section="description" data-item-identifier="collections-objets" data-page-type="collections">${this.getCollectionsDescription()}</p>
            <button class="edit-btn" data-edit-type="collections-description" style="display: none;">✏️ Modifier</button>
          </div>
        </div>
        
        <div class="collections-search">
          <div class="search-container">
            <input 
              type="text" 
              id="collection-search-input" 
              placeholder="Tapez le nom d'une collection..." 
              class="search-input"
              value="Départ"
            />
            <button id="collection-search-btn" class="search-button">🔍 Rechercher</button>
          </div>
        </div>
        
        <div id="collection-results" class="collection-results" style="display: none;">
          <div id="collection-header" class="collection-header"></div>
          <div id="tag-filters" class="tag-filters"></div>
          <div id="collection-items" class="collection-items"></div>
        </div>
        
        <div id="available-collections" class="available-collections" style="display: none;">
          <h2>Collections disponibles</h2>
          <div class="collections-grid">
            <!-- Collections will be generated dynamically -->
          </div>
        </div>
      `;
      
      // Insert content into the page
      pageElement.innerHTML = collectionsContent;
      this.setupCollectionsEventListeners();
      
      // Show collections grid in dev mode, auto-fill search in normal mode
      const availableCollections = document.getElementById('available-collections');
      const searchInput = document.getElementById('collection-search-input');
      const isDevMode = this.isDevModeActive();
      
      
      // Generate collections dynamically
      this.generateCollectionsGrid();
      
      if (availableCollections) {
        if (isDevMode) {
          availableCollections.style.display = 'block';
          // In dev mode, show all collections without needing search
          // But keep the search functional for filtering
        } else {
          availableCollections.style.display = 'none';
          // In normal mode, collections are hidden - user must search manually
        }
      } else {
        console.error('❌ available-collections element not found');
      }
      
      // Setup dev mode change listener
      this.setupDevModeListener();
      
      // Show and activate page after content is inserted
      this.show('collections-objets');
      this.updateActiveStates('collections-objets');
      
      // Ensure the page is visible regardless of dev mode
      if (pageElement) {
        pageElement.classList.add('active');
      }
      
      return true;
    },

    setupCollectionsEventListeners() {
      // console.log('Setting up collections event listeners...');
      const searchInput = document.getElementById('collection-search-input');
      const searchBtn = document.getElementById('collection-search-btn');
      const collectionCards = document.querySelectorAll('.collection-card');
      
      // console.log('Found elements:', {
      //   searchInput: !!searchInput,
      //   searchBtn: !!searchBtn,
      //   collectionCards: collectionCards.length
      // });
      
      // Search functionality
      const performSearch = () => {
        const searchTerm = searchInput.value.trim();
        if (searchTerm) {
          this.displayCollection(searchTerm);
        }
      };
      
      searchBtn.addEventListener('click', performSearch);
      searchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          performSearch();
        }
      });
      
      // Collection card clicks
      collectionCards.forEach(card => {
        card.addEventListener('click', () => {
          const collection = card.getAttribute('data-collection');
          searchInput.value = collection;
          this.displayCollection(collection);
        });
      });
    },

    displayCollection(collectionName) {
      if (!window.OBJETS || !window.OBJETS.objets || !window.COLLECTIONS || !window.COLLECTIONS.collections) return;
      
      // Find the collection by name or ID
      const collection = window.COLLECTIONS.collections.find(coll => 
        coll.id === collectionName || 
        coll.nom.toLowerCase() === collectionName.toLowerCase()
      );
      
      if (!collection) {
        this.showCollectionNotFound(collectionName);
        return;
      }
      
      // Filter objects by collection (using object numbers/IDs defined in collection)
      const filteredObjects = window.OBJETS.objets.filter(obj => {
        return collection.objets && collection.objets.includes(obj.numero);
      });
      
      const resultsContainer = document.getElementById('collection-results');
      const headerContainer = document.getElementById('collection-header');
      const itemsContainer = document.getElementById('collection-items');
      const tagFiltersContainer = document.getElementById('tag-filters');
      const availableCollections = document.getElementById('available-collections');
      
      // Hide available collections and show results
      if (availableCollections) {
        availableCollections.style.display = 'none';
      }
      if (resultsContainer) {
        resultsContainer.style.display = 'block';
      }
      
      const isDevMode = JdrApp.utils.isDevMode();
      
      // Update header with collection info
      if (headerContainer) {
        headerContainer.innerHTML = `
          ${isDevMode ? `
            <div class="collection-navigation" style="margin-bottom: 1rem;">
              <button class="btn small back-to-collections-btn" style="background: #6B7280;">← Retour aux collections</button>
            </div>
          ` : ''}
          <h2>${collection.icon} ${collection.nom}</h2>
          <p class="collection-description">${collection.description}</p>
          <p>${filteredObjects.length} objet(s) dans cette collection</p>
          ${isDevMode ? `
            <div class="collection-dev-actions" style="margin-top: 1rem;">
              <button class="btn small add-object-btn" data-collection="${collection.id}">➕ Ajouter un objet à cette collection</button>
              <button class="btn small remove-object-btn" data-collection="${collection.id}">➖ Retirer un objet de cette collection</button>
            </div>
          ` : ''}
        `;
      }
      
      // Get all unique tags from filtered objects for additional filtering
      const allTags = [...new Set(filteredObjects.flatMap(obj => obj.tags || []))];
      
      // Create tag filters if objects have multiple tags
      if (allTags.length > 1 && tagFiltersContainer) {
        tagFiltersContainer.innerHTML = `
          <h3>Filtrer par tag:</h3>
          <div class="tag-buttons">
            <button class="tag-filter-btn active" data-tag="all">Tous</button>
            ${allTags.map(tag => `
              <button class="tag-filter-btn" data-tag="${tag}">${tag}</button>
            `).join('')}
          </div>
        `;
      } else if (tagFiltersContainer) {
        tagFiltersContainer.innerHTML = '';
      }
      
      // Display objects
      this.renderCollectionItems(filteredObjects);
      
      // Setup add/remove object button listeners if in dev mode
      if (isDevMode) {
        const addObjectBtn = document.querySelector('.add-object-btn');
        if (addObjectBtn) {
          addObjectBtn.addEventListener('click', () => {
            const collection = addObjectBtn.getAttribute('data-collection');
            this.addObjectToCollection(collection);
          });
        }
        
        const removeObjectBtn = document.querySelector('.remove-object-btn');
        if (removeObjectBtn) {
          removeObjectBtn.addEventListener('click', () => {
            const collection = removeObjectBtn.getAttribute('data-collection');
            this.removeObjectFromCollection(collection);
          });
        }

        const backToCollectionsBtn = document.querySelector('.back-to-collections-btn');
        if (backToCollectionsBtn) {
          backToCollectionsBtn.addEventListener('click', () => {
            this.showCollectionsGrid();
          });
        }
      }
      
      // Tag filter event listeners
      document.querySelectorAll('.tag-filter-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          // Update active state
          document.querySelectorAll('.tag-filter-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          
          const selectedTag = btn.getAttribute('data-tag');
          let itemsToShow = filteredObjects;
          
          if (selectedTag !== 'all') {
            itemsToShow = filteredObjects.filter(obj => 
              obj.tags && obj.tags.includes(selectedTag)
            );
          }
          
          this.renderCollectionItems(itemsToShow);
        });
      });
    },

    showCollectionNotFound(collectionName) {
      const resultsContainer = document.getElementById('collection-results');
      const headerContainer = document.getElementById('collection-header');
      const itemsContainer = document.getElementById('collection-items');
      const tagFiltersContainer = document.getElementById('tag-filters');
      const availableCollections = document.getElementById('available-collections');
      
      // Show error message for non-existent collection
      if (availableCollections) {
        availableCollections.style.display = 'none';
      }
      if (resultsContainer) {
        resultsContainer.style.display = 'block';
      }
      
      if (headerContainer) {
        const isDevMode = this.isDevModeActive();
        headerContainer.innerHTML = `
          <div class="collection-error">
            <h2>❌ Collection introuvable</h2>
            <p>Aucune collection nommée "<strong>${collectionName}</strong>" n'a été trouvée.</p>
            ${isDevMode ? 
              `<p>Les collections disponibles sont listées ci-dessous.</p>` : 
              `<p>Vérifiez l'orthographe ou contactez un administrateur pour connaître les collections disponibles.</p>`
            }
          </div>
        `;
      }
      
      if (itemsContainer) {
        itemsContainer.innerHTML = '';
      }
      if (tagFiltersContainer) {
        tagFiltersContainer.innerHTML = '';
      }
      
      // Clear search input after delay and show available collections only in dev mode
      setTimeout(() => {
        document.getElementById('collection-search-input').value = '';
        
        // Only show collections grid in dev mode
        const isDevMode = this.isDevModeActive();
        if (availableCollections) {
          availableCollections.style.display = isDevMode ? 'block' : 'none';
        }
        if (resultsContainer) {
          resultsContainer.style.display = 'none';
        }
      }, 3000);
    },

    renderCollectionItems(items) {
      const itemsContainer = document.getElementById('collection-items');
      
      // Multiple ways to detect dev mode for robustness
      const isDevMode = (
        (JdrApp && JdrApp.utils && JdrApp.utils.isDevMode && JdrApp.utils.isDevMode()) ||
        document.body.classList.contains('dev-on') ||
        (JdrApp.modules && JdrApp.modules.editor && JdrApp.modules.editor.isDevMode)
      );
      
      
      // Check if CardBuilder is available
      if (!window.CardBuilder) {
        console.error('CardBuilder not available, falling back to simple display');
        const itemsHTML = items.map(item => `
          <div class="card" data-object-numero="${item.numero}">
            <h4>${item.nom}</h4>
            <p><strong>N°${item.numero}</strong></p>
            <p>${item.description}</p>
            <hr>
            <p>${item.effet}</p>
            <div style="display: flex; justify-content: space-between;">
              <span>${item.prix}</span>
              <span>${item.poids}</span>
            </div>
            ${isDevMode ? `
              <div class="dev-controls" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #ccc;">
                <button class="btn small edit-object-btn" data-numero="${item.numero}">✏️ Éditer</button>
                <button class="btn small remove-from-collection-btn" data-numero="${item.numero}" style="background: #f59e0b;">➖ Retirer</button>
                <button class="btn small delete-object-btn" data-numero="${item.numero}" style="background: #ef4444;">🗑️ Supprimer</button>
              </div>
            ` : ''}
          </div>
        `).join('');
        itemsContainer.innerHTML = itemsHTML;
      } else {
        // Use the existing CardBuilder system to ensure consistent formatting and images
        const itemsHTML = items.map(item => {
          let cardHTML = window.CardBuilder.create('objet', item, 'objets').build();
          
          // Add dev controls if in dev mode
          if (isDevMode) {
            // Insert dev controls before the closing </article> tag
            cardHTML = cardHTML.replace('</article>', `
              <div class="dev-controls collection-dev-controls">
                <button class="btn small edit-object-btn" data-numero="${item.numero}">✏️ Éditer</button>
                <button class="btn small remove-from-collection-btn" data-numero="${item.numero}">➖ Retirer de cette collection</button>
                <button class="btn small delete-object-btn" data-numero="${item.numero}">🗑️ Supprimer définitivement</button>
              </div>
            </article>`);
          }
          
          return cardHTML;
        }).join('');
        
        itemsContainer.innerHTML = itemsHTML;
      }
      
      // Add event listeners for dev controls
      if (isDevMode) {
        this.setupCollectionEditControls();
      }
      
      // Auto-load images and manage dev mode buttons after rendering
      setTimeout(() => {
        if (JdrApp.modules.renderer && JdrApp.modules.renderer.autoLoadImages) {
          JdrApp.modules.renderer.autoLoadImages();
        }
        
        // Force apply dev mode classes to ensure CSS rules work
        this.ensureDevModeClasses();
      }, 100);
    },

    setupCollectionEditControls() {
      // Edit object buttons
      const editBtns = document.querySelectorAll('.edit-object-btn');
      const removeBtns = document.querySelectorAll('.remove-from-collection-btn');
      const deleteBtns = document.querySelectorAll('.delete-object-btn');
      
      // console.log('🎛️ Setting up object controls:', {
      //   editBtns: editBtns.length,
      //   removeBtns: removeBtns.length,
      //   deleteBtns: deleteBtns.length
      // });

      editBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const objectNumero = parseInt(btn.getAttribute('data-numero'));
          // console.log('✏️ Edit object clicked:', objectNumero);
          this.editCollectionObject(objectNumero);
        });
      });

      // Remove from collection buttons
      removeBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const objectNumero = parseInt(btn.getAttribute('data-numero'));
          // console.log('➖ Remove from collection clicked:', objectNumero);
          this.removeObjectFromCurrentCollection(objectNumero);
        });
      });

      // Delete object buttons
      deleteBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const objectNumero = parseInt(btn.getAttribute('data-numero'));
          // console.log('🗑️ Delete object clicked:', objectNumero);
          this.deleteCollectionObject(objectNumero);
        });
      });
    },

    editCollectionObject(objectNumero) {
      // Find the object in the data (normalize comparison)
      const object = window.OBJETS.objets.find(obj => parseInt(obj.numero) === objectNumero);
      if (!object) {
        console.error('Object not found:', objectNumero);
        return;
      }

      // Navigate to the objects page and trigger edit for this specific object
      // This reuses the existing object editing functionality
      window.location.hash = '#/objets';
      
      // Wait for the page to load, then trigger edit
      setTimeout(() => {
        const objectCard = document.querySelector(`[data-numero="${objectNumero}"]`);
        if (objectCard) {
          // Trigger the existing edit functionality
          const editableElements = objectCard.querySelectorAll('.editable');
          if (editableElements.length > 0) {
            // Focus on the first editable element to start editing
            editableElements[0].click();
          }
        }
      }, 500);
    },

    removeObjectFromCurrentCollection(objectNumero) {
      // Find the object in the data (normalize comparison)
      const object = window.OBJETS.objets.find(obj => parseInt(obj.numero) === objectNumero);
      if (!object) {
        console.error('Object not found:', objectNumero);
        return;
      }

      // Determine which collection we're currently viewing
      const searchInput = document.getElementById('collection-search-input');
      const currentCollectionName = searchInput ? searchInput.value : null;
      
      if (!currentCollectionName) {
        alert('Impossible de déterminer la collection actuelle.');
        return;
      }

      // Find the current collection
      const collection = window.COLLECTIONS.collections.find(coll => 
        coll.nom === currentCollectionName || coll.id === currentCollectionName
      );
      
      if (!collection) {
        alert(`Collection "${currentCollectionName}" introuvable.`);
        return;
      }

      // Check if the object is in this collection (normalize comparison)
      const objNum = parseInt(objectNumero);
      const isInCollection = collection.objets.includes(objNum) || collection.objets.includes(objectNumero);
      if (!isInCollection) {
        alert(`L'objet "${object.nom}" n'est pas dans la collection "${collection.nom}".`);
        return;
      }

      // Confirm removal
      const confirmRemove = confirm(
        `Êtes-vous sûr de vouloir retirer l'objet "${object.nom}" de la collection "${collection.nom}"?\n\n` +
        `L'objet ne sera pas supprimé, seulement retiré de cette collection.`
      );
      if (!confirmRemove) return;

      // Remove the object from the collection (normalize comparison)
      let objectIndex = collection.objets.indexOf(objNum);
      if (objectIndex === -1) {
        objectIndex = collection.objets.indexOf(objectNumero);
      }
      if (objectIndex !== -1) {
        collection.objets.splice(objectIndex, 1);
        
        // Show notification
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification(`➖ Objet "${object.nom}" retiré de la collection "${collection.nom}"`, 'success');
        }

        // Refresh the current collection view
        this.displayCollection(collection.id);
      }
    },

    deleteCollectionObject(objectNumero) {
      // Find the object in the data (normalize comparison)  
      const object = window.OBJETS.objets.find(obj => parseInt(obj.numero) === objectNumero);
      if (!object) {
        console.error('Object not found:', objectNumero);
        return;
      }

      // Confirm deletion
      const confirmDelete = confirm(`Êtes-vous sûr de vouloir supprimer l'objet "${object.nom}" (N°${object.numero}) ?`);
      if (!confirmDelete) return;

      // Remove the object from the data (normalize comparison)
      const objectIndex = window.OBJETS.objets.findIndex(obj => parseInt(obj.numero) === objectNumero);
      if (objectIndex !== -1) {
        window.OBJETS.objets.splice(objectIndex, 1);
        
        // Show notification
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification(`🗑️ Objet "${object.nom}" supprimé`, 'success');
        }

        // Refresh the current collection view
        const currentSearch = document.getElementById('collection-search-input').value;
        if (currentSearch) {
          this.displayCollection(currentSearch);
        }
      }
    },

    addObjectToCollection(collectionId) {
      // Find the collection
      const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
      if (!collection) {
        alert('Collection introuvable.');
        return;
      }
      
      // Show a list of all available objects to choose from
      const allObjects = window.OBJETS.objets;
      if (allObjects.length === 0) {
        alert('Aucun objet disponible à ajouter.');
        return;
      }
      
      // Filter out objects already in this collection
      // Normalize number comparison to handle both string and number types
      const availableObjects = allObjects.filter(obj => {
        const objNum = parseInt(obj.numero);
        return !collection.objets.includes(objNum) && !collection.objets.includes(obj.numero);
      });
      
      if (availableObjects.length === 0) {
        alert('Tous les objets sont déjà dans cette collection.');
        return;
      }
      
      // Create a selection modal with dropdown
      this.showObjectSelectionModal(
        `Ajouter un objet à la collection "${collection.nom}"`,
        availableObjects,
        (selectedObject) => {
          // Add the object to the collection (normalize to number type)
          const objNum = parseInt(selectedObject.numero);
          collection.objets.push(objNum);
          
          // Show notification
          if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
            JdrApp.modules.storage.showNotification(`➕ Objet "${selectedObject.nom}" ajouté à la collection "${collection.nom}"`, 'success');
          }
          
          // Refresh the current collection view to show the added object
          this.displayCollection(collectionId);
          
          // Auto-scroll to the added object
          setTimeout(() => {
            const addedObjectCard = document.querySelector(`[data-numero="${selectedObject.numero}"]`);
            if (addedObjectCard) {
              addedObjectCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
              // Highlight the added object briefly
              addedObjectCard.style.border = '3px solid #10B981';
              setTimeout(() => {
                addedObjectCard.style.border = '';
              }, 2000);
            }
          }, 500);
        }
      );
    },

    removeObjectFromCollection(collectionId) {
      // Find the collection
      const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
      if (!collection) {
        alert('Collection introuvable.');
        return;
      }
      
      if (!collection.objets || collection.objets.length === 0) {
        alert('Cette collection est vide.');
        return;
      }
      
      // Get the objects in this collection
      const collectionObjects = window.OBJETS.objets.filter(obj => 
        collection.objets.includes(obj.numero)
      );
      
      // Create a selection modal with dropdown
      this.showObjectSelectionModal(
        `Retirer un objet de la collection "${collection.nom}"`,
        collectionObjects,
        (selectedObject) => {
          // Remove the object from the collection
          const objectIndex = collection.objets.indexOf(selectedObject.numero);
          if (objectIndex !== -1) {
            collection.objets.splice(objectIndex, 1);
            
            // Show notification
            if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
              JdrApp.modules.storage.showNotification(`➖ Objet "${selectedObject.nom}" retiré de la collection "${collection.nom}"`, 'success');
            }
            
            // Refresh the current collection view
            this.displayCollection(collectionId);
          }
        }
      );
    },

    showCollectionsGrid() {
      // Hide collection results and show collections grid only in dev mode
      const resultsContainer = document.getElementById('collection-results');
      const availableCollections = document.getElementById('available-collections');
      const searchInput = document.getElementById('collection-search-input');
      
      if (resultsContainer) {
        resultsContainer.style.display = 'none';
      }
      
      // Only show collections grid in dev mode
      const isDevMode = this.isDevModeActive();
      if (availableCollections) {
        availableCollections.style.display = isDevMode ? 'block' : 'none';
      }
      
      // Clear the search input
      if (searchInput) {
        searchInput.value = '';
      }
      
      // Refresh the collections grid to ensure it's up to date if in dev mode
      if (isDevMode) {
        this.generateCollectionsGrid();
      }
    },

    showObjectSelectionModal(title, objects, onSelectCallback) {
      // Remove any existing modal
      const existingModal = document.querySelector('#object-selection-modal');
      if (existingModal) {
        existingModal.remove();
      }

      // Create modal HTML
      const modal = document.createElement('dialog');
      modal.id = 'object-selection-modal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        border: 3px solid #8B4513;
        border-radius: 12px;
        padding: 0;
        background: transparent !important;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5) !important;
      `;

      const selectOptions = objects
        .map(obj => `<option value="${obj.numero}">N°${obj.numero} - ${obj.nom}</option>`)
        .join('');

      modal.innerHTML = `
        <div style="
          background: white; 
          border-radius: 12px; 
          padding: 1.5rem; 
          border: 3px solid #8B4513;
          font-family: inherit;
          font-size: 16px;
        ">
          <h2 style="
            color: #8B4513; 
            font-family: 'Cinzel', serif; 
            margin: 0 0 1rem 0; 
            text-align: center;
          ">${title}</h2>
          
          <div style="margin: 1rem 0;">
            <label for="object-select" style="
              display: block; 
              margin-bottom: 0.5rem; 
              color: #8B4513; 
              font-weight: bold;
            ">Sélectionnez un objet :</label>
            <select id="object-select" style="
              width: 100%; 
              padding: 0.5rem; 
              border: 2px solid #8B4513; 
              border-radius: 8px; 
              font-size: 16px;
              font-family: inherit;
            ">
              <option value="">-- Choisissez un objet --</option>
              ${selectOptions}
            </select>
          </div>
          
          <div style="
            display: flex; 
            gap: 1rem; 
            justify-content: center; 
            margin-top: 1.5rem;
          ">
            <button class="btn-confirm-selection" style="
              background: #10B981; 
              color: white; 
              border: none; 
              padding: 0.75rem 1.5rem; 
              border-radius: 8px; 
              cursor: pointer; 
              font-weight: bold;
            ">Confirmer</button>
            <button class="btn-cancel-selection" style="
              background: #6B7280; 
              color: white; 
              border: none; 
              padding: 0.75rem 1.5rem; 
              border-radius: 8px; 
              cursor: pointer; 
              font-weight: bold;
            ">Annuler</button>
          </div>
        </div>
      `;

      // Add to body and show
      document.body.appendChild(modal);
      modal.showModal();

      // Set up event handlers
      const select = modal.querySelector('#object-select');
      const confirmBtn = modal.querySelector('.btn-confirm-selection');
      const cancelBtn = modal.querySelector('.btn-cancel-selection');

      confirmBtn.addEventListener('click', () => {
        const selectedNumero = parseInt(select.value);
        if (selectedNumero) {
          const selectedObject = objects.find(obj => obj.numero === selectedNumero);
          if (selectedObject && onSelectCallback) {
            onSelectCallback(selectedObject);
          }
        } else {
          alert('Veuillez sélectionner un objet.');
          return;
        }
        modal.close();
        modal.remove();
      });

      cancelBtn.addEventListener('click', () => {
        modal.close();
        modal.remove();
      });

      // Handle ESC key
      modal.addEventListener('close', () => {
        modal.remove();
      });
    },

    ensureDevModeClasses() {
      // Ensure the body has the correct dev mode class
      const isDevMode = JdrApp && JdrApp.utils && JdrApp.utils.isDevMode ? JdrApp.utils.isDevMode() : false;
      
      if (isDevMode) {
        document.body.classList.remove('dev-off');
        document.body.classList.add('dev-on');
      } else {
        document.body.classList.remove('dev-on');
        document.body.classList.add('dev-off');
      }
      
      // Force hide image buttons on collections page if not in dev mode
      if (!isDevMode) {
        const collectionItems = document.getElementById('collection-items');
        if (collectionItems) {
          const imageButtons = collectionItems.querySelectorAll('.illus label.up, .illus button.rm');
          imageButtons.forEach(button => {
            button.style.setProperty('display', 'none', 'important');
          });
        }
      }
    },

    getCollectionsDescription() {
      return JdrApp.data.customPageDescriptions['collections-objets'] || 'Recherchez et explorez des collections d\'objets organisées par thème';
    },

    generateCollectionsGrid() {
      if (!window.COLLECTIONS || !window.COLLECTIONS.collections) {
        return;
      }
      
      // Use defined collections instead of extracting from tags
      const collections = window.COLLECTIONS.collections;
      
      // Collection icons are now defined in the collections data itself
      
      const isDevMode = this.isDevModeActive();
      const collectionsGrid = document.querySelector('.collections-grid');
      
      if (!collectionsGrid) return;
      
      // Generate HTML for each collection
      const collectionsHTML = collections
        .map((collection) => {
          const count = collection.objets ? collection.objets.length : 0;
          return `
            <div class="collection-card" data-collection="${collection.id}">
              <div class="collection-icon">${collection.icon}</div>
              <h3>${collection.nom}</h3>
              <p>${count} objet(s)</p>
              <p class="collection-description">${collection.description}</p>
              ${isDevMode ? `
                <div class="collection-dev-controls">
                  <button class="btn small edit-collection-btn" data-collection="${collection.id}" title="Modifier cette collection">✏️ Modifier</button>
                  <button class="btn small delete-collection-btn" data-collection="${collection.id}" title="Supprimer cette collection">🗑️ Supprimer</button>
                </div>
              ` : ''}
            </div>
          `;
        }).join('');
      
      // Add "create new collection" button in dev mode
      const devActions = isDevMode ? `
        <div class="collection-card new-collection-card">
          <div class="collection-icon">➕</div>
          <h3>Nouvelle Collection</h3>
          <p>Créer une collection</p>
          <button class="btn small create-collection-btn">➕ Créer</button>
        </div>
      ` : '';
      
      collectionsGrid.innerHTML = collectionsHTML + devActions;
      
      // console.log('📦 Collections grid generated:', {
      //   collectionsCount: collections.length,
      //   hasDevActions: !!devActions,
      //   gridContent: collectionsGrid.innerHTML.length + ' chars'
      // });
      
      // Setup event listeners for collections (always active)
      this.setupCollectionEventListeners();
      
      // Setup dev-specific controls only in dev mode
      if (isDevMode) {
        this.setupCollectionManagementControls();
      }
    },

    isDevModeActive() {
      // Multiple ways to detect dev mode for robustness
      return (
        (JdrApp && JdrApp.utils && JdrApp.utils.isDevMode && JdrApp.utils.isDevMode()) ||
        document.body.classList.contains('dev-on') ||
        (JdrApp.modules && JdrApp.modules.editor && JdrApp.modules.editor.isDevMode)
      );
    },

    setupCollectionEventListeners() {
      // Collection card click listeners (open collection for viewing/editing)
      const collectionCards = document.querySelectorAll('.collection-card:not(.new-collection-card)');
      
      collectionCards.forEach(card => {
        card.addEventListener('click', (e) => {
          // Don't trigger if clicking on control buttons
          if (e.target.closest('.collection-dev-controls')) {
            return;
          }
          
          const collectionId = card.getAttribute('data-collection');
          if (collectionId) {
            // Find collection to get its name
            const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
            if (collection) {
              // Fill search input with collection name
              const searchInput = document.getElementById('collection-search-input');
              if (searchInput) {
                searchInput.value = collection.nom;
              }
              
              // Open the collection
              this.displayCollection(collectionId);
            }
          }
        });
      });
    },

    setupCollectionManagementControls() {
      // Create new collection button
      const createBtn = document.querySelector('.create-collection-btn');
      const editBtns = document.querySelectorAll('.edit-collection-btn');
      const deleteBtns = document.querySelectorAll('.delete-collection-btn');
      
      // console.log('🎛️ Setting up collection controls:', {
      //   createBtn: !!createBtn,
      //   editBtns: editBtns.length,
      //   deleteBtns: deleteBtns.length
      // });
      
      if (createBtn) {
        createBtn.addEventListener('click', () => {
          // console.log('➕ Create collection clicked');
          this.createNewCollection();
        });
      }

      // Edit collection buttons (rename)
      editBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const collectionName = btn.getAttribute('data-collection');
          // console.log('✏️ Edit collection clicked:', collectionName);
          this.renameCollection(collectionName);
        });
      });

      // Delete collection buttons
      deleteBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const collectionName = btn.getAttribute('data-collection');
          // console.log('🗑️ Delete collection clicked:', collectionName);
          this.deleteCollection(collectionName);
        });
      });
    },

    createNewCollection() {
      const collectionName = prompt('Nom de la nouvelle collection:');
      if (!collectionName || !collectionName.trim()) return;
      
      const trimmedName = collectionName.trim();
      
      // Generate an ID from the name
      const collectionId = trimmedName.toLowerCase().replace(/[^a-z0-9]/g, '-');
      
      // Check if collection already exists
      const existingCollection = window.COLLECTIONS.collections.find(coll => 
        coll.id === collectionId || coll.nom.toLowerCase() === trimmedName.toLowerCase()
      );
      
      if (existingCollection) {
        alert(`La collection "${trimmedName}" existe déjà.`);
        return;
      }
      
      // Get collection description and icon
      const collectionDescription = prompt('Description de la collection:', 'Nouvelle collection d\'objets');
      const collectionIcon = prompt('Icône de la collection (emoji):', '📦');
      
      // Create new collection object
      const newCollection = {
        id: collectionId,
        nom: trimmedName,
        description: collectionDescription || 'Nouvelle collection d\'objets',
        icon: collectionIcon || '📦',
        objets: []
      };
      
      // Add to collections data
      window.COLLECTIONS.collections.push(newCollection);
      
      // Refresh the grid
      this.generateCollectionsGrid();
      
      if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
        JdrApp.modules.storage.showNotification(`✅ Collection "${trimmedName}" créée avec succès!`, 'success');
      }
    },

    renameCollection(collectionId) {
      // Find the collection by ID
      const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
      if (!collection) {
        alert('Collection introuvable.');
        return;
      }
      
      const newName = prompt(`Nouveau nom pour la collection "${collection.nom}":`, collection.nom);
      if (!newName || !newName.trim() || newName.trim() === collection.nom) return;
      
      const trimmedNewName = newName.trim();
      
      // Check if new name already exists
      const existingCollection = window.COLLECTIONS.collections.find(coll => 
        coll.id !== collectionId && coll.nom.toLowerCase() === trimmedNewName.toLowerCase()
      );
      
      if (existingCollection) {
        alert(`La collection "${trimmedNewName}" existe déjà.`);
        return;
      }
      
      // Update collection name
      collection.nom = trimmedNewName;
      
      // Refresh the collections grid
      this.generateCollectionsGrid();
      
      if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
        JdrApp.modules.storage.showNotification(`✅ Collection renommée en "${trimmedNewName}"`, 'success');
      }
    },

    deleteCollection(collectionId) {
      // Find the collection by ID
      const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
      if (!collection) {
        alert('Collection introuvable.');
        return;
      }
      
      const objectCount = collection.objets ? collection.objets.length : 0;
      
      const confirmDelete = confirm(
        `Êtes-vous sûr de vouloir supprimer la collection "${collection.nom}"?\n` +
        `Cette collection contient ${objectCount} objet(s).\n` +
        `Les objets ne seront pas supprimés, seulement la collection sera retirée.`
      );
      
      if (!confirmDelete) return;
      
      // Remove the collection from the collections array
      const collectionIndex = window.COLLECTIONS.collections.findIndex(coll => coll.id === collectionId);
      if (collectionIndex !== -1) {
        window.COLLECTIONS.collections.splice(collectionIndex, 1);
        
        // Refresh the collections grid
        this.generateCollectionsGrid();
        
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification(`🗑️ Collection "${collection.nom}" supprimée`, 'success');
        }
      }
    },

    setupDevModeListener() {
      // Listen for dev mode changes via EventBus
      if (window.EventBus && window.Events) {
        EventBus.on(Events.EDITOR_TOGGLE, (payload) => {
          // console.log('🔄 Dev mode changed via EventBus:', payload.enabled);
          setTimeout(() => this.refreshCollectionsView(), 50);
        });
      }
      
      // Also listen for body class changes (fallback)
      if (window.MutationObserver) {
        if (this.devModeObserver) {
          this.devModeObserver.disconnect();
        }
        
        // Track the previous dev mode state to avoid loops
        let lastDevMode = this.isDevModeActive();
        
        this.devModeObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
              const currentDevMode = this.isDevModeActive();
              
              // Only refresh if dev mode actually changed
              if (currentDevMode !== lastDevMode) {
                // console.log('🔄 Body class changed, refreshing views - Dev mode:', currentDevMode);
                lastDevMode = currentDevMode;
                setTimeout(() => this.refreshCollectionsView(), 100);
              }
            }
          });
        });
        
        this.devModeObserver.observe(document.body, {
          attributes: true,
          attributeFilter: ['class']
        });
      }
    },

    refreshCollectionsView() {
      const currentHash = window.location.hash;
      
      // Refresh collections page if we're on it
      if (currentHash === '#/collections-objets') {
        const availableCollections = document.getElementById('available-collections');
        const isDevMode = this.isDevModeActive();
        
        // console.log('🔄 Refreshing collections view - Dev mode:', isDevMode);
        
        // Regenerate the collections grid
        this.generateCollectionsGrid();
        
        // Update visibility
        if (availableCollections) {
          if (isDevMode) {
              availableCollections.style.display = 'block';
          } else {
              availableCollections.style.display = 'none';
          }
        }
      }
      
      // Also refresh objects page if we're on it (for filter visibility)
      if (currentHash === '#/objets') {
        console.log('🔄 Refreshing objects page due to dev mode change');
        setTimeout(() => {
          this.renderObjectsPage();
        }, 100); // Augmenter le délai pour être sûr que le dev mode est à jour
      }
    },

    updateCollectionsDescription(newDescription) {
      JdrApp.data.customPageDescriptions['collections-objets'] = newDescription;
      // Also update via ContentFactory for consistency
      if (window.ContentFactory) {
        ContentFactory.updatePageDescription('collections', newDescription);
      }
    },

    renderFeuillePersonnagePage() {
      // Create or find the page element
      let pageElement = document.getElementById('feuille-personnage');
      
      // If the page doesn't exist, create it
      if (!pageElement) {
        pageElement = document.createElement('article');
        pageElement.id = 'feuille-personnage';
        pageElement.setAttribute('data-page', 'feuille-personnage');
        pageElement.className = 'page';
        
        // Insert it into the views container
        const viewsContainer = document.querySelector('#views');
        
        if (viewsContainer) {
          viewsContainer.appendChild(pageElement);
        } else {
          console.error('Views container not found');
          return false;
        }
      }
      
      // Create full PDF content for all versions  
      const feuillePersonnageContent = `
        <div class="page-header">
          <h1>📋 Feuille de personnage</h1>
        </div>
        
          
          
          <!-- PDF Info and Actions -->
          <div class="pdf-info-container" style="width: 100%; margin: 1rem 0; padding: 2rem; border: 2px solid var(--bronze); border-radius: 12px; background: var(--card); text-align: center;">
            <h3 style="color: var(--gold); font-family: 'Cinzel', serif; margin: 0 0 1rem 0;">📄 Feuille de personnage PDF</h3>
            <p style="color: var(--text); margin: 1rem 0;">Feuille de personnage complète de 3 pages pour vos aventures BabJDR</p>
            
            <div class="pdf-preview-actions" style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; margin-top: 1.5rem;">
              <button id="open-pdf-new-tab" class="btn-base" style="background: var(--bronze); color: white;">
                📖 Voir le PDF
              </button>
              <button id="download-pdf-direct" class="btn-base" style="background: var(--emerald); color: white;">
                📥 Télécharger
              </button>
              <button id="print-pdf-direct" class="btn-base" style="background: var(--gold); color: white;">
                🖨️ Imprimer
              </button>
            </div>
            
            <p style="color: var(--text-muted); font-size: 0.9rem; margin-top: 1rem;">
              💡 Astuce : Cliquez sur "Voir le PDF" pour l'ouvrir dans un nouvel onglet
            </p>
          </div>
          
          <div class="pdf-fallback" style="display: none; text-align: center; padding: 2rem; background: var(--accent-bg); border-radius: 8px; margin: 1rem 0;">
            <h3 style="color: var(--bronze);">📄 Feuille de personnage BabJDR</h3>
            <p style="color: var(--accent-ink); margin: 1rem 0;">
              Votre navigateur ne peut pas afficher le PDF directement. Utilisez les boutons ci-dessous:
            </p>
            
            <div class="pdf-info" style="background: white; border: 1px solid var(--rule); border-radius: 8px; padding: 1.5rem; margin: 1rem 0; text-align: left;">
              <h4 style="color: var(--bronze); margin-top: 0;">📝 Contenu de la feuille:</h4>
              <ul style="color: var(--accent-ink); line-height: 1.8;">
                <li><strong>Informations du personnage:</strong> Nom, classe, niveau, expérience</li>
                <li><strong>Caractéristiques:</strong> Force, Endurance, Agilité, Intelligence, Volonté, Chance</li>
                <li><strong>Statistiques dérivées:</strong> Vie, Mana, Initiative, Fortune, Armure, Esquive</li>
                <li><strong>Compétences:</strong> Hardiesse, Finesse, Coordination, Réflexion, Éloquence</li>
                <li><strong>Éléments:</strong> Armure élémentaire (Feu, Eau, Terre, Air, Lumière, Nuit, Divin, Maléfique)</li>
                <li><strong>Sorts et capacités:</strong> Liste des sorts connus et dons acquis</li>
                <li><strong>Inventaire:</strong> Consommables et sac général</li>
                <li><strong>Background:</strong> Histoire, apparence et personnalité du personnage</li>
              </ul>
            </div>
          </div>
          
        </div>
        
        <div class="character-sheet-info" style="margin-top: 1rem; text-align: center; color: var(--accent-ink);">
          <p><strong>💡 Info:</strong> La feuille de personnage est un PDF imprimable de 3 pages contenant tous les champs nécessaires pour votre personnage.</p>
        </div>
      `;
      
      // Insert content into the page
      pageElement.innerHTML = feuillePersonnageContent;
      
      // Setup event listeners for print and download functionality
      this.setupCharacterSheetActions();
      
      
      // Show and activate page
      this.show('feuille-personnage');
      this.updateActiveStates('feuille-personnage');
      
      return true;
    },

    setupCharacterSheetActions() {
      const pdfUrl = 'https://github.com/ben-128/BabJdr/raw/master/data/feuille-personnage.pdf';
      
      // Setup main action buttons
      const openBtn = document.getElementById('open-character-sheet');
      const printBtn = document.getElementById('print-character-sheet');
      const downloadBtn = document.getElementById('download-character-sheet');
      
      // Setup preview action buttons
      const openTabBtn = document.getElementById('open-pdf-new-tab');
      const printDirectBtn = document.getElementById('print-pdf-direct');
      const downloadDirectBtn = document.getElementById('download-pdf-direct');
      
      // Check if PDF embed is supported and handle fallback
      const pdfEmbed = document.getElementById('pdf-embed');
      const pdfFallback = document.querySelector('.pdf-fallback');
      
      if (pdfEmbed) {
        // Add load error handler for PDF embed
        pdfEmbed.addEventListener('error', () => {
          // Hide embed and show fallback
          pdfEmbed.style.display = 'none';
          if (pdfFallback) {
            pdfFallback.style.display = 'block';
          }
        });
        
        // Test if PDF can be loaded after a delay
        setTimeout(() => {
          // Check if the embed has loaded properly
          try {
            const embedDoc = pdfEmbed.contentDocument || pdfEmbed.contentWindow.document;
            if (!embedDoc || embedDoc.body.innerHTML.includes('%PDF')) {
              // PDF is showing as raw text, use fallback
              pdfEmbed.style.display = 'none';
              if (pdfFallback) {
                pdfFallback.style.display = 'block';
              }
            }
          } catch (e) {
            // Can't access content, probably loaded correctly
          }
        }, 1000);
      }
      
      // Open PDF in new tab
      const openPDF = () => {
        window.open(pdfUrl, '_blank');
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification('📖 PDF ouvert dans un nouvel onglet', 'success');
        }
      };
      
      // Print PDF
      const printPDF = () => {
        const printWindow = window.open(pdfUrl, '_blank');
        if (printWindow) {
          printWindow.focus();
          setTimeout(() => {
            try {
              printWindow.print();
            } catch (e) {
              alert('PDF ouvert. Utilisez Ctrl+P pour imprimer.');
            }
          }, 1000);
        } else {
          alert('Impossible d\'ouvrir le PDF. Vérifiez que les popups ne sont pas bloqués.');
        }
      };
      
      // Download PDF
      const downloadPDF = () => {
        const link = document.createElement('a');
        link.href = pdfUrl;
        link.download = 'Feuille-Personnage-BabJDR.pdf';
        link.style.display = 'none';
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification('📥 Téléchargement en cours...', 'success');
        }
      };
      
      // Attach event listeners
      if (openBtn) openBtn.addEventListener('click', openPDF);
      if (printBtn) printBtn.addEventListener('click', printPDF);
      if (downloadBtn) downloadBtn.addEventListener('click', downloadPDF);
      
      if (openTabBtn) openTabBtn.addEventListener('click', openPDF);
      if (printDirectBtn) printDirectBtn.addEventListener('click', printPDF);
      if (downloadDirectBtn) downloadDirectBtn.addEventListener('click', downloadPDF);
    }
  
  };

})();

// ============================================================================
// JDR-BAB APPLICATION - RENDERER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // CONTENT RENDERER MODULE
  // ========================================
  JdrApp.modules.renderer = {
    currentSearch: '',
    
    init() {
      // Delay content generation to ensure all configurations are loaded
      setTimeout(() => {
        this.generateContent();
        this.autoLoadImages();
      }, 10);
      this.setupEventListeners();
    },

    setupEventListeners() {
      EventBus.on(Events.PAGE_RENDER, (payload) => {
        if (payload.type === 'category') {
          this.renderCategoryPage(payload.categoryType, payload.category);
        }
      });

      EventBus.on(Events.CONTENT_ADD, () => {
        setTimeout(() => this.autoLoadImages(), 100);
      });
    },

    generateContent() {
      JdrApp.modules.router.generateTOC.call(JdrApp.modules.router);
      this.generateArticles();
      this.generateDevToolbox();
      
      if (JdrApp.modules.editor) {
        setTimeout(() => {
          if (JdrApp.modules.editor.isDevMode) {
            JdrApp.modules.editor.forceShowAllEditButtons();
          } else {
            JdrApp.modules.editor.forceHideAllEditButtons();
          }
        }, 100);
      }
    },

    generateArticles() {
      const viewsContainer = document.querySelector('#views');
      if (!viewsContainer) return;

      let articlesHTML = '';
      articlesHTML += this.generateStaticPages();
      articlesHTML += this.generateClassPages();
      articlesHTML += this.generateCategoryPages();
      articlesHTML += this.generateMonstersPage();

      viewsContainer.innerHTML = articlesHTML;
      setTimeout(() => {
        this.autoLoadImages();
        // Reapply dev mode state to new elements
        this.applyDevModeToNewContent();
        // Attach image events for standalone compatibility
        if (JdrApp.modules.editor && JdrApp.modules.editor.attachImageEvents) {
          JdrApp.modules.editor.attachImageEvents();
        }
        // Create proxy buttons for new content
        if (JdrApp.modules.editor && JdrApp.modules.editor.isDevMode) {
          setTimeout(() => JdrApp.modules.editor.createProxyButtons(), 100);
        }
        // Auto-populate monsters page if it exists
        if (document.getElementById('monsters-container')) {
          setTimeout(() => this.populateMonstersPage(), 50);
        }
      }, 100);
    },

    applyDevModeToNewContent() {
      if (JdrApp.modules.editor) {
        if (JdrApp.utils.isDevMode()) {
          JdrApp.modules.editor.forceShowAllEditButtons();
        } else {
          JdrApp.modules.editor.forceHideAllEditButtons();
        }
      }
    },


    generateStaticPages() {
      let html = '';
      if (window.STATIC_PAGES) {
        Object.entries(window.STATIC_PAGES).forEach(([pageId, pageData]) => {
          html += PageBuilder.buildStaticPage(pageId, pageData);
        });
      }
      return html;
    },


    generateClassPages() {
      if (!window.CLASSES) return '';
      
      return window.CLASSES.map(classe => 
        PageBuilder.buildClassPage(classe)
      ).join('');
    },

    generateCategoryPages() {
      let html = '';
      
      if (window.SORTS) {
        html += window.SORTS.map(category => 
          PageBuilder.buildCategoryPage('spell', category)
        ).join('');
      }

      if (window.DONS) {
        html += window.DONS.map(category => 
          PageBuilder.buildCategoryPage('don', category)
        ).join('');
      }

      // Generate single objects page (different from category pages)
      if (window.OBJETS) {
        html += PageBuilder.buildSingleObjectPage(window.OBJETS);
      }

      return html;
    },

    generateMonstersPage() {
      if (!window.MONSTRES) return '';
      
      return PageBuilder.buildSingleMonsterPage(window.MONSTRES);
    },


    renderCategoryPage(type, category) {
      const config = window.ContentTypes[type];
      
      // Handle special case for objects (single page, no category name)
      let pageId;
      if (type === 'objet') {
        pageId = 'objets'; // Objects use fixed page ID
      } else {
        pageId = `${config.container}-${JdrApp.utils.data.sanitizeId(category.nom)}`;
      }
      
      let article = document.querySelector(`article[data-page="${pageId}"]`);
      
      // Create article if it doesn't exist (for dynamically created categories)
      if (!article) {
        article = document.createElement('article');
        article.setAttribute('data-page', pageId);
        article.className = 'active'; // Make it active since we're showing it
        
        const viewsContainer = document.querySelector('#views');
        if (viewsContainer) {
          viewsContainer.appendChild(article);
        } else {
          // Views container not found
          return;
        }
      }
      
      const newContent = PageBuilder.buildCategoryPage(type, category);
      const parser = new DOMParser();
      const newDoc = parser.parseFromString(newContent, 'text/html');
      const newArticle = newDoc.querySelector('article');
      
      if (newArticle) {
        article.innerHTML = newArticle.innerHTML;
        
        // Make sure only this article is active
        document.querySelectorAll('article').forEach(a => a.classList.remove('active'));
        article.classList.add('active');
        
        // Plus simple et plus fiable
        this.autoLoadImages();
        
        // Attach image events for standalone compatibility
        if (JdrApp.modules.editor && JdrApp.modules.editor.attachImageEvents) {
          JdrApp.modules.editor.attachImageEvents();
        }
        
        // Ensure dev mode state is applied after content change
        setTimeout(() => {
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          } else if (window.STANDALONE_VERSION) {
            // FORCE STANDALONE MODE: Ensure dev-off class and hide all dev buttons
            document.body.className = 'dev-off';
          }
        }, 50);
      }
    },

    renderSortCategory(page) {
      const categoryId = page.replace('sorts-', '');
      const category = window.SORTS?.find(cat => 
        JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
      );
      
      if (category) {
        this.renderCategoryPage('spell', category);
      }
    },

    generateDevToolbox() {
      const devToolbox = JdrApp.utils.dom.$('#devToolbox');
      if (!devToolbox) return;

      const toolboxHTML = `
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--rule);">
          <span style="font-size: 18px;">🛠</span>
          <strong style="color: var(--accent-ink); font-family: 'Cinzel', serif;">Outils de développement</strong>
        </div>
        
        <div style="margin-bottom: 12px;">
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">✏️ Édition</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="saveAndExport" title="Sauvegarder et exporter tout en ZIP">💾 Export ZIP</button>
          </div>
        </div>
        
        <div style="margin-bottom: 12px;">
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">📝 Création</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="addCategory" title="Créer une nouvelle catégorie/page">📄 Nouvelle page</button>
            <button class="btn small" id="addSpellCategory" title="Créer une nouvelle catégorie de sorts">🔮 Catégorie de sorts</button>
            <button class="btn small" id="addDonCategory" title="Créer une nouvelle catégorie de dons">🎖️ Catégorie de dons</button>
          </div>
        </div>
        
        <div>
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">🎭 Ressources</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="elementsBtn" title="Choisir un élément pour copier sa balise HTML colorée">🎨 Éléments</button>
            <button class="btn small" id="etatsBtn" title="Choisir un état pour copier sa balise HTML avec tooltip">⚡ États</button>
            <button class="btn small" id="spellLinksBtn" title="Créer un lien vers un sort avec aperçu">🔮 Liens sorts</button>
            <button class="btn small" id="pageLinksBtn" title="Créer un lien vers une page du projet">🔗 Liens pages</button>
          </div>
        </div>
      `;

      devToolbox.innerHTML = toolboxHTML;
    },

    autoLoadImages() {
      if (JdrApp.modules.images) {
        return JdrApp.modules.images.autoLoadImages();
      }
      return 0;
    },

    regenerateCurrentPage() {
      // Find the currently active article
      const activeArticle = document.querySelector('article.active');
      if (!activeArticle) return;

      const pageId = activeArticle.dataset.page;
      if (!pageId) return;

      // Determine what type of page it is and regenerate only that page
      if (pageId.startsWith('sorts-')) {
        const categoryId = pageId.replace('sorts-', '');
        const category = window.SORTS?.find(cat => 
          JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
        );
        if (category) {
          this.renderCategoryPage('spell', category);
        }
      } else if (pageId.startsWith('dons-')) {
        const categoryId = pageId.replace('dons-', '');
        const category = window.DONS?.find(cat => 
          JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
        );
        if (category) {
          this.renderCategoryPage('don', category);
        }
      } else if (pageId === 'objets') {
        // Regenerate objects page using the generic approach
        const newHTML = this.generatePageContent(pageId);
        if (newHTML) {
          activeArticle.innerHTML = newHTML;
          this.autoLoadImages();
          
          // Apply dev mode state immediately
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          } else if (window.STANDALONE_VERSION) {
            // FORCE STANDALONE MODE: Ensure dev-off class and hide all dev buttons
            document.body.className = 'dev-off';
          }
        }
      } else {
        // For class pages, static pages, etc. - regenerate the specific content
        const newHTML = this.generatePageContent(pageId);
        if (newHTML) {
          activeArticle.innerHTML = newHTML;
          this.autoLoadImages();
          
          // Apply dev mode state immediately
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          } else if (window.STANDALONE_VERSION) {
            // FORCE STANDALONE MODE: Ensure dev-off class and hide all dev buttons
            document.body.className = 'dev-off';
          }
        }
      }
    },

    generatePageContent(pageId) {
      // Generate content for a specific page without affecting navigation
      if (window.CLASSES) {
        const classe = window.CLASSES.find(c => JdrApp.utils.data.sanitizeId(c.nom) === pageId);
        if (classe) {
          const content = PageBuilder.buildClassPage(classe);
          const parser = new DOMParser();
          const doc = parser.parseFromString(content, 'text/html');
          const article = doc.querySelector('article');
          return article ? article.innerHTML : null;
        }
      }

      if (window.STATIC_PAGES && window.STATIC_PAGES[pageId]) {
        const content = PageBuilder.buildStaticPage(pageId, window.STATIC_PAGES[pageId]);
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        const article = doc.querySelector('article');
        return article ? article.innerHTML : null;
      }

      // Handle objects page
      if (pageId === 'objets' && window.OBJETS) {
        const content = PageBuilder.buildSingleObjectPage(window.OBJETS);
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        const article = doc.querySelector('article');
        return article ? article.innerHTML : null;
      }

      return null;
    },

    populateMonstersPage() {
      const monstersContainer = document.getElementById('monstres-container');
      if (!monstersContainer || !window.MONSTRES) return;

      // Clear existing content
      monstersContainer.innerHTML = '';

      // Generate monster cards directly
      const cardsHTML = window.MONSTRES.map((monster, index) => 
        CardBuilder.create('monster', monster, 'monstres', index).build()
      ).join('');
      
      monstersContainer.innerHTML = cardsHTML;

      // Apply dev mode styling and load images
      this.applyDevModeToNewContent();
      this.autoLoadImages();
    },

    renderUnifiedContentPage(contentType, data) {
      // This method dynamically creates a unified content page (like objets or monstres)
      // using the PageBuilder with the appropriate build method
      let content = '';
      let pageId = '';
      
      if (contentType === 'objet' && data) {
        content = PageBuilder.buildSingleObjectPage(data);
        pageId = 'objets';
      } else if (contentType === 'monster' && data) {
        content = PageBuilder.buildSingleMonsterPage(data);
        pageId = 'monstres';
      } else if (contentType === 'tableTresor' && data) {
        content = PageBuilder.buildSingleTableTresorPage(data);
        pageId = 'tables-tresors';
      }
      
      if (content && pageId) {
        // Find or create the specific article element in #views
        const viewsContainer = document.querySelector('#views');
        if (viewsContainer) {
          // Remove existing article for this page if it exists
          const existingArticle = document.querySelector(`article[data-page="${pageId}"]`);
          if (existingArticle) {
            existingArticle.remove();
          }
          
          // Add the new content to the views container
          viewsContainer.insertAdjacentHTML('beforeend', content);
          
          this.autoLoadImages();
          
          // Apply dev mode state with slight delay to ensure DOM is processed
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            setTimeout(() => {
              if (JdrApp.modules.editor.isDevMode) {
                JdrApp.modules.editor.forceShowAllEditButtons();
              } else {
                JdrApp.modules.editor.forceHideAllEditButtons();
              }
            }, 10);
          }
        }
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - UNIFIED EDITOR SYSTEM
// ============================================================================

(() => {
  "use strict";

  class UnifiedEditor {
    constructor() {
      this.currentEditSession = null;
    }

    /*
     * IMPORTANT: Content Restoration Best Practices
     * =============================================
     * ALWAYS use restoreElementContent() for any content that has been edited
     * NEVER directly assign to innerHTML in editing contexts
     * This prevents HTML tags from being displayed as visible text
     */

    static getInstance() {
      if (!UnifiedEditor.instance) {
        UnifiedEditor.instance = new UnifiedEditor();
      }
      return UnifiedEditor.instance;
    }

    // Parse edit context from DOM element
    parseEditContext(element) {
      // Force reset any stuck elements FIRST
      this.forceResetAllEditingElements();
      
      const editableElement = element.classList.contains('editable-section') 
        ? element.querySelector('.editable') 
        : element;

      if (!editableElement) {
        return null;
      }

      const editType = editableElement.dataset.editType;
      const editSection = editableElement.dataset.editSection;
      
      // For simplified HTML editing, everything is treated as HTML content
      if (editType === 'html') {
        return this.parseHtmlEditContext(element, editSection);
      }
      
      // Generic editing - use contextual detection, don't force type
      if (editType === 'generic') {
        // Use the full parsing logic and keep the detected contentType
        return this.parseHtmlEditContext(element, editSection);
      }

      // Tags editing for objects
      if (editType === 'tags') {
        return this.parseTagsEditContext(element, editSection);
      }

      // Select element editing (for dropdowns like monster elements)
      if (editType === 'select') {
        return this.parseSelectEditContext(element, editSection);
      }

      // All legacy edit types have been migrated to 'generic'
      return null;
    }

    parseHtmlEditContext(element, editSection) {
      // Detect context automatically based on page structure
      // Order matters: check most specific first (spells, dons, classes, then static pages)
      
      // Check if we're in a spell card first (most specific)
      const spellCard = element.closest('.card[data-spell-name]');
      if (spellCard) {
        const spellName = spellCard.dataset.spellName;
        const spellIndex = spellCard.dataset.spellIndex;
        const categoryName = spellCard.dataset.categoryName;
        
        // Use class-based detection for spell sections to avoid index mismatches
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        // Detect the spell property from the element's classes or data attributes
        let spellEditSection = 'description'; // default fallback
        
        // Check for specific section classes to determine the property
        if (editableElement.classList.contains('spell-name') || editableElement.dataset.editSection === 'spell-name') {
          spellEditSection = 'nom';
        } else if (editableElement.classList.contains('spell-description') || editableElement.dataset.editSection === 'spell-description') {
          spellEditSection = 'description';
        } else if (editableElement.classList.contains('spell-prerequis') || editableElement.dataset.editSection === 'spell-prerequis') {
          spellEditSection = 'prerequis';
        } else if (editableElement.classList.contains('spell-portee') || editableElement.dataset.editSection === 'spell-portee') {
          spellEditSection = 'portee';
        } else if (editableElement.classList.contains('spell-mana') || editableElement.dataset.editSection === 'spell-mana') {
          spellEditSection = 'coutMana';
        } else if (editableElement.classList.contains('spell-temps-incantation') || editableElement.dataset.editSection === 'spell-temps-incantation') {
          spellEditSection = 'tempsIncantation';
        } else if (editableElement.classList.contains('spell-resistance') || editableElement.dataset.editSection === 'spell-resistance') {
          spellEditSection = 'resistance';
        } else if (editableElement.classList.contains('spell-effect-normal') || editableElement.dataset.editSection === 'spell-effect-normal') {
          spellEditSection = 'effetNormal';
        } else if (editableElement.classList.contains('spell-effect-critical') || editableElement.dataset.editSection === 'spell-effect-critical') {
          spellEditSection = 'effetCritique';
        }
        
        return {
          contentType: 'spell',
          itemIdentifier: spellName,
          itemIndex: spellIndex,
          categoryName: categoryName,
          property: 'html',
          editType: 'html',
          editSection: spellEditSection,
          config: window.ContentTypes.spell,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a don card
      const donCard = element.closest('.card[data-don-name]');
      if (donCard) {
        const donName = donCard.dataset.donName;
        const donIndex = donCard.dataset.donIndex;
        const categoryName = donCard.dataset.categoryName;
        
        // Use index-based detection for don sections
        const allEditables = Array.from(donCard.querySelectorAll('.editable'));
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const currentIndex = allEditables.indexOf(editableElement);
        
        // Map index to don property based on CardBuilder order
        // 0=nom, 1=description, 2=prerequis, 3=cout
        const donSections = ['nom', 'description', 'prerequis', 'cout'];
        const donEditSection = donSections[currentIndex] || 'description';
        
        return {
          contentType: 'don',
          itemIdentifier: donName,
          itemIndex: donIndex,
          categoryName: categoryName,
          property: 'html',
          editType: 'html',
          editSection: donEditSection,
          config: window.ContentTypes.don,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in an objet card
      const objetCard = element.closest('.card[data-objet-name]');
      if (objetCard) {
        const objetName = objetCard.dataset.objetName;
        const categoryName = objetCard.dataset.categoryName;
        
        // Use index-based detection for objet sections
        const allEditables = Array.from(objetCard.querySelectorAll('.editable'));
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const currentIndex = allEditables.indexOf(editableElement);
        
        // Map index to objet property based on CardBuilder order
        // 0=nom, 1=numero, 2=tags, 3=description, 4=effet, 5=prix, 6=poids
        const objetSections = ['nom', 'numero', 'tags', 'description', 'effet', 'prix', 'poids'];
        const objetEditSection = objetSections[currentIndex] || 'description';
        
        return {
          contentType: 'objet',
          itemIdentifier: objetName,
          categoryName: categoryName,
          property: 'html',
          editType: 'html',
          editSection: objetEditSection,
          config: window.ContentTypes.objet,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        // Use data-item-identifier if available, otherwise fall back to monsterName
        const itemIdentifier = editableElement?.dataset?.itemIdentifier || monsterName;
        
        // Use editSection directly (new format: "monster-fieldName")
        const editSection = editableElement?.dataset?.editSection || 'abilites';
        
        return {
          contentType: 'monster',
          itemIdentifier: itemIdentifier,
          categoryName: categoryName || 'monstres',
          property: 'html',
          editType: 'html', 
          editSection: editSection,
          config: window.ContentTypes.monster,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a table-tresor card
      const tableTresorCard = element.closest('.card[data-table-tresor-name]');
      if (tableTresorCard) {
        const tableName = tableTresorCard.dataset.tableTresorName;
        const categoryName = tableTresorCard.dataset.categoryName;
        
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        // Use data-item-identifier if available, otherwise fall back to tableName
        const itemIdentifier = editableElement?.dataset?.itemIdentifier || tableName;
        
        // Use editSection directly (new format: "table-tresor-fieldName")
        const editSection = editableElement?.dataset?.editSection || 'description';
        
        return {
          contentType: 'tableTresor',
          itemIdentifier: itemIdentifier,
          categoryName: categoryName || 'tables',
          property: 'html',
          editType: 'html', 
          editSection: editSection,
          config: window.ContentTypes.tableTresor,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a class page (before static pages!)
      // IMPORTANT: Exclude static pages even if they have data-page-title
      const classArticle = element.closest('article[data-page-title]:not([data-static-page="true"])');
      if (classArticle) {
        const className = classArticle.dataset.pageTitle;
        
        // Check if we're editing a subclass (look for subclass card)
        const subclassCard = element.closest('.card[data-subclass-name]');
        if (subclassCard) {
          // Determine what part of the subclass we're editing
          let subclassEditSection = 'content';
          
          const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
          
          if (editableElement) {
            const parentSection = editableElement.closest('.editable-section');
            
            // Use index-based detection for subclasses
            const subclassCard = editableElement.closest('.card[data-subclass-name]');
            const allEditables = subclassCard ? Array.from(subclassCard.querySelectorAll('.editable')) : [];
            const currentIndex = allEditables.indexOf(editableElement);
            
            // Map index to property based on subclass structure  
            // UPDATED ORDER: Index 0 = nom (title), Index 1 = description, Index 2 = base (stats), Index 3 = progression, Index 4+ = capacites
            if (element.closest('.stats-grid') || currentIndex === 2) {
              subclassEditSection = 'base';
            } else if (currentIndex === 0) {
              subclassEditSection = 'nom';
            } else if (currentIndex === 1) {
              subclassEditSection = 'description';
            } else if (currentIndex === 3) {
              subclassEditSection = 'progression';  
            } else if (currentIndex >= 4) {
              subclassEditSection = 'capacites';
            }
          }
          
          return {
            contentType: 'subclass',
            itemIdentifier: subclassCard.dataset.subclassName,
            categoryName: className,
            property: 'html',
            editType: 'html',
            editSection: subclassEditSection,
            config: window.ContentTypes.subclass,
            element: element.classList.contains('editable-section') ? element.querySelector('.editable') : element,
            container: element
          };
        }
        
        // Otherwise it's a class - determine what part of the class we're editing
        let classEditSection = 'content';
        
        // More specific detection based on parent elements and content
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        if (editableElement) {
          const parentCard = editableElement.closest('.card');
          const parentSection = editableElement.closest('.editable-section');
          
          // Use index-based detection instead of content analysis
          const classArticle = editableElement.closest('article[data-page-title]');
          const allEditables = classArticle ? Array.from(classArticle.querySelectorAll('.editable')) : [];
          const currentIndex = allEditables.indexOf(editableElement);
          
          // Map index to property based on class structure
          // Index 0 = resume (first editable in class)
          // Index 1+ = capacites (subsequent editables are class capabilities)
          if (currentIndex === 0) {
            classEditSection = 'resume';
          } else if (currentIndex >= 1) {
            classEditSection = 'capacites';
          }
        }
        
        return {
          contentType: 'class',
          itemIdentifier: className,
          categoryName: null,
          property: 'html',
          editType: 'html',
          editSection: classEditSection,
          config: window.ContentTypes.class,
          element: element.classList.contains('editable-section') ? element.querySelector('.editable') : element,
          container: element
        };
      }
      
      // Check if we're editing a page description (unified system)
      const pageDescSection = element.closest('.editable-section[data-section-type*="-category-description"], .editable-section[data-section-type="pageDescription"]');
      if (pageDescSection) {
        const sectionType = pageDescSection.dataset.sectionType;
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const editSection = editableElement ? editableElement.dataset.editSection : '';
        
        let contentType;
        
        // Handle different types of page descriptions
        if (sectionType === 'pageDescription') {
          // For generic page descriptions, get the content type from the editable element
          const pageType = editableElement?.dataset?.pageType;
          contentType = pageType || 'collections'; // fallback to collections
        } else {
          // Extract content type from section type (e.g., "objet-category-description" -> "objet")
          contentType = sectionType.replace('-category-description', '');
        }
        
        // Use unified page description system via ContentFactory
        return {
          contentType: 'pageDescription',
          pageType: contentType, // The actual content type (spell, don, objet, collections, etc.)
          itemIdentifier: contentType,
          categoryName: null,
          property: 'description',
          editType: 'html',
          editSection: editSection,
          element: editableElement,
          container: element,
          applyEdit: (content) => {
            const success = ContentFactory.updatePageDescription(contentType, content);
            if (!success) {
              console.error(`❌ Failed to update page description for ${contentType}`);
            }
            return success;
          }
        };
      }
        
      // Check if we're editing a category description (spell/don category pages - fallback for old system)
      const categorySection = element.closest('.editable-section');
      if (categorySection && categorySection.dataset.sectionType && categorySection.dataset.sectionType.includes('category-description')) {
        const sectionType = categorySection.dataset.sectionType;
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const editSection = editableElement ? editableElement.dataset.editSection : '';
        
        // Extract content type from section type
        const contentType = sectionType.replace('-category-description', '');
        
        return {
          contentType: 'category',
          itemIdentifier: editSection, // This is the category name
          categoryName: editSection,
          property: 'description',
          editType: 'html',
          editSection: 'description',
          categoryType: contentType,
          config: window.ContentTypes[contentType],
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're editing campaign or sub-page content (specific handling before static page fallback)
      const campaignArticle = element.closest('article[data-static-page="true"]');
      if (campaignArticle && campaignArticle.dataset.page === 'campagne') {
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const editSection = editableElement?.dataset?.editSection || '';
        
        // Handle campaign-specific edit sections
        if (editSection.startsWith('campaign-')) {
          // Parse campaign edit section: campaign-{campaignName}-{property}
          const parts = editSection.split('-');
          if (parts.length >= 3) {
            const campaignName = parts.slice(1, -1).join('-'); // Handle campaign names with hyphens
            const property = parts[parts.length - 1]; // last part is the property
            
            return {
              contentType: 'campaign',
              itemIdentifier: campaignName,
              categoryName: null,
              property: 'html',
              editType: 'html',
              editSection: property, // 'name' or 'description'
              config: window.ContentTypes.campaign,
              element: editableElement,
              container: element,
              applyEdit: (content) => {
                return this.updateCampaignData('campaign', campaignName, property, content);
              }
            };
          }
        } else if (editSection.startsWith('subpage-')) {
          // Parse sub-page edit section: subpage-{campaignName}-{subPageName}-{property}
          const parts = editSection.split('-');
          if (parts.length >= 4) {
            const campaignName = parts[1];
            const subPageName = parts.slice(2, -1).join('-'); // Handle sub-page names with hyphens
            const property = parts[parts.length - 1]; // last part is the property
            
            return {
              contentType: 'campaignSubPage',
              itemIdentifier: `${campaignName}:${subPageName}`,
              categoryName: campaignName,
              property: 'html',
              editType: 'html',
              editSection: property, // 'title' or 'content'
              config: window.ContentTypes.campaignSubPage,
              element: editableElement,
              container: element,
              applyEdit: (content) => {
                return this.updateCampaignData('subpage', campaignName, property, content, subPageName);
              }
            };
          }
        }
      }
      
      // Check if we're in a static page (LAST, as fallback)
      // Now we include ALL static pages, regardless of data-page-title
      const staticPageArticle = element.closest('article[data-static-page="true"]');
      if (staticPageArticle) {
        const pageName = staticPageArticle.dataset.page;
        
        // Enhanced page detection with ID-based fallback
        let actualPageName = pageName;
        const elementEditSection = element.dataset?.editSection || 'none';
        
        // If the element's edit section contains a page prefix, use that instead
        if (elementEditSection !== 'none' && elementEditSection.includes('-')) {
          const possiblePageId = elementEditSection.split('-')[0];
          // Check if this matches a known static page
          if (window.STATIC_PAGES && window.STATIC_PAGES[possiblePageId]) {
            actualPageName = possiblePageId;
          }
        }
        
        // Use the corrected page name
        const finalPageName = actualPageName;
        
        // Use index-based detection for static page sections
        const allEditables = Array.from(staticPageArticle.querySelectorAll('.editable'));
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const currentIndex = allEditables.indexOf(editableElement);
        
        // For static pages, use the actual edit section from the element's data attribute
        const actualEditSection = elementEditSection !== 'none' ? elementEditSection : `section-${currentIndex}`;
        
        return {
          contentType: 'staticPage',
          itemIdentifier: finalPageName,  // Use corrected page name
          categoryName: null,
          property: 'html',
          editType: 'html',
          editSection: actualEditSection,  // Use actual edit section ID
          config: window.ContentTypes.staticPage,
          element: editableElement,
          container: element
        };
      }
      
      // Default fallback
      return {
        contentType: 'unknown',
        itemIdentifier: editSection || 'content',
        categoryName: null,
        property: 'html',
        editType: 'html',
        editSection,
        config: { fields: {} },
        element: element.classList.contains('editable-section') ? element.querySelector('.editable') : element,
        container: element
      };
    }

    parseTagsEditContext(element, editSection) {
      // Check if we're in an object card
      const objetCard = element.closest('.card[data-objet-name]');
      if (objetCard) {
        const objetName = objetCard.dataset.objetName;
        const categoryName = objetCard.dataset.categoryName;
        
        return {
          contentType: 'objet',
          itemIdentifier: objetName,
          categoryName: categoryName,
          property: 'tags',
          editType: 'tags',
          editSection: editSection,
          config: window.ContentTypes.objet,
          element: element.classList.contains('editable') ? element : element.querySelector('.editable'),
          container: element
        };
      }
      
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        return {
          contentType: 'monster',
          itemIdentifier: monsterName,
          categoryName: categoryName || 'monstres',
          property: 'tags',
          editType: 'tags',
          editSection: editSection,
          config: window.ContentTypes.monster,
          element: element.classList.contains('editable') ? element : element.querySelector('.editable'),
          container: element
        };
      }
      
      return null;
    }

    parseSelectEditContext(element, editSection) {
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        return {
          contentType: 'monster',
          itemIdentifier: monsterName,
          categoryName: categoryName || 'monstres',
          property: 'element',
          editType: 'select',
          editSection: editSection,
          config: window.ContentTypes.monster,
          element: element,
          container: element.closest('.monster-element-section')
        };
      }
      
      // Check if we're in a spell card
      const spellCard = element.closest('.card[data-spell-name]');
      if (spellCard) {
        const spellName = spellCard.dataset.spellName;
        const spellIndex = spellCard.dataset.spellIndex;
        const categoryName = spellCard.dataset.categoryName;
        
        return {
          contentType: 'spell',
          itemIdentifier: spellName,
          itemIndex: spellIndex,
          categoryName: categoryName,
          property: 'element',
          editType: 'select',
          editSection: editSection,
          config: window.ContentTypes.spell,
          element: element,
          container: element.closest('.spell-element-section')
        };
      }
      
      return null;
    }

    makeElementEditable(editableElement, container) {
      const originalHtml = editableElement.innerHTML;
      container.dataset.originalContent = originalHtml;
      container.dataset.editing = 'true';

      // Decode any encoded HTML before showing for editing
      const decodedHtml = this.decodeHtmlEntities(originalHtml);
      editableElement.innerHTML = decodedHtml;
      editableElement.contentEditable = true;
      editableElement.style.cssText += `
        background-color: rgba(255, 255, 0, 0.1);
        border: 1px dashed var(--bronze);
        border-radius: 4px;
        padding: 4px;
        font-family: monospace;
        white-space: pre-wrap;
      `;
      editableElement.focus();

      const range = document.createRange();
      range.selectNodeContents(editableElement);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
    }

    makeTagsEditable(editableElement, container) {
      
      const originalHtml = editableElement.innerHTML;
      container.dataset.originalContent = originalHtml;
      container.dataset.editing = 'true';

      // Get current tags from the object
      const objetName = this.currentEditSession.itemIdentifier;
      
      const objet = window.OBJETS?.objets?.find(obj => obj.nom === objetName);
      
      const currentTags = objet?.tags || [];
      const availableTags = window.ContentTypes.objet.filterConfig.availableTags;

      // Create and show modal instead of inline editor
      this.showTagsModal(objetName, currentTags, availableTags);
    }

    showTagsModal(objetName, currentTags, availableTags) {
      // Remove any existing tags modal
      const existingModal = document.querySelector('#tagsEditModal');
      if (existingModal) {
        existingModal.remove();
      }

      // Use native HTML5 dialog element for proper z-index handling
      const modal = document.createElement('dialog');
      modal.id = 'tagsEditModal';
      modal.style.cssText = `
        max-width: 500px !important;
        width: 90% !important;
        padding: 0 !important;
        border: none !important;
        border-radius: 12px !important;
        background: transparent !important;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5) !important;
      `;

      const checkboxesHTML = availableTags.map(tag => `
        <div style="display: flex; align-items: center; gap: 0.5rem; margin: 0.5rem 0; padding: 0.5rem; background: #f5f5f5; border-radius: 8px;">
          <input 
            type="checkbox" 
            id="modal-tag-${tag}" 
            value="${tag}" 
            ${currentTags.includes(tag) ? 'checked' : ''}
            style="margin: 0;"
          >
          <label for="modal-tag-${tag}" style="flex: 1; cursor: pointer; font-weight: 500;">
            <span style="background: #8B4513; color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 0.5rem;">${tag}</span>
            ${tag}
          </label>
        </div>
      `).join('');

      modal.innerHTML = `
        <div style="
          background: white; 
          border-radius: 12px; 
          padding: 1.5rem; 
          border: 3px solid #8B4513;
          font-family: inherit;
          font-size: 16px;
          color: #333;
        ">
          <h3 style="margin: 0 0 1rem 0; color: #8B4513; font-size: 1.2em;">🏷️ Éditer les tags de "${objetName}"</h3>
          <p style="margin: 0 0 1rem 0; color: #666; font-size: 0.9em;">Sélectionnez les tags à assigner à cet objet :</p>
          
          <div id="tagsCheckboxes" style="margin: 1rem 0;">
            ${checkboxesHTML}
          </div>
          
          <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem;">
            <button type="button" class="btn-cancel-tags-modal" style="
              background: #666; 
              color: white; 
              border: none; 
              padding: 8px 16px; 
              border-radius: 6px; 
              cursor: pointer;
              font-weight: 500;
              font-size: 14px;
            ">
              ❌ Annuler
            </button>
            <button type="button" class="btn-save-tags-modal" style="
              background: #8B4513; 
              color: white; 
              border: none; 
              padding: 8px 16px; 
              border-radius: 6px; 
              cursor: pointer;
              font-weight: 500;
              font-size: 14px;
            ">
              💾 Sauvegarder
            </button>
          </div>
        </div>
      `;

      // Append to body and show modal using native dialog API
      document.body.appendChild(modal);

      // Use showModal() for proper top-level display
      try {
        modal.showModal();
      } catch (error) {
        console.error('Error calling showModal():', error);
      }

      // Set up event handlers
      modal.querySelector('.btn-save-tags-modal').addEventListener('click', () => {
        this.saveTagsFromModal(modal);
      });

      modal.querySelector('.btn-cancel-tags-modal').addEventListener('click', () => {
        this.cancelTagsModal(modal);
      });

      // Native dialog handles backdrop clicks and ESC automatically
      modal.addEventListener('cancel', (e) => {
        this.cancelTagsModal(modal);
      });

      // Close on backdrop click (for dialog elements)
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.cancelTagsModal(modal);
        }
      });
    }

    saveTagsFromModal(modal) {
      if (!this.currentEditSession) return false;

      const checkboxes = modal.querySelectorAll('input[type="checkbox"]:checked');
      const selectedTags = Array.from(checkboxes).map(cb => cb.value);

      if (selectedTags.length === 0) {
        alert('Veuillez sélectionner au moins un tag');
        return false;
      }

      // Update data based on content type
      const itemName = this.currentEditSession.itemIdentifier;
      let targetItem = null;
      
      if (this.currentEditSession.contentType === 'objet') {
        // Update the object data
        targetItem = window.OBJETS?.objets?.find(obj => obj.nom === itemName);
      } else if (this.currentEditSession.contentType === 'monster') {
        // Update the monster data
        targetItem = window.MONSTRES?.find(monster => monster.nom === itemName);
      } else if (this.currentEditSession.contentType === 'tableTresor') {
        // Update the table tresor data
        targetItem = window.TABLES_TRESORS?.tables?.find(table => table.nom === itemName);
      }
      
      if (targetItem) {
        targetItem.tags = selectedTags;
        
        // Update the display
        const tagsDisplay = selectedTags.map(tag => 
          `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`
        ).join('');
        
        // Restore the element and update its content
        this.resetEditingState(this.currentEditSession.container);
        this.restoreElementContent(this.currentEditSession, tagsDisplay);
        
        // Save to storage
        EventBus.emit(Events.STORAGE_SAVE);
        
        // Close modal and clear edit session
        modal.close();
        modal.remove();
        this.currentEditSession = null;
        
        // Show success notification
        JdrApp.modules.ui.showNotification(`🏷️ Tags mis à jour : ${selectedTags.join(', ')}`, 'success');
        
        return true;
      }
      
      return false;
    }

    cancelTagsModal(modal) {
      // Close modal without saving
      modal.close();
      modal.remove();
      
      // Cancel the edit session
      this.cancelCurrentEdit();
    }

    // Save current editing session
    saveCurrentEdit() {
      if (!this.currentEditSession) return false;

      const session = this.currentEditSession;
      // Get the edited HTML content from innerHTML (user edited the rendered content)
      const newContent = session.element.innerHTML.trim();
      const normalizedContent = this.normalizeHTMLContent(newContent);

      // Reset editing state first to avoid interfering with content restoration
      this.resetEditingState(session.container);

      if (normalizedContent !== session.originalContent) {
        const success = this.saveContent(session, normalizedContent);
        if (success) {
          // Convert back from text to rendered HTML
          this.restoreElementContent(session, normalizedContent);
          
          EventBus.emit(Events.CONTENT_UPDATE, {
            contentType: session.contentType,
            itemIdentifier: session.itemIdentifier,
            property: session.property,
            value: normalizedContent
          });
        } else {
          // If save failed, restore original content
          this.restoreElementContent(session, session.originalContent);
        }
      } else {
        // Even if no changes, restore HTML rendering
        this.restoreElementContent(session, session.originalContent);
      }

      this.currentEditSession = null;
      return true;
    }

    // Update content in data structure - unified method for all content types
    updateContentInDataStructure(session, content) {
      try {
        switch (session.contentType) {
          case 'spell':
            return this.updateSpellData(session, content);
          case 'don':
            return this.updateDonData(session, content);
          case 'objet':
            return this.updateObjetData(session, content);
          case 'monster':
            return this.updateMonsterData(session, content);
          case 'category':
            return this.updateCategoryData(session, content);
          case 'subclass':
            return this.updateSubclassData(session, content);
          case 'class':
            return this.updateClassData(session, content);
          case 'staticPage':
            return this.updateStaticPageData(session, content);
          case 'tableTresor':
            return this.updateTableTresorData(session, content);
          case 'pageDescription':
            return this.updatePageDescriptionData(session, content);
          case 'campaign':
            return session.applyEdit(content);
          case 'campaignSubPage':
            return session.applyEdit(content);
          default:
            console.error('Unknown content type for update:', session.contentType);
            return false;
        }
      } catch (error) {
        console.error('Error updating content:', error, session);
        return false;
      }
    }

    // Update spell data
    updateSpellData(session, content) {
      const category = window.SORTS?.find(cat => cat.nom === session.categoryName);
      if (!category) return false;
      
      const spell = category.sorts?.find(s => s.nom === session.itemIdentifier);
      if (!spell) return false;
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.spell;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // If we're updating the name, we need to update the container's data-spell-name attribute
      if (propertyName === 'nom') {
        const oldName = spell.nom;
        spell[propertyName] = content;
        
        // Update the data-spell-name attribute on the card container
        const spellCard = session.container.closest('.card[data-spell-name]');
        if (spellCard && spellCard.dataset.spellName === oldName) {
          spellCard.dataset.spellName = content;
        }
      } else {
        spell[propertyName] = content;
      }
      
      return true;
    }

    // Update don data
    updateDonData(session, content) {
      const category = window.DONS?.find(cat => cat.nom === session.categoryName);
      if (!category) return false;
      
      const don = category.dons?.find(d => d.nom === session.itemIdentifier);
      if (!don) return false;
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.don;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // If we're updating the name, we need to update the container's data-don-name attribute
      if (propertyName === 'nom') {
        const oldName = don.nom;
        don[propertyName] = content;
        
        // Update the data-don-name attribute on the card container
        const donCard = session.container.closest('.card[data-don-name]');
        if (donCard && donCard.dataset.donName === oldName) {
          donCard.dataset.donName = content;
        }
      } else {
        don[propertyName] = content;
      }
      
      return true;
    }

    // Update objet data
    updateObjetData(session, content) {
      const objet = window.OBJETS?.objets?.find(o => o.nom === session.itemIdentifier);
      if (!objet) return false;
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.objet;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // If we're updating the name, we need to update the container's data-objet-name attribute
      if (propertyName === 'nom') {
        const oldName = objet.nom;
        objet[propertyName] = content;
        
        // Update the data-objet-name attribute on the card container
        const objetCard = session.container.closest('.card[data-objet-name]');
        if (objetCard && objetCard.dataset.objetName === oldName) {
          objetCard.dataset.objetName = content;
        }
      } else {
        objet[propertyName] = content;
      }
      
      return true;
    }

    // Update monster data
    updateMonsterData(session, content) {
      const monster = window.MONSTRES?.find(m => m.nom === session.itemIdentifier);
      if (!monster) {
        console.error('Monster not found:', session.itemIdentifier, 'Available monsters:', window.MONSTRES?.map(m => m.nom));
        return false;
      }
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.monster;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // Backup current value for rollback capability
      const originalValue = monster[propertyName];
      
      try {
        // If we're updating the name, we need to update the container's data-monster-name attribute
        if (propertyName === 'nom') {
          const oldName = monster.nom;
          monster[propertyName] = content;
          
          // Update the data-monster-name attribute on the card container
          const monsterCard = session.container.closest('.card[data-monster-name]');
          if (monsterCard && monsterCard.dataset.monsterName === oldName) {
            monsterCard.dataset.monsterName = content;
          }
        } else {
          // Update the monster property
          monster[propertyName] = content;
        }
        
        // Force synchronization using ContentFactory to prevent data reversion
        const contentFactory = window.ContentFactory?.getInstance ? window.ContentFactory.getInstance() : null;
        if (contentFactory && contentFactory.updateItem) {
          // Use ContentFactory to ensure proper data synchronization
          contentFactory.updateItem('monster', null, monster.nom, propertyName, content);
        }
        
        // Additional safety: ensure image mapping is maintained
        if (propertyName === 'image' && JdrApp.modules.images) {
          const imageKey = `monster:${monster.nom}`;
          JdrApp.modules.images.setImage(imageKey, content);
        }
        
        // Create backup for crash recovery
        this.createMonsterBackup(monster);
        
        return true;
        
      } catch (error) {
        // Rollback on error
        console.error('❌ Error updating monster, rolling back:', error);
        monster[propertyName] = originalValue;
        return false;
      }
    }

    // Update table tresor data
    updateTableTresorData(session, content) {
      const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === session.itemIdentifier);
      if (!table) {
        console.error('Table tresor not found:', session.itemIdentifier, 'Available tables:', window.TABLES_TRESORS?.tables?.map(t => t.nom));
        return false;
      }
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.tableTresor;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // Backup current value for rollback capability
      const originalValue = table[propertyName];
      
      try {
        // If we're updating the name, we need to update the container's data-table-tresor-name attribute
        if (propertyName === 'nom') {
          const oldName = table.nom;
          table[propertyName] = content;
          
          // Update the data-table-tresor-name attribute on the card container
          const tableTresorCard = session.container.closest('.card[data-table-tresor-name]');
          if (tableTresorCard && tableTresorCard.dataset.tableTresorName === oldName) {
            tableTresorCard.dataset.tableTresorName = content;
          }
          
          // If we're updating the name, we need to update the session itemIdentifier
          // to prevent future saves from failing with the old name
          if (this.currentEditSession && this.currentEditSession.itemIdentifier === originalValue) {
            this.currentEditSession.itemIdentifier = content;
          }
        } else {
          // Update the table property
          table[propertyName] = content;
        }
        
        // Force synchronization using ContentFactory to prevent data reversion
        const contentFactory = window.ContentFactory?.getInstance ? window.ContentFactory.getInstance() : null;
        if (contentFactory && contentFactory.updateItem) {
          // Use ContentFactory to ensure proper data synchronization
          contentFactory.updateItem('tableTresor', 'tables', table.nom, propertyName, content);
        }
        
        return true;
        
      } catch (error) {
        // Rollback on error
        console.error('❌ Error updating table tresor, rolling back:', error);
        table[propertyName] = originalValue;
        return false;
      }
    }

    // Update page description data (unified system)
    updatePageDescriptionData(session, content) {
      // Use the ContentFactory method that already handles the configuration
      const success = ContentFactory.updatePageDescription(session.pageType, content);
      
      if (success) {
        return true;
      } else {
        console.error(`❌ Failed to update page description for ${session.pageType}`);
        return false;
      }
    }

    // Update category data (generic for all category types)
    updateCategoryData(session, content) {
      // Handle different category types generically
      if (session.categoryType === 'don') {
        const category = window.DONS?.find(cat => cat.nom === session.categoryName);
        if (category && session.editSection === 'description') {
          category.description = content;
          return true;
        }
      } else if (session.categoryType === 'spell') {
        const category = window.SORTS?.find(cat => cat.nom === session.categoryName);
        if (category && session.editSection === 'description') {
          category.description = content;
          return true;
        }
      }
      
      // Simple fallback - if we're editing description and nothing else matched, 
      // and we have OBJETS, assume it's the objects category
      if (session.editSection === 'description' && window.OBJETS) {
        window.OBJETS.description = content;
        return true;
      }
      
      return false;
    }

    // Update subclass data
    updateSubclassData(session, content) {
      const classe = window.CLASSES?.find(c => c.nom === session.categoryName);
      if (!classe) return false;
      
      const subclass = classe.sousClasses?.find(sc => sc.nom === session.itemIdentifier);
      if (!subclass) return false;
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.subclass;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // If we're updating the name, we need to update the container's data-subclass-name attribute
      if (propertyName === 'nom') {
        const oldName = subclass.nom;
        subclass[propertyName] = content;
        
        // Update the data-subclass-name attribute on the card container
        const subclassCard = session.container.closest('.card[data-subclass-name]');
        if (subclassCard && subclassCard.dataset.subclassName === oldName) {
          subclassCard.dataset.subclassName = content;
        }
      } else {
        subclass[propertyName] = content;
      }
      
      return true;
    }

    // Update class data
    updateClassData(session, content) {
      const classe = window.CLASSES?.find(c => c.nom === session.itemIdentifier);
      if (!classe) return false;
      
      classe[session.editSection] = content;
      return true;
    }

    // Update static page data
    updateStaticPageData(session, content) {
      const pageKey = session.itemIdentifier;
      const pageData = window.STATIC_PAGES?.[pageKey];
      
      if (!pageData) return false;
      
      // Handle page title
      if (session.editSection === 'page-title') {
        pageData.title = content;
        return true;
      }
      
      // Handle campaign data (special case for campaign page)
      if (pageKey === 'campagne') {
        return this.updateCampaignData(pageData, session, content);
      }
      
      // Handle sections
      return this.updateStaticPageSection(pageData, session, content);
    }

    // Update specific section in static page data
    updateStaticPageSection(pageData, session, content) {
      if (!pageData.sections) return false;
      
      const sections = pageData.sections;
      
      // Find section by ID or type
      for (let i = 0; i < sections.length; i++) {
        const section = sections[i];
        
        // Direct ID match
        if (section.id === session.editSection) {
          section.content = content;
          return true;
        }
        
        // Handle title updates (ID + "-title")
        if (session.editSection.endsWith('-title')) {
          const sectionId = session.editSection.replace('-title', '');
          if (section.id === sectionId) {
            section.title = content;
            return true;
          }
        }
        
        // Handle intro sections
        if (section.type === 'intro' && session.editSection.includes('intro')) {
          section.content = content;
          return true;
        }
        
        // Handle card sections
        if (section.type === 'card' && section.id === session.editSection) {
          section.content = content;
          return true;
        }
      }
      
      // If no existing section found, check if we need to create one for intro
      if (session.editSection === 'intro' || session.editSection.includes('intro')) {
        const introSection = sections.find(s => s.type === 'intro');
        if (introSection) {
          introSection.content = content;
          return true;
        }
      }
      
      return false;
    }

    // Update campaign and sub-page data
    updateCampaignData(pageData, session, content) {
      const editSection = session.editSection;
      
      // Initialize subPages if not exists
      if (!pageData.subPages) {
        pageData.subPages = {};
      }
      
      // Parse edit section: campaign-{campaignName}-{field} or subpage-{campaignName}-{subPageName}-{field}
      if (editSection.startsWith('campaign-')) {
        // Format: campaign-{campaignName}-{field}
        const parts = editSection.split('-');
        if (parts.length >= 3) {
          const campaignName = parts.slice(1, -1).join('-'); // Handle campaign names with dashes
          const field = parts[parts.length - 1];
          
          if (!pageData.subPages[campaignName]) {
            pageData.subPages[campaignName] = {
              name: campaignName,
              description: 'Description de la campagne',
              subPages: {}
            };
          }
          
          if (field === 'name') {
            // If renaming campaign, we need to move the entire campaign data
            if (campaignName !== content && !pageData.subPages[content]) {
              pageData.subPages[content] = pageData.subPages[campaignName];
              pageData.subPages[content].name = content;
              delete pageData.subPages[campaignName];
            }
          } else if (field === 'description') {
            pageData.subPages[campaignName].description = content;
          }
          
          return true;
        }
      } else if (editSection.startsWith('subpage-')) {
        // Format: subpage-{campaignName}-{subPageName}-{field}
        const parts = editSection.split('-');
        if (parts.length >= 4) {
          const campaignName = parts[1];
          const subPageName = parts.slice(2, -1).join('-'); // Handle sub-page names with dashes
          const field = parts[parts.length - 1];
          
          if (!pageData.subPages[campaignName]) {
            return false; // Campaign doesn't exist
          }
          
          if (!pageData.subPages[campaignName].subPages) {
            pageData.subPages[campaignName].subPages = {};
          }
          
          if (!pageData.subPages[campaignName].subPages[subPageName]) {
            pageData.subPages[campaignName].subPages[subPageName] = {
              title: subPageName,
              content: '<p>Contenu de la sous-page...</p>'
            };
          }
          
          if (field === 'title') {
            // If renaming sub-page, we need to move the entire sub-page data
            if (subPageName !== content && !pageData.subPages[campaignName].subPages[content]) {
              pageData.subPages[campaignName].subPages[content] = pageData.subPages[campaignName].subPages[subPageName];
              pageData.subPages[campaignName].subPages[content].title = content;
              delete pageData.subPages[campaignName].subPages[subPageName];
            }
          } else if (field === 'content') {
            pageData.subPages[campaignName].subPages[subPageName].content = content;
          }
          
          return true;
        }
      }
      
      return false;
    }

    // Save content using unified system
    saveContent(session, content) {
      try {
        // Determine which JSON category to save to
        let jsonCategory;
        
        switch (session.contentType) {
          case 'spell':
            jsonCategory = 'SORTS';
            break;
          case 'don':
            jsonCategory = 'DONS';
            break;
          case 'class':
            jsonCategory = 'CLASSES';
            break;
          case 'subclass':
            jsonCategory = 'CLASSES';  // Subclasses are stored within CLASSES
            break;
          case 'category':
            // Category descriptions can be in SORTS, DONS, or OBJETS
            if (session.categoryType === 'don') {
              jsonCategory = 'DONS';
            } else if (session.categoryType === 'spell') {
              jsonCategory = 'SORTS';
            } else {
              // Default to OBJETS for other category descriptions
              jsonCategory = 'OBJETS';
            }
            break;
          case 'objet':
            jsonCategory = 'OBJETS';
            break;
          case 'monster':
            jsonCategory = 'MONSTRES';
            break;
          case 'staticPage':
          case 'generic':
            jsonCategory = 'STATIC_PAGES';
            break;
          default:
            return false;
        }
        
        return this.saveToJson(session, content, jsonCategory);
      } catch (error) {
        console.error('Save error:', error);
        return false;
      }
    }

    // Unified save method that takes a JSON category parameter
    saveToJson(session, content, jsonCategory) {
      const jsonData = window[jsonCategory];
      if (!jsonData) {
        console.error(`JSON category ${jsonCategory} not found`);
        return false;
      }


      // Generic save - find the target object and save the content
      let targetObject = null;
      
      if (session.contentType === 'spell' || session.contentType === 'don') {
        // Find in category -> items structure
        for (const category of jsonData) {
          if (category.nom === session.categoryName) {
            const itemsKey = session.contentType === 'spell' ? 'sorts' : 'dons';
            // Use index-based identification if available, fallback to name-based
            if (session.itemIndex !== undefined && session.itemIndex !== null) {
              const index = parseInt(session.itemIndex, 10);
              targetObject = category[itemsKey]?.[index];
            } else {
              targetObject = category[itemsKey]?.find(item => item.nom === session.itemIdentifier);
            }
            break;
          }
        }
      } else if (session.contentType === 'class') {
        // Find class directly
        targetObject = jsonData.find(c => c.nom === session.itemIdentifier);
      } else if (session.contentType === 'subclass') {
        // Find subclass within a class
        const parentClass = jsonData.find(c => c.nom === session.categoryName);
        if (parentClass?.sousClasses) {
          targetObject = parentClass.sousClasses.find(sc => sc.nom === session.itemIdentifier);
        }
      } else if (session.contentType === 'objet') {
        // Find object directly in the objets array
        targetObject = jsonData.objets?.find(obj => obj.nom === session.itemIdentifier);
      } else if (session.contentType === 'monster') {
        // Find monster directly in the array
        targetObject = jsonData?.find(monster => monster.nom === session.itemIdentifier);
      } else if (session.contentType === 'tableTresor') {
        // Find table tresor directly in the array
        targetObject = jsonData?.tables?.find(table => table.nom === session.itemIdentifier);
      } else if (session.contentType === 'category') {
        // Find category by name and update its description
        targetObject = jsonData.find(category => category.nom === session.categoryName);
      } else if (session.contentType === 'staticPage' || session.contentType === 'generic') {
        return this.saveStaticPageToJson(jsonData, session, content);
      }
      
      if (targetObject) {
        targetObject[session.editSection] = content;
        return true;
      } else {
        return false;
      }
    }


    saveStaticPageToJson(jsonData, session, content) {
      const pageData = jsonData[session.itemIdentifier];
      if (!pageData?.sections) {
        console.error('Page data or sections not found for:', session.itemIdentifier);
        return false;
      }

      // Generic search by section ID or special cases
      const updateSection = (sections) => {
        for (const section of sections) {
          // Direct ID match for content
          if (section.id === session.editSection) {
            section.content = content;
            return true;
          }
          
          // Handle title updates (ID + "-title")
          if (session.editSection.endsWith('-title')) {
            const sectionId = session.editSection.replace('-title', '');
            if (section.id === sectionId) {
              section.title = content;
              return true;
            }
          }
          
          // Handle page title
          if (session.editSection === 'page-title') {
            // Page title is stored in the page data, not sections
            // This will be handled at page level
            return false;
          }
          
          // Handle intro sections
          if (section.type === 'intro' && session.editSection === 'intro') {
            section.content = content;
            return true;
          }

          // Handle nested content arrays (for grid sections)
          if (section.content && Array.isArray(section.content)) {
            if (updateSection(section.content)) {
              return true;
            }
          }
        }
        return false;
      };

      // Special handling for page title
      if (session.editSection === 'page-title') {
        pageData.title = content;
        return true;
      }

      if (updateSection(pageData.sections)) {
        return true;
      }

      console.error('Section not found for editSection:', session.editSection);
      return false;
    }

    // No special processing - everything is just HTML now
    processContentByType(content, fieldConfig) {
      return content;
    }

    // UNIFIED CONTENT RESTORATION - USE THIS FOR ALL CONTENT TYPES
    // This method ensures that HTML content is always properly rendered
    // and prevents HTML tags from being displayed as visible text
    restoreElementContent(session, content) {
      // IMPORTANT: Always use innerHTML to render HTML content properly
      // Never use textContent for edited content as it will show HTML tags
      session.element.innerHTML = content;
      
      // NOTE FOR DEVELOPERS: 
      // - For ANY new content type, use this method instead of direct innerHTML assignment
      // - This prevents the recurring issue of visible HTML tags after editing
      // - ALL content types (static pages, spells, classes, dons) go through this
    }

    resetEditingState(container) {
      const editableElement = container.querySelector('.editable') || container;
      
      // Standard editing cleanup (modal is handled separately)
      editableElement.contentEditable = false;
      // Simplified cleanup to prevent stack overflow
      editableElement.style.background = '';
      editableElement.style.border = '';
      editableElement.style.padding = '';
      editableElement.style.fontFamily = '';
      editableElement.style.whiteSpace = '';
      
      // Reset both container and editable element attributes
      container.dataset.editing = 'false';
      delete container.dataset.originalContent;
      
      // Also reset on the editable element itself in case it's the same
      if (editableElement !== container) {
        editableElement.dataset.editing = 'false';
        delete editableElement.dataset.originalContent;
      }
    }


    decodeHtmlEntities(html) {
      // Decode HTML entities step by step to prevent double-encoding
      let decoded = html
        .replace(/&amp;lt;/g, '<')  // &amp;lt; -> <
        .replace(/&amp;gt;/g, '>')  // &amp;gt; -> >
        .replace(/&lt;/g, '<')     // &lt; -> <
        .replace(/&gt;/g, '>')     // &gt; -> >
        .replace(/&quot;/g, '"')   // &quot; -> "
        .replace(/&#39;/g, "'")    // &#39; -> '
        .replace(/&amp;/g, '&');   // &amp; -> & (do this last)
      return decoded;
    }

    normalizeHTMLContent(html) {
      // SIMPLIFIED VERSION to prevent infinite loops
      // Just return the trimmed HTML without complex transformations
      if (!html || typeof html !== 'string') {
        return '';
      }
      
      // Basic cleanup only - avoid complex regex chains that can loop
      let cleaned = html.trim();
      
      // Only safe, non-recursive replacements
      cleaned = cleaned.replace(/&quot;/g, '"');
      cleaned = cleaned.replace(/&#39;/g, "'");
      cleaned = cleaned.replace(/<br\s*\/?>/gi, '<br>');
      
      return cleaned;
    }

    // Cancel current edit
    cancelCurrentEdit() {
      if (!this.currentEditSession) return false;

      const session = this.currentEditSession;
      // Reset editing state first to avoid interfering with content restoration
      this.resetEditingState(session.container);
      // Restore original content
      this.restoreElementContent(session, session.originalContent);
      this.currentEditSession = null;
      return true;
    }

    // Check if element is currently being edited
    isEditing(element) {
      return element.dataset.editing === 'true';
    }

    // Save all active edits
    saveAllEdits() {
      if (this.currentEditSession) {
        this.saveCurrentEdit();
      }

      // Handle any remaining editing elements
      document.querySelectorAll('[data-editing="true"]').forEach(element => {
        if (!this.isValidForEdit(element)) {
          this.resetEditingState(element);
        }
      });
    }

    isValidForEdit(element) {
      const context = this.parseEditContext(element);
      return context !== null;
    }

    // Handle tags editing context
    parseTagsEditContext(element, editSection) {
      // Check if we're in an objet card
      const objetCard = element.closest('.card[data-objet-name]');
      if (objetCard) {
        const objetName = objetCard.dataset.objetName;
        const categoryName = objetCard.dataset.categoryName;
        
        return {
          contentType: 'objet',
          itemIdentifier: objetName,
          categoryName: categoryName,
          property: 'tags',
          editType: 'tags',
          editSection: 'tags',
          config: window.ContentTypes.objet,
          element: element.classList.contains('editable-tags') ? element : element.querySelector('.editable-tags'),
          container: element
        };
      }
      
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        const editableElement = element.classList.contains('editable-tags') ? element : element.querySelector('.editable-tags');
        
        // Use data-item-identifier if available, otherwise fall back to monsterName
        const itemIdentifier = editableElement?.dataset?.itemIdentifier || monsterName;
        
        return {
          contentType: 'monster',
          itemIdentifier: itemIdentifier,
          categoryName: categoryName || 'monstres',
          property: 'tags',
          editType: 'tags',
          editSection: 'tags',
          config: window.ContentTypes.monster,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a table de trésor card
      const tableTresorCard = element.closest('.card[data-table-tresor-name]');
      if (tableTresorCard) {
        const tableTresorName = tableTresorCard.dataset.tableTresorName;
        const categoryName = tableTresorCard.dataset.categoryName || 'tables';
        
        const editableElement = element.classList.contains('editable-tags') ? element : element.querySelector('.editable-tags');
        
        // Use data-item-identifier if available, otherwise fall back to tableTresorName
        const itemIdentifier = editableElement?.dataset?.itemIdentifier || tableTresorName;
        
        return {
          contentType: 'tableTresor',
          itemIdentifier: itemIdentifier,
          categoryName: categoryName,
          property: 'tags',
          editType: 'tags',
          editSection: 'tags',
          config: window.ContentTypes.tableTresor,
          element: editableElement,
          container: element
        };
      }
      
      return null;
    }

    // Force reset of all elements that might be stuck in editing mode
    forceResetAllEditingElements() {
      // Reset any elements with contenteditable=true
      const editableElements = document.querySelectorAll('[contenteditable="true"]');
      editableElements.forEach(element => {
        element.contentEditable = false;
        element.style.background = '';
        element.style.border = '';
        element.style.padding = '';
        element.style.borderRadius = '';
        element.style.fontFamily = '';
        element.style.whiteSpace = '';
      });
      
      // Reset any containers with data-editing=true
      const editingContainers = document.querySelectorAll('[data-editing="true"]');
      editingContainers.forEach(container => {
        container.dataset.editing = 'false';
        delete container.dataset.originalContent;
      });
      
      // Clear any current edit session
      this.currentEditSession = null;
    }

    // Main entry point for starting edit
    startEdit(element) {
      // Force reset of any stuck editing elements first
      this.forceResetAllEditingElements();
      
      // Cancel any existing edit first
      if (this.currentEditSession) {
        this.saveCurrentEdit();
      }

      const context = this.parseEditContext(element);
      if (!context) {
        return false;
      }

      // Handle tags editing differently - show modal instead of inline editing
      if (context.editType === 'tags') {
        this.startTagsEdit(context);
        return true;
      }

      // Handle select editing differently - show dropdown instead of inline editing
      if (context.editType === 'select') {
        this.startSelectEdit(context);
        return true;
      }

      // Start normal inline editing
      return this.startInlineEdit(context);
    }

    // Start inline editing (for non-tags content)
    startInlineEdit(context) {
      const element = context.element;
      const container = context.container;

      // Store original content
      const originalContent = element.innerHTML;
      
      // Create edit session
      this.currentEditSession = {
        ...context,
        originalContent: originalContent
      };

      // Set up editing state
      container.dataset.editing = 'true';
      container.dataset.originalContent = originalContent;
      
      // Decode any encoded HTML before showing for editing
      const decodedHtml = this.decodeHtmlEntities(originalContent);
      element.innerHTML = decodedHtml;
      
      // Always use modal editing for consistency
      // Force modal editing for all content types to ensure uniform behavior
      this.showHTMLEditModal(element, decodedHtml);

      return true;
    }

    // Save current edit
    saveCurrentEdit() {
      if (!this.currentEditSession) return false;

      const session = this.currentEditSession;
      const element = session.element;
      const newContent = element.innerHTML.trim();
      
      // Normalize and clean HTML content
      const processedContent = this.normalizeHTMLContent(newContent);
      
      // Apply changes to data structure
      const success = this.updateContentInDataStructure(session, processedContent);
      
      if (success) {
        // Update display
        this.restoreElementContent(session, processedContent);
        
        // Note: Storage save is handled elsewhere to prevent loops
        // Show success notification
        if (JdrApp.modules.ui?.showNotification) {
          JdrApp.modules.ui.showNotification('💾 Modification sauvegardée', 'success');
        }
      } else {
        console.error('Failed to save edit:', session);
      }
      
      // Reset editing state
      this.resetEditingState(session.container);
      this.currentEditSession = null;
      
      return success;
    }

    // Show modal for editing HTML content
    showHTMLEditModal(element, htmlContent) {
      // Store the current edit session for later use
      const editSession = this.currentEditSession;
      
      const modal = document.createElement('dialog');
      modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 0;
        border: none;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        max-width: 80vw;
        max-height: 80vh;
        z-index: 1000000 !important;
        background: transparent;
      `;

      // Créer un backdrop manuel
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999999 !important;
        backdrop-filter: blur(4px);
      `;

      modal.innerHTML = `
        <div style="background: var(--paper); border-radius: 12px; padding: 1.5rem; border: 2px solid var(--rule); max-height: 80vh; overflow-y: auto; display: flex; flex-direction: column;">
          <h3 style="margin: 0 0 1rem 0; color: var(--accent-ink); flex-shrink: 0;">Édition du contenu</h3>
          
          <div style="margin-bottom: 1rem; flex-shrink: 0;">
            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Aperçu du rendu:</label>
            <div id="preview" style="border: 1px solid var(--rule); padding: 1rem; border-radius: 6px; background: var(--card); min-height: 60px; max-height: 150px; overflow-y: auto;">
              ${htmlContent}
            </div>
          </div>
          
          <div style="margin-bottom: 1rem; flex: 1; min-height: 0; display: flex; flex-direction: column;">
            <label for="htmlEditor" style="display: block; margin-bottom: 0.5rem; font-weight: 600; flex-shrink: 0;">Code HTML:</label>
            <textarea 
              id="htmlEditor" 
              style="width: 100%; flex: 1; min-height: 200px; padding: 1rem; border: 1px solid var(--rule); border-radius: 6px; font-family: monospace; font-size: 14px; resize: vertical;"
              placeholder="Entrez le HTML ici..."
            >${htmlContent}</textarea>
          </div>
          
          <div style="margin-bottom: 1rem; flex-shrink: 0;">
            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 0.5rem;">
              <button id="elementsBtn" class="btn" style="background: #059669; color: white; font-size: 12px;">🔥 Éléments</button>
              <button id="etatsBtn" class="btn" style="background: #7c2d12; color: white; font-size: 12px;">⚡ États</button>
              <button id="spellLinksBtn" class="btn" style="background: #6b21a8; color: white; font-size: 12px;">🔗 Liens Sorts</button>
              <button id="pageLinksBtn" class="btn" style="background: #1d4ed8; color: white; font-size: 12px;">🔗 Liens Pages</button>
            </div>
            <div style="font-size: 12px; color: var(--paper-muted); line-height: 1.4;">
              💡 <strong>Astuce:</strong> Utilisez ces boutons pour insérer rapidement des éléments, états, liens vers les sorts et liens vers les pages dans votre contenu HTML.
            </div>
          </div>
          
          <div style="display: flex; gap: 1rem; justify-content: flex-end; flex-shrink: 0;">
            <button id="cancelEdit" class="btn" style="background: #6b7280; color: white;">Annuler</button>
            <button id="saveEdit" class="btn" style="background: var(--accent); color: white;">💾 Sauvegarder</button>
          </div>
        </div>
      `;

      document.body.appendChild(backdrop);
      document.body.appendChild(modal);
      modal.show();

      const textarea = modal.querySelector('#htmlEditor');
      const preview = modal.querySelector('#preview');
      const saveBtn = modal.querySelector('#saveEdit');
      const cancelBtn = modal.querySelector('#cancelEdit');
      const elementsBtn = modal.querySelector('#elementsBtn');
      const etatsBtn = modal.querySelector('#etatsBtn');
      const spellLinksBtn = modal.querySelector('#spellLinksBtn');
      const pageLinksBtn = modal.querySelector('#pageLinksBtn');

      // Helper function to insert text at cursor position in textarea
      const insertTextAtCursor = (text) => {
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const currentValue = textarea.value;
        
        textarea.value = currentValue.substring(0, start) + text + currentValue.substring(end);
        textarea.selectionStart = textarea.selectionEnd = start + text.length;
        textarea.focus();
        
        // Update preview
        try {
          preview.innerHTML = textarea.value;
        } catch (e) {
          preview.textContent = 'Aperçu invalide: ' + e.message;
        }
      };

      // Store the insertTextAtCursor function globally so modals can access it
      window.editorInsertTextAtCursor = insertTextAtCursor;

      // Toolbox buttons handlers
      if (elementsBtn) {
        elementsBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showElementsModal) {
            JdrApp.modules.ui.showElementsModal();
          }
        });
      }

      if (etatsBtn) {
        etatsBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showEtatsModal) {
            JdrApp.modules.ui.showEtatsModal();
          }
        });
      }

      if (spellLinksBtn) {
        spellLinksBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showSpellLinksModal) {
            JdrApp.modules.ui.showSpellLinksModal();
          }
        });
      }

      if (pageLinksBtn) {
        pageLinksBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showPageLinksModal) {
            JdrApp.modules.ui.showPageLinksModal();
          }
        });
      }

      // Live preview update with debounce to prevent performance issues
      let previewUpdateTimeout;
      textarea.addEventListener('input', () => {
        clearTimeout(previewUpdateTimeout);
        previewUpdateTimeout = setTimeout(() => {
          try {
            preview.innerHTML = textarea.value;
          } catch (e) {
            preview.textContent = 'Aperçu invalide: ' + e.message;
          }
        }, 300); // 300ms debounce
      });

      // Save handler
      saveBtn.addEventListener('click', () => {
        const newContent = textarea.value.trim();
        const normalizedContent = this.normalizeHTMLContent(newContent);
        
        // Update the element content
        element.innerHTML = normalizedContent;
        
        // Update in data structure using stored session
        const success = this.updateContentInDataStructure(editSession, normalizedContent);
        
        if (success) {
          EventBus.emit(Events.STORAGE_SAVE);
          if (JdrApp.modules.ui?.showNotification) {
            JdrApp.modules.ui.showNotification('💾 Modification sauvegardée', 'success');
          }
        }
        
        // Clean up
        this.resetEditingState(editSession.container);
        this.currentEditSession = null;
        window.editorInsertTextAtCursor = null;
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Cancel handler
      cancelBtn.addEventListener('click', () => {
        this.resetEditingState(editSession.container);
        this.currentEditSession = null;
        window.editorInsertTextAtCursor = null;
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Close on backdrop click
      backdrop.addEventListener('click', () => {
        this.resetEditingState(editSession.container);
        this.currentEditSession = null;
        window.editorInsertTextAtCursor = null;
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Focus textarea
      textarea.focus();
      textarea.select();
    }

    // Handle select editing by toggling display/selector visibility
    startSelectEdit(context) {
      const element = context.element;
      const container = context.container;

      // Store the current edit session
      this.currentEditSession = {
        ...context,
        originalContent: element.value // For select, we store the value, not innerHTML
      };

      // Find the display and selector sections
      const sectionContainer = element.closest('.monster-element-section, .spell-element-section');
      if (!sectionContainer) {
        return false;
      }

      const displaySection = sectionContainer.querySelector('.monster-element-display, .spell-element-display');
      const selectorSection = sectionContainer.querySelector('.monster-element-selector, .spell-element-selector');
      
      if (!displaySection || !selectorSection) {
        return false;
      }

      // Toggle visibility
      displaySection.style.display = 'none';
      selectorSection.style.display = 'block';

      // Set up change listener for the select element
      const selectElement = selectorSection.querySelector('select');
      if (selectElement) {
        selectElement.focus();
        
        // Add event listener for changes
        const changeHandler = () => {
          this.saveSelectEdit(selectElement);
          selectElement.removeEventListener('change', changeHandler);
          selectElement.removeEventListener('blur', blurHandler);
        };

        const blurHandler = () => {
          this.cancelSelectEdit(sectionContainer);
          selectElement.removeEventListener('change', changeHandler);
          selectElement.removeEventListener('blur', blurHandler);
        };

        selectElement.addEventListener('change', changeHandler);
        selectElement.addEventListener('blur', blurHandler);
      }

      return true;
    }

    // Save select edit
    saveSelectEdit(selectElement) {
      if (!this.currentEditSession) return false;

      const newValue = selectElement.value;
      const session = this.currentEditSession;

      // Update the data structure
      const success = this.updateContentInDataStructure(session, newValue);

      if (success) {
        // Update the display immediately
        this.updateElementDisplay(session, newValue);
        
        // Emit storage save event
        EventBus.emit(Events.STORAGE_SAVE);
        
        // Show success notification
        if (JdrApp.modules.ui?.showNotification) {
          JdrApp.modules.ui.showNotification('💾 Élément mis à jour', 'success');
        }
      }

      // Hide selector and show display
      this.resetSelectEdit();
      this.currentEditSession = null;
      return success;
    }

    // Cancel select edit
    cancelSelectEdit(sectionContainer) {
      this.resetSelectEdit();
      this.currentEditSession = null;
    }

    // Reset select edit UI state
    resetSelectEdit() {
      if (!this.currentEditSession) return;

      const element = this.currentEditSession.element;
      const sectionContainer = element.closest('.monster-element-section, .spell-element-section');
      if (!sectionContainer) return;

      const displaySection = sectionContainer.querySelector('.monster-element-display, .spell-element-display');
      const selectorSection = sectionContainer.querySelector('.monster-element-selector, .spell-element-selector');
      
      if (displaySection && selectorSection) {
        displaySection.style.display = 'block';
        selectorSection.style.display = 'none';
      }
    }

    // Update element display after selection change
    updateElementDisplay(session, newValue) {
      const element = session.element;
      const sectionContainer = element.closest('.monster-element-section, .spell-element-section');
      if (!sectionContainer) return;

      const displaySection = sectionContainer.querySelector('.monster-element-display, .spell-element-display');
      const badge = displaySection?.querySelector('.element-badge');
      
      if (badge) {
        // Get element icon and color
        const icon = window.ElementIcons?.[newValue] || '⚡';
        const color = window.ElementColors?.[newValue]?.color || '#666';
        
        // Update the badge content and style
        if (session.contentType === 'monster') {
          // For monsters, we need to update the complete badge styling
          const iconSpan = badge.querySelector('span:first-child');
          const textSpan = badge.querySelector('span:last-child');
          if (iconSpan && textSpan) {
            iconSpan.textContent = icon;
            textSpan.textContent = newValue;
            textSpan.style.color = color;
            
            // Update the complete badge background and border
            const hexColor = color;
            const rgbMatch = hexColor.match(/^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
            if (rgbMatch) {
              const r = parseInt(rgbMatch[1], 16);
              const g = parseInt(rgbMatch[2], 16);
              const b = parseInt(rgbMatch[3], 16);
              badge.style.background = `rgba(${r}, ${g}, ${b}, 0.1)`;
              badge.style.border = `1px solid ${hexColor}`;
            }
          }
        } else if (session.contentType === 'spell') {
          // Update spell badge
          badge.innerHTML = `${icon} ${newValue}`;
        }
      }
    }

    // Handle tags editing by showing modal
    startTagsEdit(context) {
      // For tags, we don't do inline editing, we show a modal
      this.showTagsModal(context);
    }

    // Show tags editing modal
    showTagsModal(context) {
      // Find the target item (object or monster)
      let targetItem = null;
      let availableTags = [];
      
      if (context.contentType === 'objet') {
        const allObjects = window.OBJETS?.objets || [];
        targetItem = allObjects.find(o => o.nom === context.itemIdentifier);
        availableTags = window.ContentTypes.objet.filterConfig.availableTags || [];
      } else if (context.contentType === 'monster') {
        const allMonsters = window.MONSTRES || [];
        targetItem = allMonsters.find(m => m.nom === context.itemIdentifier);
        availableTags = window.ContentTypes.monster.filterConfig.availableTags || [];
      } else if (context.contentType === 'tableTresor') {
        const allTables = window.TABLES_TRESORS?.tables || [];
        targetItem = allTables.find(t => t.nom === context.itemIdentifier);
        // Use metadata as primary source, fallback to ContentTypes config
        availableTags = window.TABLES_TRESORS?._metadata?.availableTags || 
                       window.ContentTypes.tableTresor?.filterConfig?.availableTags || [];
      }
      
      if (!targetItem) {
        console.error('Item not found for tags editing:', context.itemIdentifier, 'Type:', context.contentType);
        return;
      }

      const itemTags = targetItem.tags || [];

      // Remove existing modal if any
      const existingModal = document.querySelector('#tagsEditModal');
      if (existingModal) {
        existingModal.remove();
      }

      // Create modal
      const modal = document.createElement('dialog');
      modal.id = 'tagsEditModal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        padding: 0;
        border: none;
        border-radius: 12px;
        background: transparent;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      `;
      
      const tagsCheckboxes = availableTags.map(tag => {
        const isSelected = itemTags.includes(tag);
        return `
          <div style="display: flex; align-items: center; gap: 0.5rem; margin: 0.5rem 0; padding: 0.5rem; background: var(--card); border-radius: 8px;">
            <input 
              type="checkbox" 
              id="tag-${tag}" 
              value="${tag}" 
              ${isSelected ? 'checked' : ''}
              style="margin: 0;"
            >
            <label for="tag-${tag}" style="flex: 1; cursor: pointer; font-weight: 500;">
              <span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 0.5rem;">${tag}</span>
              ${tag}
            </label>
          </div>
        `;
      }).join('');

      modal.innerHTML = `
        <div style="background: var(--paper); border-radius: 12px; padding: 1.5rem; border: 2px solid var(--rule);">
          <h3 style="margin: 0 0 1rem 0; color: var(--accent-ink);">Édition des tags - ${targetItem.nom}</h3>
          <p style="margin: 0 0 1rem 0; color: var(--paper-muted);">Sélectionnez les tags pour cet objet :</p>
          <div id="tagsCheckboxes" style="margin: 1rem 0; max-height: 300px; overflow-y: auto;">
            ${tagsCheckboxes}
          </div>
          <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem;">
            <button class="btn" id="saveTagsBtn" style="background: var(--accent); color: white;">
              💾 Sauvegarder
            </button>
            <button class="btn modal-close" style="background: #666; color: white;">
              ❌ Annuler
            </button>
          </div>
        </div>
      `;

      // Add event listeners
      modal.addEventListener('click', (e) => {
        if (e.target.id === 'saveTagsBtn') {
          this.saveTagsFromModal(modal, targetItem, context);
        } else if (e.target.classList.contains('modal-close')) {
          modal.close();
          modal.remove();
        }
      });

      // Handle dialog close events
      modal.addEventListener('cancel', () => {
        modal.close();
        modal.remove();
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.close();
          modal.remove();
        }
      });

      document.body.appendChild(modal);
      modal.showModal();
    }

    // Save tags from modal
    saveTagsFromModal(modal, obj, context) {
      // Get selected tags
      const checkboxes = modal.querySelectorAll('input[type="checkbox"]:checked');
      const selectedTags = Array.from(checkboxes).map(cb => cb.value);

      if (selectedTags.length === 0) {
        JdrApp.modules.ui.showNotification('❌ Veuillez sélectionner au moins un tag', 'error');
        return;
      }

      // Update tags for the target item (works for both objects and monsters)
      obj.tags = selectedTags;

      // Update the display immediately
      const tagDisplay = context.element;
      if (tagDisplay) {
        const tagsDisplayHTML = selectedTags.map(tag => 
          `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`
        ).join('');
        tagDisplay.innerHTML = tagsDisplayHTML;
      }

      // Trigger save to storage
      EventBus.emit(Events.STORAGE_SAVE);
      
      // Close modal
      modal.close();
      modal.remove();
      
      JdrApp.modules.ui.showNotification(`💾 Tags sauvegardés pour "${obj.nom}"`, 'success');
    }

    // Create backup of monster data for recovery
    createMonsterBackup(monster) {
      try {
        if (!window.MonsterBackups) {
          window.MonsterBackups = new Map();
        }
        
        // Keep only last MAX_MONSTER_BACKUPS backups per monster
        const backupKey = monster.nom;
        const currentBackups = window.MonsterBackups.get(backupKey) || [];
        
        const backup = {
          timestamp: Date.now(),
          data: JSON.parse(JSON.stringify(monster)) // Deep copy
        };
        
        currentBackups.push(backup);
        const maxBackups = window.DEFAULT_VALUES?.MAX_MONSTER_BACKUPS || 10;
        if (currentBackups.length > maxBackups) {
          currentBackups.shift(); // Remove oldest
        }
        
        window.MonsterBackups.set(backupKey, currentBackups);
        
      } catch (error) {
        // Ignore backup failures - not critical
      }
    }

    // Recover monster from backup
    recoverMonsterFromBackup(monsterName, backupIndex = 0) {
      try {
        if (!window.MonsterBackups || !window.MonsterBackups.has(monsterName)) {
          console.error('No backup found for monster:', monsterName);
          return false;
        }
        
        const backups = window.MonsterBackups.get(monsterName);
        const backup = backups[backups.length - 1 - backupIndex]; // Get latest by default
        
        if (!backup) {
          console.error('Backup index out of range for monster:', monsterName);
          return false;
        }
        
        // Find monster in current data
        const monster = window.MONSTRES?.find(m => m.nom === monsterName);
        if (!monster) {
          console.error('Monster not found in current data:', monsterName);
          return false;
        }
        
        // Restore data
        Object.assign(monster, backup.data);
        
        // Force sync
        const contentFactory = window.ContentFactory?.getInstance ? window.ContentFactory.getInstance() : null;
        if (contentFactory && contentFactory.refreshData) {
          contentFactory.refreshData();
        }
        
        return true;
        
      } catch (error) {
        console.error('Failed to recover monster from backup:', error);
        return false;
      }
    }

    // Global validation and repair of monster data
    validateAndRepairMonsterData() {
      if (!window.MONSTRES || !Array.isArray(window.MONSTRES)) {
        return 0;
      }
      
      let repairCount = 0;
      const contentTypes = window.ContentTypes?.monster;
      
      window.MONSTRES.forEach((monster, index) => {
        // Ensure required properties exist
        if (!monster.nom) {
          monster.nom = `Monstre ${index + 1}`;
          repairCount++;
        }
        
        // Validate numeric properties
        if (contentTypes && contentTypes.fields) {
          Object.entries(contentTypes.fields).forEach(([fieldName, fieldConfig]) => {
            if (fieldConfig.type === 'number') {
              if (typeof monster[fieldName] !== 'number' || isNaN(monster[fieldName])) {
                const defaultValue = contentTypes.defaultValues?.[fieldName] || 0;
                monster[fieldName] = defaultValue;
                repairCount++;
              }
            }
          });
        }
        
        // Ensure image path exists and is valid
        if (!monster.image || typeof monster.image !== 'string') {
          monster.image = `data/images/Monstres/foret/Monstre_Forêt_${monster.nom.replace(/[^a-zA-Z0-9]/g, '')}.png`;
          repairCount++;
        }
        
        // Validate image mapping exists
        if (JdrApp.modules.images) {
          const imageKey = `monster:${monster.nom}`;
          if (!JdrApp.modules.images.getImageUrl(imageKey)) {
            JdrApp.modules.images.setImage(imageKey, monster.image);
          }
        }
      });
      
      if (repairCount > 0) {
        // Save repaired data
        if (JdrApp.modules.storage && JdrApp.modules.storage.saveChanges) {
          JdrApp.modules.storage.saveChanges(true);
        }
      }
      
      return repairCount;
    }
    
    // Update static page data method
    updateStaticPageData(session, content) {
      try {
        const pageId = session.itemIdentifier;
        const editSection = session.editSection;
        
        // Get the static page data
        const staticPageData = window.STATIC_PAGES?.[pageId];
        if (!staticPageData) {
          console.error('Static page not found:', pageId);
          return false;
        }
        
        // Handle different edit section formats
        if (editSection.startsWith('intro-')) {
          // Editing intro section
          const sectionIndex = parseInt(editSection.split('-')[1]);
          if (staticPageData.sections && staticPageData.sections[sectionIndex] && staticPageData.sections[sectionIndex].type === 'intro') {
            staticPageData.sections[sectionIndex].content = content;
          }
        } else if (editSection === 'page-title') {
          // Editing page title
          staticPageData.title = content;
        } else if (editSection.endsWith('-title')) {
          // Editing card title (e.g., "dieux-new-2-1756899335313-title")
          const cardId = editSection.slice(0, -6); // Remove "-title"
          const cardSection = staticPageData.sections?.find(s => s.id === cardId);
          if (cardSection) {
            cardSection.title = content;
          }
        } else {
          // Editing card content (e.g., "dieux-new-2-1756899335313")
          const cardSection = staticPageData.sections?.find(s => s.id === editSection);
          if (cardSection) {
            cardSection.content = content;
          } else {
            console.warn('Unhandled static page edit section:', editSection);
            return false;
          }
        }
        
        return true;
        
      } catch (error) {
        console.error('Failed to update static page data:', error);
        return false;
      }
    }

    // Campaign and sub-page data update method
    updateCampaignData(type, campaignName, property, content, subPageName = null) {
      try {
        // Get the campaign data from the static pages
        const campagneData = window.STATIC_PAGES?.campagne;
        if (!campagneData || !campagneData.subPages) {
          return false;
        }
        
        if (type === 'campaign') {
          // Update campaign property (name or description)
          if (!campagneData.subPages[campaignName]) {
            return false;
          }
          
          if (property === 'name') {
            // Renaming a campaign requires more complex handling
            // For now, just update the description property
            return false;
          } else if (property === 'description') {
            campagneData.subPages[campaignName].description = content;
          }
        } else if (type === 'subpage') {
          // Update sub-page property (title or content)
          if (!campagneData.subPages[campaignName] || !campagneData.subPages[campaignName].subPages || !subPageName) {
            return false;
          }
          
          const subPage = campagneData.subPages[campaignName].subPages[subPageName];
          if (!subPage) {
            return false;
          }
          
          if (property === 'title') {
            subPage.title = content;
          } else if (property === 'content') {
            subPage.content = content;
          }
        }
        
        // Direct save to avoid infinite loop from STORAGE_SAVE event
        try {
          if (JdrApp?.modules?.storage?.saveChanges) {
            JdrApp.modules.storage.saveChanges(true); // Silent save
          }
        } catch (saveError) {
          // Ignore save errors - data is still updated in memory
        }
        
        return true;
        
      } catch (error) {
        console.error('Failed to update campaign data:', error);
        return false;
      }
    }
  }

  window.UnifiedEditor = UnifiedEditor.getInstance();

})();
// ============================================================================
// JDR-BAB APPLICATION - EDITOR MODULE (REFACTORED)
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // EDITOR MODULE - Now uses UnifiedEditor
  // ========================================
  JdrApp.modules.editor = {
    editedData: {},
    isDevMode: false,

    init() {
      this.setupEventListeners();
      this.setupEditableHandlers();
      this.setupCreationHandlers();
      this.setupImageHandlers();
      this.updateDevModeState();
    },

    setupEventListeners() {
      JdrApp.utils.events.register('click', '#devToggle', () => this.toggleDevMode());

      EventBus.on(Events.EDITOR_TOGGLE, (payload) => {
        this.isDevMode = payload.enabled;
        this.updateDevModeState();
      });

      EventBus.on(Events.CONTENT_UPDATE, () => {
        this.saveChangesToStorage();
      });

    },

    toggleDevMode() {
      if (window.STANDALONE_VERSION) return;
      
      this.isDevMode = !this.isDevMode;
      EventBus.emit(Events.EDITOR_TOGGLE, { enabled: this.isDevMode });
    },

    updateDevModeState() {
      if (window.STANDALONE_VERSION) {
        document.body.className = 'dev-off';
        this.forceHideAllEditButtons();
        return;
      }
      
      document.body.classList.toggle('dev-on', this.isDevMode);
      document.body.classList.toggle('dev-off', !this.isDevMode);
      
      const devToggle = document.querySelector('#devToggle');
      const devToolbox = document.querySelector('#devToolbox');
      
      if (devToggle) {
        devToggle.textContent = `🛠 Dev Mode: ${this.isDevMode ? 'ON' : 'OFF'}`;
      }
      
      if (devToolbox) {
        devToolbox.style.display = this.isDevMode ? 'block' : 'none';
      }
      
      // Update dev-only containers visibility - same approach as modal buttons
      const devOnlyElements = document.querySelectorAll('[data-dev-only]');
      devOnlyElements.forEach(element => {
        element.style.display = this.isDevMode ? 'block' : 'none';
      });
      
      if (this.isDevMode) {
        this.forceShowAllEditButtons();
      } else {
        this.forceHideAllEditButtons();
      }

      // Regenerate monsters page if currently viewing it
      const currentPage = window.location.hash.replace('#/', '');
      if (currentPage === 'monstres' && JdrApp.modules.renderer && JdrApp.modules.renderer.populateMonstersPage) {
        setTimeout(() => {
          JdrApp.modules.renderer.populateMonstersPage();
        }, 100);
      }
    },

    forceHideAllEditButtons() {
      if (this.isDevMode) {
        return;
      }
      
      const selectors = [
        '.edit-btn', '[class$="-add"]', '[class$="-delete"]', '[class*="-move-"]',
        '.section-delete', '.remove-section-btn', '.add-paragraph-btn', 
        '.add-subclass-btn', '.delete-subclass-btn',
        '.spell-delete', '.don-delete', // Explicit delete buttons
        '.illus .up', '.illus .rm', '.illus label', '.illus input[type="file"]',
        '.tags-manager-btn', '.filter-manager-btn' // Tags and filter manager buttons
      ];
      
      selectors.forEach(selector => {
        document.querySelectorAll(selector).forEach(element => {
          element.style.display = 'none';
          element.style.visibility = 'hidden';
          element.setAttribute('aria-hidden', 'true');
        });
      });
    },
    
    forceShowAllEditButtons() {
      if (!this.isDevMode) return;
      
      // Ensure body has the correct classes
      document.body.classList.add('dev-on');
      document.body.classList.remove('dev-off');
      
      // Force reset all CSS properties that might be causing 0x0 dimensions
      const selectors = [
        '.edit-btn', '[class$="-add"]', '[class$="-delete"]', '[class*="-move-"]',
        '.section-delete', '.remove-section-btn', '.add-paragraph-btn', 
        '.add-subclass-btn', '.delete-subclass-btn',
        '.spell-delete', '.don-delete', '.objet-delete',
        '.spell-add', '.don-add', '.objet-add',
        '.illus .up', '.illus .rm', '.illus label', '.illus input[type="file"]',
        '.tags-manager-btn', '.filter-manager-btn' // Tags and filter manager buttons
      ];
      
      selectors.forEach(selector => {
        document.querySelectorAll(selector).forEach(element => {
          // Force reset all dimension properties
          element.style.removeProperty('display');
          element.style.removeProperty('visibility');
          element.style.removeProperty('opacity');
          element.style.removeProperty('width');
          element.style.removeProperty('height');
          element.style.removeProperty('min-width');
          element.style.removeProperty('min-height');
          element.style.removeProperty('pointer-events');
          element.removeAttribute('aria-hidden');
          
          // Let CSS handle the styling
          element.style.display = '';
          element.style.visibility = '';
        });
      });
    },

    setupEditableHandlers() {
      // Unified edit button handler
      JdrApp.utils.events.register('click', '.edit-btn', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!this.isDevMode) return;
        
        // Prevent multiple edit sessions
        if (UnifiedEditor.currentEditSession) {
          console.warn('Another edit session is already active');
          return;
        }
        
        // Find the editable element near the button
        let editableElement = e.target.previousElementSibling;
        
        // If not found as previous sibling, look in parent
        if (!editableElement || !editableElement.classList.contains('editable')) {
          const parent = e.target.parentElement;
          editableElement = parent.querySelector('.editable');
        }
        
        // Fallback: look for closest editable element
        if (!editableElement || !editableElement.classList.contains('editable')) {
          editableElement = e.target.closest('.editable-section')?.querySelector('.editable') ||
                           e.target.closest('.card')?.querySelector('.editable');
        }
        
        if (editableElement && editableElement.classList.contains('editable')) {
          UnifiedEditor.startEdit(editableElement);
        } else {
          console.warn('No editable element found for edit button');
        }
      });

      // Handle select element changes directly
      JdrApp.utils.events.register('change', '.editable[data-edit-type="select"]', (e) => {
        if (!this.isDevMode) return;
        
        const selectElement = e.target;
        const newValue = selectElement.value;
        
        // Parse context and save immediately
        const context = UnifiedEditor.parseEditContext(selectElement);
        if (context) {
          // Update the data structure
          const success = UnifiedEditor.updateContentInDataStructure(context, newValue);
          if (success) {
            // Update display
            UnifiedEditor.updateElementDisplay(context, newValue);
            
            // Save to storage
            EventBus.emit(Events.STORAGE_SAVE);
            
            // Show notification
            if (JdrApp.modules.ui?.showNotification) {
              JdrApp.modules.ui.showNotification('💾 Élément mis à jour', 'success');
            }
          }
        }
      });

      // Click outside to save
      JdrApp.utils.events.register('click', 'body', (e) => {
        if (!e.target.closest('.editable') && !e.target.matches('.edit-btn')) {
          UnifiedEditor.saveAllEdits();
        }
      });

      // Keyboard shortcuts
      JdrApp.utils.events.register('keydown', '.editable', (e) => {
        if ((e.key === 'Enter' && !e.shiftKey) || e.key === 'Escape') {
          e.preventDefault();
          UnifiedEditor.saveCurrentEdit();
        }
      });

      // Prevent double-click editing (force button-only editing)
      JdrApp.utils.events.register('dblclick', '.editable', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      });
    },

    setupCreationHandlers() {
      // Unified subclass management
      JdrApp.utils.events.register('click', '.add-subclass-btn', (e) => {
        if (!this.isDevMode) return;
        this.addNewSubclass(e.target);
      });

      JdrApp.utils.events.register('click', '.delete-subclass-btn', (e) => {
        if (!this.isDevMode) return;
        this.deleteSubclass(e.target);
      });
    },

    addNewSubclass(button) {
      const article = button.closest('article');
      if (!article) return;
      
      let className = article.dataset.pageTitle;
      if (!className) {
        const hash = window.location.hash.match(/#\/([^\/]+)/);
        if (hash) {
          className = hash[1].charAt(0).toUpperCase() + hash[1].slice(1);
        }
      }
      
      console.log('Adding subclass to class:', className);
      
      if (!className || !window.CLASSES) {
        console.log('Missing className or CLASSES:', { className, hasClasses: !!window.CLASSES });
        return;
      }
      
      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe) {
        console.log('Class not found:', className);
        console.log('Available classes:', window.CLASSES.map(c => c.nom));
        return;
      }
      
      const config = window.ContentTypes.subclass;
      const newSubclass = { ...config.defaultValues };
      
      console.log('Creating new subclass:', newSubclass);
      
      if (!classe.sousClasses) classe.sousClasses = [];
      classe.sousClasses.push(newSubclass);
      
      console.log('Class after adding subclass:', classe);
      
      EventBus.emit(Events.CONTENT_ADD, {
        type: 'subclass',
        category: className,
        item: newSubclass
      });
      
      // Recharger juste le contenu de l'article au lieu de toute la page
      this.reloadClassPage(className);
    },

    deleteSubclass(button) {
      const className = button.dataset.className;
      const subclassName = button.dataset.subclassName;
      
      if (!className || !subclassName) return;
      if (!confirm(`Êtes-vous sûr de vouloir supprimer la sous-classe "${subclassName}" ?`)) return;

      const classe = window.CLASSES?.find(c => c.nom === className);
      if (!classe?.sousClasses) return;

      const index = classe.sousClasses.findIndex(sc => sc.nom === subclassName);
      if (index === -1) return;

      const deletedSubclass = classe.sousClasses.splice(index, 1)[0];
      
      EventBus.emit(Events.CONTENT_DELETE, {
        type: 'subclass',
        category: className,
        item: deletedSubclass
      });
      
      // Recharger juste le contenu de l'article au lieu de toute la page  
      this.reloadClassPage(className);
    },

    reloadClassPage(className) {
      // Trouver l'article de la classe
      const article = document.querySelector(`article[data-page-title="${className}"]`);
      if (!article) return;

      // Régénérer le contenu de la classe
      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe) return;

      // Vérifier que PageBuilder existe
      if (!window.PageBuilder) {
        console.error('PageBuilder not available, falling back to page reload');
        window.location.reload();
        return;
      }

      // Utiliser PageBuilder pour régénérer le contenu
      const newContent = window.PageBuilder.buildClassPage(classe);
      const parser = new DOMParser();
      const newDoc = parser.parseFromString(newContent, 'text/html');
      const newArticle = newDoc.querySelector('article');
      
      if (newArticle) {
        article.innerHTML = newArticle.innerHTML;
        
        // Réappliquer les images et l'état de dev mode
        setTimeout(() => {
          if (JdrApp.modules.renderer?.autoLoadImages) {
            JdrApp.modules.renderer.autoLoadImages();
          }
          // Apply dev mode state properly
          if (this.isDevMode) {
            this.forceShowAllEditButtons();
          } else {
            this.forceHideAllEditButtons();
          }
        }, 50);
      }
    },

    setupImageHandlers() {
      // Fonction pour attacher les événements aux images existantes
      this.attachImageEvents();
      
      // Observer pour attacher les événements aux nouvelles images créées dynamiquement
      if (typeof MutationObserver !== 'undefined') {
        const observer = new MutationObserver(() => {
          this.attachImageEvents();
        });
        observer.observe(document.body, { childList: true, subtree: true });
      }
    },

    attachImageEvents() {
      // Attacher aux inputs de fichier
      document.querySelectorAll('.illus input[type="file"]').forEach(input => {
        if (!input.hasAttribute('data-events-attached')) {
          input.addEventListener('change', (e) => this.handleImageUpload(e));
          input.setAttribute('data-events-attached', 'true');
        }
      });

      // Attacher aux boutons de suppression
      document.querySelectorAll('.illus .rm').forEach(button => {
        if (!button.hasAttribute('data-events-attached')) {
          button.addEventListener('click', (e) => this.handleImageRemoval(e));
          button.setAttribute('data-events-attached', 'true');
        }
      });

      // Attacher aux images pour agrandissement - toutes les images, pas seulement celles dans .illus
      document.querySelectorAll('img').forEach(img => {
        // Éviter les images dans les éditeurs ou les inputs
        if (!img.closest('.editor-content') && !img.hasAttribute('data-events-attached')) {
          // Ajouter support tactile pour mobile
          img.addEventListener('click', (e) => this.toggleImageEnlargement(e.target));
          img.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.toggleImageEnlargement(e.target);
          });
          img.setAttribute('data-events-attached', 'true');
          img.style.cursor = 'zoom-in';
        }
      });
    },

    handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const illus = event.target.closest('.illus');
        const img = illus.querySelector('img');
        const rmButton = illus.querySelector('.rm');
        const illusKey = illus.dataset.illusKey;

        img.src = e.target.result;
        img.style.display = 'block';
        if (rmButton) rmButton.style.display = 'block';

        if (JdrApp.modules.images?.setImageUrl) {
          JdrApp.modules.images.setImageUrl(illusKey, e.target.result);
        }

        EventBus.emit(Events.IMAGE_UPLOAD, { 
          illusKey, 
          src: e.target.result 
        });
      };
      
      reader.readAsDataURL(file);
    },

    handleImageRemoval(event) {
      const illus = event.target.closest('.illus');
      const img = illus.querySelector('img');
      const rmButton = illus.querySelector('.rm');
      const illusKey = illus.dataset.illusKey;

      img.src = '';
      img.style.display = 'none';
      if (rmButton) rmButton.style.display = 'none';

      if (JdrApp.modules.images?.removeImage) {
        JdrApp.modules.images.removeImage(illusKey);
      }

      EventBus.emit(Events.IMAGE_DELETE, { illusKey });
    },

    toggleImageEnlargement(img) {
      if (img.classList.contains('enlarged')) {
        this.closeEnlargedImage();
      } else {
        this.showEnlargedImage(img);
      }
    },

    showEnlargedImage(img) {
      // Fermer toute image déjà ouverte
      this.closeEnlargedImage();
      
      // Créer un conteneur modal complet
      const modal = document.createElement('div');
      modal.id = 'image-enlargement-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0,0,0,0.8);
        z-index: 2147483647;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: zoom-out;
      `;
      
      // Créer une copie de l'image
      const enlargedImg = img.cloneNode(true);
      enlargedImg.style.cssText = `
        max-width: 90vw;
        max-height: 90vh;
        width: auto;
        height: auto;
        object-fit: contain;
        border: 3px solid var(--gold);
        border-radius: 8px;
        background: white;
        box-shadow: 0 20px 60px rgba(0,0,0,.8), 0 0 20px rgba(212,175,55,.3);
        cursor: zoom-out;
      `;
      
      modal.appendChild(enlargedImg);
      document.body.appendChild(modal);
      
      // Fermer au clic et au touch pour mobile
      modal.onclick = () => this.closeEnlargedImage();
      modal.addEventListener('touchend', (e) => {
        if (e.target === modal) {
          e.preventDefault();
          this.closeEnlargedImage();
        }
      });
      
      // Fermer avec Échap
      const escapeHandler = (e) => {
        if (e.key === 'Escape') {
          this.closeEnlargedImage();
          document.removeEventListener('keydown', escapeHandler);
        }
      };
      document.addEventListener('keydown', escapeHandler);
      
      // Marquer l'image originale comme agrandie
      img.classList.add('enlarged');
    },

    closeEnlargedImage() {
      const modal = document.getElementById('image-enlargement-modal');
      if (modal) {
        modal.remove();
      }
      
      // Retirer la classe de toutes les images
      document.querySelectorAll('img.enlarged').forEach(img => {
        img.classList.remove('enlarged');
      });
      
      // Nettoyer les anciens backdrops
      const oldBackdrop = document.querySelector('.image-backdrop');
      if (oldBackdrop) {
        oldBackdrop.remove();
      }
    },


    saveChangesToStorage() {
      try {
        localStorage.setItem('jdr-bab-edits', JSON.stringify(this.editedData));
        localStorage.setItem('jdr-bab-last-modified', Date.now().toString());
        EventBus.emit(Events.STORAGE_SAVE);
      } catch (error) {
        // Failed to save changes
      }
    },

    forceCollectAllEdits() {
      // Collect page description edits before general edits
      this.collectPageDescriptionEdits();
      UnifiedEditor.saveAllEdits();
      return this.editedData;
    },

    collectPageDescriptionEdits() {
      // Check for edited table tresor page description
      const tablesTresorsDesc = document.querySelector('[data-section-type="table-tresor-category-description"] .editable');
      if (tablesTresorsDesc && tablesTresorsDesc.innerHTML) {
        const content = tablesTresorsDesc.innerHTML.trim();
        if (content && content !== "Tables de butin permettant de générer aléatoirement des récompenses selon les fourchettes définies. Lancez un dé 20 et consultez la table correspondante pour déterminer l'objet obtenu.") {
          if (!window.TABLES_TRESORS_PAGE_DESC) {
            window.TABLES_TRESORS_PAGE_DESC = {};
          }
          window.TABLES_TRESORS_PAGE_DESC.description = content;
          console.log('💾 Collected Tables Tresors page description:', content);
        }
      }

      // Check for edited monster page description
      const monstersDesc = document.querySelector('[data-section-type="monster-category-description"] .editable');
      if (monstersDesc && monstersDesc.innerHTML) {
        const content = monstersDesc.innerHTML.trim();
        if (content && content !== "Créatures, ennemis et adversaires que peuvent affronter les héros dans leurs aventures.") {
          if (!window.MONSTRES_PAGE_DESC) {
            window.MONSTRES_PAGE_DESC = {};
          }
          window.MONSTRES_PAGE_DESC.description = content;
          console.log('💾 Collected Monsters page description:', content);
        }
      }
    },


    saveAllEdits() {
      return UnifiedEditor.saveAllEdits();
    },

    regenerateCurrentPage() {
      // Force regeneration of only the current page content (not all pages)
      if (JdrApp.modules.renderer && JdrApp.modules.renderer.regenerateCurrentPage) {
        JdrApp.modules.renderer.regenerateCurrentPage();
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - SPELL FILTER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // SPELL FILTER MODULE
  // ========================================
  const SpellFilter = {
    
    init() {
      this.setupEventListeners();
    },

    setupEventListeners() {
      // Use direct event delegation on document to catch dynamically added elements
      document.addEventListener('input', (e) => {
        if (e.target && e.target.id === 'spell-level-filter') {
          this.filterSpellsByLevel(parseInt(e.target.value, 10));
        }
      });

      document.addEventListener('click', (e) => {
        if (e.target && e.target.id === 'reset-spell-filter') {
          e.preventDefault();
          this.resetFilter();
        }
      });

      // Setup when page changes (router events)
      if (window.EventBus && window.Events) {
        EventBus.on(Events.PAGE_RENDER, (payload) => {
          if (payload.type === 'category' && payload.categoryType === 'spell') {
            // Re-setup filter after page render
            setTimeout(() => this.initializeFilter(), 200);
          }
        });
      }

      // Also listen to hash changes for direct navigation
      window.addEventListener('hashchange', () => {
        setTimeout(() => this.initializeFilter(), 200);
      });
    },

    initializeFilter() {
      const filterInput = document.querySelector('#spell-level-filter');
      if (!filterInput) return;
      
      
      // Set initial value and apply filter
      const initialValue = parseInt(filterInput.value, 10) || 20;
      this.filterSpellsByLevel(initialValue);
    },

    filterSpellsByLevel(maxLevel) {
      
      // Get current page from URL hash
      const currentHash = window.location.hash.replace('#/', '');
      
      if (!currentHash.startsWith('sorts-')) {
        return;
      }
      
      // Find all spell cards in the current page
      const spellCards = document.querySelectorAll('.card[data-spell-name]');
      
      if (spellCards.length === 0) return;

      let visibleCount = 0;

      spellCards.forEach((card) => {
        const spellName = card.dataset.spellName;
        const categoryName = card.dataset.categoryName;
        
        // Find the spell data to get its level
        const spellLevel = this.getSpellLevel(spellName, categoryName);
        
        if (spellLevel <= maxLevel) {
          card.style.display = '';
          visibleCount++;
        } else {
          card.style.display = 'none';
        }
      });

      
      // Update filter display with count
      this.updateFilterDisplay(maxLevel, visibleCount, spellCards.length);
    },

    getSpellLevel(spellName, categoryName) {
      if (!window.SORTS) return 0;

      // Find the category
      const category = window.SORTS.find(cat => cat.nom === categoryName);
      if (!category || !category.sorts) return 0;

      // Find the spell
      const spell = category.sorts.find(sort => sort.nom === spellName);
      if (!spell || !spell.prerequis) return 0;

      // Extract level from prerequisite
      const match = spell.prerequis.match(/Niveau (\d+)/i);
      return match ? parseInt(match[1], 10) : 0;
    },

    updateFilterDisplay(maxLevel, visibleCount, totalCount) {
      const filterContainer = document.querySelector('.spell-level-filter');
      if (!filterContainer) return;

      // Remove existing count display
      let countDisplay = filterContainer.querySelector('.filter-count');
      if (countDisplay) {
        countDisplay.remove();
      }

      // Add new count display
      const countText = `📊 ${visibleCount}/${totalCount} sorts affichés (niveau ≤ ${maxLevel})`;
      countDisplay = document.createElement('div');
      countDisplay.className = 'filter-count';
      countDisplay.style.cssText = 'margin-top: 0.5rem; font-size: 0.9rem; color: var(--bronze); font-weight: 500;';
      countDisplay.textContent = countText;
      
      filterContainer.appendChild(countDisplay);
    },

    resetFilter() {
      const filterInput = document.querySelector('#spell-level-filter');
      if (filterInput) {
        filterInput.value = '20';
        this.filterSpellsByLevel(20);
      }
    }
  };

  // Initialize the spell filter when the app is ready
  function initializeSpellFilter() {
    
    if (window.JdrApp) {
      if (JdrApp.modules) {
        JdrApp.modules.spellFilter = SpellFilter;
      }
    }
    
    // Initialize the filter
    SpellFilter.init();
    
    // Try to initialize the filter after a delay to ensure DOM is ready
    setTimeout(() => {
      if (window.location.hash.includes('sorts-')) {
        SpellFilter.initializeFilter();
      }
    }, 500);
  }

  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeSpellFilter);
  } else {
    // DOM is already ready
    initializeSpellFilter();
  }

  window.SpellFilter = SpellFilter;

})();
// ============================================================================
// JDR-BAB APPLICATION - TABLES DE TRESORS MANAGER
// ============================================================================

(() => {
  "use strict";

  class TablesTresorsManager {
    constructor() {
      this.initialized = false;
      this.currentPreviewModal = null;
      this.currentEditModal = null;
    }

    static getInstance() {
      if (!TablesTresorsManager.instance) {
        TablesTresorsManager.instance = new TablesTresorsManager();
      }
      return TablesTresorsManager.instance;
    }

    init() {
      if (this.initialized) return;
      
      this.setupEventListeners();
      this.initialized = true;
      // TablesTresorsManager initialized
    }

    setupEventListeners() {
      // Preview d'objets
      document.addEventListener('click', (e) => {
        if (e.target.matches('.object-preview-link')) {
          e.preventDefault();
          const numeroObjet = e.target.dataset.objectNumero;
          this.showObjectPreview(numeroObjet);
        }
      });

      // Édition de fourchette
      document.addEventListener('click', (e) => {
        if (e.target.matches('.edit-fourchette-btn')) {
          const tableName = e.target.dataset.tableName;
          const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
          this.showEditFourchetteModal(tableName, fourchetteIndex);
        }
      });

      // Suppression de fourchette
      document.addEventListener('click', (e) => {
        if (e.target.matches('.delete-fourchette-btn')) {
          const tableName = e.target.dataset.tableName;
          const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
          this.deleteFourchette(tableName, fourchetteIndex);
        }
      });

      // Ajout de nouvelle fourchette
      document.addEventListener('click', (e) => {
        if (e.target.matches('.table-tresor-add-fourchette')) {
          const tableName = e.target.dataset.tableTresorName;
          this.showEditFourchetteModal(tableName, -1); // -1 pour nouvelle fourchette
        }
      });

      // Fermer les modals en cliquant à l'extérieur
      document.addEventListener('click', (e) => {
        if (e.target.matches('.modal-overlay')) {
          this.closeAllModals();
        }
      });

      // Fermer avec la touche Escape
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          this.closeAllModals();
        }
      });
    }

    showObjectPreview(numeroObjet) {
      try {
        // Trouver l'objet par son numéro
        const objet = window.OBJETS?.objets?.find(obj => obj.numero == numeroObjet);
        
        if (!objet) {
          console.error('Objet non trouvé:', numeroObjet);
          return;
        }

        const previewHtml = this.generateObjectPreviewHtml(objet);
        this.showModal(previewHtml, 'object-preview');
        
      } catch (error) {
        console.error('Erreur lors de l\'affichage de la preview:', error);
      }
    }

    generateObjectPreviewHtml(objet) {
      const tagsDisplay = objet.tags?.map(tag => 
        `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`
      ).join('') || 'Aucun tag';

      return `
        <div class="object-preview-content">
          <header style="text-align: center; margin-bottom: 1rem; border-bottom: 2px solid var(--bronze); padding-bottom: 1rem;">
            <h3 style="margin: 0; color: var(--accent);">📦 ${objet.nom}</h3>
            <div style="color: var(--bronze); font-size: 0.9em;">Objet N°${objet.numero}</div>
          </header>
          
          <div style="margin: 1rem 0;">
            <strong>Tags:</strong><br>
            ${tagsDisplay}
          </div>
          
          <div style="margin: 1rem 0;">
            <strong>Description:</strong><br>
            <div style="font-style: italic; margin: 0.5rem 0;">${objet.description || 'Aucune description'}</div>
          </div>
          
          <div style="margin: 1rem 0;">
            <strong>Effet:</strong><br>
            <div>${objet.effet || 'Aucun effet spécifié'}</div>
          </div>
          
          <div style="display: flex; gap: 1rem; margin: 1rem 0;">
            <div style="flex: 1;">
              <strong>Prix:</strong><br>
              ${objet.prix || 'Non spécifié'}
            </div>
            <div style="flex: 1;">
              <strong>Poids:</strong><br>
              ${objet.poids || 'Non spécifié'}
            </div>
          </div>
          
          <div style="text-align: center; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--rule);">
            <button class="btn" onclick="window.TablesTresorsManager.closeAllModals()" style="background: var(--accent); color: white;">
              ✓ Fermer
            </button>
            <button class="btn" onclick="window.TablesTresorsManager.goToObject(${objet.numero})" style="background: var(--bronze); color: white; margin-left: 0.5rem;">
              🔗 Aller à la page objets
            </button>
          </div>
        </div>
      `;
    }

    showEditFourchetteModal(tableName, fourchetteIndex) {
      try {
        const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === tableName);
        if (!table) {
          console.error('Table non trouvée:', tableName);
          return;
        }

        const isNewFourchette = fourchetteIndex === -1;
        const fourchette = isNewFourchette ? { min: 1, max: 1, objet: { type: 'reference', numero: 1, nom: 'Choisir un objet' } } : table.fourchettes[fourchetteIndex];

        if (!isNewFourchette && !fourchette) {
          console.error('Fourchette non trouvée:', fourchetteIndex);
          return;
        }

        const editHtml = this.generateEditFourchetteHtml(tableName, fourchetteIndex, fourchette, isNewFourchette);
        this.showModal(editHtml, 'edit-fourchette');

      } catch (error) {
        console.error('Erreur lors de l\'affichage du modal d\'édition:', error);
      }
    }

    generateEditFourchetteHtml(tableName, fourchetteIndex, fourchette, isNewFourchette) {
      // Générer la liste des objets disponibles
      const objetsOptions = window.OBJETS?.objets?.map(obj => 
        `<option value="${obj.numero}" ${obj.numero == fourchette.objet.numero ? 'selected' : ''}>N°${obj.numero} - ${obj.nom}</option>`
      ).join('') || '<option value="1">Aucun objet disponible</option>';

      return `
        <div class="edit-fourchette-content">
          <header style="text-align: center; margin-bottom: 1rem; border-bottom: 2px solid var(--bronze); padding-bottom: 1rem;">
            <h3 style="margin: 0; color: var(--accent);">
              ${isNewFourchette ? '➕ Ajouter une fourchette' : '✏️ Éditer la fourchette'}
            </h3>
            <div style="color: var(--bronze); font-size: 0.9em;">Table: ${tableName}</div>
          </header>
          
          <form id="edit-fourchette-form">
            <div style="margin: 1rem 0;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: bold; color: var(--accent);">
                🎲 Fourchette de dé (1-20):
              </label>
              <div style="display: flex; gap: 1rem; align-items: center;">
                <div style="flex: 1;">
                  <label style="font-size: 0.9em; color: var(--paper-muted);">Minimum:</label>
                  <input 
                    type="number" 
                    id="fourchette-min" 
                    min="1" 
                    max="20" 
                    value="${fourchette.min}"
                    style="width: 100%; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px;"
                    required
                  >
                </div>
                <div style="padding: 1rem 0.5rem; color: var(--accent); font-weight: bold;">-</div>
                <div style="flex: 1;">
                  <label style="font-size: 0.9em; color: var(--paper-muted);">Maximum:</label>
                  <input 
                    type="number" 
                    id="fourchette-max" 
                    min="1" 
                    max="20" 
                    value="${fourchette.max}"
                    style="width: 100%; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px;"
                    required
                  >
                </div>
              </div>
            </div>
            
            <div style="margin: 1rem 0;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: bold; color: var(--accent);">
                📦 Objet associé:
              </label>
              <select 
                id="fourchette-objet" 
                style="width: 100%; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px;"
                required
              >
                ${objetsOptions}
              </select>
              <div style="margin-top: 0.5rem;">
                <button 
                  type="button" 
                  id="preview-selected-object" 
                  class="btn small" 
                  style="background: var(--bronze); color: white; font-size: 0.8em;"
                >
                  👁️ Aperçu de l'objet sélectionné
                </button>
              </div>
            </div>
            
            <div style="text-align: center; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--rule);">
              <button type="submit" class="btn" style="background: var(--accent); color: white;">
                ${isNewFourchette ? '➕ Ajouter' : '✓ Sauvegarder'}
              </button>
              <button type="button" onclick="window.TablesTresorsManager.closeAllModals()" class="btn" style="background: #6b7280; color: white; margin-left: 0.5rem;">
                ❌ Annuler
              </button>
            </div>
          </form>
        </div>
      `;
    }

    showModal(content, modalClass = '') {
      this.closeAllModals(); // Fermer les modals existants

      const modalHtml = `
        <div class="modal-overlay ${modalClass}" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 1000;">
          <div class="modal-content" style="background: var(--paper); border-radius: 12px; padding: 2rem; max-width: 90vw; max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 25px rgba(0,0,0,0.3); border: 2px solid var(--rule);">
            ${content}
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML('beforeend', modalHtml);
      
      // Setup form handler si c'est le modal d'édition
      if (modalClass === 'edit-fourchette') {
        this.setupEditFormHandlers();
      }
    }

    setupEditFormHandlers() {
      const form = document.getElementById('edit-fourchette-form');
      if (!form) return;

      form.addEventListener('submit', (e) => {
        e.preventDefault();
        this.saveFourchette();
      });

      // Preview de l'objet sélectionné
      const previewBtn = document.getElementById('preview-selected-object');
      if (previewBtn) {
        previewBtn.addEventListener('click', () => {
          const selectElement = document.getElementById('fourchette-objet');
          const selectedNumero = selectElement.value;
          this.showObjectPreview(selectedNumero);
        });
      }

      // Validation en temps réel
      const minInput = document.getElementById('fourchette-min');
      const maxInput = document.getElementById('fourchette-max');
      
      const validateRange = () => {
        const min = parseInt(minInput.value);
        const max = parseInt(maxInput.value);
        
        if (min > max) {
          maxInput.value = min;
        }
      };

      minInput.addEventListener('change', validateRange);
      maxInput.addEventListener('change', validateRange);
    }

    saveFourchette() {
      try {
        const form = document.getElementById('edit-fourchette-form');
        const formData = new FormData(form);
        
        const min = parseInt(document.getElementById('fourchette-min').value);
        const max = parseInt(document.getElementById('fourchette-max').value);
        const objetNumero = parseInt(document.getElementById('fourchette-objet').value);
        
        // Trouver l'objet sélectionné
        const objet = window.OBJETS?.objets?.find(obj => obj.numero === objetNumero);
        if (!objet) {
          alert('Objet sélectionné introuvable');
          return;
        }

        const newFourchette = {
          min: min,
          max: max,
          objet: {
            type: 'reference',
            numero: objet.numero,
            nom: objet.nom
          }
        };

        // Extraire les informations depuis le modal
        const tableName = document.querySelector('.edit-fourchette-content h3 + div').textContent.replace('Table: ', '');
        const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === tableName);
        
        if (!table) {
          console.error('Table non trouvée pour la sauvegarde');
          return;
        }

        // Déterminer si c'est une nouvelle fourchette ou une modification
        const currentModal = document.querySelector('.modal-overlay.edit-fourchette');
        const isNewFourchette = currentModal?.querySelector('h3')?.textContent.includes('Ajouter');

        if (isNewFourchette) {
          table.fourchettes.push(newFourchette);
        } else {
          // Trouver l'index de la fourchette à modifier (pas optimal mais fonctionne)
          // Pour une vraie app, il faudrait passer l'index via les données du modal
          // Mode modification - non implémenté complètement dans cette demo
        }

        // Sauvegarder et regénérer la page
        this.saveToStorage();
        this.refreshTablesTresorsPage();
        this.closeAllModals();
        
        // Fourchette sauvegardée avec succès

      } catch (error) {
        console.error('Erreur lors de la sauvegarde:', error);
        alert('Erreur lors de la sauvegarde de la fourchette');
      }
    }

    deleteFourchette(tableName, fourchetteIndex) {
      if (!confirm('Êtes-vous sûr de vouloir supprimer cette fourchette ?')) {
        return;
      }

      try {
        const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === tableName);
        if (!table) {
          console.error('Table non trouvée:', tableName);
          return;
        }

        if (fourchetteIndex < 0 || fourchetteIndex >= table.fourchettes.length) {
          console.error('Index de fourchette invalide:', fourchetteIndex);
          return;
        }

        table.fourchettes.splice(fourchetteIndex, 1);
        
        this.saveToStorage();
        this.refreshTablesTresorsPage();
        
        // Fourchette supprimée avec succès

      } catch (error) {
        console.error('Erreur lors de la suppression:', error);
        alert('Erreur lors de la suppression de la fourchette');
      }
    }

    goToObject(numeroObjet) {
      this.closeAllModals();
      // Naviguer vers la page objets avec focus sur l'objet spécifique
      JdrApp.modules.router.navigate('objets');
      
      // Optionnel: highlight l'objet après navigation
      setTimeout(() => {
        const objectCard = document.querySelector(`[data-objet-name*="${numeroObjet}"]`);
        if (objectCard) {
          objectCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
          objectCard.style.border = '3px solid var(--accent)';
          setTimeout(() => {
            objectCard.style.border = '';
          }, 2000);
        }
      }, 500);
    }

    closeAllModals() {
      const modals = document.querySelectorAll('.modal-overlay');
      modals.forEach(modal => modal.remove());
      this.currentPreviewModal = null;
      this.currentEditModal = null;
    }

    saveToStorage() {
      // Utiliser le système de stockage existant
      if (JdrApp.modules.storage) {
        JdrApp.modules.storage.save();
      }
    }

    refreshTablesTresorsPage() {
      // Regénérer la page des tables de trésors
      if (JdrApp.modules.router && JdrApp.modules.router.getCurrentRoute() === 'tables-tresors') {
        JdrApp.modules.router.renderTablesTresorsPage();
      }
    }
  }

  // Exposer globalement pour les event handlers inline
  window.TablesTresorsManager = TablesTresorsManager.getInstance();

  // Auto-initialiser quand le DOM est prêt
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => window.TablesTresorsManager.init());
  } else {
    window.TablesTresorsManager.init();
  }

})();
// ============================================================================
// DYNAMIC CENTERING SYSTEM
// ============================================================================

(() => {
  "use strict";

  class DynamicCentering {
    constructor() {
      this.sidebarWidth = 350; // Width of the sidebar
      this.isEnabled = false;
      this.observer = null;
      this.rafId = null;
    }

    init() {
      this.isEnabled = true;
      this.setupResizeObserver();
      this.setupWindowResize();
      // Initial calculation
      this.updateCentering();
    }

    setupResizeObserver() {
      if (!window.ResizeObserver) return;

      // Observe changes to the main content container
      const viewsContainer = document.getElementById('views');
      if (!viewsContainer) return;

      this.observer = new ResizeObserver(() => {
        if (this.rafId) {
          cancelAnimationFrame(this.rafId);
        }
        this.rafId = requestAnimationFrame(() => this.updateCentering());
      });

      this.observer.observe(viewsContainer);
    }

    setupWindowResize() {
      let resizeTimer;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => this.updateCentering(), 100);
      });
    }

    updateCentering() {
      if (!this.isEnabled) return;

      const viewsContainer = document.getElementById('views');
      if (!viewsContainer) return;

      // Get actual container dimensions
      const containerRect = viewsContainer.getBoundingClientRect();
      const actualContentWidth = containerRect.width;
      const viewportWidth = window.innerWidth;

      // Calculate available space after sidebar
      const availableSpace = viewportWidth - this.sidebarWidth;
      
      // Calculate optimal margin to center content in available space
      const optimalMarginLeft = this.sidebarWidth + (availableSpace - actualContentWidth) / 2;

      // Apply the centering with bounds checking
      const minMarginLeft = this.sidebarWidth + 20; // Minimum clearance
      const maxMarginLeft = viewportWidth - actualContentWidth - 20; // Don't overflow right
      
      const finalMarginLeft = Math.max(minMarginLeft, Math.min(optimalMarginLeft, maxMarginLeft));

      // Apply the calculated margin
      viewsContainer.style.marginLeft = `${finalMarginLeft}px`;
      viewsContainer.style.marginRight = '20px';

      // Debug info (remove in production)
      if (window.location.hash.includes('debug-centering')) {
        console.log('🎯 Dynamic Centering:', {
          viewportWidth,
          availableSpace,
          actualContentWidth,
          optimalMarginLeft,
          finalMarginLeft
        });
      }
    }

    disable() {
      this.isEnabled = false;
      if (this.observer) {
        this.observer.disconnect();
      }
      if (this.rafId) {
        cancelAnimationFrame(this.rafId);
      }
      
      // Reset to CSS default
      const viewsContainer = document.getElementById('views');
      if (viewsContainer) {
        viewsContainer.style.marginLeft = '';
        viewsContainer.style.marginRight = '';
      }
    }
  }

  // Initialize the dynamic centering system
  const dynamicCentering = new DynamicCentering();

  // Attach to JdrApp
  if (window.JdrApp) {
    JdrApp.modules.dynamicCentering = dynamicCentering;
  }

  // Auto-initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      // Delay initialization to ensure layout is stable
      setTimeout(() => dynamicCentering.init(), 500);
    });
  } else {
    setTimeout(() => dynamicCentering.init(), 500);
  }

  // Make it globally available for debugging
  window.DynamicCentering = dynamicCentering;

})();
// ============================================================================
// JSPDF LOADER - Character Sheet PDF Generation Support
// ============================================================================

(() => {
  "use strict";

  // Check if jsPDF is already loaded
  if (window.jsPDF) {
    return;
  }

  // For standalone builds, we need to handle jsPDF loading
  const loadJsPDF = () => {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
      script.onload = () => {
        resolve();
      };
      script.onerror = () => {
        console.error('❌ Failed to load jsPDF');
        reject();
      };
      document.head.appendChild(script);
    });
  };

  // Load jsPDF if not available
  if (typeof window.jsPDF === 'undefined') {
    loadJsPDF().catch(() => {
      // Silent fallback - PDF generation will not be available
    });
  }

})();
// ============================================================================
// JDR-BAB APPLICATION - UI MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // UI INTERACTIONS MODULE
  // ========================================
  JdrApp.modules.ui = {
    _initialized: false,
    
    init() {
      // Prevent multiple initialization to avoid duplicate event listeners
      if (this._initialized) {
        return;
      }
      
      this.setupEventListeners();
      this.setupSearch();
      this.setupModals();
      this.setupResponsive();
      this.setupNewPageHandler();
      this._initialized = true;
    },

    setupEventListeners() {
      // Content management via EventBus
      EventBus.on(Events.CONTENT_ADD, (payload) => {
        this.handleContentAdd(payload.type, payload.category, payload.item);
      });

      EventBus.on(Events.CONTENT_DELETE, (payload) => {
        this.handleContentDelete(payload.type, payload.category, payload.item);
      });

      EventBus.on(Events.CONTENT_MOVE, (payload) => {
        this.handleContentMove(payload.type, payload.category, payload.itemName, payload.direction);
      });

      // UI event handlers
      this.setupContentHandlers();
      this.setupTagsManagement();
    },

    setupContentHandlers() {
      // Generic content addition
      JdrApp.utils.events.register('click', '[class$="-add"]', (e) => {
        const type = this.extractTypeFromClass(e.target.className);
        const categoryName = e.target.dataset.categoryName;
        
        if (type && categoryName) {
          this.addContent(type, categoryName);
        }
      });

      // Generic content deletion - using multiple specific selectors
      JdrApp.utils.events.register('click', '.spell-delete, .don-delete, .delete-subclass-btn, .objet-delete, .monster-delete, .tableTresor-delete', (e) => {
        const type = this.extractTypeFromClass(e.target.className);
        const categoryName = e.target.dataset.categoryName;
        
        // Handle different dataset attribute naming patterns
        let itemName;
        if (type === 'spell') {
          itemName = e.target.dataset.spellName;
        } else if (type === 'don') {
          itemName = e.target.dataset.donName;
        } else if (type === 'objet') {
          itemName = e.target.dataset.objetName;
        } else if (type === 'monster') {
          itemName = e.target.dataset.monsterName;
        } else if (type === 'tableTresor') {
          itemName = e.target.dataset.tableTresorName;
        } else if (type === 'class') {
          itemName = e.target.dataset.className || e.target.dataset.subclassName;
        } else {
          itemName = e.target.dataset[`${type}Name`];
        }
        
        if (type && categoryName && itemName) {
          this.deleteContent(type, categoryName, itemName);
        }
      });

      // Generic content movement
      JdrApp.utils.events.register('click', '[class*="-move-"]', (e) => {
        const type = this.extractTypeFromClass(e.target.className);
        const categoryName = e.target.dataset.categoryName;
        
        // Handle different dataset attribute naming patterns
        let itemName;
        if (type === 'spell') {
          itemName = e.target.dataset.spellName;
        } else if (type === 'don') {
          itemName = e.target.dataset.donName;
        } else if (type === 'tableTresor') {
          itemName = e.target.dataset.tableTresorName;
        } else if (type === 'class') {
          itemName = e.target.dataset.className || e.target.dataset.subclassName;
        } else {
          itemName = e.target.dataset[`${type}Name`];
        }
        
        const direction = e.target.className.includes('move-up') ? -1 : 1;
        
        if (type && categoryName && itemName) {
          this.moveContent(type, categoryName, itemName, direction);
        }
      });

      // Filter manager button for objects
      JdrApp.utils.events.register('click', '.filter-manager-btn', () => {
        this.showFilterManagementModal();
      });

      // Tags manager button for objects
      JdrApp.utils.events.register('click', '.tags-manager-btn', () => {
        this.showTagsManagementModal();
      });

      // Filter chip toggle for objects
      JdrApp.utils.events.register('click', '.filter-chip', (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.toggleFilter(e.target);
      });

      // Select all tags button
      JdrApp.utils.events.register('click', '#select-all-tags', () => {
        this.selectAllTags();
      });

      // Select no tags button
      JdrApp.utils.events.register('click', '#select-no-tags', () => {
        this.selectNoTags();
      });

      // ID search functionality (only on Enter key or button click)
      JdrApp.utils.events.register('keydown', '#id-search-input', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          this.performIdSearch(e.target.value);
        } else if (e.key === 'Escape') {
          e.target.value = '';
          this.clearIdSearch();
        }
      });

      JdrApp.utils.events.register('click', '#clear-id-search', () => {
        this.clearIdSearch();
      });

      // Spell element change
      JdrApp.utils.events.register('change', '.spell-element-selector select', (e) => {
        this.updateSpellElement(e.target);
      });

      // Paragraph addition
      JdrApp.utils.events.register('click', '.add-paragraph-btn', (e) => {
        const target = e.target.dataset.target;
        this.addParagraph(target, e.target);
      });

      // Section deletion for static pages
      JdrApp.utils.events.register('click', '.section-delete', (e) => {
        const sectionName = e.target.dataset.sectionName;
        if (sectionName && confirm(`Supprimer la section "${sectionName}" ?`)) {
          this.deleteSection(sectionName, e.target);
        }
      });

      // Dev toolbox category creation buttons
      JdrApp.utils.events.register('click', '#addSpellCategory', () => {
        this.createNewCategory('spell');
      });

      JdrApp.utils.events.register('click', '#addDonCategory', () => {
        this.createNewCategory('don');
      });

      // Category deletion buttons
      JdrApp.utils.events.register('click', '[class$="-category-delete"]', (e) => {
        const categoryName = e.target.dataset.categoryName;
        const categoryType = e.target.dataset.categoryType;
        
        if (categoryName && categoryType) {
          this.deleteCategory(categoryType, categoryName);
        }
      });

      // Filter management for objects page
      JdrApp.utils.events.register('click', '.filter-manager-btn', (e) => {
        this.showFilterManagementModal();
      });

      // Tables de trésors - Edition des fourchettes
      JdrApp.utils.events.register('click', '.edit-fourchette-btn', (e) => {
        const tableName = e.target.dataset.tableName;
        const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
        
        if (tableName && fourchetteIndex >= 0) {
          this.editFourchette(tableName, fourchetteIndex);
        }
      });

      // Tables de trésors - Suppression des fourchettes
      JdrApp.utils.events.register('click', '.delete-fourchette-btn', (e) => {
        const tableName = e.target.dataset.tableName;
        const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
        
        if (tableName && fourchetteIndex >= 0) {
          if (confirm('Êtes-vous sûr de vouloir supprimer cette fourchette ?')) {
            this.deleteFourchette(tableName, fourchetteIndex);
          }
        }
      });

      // Tables de trésors - Ajout de fourchettes
      JdrApp.utils.events.register('click', '.table-tresor-add-fourchette', (e) => {
        const tableName = e.target.dataset.tableTresorName;
        
        if (tableName) {
          this.addFourchette(tableName);
        }
      });

      // Tables de trésors - Prévisualisation des objets
      JdrApp.utils.events.register('click', '.object-preview-link', (e) => {
        e.preventDefault();
        const objetNumero = parseInt(e.target.dataset.objectNumero);
        
        if (objetNumero) {
          this.showObjectPreview(objetNumero);
        }
      });

      // Filter chip toggling (REMOVED - duplicate listener that was causing double toggle)

      // Element selector for spells (dev mode)
      JdrApp.utils.events.register('change', '.spell-element-selector', (e) => {
        this.updateSpellElement(e.target);
      });

      // Print button for states page
      JdrApp.utils.events.register('click', '#print-etats-btn', () => {
        this.printStates();
      });
    },

    setupTagsManagement() {
      // Handle manage tags button clicks
      JdrApp.utils.events.register('click', '.manage-tags-btn', (e) => {
        const contentType = e.target.dataset.contentType;
        if (contentType === 'monster') {
          this.showMonsterTagsManagement();
        } else if (contentType === 'tableTresor') {
          this.showTableTresorTagsManagement();
        }
      });
    },

    showMonsterTagsManagement() {
      const config = window.ContentTypes.monster;
      if (!config || !config.filterConfig) {
        this.showNotification('Configuration des tags monstres non trouvée', 'error');
        return;
      }

      // Remove existing modal if any
      const existingModal = document.querySelector('#monsterTagsModal');
      if (existingModal) {
        existingModal.remove();
      }

      const availableTags = config.filterConfig.availableTags || [];
      const modal = this.createMonsterTagsModal(availableTags);
      document.body.appendChild(modal);
      
      // Use native dialog showModal for proper z-index
      modal.showModal();
    },

    showTableTresorTagsManagement() {
      // Priority: Load tags from metadata, then config, then fallback
      let availableTags = [];
      
      if (window.TABLES_TRESORS?._metadata?.availableTags) {
        availableTags = window.TABLES_TRESORS._metadata.availableTags;
      } else {
        // Initialize metadata if missing (shouldn't happen normally)
        availableTags = ['Forêt', 'Boss', 'Coffre'];
        if (window.TABLES_TRESORS) {
          if (!window.TABLES_TRESORS._metadata) {
            window.TABLES_TRESORS._metadata = {};
          }
          window.TABLES_TRESORS._metadata.availableTags = [...availableTags];
        }
      }

      // Remove existing modal if any
      const existingModal = document.querySelector('#tableTresorTagsModal');
      if (existingModal) {
        existingModal.remove();
      }
      const modal = this.createTableTresorTagsModal(availableTags);
      document.body.appendChild(modal);
      
      // Use native dialog showModal for proper z-index
      modal.showModal();
    },

    createMonsterTagsModal(availableTags) {
      const modal = document.createElement('dialog');
      modal.id = 'monsterTagsModal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        padding: 0;
        border: none;
        border-radius: 12px;
        background: transparent;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      `;
      
      modal.innerHTML = `
        <div style="background: var(--paper); padding: 24px; border-radius: 12px; border: 3px solid var(--bronze);">
          <h3 style="margin: 0 0 16px 0; color: var(--bronze); display: flex; align-items: center; gap: 8px;">
            🏷️ Gérer les tags - Monstres
          </h3>
          <p style="margin: 0 0 20px 0; color: var(--text-muted);">
            Ajoutez, modifiez ou supprimez les tags disponibles pour le filtrage des monstres.
          </p>
          
          <div class="current-tags" style="margin-bottom: 20px;">
            <h4 style="margin: 0 0 12px 0; color: var(--bronze);">Tags actuels:</h4>
            <div class="tags-list" style="display: flex; flex-wrap: wrap; gap: 12px;">
              ${availableTags.map(tag => `
                <div class="tag-item" style="display: flex; align-items: center; background: #f5f5f5; border: 2px solid #ddd; border-radius: 8px; padding: 8px 12px;">
                  <span class="tag-name" style="margin-right: 12px; font-weight: 600; color: #333;">${tag}</span>
                  <button 
                    class="delete-monster-tag-btn" 
                    data-tag="${tag}" 
                    type="button"
                    style="background: #dc2626; color: white; border: none; padding: 6px 10px; font-size: 14px; border-radius: 4px; cursor: pointer;"
                    title="Supprimer ${tag}"
                  >🗑️</button>
                </div>
              `).join('')}
            </div>
          </div>

          <div class="add-tag-section" style="margin-bottom: 20px;">
            <h4 style="margin: 0 0 12px 0; color: var(--bronze);">Ajouter un nouveau tag:</h4>
            <div style="display: flex; gap: 8px; align-items: center;">
              <input type="text" id="new-monster-tag-input" placeholder="Nom du nouveau tag" style="flex: 1; padding: 8px 12px; border: 2px solid var(--rule); border-radius: 6px; font-size: 14px;">
              <button class="btn btn-primary" id="add-monster-tag-btn" style="padding: 8px 16px; background: var(--bronze); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">➕ Ajouter</button>
            </div>
          </div>
          
          <div style="text-align: right; padding-top: 20px; border-top: 2px solid var(--rule);">
            <button type="button" class="btn modal-close" style="padding: 8px 16px; background: var(--paper-light); border: 2px solid var(--rule); border-radius: 6px; cursor: pointer;">Fermer</button>
          </div>
        </div>
      `;

      // Setup event handlers for this modal
      this.setupMonsterTagsModalEvents(modal, availableTags);

      return modal;
    },

    createTableTresorTagsModal(availableTags) {
      const modal = document.createElement('dialog');
      modal.id = 'tableTresorTagsModal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        border: 2px solid var(--gold);
        border-radius: 12px;
        padding: 0;
        background: #2a2a2a;
        color: #ffffff;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(8px);
      `;
      
      const tagsListHTML = availableTags.map(tag => `
        <div class="tag-item" style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; margin: 4px 0; background: #3a3a3a; border-radius: 6px; border-left: 4px solid var(--gold);">
          <span style="font-weight: 500; color: #ffffff;">${tag}</span>
          <button type="button" class="delete-table-tresor-tag-btn" data-tag="${tag}" style="background: #dc2626; color: white; border: none; border-radius: 4px; padding: 4px 8px; font-size: 0.8em; cursor: pointer;" title="Supprimer ce tag">🗑️</button>
        </div>
      `).join('');
      
      modal.innerHTML = `
        <div style="padding: 24px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--gold); display: flex; align-items: center; gap: 8px;">
              💎 <span>Gérer les Tags - Tables de Trésors</span>
            </h3>
            <button type="button" class="modal-close-btn" style="background: none; border: none; font-size: 1.5em; cursor: pointer; color: var(--text-color);" title="Fermer">×</button>
          </div>
          
          <div style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 600;">Ajouter un nouveau tag :</label>
            <div style="display: flex; gap: 8px;">
              <input type="text" id="newTableTresorTagInput" placeholder="Ex: Boss, Mythique..." style="flex: 1; padding: 8px 12px; border: 1px solid var(--gold); border-radius: 6px; background: #1a1a1a; color: #ffffff;">
              <button type="button" id="addTableTresorTagBtn" style="background: var(--accent); color: white; border: none; border-radius: 6px; padding: 8px 16px; cursor: pointer; font-weight: 500;">
                ➕ Ajouter
              </button>
            </div>
          </div>
          
          <div style="margin-bottom: 20px;">
            <h4 style="margin: 0 0 12px 0; color: var(--gold);">Tags existants :</h4>
            <div id="tableTresorTagsList" style="max-height: 300px; overflow-y: auto;">
              ${tagsListHTML}
            </div>
          </div>
          
          <div style="text-align: center; padding-top: 16px; border-top: 1px solid var(--rule);">
            <button type="button" class="modal-close-btn" style="background: var(--secondary-color); color: white; border: none; border-radius: 6px; padding: 10px 20px; cursor: pointer; font-weight: 500;">
              Fermer
            </button>
          </div>
        </div>
      `;
      
      // Setup event handlers for this modal
      this.setupTableTresorTagsModalEvents(modal, availableTags);

      return modal;
    },

    setupMonsterTagsModalEvents(modal, availableTags) {
      // Close modal
      modal.querySelector('.modal-close').addEventListener('click', () => {
        modal.close();
      });

      // Add new tag
      const addBtn = modal.querySelector('#add-monster-tag-btn');
      const newTagInput = modal.querySelector('#new-monster-tag-input');
      
      const addTag = () => {
        const newTag = newTagInput.value.trim();
        if (newTag && !availableTags.includes(newTag)) {
          window.ContentTypes.monster.filterConfig.availableTags.push(newTag);
          modal.close();
          this.showMonsterTagsManagement(); // Refresh modal
          this.showNotification(`Tag "${newTag}" ajouté avec succès`, 'success');
        } else if (newTag && availableTags.includes(newTag)) {
          this.showNotification('Ce tag existe déjà', 'error');
        }
      };

      addBtn.addEventListener('click', addTag);
      newTagInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          addTag();
        }
      });

      // Delete tag buttons using event delegation
      modal.addEventListener('click', (e) => {        
        // Check if the clicked element is a delete button
        if (e.target && (e.target.classList.contains('delete-monster-tag-btn') || 
            e.target.closest('.delete-monster-tag-btn'))) {
          
          e.preventDefault();
          e.stopPropagation();
          
          // Get the button element (might be clicked on emoji inside)
          const button = e.target.classList.contains('delete-monster-tag-btn') ? 
                        e.target : e.target.closest('.delete-monster-tag-btn');
          
          const tagToDelete = button.dataset.tag;
          
          if (!tagToDelete) {
            console.error('No tag found on delete button:', button);
            this.showNotification('❌ Erreur: tag non trouvé', 'error');
            return;
          }
          
          const config = window.ContentTypes.monster;
          if (!config || !config.filterConfig || !config.filterConfig.availableTags) {
            console.error('Monster config not found or invalid');
            this.showNotification('❌ Configuration des monstres non trouvée', 'error');
            return;
          }
          
          const index = config.filterConfig.availableTags.indexOf(tagToDelete);
          
          if (index > -1) {
            // Confirm deletion
            if (confirm(`Êtes-vous sûr de vouloir supprimer le tag "${tagToDelete}" ?\n\nCela supprimera aussi ce tag de tous les monstres qui l'utilisent.`)) {
              // Remove from available tags
              config.filterConfig.availableTags.splice(index, 1);
              
              // Remove the tag from all monsters
              if (window.MONSTRES && Array.isArray(window.MONSTRES)) {
                window.MONSTRES.forEach(monster => {
                  if (monster.tags && monster.tags.includes(tagToDelete)) {
                    monster.tags = monster.tags.filter(tag => tag !== tagToDelete);
                    // Ensure monster has at least one tag if possible
                    if (monster.tags.length === 0 && config.filterConfig.availableTags.length > 0) {
                      monster.tags = [config.filterConfig.availableTags[0]];
                    }
                  }
                });
              }
              
              // Update filter state to remove deleted tag
              if (window.MONSTRES_FILTER_STATE && window.MONSTRES_FILTER_STATE.visibleTags) {
                window.MONSTRES_FILTER_STATE.visibleTags = 
                  window.MONSTRES_FILTER_STATE.visibleTags.filter(tag => tag !== tagToDelete);
                // Ensure at least one visible tag remains
                if (window.MONSTRES_FILTER_STATE.visibleTags.length === 0 && 
                    config.filterConfig.availableTags.length > 0) {
                  window.MONSTRES_FILTER_STATE.visibleTags = [config.filterConfig.availableTags[0]];
                }
              }
              
              // Save the updated availableTags in the monster data for persistence
              if (window.MONSTRES && Array.isArray(window.MONSTRES)) {
                // Store availableTags in the first monster's metadata or create a special entry
                if (!window.MONSTRES._metadata) {
                  window.MONSTRES._metadata = {};
                }
                window.MONSTRES._metadata.availableTags = [...config.filterConfig.availableTags];
              }
              
              // Save changes to storage
              EventBus.emit(Events.STORAGE_SAVE);
              
              // Refresh modal and monsters page
              modal.close();
              this.showMonsterTagsManagement();
              
              // Force complete page reload for monsters page to update filters
              const currentPage = window.location.hash.replace('#/', '');
              if (currentPage === 'monstres') {
                // Trigger router to completely rebuild the page
                setTimeout(() => {
                  if (JdrApp.modules.router && JdrApp.modules.router.show) {
                    JdrApp.modules.router.show('monstres');
                  }
                }, 100);
              }
              
              this.showNotification(`✅ Tag "${tagToDelete}" supprimé avec succès`, 'success');
            }
          } else {
            console.error(`Tag "${tagToDelete}" not found in available tags`);
            this.showNotification(`❌ Tag "${tagToDelete}" non trouvé`, 'error');
          }
        }
      });
    },

    setupTableTresorTagsModalEvents(modal, availableTags) {
      // Close modal
      const closeButtons = modal.querySelectorAll('.modal-close-btn');
      closeButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          modal.close();
          modal.remove();
        });
      });

      const newTagInput = modal.querySelector('#newTableTresorTagInput');
      const addBtn = modal.querySelector('#addTableTresorTagBtn');

      const addTag = () => {
        const newTag = newTagInput.value.trim();
        
        if (newTag && !availableTags.includes(newTag)) {
          // Add to the current available tags
          availableTags.push(newTag);
          
          // Save in TABLES_TRESORS metadata for persistence (primary storage)
          if (window.TABLES_TRESORS) {
            if (!window.TABLES_TRESORS._metadata) {
              window.TABLES_TRESORS._metadata = {};
            }
            window.TABLES_TRESORS._metadata.availableTags = [...availableTags];
          }
          
          // Note: ContentTypes.tableTresor.filterConfig.availableTags removed - metadata is single source of truth
          
          // Save changes to storage
          EventBus.emit(Events.STORAGE_SAVE);
          
          // Refresh modal and tables page
          modal.close();
          this.showTableTresorTagsManagement(); // Refresh modal
          this.showNotification(`Tag "${newTag}" ajouté avec succès`, 'success');
        } else if (newTag && availableTags.includes(newTag)) {
          this.showNotification('Ce tag existe déjà', 'error');
        }
      };

      addBtn.addEventListener('click', addTag);
      newTagInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          addTag();
        }
      });

      // Delete tag buttons using event delegation
      modal.addEventListener('click', (e) => {        
        // Check if the clicked element is a delete button
        if (e.target && (e.target.classList.contains('delete-table-tresor-tag-btn') || 
            e.target.closest('.delete-table-tresor-tag-btn'))) {
          
          e.preventDefault();
          e.stopPropagation();
          
          const deleteBtn = e.target.classList.contains('delete-table-tresor-tag-btn') 
            ? e.target 
            : e.target.closest('.delete-table-tresor-tag-btn');
          
          const tagToDelete = deleteBtn.dataset.tag;
          
          if (confirm(`Êtes-vous sûr de vouloir supprimer le tag "${tagToDelete}" ?\n\nCela supprimera le tag de tous les filtres et des tables qui l'utilisent.`)) {
            // Get current availableTags from metadata if available, otherwise from config
            let currentAvailableTags = window.TABLES_TRESORS?._metadata?.availableTags || 
                                     window.ContentTypes?.tableTresor?.filterConfig?.availableTags || 
                                     availableTags;
            
            const tagIndex = currentAvailableTags.indexOf(tagToDelete);
            
            if (tagIndex > -1) {
              // Remove from available tags
              currentAvailableTags.splice(tagIndex, 1);
              
              // Remove from all tables that use this tag
              if (window.TABLES_TRESORS?.tables) {
                window.TABLES_TRESORS.tables.forEach(table => {
                  if (table.tags && table.tags.includes(tagToDelete)) {
                    const tableTagIndex = table.tags.indexOf(tagToDelete);
                    table.tags.splice(tableTagIndex, 1);
                  }
                });
              }
              
              // Save in TABLES_TRESORS metadata for persistence (primary storage)
              if (window.TABLES_TRESORS) {
                if (!window.TABLES_TRESORS._metadata) {
                  window.TABLES_TRESORS._metadata = {};
                }
                window.TABLES_TRESORS._metadata.availableTags = [...currentAvailableTags];
              }
              
              // Note: ContentTypes backup removed - metadata is single source of truth
              
              // Clear filter state to force refresh
              if (window.TABLES_TRESORS_FILTER_STATE && window.TABLES_TRESORS_FILTER_STATE.visibleTags) {
                // Remove the deleted tag from visible tags if present  
                const visibleTagIndex = window.TABLES_TRESORS_FILTER_STATE.visibleTags.indexOf(tagToDelete);
                if (visibleTagIndex > -1) {
                  window.TABLES_TRESORS_FILTER_STATE.visibleTags.splice(visibleTagIndex, 1);
                }
              }
              
              // Save changes to storage
              EventBus.emit(Events.STORAGE_SAVE);
              
              // Close modal first 
              modal.close();
              
              // Force complete page reload for tables page to update filters
              const currentPage = window.location.hash.replace('#/', '');
              if (currentPage === 'tables-tresors') {
                // Trigger router to completely rebuild the page
                setTimeout(() => {
                  if (JdrApp.modules.router && JdrApp.modules.router.renderTablesTresorsPage) {
                    JdrApp.modules.router.renderTablesTresorsPage();
                  }
                }, 100);
              }
              
              // Refresh modal after page update
              setTimeout(() => {
                this.showTableTresorTagsManagement();
              }, 200);
              
              this.showNotification(`✅ Tag "${tagToDelete}" supprimé avec succès`, 'success');
            }
          } else {
            console.error(`Tag "${tagToDelete}" not found in available tags`);
            this.showNotification(`❌ Tag "${tagToDelete}" non trouvé`, 'error');
          }
        }
      });
    },

    extractTypeFromClass(className) {
      if (className.includes('spell')) return 'spell';
      if (className.includes('don')) return 'don';
      if (className.includes('class')) return 'class';
      if (className.includes('objet')) return 'objet';
      if (className.includes('monster')) return 'monster';
      if (className.includes('tableTresor')) return 'tableTresor';
      return null;
    },

    deleteContent(type, categoryName, itemName) {
      if (!confirm(`Supprimer "${itemName}" ?`)) return;

      const success = ContentFactory.deleteItem(type, categoryName, itemName);
      
      if (success) {
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: type,
          category: ContentFactory.getEntity(type).findCategory(categoryName)
        });
        
        this.showNotification('🗑 Élément supprimé');
      }
    },

    moveContent(type, categoryName, itemName, direction) {
      const success = ContentFactory.moveItem(type, categoryName, itemName, direction);
      
      if (success) {
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: type,
          category: ContentFactory.getEntity(type).findCategory(categoryName)
        });
        
        const directionText = direction > 0 ? 'descendu' : 'monté';
        this.showNotification(`🔄 Élément ${directionText}`);
      }
    },

    addParagraph(target, button) {
      // Handle different types of additions based on target
      if (target === 'section') {
        this.addNewSection(button);
      } else {
        this.addParagraphToSection(target, button);
      }
    },

    addNewSection(button) {
      // Generate a unique but readable ID
      const pageId = this.getCurrentPageId();
      const sectionCount = this.countExistingSections();
      const sectionId = `${pageId}-new-${sectionCount + 1}-${Date.now()}`;
      
      const newSection = document.createElement('div');
      newSection.className = 'card editable-section';
      newSection.dataset.sectionType = 'card';
      newSection.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${sectionId}-title">Nouvelle section</h3>
            <button class="edit-btn edit-title-btn" title="Éditer le titre">✏️</button>
          </div>
        </div>
        <div style="position:relative;">
          <div class="editable" data-edit-type="generic" data-edit-section="${sectionId}">
            <p>Contenu de la nouvelle section.</p>
          </div>
          <button class="edit-btn edit-section-btn" title="Éditer cette section">✏️</button>
        </div>
        <div style="margin-top: 1rem; text-align: center;">
          <button class="section-delete btn small" data-section-name="Nouvelle section" type="button" style="background: #ff6b6b; color: white;">🗑 Supprimer section</button>
        </div>
      `;
      
      button.parentNode.insertBefore(newSection, button);
      
      // Immediately save the new section to JSON
      this.saveNewSectionToJSON(sectionId, "Nouvelle section", "<p>Contenu de la nouvelle section.</p>");
      
      // No need to recalculate indices - unique IDs prevent conflicts
      // this.recalculateSectionIndices();
      
      // Trigger persistent storage save
      this.triggerDataSave();
      
      this.showNotification('➕ Nouvelle section ajoutée et sauvegardée');
    },

    addParagraphToSection(target, button) {
      // Generate a unique but readable ID
      const pageId = this.getCurrentPageId();
      const sectionCount = this.countExistingSections();
      const paragraphId = `${pageId}-para-${sectionCount + 1}-${Date.now()}`;
      
      const container = document.createElement('div');
      container.className = 'editable-paragraph card';
      container.dataset.sectionType = 'card';
      container.style.position = 'relative';
      container.style.marginTop = '1rem';
      
      container.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${paragraphId}-title">Nouveau paragraphe</h3>
            <button class="edit-btn edit-title-btn" title="Éditer le titre">✏️</button>
          </div>
        </div>
        <div style="position:relative;">
          <div class="editable" data-edit-type="generic" data-edit-section="${paragraphId}">
            <p>Contenu du nouveau paragraphe.</p>
          </div>
          <button class="edit-btn edit-section-btn" title="Éditer cette section">✏️</button>
        </div>
        <div style="margin-top: 1rem; text-align: center;">
          <button class="section-delete btn small" data-section-name="Nouveau paragraphe" type="button" style="background: #ff6b6b; color: white;">🗑 Supprimer section</button>
        </div>
      `;
      
      button.parentNode.insertBefore(container, button);
      
      // Immediately save the new paragraph as a section to JSON
      this.saveNewSectionToJSON(paragraphId, "Nouveau paragraphe", "<p>Contenu du nouveau paragraphe.</p>");
      
      // No need to recalculate indices - unique IDs prevent conflicts
      // this.recalculateSectionIndices();
      
      // Trigger persistent storage save
      this.triggerDataSave();
      
      this.showNotification('➕ Paragraphe ajouté et sauvegardé');
    },

    deleteSection(sectionName, button) {
      // Find and remove the section
      const section = button.closest('.card');
      if (section) {
        // Extract the section ID from the editable elements
        const editableElement = section.querySelector('[data-edit-section]');
        let sectionId = null;
        if (editableElement) {
          sectionId = editableElement.dataset.editSection;
          // Remove "-title" suffix if present to get base ID
          if (sectionId.endsWith('-title')) {
            sectionId = sectionId.replace('-title', '');
          }
        }
        
        section.remove();
        
        // Save the deletion to JSON
        if (sectionId) {
          this.deleteSectionFromJSON(sectionId);
        }
        
        // Recalculate all section indices after deletion
        this.recalculateSectionIndices();
        
        // Trigger persistent storage save
        this.triggerDataSave();
        
        this.showNotification(`🗑️ Section "${sectionName}" supprimée et mise à jour JSON`);
      }
    },

    // ========================================
    // CONTENT MANIPULATION METHODS 
    // ========================================
    
    addContent(type, categoryName) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`❌ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Create new item with default values
      const defaultItem = ContentFactory.createDefaultItem(type);
      
      // Special handling for objects and monsters (add to single array)
      if (type === 'objet') {
        if (!window.OBJETS.objets) {
          window.OBJETS.objets = [];
        }
        
        // Get next number
        const existingNumbers = window.OBJETS.objets.map(obj => obj.numero || 0);
        const nextNumber = existingNumbers.length > 0 ? Math.max(...existingNumbers) + 1 : 1;
        defaultItem.numero = nextNumber;
        
        window.OBJETS.objets.push(defaultItem);
        this.refreshObjectsPage();
      } else if (type === 'monster') {
        if (!window.MONSTRES) {
          window.MONSTRES = [];
        }
        
        window.MONSTRES.push(defaultItem);
        this.refreshMonstersPage();
      } else {
        // Standard category-based addition
        const success = ContentFactory.addItem(type, categoryName, defaultItem);
        if (success) {
          EventBus.emit(Events.CONTENT_ADD, {
            type: type,
            category: categoryName,
            item: defaultItem
          });
          
          EventBus.emit(Events.PAGE_RENDER, {
            type: 'category',
            categoryType: type,
            category: ContentFactory.getEntity(type).findCategory(categoryName)
          });
        }
      }
      
      EventBus.emit(Events.STORAGE_SAVE);
      this.showNotification(`${config.icons.add} Nouvel élément ajouté`, 'success');
    },

    deleteContent(type, categoryName, itemName) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`❌ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      if (!confirm(`Supprimer "${itemName}" ?`)) {
        return;
      }

      // Special handling for objects and monsters
      if (type === 'objet') {
        if (window.OBJETS?.objets) {
          const itemIndex = window.OBJETS.objets.findIndex(obj => obj.nom === itemName);
          if (itemIndex >= 0) {
            window.OBJETS.objets.splice(itemIndex, 1);
            this.refreshObjectsPage();
          }
        }
      } else if (type === 'monster') {
        if (window.MONSTRES) {
          const itemIndex = window.MONSTRES.findIndex(monster => monster.nom === itemName);
          if (itemIndex >= 0) {
            window.MONSTRES.splice(itemIndex, 1);
            this.refreshMonstersPage();
          }
        }
      } else {
        // Standard category-based deletion
        const success = ContentFactory.deleteItem(type, categoryName, itemName);
        if (success) {
          EventBus.emit(Events.CONTENT_DELETE, {
            type: type,
            category: categoryName,
            item: itemName
          });
          
          EventBus.emit(Events.PAGE_RENDER, {
            type: 'category',
            categoryType: type,
            category: ContentFactory.getEntity(type).findCategory(categoryName)
          });
        }
      }
      
      EventBus.emit(Events.STORAGE_SAVE);
      this.showNotification(`${config.icons.delete} "${itemName}" supprimé`, 'success');
    },

    moveContent(type, categoryName, itemName, direction) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`❌ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Special handling for objects
      if (type === 'objet') {
        if (window.OBJETS?.objets) {
          const itemIndex = window.OBJETS.objets.findIndex(obj => obj.nom === itemName);
          if (itemIndex >= 0) {
            const newIndex = itemIndex + direction;
            if (newIndex >= 0 && newIndex < window.OBJETS.objets.length) {
              const item = window.OBJETS.objets.splice(itemIndex, 1)[0];
              window.OBJETS.objets.splice(newIndex, 0, item);
              this.refreshObjectsPage();
            }
          }
        }
      } else {
        // Standard category-based movement
        const success = ContentFactory.moveItem(type, categoryName, itemName, direction);
        if (success) {
          EventBus.emit(Events.CONTENT_MOVE, {
            type: type,
            category: categoryName,
            itemName: itemName,
            direction: direction
          });
          
          EventBus.emit(Events.PAGE_RENDER, {
            type: 'category',
            categoryType: type,
            category: ContentFactory.getEntity(type).findCategory(categoryName)
          });
        }
      }
      
      EventBus.emit(Events.STORAGE_SAVE);
      const directionText = direction > 0 ? 'descendu' : 'monté';
      this.showNotification(`🔄 "${itemName}" ${directionText}`, 'success');
    },

    handleContentAdd(type, category, item) {
      // Additional handling after content is added
      setTimeout(() => {
        if (JdrApp.modules.renderer?.autoLoadImages) {
          JdrApp.modules.renderer.autoLoadImages();
        }
      }, 100);
    },

    handleContentDelete(type, category, item) {
      // Cleanup after content deletion
    },

    handleContentMove(type, category, itemName, direction) {
      // Additional handling after content is moved
    },

    setupSearch() {
      const searchInput = JdrApp.utils.dom.$('#search');
      const clearButton = JdrApp.utils.dom.$('#clear');
      let searchTimeout;
      
      if (searchInput) {
        // Only search on Enter key press
        JdrApp.utils.events.register('keydown', '#search', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            const query = e.target.value.trim();
            if (query.length > 0) {
              this.performSearch(query);
            } else {
              this.clearMainSearchResults();
            }
          } else if (e.key === 'Escape') {
            this.clearMainSearchResults();
            e.target.value = '';
            e.target.blur();
          }
        });
      }
      
      if (clearButton) {
        JdrApp.utils.events.register('click', '#clear', () => {
          if (searchInput) {
            searchInput.value = '';
            this.clearMainSearchResults();
          }
        });
      }

      // Remove click outside handler since we're not using dropdown anymore
      // JdrApp.utils.events.register('click', 'body', (e) => {
      //   if (!e.target.closest('.searchbar') && !e.target.closest('#search-results')) {
      //     this.hideSearchResults();
      //   }
      // });

      // Remove EventBus listener that may cause issues
      // EventBus.on(Events.SEARCH_PERFORM, (payload) => {
      //   this.performSearch(payload.query);
      // });
    },

    performSearch(query) {
      const normalizedQuery = query.toLowerCase().trim();
      
      if (!normalizedQuery) {
        this.showAllContent();
        this.clearMainSearchResults();
        return;
      }

      // Search without minimum character limit since user has to press Enter
      const results = this.searchInData(normalizedQuery);
      this.displaySearchResultsInMain(results, normalizedQuery);
      
      // Keep existing TOC search for compatibility
      this.searchInTOC(normalizedQuery);
    },

    searchInData(query) {
      const results = [];
      
      // Search in SORTS
      if (window.SORTS) {
        window.SORTS.forEach(category => {
          if (category.sorts) {
            category.sorts.forEach(sort => {
              if (this.matchesSearch(sort, query)) {
                const url = `#/sorts-${JdrApp.utils.data.sanitizeId(category.nom)}`;
                
                results.push({
                  type: 'spell',
                  category: category.nom,
                  item: sort,
                  url: url,
                  summary: this.generateSpellSummary(sort)
                });
              }
            });
          }
        });
      }

      // Search in DONS
      if (window.DONS) {
        window.DONS.forEach(category => {
          if (category.dons) {
            category.dons.forEach(don => {
              if (this.matchesSearch(don, query)) {
                results.push({
                  type: 'don',
                  category: category.nom,
                  item: don,
                  url: `#/dons-${JdrApp.utils.data.sanitizeId(category.nom)}`,
                  summary: this.generateDonSummary(don)
                });
              }
            });
          }
        });
      }

      // Search in CLASSES
      if (window.CLASSES) {
        window.CLASSES.forEach(classe => {
          if (this.matchesSearch(classe, query)) {
            results.push({
              type: 'class',
              category: null,
              item: classe,
              url: `#/${JdrApp.utils.data.sanitizeId(classe.nom)}`,
              summary: this.generateClassSummary(classe)
            });
          }
          
          // Search in subclasses
          if (classe.sousClasses) {
            classe.sousClasses.forEach(sousClasse => {
              if (this.matchesSearch(sousClasse, query)) {
                results.push({
                  type: 'subclass',
                  category: classe.nom,
                  item: sousClasse,
                  url: `#/${JdrApp.utils.data.sanitizeId(classe.nom)}`,
                  summary: this.generateSubclassSummary(sousClasse, classe.nom)
                });
              }
            });
          }
        });
      }

      // Search in static pages
      this.searchInStaticPages(query, results);
      
      return results.slice(0, 10); // Limit to 10 results
    },

    searchInStaticPages(query, results) {
      // Search in static pages data
      if (window.STATIC_PAGES) {
        Object.keys(window.STATIC_PAGES).forEach(pageId => {
          const pageData = window.STATIC_PAGES[pageId];
          if (this.matchesStaticPage(pageData, query)) {
            results.push({
              type: 'staticPage',
              category: null,
              item: pageData,
              url: `#/${pageId}`,
              summary: this.generateStaticPageSummary(pageData)
            });
          }
        });
      }

      // Also search in static page config if available
      if (window.STATIC_PAGE_CONFIG?.pages) {
        window.STATIC_PAGE_CONFIG.pages.forEach(pageConfig => {
          if (pageConfig.active && this.matchesPageConfig(pageConfig, query)) {
            // Only add if we haven't already found this page
            const alreadyExists = results.some(r => 
              r.type === 'staticPage' && r.url === `#/${pageConfig.id}`
            );
            
            if (!alreadyExists) {
              results.push({
                type: 'staticPage',
                category: null,
                item: { 
                  title: pageConfig.title, 
                  page: pageConfig.id,
                  description: `Page sur ${pageConfig.title.toLowerCase()}`
                },
                url: `#/${pageConfig.id}`,
                summary: this.generatePageConfigSummary(pageConfig)
              });
            }
          }
        });
      }
    },

    matchesStaticPage(pageData, query) {
      const searchText = [
        pageData.title || '',
        pageData.page || '',
        this.extractStaticPageContent(pageData.sections || [])
      ].join(' ').toLowerCase();
      
      return searchText.includes(query);
    },

    matchesPageConfig(pageConfig, query) {
      const searchText = [
        pageConfig.title || '',
        pageConfig.id || ''
      ].join(' ').toLowerCase();
      
      return searchText.includes(query);
    },

    extractStaticPageContent(sections) {
      return sections.map(section => {
        let content = '';
        if (section.content) {
          if (typeof section.content === 'string') {
            content += section.content;
          } else if (section.content.content) {
            // New HTML format: extract text from HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = section.content.content;
            content += tempDiv.textContent || tempDiv.innerText || '';
          } else if (section.content.items && Array.isArray(section.content.items)) {
            // Legacy format
            content += section.content.items.join(' ');
          }
        }
        return content;
      }).join(' ');
    },

    matchesSearch(item, query) {
      // Fonction pour nettoyer le HTML et extraire le texte
      const stripHtml = (text) => {
        if (!text) return '';
        if (typeof text !== 'string') text = String(text);
        return text.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
      };

      // Fonction pour traiter les listes/arrays
      const processArray = (arr) => {
        if (!arr) return '';
        if (Array.isArray(arr)) {
          return arr.map(item => stripHtml(item)).join(' ');
        }
        return stripHtml(arr);
      };

      // Collecter TOUS les champs textuels possibles
      const searchFields = [
        // Champs communs
        item.nom,
        item.description,
        item.prerequis,
        item.resume,
        
        // Champs spécifiques aux sorts
        item.element,
        item.portee,
        item.tempsIncantation,
        item.coutMana,
        item.resistance,
        item.effetNormal,
        item.effetCritique,
        
        // Champs spécifiques aux dons
        item.cout,
        
        // Champs spécifiques aux classes/sous-classes
        item.progression,
        processArray(item.capacites),
        
        // Champs spécifiques aux objets
        item.effet,
        item.prix,
        item.poids,
        item.tags ? item.tags.join(' ') : '',
        
        // Champs de statistiques (si c'est un objet)
        item.base ? Object.entries(item.base || {}).map(([key, value]) => `${key} ${value}`).join(' ') : '',
        
        // Autres champs possibles
        item.title,
        item.content,
        item.type
      ];

      // Joindre tous les champs et nettoyer
      const searchText = searchFields
        .filter(field => field !== null && field !== undefined)
        .map(field => stripHtml(field))
        .join(' ')
        .toLowerCase();
      
      // Chercher chaque mot de la requête
      const queryWords = query.toLowerCase().split(/\s+/).filter(word => word.length > 0);
      
      // Tous les mots doivent être trouvés (recherche ET logique)
      return queryWords.every(word => searchText.includes(word));
    },

    generateSpellSummary(spell) {
      // Strip HTML tags from fields to avoid breaking template
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `🔮 ${stripHtml(spell.nom)} - ${stripHtml(spell.prerequis || 'Aucun prérequis')} | ${stripHtml(spell.coutMana || 'Coût inconnu')}`;
    },

    generateDonSummary(don) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `🏆 ${stripHtml(don.nom)} - ${stripHtml(don.prerequis || 'Aucun prérequis')} | ${stripHtml(don.cout || 'Coût inconnu')}`;
    },

    generateClassSummary(classe) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `⚔️ ${stripHtml(classe.nom)} - ${stripHtml(classe.resume || 'Classe de combat')}`;
    },

    generateSubclassSummary(sousClasse, parentClass) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `⚡ ${stripHtml(sousClasse.nom)} (${stripHtml(parentClass)}) - Sous-classe spécialisée`;
    },

    generateStaticPageSummary(pageData) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `📄 ${stripHtml(pageData.title)} - ${stripHtml(pageData.description || 'Page d\'information du jeu')}`;
    },

    generatePageConfigSummary(pageConfig) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `📄 ${stripHtml(pageConfig.title)} - Guide et informations sur ${stripHtml(pageConfig.title.toLowerCase())}`;
    },

    slugify(text) {
      return text.toLowerCase()
        .replace(/[àáâãäå]/g, 'a')
        .replace(/[èéêë]/g, 'e')
        .replace(/[ìíîï]/g, 'i')
        .replace(/[òóôõö]/g, 'o')
        .replace(/[ùúûü]/g, 'u')
        .replace(/[ç]/g, 'c')
        .replace(/[^a-z0-9]/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '');
    },

    showAllContent() {
      JdrApp.utils.dom.$('article, .toc a').forEach(el => {
        el.style.display = '';
      });
    },

    displaySearchResultsInMain(results, query) {
      const main = document.querySelector('main');
      if (!main) return;

      // Create search results page content
      const searchPageHTML = this.generateSearchResultsPage(results, query);
      
      // Replace main content with search results
      main.innerHTML = searchPageHTML;
      
      // Quick debug to see card dimensions
      setTimeout(() => {
        const cards = main.querySelectorAll('.search-result-card');
        console.log('Cards found:', cards.length);
        cards.forEach((card, i) => {
          console.log(`Card ${i+1} dimensions:`, {
            height: card.offsetHeight,
            width: card.offsetWidth,
            display: getComputedStyle(card).display,
            visibility: getComputedStyle(card).visibility
          });
        });
      }, 100);
      
      // Setup click handlers for results
      this.setupMainSearchHandlers();
      
      // Also setup direct handlers as fallback
      this.setupDirectHandlers();
    },

    generateSearchResultsPage(results, query) {
      if (results.length === 0) {
        return `
          <div class="search-page">
            <div class="search-page-header">
              <h1>🔍 Recherche: "${query}"</h1>
              <p class="search-no-results">Aucun résultat trouvé</p>
              <button class="btn small" onclick="JdrApp.modules.ui.clearMainSearchResults()">
                ← Retour au sommaire
              </button>
            </div>
          </div>
        `;
      }
      
      let resultsHTML = '';
      
      try {
        resultsHTML = results.map((result, index) => {
          const itemName = result.item.nom || result.item.title || 'Sans nom';
          
          
          // Generate preview safely
          let preview;
          try {
            preview = this.generatePreview(result.item, result.type);
          } catch (previewError) {
            console.error('Preview error:', previewError);
            preview = '<div class="preview-field">Erreur dans l\'aperçu</div>';
          }
          
          // Escape potentially problematic text
          const escapeAttr = (text) => {
            if (!text) return '';
            return String(text).replace(/"/g, '&quot;');
          };
          
          const escapeText = (text) => {
            if (!text) return '';
            return String(text)
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;');
          };

          const cardHTML = `
            <article class="search-result-card" data-url="${result.url}">
              <div class="search-result-header">
                <h3>${this.getTypeIcon(result.type)} ${itemName}</h3>
                <div class="search-result-type">${this.getTypeName(result.type)}</div>
              </div>
              <div class="search-result-content">
                <div class="search-result-summary">${escapeText(result.summary || 'Pas de résumé')}</div>
                ${result.category ? `<div class="search-result-category">📂 Catégorie: ${escapeText(result.category)}</div>` : ''}
                <div class="search-result-preview">
                  ${preview}
                </div>
              </div>
              <div class="search-result-footer">
                <button class="btn small search-result-btn" data-url="${result.url}">
                  Voir la page →
                </button>
              </div>
            </article>
          `;
          
          return cardHTML;
        }).join('');
      } catch (error) {
        console.error('Error generating results HTML:', error);
        resultsHTML = '<div class="error">Erreur lors de la génération des résultats</div>';
      }

      const finalHTML = `
        <div class="search-page">
          <div class="search-page-header">
            <h1>🔍 Recherche: "${query}"</h1>
            <p class="search-results-count">${results.length} résultat${results.length > 1 ? 's' : ''} trouvé${results.length > 1 ? 's' : ''}</p>
            <button class="btn small" onclick="JdrApp.modules.ui.clearMainSearchResults()">
              ← Retour au sommaire
            </button>
          </div>
          <div class="search-results-grid">
            ${resultsHTML}
          </div>
        </div>
      `;
      
      return finalHTML;
    },

    getTypeIcon(type) {
      const icons = {
        'spell': '🔮',
        'don': '🏆', 
        'class': '⚔️',
        'subclass': '⚡',
        'staticPage': '📄'
      };
      return icons[type] || '📄';
    },

    getTypeName(type) {
      const names = {
        'spell': 'Sort',
        'don': 'Don',
        'class': 'Classe',
        'subclass': 'Sous-classe',
        'staticPage': 'Page'
      };
      return names[type] || 'Contenu';
    },

    generatePreview(item, type) {
      // Strip all HTML and clean text completely
      const cleanText = (text) => {
        if (!text) return '';
        return String(text)
          .replace(/<[^>]*>/g, '') // Remove HTML tags
          .replace(/&[^;]+;/g, ' ') // Remove HTML entities
          .replace(/\s+/g, ' ') // Normalize whitespace
          .trim()
          .substring(0, 100); // Limit length
      };

      switch (type) {
        case 'spell':
          const desc = cleanText(item.description || 'Non spécifiée');
          const portee = cleanText(item.portee || 'Non spécifiée');
          return `<div class="preview-field">Description: ${desc}</div><div class="preview-field">Portée: ${portee}</div>`;
          
        case 'don':
          const donDesc = cleanText(item.description || 'Non spécifiée');
          return `<div class="preview-field">Description: ${donDesc}</div>`;
          
        case 'class':
          const resume = cleanText(item.resume || 'Non spécifié');
          return `<div class="preview-field">Résumé: ${resume}</div>`;
          
        case 'subclass':
          const progression = cleanText(item.progression || 'Non spécifiée');
          return `<div class="preview-field">Progression: ${progression}</div>`;
          
        case 'staticPage':
          const content = this.extractStaticPageContent(item.sections || []);
          const preview = cleanText(content || 'Page d\'information');
          return `<div class="preview-field">Contenu: ${preview}</div>`;
          
        default:
          return '<div class="preview-field">Aperçu non disponible</div>';
      }
    },

    setupMainSearchHandlers() {
      // Handle click on entire card
      JdrApp.utils.events.register('click', '.search-result-card', (e) => {
        console.log('Card clicked, currentTarget:', e.currentTarget);
        if (e.target.closest('.search-result-btn')) return; // Let button handle it
        
        const url = e.currentTarget ? e.currentTarget.dataset.url : null;
        console.log('Card URL:', url);
        
        if (url && url !== '#test') {
          console.log('Navigating to:', url);
          window.location.hash = url;
          // Force page reload to trigger router
          window.location.reload();
        } else {
          console.warn('No valid URL found on card');
        }
      });

      // Handle button clicks
      JdrApp.utils.events.register('click', '.search-result-btn', (e) => {
        console.log('Button clicked, target:', e.target);
        e.stopPropagation();
        
        const url = e.target ? e.target.dataset.url : null;
        console.log('Button URL:', url);
        
        if (url && url !== '#test') {
          console.log('Navigating to:', url);
          window.location.hash = url;
          // Force page reload to trigger router
          window.location.reload();
        } else {
          console.warn('No valid URL found on button');
        }
      });
    },

    setupDirectHandlers() {
      // Direct event listeners on the elements themselves
      setTimeout(() => {
        const cards = document.querySelectorAll('.search-result-card');
        const buttons = document.querySelectorAll('.search-result-btn');
        
        console.log('Setting up direct handlers for', cards.length, 'cards and', buttons.length, 'buttons');
        
        cards.forEach((card, index) => {
          const url = card.dataset.url;
          console.log(`Card ${index + 1} URL:`, url);
          
          card.addEventListener('click', (e) => {
            if (e.target.closest('.search-result-btn')) return;
            console.log('Direct card click, URL:', url);
            if (url && url !== '#test') {
              window.location.hash = url;
              window.location.reload();
            }
          });
        });
        
        buttons.forEach((button, index) => {
          const url = button.dataset.url;
          console.log(`Button ${index + 1} URL:`, url);
          
          button.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log('Direct button click, URL:', url);
            if (url && url !== '#test') {
              window.location.hash = url;
              window.location.reload();
            }
          });
        });
      }, 200);
    },

    clearMainSearchResults() {
      // Reload the current page or go back to homepage
      if (window.location.hash && window.location.hash !== '#/') {
        window.location.reload();
      } else {
        window.location.hash = '#/creation';
      }
    },

    searchInTOC(query) {
      JdrApp.utils.dom.$('.toc a').forEach(link => {
        const text = link.textContent.toLowerCase();
        const isMatch = text.includes(query);
        link.style.display = isMatch ? '' : 'none';
        
        if (isMatch) {
          const category = link.closest('.toc-category');
          if (category) {
            category.classList.remove('collapsed');
          }
        }
      });
    },

    searchInContent(query) {
      JdrApp.utils.dom.$('article').forEach(article => {
        const text = article.textContent.toLowerCase();
        const isMatch = text.includes(query);
        
        if (isMatch) {
          this.highlightSearchTerms(article, query);
        }
      });
    },

    highlightSearchTerms(container, query) {
      const walker = document.createTreeWalker(
        container,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );

      const textNodes = [];
      let node;
      while (node = walker.nextNode()) {
        if (node.textContent.toLowerCase().includes(query)) {
          textNodes.push(node);
        }
      }

      textNodes.forEach(textNode => {
        const regex = new RegExp(`(${query})`, 'gi');
        const content = textNode.textContent;
        
        if (regex.test(content)) {
          const highlightedContent = content.replace(regex, '<mark>$1</mark>');
          const wrapper = document.createElement('span');
          wrapper.innerHTML = highlightedContent;
          textNode.parentNode.replaceChild(wrapper, textNode);
        }
      });
    },

    setupModals() {
      JdrApp.utils.events.register('click', '.modal-overlay, .modal-close', (e) => {
        const modal = e.target.closest('.modal') || document.querySelector('.modal.visible');
        if (modal) {
          this.closeModal(modal);
        }
      });

      JdrApp.utils.events.register('click', '.modal-content', (e) => {
        e.stopPropagation();
      });

      JdrApp.utils.events.register('keydown', 'body', (e) => {
        if (e.key === 'Escape') {
          const openModal = document.querySelector('.modal.visible');
          if (openModal) {
            this.closeModal(openModal);
          }
        }
      });

      // Resource tools
      JdrApp.utils.events.register('click', '#elementsBtn', () => {
        this.showElementsModal();
      });

      JdrApp.utils.events.register('click', '#etatsBtn', () => {
        this.showEtatsModal();
      });

      JdrApp.utils.events.register('click', '#spellLinksBtn', () => {
        this.showSpellLinksModal();
      });

      JdrApp.utils.events.register('click', '#pageLinksBtn', () => {
        this.showPageLinksModal();
      });

      // Gestionnaire pour les liens de sorts dans le contenu
      JdrApp.utils.events.register('click', '.spell-link', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const spellName = e.target.dataset.spell;
        const categoryName = e.target.dataset.category;
        this.showSpellPreview(spellName, categoryName, e.target);
      });

      // Gestionnaire pour les liens d'états dans le contenu
      JdrApp.utils.events.register('click', '.etat-link', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const etatName = e.target.dataset.etat;
        
        // Récupérer dynamiquement la description depuis les données statiques
        let etatDescription = '';
        if (window.STATIC_PAGES?.etats?.sections) {
          const etatSection = window.STATIC_PAGES.etats.sections.find(section => 
            section.type === 'card' && section.title === etatName
          );
          if (etatSection) {
            // Convertir le HTML en texte propre
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = etatSection.content;
            tempDiv.innerHTML = tempDiv.innerHTML
              .replace(/<\/p>/gi, '\n')
              .replace(/<br\s*\/?>/gi, '\n')
              .replace(/<\/li>/gi, '\n')
              .replace(/<\/div>/gi, '\n');
            etatDescription = (tempDiv.textContent || tempDiv.innerText || etatSection.content)
              .replace(/\n\s*\n/g, '\n')
              .trim();
          }
        }
        
        this.showEtatPreview(etatName, etatDescription, e.target);
      });

      EventBus.on(Events.MODAL_OPEN, (payload) => {
        this.openModal(payload.modalId);
      });

      EventBus.on(Events.MODAL_CLOSE, (payload) => {
        const modal = payload.modal || document.querySelector('.modal.visible');
        if (modal) {
          this.closeModal(modal);
        }
      });
    },

    openModal(modalId) {
      const modal = JdrApp.utils.dom.$(`#${modalId}`);
      if (modal) {
        if (modal.tagName === 'DIALOG') {
          modal.showModal();
        } else {
          modal.classList.add('visible');
          modal.style.display = 'flex';
        }
        
        const firstInput = modal.querySelector('input, textarea, select');
        if (firstInput) {
          firstInput.focus();
        }
      }
    },

    closeModal(modal) {
      if (modal) {
        modal.classList.remove('visible');
        modal.style.display = 'none';
        
        const form = modal.querySelector('form');
        if (form) {
          form.reset();
        }
      }
    },

    showElementsModal() {
      let modal = JdrApp.utils.dom.$('#elementsModal');
      if (!modal) {
        modal = this.createElementsModal();
        document.body.appendChild(modal);
      }
      
      this.openModal('elementsModal');
    },

    createElementsModal() {
      const elements = Object.entries(window.ElementColors).map(([name, config]) => ({
        name,
        color: config.color,
        icon: this.getElementIcon(name)
      }));

      const elementsHTML = elements.map(element => `
        <div class="element-item" data-element="${element.name}" data-color="${element.color}">
          <div class="element-icon" style="background: ${element.color};">${element.icon}</div>
          <div class="element-name">${element.name}</div>
          <div class="copy-indicator">Copié!</div>
        </div>
      `).join('');

      const modal = JdrApp.utils.dom.create('div', 'modal elements-modal', `
        <div class="modal-content elements-modal-content">
          <div style="position: relative;">
            <button class="modal-close-x" style="position: absolute; top: 0; right: 0; background: none; border: none; font-size: 20px; cursor: pointer; color: var(--paper-muted); padding: 4px 8px; border-radius: 4px; transition: all 0.2s ease;" onmouseover="this.style.background='var(--rule)'; this.style.color='var(--accent-ink)';" onmouseout="this.style.background='none'; this.style.color='var(--paper-muted)';">×</button>
            <h3>🎨 Éléments</h3>
          </div>
          <p>Cliquez sur un élément pour copier sa balise HTML colorée.</p>
          <div class="elements-list">
            ${elementsHTML}
          </div>
          <button class="modal-close btn">Fermer</button>
        </div>
      `, { id: 'elementsModal' });

      modal.addEventListener('click', (e) => {
        const elementItem = e.target.closest('.element-item');
        if (elementItem) {
          const elementName = elementItem.dataset.element;
          
          // Get the full style configuration from ElementColors
          const style = window.ElementColors[elementName];
          if (style) {
            // Build the complete style string
            let styleString = `color: ${style.color}; font-weight: ${style.weight || 'bold'};`;
            if (style.background) styleString += ` background: ${style.background};`;
            if (style.padding) styleString += ` padding: ${style.padding};`;
            if (style.borderRadius) styleString += ` border-radius: ${style.borderRadius};`;
            
            const html = `<span style="${styleString}">${elementName}</span>`;
            this.copyToClipboard(html);
          } else {
            // Fallback for elements not found
            const html = `<span style="color: ${elementItem.dataset.color}; font-weight: bold;">${elementName}</span>`;
            this.copyToClipboard(html);
          }
          
          elementItem.classList.add('copied');
          
          // Fermer la modale après un court délai pour voir l'effet "Copié!"
          setTimeout(() => {
            this.closeModal(modal);
          }, 500);
        }
      });

      // Gestionnaire pour le bouton X de fermeture
      const closeBtn = modal.querySelector('.modal-close-x');
      if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.closeModal(modal);
        });
      }

      return modal;
    },

    getElementIcon(elementName) {
      const icons = {
        'Feu': '🔥',
        'Air': '💨',
        'Eau': '💧',
        'Terre': '🌍',
        'Divin': '✨',
        'Lumière': '☀️',
        'Maléfique': '💀'
      };
      return icons[elementName] || '⚡';
    },

    showEtatsModal() {
      // TOUJOURS recréer la modal pour avoir les données à jour
      let modal = JdrApp.utils.dom.$('#etatsModal');
      if (modal) {
        document.body.removeChild(modal);
      }
      
      modal = this.createEtatsModal();
      document.body.appendChild(modal);
      
      this.openModal('etatsModal');
    },

    createEtatsModal() {
      // Récupérer les données d'états depuis window.STATIC_PAGES.etats
      const etatsData = window.STATIC_PAGES?.etats;
      const etats = [];
      
      if (etatsData?.sections) {
        etatsData.sections.forEach(section => {
          if (section.type === 'card' && section.title && section.content) {
            // Convertir le HTML en texte en préservant les sauts de ligne
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = section.content;
            
            // Remplacer les balises de saut de ligne par des \n avant d'extraire le texte
            tempDiv.innerHTML = tempDiv.innerHTML
              .replace(/<\/p>/gi, '\n')
              .replace(/<br\s*\/?>/gi, '\n')
              .replace(/<\/li>/gi, '\n')
              .replace(/<\/div>/gi, '\n');
            
            const description = (tempDiv.textContent || tempDiv.innerText || section.content)
              .replace(/\n\s*\n/g, '\n') // Supprimer les doubles sauts de ligne
              .trim();
            
            etats.push({
              name: section.title,
              description: description
            });
          }
        });
      }

      const etatsHTML = etats.map(etat => `
        <div class="etat-item" data-etat-name="${etat.name}" data-etat-description="${etat.description}">
          <div class="etat-icon">⚡</div>
          <div class="etat-content">
            <div class="etat-name">${etat.name}</div>
            <div class="etat-description">${etat.description.length > 60 ? etat.description.substring(0, 60) + '...' : etat.description}</div>
          </div>
          <div class="copy-indicator">Copié!</div>
        </div>
      `).join('');

      const modal = JdrApp.utils.dom.create('div', 'modal etats-modal', `
        <div class="modal-content etats-modal-content">
          <div style="position: relative;">
            <button class="modal-close-x" style="position: absolute; top: 0; right: 0; background: none; border: none; font-size: 20px; cursor: pointer; color: var(--paper-muted); padding: 4px 8px; border-radius: 4px; transition: all 0.2s ease;" onmouseover="this.style.background='var(--rule)'; this.style.color='var(--accent-ink)';" onmouseout="this.style.background='none'; this.style.color='var(--paper-muted)';">×</button>
            <h3>⚡ États</h3>
          </div>
          <p>Cliquez sur un état pour copier un lien avec prévisualisation dans le presse-papiers.</p>
          <div class="etats-list">
            ${etatsHTML || '<div style="text-align: center; color: #666; padding: 2rem;">Aucun état trouvé</div>'}
          </div>
          <button class="modal-close btn">Fermer</button>
        </div>
      `, { id: 'etatsModal' });

      modal.addEventListener('click', (e) => {
        const etatItem = e.target.closest('.etat-item');
        if (etatItem) {
          const etatName = etatItem.dataset.etatName;
          const etatDescription = etatItem.dataset.etatDescription;
          
          // Créer un lien cliquable simple avec prévisualisation (description récupérée dynamiquement)
          const etatLink = `<span class="etat-link" data-etat="${etatName}" style="color: #ea7332; cursor: pointer; text-decoration: underline;">${etatName}</span>`;
          
          // Toujours copier dans le presse-papiers
          this.copyToClipboard(etatLink);
          
          etatItem.classList.add('copied');
          
          // Fermer la modale après un court délai pour voir l'effet "Copié!"
          setTimeout(() => {
            this.closeModal(modal);
          }, 500);
        }
      });

      // Gestionnaire pour le bouton X de fermeture
      const closeBtn = modal.querySelector('.modal-close-x');
      if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.closeModal(modal);
        });
      }

      return modal;
    },

    showSpellLinksModal() {
      let modal = JdrApp.utils.dom.$('#spellLinksModal');
      if (modal) {
        document.body.removeChild(modal);
      }
      
      modal = this.createSpellLinksModal();
      document.body.appendChild(modal);

      
      this.openModal('spellLinksModal');
    },

    createSpellLinksModal() {
      // Récupérer tous les sorts depuis window.SORTS
      const spells = [];
      
      if (window.SORTS && Array.isArray(window.SORTS)) {
        window.SORTS.forEach(category => {
          if (category.sorts && Array.isArray(category.sorts)) {
            category.sorts.forEach(spell => {
              spells.push({
                name: spell.nom,
                category: category.nom,
                element: spell.element,
                description: spell.description || ''
              });
            });
          }
        });
      }

      const spellsHTML = spells.map(spell => `
        <div class="spell-item" data-spell-name="${spell.name}" data-spell-category="${spell.category}">
          <div class="spell-info">
            <div class="spell-name" style="color: ${this.getElementColor(spell.element)}; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">${spell.name}</div>
            <span data-spell-meta style="color: ${this.getElementColor(spell.element)} !important; font-size: 12px; margin-bottom: 6px; display: block;">${this.getElementIcon(spell.element)} ${spell.element} • ${spell.category}</span>
            <div class="spell-description">${spell.description.length > 80 ? spell.description.substring(0, 80) + '...' : spell.description}</div>
          </div>
          <div class="copy-indicator">Copié!</div>
        </div>
      `).join('');

      const modal = JdrApp.utils.dom.create('div', 'modal spell-links-modal', `
        <div class="modal-content spell-links-modal-content">
          <div style="position: relative;">
            <button class="modal-close-x" style="position: absolute; top: 0; right: 0; background: none; border: none; font-size: 20px; cursor: pointer; color: var(--paper-muted); padding: 4px 8px; border-radius: 4px; transition: all 0.2s ease;" onmouseover="this.style.background='var(--rule)'; this.style.color='var(--accent-ink)';" onmouseout="this.style.background='none'; this.style.color='var(--paper-muted)';">×</button>
            <h3>🔮 Liens vers les sorts</h3>
          </div>
          <p>Cliquez sur un sort pour copier un lien avec aperçu interactif.</p>
          <div class="spells-search">
            <input type="text" id="spellSearchInput" placeholder="Rechercher un sort..." style="width: 100%; padding: 8px; margin-bottom: 12px; border: 1px solid var(--rule); border-radius: 4px;">
          </div>
          <div class="spells-list" style="max-height: 400px; overflow-y: auto;">
            ${spellsHTML || '<div style="text-align: center; color: #666; padding: 2rem;">Aucun sort trouvé</div>'}
          </div>
          <button class="modal-close btn">Fermer</button>
        </div>
      `, { id: 'spellLinksModal' });

      // Recherche dans la modal
      const searchInput = modal.querySelector('#spellSearchInput');
      if (searchInput) {
        searchInput.addEventListener('input', (e) => {
          const searchTerm = e.target.value.toLowerCase();
          const spellItems = modal.querySelectorAll('.spell-item');
          
          spellItems.forEach(item => {
            const spellName = item.querySelector('.spell-name').textContent.toLowerCase();
            const spellCategory = item.querySelector('.spell-meta').textContent.toLowerCase();
            
            if (spellName.includes(searchTerm) || spellCategory.includes(searchTerm)) {
              item.style.display = '';
            } else {
              item.style.display = 'none';
            }
          });
        });
      }

      // Clic sur un sort
      modal.addEventListener('click', (e) => {
        const spellItem = e.target.closest('.spell-item');
        if (spellItem) {
          const spellName = spellItem.dataset.spellName;
          const spellCategory = spellItem.dataset.spellCategory;
          
          // Créer le lien HTML avec les attributs nécessaires
          const spellLink = `<span class="spell-link" data-spell="${spellName}" data-category="${spellCategory}" style="color: var(--accent); cursor: pointer; text-decoration: underline;">${spellName}</span>`;
          
          this.copyToClipboard(spellLink);
          
          spellItem.classList.add('copied');
          
          // Fermer la modale après un court délai pour voir l'effet "Copié!"
          setTimeout(() => {
            this.closeModal(modal);
          }, 500);
        }
      });

      // Gestionnaire pour le bouton X de fermeture
      const closeBtn = modal.querySelector('.modal-close-x');
      if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.closeModal(modal);
        });
      }

      return modal;
    },

    getElementColor(element) {
      // Couleurs optimisées pour la lisibilité sur fond clair et foncé
      const colorMap = {
        'Feu': '#e25822',        // Rouge-orange vif
        'Eau': '#2563eb',        // Bleu vif
        'Terre': '#92400e',      // Marron foncé
        'Air': '#059669',        // Vert émeraude
        'Lumière': '#d97706',    // Orange doré (au lieu du jaune pâle)
        'Nuit': '#6b21a8',       // Violet foncé (au lieu du noir)
        'Divin': '#7c2d12',      // Marron doré (au lieu du blanc)
        'Maléfique': '#7c3aed'   // Violet intense
      };
      
      return colorMap[element] || '#666666';
    },

    getElementIcon(element) {
      const icons = window.ElementIcons || {};
      return icons[element] || '⚡';
    },

    showSpellPreview(spellName, categoryName, triggerElement) {
      // Trouver le sort dans les données
      let spellData = null;
      
      if (window.SORTS && Array.isArray(window.SORTS)) {
        for (const category of window.SORTS) {
          if (category.nom === categoryName && category.sorts) {
            spellData = category.sorts.find(spell => spell.nom === spellName);
            if (spellData) break;
          }
        }
      }

      if (!spellData) {
        this.showNotification(`❌ Sort "${spellName}" non trouvé`, 'error');
        return;
      }

      // Fermer toute preview existante
      const existingPreview = document.querySelector('.spell-preview-popup');
      if (existingPreview) {
        existingPreview.remove();
      }

      // Calculer la position de la popup
      const rect = triggerElement.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      
      // Créer la popup de preview
      const popup = document.createElement('div');
      popup.className = 'spell-preview-popup';
      
      const elementColor = this.getElementColor(spellData.element);
      
      popup.innerHTML = `
        <div class="spell-preview-content">
          <div class="spell-preview-header" style="border-left: 4px solid ${elementColor};">
            <div class="spell-title" style="color: ${elementColor}; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">${spellData.nom}</div>
            <span data-element-display style="color: ${elementColor} !important; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">${this.getElementIcon(spellData.element)} ${spellData.element} • ${categoryName}</span>
            <button class="spell-preview-close">✕</button>
          </div>
          <div class="spell-preview-body">
            ${spellData.description ? `<div class="spell-description">${spellData.description}</div>` : ''}
            ${spellData.prerequis ? `<div class="spell-field">${spellData.prerequis}</div>` : ''}
            ${spellData.portee ? `<div class="spell-field">${spellData.portee}</div>` : ''}
            ${spellData.tempsIncantation ? `<div class="spell-field">${spellData.tempsIncantation}</div>` : ''}
            ${spellData.coutMana ? `<div class="spell-field">${spellData.coutMana}</div>` : ''}
            ${spellData.resistance ? `<div class="spell-field">${spellData.resistance}</div>` : ''}
            ${spellData.effetNormal ? `<div class="spell-field">${spellData.effetNormal}</div>` : ''}
            ${spellData.effetCritique ? `<div class="spell-field">${spellData.effetCritique}</div>` : ''}
          </div>
        </div>
      `;

      // Styles de la popup
      popup.style.cssText = `
        position: fixed;
        z-index: 10000;
        background: var(--card);
        border: 2px solid ${elementColor};
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        max-width: 400px;
        max-height: 500px;
        overflow-y: auto;
        font-family: 'Roboto', sans-serif;
        line-height: 1.4;
      `;

      document.body.appendChild(popup);

      // FORCE les couleurs avec JavaScript après ajout au DOM
      setTimeout(() => {
        const elementDisplay = popup.querySelector('[data-element-display]');
        if (elementDisplay) {
          elementDisplay.style.setProperty('color', elementColor, 'important');
        }
      }, 10);

      // Positionner la popup
      const popupRect = popup.getBoundingClientRect();
      let left = rect.left + rect.width / 2 - popupRect.width / 2;
      let top = rect.bottom + 8;

      // Ajustements si la popup sort de l'écran
      if (left < 8) left = 8;
      if (left + popupRect.width > viewportWidth - 8) left = viewportWidth - popupRect.width - 8;
      if (top + popupRect.height > viewportHeight - 8) top = rect.top - popupRect.height - 8;
      if (top < 8) top = 8;

      popup.style.left = `${left}px`;
      popup.style.top = `${top}px`;

      // Gestionnaires d'événements
      popup.querySelector('.spell-preview-close').addEventListener('click', () => {
        popup.remove();
      });

      // Fermer en cliquant à l'extérieur
      const handleOutsideClick = (e) => {
        if (!popup.contains(e.target) && e.target !== triggerElement) {
          popup.remove();
          document.removeEventListener('click', handleOutsideClick);
        }
      };
      
      setTimeout(() => {
        document.addEventListener('click', handleOutsideClick);
      }, 100);

      // Fermer avec Escape
      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          popup.remove();
          document.removeEventListener('keydown', handleEscape);
        }
      };
      document.addEventListener('keydown', handleEscape);
    },

    showEtatPreview(etatName, etatDescription, triggerElement) {
      // Fermer toute preview existante
      const existingPreview = document.querySelector('.etat-preview-popup');
      if (existingPreview) {
        existingPreview.remove();
      }

      // Calculer la position de la popup
      const rect = triggerElement.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      
      // Créer la popup de preview
      const popup = document.createElement('div');
      popup.className = 'etat-preview-popup';
      
      popup.innerHTML = `
        <div class="etat-preview-content">
          <div class="etat-preview-header">
            <div class="etat-title">⚡ ${etatName}</div>
            <button class="etat-preview-close">✕</button>
          </div>
          <div class="etat-preview-body">
            <div class="etat-description">${etatDescription}</div>
          </div>
        </div>
      `;

      // Styles de la popup
      popup.style.cssText = `
        position: fixed;
        z-index: 10000;
        background: var(--card);
        border: 2px solid #7c2d12;
        border-radius: 12px;
        box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        max-width: 300px;
        padding: 1rem;
        font-size: 14px;
        line-height: 1.4;
        color: var(--paper-ink);
        pointer-events: auto;
      `;

      document.body.appendChild(popup);

      // Positionner la popup
      setTimeout(() => {
        const popupRect = popup.getBoundingClientRect();
        let left = rect.left + rect.width / 2 - popupRect.width / 2;
        let top = rect.bottom + 8;

        // Ajustements si la popup sort de l'écran
        if (left < 8) left = 8;
        if (left + popupRect.width > viewportWidth - 8) left = viewportWidth - popupRect.width - 8;
        if (top + popupRect.height > viewportHeight - 8) top = rect.top - popupRect.height - 8;
        if (top < 8) top = 8;

        popup.style.left = `${left}px`;
        popup.style.top = `${top}px`;
      }, 10);

      // Gestionnaires d'événements
      popup.querySelector('.etat-preview-close').addEventListener('click', () => {
        popup.remove();
      });

      // Fermer en cliquant à l'extérieur
      const handleOutsideClick = (e) => {
        if (!popup.contains(e.target) && e.target !== triggerElement) {
          popup.remove();
          document.removeEventListener('click', handleOutsideClick);
        }
      };
      
      setTimeout(() => {
        document.addEventListener('click', handleOutsideClick);
      }, 100);

      // Fermer avec Escape
      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          popup.remove();
          document.removeEventListener('keydown', handleEscape);
        }
      };
      document.addEventListener('keydown', handleEscape);
    },

    copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        this.showNotification('📋 Copié dans le presse-papiers', 'success');
      }).catch(() => {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        this.showNotification('📋 Copié dans le presse-papiers', 'success');
      });
    },

    setupResponsive() {
      this.setupMobileNavigation();
      this.setupLegacyResponsive();
    },

    setupMobileNavigation() {
      // Create mobile navigation toggle button immediately and on resize
      this.createMobileNavToggle();
      
      // Handle mobile nav toggle with delegation
      document.addEventListener('click', (e) => {
        if (e.target.closest('.mobile-nav-toggle')) {
          e.preventDefault();
          this.toggleMobileNav();
        }
      });

      // Auto-close navigation when selecting a page
      document.addEventListener('click', (e) => {
        if (e.target.closest('.toc a') && window.innerWidth <= 980) {
          this.closeMobileNav();
        }
      });

      // Handle window resize
      window.addEventListener('resize', () => {
        if (window.innerWidth <= 980) {
          this.createMobileNavToggle();
        } else {
          this.closeMobileNav();
          const existingButton = document.querySelector('.mobile-nav-toggle');
          if (existingButton) {
            existingButton.remove();
          }
        }
      });
      
      // Also create on DOM content loaded
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          this.createMobileNavToggle();
        });
      }
    },

    createMobileNavToggle() {
      // Only create if it doesn't exist and we're on mobile
      if (window.innerWidth <= 980 && !document.querySelector('.mobile-nav-toggle')) {
        const toggleButton = document.createElement('button');
        toggleButton.className = 'mobile-nav-toggle';
        toggleButton.innerHTML = `
          <span class="icon">📜</span>
          <span class="text">Menu</span>
        `;
        toggleButton.setAttribute('aria-label', 'Ouvrir/fermer le menu de navigation');
        toggleButton.setAttribute('title', 'Navigation');
        toggleButton.type = 'button';
        
        // Insert at the beginning of body
        if (document.body) {
          document.body.insertBefore(toggleButton, document.body.firstChild);
        }
      }
    },

    toggleMobileNav() {
      const sidebar = document.querySelector('.sidebar');
      const toggleButton = document.querySelector('.mobile-nav-toggle');
      
      if (sidebar && toggleButton) {
        const isOpen = sidebar.classList.contains('mobile-open');
        
        if (isOpen) {
          this.closeMobileNav();
        } else {
          this.openMobileNav();
        }
      }
    },

    openMobileNav() {
      const sidebar = document.querySelector('.sidebar');
      const toggleButton = document.querySelector('.mobile-nav-toggle');
      
      if (sidebar && toggleButton) {
        sidebar.classList.add('mobile-open');
        toggleButton.classList.add('open');
        
        const textSpan = toggleButton.querySelector('.text');
        if (textSpan) {
          textSpan.textContent = 'Fermer';
        }
        
        // Add event listener to close on outside click
        setTimeout(() => {
          document.addEventListener('click', this.handleOutsideClick);
        }, 100);
      }
    },

    closeMobileNav() {
      const sidebar = document.querySelector('.sidebar');
      const toggleButton = document.querySelector('.mobile-nav-toggle');
      
      if (sidebar && toggleButton) {
        sidebar.classList.remove('mobile-open');
        toggleButton.classList.remove('open');
        
        const textSpan = toggleButton.querySelector('.text');
        if (textSpan) {
          textSpan.textContent = 'Menu';
        }
        
        // Remove outside click listener
        document.removeEventListener('click', this.handleOutsideClick);
      }
    },

    handleOutsideClick: (e) => {
      const sidebar = document.querySelector('.sidebar');
      const toggleButton = document.querySelector('.mobile-nav-toggle');
      
      // Close if clicking outside sidebar and toggle button
      if (sidebar && toggleButton && 
          !sidebar.contains(e.target) && 
          !toggleButton.contains(e.target)) {
        JdrApp.modules.ui.closeMobileNav();
      }
    },

    setupLegacyResponsive() {
      // Keep existing responsive handlers for compatibility
      JdrApp.utils.events.register('click', '#menuToggle', () => {
        const sidebar = JdrApp.utils.dom.$('#sidebar');
        const backdrop = JdrApp.utils.dom.$('#backdrop');
        
        if (sidebar && backdrop) {
          sidebar.classList.toggle('mobile-open');
          backdrop.hidden = !sidebar.classList.contains('mobile-open');
        }
      });

      JdrApp.utils.events.register('click', '#backdrop', () => {
        const sidebar = JdrApp.utils.dom.$('#sidebar');
        const backdrop = JdrApp.utils.dom.$('#backdrop');
        
        if (sidebar && backdrop) {
          sidebar.classList.remove('mobile-open');
          backdrop.hidden = true;
        }
      });
    },

    showNotification(message, type = 'info') {
      EventBus.emit(Events.NOTIFICATION_SHOW, { message, type });
      
      // Fallback notification if storage module is not available
      if (!JdrApp.modules.storage?.showNotification) {
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: ${type === 'success' ? '#10B981' : type === 'error' ? '#EF4444' : '#3B82F6'};
          color: white;
          padding: 12px 16px;
          border-radius: 8px;
          font-weight: 500;
          z-index: 10000;
          animation: slideIn 0.3s ease;
        `;
        
        notification.textContent = message;
        document.body.appendChild(notification);
        
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 3000);
      } else {
        JdrApp.modules.storage.showNotification(message, type);
      }
    },

    // Get current page ID from DOM
    getCurrentPageId() {
      // Find the currently visible article (not hidden)
      const articles = document.querySelectorAll('article[data-static-page="true"]');
      let visibleArticle = null;
      
      for (const article of articles) {
        const style = window.getComputedStyle(article);
        if (style.display !== 'none' && style.visibility !== 'hidden') {
          visibleArticle = article;
          break;
        }
      }
      
      // Fallback: find by active class or current hash
      if (!visibleArticle) {
        const hash = window.location.hash.replace('#/', '');
        if (hash) {
          visibleArticle = document.querySelector(`article[data-page="${hash}"]`);
        }
      }
      
      // Last fallback: any visible article
      if (!visibleArticle) {
        visibleArticle = document.querySelector('article[data-static-page="true"]:not([style*="display: none"])');
      }
      
      const pageId = visibleArticle ? visibleArticle.dataset.page : null;
      if (visibleArticle) {
      }
      return pageId;
    },

    // Count existing sections for unique ID generation
    countExistingSections() {
      const pageId = this.getCurrentPageId();
      if (!pageId || !window.STATIC_PAGES || !window.STATIC_PAGES[pageId]) {
        return 0;
      }
      const pageData = window.STATIC_PAGES[pageId];
      return pageData.sections ? pageData.sections.length : 0;
    },

    // Save new section to JSON data
    saveNewSectionToJSON(sectionId, title, content) {
      const pageId = this.getCurrentPageId();
      
      if (!pageId || !window.STATIC_PAGES || !window.STATIC_PAGES[pageId]) {
        // Cannot save new section - page not found
        return false;
      }

      const pageData = window.STATIC_PAGES[pageId];
      
      // Create new section object
      const newSection = {
        type: "card",
        id: sectionId,
        title: title,
        content: content,
        deletable: true,
        sectionName: title
      };

      // Add to sections array
      if (!pageData.sections) {
        pageData.sections = [];
      }
      
      pageData.sections.push(newSection);
      
      return true;
    },

    // Delete section from JSON data
    deleteSectionFromJSON(sectionId) {
      const pageId = this.getCurrentPageId();
      if (!pageId || !window.STATIC_PAGES || !window.STATIC_PAGES[pageId]) {
        console.warn('Cannot delete section - page not found:', pageId);
        return false;
      }

      const pageData = window.STATIC_PAGES[pageId];
      if (!pageData.sections) {
        console.warn('No sections found in page data');
        return false;
      }

      console.log(`🗑️ SUPPRESSION JSON: Tentative de suppression "${sectionId}" de ${pageId}.json`);
      console.log('📊 État JSON avant suppression:', {
        pageId,
        totalSections: pageData.sections.length,
        sectionIds: pageData.sections.map(s => s.id)
      });

      // Remove section by ID
      const initialLength = pageData.sections.length;
      pageData.sections = pageData.sections.filter(section => section.id !== sectionId);
      
      // Check if section was found and removed
      const removed = pageData.sections.length < initialLength;
      if (removed) {
        console.log(`✅ SUPPRESSION JSON: Section "${sectionId}" supprimée de ${pageId}.json`);
        console.log('📊 État JSON après suppression:', {
          pageId,
          totalSections: pageData.sections.length,
          sectionIds: pageData.sections.map(s => s.id)
        });
        return true;
      } else {
        // Try to find in nested grid content
        for (let section of pageData.sections) {
          if (section.type === 'grid' && section.content) {
            const gridInitialLength = section.content.length;
            section.content = section.content.filter(item => item.id !== sectionId);
            if (section.content.length < gridInitialLength) {
              console.log(`✅ SUPPRESSION JSON: Section "${sectionId}" supprimée de grille dans ${pageId}.json`);
              return true;
            }
          }
        }
        
        return false;
      }
    },

    // Recalculate all section indices in the current page to prevent conflicts
    recalculateSectionIndices() {
      // Disable index recalculation for now - it causes ID mismatches
      // The current approach of using timestamp-based unique IDs is more stable
      console.log('Index recalculation disabled - using stable unique IDs');
      return true;
    },

    // OLD VERSION - kept for reference but disabled
    _recalculateSectionIndicesOld() {
      const pageId = this.getCurrentPageId();
      if (!pageId) {
        console.warn('Cannot recalculate indices - no current page');
        return false;
      }

      // Update DOM data-edit-section attributes to match JSON structure
      const article = document.querySelector('article[data-static-page="true"]');
      if (!article) {
        console.warn('No static page article found');
        return false;
      }

      // Get the JSON data for this page
      const pageData = window.STATIC_PAGES?.[pageId];
      if (!pageData?.sections) {
        console.warn('No page data found for recalculation');
        return false;
      }

      // Build a mapping of DOM sections to JSON sections
      const sections = article.querySelectorAll('.editable-section, .card');
      let sectionIndex = 0;

      sections.forEach((domSection, domIndex) => {
        // Skip sections that don't have editable content
        const editableElements = domSection.querySelectorAll('[data-edit-section]');
        if (editableElements.length === 0) return;

        // Find corresponding JSON section
        let jsonSection = null;
        let jsonIndex = sectionIndex;

        // Try to match by existing ID first
        const firstEditable = editableElements[0];
        let currentId = firstEditable.dataset.editSection;
        if (currentId.endsWith('-title')) {
          currentId = currentId.replace('-title', '');
        }

        // Look for matching JSON section
        for (let i = 0; i < pageData.sections.length; i++) {
          const section = pageData.sections[i];
          if (section.id === currentId || section.type === 'intro') {
            jsonSection = section;
            jsonIndex = i;
            break;
          }
        }

        // If no match found, assign next available index
        if (!jsonSection && sectionIndex < pageData.sections.length) {
          jsonSection = pageData.sections[sectionIndex];
          jsonIndex = sectionIndex;
        }

        if (jsonSection) {
          // Update DOM attributes to match JSON structure
          editableElements.forEach(editable => {
            const currentEditSection = editable.dataset.editSection;
            
            // Determine the new ID based on JSON section
            let newEditSection;
            if (currentEditSection.endsWith('-title')) {
              newEditSection = `${jsonSection.id}-title`;
            } else {
              newEditSection = jsonSection.id;
            }

            // Update the data attribute
            editable.dataset.editSection = newEditSection;
            
            console.log(`Updated section ${domIndex}: ${currentEditSection} → ${newEditSection}`);
          });

          sectionIndex++;
        }
      });

      // Also update section indices in JSON to ensure consistency
      pageData.sections.forEach((section, index) => {
        // Ensure each section has a proper ID
        if (!section.id || section.id.startsWith('section-')) {
          // Generate a stable ID based on title or position
          const baseId = section.title ? 
            section.title.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '') :
            `section-${index}`;
          section.id = baseId;
        }
      });

      console.log(`Recalculated indices for ${sectionIndex} sections in page ${pageId}`);
      return true;
    },

    // Trigger data save to localStorage/persistent storage
    triggerDataSave() {
      // Data is already saved in window.STATIC_PAGES in memory
    },

    createNewCategory(type) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`❌ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Demander le nom de la catégorie
      const categoryName = prompt(`Nom de la nouvelle catégorie de ${config.container} :`);
      if (!categoryName || !categoryName.trim()) {
        return;
      }

      const trimmedName = categoryName.trim();

      // Vérifier que la catégorie n'existe pas déjà
      const entity = ContentFactory.getEntity(type);
      if (entity && entity.findCategory(trimmedName)) {
        this.showNotification(`❌ Une catégorie "${trimmedName}" existe déjà`, 'error');
        return;
      }

      // Demander la description et spoilAlert pour les objets
      let description = prompt(`Description de la catégorie "${trimmedName}" :`);
      if (!description) description = '';

      let spoilAlert = false;
      if (type === 'objet') {
        spoilAlert = confirm('Cette catégorie contient-elle des éléments de spoil ?');
      }

      // Créer la nouvelle catégorie
      const newCategory = {
        nom: trimmedName,
        description: description.trim(),
        [config.identifiers.category]: []
      };

      // Ajouter spoilAlert pour les objets
      if (type === 'objet') {
        newCategory.spoilAlert = spoilAlert;
      }

      // Ajouter à la structure de données
      const dataKey = config.dataKey;
      if (!window[dataKey]) {
        window[dataKey] = [];
      }

      window[dataKey].push(newCategory);

      // Rafraîchir ContentFactory
      ContentFactory.refreshData();

      // Rafraîchir le router TOC
      if (JdrApp.modules.router && JdrApp.modules.router.generateTOC) {
        JdrApp.modules.router.generateTOC();
      }

      // Naviguer vers la nouvelle catégorie
      const categoryRoute = `${config.container}-${JdrApp.utils.data.sanitizeId(trimmedName)}`;
      JdrApp.modules.router.navigate(categoryRoute);

      this.showNotification(`${config.icons.category} Catégorie "${trimmedName}" créée avec succès!`, 'success');
    },

    deleteCategory(type, categoryName) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`❌ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Confirmation avec détails
      const entity = ContentFactory.getEntity(type);
      const category = entity?.findCategory(categoryName);
      
      if (!category) {
        this.showNotification(`❌ Catégorie "${categoryName}" introuvable`, 'error');
        return;
      }

      const itemsProperty = this.getItemsProperty(type);
      const itemCount = category[itemsProperty]?.length || 0;
      
      const confirmMessage = itemCount > 0 
        ? `Supprimer la catégorie "${categoryName}" et ses ${itemCount} éléments ?`
        : `Supprimer la catégorie vide "${categoryName}" ?`;
        
      if (!confirm(confirmMessage)) {
        return;
      }

      // Supprimer de la structure de données
      const dataKey = config.dataKey;
      if (window[dataKey]) {
        const categoryIndex = window[dataKey].findIndex(cat => cat.nom === categoryName);
        
        if (categoryIndex >= 0) {
          window[dataKey].splice(categoryIndex, 1);
          
          // Rafraîchir ContentFactory
          ContentFactory.refreshData();

          // Rafraîchir le router TOC
          if (JdrApp.modules.router && JdrApp.modules.router.generateTOC) {
            JdrApp.modules.router.generateTOC();
          }

          // Naviguer vers la page principale du type
          JdrApp.modules.router.navigate(config.container);

          this.showNotification(`${config.icons.delete} Catégorie "${categoryName}" supprimée`, 'success');
        } else {
          this.showNotification(`❌ Erreur lors de la suppression`, 'error');
        }
      }
    },

    getItemsProperty(type) {
      switch (type) {
        case 'spell': return 'sorts';
        case 'don': return 'dons';
        case 'objet': return 'objets';
        case 'class': return 'sousClasses';
        default: return 'items';
      }
    },

    // SUPPRIMÉ: Toutes les méthodes de gestion des filtres (showFilterManagementModal, createFilterModal, updateFilterModalContent, saveFilterSettings, resetFilterSettings, moveTagInModal)

    refreshObjectsPage() {
      // Check if we're currently on the objects page
      if (window.location.hash === '#/objets' || window.location.hash === '#/objet') {
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: 'objet',
          category: window.OBJETS
        });
      }
    },

    refreshMonstersPage() {
      // Check if we're currently on the monsters page
      if (window.location.hash === '#/monstres' || window.location.hash === '#/monstre') {
        // Use the router to refresh the monsters page
        if (JdrApp.modules.router && JdrApp.modules.router.renderMonstersPage) {
          JdrApp.modules.router.renderMonstersPage();
        }
      }
    },

    refreshTablesTresorsPage() {
      // Check if we're currently on the tables de trésors page
      if (window.location.hash === '#/tables-tresors') {
        // Use the router to refresh the tables de trésors page
        if (JdrApp.modules.router && JdrApp.modules.router.renderTablesTresorsPage) {
          JdrApp.modules.router.renderTablesTresorsPage();
        }
      }
    },

    // ==== SPELL ELEMENT MANAGEMENT ====

    updateSpellElement(selectElement) {
      // Get the selected element
      const newElement = selectElement.value;
      const spellName = selectElement.dataset.spellName;
      const categoryName = selectElement.dataset.categoryName;

      if (!newElement || !spellName || !categoryName) {
        this.showNotification('❌ Erreur : données du sort manquantes', 'error');
        return;
      }

      // Find and update the spell data
      const spellEntity = ContentFactory.getEntity('spell');
      const category = spellEntity?.findCategory(categoryName);
      
      if (!category) {
        this.showNotification(`❌ Catégorie "${categoryName}" introuvable`, 'error');
        return;
      }

      const spell = category.sorts?.find(s => s.nom === spellName);
      if (!spell) {
        this.showNotification(`❌ Sort "${spellName}" introuvable`, 'error');
        return;
      }

      // Update the spell element
      spell.element = newElement;

      // Save the changes to storage
      EventBus.emit(Events.STORAGE_SAVE);

      // Update the visual display
      const spellCard = selectElement.closest('.card');
      if (spellCard) {
        const elementDisplay = spellCard.querySelector('.spell-element-selector').parentNode;
        if (elementDisplay) {
          // Find the icon and colors for the new element
          const icon = window.ElementIcons ? window.ElementIcons[newElement] : '🔥';
          const colors = window.ElementColors ? window.ElementColors[newElement] : { color: '#ff6b35', weight: 'bold' };
          
          // Build style string
          let style = `color: ${colors.color}; font-weight: ${colors.weight};`;
          if (colors.background) style += ` background: ${colors.background};`;
          if (colors.padding) style += ` padding: ${colors.padding};`;
          if (colors.borderRadius) style += ` border-radius: ${colors.borderRadius};`;
          
          // Update the dropdown options to reflect the selection
          const options = Object.keys(window.ElementIcons || {});
          const optionsHTML = options.map(elem => 
            `<option value="${elem}" ${elem === newElement ? 'selected' : ''}>${window.ElementIcons[elem]} ${elem}</option>`
          ).join('');
          
          selectElement.innerHTML = optionsHTML;
        }
      }

      // Trigger page re-render to update all spell displays
      EventBus.emit(Events.PAGE_RENDER, {
        type: 'category',
        categoryType: 'spell',
        category: category
      });

      // Show success notification
      const elementIcon = window.ElementIcons ? window.ElementIcons[newElement] : '🔥';
      this.showNotification(`${elementIcon} Élément du sort "${spellName}" mis à jour : ${newElement}`, 'success');
    },

    // ========================================
    // NEW PAGE CREATION WITH SECTION SELECTION
    // ========================================
    setupNewPageHandler() {
      // Set up event listener for "Nouvelle page" button
      document.addEventListener('click', (e) => {
        if (e.target && e.target.id === 'addCategory') {
          e.preventDefault();
          this.showSectionSelectionModal();
        }
      });
    },

    showSectionSelectionModal() {
      const modal = this.createSectionSelectionModal();
      document.body.appendChild(modal);
      this.openModal('sectionSelectionModal');
    },

    createSectionSelectionModal() {
      // Get available sections from TOC structure
      const sections = window.TOC_STRUCTURE?.sections || [
        { id: 'heros', title: '🦸 Héros', icon: '🦸' },
        { id: 'arsenal', title: '⚔️ Arsenal', icon: '⚔️' },
        { id: 'regles', title: '📚 Règles', icon: '📚' }
      ];

      // Filter sections based on MJ access if needed
      const availableSections = sections.filter(section => 
        !section.requiresMJ || window.JdrApp?.state?.isMJ
      );

      const sectionsHTML = availableSections.map(section => `
        <div class="section-option" data-section-id="${section.id}">
          <div class="section-icon">${section.icon}</div>
          <div class="section-info">
            <div class="section-title">${section.title}</div>
            <div class="section-description">${section.description || 'Section de contenu'}</div>
          </div>
        </div>
      `).join('');

      const modal = document.createElement('div');
      modal.className = 'modal section-selection-modal';
      modal.id = 'sectionSelectionModal';
      modal.innerHTML = `
        <div class="modal-overlay"></div>
        <div class="modal-content">
          <h3>📄 Nouvelle page</h3>
          <p>Dans quelle section souhaitez-vous créer la nouvelle page ?</p>
          
          <div class="sections-list">
            ${sectionsHTML}
          </div>
          
          <div class="page-details" style="display: none;">
            <div class="form-group">
              <label for="pageTitle">Titre de la page :</label>
              <input type="text" id="pageTitle" placeholder="Nom de la nouvelle page" required>
            </div>
            <div class="form-group">
              <label for="pageIcon">Icône (optionnel) :</label>
              <select id="pageIcon">
                <option value="📄">📄 Page</option>
                <option value="⚔️">⚔️ Combat</option>
                <option value="🔮">🔮 Magie</option>
                <option value="🏛️">🏛️ Lieu</option>
                <option value="👥">👥 Personnages</option>
                <option value="📚">📚 Règles</option>
                <option value="🗡️">🗡️ Armes</option>
                <option value="🛡️">🛡️ Armures</option>
                <option value="💰">💰 Économie</option>
                <option value="🌟">🌟 Éléments</option>
                <option value="📊">📊 Statistiques</option>
                <option value="🎯">🎯 Compétences</option>
                <option value="⚡">⚡ États</option>
                <option value="📜">📜 Histoire</option>
                <option value="🗺️">🗺️ Géographie</option>
                <option value="👹">👹 Monstres</option>
                <option value="🎭">🎭 Culture</option>
                <option value="🏰">🏰 Royaumes</option>
                <option value="⭐">⭐ Important</option>
                <option value="💎">💎 Trésors</option>
              </select>
            </div>
          </div>
          
          <div class="modal-actions">
            <button type="button" class="btn modal-close">Annuler</button>
            <button type="button" class="btn btn-primary" id="createPageBtn" style="display: none;">Créer la page</button>
          </div>
        </div>
      `;

      // Set up event handlers
      this.setupSectionSelectionHandlers(modal);

      return modal;
    },

    setupSectionSelectionHandlers(modal) {
      let selectedSectionId = null;

      // Section selection
      modal.addEventListener('click', (e) => {
        const sectionOption = e.target.closest('.section-option');
        if (sectionOption) {
          // Remove previous selection
          modal.querySelectorAll('.section-option').forEach(opt => opt.classList.remove('selected'));
          
          // Select this section
          sectionOption.classList.add('selected');
          selectedSectionId = sectionOption.dataset.sectionId;
          
          // Show page details form
          const pageDetails = modal.querySelector('.page-details');
          const createBtn = modal.querySelector('#createPageBtn');
          pageDetails.style.display = 'block';
          createBtn.style.display = 'inline-block';
          
          // Focus on title input
          modal.querySelector('#pageTitle').focus();
        }
      });

      // Create page button
      modal.querySelector('#createPageBtn').addEventListener('click', () => {
        const titleInput = modal.querySelector('#pageTitle');
        const iconInput = modal.querySelector('#pageIcon');
        
        const pageTitle = titleInput.value.trim();
        const pageIcon = iconInput.value || '📄';
        
        if (!pageTitle) {
          this.showNotification('Veuillez saisir un titre pour la page', 'error');
          titleInput.focus();
          return;
        }

        if (!selectedSectionId) {
          this.showNotification('Veuillez sélectionner une section', 'error');
          return;
        }

        this.createNewPage(selectedSectionId, pageTitle, pageIcon);
        this.closeModal(modal);
      });

      // Handle Enter key in form
      modal.querySelector('#pageTitle').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && selectedSectionId) {
          modal.querySelector('#createPageBtn').click();
        }
      });
    },

    createNewPage(sectionId, pageTitle, pageIcon) {
      // Generate page ID from title
      const pageId = this.slugify(pageTitle);
      
      // Create new page object
      const newPage = {
        type: 'page',
        id: pageId,
        title: pageTitle,
        icon: pageIcon
      };

      // Add to TOC structure
      if (window.TOC_STRUCTURE) {
        const section = window.TOC_STRUCTURE.sections.find(s => s.id === sectionId);
        if (section) {
          section.items.push(newPage);
          
          // Create default page data
          const defaultPageData = {
            page: pageId,
            title: pageTitle,
            sections: [
              {
                type: 'intro',
                content: `Contenu de la page ${pageTitle}. Vous pouvez éditer ce texte en mode développement.`
              }
            ]
          };

          // Add to static pages
          if (!window.STATIC_PAGES) {
            window.STATIC_PAGES = {};
          }
          window.STATIC_PAGES[pageId] = defaultPageData;

          // Add to static pages config
          if (!window.STATIC_PAGES_CONFIG) {
            window.STATIC_PAGES_CONFIG = { pages: [] };
          }
          const newPageConfig = {
            id: pageId,
            title: pageTitle,
            file: `${pageId}.json`,
            active: true,
            order: window.STATIC_PAGES_CONFIG.pages.length + 1
          };
          window.STATIC_PAGES_CONFIG.pages.push(newPageConfig);

          // Create the article element for the new page
          this.createPageArticle(pageId, pageTitle, defaultPageData);

          // Regenerate TOC to include new page
          if (JdrApp.modules.router) {
            JdrApp.modules.router.generateTOC();
          }

          // Save changes
          if (JdrApp.modules.storage) {
            JdrApp.modules.storage.saveChanges(true);
          }

          // Navigate to new page
          window.location.hash = `#/${pageId}`;

          this.showNotification(`📄 Page "${pageTitle}" créée avec succès dans la section ${this.getSectionTitle(sectionId)}`, 'success');
        }
      }
    },

    createPageArticle(pageId, pageTitle, pageData) {
      // Force the renderer to generate the page content immediately
      if (JdrApp.modules.renderer && JdrApp.modules.renderer.generatePageContent) {
        const content = JdrApp.modules.renderer.generatePageContent(pageId);
        if (content) {
          // Create the article if it doesn't exist
          let article = document.querySelector(`article[data-page="${pageId}"]`);
          if (!article) {
            article = document.createElement('article');
            article.setAttribute('data-page', pageId);
            article.style.display = 'none';
            const viewsContainer = document.getElementById('views');
            if (viewsContainer) {
              viewsContainer.appendChild(article);
            }
          }
          // Set the content
          article.innerHTML = content;
        }
      }
    },

    getSectionTitle(sectionId) {
      if (window.TOC_STRUCTURE) {
        const section = window.TOC_STRUCTURE.sections.find(s => s.id === sectionId);
        return section ? section.title : sectionId;
      }
      return sectionId;
    },

    // ==== GLOBAL TAGS MANAGEMENT ====

    showTagsManagementModal() {
      // Déterminer le type de contenu basé sur la page actuelle
      const currentPage = window.location.hash.replace('#/', '') || 'creation';
      let contentType = 'objet'; // par défaut
      let config = null;
      
      if (currentPage === 'monstres' && window.ContentTypes.monster?.filterConfig) {
        contentType = 'monster';
        config = window.ContentTypes.monster.filterConfig;
      } else if (window.ContentTypes.objet?.filterConfig) {
        contentType = 'objet';
        config = window.ContentTypes.objet.filterConfig;
      }
      
      if (!config) {
        this.showNotification('❌ Configuration des tags non trouvée', 'error');
        return;
      }

      // Remove any existing modal
      const existingModal = document.querySelector('#tagsManagementModal');
      if (existingModal) {
        existingModal.remove();
      }

      const modal = this.createTagsManagementModal(config, contentType);
      document.body.appendChild(modal);
      
      // Use native dialog showModal for proper z-index
      modal.showModal();
    },

    createTagsManagementModal(config, contentType = 'objet') {
      const modal = document.createElement('dialog');
      modal.id = 'tagsManagementModal';
      modal.style.cssText = `
        max-width: 600px;
        width: 90%;
        padding: 0;
        border: none;
        border-radius: 12px;
        background: transparent;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      `;

      const tagsListHTML = config.availableTags.map((tag, index) => `
        <div class="tag-item" data-tag-index="${index}" data-tag-name="${tag}">
          <span class="tag-chip" style="background: var(--bronze); color: white; padding: 4px 8px; border-radius: 8px; margin-right: 0.5rem;">${tag}</span>
          <input type="text" value="${tag}" class="tag-input" style="flex: 1; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 4px; margin-right: 0.5rem;">
          <button type="button" class="btn small delete-tag-btn" data-tag-name="${tag}" style="background: #dc2626 !important; color: white !important; padding: 0.25rem 0.5rem !important; display: inline-block !important; opacity: 1 !important; visibility: visible !important;">
            🗑️
          </button>
        </div>
      `).join('');

      modal.innerHTML = `
        <div style="background: var(--paper); border-radius: 12px; padding: 1.5rem; border: 2px solid var(--rule);">
          <h3 style="margin: 0 0 1rem 0; color: var(--accent-ink);">🏷️ Gestion des tags globaux</h3>
          <p style="margin: 0 0 1rem 0; color: var(--paper-muted);">Gérez la liste principale des tags disponibles pour les ${contentType === 'monster' ? 'monstres' : 'objets'}.</p>
          
          <div style="margin: 1rem 0;">
            <h4 style="margin: 0 0 0.5rem 0; color: var(--accent-ink);">Tags existants :</h4>
            <div id="tagsManagementList" style="max-height: 300px; overflow-y: auto;">
              ${tagsListHTML}
            </div>
          </div>
          
          <div style="margin: 1rem 0; padding: 1rem; background: var(--card); border-radius: 8px;">
            <h4 style="margin: 0 0 0.5rem 0; color: var(--accent-ink);">Ajouter un nouveau tag :</h4>
            <div style="display: flex; gap: 0.5rem; align-items: center;">
              <input type="text" id="newTagInput" placeholder="Nom du nouveau tag" style="flex: 1; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 4px;">
              <button type="button" id="addTagBtn" class="btn" style="background: var(--accent); color: white;">
                ➕ Ajouter
              </button>
            </div>
          </div>
          
          <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem;">
            <button type="button" class="btn modal-close" style="background: #666; color: white;">
              ❌ Annuler
            </button>
            <button type="button" id="saveTagsManagementBtn" class="btn" style="background: var(--accent); color: white;">
              💾 Sauvegarder
            </button>
          </div>
        </div>
      `;

      this.setupTagsManagementHandlers(modal, config, contentType);
      return modal;
    },

    setupTagsManagementHandlers(modal, config, contentType = 'objet') {
      // Add new tag
      modal.querySelector('#addTagBtn').addEventListener('click', () => {
        const input = modal.querySelector('#newTagInput');
        const newTag = input.value.trim();
        
        if (!newTag) {
          this.showNotification('❌ Veuillez saisir un nom de tag', 'error');
          return;
        }
        
        if (config.availableTags.includes(newTag)) {
          this.showNotification(`❌ Le tag "${newTag}" existe déjà`, 'error');
          return;
        }
        
        // Add to temporary config (will be saved when user clicks save)
        config.availableTags.push(newTag);
        
        // Update the modal display
        this.refreshTagsManagementModal(modal, config);
        
        // Clear input
        input.value = '';
        this.showNotification(`➕ Tag "${newTag}" ajouté à la liste`, 'success');
      });

      // Handle Enter key in new tag input
      modal.querySelector('#newTagInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          modal.querySelector('#addTagBtn').click();
        }
      });

      // Delete tag
      modal.addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-tag-btn')) {
          const tagName = e.target.dataset.tagName;
          
          if (config.availableTags.length <= 1) {
            this.showNotification('❌ Impossible de supprimer le dernier tag', 'error');
            return;
          }
          
          if (confirm(`Supprimer le tag "${tagName}" ?\nAttention: il sera retiré de tous les objets qui l'utilisent.`)) {
            // Remove from config
            config.availableTags = config.availableTags.filter(tag => tag !== tagName);
            
            // Remove from all items that use this tag
            if (contentType === 'monster' && Array.isArray(window.MONSTRES)) {
              window.MONSTRES.forEach(monster => {
                if (monster.tags && monster.tags.includes(tagName)) {
                  monster.tags = monster.tags.filter(tag => tag !== tagName);
                  // Ensure monster has at least one tag if possible
                  if (monster.tags.length === 0 && config.availableTags.length > 0) {
                    monster.tags = [config.availableTags[0]];
                  }
                }
              });
              
              // Update filter settings to remove deleted tag for monsters
              if (window.MONSTRES_FILTER_STATE?.visibleTags) {
                window.MONSTRES_FILTER_STATE.visibleTags = window.MONSTRES_FILTER_STATE.visibleTags.filter(tag => tag !== tagName);
                // Ensure at least one visible tag remains
                if (window.MONSTRES_FILTER_STATE.visibleTags.length === 0 && config.availableTags.length > 0) {
                  window.MONSTRES_FILTER_STATE.visibleTags = [config.availableTags[0]];
                }
              }
            } else if (contentType === 'objet' && window.OBJETS?.objets) {
              window.OBJETS.objets.forEach(obj => {
                if (obj.tags && obj.tags.includes(tagName)) {
                  obj.tags = obj.tags.filter(tag => tag !== tagName);
                  // Ensure object has at least one tag if possible
                  if (obj.tags.length === 0 && config.availableTags.length > 0) {
                    obj.tags = [config.availableTags[0]];
                  }
                }
              });
              
              // Update filter settings to remove deleted tag for objects
              if (window.OBJETS?.filterSettings?.visibleTags) {
                window.OBJETS.filterSettings.visibleTags = window.OBJETS.filterSettings.visibleTags.filter(tag => tag !== tagName);
                // Ensure at least one visible tag remains
                if (window.OBJETS.filterSettings.visibleTags.length === 0 && config.availableTags.length > 0) {
                  window.OBJETS.filterSettings.visibleTags = [config.availableTags[0]];
                }
              }
            }
            
            // Update modal display
            this.refreshTagsManagementModal(modal, config);
            this.showNotification(`🗑️ Tag "${tagName}" supprimé`, 'success');
          }
        }
      });

      // Save all changes
      modal.querySelector('#saveTagsManagementBtn').addEventListener('click', () => {
        // Collect all tag renames
        const tagItems = modal.querySelectorAll('.tag-item');
        const renames = [];
        
        tagItems.forEach(item => {
          const originalName = item.dataset.tagName;
          const newName = item.querySelector('.tag-input').value.trim();
          
          if (newName && newName !== originalName) {
            renames.push({ old: originalName, new: newName });
          }
        });
        
        // Apply renames to config
        renames.forEach(rename => {
          const index = config.availableTags.indexOf(rename.old);
          if (index >= 0) {
            config.availableTags[index] = rename.new;
            
            // Update all items that use this tag
            if (contentType === 'monster' && Array.isArray(window.MONSTRES)) {
              window.MONSTRES.forEach(monster => {
                if (monster.tags && monster.tags.includes(rename.old)) {
                  const tagIndex = monster.tags.indexOf(rename.old);
                  monster.tags[tagIndex] = rename.new;
                }
              });
            } else if (contentType === 'objet' && window.OBJETS?.objets) {
              window.OBJETS.objets.forEach(obj => {
                if (obj.tags && obj.tags.includes(rename.old)) {
                  const tagIndex = obj.tags.indexOf(rename.old);
                  obj.tags[tagIndex] = rename.new;
                }
              });
              
              // Update filter settings for objects
              if (window.OBJETS?.filterSettings?.visibleTags) {
                const visibleIndex = window.OBJETS.filterSettings.visibleTags.indexOf(rename.old);
                if (visibleIndex >= 0) {
                  window.OBJETS.filterSettings.visibleTags[visibleIndex] = rename.new;
                }
              }
            }
          }
        });
        
        // Save to storage
        EventBus.emit(Events.STORAGE_SAVE);
        
        // Refresh current page if it matches the content type
        if (contentType === 'monster') {
          this.refreshMonstersPage();
        } else {
          this.refreshObjectsPage();
        }
        
        // Close modal
        modal.close();
        modal.remove();
        
        const changesCount = renames.length;
        if (changesCount > 0) {
          this.showNotification(`💾 ${changesCount} modification(s) sauvegardée(s)`, 'success');
        } else {
          this.showNotification('💾 Tags sauvegardés', 'success');
        }
      });

      // Close modal events
      modal.querySelector('.modal-close').addEventListener('click', () => {
        modal.close();
        modal.remove();
      });

      modal.addEventListener('cancel', () => {
        modal.close();
        modal.remove();
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.close();
          modal.remove();
        }
      });
    },

    refreshTagsManagementModal(modal, config) {
      const container = modal.querySelector('#tagsManagementList');
      if (!container) return;

      const tagsListHTML = config.availableTags.map((tag, index) => `
        <div class="tag-item" data-tag-index="${index}" data-tag-name="${tag}">
          <span class="tag-chip" style="background: var(--bronze); color: white; padding: 4px 8px; border-radius: 8px; margin-right: 0.5rem;">${tag}</span>
          <input type="text" value="${tag}" class="tag-input" style="flex: 1; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 4px; margin-right: 0.5rem;">
          <button type="button" class="btn small delete-tag-btn" data-tag-name="${tag}" style="background: #dc2626; color: white; padding: 0.25rem 0.5rem;">
            🗑️
          </button>
        </div>
      `).join('');

      container.innerHTML = tagsListHTML;
    },

    // ==== ID SEARCH FUNCTIONALITY ====

    performIdSearch(searchValue) {
      const searchId = searchValue.trim();
      const resultDiv = document.querySelector('#id-search-result');
      
      if (!searchId) {
        this.clearIdSearch();
        return;
      }

      const searchNumber = parseInt(searchId, 10);
      if (isNaN(searchNumber)) {
        if (resultDiv) {
          resultDiv.innerHTML = '❌ Veuillez saisir un numéro valide';
          resultDiv.style.color = '#dc2626';
        }
        return;
      }

      // Find object by number
      const allObjects = window.OBJETS?.objets || [];
      const foundObject = allObjects.find(obj => obj.numero === searchNumber);

      if (!foundObject) {
        if (resultDiv) {
          resultDiv.innerHTML = `❌ Aucun objet trouvé avec l'ID ${searchNumber}`;
          resultDiv.style.color = '#dc2626';
        }
        // Hide all objects
        this.hideAllObjects();
        return;
      }

      // Set global flag BEFORE regenerating page
      window.activeIdSearch = true;

      // Immediately hide the container to prevent flash
      const container = document.querySelector('#objets-container');
      if (container) {
        container.style.visibility = 'hidden';
      }

      // Show success message immediately
      if (resultDiv) {
        resultDiv.innerHTML = `✅ Objet trouvé : "${foundObject.nom}" (ID: ${searchNumber})`;
        resultDiv.style.color = '#16a34a';
      }

      // Force regenerate page with all objects AND visual feedback
      if (JdrApp.modules.renderer?.regenerateCurrentPage) {
        JdrApp.modules.renderer.regenerateCurrentPage();
      }

      // After regeneration, configure display and show only target object
      requestAnimationFrame(() => {
        const newContainer = document.querySelector('#objets-container');
        if (newContainer) {
          // Hide all objects first
          this.hideAllObjects();
          
          // Show only the target object and make container visible again
          setTimeout(() => {
            this.showOnlyObjectById(searchNumber);
            newContainer.style.visibility = 'visible';
            
            // Restore the search value in the input field
            const searchInput = document.querySelector('#id-search-input');
            if (searchInput) {
              searchInput.value = searchNumber;
            }
          }, 10);
        }
      });
    },

    clearIdSearch() {
      const input = document.querySelector('#id-search-input');
      const resultDiv = document.querySelector('#id-search-result');
      
      if (input) {
        input.value = '';
      }
      
      if (resultDiv) {
        resultDiv.innerHTML = '';
        resultDiv.style.color = '';
      }

      // Clear global flag for active ID search
      window.activeIdSearch = false;

      // Reset container styles when clearing search
      const container = document.querySelector('#objets-container');
      if (container) {
        container.style.display = '';
        container.style.flexDirection = '';
        container.style.alignItems = '';
        container.style.justifyContent = '';
        container.style.minHeight = '';
        container.style.padding = '';
        container.style.visibility = ''; // Restore visibility
        
        // Reset all card sizes to normal
        const allCards = container.querySelectorAll('.card');
        allCards.forEach(card => {
          card.style.minWidth = '';
          card.style.maxWidth = '';
          card.style.width = '';
        });
      }

      // Regenerate page to update visual feedback and return to normal display
      if (JdrApp.modules.renderer?.regenerateCurrentPage) {
        JdrApp.modules.renderer.regenerateCurrentPage();
      }
    },

    hideAllObjects() {
      const container = document.querySelector('#objets-container');
      if (container) {
        const allCards = container.querySelectorAll('.card');
        allCards.forEach(card => {
          card.style.display = 'none';
        });
      }
    },

    showOnlyObjectById(objectId) {
      const container = document.querySelector('#objets-container');
      if (!container) {
        return;
      }

      const allCards = container.querySelectorAll('.card');
      let foundCard = null;

      allCards.forEach((card, index) => {
        const objetName = card.dataset.objetName;
        if (objetName) {
          // Find the object by name to get its number
          const obj = window.OBJETS?.objets?.find(o => o.nom === objetName);
          if (obj && obj.numero === objectId) {
            card.style.display = '';
            foundCard = card;
          } else {
            card.style.display = 'none';
          }
        }
      });


      // Scroll to the found card if it exists
      if (foundCard) {
        // Center the found object both horizontally and vertically
        const container = document.querySelector('#objets-container');
        if (container) {
          // Apply centering styles to the container when showing single object
          container.style.display = 'flex';
          container.style.flexDirection = 'column';
          container.style.alignItems = 'center';
          container.style.justifyContent = 'center';
          container.style.minHeight = '70vh';
          container.style.padding = '2rem';
        }

        // Enlarge the found card for better visibility when searched by ID
        // Check if we're on mobile to adjust sizing accordingly
        const isMobile = window.innerWidth <= 640;
        if (isMobile) {
          // On mobile, use slightly smaller enlargement to fit the screen
          foundCard.style.minWidth = '320px';
          foundCard.style.maxWidth = '90vw';
          foundCard.style.width = '90vw';
        } else {
          // On desktop, double the normal size
          foundCard.style.minWidth = '560px'; // Double the normal min-width (280px * 2)
          foundCard.style.maxWidth = '700px'; // Double the normal max-width (350px * 2)
          foundCard.style.width = 'auto';
        }

        setTimeout(() => {
          foundCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Enhanced highlight effect for centered object
          foundCard.style.transition = 'all 0.4s ease';
          foundCard.style.boxShadow = '0 0 30px rgba(212, 175, 55, 0.6), 0 0 60px rgba(212, 175, 55, 0.3)';
          foundCard.style.transform = 'scale(1.05)';
          foundCard.style.zIndex = '10';
          
          setTimeout(() => {
            foundCard.style.boxShadow = '0 4px 20px rgba(0,0,0,0.15)';
            foundCard.style.transform = 'scale(1.02)';
            foundCard.style.zIndex = '';
          }, 2000);
        }, 100);
      }
    },

    showAllObjectsWithTagFilters() {
      // Restore normal tag filtering behavior
      const currentSettings = window.OBJETS?.filterSettings || { 
        visibleTags: window.ContentTypes.objet.filterConfig.defaultVisibleTags 
      };
      
      const container = document.querySelector('#objets-container');
      if (!container) return;

      // Reset container styles to normal grid layout
      container.style.display = '';
      container.style.flexDirection = '';
      container.style.alignItems = '';
      container.style.justifyContent = '';
      container.style.minHeight = '';
      container.style.padding = '';
      container.style.visibility = ''; // Restore visibility

      const allCards = container.querySelectorAll('.card');
      allCards.forEach(card => {
        // Reset card sizing to normal
        card.style.minWidth = '';
        card.style.maxWidth = '';
        card.style.width = '';
        
        const objetName = card.dataset.objetName;
        if (objetName) {
          // Find the object and check if it has visible tags
          const obj = window.OBJETS?.objets?.find(o => o.nom === objetName);
          if (obj && obj.tags) {
            const hasVisibleTag = obj.tags.some(tag => currentSettings.visibleTags.includes(tag));
            card.style.display = hasVisibleTag ? '' : 'none';
          } else {
            card.style.display = 'none';
          }
        }
      });
    },

    // Toggle individual filter tag
    toggleFilter(chipElement) {
      const tag = chipElement.dataset.tag;
      if (!tag) return;

      // GUARD: Prevent rapid double clicks (debounce)
      if (this._toggleInProgress) {
        return;
      }
      this._toggleInProgress = true;
      
      // Release the lock after a short delay
      setTimeout(() => {
        this._toggleInProgress = false;
      }, 100);

      // Déterminer le type de contenu basé sur la page actuelle
      const currentPage = window.location.hash.replace('#/', '') || 'creation';
      let contentType = 'objet'; // par défaut
      let dataObject = null;
      let visibleTags = null;
      
      if (currentPage === 'monstres') {
        contentType = 'monster';
        // Pour les monstres, on utilise une structure simplifiée dans window.MONSTRES_FILTER_STATE
        if (!window.MONSTRES_FILTER_STATE) {
          window.MONSTRES_FILTER_STATE = { visibleTags: [...window.ContentTypes.monster.filterConfig.defaultVisibleTags] };
        }
        visibleTags = window.MONSTRES_FILTER_STATE.visibleTags;
      } else if (currentPage === 'tables-tresors') {
        contentType = 'tableTresor';
        // Pour les tables de trésors
        if (!window.TABLES_TRESORS_FILTER_STATE) {
          // Use fallback default tags if ContentTypes is not available
          const defaultTags = window.ContentTypes?.tableTresor?.filterConfig?.defaultVisibleTags || ['Commun'];
          window.TABLES_TRESORS_FILTER_STATE = { visibleTags: [...defaultTags] };
        }
        visibleTags = window.TABLES_TRESORS_FILTER_STATE.visibleTags;
      } else {
        // Pour les objets - NOUVEAU SYSTÈME SIMPLIFIÉ
        if (!window.ACTIVE_OBJECT_TAGS) {
          window.ACTIVE_OBJECT_TAGS = []; // Aucun tag actif par défaut
        }
        visibleTags = window.ACTIVE_OBJECT_TAGS;
      }
      
      // IMPORTANT: Track state BEFORE modification to know if we need full regeneration
      const wasEmpty = visibleTags.length === 0;
      
      // SIMPLE LOGIC: Check visual state directly and toggle
      const isVisuallyActive = chipElement.classList.contains('active');
      

      if (isVisuallyActive) {
        // DEACTIVATE - remove from visible tags
        const tagIndex = visibleTags.indexOf(tag);
        if (tagIndex > -1) {
          visibleTags.splice(tagIndex, 1);
        }
        chipElement.classList.remove('active');
        chipElement.classList.add('inactive');
        chipElement.style.background = '#6b7280';
        chipElement.style.opacity = '0.6';
        chipElement.style.boxShadow = '';
        // Mise à jour du texte du bouton
        chipElement.innerHTML = tag;
        chipElement.title = 'Inactif - Cliquer pour activer';
        this.showNotification(`🏷️ Tag "${tag}" désactivé`, 'info');
      } else {
        // ACTIVATE - add to visible tags
        if (!visibleTags.includes(tag)) {
          visibleTags.push(tag);
        }
        chipElement.classList.add('active');
        chipElement.classList.remove('inactive');
        chipElement.style.background = '#16a34a';
        chipElement.style.opacity = '1';
        chipElement.style.boxShadow = '0 2px 4px rgba(22, 163, 74, 0.3)';
        // Mise à jour du texte du bouton
        chipElement.innerHTML = '✓ ' + tag;
        chipElement.title = 'Actif - Cliquer pour désactiver';
        this.showNotification(`🏷️ Tag "${tag}" activé`, 'info');
      }


      // Check if we need a full page regeneration vs just visibility update
      const nowHasTags = visibleTags.length > 0;
      
      if (contentType === 'monster' || contentType === 'tableTresor') {
        // For monsters and tables de trésors, ALWAYS refresh because they have special logic
        // Any change in tags can reveal/hide different content and update UI elements
        this.refreshCurrentPage(contentType);
      } else {
        // SIMPLIFIÉ: Pour les objets, toujours rafraîchir la page
        // C'est plus simple et évite les problèmes de synchronisation
        this.refreshCurrentPage(contentType);
        
        // Mettre à jour le texte indicateur du nombre de tags actifs
        setTimeout(() => {
          const statusElement = document.querySelector('.objects-tag-display p');
          if (statusElement) {
            const activeCount = visibleTags.length;
            statusElement.innerHTML = activeCount === 0 
              ? 'Aucun filtre actif - Tous les objets affichés' 
              : activeCount === 1 
                ? '1 filtre actif - Objets avec ce tag uniquement'
                : `${activeCount} filtres actifs - Objets avec TOUS ces tags`;
          }
        }, 100);
      }

      // Save changes to storage
      EventBus.emit(Events.STORAGE_SAVE);
    },

    refreshCurrentPage(contentType) {
      if (contentType === 'monster') {
        this.refreshMonstersPage();
      } else if (contentType === 'tableTresor') {
        this.refreshTablesTresorsPage();
      } else {
        this.refreshObjectsPage();
      }
    },

    updateContentVisibility(contentType) {
      if (contentType === 'monster') {
        this.updateMonstersVisibility();
      } else if (contentType === 'tableTresor') {
        this.updateTablesTresorsVisibility();
      } else {
        this.updateObjectVisibility();
      }
    },

    updateMonstersVisibility() {
      if (!window.MONSTRES_FILTER_STATE) return;
      
      const visibleTags = window.MONSTRES_FILTER_STATE.visibleTags;
      const allMonsterCards = document.querySelectorAll('#monstres-container .card');
      
      allMonsterCards.forEach(card => {
        const monsterName = card.dataset.monsterName || card.querySelector('[data-edit-section*="nom"]')?.textContent;
        if (!monsterName) return;
        
        // Trouver le monstre correspondant dans les données
        const monster = window.MONSTRES.find(m => m.nom === monsterName);
        if (!monster || !monster.tags) return;
        
        // En mode "ET" : le monstre doit avoir TOUS les tags visibles
        const shouldShow = visibleTags.length === 0 || 
                          visibleTags.every(tag => monster.tags.includes(tag));
        
        card.style.display = shouldShow ? '' : 'none';
      });
    },

    updateTablesTresorsVisibility() {
      if (!window.TABLES_TRESORS_FILTER_STATE) return;
      
      const visibleTags = window.TABLES_TRESORS_FILTER_STATE.visibleTags;
      const allTableCards = document.querySelectorAll('#tables-tresors-container .card');
      
      allTableCards.forEach(card => {
        const tableName = card.dataset.tableTresorName;
        if (!tableName) return;
        
        // Trouver la table correspondante dans les données
        const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === tableName);
        if (!table || !table.tags) return;
        
        // En mode "OR" : la table doit avoir AU MOINS UN des tags visibles
        const shouldShow = visibleTags.length === 0 || 
                          visibleTags.some(tag => table.tags.includes(tag));
        
        card.style.display = shouldShow ? '' : 'none';
      });
    },

    // Update object visibility based on current filter settings
    updateObjectVisibility() {
      const allObjects = document.querySelectorAll('.card[data-objet-name]');
      const visibleTags = window.OBJETS.filterSettings?.visibleTags || [];
      
      allObjects.forEach(card => {
        const objetName = card.dataset.objetName;
        const objet = window.OBJETS.objets?.find(o => o.nom === objetName);
        
        if (objet && objet.tags) {
          // Check if object should be visible based on current filter settings
          const hasVisibleTag = objet.tags.some(tag => visibleTags.includes(tag));
          
          // Apply same logic as PageBuilder for "Départ" tag requirement
          const isMJMode = window.JdrApp?.state?.isMJ || false;
          const isDevMode = window.JdrApp?.utils?.isDevMode?.() || false;
          const bypassDepartRequirement = isMJMode || isDevMode || window.activeIdSearch;
          
          let shouldShow = hasVisibleTag && visibleTags.length > 0;
          
          // CONDITION OBLIGATOIRE : L'objet doit avoir le tag "Départ" pour être visible
          // SAUF si mode MJ activé, dev mode activé, ou recherche par ID active
          if (shouldShow && !bypassDepartRequirement) {
            const hasDepartTag = objet.tags.includes('Départ');
            if (!hasDepartTag) {
              shouldShow = false;
            }
          }
          
          if (shouldShow) {
            card.style.display = '';
          } else {
            card.style.display = 'none';
          }
        }
      });
      
      // Update filter count display if it exists
      const filterCount = document.querySelector('.filter-count');
      if (filterCount) {
        const visibleCount = Array.from(allObjects).filter(card => card.style.display !== 'none').length;
        filterCount.textContent = `${visibleCount} objet(s) affiché(s)`;
      }
    },

    // Select all tags
    selectAllTags() {
      if (!window.OBJETS.filterSettings) {
        window.OBJETS.filterSettings = { visibleTags: [] };
      }

      // Get all available tags and set them as visible
      const availableTags = window.ContentTypes.objet.filterConfig.availableTags || [];
      window.OBJETS.filterSettings.visibleTags = [...availableTags];

      // Reset regeneration flag since we're doing a full reset
      this._needsRegenerationAfterEmpty = false;

      // Save changes to storage
      EventBus.emit(Events.STORAGE_SAVE);
      
      // Regenerate the objects page to reflect changes
      this.refreshObjectsPage();
    },

    // Select no tags (allow having no tags active)
    selectNoTags() {
      if (!window.OBJETS.filterSettings) {
        window.OBJETS.filterSettings = { visibleTags: [] };
      }

      // Clear all visible tags
      window.OBJETS.filterSettings.visibleTags = [];

      // Reset regeneration flag since we're starting fresh
      this._needsRegenerationAfterEmpty = false;

      // Save changes to storage
      EventBus.emit(Events.STORAGE_SAVE);
      
      // Regenerate the objects page to reflect changes
      this.refreshObjectsPage();
    },

    // Refresh the objects page after filter changes
    refreshObjectsPage() {
      // Clean up active tags that are not in displayed buttons
      this.cleanupActiveFilters();
      
      // Don't regenerate if an ID search is active
      if (window.activeIdSearch) {
        // Just show notification, keep current display
        const tagCount = window.OBJETS.filterSettings?.visibleTags?.length || 0;
        this.showNotification(`🏷️ Filtres mis à jour (${tagCount} tag${tagCount > 1 ? 's' : ''} actif${tagCount > 1 ? 's' : ''}) - Recherche par ID active`, 'success');
        return;
      }

      // Regenerate and update the objects page
      if (JdrApp.modules.renderer?.regenerateCurrentPage) {
        JdrApp.modules.renderer.regenerateCurrentPage();
      }
      
      // Show notification
      const tagCount = window.OBJETS.filterSettings?.visibleTags?.length || 0;
      this.showNotification(`🏷️ Filtres mis à jour (${tagCount} tag${tagCount > 1 ? 's' : ''} actif${tagCount > 1 ? 's' : ''})`, 'success');
    },

    // Clean up active filters to ensure only displayed buttons can be active
    cleanupActiveFilters() {
      if (!window.OBJETS?.filterSettings) return;
      
      const displayedButtons = window.OBJETS.filterSettings.displayedFilterButtons || [];
      const activeFilters = window.OBJETS.filterSettings.visibleTags || [];
      
      // Remove any active filters that are not in displayed buttons
      const cleanedActiveFilters = activeFilters.filter(tag => displayedButtons.includes(tag));
      
      // Update if something was cleaned
      if (cleanedActiveFilters.length !== activeFilters.length) {
        window.OBJETS.filterSettings.visibleTags = cleanedActiveFilters;
        const removedCount = activeFilters.length - cleanedActiveFilters.length;
      }
    },

    // ========================================
    // UTILITY METHODS
    // ========================================

    // Créer une modale simple
    createModal(title, content) {
      // Créer le overlay de la modale
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
      `;

      // Créer la modale
      const modal = document.createElement('div');
      modal.style.cssText = `
        background: var(--parchment, #f4f1e8);
        border: 2px solid var(--bronze, #8b5c17);
        border-radius: 8px;
        padding: 1.5rem;
        max-width: 500px;
        width: 90%;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      `;

      modal.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; border-bottom: 1px solid var(--bronze); padding-bottom: 0.5rem;">
          <h3 style="margin: 0; color: var(--bronze);">${title}</h3>
          <button type="button" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--bronze);" title="Fermer">✕</button>
        </div>
        <div>${content}</div>
      `;

      overlay.appendChild(modal);

      // Méthode pour fermer la modale
      overlay.close = () => {
        document.body.removeChild(overlay);
      };

      // Gestionnaires d'événements pour fermer
      const closeBtn = modal.querySelector('button');
      closeBtn.addEventListener('click', overlay.close);

      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.close();
        }
      });

      // Ajouter au DOM
      document.body.appendChild(overlay);

      return overlay;
    },

    // ========================================
    // TABLES DE TRÉSORS - GESTION DES FOURCHETTES
    // ========================================

    // Éditer une fourchette existante
    editFourchette(tableName, fourchetteIndex) {
      const table = this.findTableTresor(tableName);
      if (!table || !table.fourchettes || fourchetteIndex >= table.fourchettes.length) {
        this.showNotification('Table ou fourchette introuvable', 'error');
        return;
      }

      const fourchette = table.fourchettes[fourchetteIndex];
      this.showFourchetteModal(tableName, fourchetteIndex, fourchette);
    },

    // Supprimer une fourchette
    deleteFourchette(tableName, fourchetteIndex) {
      const table = this.findTableTresor(tableName);
      if (!table || !table.fourchettes || fourchetteIndex >= table.fourchettes.length) {
        this.showNotification('Table ou fourchette introuvable', 'error');
        return;
      }

      // Supprimer la fourchette
      table.fourchettes.splice(fourchetteIndex, 1);

      // Sauvegarder les changements
      EventBus.emit(Events.STORAGE_SAVE);

      // Supprimer la fourchette du DOM et réindexer
      this.removeFourchetteFromDOM(tableName, fourchetteIndex);

      this.showNotification('Fourchette supprimée', 'success');
    },

    // Ajouter une nouvelle fourchette
    addFourchette(tableName) {
      const table = this.findTableTresor(tableName);
      if (!table) {
        this.showNotification('Table introuvable', 'error');
        return;
      }

      // Calculer les valeurs par défaut pour la nouvelle fourchette
      const lastFourchette = table.fourchettes?.[table.fourchettes.length - 1];
      const nextMin = lastFourchette ? lastFourchette.max + 1 : 1;
      const nextMax = nextMin + 4; // Fourchette de 5 valeurs par défaut

      const newFourchette = {
        min: nextMin,
        max: nextMax,
        objet: {
          type: "reference",
          numero: 1,
          nom: "Nouvel objet"
        }
      };

      // Ajouter la nouvelle fourchette
      if (!table.fourchettes) {
        table.fourchettes = [];
      }
      table.fourchettes.push(newFourchette);

      // Ouvrir immédiatement le modal d'édition
      const newIndex = table.fourchettes.length - 1;
      this.showFourchetteModal(tableName, newIndex, newFourchette);
    },

    // Trouver une table de trésor par nom
    findTableTresor(tableName) {
      return window.TABLES_TRESORS?.tables?.find(table => table.nom === tableName);
    },

    // Afficher le modal d'édition d'une fourchette
    showFourchetteModal(tableName, fourchetteIndex, fourchette) {
      const modal = this.createModal('Éditer la fourchette', `
        <form id="fourchette-edit-form" style="display: flex; flex-direction: column; gap: 1rem;">
          <div style="display: flex; gap: 1rem;">
            <div style="flex: 1;">
              <label for="fourchette-min" style="display: block; margin-bottom: 0.25rem; font-weight: 600;">🎲 Valeur minimum:</label>
              <input type="number" id="fourchette-min" value="${fourchette.min}" min="1" style="width: 100%; padding: 0.5rem; border: 1px solid var(--bronze); border-radius: 4px;">
            </div>
            <div style="flex: 1;">
              <label for="fourchette-max" style="display: block; margin-bottom: 0.25rem; font-weight: 600;">🎲 Valeur maximum:</label>
              <input type="number" id="fourchette-max" value="${fourchette.max}" min="1" style="width: 100%; padding: 0.5rem; border: 1px solid var(--bronze); border-radius: 4px;">
            </div>
          </div>
          
          <div>
            <label style="display: block; margin-bottom: 0.25rem; font-weight: 600;">📦 Objet sélectionné:</label>
            <div id="selected-object-display" style="padding: 0.75rem; border: 1px solid var(--bronze); border-radius: 4px; background: #f9f9f9; margin-bottom: 0.5rem; min-height: 2rem; display: flex; align-items: center; justify-content: space-between;">
              <span id="selected-object-text" style="flex: 1;">
                ${fourchette.objet?.nom ? `📦 ${fourchette.objet.nom} (N°${fourchette.objet.numero})` : 'Aucun objet sélectionné'}
              </span>
              ${fourchette.objet?.nom ? `<button type="button" id="clear-object-selection" style="background: #dc2626; color: white; border: none; border-radius: 3px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;" title="Effacer la sélection">✕</button>` : ''}
            </div>
            <button type="button" id="select-object-btn" style="width: 100%; background: var(--accent); color: white; padding: 0.75rem; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">
              🔍 Sélectionner un objet
            </button>
            <input type="hidden" id="fourchette-objet-numero" value="${fourchette.objet?.numero || ''}">
            <input type="hidden" id="fourchette-objet-nom" value="${fourchette.objet?.nom || ''}">
          </div>
          
          <div style="display: flex; gap: 0.5rem; margin-top: 1rem;">
            <button type="submit" style="flex: 1; background: var(--accent); color: white; padding: 0.75rem; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">
              ✅ Sauvegarder
            </button>
            <button type="button" id="cancel-fourchette-edit" style="flex: 1; background: #666; color: white; padding: 0.75rem; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">
              ❌ Annuler
            </button>
          </div>
        </form>
      `);

      // Gestionnaire de soumission
      const form = modal.querySelector('#fourchette-edit-form');
      form.addEventListener('submit', (e) => {
        e.preventDefault();
        this.saveFourchette(tableName, fourchetteIndex, modal);
      });

      // Gestionnaire d'annulation
      modal.querySelector('#cancel-fourchette-edit').addEventListener('click', () => {
        modal.close();
      });

      // Gestionnaire de sélection d'objet
      modal.querySelector('#select-object-btn').addEventListener('click', () => {
        this.showObjectSelectionModal(modal);
      });

      // Gestionnaire d'effacement de sélection (si présent)
      const clearBtn = modal.querySelector('#clear-object-selection');
      if (clearBtn) {
        clearBtn.addEventListener('click', () => {
          this.clearObjectSelection(modal);
        });
      }
    },

    // Sauvegarder les modifications d'une fourchette
    saveFourchette(tableName, fourchetteIndex, modal) {
      const table = this.findTableTresor(tableName);
      if (!table) {
        this.showNotification('Table introuvable', 'error');
        return;
      }

      // Récupérer les valeurs du formulaire
      const minValue = parseInt(modal.querySelector('#fourchette-min').value);
      const maxValue = parseInt(modal.querySelector('#fourchette-max').value);
      const objetNumero = parseInt(modal.querySelector('#fourchette-objet-numero').value);
      const objetNom = modal.querySelector('#fourchette-objet-nom').value.trim();

      // Validation
      if (minValue <= 0 || maxValue <= 0 || minValue > maxValue) {
        this.showNotification('Les valeurs min/max doivent être positives et min ≤ max', 'error');
        return;
      }

      if (!objetNumero || !objetNom) {
        this.showNotification('Veuillez sélectionner un objet', 'error');
        return;
      }

      // Mettre à jour la fourchette
      const updatedFourchette = {
        min: minValue,
        max: maxValue,
        objet: {
          type: "reference",
          numero: objetNumero,
          nom: objetNom
        }
      };

      table.fourchettes[fourchetteIndex] = updatedFourchette;

      // Sauvegarder les changements
      EventBus.emit(Events.STORAGE_SAVE);

      // Fermer le modal
      modal.close();

      // Mettre à jour immédiatement l'affichage de la fourchette modifiée
      this.updateFourchetteDisplay(tableName, fourchetteIndex, updatedFourchette);

      this.showNotification('Fourchette mise à jour', 'success');
    },

    // Afficher la prévisualisation d'un objet
    showObjectPreview(objetNumero) {
      // Trouver l'objet par son numéro
      const objet = this.findObjetByNumero(objetNumero);
      
      if (!objet) {
        this.showNotification(`Objet N°${objetNumero} introuvable`, 'error');
        return;
      }

      // Construire l'affichage des tags
      const tagsDisplay = objet.tags && objet.tags.length > 0 
        ? objet.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';

      // Créer le contenu de la prévisualisation
      const previewContent = `
        <div style="text-align: center; margin-bottom: 1rem;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin: 0.5rem 0; font-size: 0.9em; color: var(--bronze);">
            <div style="font-weight: bold;">N°${objet.numero}</div>
            <div style="flex: 1; text-align: right;">
              ${tagsDisplay}
            </div>
          </div>
        </div>
        
        <div style="margin: 1rem 0; text-align: center; font-style: italic;">
          ${objet.description}
        </div>
        
        <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
        
        <div style="margin: 1rem 0;">
          ${objet.effet}
        </div>
        
        <div style="display: flex; justify-content: space-between; gap: 1rem; margin: 1rem 0; font-size: 0.9em;">
          <div style="flex: 1;">
            ${objet.prix}
          </div>
          <div style="flex: 1;">
            ${objet.poids}
          </div>
        </div>
      `;

      // Afficher la modal de prévisualisation
      const modal = this.createModal(`📦 ${objet.nom}`, previewContent);

      // Ajouter un bouton pour aller à la page de l'objet si désiré
      const modalContent = modal.querySelector('div:last-child');
      modalContent.insertAdjacentHTML('beforeend', `
        <div style="text-align: center; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--rule);">
          <button type="button" onclick="window.location.hash = '#/objets'; this.closest('.modal-overlay, [style*=fixed]').remove();" 
                  style="background: var(--accent); color: white; padding: 0.5rem 1rem; border: none; border-radius: 4px; cursor: pointer;">
            🔗 Voir tous les objets
          </button>
        </div>
      `);
    },

    // Trouver un objet par son numéro
    findObjetByNumero(numero) {
      if (!window.OBJETS || !window.OBJETS.objets) {
        return null;
      }
      
      return window.OBJETS.objets.find(objet => objet.numero === numero);
    },

    // Afficher la modal de sélection d'objets
    showObjectSelectionModal(parentModal) {
      const objets = window.OBJETS?.objets || [];
      
      if (objets.length === 0) {
        this.showNotification('Aucun objet disponible', 'error');
        return;
      }

      const selectionContent = `
        <div style="margin-bottom: 1rem;">
          <label for="object-search" style="display: block; margin-bottom: 0.5rem; font-weight: 600;">🔍 Rechercher un objet:</label>
          <input type="text" id="object-search" placeholder="Tapez le nom ou numéro d'un objet..." 
                 style="width: 100%; padding: 0.75rem; border: 1px solid var(--bronze); border-radius: 4px; font-size: 1rem;">
        </div>
        
        <div style="margin-bottom: 1rem; color: var(--bronze); font-size: 0.9em;">
          <span id="object-count">${objets.length} objet(s) disponible(s)</span>
        </div>
        
        <div id="objects-list" style="max-height: 400px; overflow-y: auto; border: 1px solid var(--bronze); border-radius: 4px;">
          ${this.generateObjectsList(objets)}
        </div>
        
        <div style="text-align: center; margin-top: 1rem;">
          <button type="button" id="cancel-object-selection" style="background: #666; color: white; padding: 0.75rem 1.5rem; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">
            ❌ Annuler
          </button>
        </div>
      `;

      const selectionModal = this.createModal('📦 Sélectionner un objet', selectionContent);
      
      // Référence au modal parent pour pouvoir le mettre à jour
      selectionModal._parentModal = parentModal;

      // Gestionnaire de recherche
      const searchInput = selectionModal.querySelector('#object-search');
      const objectsList = selectionModal.querySelector('#objects-list');
      const objectCount = selectionModal.querySelector('#object-count');
      
      let searchTimeout;
      searchInput.addEventListener('input', () => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          const query = searchInput.value.toLowerCase().trim();
          const filteredObjets = this.filterObjects(objets, query);
          objectsList.innerHTML = this.generateObjectsList(filteredObjets);
          objectCount.textContent = `${filteredObjets.length} objet(s) trouvé(s)`;
          
          // Réattacher les gestionnaires de clic
          this.attachObjectClickHandlers(selectionModal);
        }, 300);
      });

      // Gestionnaire d'annulation
      selectionModal.querySelector('#cancel-object-selection').addEventListener('click', () => {
        selectionModal.close();
      });

      // Attacher les gestionnaires de clic aux objets
      this.attachObjectClickHandlers(selectionModal);

      // Focus sur le champ de recherche
      setTimeout(() => {
        searchInput.focus();
      }, 100);
    },

    // Générer la liste HTML des objets
    generateObjectsList(objets) {
      if (objets.length === 0) {
        return '<div style="padding: 2rem; text-align: center; color: #666; font-style: italic;">Aucun objet trouvé</div>';
      }

      return objets.map(objet => {
        const tagsDisplay = objet.tags && objet.tags.length > 0 
          ? objet.tags.slice(0, 3).map(tag => `<span style="background: var(--bronze); color: white; padding: 1px 4px; border-radius: 3px; font-size: 0.7em; margin-left: 4px;">${tag}</span>`).join('')
          : '';

        return `
          <div class="object-selection-item" data-object-numero="${objet.numero}" data-object-nom="${objet.nom}" 
               style="padding: 0.75rem; border-bottom: 1px solid #ddd; cursor: pointer; transition: background 0.2s;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div style="flex: 1;">
                <div style="font-weight: 600; color: var(--bronze);">
                  📦 ${objet.nom}
                </div>
                <div style="font-size: 0.9em; color: #666; margin-top: 2px;">
                  N°${objet.numero} • ${objet.description.substring(0, 60)}${objet.description.length > 60 ? '...' : ''}
                </div>
              </div>
              <div style="text-align: right;">
                ${tagsDisplay}
              </div>
            </div>
          </div>
        `;
      }).join('');
    },

    // Filtrer les objets selon la recherche
    filterObjects(objets, query) {
      if (!query) return objets;

      return objets.filter(objet => {
        return (
          objet.nom.toLowerCase().includes(query) ||
          objet.description.toLowerCase().includes(query) ||
          objet.numero.toString().includes(query) ||
          (objet.tags && objet.tags.some(tag => tag.toLowerCase().includes(query)))
        );
      });
    },

    // Attacher les gestionnaires de clic aux objets
    attachObjectClickHandlers(selectionModal) {
      const objectItems = selectionModal.querySelectorAll('.object-selection-item');
      
      objectItems.forEach(item => {
        // Style au survol
        item.addEventListener('mouseenter', () => {
          item.style.backgroundColor = 'rgba(139, 92, 23, 0.1)';
        });
        
        item.addEventListener('mouseleave', () => {
          item.style.backgroundColor = '';
        });

        // Clic pour sélectionner
        item.addEventListener('click', () => {
          const numero = parseInt(item.dataset.objectNumero);
          const nom = item.dataset.objectNom;
          
          this.selectObject(selectionModal._parentModal, numero, nom);
          selectionModal.close();
        });
      });
    },

    // Sélectionner un objet et mettre à jour le modal parent
    selectObject(parentModal, numero, nom) {
      const numeroInput = parentModal.querySelector('#fourchette-objet-numero');
      const nomInput = parentModal.querySelector('#fourchette-objet-nom');
      const displayText = parentModal.querySelector('#selected-object-text');
      const displayContainer = parentModal.querySelector('#selected-object-display');

      numeroInput.value = numero;
      nomInput.value = nom;
      displayText.textContent = `📦 ${nom} (N°${numero})`;
      
      // Ajouter le bouton d'effacement s'il n'existe pas
      if (!parentModal.querySelector('#clear-object-selection')) {
        displayContainer.insertAdjacentHTML('beforeend', `
          <button type="button" id="clear-object-selection" style="background: #dc2626; color: white; border: none; border-radius: 3px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;" title="Effacer la sélection">✕</button>
        `);
        
        // Attacher le gestionnaire au nouveau bouton
        parentModal.querySelector('#clear-object-selection').addEventListener('click', () => {
          this.clearObjectSelection(parentModal);
        });
      }

      this.showNotification(`📦 "${nom}" sélectionné`, 'success');
    },

    // Effacer la sélection d'objet
    clearObjectSelection(parentModal) {
      const numeroInput = parentModal.querySelector('#fourchette-objet-numero');
      const nomInput = parentModal.querySelector('#fourchette-objet-nom');
      const displayText = parentModal.querySelector('#selected-object-text');
      const clearBtn = parentModal.querySelector('#clear-object-selection');

      numeroInput.value = '';
      nomInput.value = '';
      displayText.textContent = 'Aucun objet sélectionné';
      
      if (clearBtn) {
        clearBtn.remove();
      }

      this.showNotification('Sélection effacée', 'info');
    },

    // Mettre à jour l'affichage d'une fourchette spécifique sans recharger la page
    updateFourchetteDisplay(tableName, fourchetteIndex, updatedFourchette) {
      try {
        // Trouver la table et la fourchette dans le DOM
        const tableCard = document.querySelector(`[data-table-tresor-name="${tableName}"]`);
        if (!tableCard) {
          console.warn('Table non trouvée dans le DOM:', tableName);
          this.forcePageRefresh();
          return;
        }

        // Trouver toutes les fourchettes de cette table
        const fourchetteRows = tableCard.querySelectorAll('.fourchette-row');
        if (fourchetteIndex >= fourchetteRows.length) {
          console.warn('Index de fourchette invalide:', fourchetteIndex);
          this.forcePageRefresh();
          return;
        }

        const fourchetteRow = fourchetteRows[fourchetteIndex];
        
        // Générer le nouveau contenu pour cette fourchette
        const objet = updatedFourchette.objet;
        const objetLink = objet?.type === 'reference' 
          ? `<a href="#" class="object-preview-link" data-object-numero="${objet.numero}" style="color: var(--accent); text-decoration: none;" title="Cliquer pour prévisualiser l'objet #${objet.numero}">📦 ${objet.nom} (N°${objet.numero})</a>`
          : `📦 ${objet?.nom || 'Objet inconnu'}`;

        // Déterminer si on doit afficher les boutons d'édition
        const shouldShowButtons = this.shouldShowFourchetteButtons();
        const editButtons = shouldShowButtons ? `
          <div class="fourchette-actions" style="margin-left: 8px; display: flex; gap: 4px;">
            <button class="edit-fourchette-btn" data-table-name="${tableName}" data-fourchette-index="${fourchetteIndex}" title="Éditer cette fourchette" style="background: #3b82f6; color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;">✏️</button>
            <button class="delete-fourchette-btn" data-table-name="${tableName}" data-fourchette-index="${fourchetteIndex}" title="Supprimer cette fourchette" style="background: #dc2626; color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;">🗑️</button>
          </div>
        ` : '';

        // Mettre à jour le contenu de la fourchette
        fourchetteRow.innerHTML = `
          <div class="fourchette-range" style="font-weight: bold; color: var(--bronze); min-width: 80px;">
            🎲 ${updatedFourchette.min}-${updatedFourchette.max}
          </div>
          <div class="fourchette-objet" style="flex: 1; margin-left: 12px;">
            ${objetLink}
          </div>
          ${editButtons}
        `;

        console.log('Fourchette mise à jour dans le DOM:', tableName, fourchetteIndex);
        
      } catch (error) {
        console.error('Erreur lors de la mise à jour de la fourchette:', error);
        // En cas d'erreur, on revient au rechargement complet
        this.forcePageRefresh();
      }
    },

    // Supprimer une fourchette du DOM et réindexer les autres
    removeFourchetteFromDOM(tableName, fourchetteIndex) {
      try {
        const tableCard = document.querySelector(`[data-table-tresor-name="${tableName}"]`);
        if (!tableCard) {
          console.warn('Table non trouvée dans le DOM:', tableName);
          this.forcePageRefresh();
          return;
        }

        const fourchetteRows = tableCard.querySelectorAll('.fourchette-row');
        if (fourchetteIndex >= fourchetteRows.length) {
          console.warn('Index de fourchette invalide:', fourchetteIndex);
          this.forcePageRefresh();
          return;
        }

        // Supprimer l'élément du DOM
        fourchetteRows[fourchetteIndex].remove();

        // Réindexer toutes les fourchettes restantes pour les boutons d'édition
        const remainingRows = tableCard.querySelectorAll('.fourchette-row');
        remainingRows.forEach((row, newIndex) => {
          const editBtn = row.querySelector('.edit-fourchette-btn');
          const deleteBtn = row.querySelector('.delete-fourchette-btn');
          
          if (editBtn) editBtn.dataset.fourchetteIndex = newIndex;
          if (deleteBtn) deleteBtn.dataset.fourchetteIndex = newIndex;
        });

        console.log('Fourchette supprimée du DOM:', tableName, fourchetteIndex);
        
      } catch (error) {
        console.error('Erreur lors de la suppression de la fourchette:', error);
        this.forcePageRefresh();
      }
    },

    // Vérifier si on doit afficher les boutons d'édition des fourchettes
    shouldShowFourchetteButtons() {
      // Reprendre la même logique que dans CardBuilder
      return JdrApp.utils.isDevMode() || 
             (!window.STANDALONE_VERSION && window.location.search.includes('dev=1')) ||
             (document.body.classList.contains('dev-on')) ||
             (window.location.protocol === 'file:' && !window.STANDALONE_VERSION) ||
             (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1');
    },

    showPageLinksModal() {
      let modal = JdrApp.utils.dom.$('#pageLinksModal');
      if (modal) {
        document.body.removeChild(modal);
      }
      
      modal = this.createPageLinksModal();
      document.body.appendChild(modal);
      
      this.openModal('pageLinksModal');
    },

    createPageLinksModal() {
      // Construire la liste des pages à partir de la structure TOC
      const pages = [];
      
      if (window.TOC_STRUCTURE && window.TOC_STRUCTURE.sections) {
        window.TOC_STRUCTURE.sections.forEach(section => {
          if (section.items && Array.isArray(section.items)) {
            section.items.forEach(item => {
              if (item.type === 'page') {
                pages.push({
                  id: item.id,
                  title: item.title,
                  icon: item.icon,
                  section: section.title
                });
              } else if (item.type === 'category') {
                // Ajouter la page principale de catégorie
                pages.push({
                  id: item.id,
                  title: item.title,
                  icon: item.icon,
                  section: section.title
                });
                
                // Ajouter les sous-catégories si elles existent
                if (item.id === 'sorts' && window.SORTS) {
                  window.SORTS.forEach(category => {
                    pages.push({
                      id: `sorts-${category.nom}`,
                      title: `${category.nom} (sorts)`,
                      icon: '🔮',
                      section: section.title
                    });
                  });
                } else if (item.id === 'dons' && window.DONS) {
                  window.DONS.forEach(category => {
                    pages.push({
                      id: `dons-${category.nom}`,
                      title: `${category.nom} (dons)`,
                      icon: '🎖️',
                      section: section.title
                    });
                  });
                } else if (item.id === 'classes' && window.CLASSES) {
                  window.CLASSES.forEach(classe => {
                    pages.push({
                      id: classe.nom.toLowerCase(),
                      title: classe.nom,
                      icon: '⚔️',
                      section: section.title
                    });
                  });
                }
              }
            });
          }
        });
      }

      const pagesHTML = pages.map(page => `
        <div class="page-item" data-page-id="${page.id}">
          <div class="page-info">
            <div class="page-name">${page.icon} ${page.title}</div>
            <div class="page-section" style="color: var(--paper-muted); font-size: 12px;">${page.section}</div>
          </div>
          <div class="copy-indicator">Copié!</div>
        </div>
      `).join('');

      const modal = JdrApp.utils.dom.create('div', 'modal page-links-modal', `
        <div class="modal-content page-links-modal-content">
          <div style="position: relative;">
            <button class="modal-close-x" style="position: absolute; top: 0; right: 0; background: none; border: none; font-size: 20px; cursor: pointer; color: var(--paper-muted); padding: 4px 8px; border-radius: 4px; transition: all 0.2s ease;" onmouseover="this.style.background='var(--rule)'; this.style.color='var(--accent-ink)';" onmouseout="this.style.background='none'; this.style.color='var(--paper-muted)';">×</button>
            <h3>🔗 Liens vers les pages</h3>
          </div>
          <p>Cliquez sur une page pour copier un lien vers celle-ci.</p>
          <div class="pages-search">
            <input type="text" id="pageSearchInput" placeholder="Rechercher une page..." style="width: 100%; padding: 8px; margin-bottom: 12px; border: 1px solid var(--rule); border-radius: 4px;">
          </div>
          <div class="pages-list" style="max-height: 400px; overflow-y: auto;">
            ${pagesHTML || '<div style="text-align: center; color: #666; padding: 2rem;">Aucune page trouvée</div>'}
          </div>
          <button class="modal-close btn">Fermer</button>
        </div>
      `, { id: 'pageLinksModal' });

      // Recherche dans la modal
      const searchInput = modal.querySelector('#pageSearchInput');
      if (searchInput) {
        searchInput.addEventListener('input', (e) => {
          const searchTerm = e.target.value.toLowerCase();
          const pageItems = modal.querySelectorAll('.page-item');
          
          pageItems.forEach(item => {
            const pageName = item.querySelector('.page-name').textContent.toLowerCase();
            const pageSection = item.querySelector('.page-section').textContent.toLowerCase();
            
            if (pageName.includes(searchTerm) || pageSection.includes(searchTerm)) {
              item.style.display = '';
            } else {
              item.style.display = 'none';
            }
          });
        });
      }

      // Clic sur une page
      modal.addEventListener('click', (e) => {
        const pageItem = e.target.closest('.page-item');
        if (pageItem) {
          const pageId = pageItem.dataset.pageId;
          const pageTitle = pageItem.querySelector('.page-name').textContent.replace(/^[^\s]+ /, ''); // Enlever l'icône
          
          // Créer le lien vers la page
          const pageLink = `<a href="#/${pageId}" style="color: var(--accent); text-decoration: underline;">${pageTitle}</a>`;
          
          this.copyToClipboard(pageLink);
          
          pageItem.classList.add('copied');
          
          // Fermer la modale après un court délai pour voir l'effet "Copié!"
          setTimeout(() => {
            this.closeModal(modal);
          }, 500);
        }
      });

      // Gestionnaire pour le bouton X de fermeture
      const closeBtn = modal.querySelector('.modal-close-x');
      if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.closeModal(modal);
        });
      }

      return modal;
    },

    // Fonction d'impression des états
    printStates() {
      // Récupérer tous les états depuis les données chargées
      let etatsData;
      
      // Essayer plusieurs sources de données
      if (window.ETATS) {
        etatsData = window.ETATS;
      } else if (window.STATIC_PAGES?.etats) {
        etatsData = window.STATIC_PAGES.etats;
      } else {
        // Essayer de récupérer depuis l'article actuellement affiché
        const activeArticle = document.querySelector('article[data-page="etats"]');
        if (activeArticle) {
          const cards = activeArticle.querySelectorAll('.card');
          const states = Array.from(cards).map(card => {
            const title = card.querySelector('h3')?.textContent || 'État';
            const content = card.querySelector('.editable')?.innerHTML || '';
            return { title, content };
          });
          
          if (states.length > 0) {
            this.generatePrintableStates(states);
            return;
          }
        }
        
        console.error('Données des états non trouvées');
        return;
      }

      // Filtrer seulement les sections de type "card" (les états)
      const states = etatsData.sections ? 
        etatsData.sections.filter(section => section.type === 'card') :
        [];
      
      if (states.length === 0) {
        console.warn('Aucun état trouvé à imprimer');
        return;
      }

      this.generatePrintableStates(states);
    },

    generatePrintableStates(states) {
      // Ouvrir une nouvelle fenêtre pour l'impression
      const printWindow = window.open('', '_blank', 'width=800,height=600');
      
      // Créer le HTML complet pour l'impression
      const printableHTML = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <title>États - Aide de jeu</title>
          <style>
            @page { 
              margin: 15mm !important; 
              size: A4 !important;
            }
            body { 
              font-family: "Times New Roman", serif; 
              background: white; 
              color: black; 
              margin: 0; 
              padding: 0;
              font-size: 10pt;
              line-height: 1.2;
            }
            h1 { 
              font-size: 16pt; 
              font-weight: bold; 
              text-align: center; 
              margin-bottom: 8mm; 
              color: black;
            }
            .printable-states-grid { 
              display: grid; 
              grid-template-columns: 1fr 1fr; 
              gap: 4mm; 
              margin: 0;
            }
            .printable-state-item { 
              border: 1pt solid #ccc; 
              border-radius: 2mm; 
              padding: 3mm; 
              page-break-inside: avoid; 
              font-size: 9pt;
              line-height: 1.1;
              background: white;
            }
            .printable-state-item h3 { 
              font-size: 11pt; 
              font-weight: bold; 
              margin: 0 0 2mm 0; 
              color: black;
            }
            .printable-state-item p { 
              margin: 1mm 0; 
              color: black;
            }
          </style>
        </head>
        <body>
          <h1>États - Aide de jeu</h1>
          <div class="printable-states-grid">
            ${states.map(state => `
              <div class="printable-state-item">
                <h3>${state.title}</h3>
                <div>${this.stripHtmlTags(state.content)}</div>
              </div>
            `).join('')}
          </div>
        </body>
        </html>
      `;

      // Écrire le contenu et imprimer
      printWindow.document.write(printableHTML);
      printWindow.document.close();
      
      // Attendre que le contenu soit chargé puis imprimer
      printWindow.onload = function() {
        printWindow.focus();
        printWindow.print();
        printWindow.close();
      };
    },

    // Fonction utilitaire pour nettoyer les balises HTML pour l'impression
    stripHtmlTags(html) {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;
      
      // Convertir les listes en texte simple avec des tirets
      const lists = tempDiv.querySelectorAll('ul');
      lists.forEach(ul => {
        const items = ul.querySelectorAll('li');
        const textItems = Array.from(items).map(li => `• ${li.textContent.trim()}`);
        ul.outerHTML = textItems.join('<br>');
      });

      // Préserver les paragraphes mais simplifier le formatage
      const paragraphs = tempDiv.querySelectorAll('p');
      paragraphs.forEach(p => {
        p.style.margin = '2px 0';
      });

      return tempDiv.innerHTML;
    },

    // Méthode robuste pour forcer le rafraîchissement de la page (fallback)
    forcePageRefresh() {
      setTimeout(() => {
        try {
          const currentHash = window.location.hash;
          const pageName = currentHash.replace('#/', '');
          
          if (JdrApp.modules.router && JdrApp.modules.router.show) {
            JdrApp.modules.router.show(pageName);
          } else if (JdrApp.modules.renderer && JdrApp.modules.renderer.regenerateCurrentPage) {
            JdrApp.modules.renderer.regenerateCurrentPage();
          } else {
            window.location.reload();
          }
        } catch (error) {
          console.error('Erreur lors du rafraîchissement:', error);
          window.location.reload();
        }
      }, 100);
    },

    // ========================================
    // CAMPAIGN MANAGEMENT
    // ========================================

    addCampaign() {
      const campaignName = prompt("Nom de la nouvelle campagne:");
      if (!campaignName || !campaignName.trim()) return;
      
      // Initialize campaigns structure if needed
      if (!window.STATIC_PAGES.campagne) {
        window.STATIC_PAGES.campagne = {
          id: 'campagne',
          title: 'Campagne',
          sections: [],
          subPages: {}
        };
      }
      
      if (!window.STATIC_PAGES.campagne.subPages) {
        window.STATIC_PAGES.campagne.subPages = {};
      }
      
      const trimmedName = campaignName.trim();
      
      // Check if campaign already exists
      if (window.STATIC_PAGES.campagne.subPages[trimmedName]) {
        this.showNotification('❌ Une campagne avec ce nom existe déjà', 'error');
        return;
      }
      
      // Create new campaign
      window.STATIC_PAGES.campagne.subPages[trimmedName] = {
        name: trimmedName,
        description: "Description de la campagne",
        subPages: {}
      };
      
      // Save and refresh
      EventBus.emit(Events.STORAGE_SAVE);
      this.refreshCurrentPage();
      this.showNotification('📖 Campagne créée avec succès', 'success');
    },

    deleteCampaign(campaignName) {
      if (!confirm(`Supprimer la campagne "${campaignName}" et toutes ses sous-pages ?`)) {
        return;
      }
      
      if (window.STATIC_PAGES.campagne && window.STATIC_PAGES.campagne.subPages) {
        delete window.STATIC_PAGES.campagne.subPages[campaignName];
        EventBus.emit(Events.STORAGE_SAVE);
        this.refreshCurrentPage();
        this.showNotification('🗑️ Campagne supprimée', 'success');
      }
    },

    addCampaignSubPage(campaignName) {
      const subPageName = prompt("Nom de la nouvelle sous-page:");
      if (!subPageName || !subPageName.trim()) return;
      
      const trimmedName = subPageName.trim();
      
      const campaign = window.STATIC_PAGES.campagne?.subPages?.[campaignName];
      if (!campaign) {
        this.showNotification('❌ Campagne introuvable', 'error');
        return;
      }
      
      if (!campaign.subPages) {
        campaign.subPages = {};
      }
      
      // Check if sub-page already exists
      if (campaign.subPages[trimmedName]) {
        this.showNotification('❌ Une sous-page avec ce nom existe déjà', 'error');
        return;
      }
      
      // Create new sub-page
      campaign.subPages[trimmedName] = {
        title: trimmedName,
        content: "<p>Contenu de la sous-page...</p>"
      };
      
      // Save and refresh
      EventBus.emit(Events.STORAGE_SAVE);
      this.refreshCurrentPage();
      this.showNotification('📄 Sous-page créée avec succès', 'success');
    },

    editCampaignSubPage(campaignName, subPageName) {
      // This would open a modal or navigate to an edit view
      // For now, just show a notification that editing is available through inline editing
      this.showNotification('✏️ Vous pouvez éditer le contenu directement en double-cliquant dessus', 'info');
    },

    deleteCampaignSubPage(campaignName, subPageName) {
      if (!confirm(`Supprimer la sous-page "${subPageName}" ?`)) {
        return;
      }
      
      const campaign = window.STATIC_PAGES.campagne?.subPages?.[campaignName];
      if (campaign && campaign.subPages) {
        delete campaign.subPages[subPageName];
        EventBus.emit(Events.STORAGE_SAVE);
        this.refreshCurrentPage();
        this.showNotification('🗑️ Sous-page supprimée', 'success');
      }
    },

    // Campaign and Sub-page Selection
    selectCampaign(campaignName) {
      if (!window.JdrApp.state) {
        window.JdrApp.state = {};
      }
      window.JdrApp.state.selectedCampaign = campaignName;
      window.JdrApp.state.selectedSubPage = null; // Reset sub-page selection
      this.refreshCurrentPage();
      this.showNotification(`📖 Campagne "${campaignName}" sélectionnée`, 'info');
    },

    selectSubPage(subPageName) {
      if (!window.JdrApp.state) {
        window.JdrApp.state = {};
      }
      window.JdrApp.state.selectedSubPage = subPageName;
      this.refreshCurrentPage();
      this.showNotification(`📄 Sous-page "${subPageName}" sélectionnée`, 'info');
    }
  };

})();

</script>
</body>
</html>