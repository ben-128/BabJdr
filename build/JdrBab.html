<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta name="referrer" content="no-referrer-when-downgrade">
<!-- Generated on 2025-08-20T09:23:45.654Z by JdrBab Build System -->
<title>JDR‑BAB — Livret de règles</title>
<meta content="Livret web multipages des règles JDR‑BAB, thème parchemin, illustrations par catégorie/classe/sous‑classe, export HTML autonome." name="description">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&amp;family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600&amp;display=swap" rel="stylesheet">
<style>
/* —— Thème Heroic Fantasy —— */
:root{
  --paper:#f4f0e6;        /* parchemin ancien */
  --paper-ink:#2c1810;    /* encre noire profonde */
  --paper-muted:#8b6f47;  /* bronze ancien */
  --accent-ink:#4a2c17;   /* titres sombres */
  --rule:#d4c4a8;         /* bordures dorées */
  --card:#faf6ee;         /* cartes parchemin */
  --link:#8b4513;         /* liens cuivre */
  --gold:#d4af37;         /* or */
  --bronze:#cd7f32;       /* bronze */
  --shadow:0 8px 32px rgba(0,0,0,.15), 0 2px 8px rgba(139,69,19,.1);
  --card-shadow:0 6px 20px rgba(0,0,0,.1), 0 2px 6px rgba(139,69,19,.08);
  --image-border:3px solid #8b4513;
  --image-shadow:0 4px 12px rgba(0,0,0,.2), inset 0 1px 2px rgba(212,175,55,.3);
  
  /* Element colors system */
  --feu:#ff6b35; --feu-bg:rgba(255,107,53,.1); --feu-border:rgba(255,107,53,.3);
  --air:#87ceeb; --air-bg:rgba(135,206,235,.1); --air-border:rgba(135,206,235,.3);
  --eau:#4682b4; --eau-bg:rgba(70,130,180,.1); --eau-border:rgba(70,130,180,.3);
  --terre:#8b7355; --terre-bg:rgba(139,115,85,.1); --terre-border:rgba(139,115,85,.3);
  --divin:#ffd700; --divin-bg:rgba(255,215,0,.1); --divin-border:rgba(255,215,0,.3);
  --malefique:#8b008b; --malefique-bg:rgba(139,0,139,.1); --malefique-border:rgba(139,0,139,.3);
  
  /* Spacing system */
  --space-xs:4px; --space-sm:6px; --space-md:8px; --space-lg:12px; --space-xl:16px; --space-2xl:24px;
  
  /* Common transitions */
  --transition-fast:.2s ease; --transition-normal:.3s ease; --transition-slow:.5s ease;
}

@media (prefers-color-scheme: dark){ 
  :root{ 
    --paper:#e9e0cc; 
    --card:#f3ead4; 
    --paper-ink:#1c170f; 
  } 
}

/* Base styles */
html,body{height:100%}
body{
  margin:0;
  background:
    radial-gradient(1600px 800px at 50% -10%, rgba(212,175,55,.08), transparent 45%),
    radial-gradient(1400px 700px at 120% 10%, rgba(139,69,19,.06), transparent 40%),
    radial-gradient(800px 400px at 20% 80%, rgba(205,127,50,.04), transparent 30%),
    repeating-linear-gradient(90deg, rgba(74,44,23,.02) 0 1px, transparent 1px 3px),
    repeating-linear-gradient(0deg, rgba(139,69,19,.015) 0 1px, transparent 1px 4px),
    var(--paper);
  color:var(--paper-ink); 
  font:17px/1.65 "Source Serif Pro", "Cinzel", ui-serif, Georgia, Cambria, "Times New Roman", Times, serif; 
  -webkit-font-smoothing:antialiased; 
  text-rendering:optimizeLegibility;
}

/* Typography */
a{color:var(--link);text-decoration:none} 
a:hover{text-decoration:underline}
strong, b{font-weight:700; font-family: "Source Serif Pro", serif; color:var(--accent-ink)}
em, i{font-style:italic; font-weight:400}
h1,h2,h3{font-family: "Cinzel", "Trajan Pro", ui-serif, Georgia, Cambria, Times, serif; color:var(--accent-ink); text-shadow: 1px 1px 2px rgba(0,0,0,.1)}
h1{font-size:clamp(32px,4.5vw,44px);letter-spacing:.03em;margin:.2rem 0 .4rem; font-weight:600;
   background:linear-gradient(135deg, var(--gold), var(--bronze)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text}
h2{font-size:clamp(24px,3.2vw,30px);margin:.2rem 0 .2rem; font-weight:500; color:var(--bronze)}
h3{font-size:clamp(19px,2.4vw,24px);margin:.8rem 0 .2rem; font-weight:500; color:var(--accent-ink)}
.muted{color:var(--paper-muted)}
.lead{font-size:18px}
.rule{height:1px;background:linear-gradient(90deg, transparent, var(--rule), transparent);margin:10px 0}
/* === UTILITY CLASSES === */

/* Spacing utilities */
.m-0{margin:0} .m-1{margin:var(--space-xs)} .m-2{margin:var(--space-md)} .m-3{margin:var(--space-lg)} .m-4{margin:var(--space-xl)}
.mt-0{margin-top:0} .mt-1{margin-top:var(--space-xs)} .mt-2{margin-top:var(--space-md)} .mt-3{margin-top:var(--space-lg)}
.mb-0{margin-bottom:0} .mb-1{margin-bottom:var(--space-xs)} .mb-2{margin-bottom:var(--space-md)} .mb-3{margin-bottom:var(--space-lg)}
.p-0{padding:0} .p-1{padding:var(--space-xs)} .p-2{padding:var(--space-md)} .p-3{padding:var(--space-lg)} .p-4{padding:var(--space-xl)}

/* Flex utilities */
.flex{display:flex} .flex-col{flex-direction:column} .flex-wrap{flex-wrap:wrap}
.items-center{align-items:center} .items-start{align-items:flex-start} .items-end{align-items:flex-end}
.justify-center{justify-content:center} .justify-start{justify-content:flex-start} .justify-end{justify-content:flex-end}
.gap-1{gap:var(--space-xs)} .gap-2{gap:var(--space-md)} .gap-3{gap:var(--space-lg)}

/* Element color utilities */
.text-feu{color:var(--feu)} .text-air{color:var(--air)} .text-eau{color:var(--eau)} .text-terre{color:var(--terre)} .text-divin{color:var(--divin)} .text-malefique{color:var(--malefique)}
.bg-feu{background:var(--feu-bg);border-color:var(--feu-border)} .bg-air{background:var(--air-bg);border-color:var(--air-border)}
.bg-eau{background:var(--eau-bg);border-color:var(--eau-border)} .bg-terre{background:var(--terre-bg);border-color:var(--terre-border)}
.bg-divin{background:var(--divin-bg);border-color:var(--divin-border)} .bg-malefique{background:var(--malefique-bg);border-color:var(--malefique-border)}

/* Grid utilities */
.grid{display:grid;gap:var(--space-lg)}
.cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}
.cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}
@media (max-width: 900px){ .cols-3{grid-template-columns:1fr} }
@media (max-width: 768px){ .cols-2{grid-template-columns:1fr !important} }

/* Misc utilities */
.subclass-stack{display:flex;flex-direction:column;gap:var(--space-lg)}
.chip{font-size:12px;border:1px solid var(--rule);border-radius:999px;padding:4px 8px;background:rgba(155,107,47,.08)}
.chips{display:flex;flex-wrap:wrap;gap:6px;justify-content:center}
/* — Layout — */
.shell{display:grid;grid-template-rows:1fr auto;min-height:100svh}

.page{position:relative;min-height:100vh;padding-left:318px;padding-right:18px;padding-top:18px;padding-bottom:18px}

/* Centrer le contenu principal dans l'espace disponible */
#views{max-width:1200px;margin:0 auto}
@media (max-width: 980px){ .page{padding-left:12px;padding-right:12px} }

.sidebar{position:fixed;top:0;left:0;width:300px;height:100vh;overflow-y:auto;overflow-x:hidden;z-index:100;background:var(--paper)}
@media (max-width: 980px){ .sidebar{position:relative;width:100%;height:auto;background:transparent} }
.panel{background:var(--card);border:2px solid var(--rule);border-radius:16px;box-shadow:var(--card-shadow);padding:14px;
       position:relative; overflow:hidden;margin:12px}
.toc{max-height:calc(100vh - 150px);overflow-y:auto;overflow-x:hidden}
.panel::before{content:''; position:absolute; top:0; left:0; right:0; height:2px; 
               background:linear-gradient(90deg, transparent, var(--gold), transparent); opacity:.4}

.toc h4{margin:6px 8px;color:var(--paper-muted);text-transform:uppercase;font-size:12px;letter-spacing:.12em}
.toc a{display:flex;gap:8px;padding:8px;border-radius:10px;color:inherit;border:1px solid transparent;
       transition:all .3s cubic-bezier(0.4, 0, 0.2, 1); position:relative; overflow:hidden}
.toc a::before{content:''; position:absolute; top:0; left:-100%; width:100%; height:100%;
               background:linear-gradient(90deg, transparent, rgba(212,175,55,.15), transparent);
               transition:left .5s ease; z-index:0}
.toc a:hover{transform:translateX(4px); background:rgba(212,175,55,.08); border-color:rgba(139,69,19,.3);
             box-shadow:0 4px 12px rgba(139,69,19,.15), inset 0 1px 2px rgba(212,175,55,.2)}
.toc a:hover::before{left:100%}
.toc a > *{position:relative; z-index:1}
.toc a.active{background:linear-gradient(135deg, rgba(212,175,55,.12), rgba(139,69,19,.08)); 
              border-color:var(--bronze); box-shadow:inset 0 1px 3px rgba(212,175,55,.2);
              transform:translateX(2px)}
.toc-category{margin:0}
.toc-category > a{position:relative; cursor:pointer}
.toc-category > a::after{content:'▼'; position:absolute; right:8px; top:50%; transform:translateY(-50%); 
                         font-size:10px; transition:transform .3s ease; color:var(--bronze)}
.toc-category.collapsed > a::after{transform:translateY(-50%) rotate(-90deg)}
.toc-sub{margin-left:24px;border-left:2px solid var(--rule);padding-left:8px; 
         overflow:hidden; transition:all .3s ease}
.toc-category.collapsed .toc-sub{max-height:0; opacity:0; padding-top:0; padding-bottom:0; margin-top:0; margin-bottom:0}
.toc-category:not(.collapsed) .toc-sub{max-height:500px; opacity:1}
.toc-sub a{font-size:14px;padding:6px 8px; margin-left:4px}
.toc-sub a:hover{transform:translateX(6px); margin-left:0}

/* Outils latéraux */
.tools{display:flex;gap:var(--space-md);flex-wrap:wrap;margin:var(--space-md) 0}

/* Article and section layout */
article{display:none}
article.active{display:block}
section{background:var(--card);border:1px solid var(--rule);border-radius:14px;box-shadow:var(--shadow);padding:18px;margin:0 0 14px}

/* Footer */
footer{padding:24px;text-align:center;color:var(--paper-muted)}

/* Print styles */
@media print{ 
  .sidebar, .tools{display:none} 
  .page{grid-template-columns:1fr;padding:0} 
  section{break-inside:avoid;box-shadow:none} 
}

/* Responsive */
@media (max-width: 768px) {
  .illus .thumb { width: 100%; max-width: 300px; height: auto; }
}
/* Component base classes */
.card-base{background:var(--card);border:2px solid var(--rule);border-radius:14px;box-shadow:var(--card-shadow);padding:14px;position:relative;overflow:hidden}
.card-base::before{content:''; position:absolute; top:0; left:0; right:0; height:1px;background:linear-gradient(90deg, transparent, var(--gold), transparent); opacity:.6}
.card-base::after{content:''; position:absolute; bottom:0; left:0; right:0; height:1px;background:linear-gradient(90deg, transparent, var(--bronze), transparent); opacity:.3}

.btn-base{display:inline-flex;gap:var(--space-md);align-items:center;background:var(--card);border:2px solid var(--rule);border-radius:12px;padding:var(--space-md) var(--space-lg);box-shadow:var(--card-shadow);cursor:pointer;transition:var(--transition-fast);font-weight:500}
.btn-base:hover{transform:translateY(-1px);box-shadow:0 8px 25px rgba(0,0,0,.15);border-color:var(--bronze)}
.btn-small{padding:var(--space-sm) var(--space-md)}

.modal-base{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);z-index:99999;display:none;align-items:center;justify-content:center}
.modal-base.visible{display:flex}
.modal-content-base{background:var(--card);border:2px solid var(--rule);border-radius:16px;padding:var(--space-2xl);box-shadow:var(--shadow);position:relative}

/* Cards */
.card{border:2px solid var(--rule);border-radius:14px;padding:14px;
      background:linear-gradient(145deg, #faf7f0, var(--card), #f8f4e8);
      box-shadow:var(--card-shadow); position:relative; overflow:hidden}
.card::before{content:''; position:absolute; top:0; left:0; right:0; height:1px;
              background:linear-gradient(90deg, transparent, var(--gold), transparent); opacity:.6}
.card::after{content:''; position:absolute; bottom:0; left:0; right:0; height:1px;
             background:linear-gradient(90deg, transparent, var(--bronze), transparent); opacity:.3}
.card ul, ul{padding-left:35px !important;margin-left:0 !important}

/* Buttons */
.btn{display:inline-flex;gap:var(--space-md);align-items:center;background:var(--card);border:2px solid var(--rule);border-radius:12px;padding:var(--space-md) var(--space-lg);box-shadow:var(--card-shadow);cursor:pointer;
     transition:var(--transition-fast); font-weight:500}
.btn:hover{transform:translateY(-1px); box-shadow:0 8px 25px rgba(0,0,0,.15); border-color:var(--bronze)}
.btn.small{padding:var(--space-sm) var(--space-md)}

/* Search bar */
.searchbar{display:flex;gap:var(--space-md);align-items:center}
.searchbar input{flex:1 1 auto;max-width:100%;height:38px;font-size:15px;padding:var(--space-md) 10px;border-radius:10px;border:1px solid var(--rule);background:#fff6e8;color:inherit}
.searchbar button{height:38px}

/* Illustrations */
.illus{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap;margin:.6rem 0}
.illus img{max-width:100%;height:auto;border-radius:12px; transition:all .3s ease}
.illus img.enlarged{transition:none !important}
.illus .thumb{width:500px;height:300px;object-fit:contain}

/* Images avec cadres - système unifié */
.illus-spell, .illus-class, .illus-subclass, .illus-don,
article[data-page="guerrier"] .illus,
article[data-page="mage"] .illus,
article[data-page="pretre"] .illus,
article[data-page="rodeur"] .illus,
article[data-page="enchanteur"] .illus,
.illus[data-illus-key^="class:"],
.illus[data-illus-key^="subclass:"],
.illus[data-illus-key^="spell:"],
.illus[data-illus-key^="sort:"],
.illus[data-illus-key^="spellcategory:"],
.illus[data-illus-key^="don:"] {
  display:flex !important; flex-direction:column !important; align-items:center !important;
  justify-content:center !important; margin:1rem auto !important;
}

.illus-spell img, .illus-class img, .illus-subclass img, .illus-don img,
article[data-page="guerrier"] .illus img,
article[data-page="mage"] .illus img,
article[data-page="pretre"] .illus img,
article[data-page="rodeur"] .illus img,
article[data-page="enchanteur"] .illus img,
.illus[data-illus-key^="class:"] img,
.illus[data-illus-key^="subclass:"] img,
.illus[data-illus-key^="spell:"] img,
.illus[data-illus-key^="sort:"] img,
.illus[data-illus-key^="spellcategory:"] img,
.illus[data-illus-key^="don:"] img {
  border:var(--image-border) !important; 
  box-shadow:var(--image-shadow) !important;
  padding:4px !important; 
  background:transparent !important;
  border-radius:16px !important; 
  max-width:fit-content !important;
  width:auto !important;
  cursor:pointer !important;
}

.illus-spell img:hover, .illus-class img:hover, .illus-subclass img:hover, .illus-don img:hover,
article[data-page="guerrier"] .illus img:hover,
article[data-page="mage"] .illus img:hover,
article[data-page="pretre"] .illus img:hover,
article[data-page="rodeur"] .illus img:hover,
article[data-page="enchanteur"] .illus img:hover,
.illus[data-illus-key^="class:"] img:hover,
.illus[data-illus-key^="subclass:"] img:hover,
.illus[data-illus-key^="spell:"] img:hover,
.illus[data-illus-key^="sort:"] img:hover,
.illus[data-illus-key^="spellcategory:"] img:hover,
.illus[data-illus-key^="don:"] img:hover {
  transform:scale(1.03) !important; 
  box-shadow:var(--image-shadow), 0 8px 25px rgba(139,69,19,.25) !important;
}

/* Variantes de taille d'images */
.illus-small img { max-width: 150px !important; }
.illus-large img { max-width: 400px !important; }

/* Style spécial pour les sorts - cadre doré et taille augmentée */
.illus-spell img,
.card .illus img {
  border: 3px solid var(--gold) !important;
  box-shadow: var(--image-shadow), 0 0 10px rgba(212,175,55,.3) !important;
  max-width: 350px !important;
  max-height: 250px !important;
  object-fit: contain !important;
}

/* Style spécial pour les sous-classes - 2 images centrées et collées */
.subclass-images {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0;
  margin: 0.6rem 0;
}

.subclass-images .illus {
  margin: 0;
  flex: 0 0 auto;
}

.subclass-images .illus img {
  max-width: 400px !important;
  max-height: 300px !important;
  object-fit: contain !important;
  border-radius: 12px 0 0 12px !important;
}

.subclass-images .illus:last-child img {
  border-radius: 0 12px 12px 0 !important;
}

/* Style spécial pour les titres de sous-classes */
.subclass-title {
  font-size: 1.8rem !important;
  font-weight: 600 !important;
  text-align: center !important;
  margin: 0 0 1.5rem 0 !important;
  color: var(--accent-ink) !important;
  font-family: 'Cinzel', serif !important;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.1) !important;
  letter-spacing: 0.5px !important;
}
/* Editor and Dev Mode styles */

/* === HIDE ALL EDITING ELEMENTS IN STANDALONE MODE === */
/* Hide all editing elements when dev mode is OFF */

/* ULTRA NUCLEAR OPTION - Hide ALL editing buttons when dev mode is OFF */
/* This rule will override ANY other CSS that might be showing edit buttons */
body.dev-off button[title*="✏️"],
body.dev-off *[class*="edit"],
body.dev-off *[class*="Edit"],

/* NUCLEAR OPTION - Hide all buttons with editing text content */
body.dev-off button:is([class*="add"], [class*="delete"], [class*="remove"], [class*="move"], [class*="upload"], [class*="edit"]),
body.dev-off button[data-category-name],
body.dev-off button[data-spell-name], 
body.dev-off button[data-don-name],
body.dev-off button[data-section-name],
body.dev-off button[data-section-type],
body.dev-off .btn:is([class*="add"], [class*="delete"], [class*="remove"], [class*="move"], [class*="edit"]),
body.dev-off .add-paragraph-btn,
body.dev-off .section-delete,
body.dev-off .spell-delete,
body.dev-off .don-delete,
body.dev-off .don-move-up,
body.dev-off .don-move-down,
body.dev-off .remove-section-btn,
body.dev-off .illus .up,
body.dev-off .illus .rm,
body.dev-off .illus label.up,
body.dev-off .illus button.rm,
body.dev-off .illus label,
body.dev-off .illus input[type="file"],
body.dev-off button[class*="add"]:not(.menu-toggle),
body.dev-off button[class*="delete"],
body.dev-off button[class*="remove"],
body.dev-off button[class*="move"],
body.dev-off button[class*="edit"],
body.dev-off .spell-add,
body.dev-off .don-add,
body.dev-off .category-add,
body.dev-off .add-*,
body.dev-off [data-bound] .up,
body.dev-off [data-bound] .rm,
body.dev-off [data-bound] label,
body.dev-off [data-bound] button,
/* Specific button selectors */
body.dev-off button[data-category-name],
body.dev-off button[data-spell-name],
body.dev-off button[data-don-name],
body.dev-off button[data-section-name],
body.dev-off button[data-section-type],
/* Input file upload elements */
body.dev-off input[type="file"],
body.dev-off label[for*="file"],
/* Additional specific selectors */
body.dev-off .add-subclass-btn,
body.dev-off .add-new-section,
/* COMPREHENSIVE EDIT BUTTON HIDING */
body.dev-off .edit-btn,
body.dev-off .edit-title-btn,
body.dev-off .edit-paragraph-btn,
body.dev-off .edit-list-btn,
body.dev-off .edit-field-btn,
body.dev-off .edit-effect-btn,
body.dev-off .edit-stats-btn,
body.dev-off .edit-section-btn,
body.dev-off button.edit-btn,
body.dev-off button.edit-title-btn,
body.dev-off button.edit-paragraph-btn,
body.dev-off button.edit-list-btn,
body.dev-off button.edit-field-btn,
body.dev-off button.edit-effect-btn,
body.dev-off button.edit-stats-btn,
body.dev-off button.edit-section-btn,
body.dev-off .editable-section .edit-btn,
body.dev-off .editable-section button[class*="edit"],
body.dev-off .card .edit-btn,
body.dev-off .card button[class*="edit"],
body.dev-off .editable-item .edit-btn,
body.dev-off .editable-item button[class*="edit"],
body.dev-off [data-section-type] .edit-btn,
body.dev-off [data-section-type] button[class*="edit"],
body.dev-off .add-*-btn,
/* Very specific selectors for inline styled buttons */
body.dev-off button[style*="background: #ff6b6b"],
body.dev-off button[style*="background: var(--bronze)"],
body.dev-off button[style*="background: #dc2626"],
/* Target buttons by text content patterns */
body.dev-off .btn.small[data-category-name],
body.dev-off .btn.small[data-spell-name],  
body.dev-off .btn.small[data-don-name],
body.dev-off .btn.small[data-section-name],
body.dev-off .btn.small[data-don-index],
/* Target specific button classes from renderer */
body.dev-off .spell-add,
body.dev-off .don-add,
body.dev-off .spell-delete,
body.dev-off .don-delete,
body.dev-off .don-move-up,
body.dev-off .don-move-down,
body.dev-off .section-delete,
body.dev-off .remove-section-btn,
/* Universal button selectors with edit-related titles */
body.dev-off button[title*="diter"],
body.dev-off button[title*="Edit"],
body.dev-off button[title*="Supprimer"],
body.dev-off button[title*="Ajouter"],
body.dev-off button[title*="Haut"],
body.dev-off button[title*="Bas"] {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  pointer-events: none !important;
}

/* Système d'agrandissement d'images */
.illus img.enlarged {
  position:fixed !important; top:50% !important; left:50% !important; 
  transform:translate(-50%, -50%) !important; z-index:9999 !important;
  max-width:85vw !important; max-height:85vh !important; width:auto !important; height:auto !important;
  box-shadow:0 20px 60px rgba(0,0,0,.5), inset 0 4px 12px rgba(212,175,55,.8) !important;
  cursor:zoom-out !important; 
  transition:none !important;
  pointer-events:auto !important;
  object-fit:contain !important;
}

/* Forcer l'état stable sur hover pour les images agrandies */
.illus img.enlarged:hover,
article[data-page="guerrier"] .illus img.enlarged:hover,
article[data-page="mage"] .illus img.enlarged:hover,
article[data-page="pretre"] .illus img.enlarged:hover,
article[data-page="rodeur"] .illus img.enlarged:hover,
article[data-page="enchanteur"] .illus img.enlarged:hover,
.illus[data-illus-key^="class:"] img.enlarged:hover,
article[data-page="sorts-mage"] .illus img.enlarged:hover,
article[data-page="sorts-pretre"] .illus img.enlarged:hover,
article[data-page="sorts-enchanteur"] .illus img.enlarged:hover,
.illus[data-illus-key^="spellcategory:"] img.enlarged:hover {
  transform:translate(-50%, -50%) !important;
  transition:none !important;
}

.image-backdrop {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:9998; opacity:0; transition:opacity .3s ease; pointer-events:none;
}
.image-backdrop.visible {
  opacity:1; pointer-events:auto;
}

/* Interactive buttons */
.btn-action{display:inline-flex;gap:var(--space-sm);align-items:center;padding:var(--space-sm) 10px;border-radius:10px;cursor:pointer;border:1px solid}
.btn-upload{border-color:rgba(0,0,0,.25);border-style:dashed;background:#fff8ee}
.btn-remove{border-color:rgba(120,0,0,.25);background:#fee2e2}
.btn-add{border-color:rgba(0,120,0,.25);background:#f0fff4;margin-bottom:10px}
.btn-delete{padding:var(--space-xs) var(--space-md);border-radius:6px;font-size:12px;margin-left:10px}
.illus .up{border-color:rgba(0,0,0,.25);border-style:dashed;background:#fff8ee}
.illus .rm, .spell-delete{border-color:rgba(120,0,0,.25);background:#fee2e2}
.spell-add{border-color:rgba(0,120,0,.25);background:#f0fff4;margin-bottom:10px}
.spell-delete{padding:var(--space-xs) var(--space-md);border-radius:6px;font-size:12px;margin-left:10px}

/* Bouton d'ajout de paragraphe - seulement dans les articles */
.add-paragraph-btn {
  display:none !important;
}
/* Masquer explicitement dans la sidebar et le sommaire */
.sidebar .add-paragraph-btn,
.toc .add-paragraph-btn,
#toc .add-paragraph-btn {
  display:none !important;
  visibility:hidden !important;
}
/* Afficher SEULEMENT dans les articles actifs en mode dev */
body.dev-on article.active .add-paragraph-btn {
  display:block !important; margin:10px 0; padding:8px 12px; background:var(--card); 
  border:2px dashed var(--bronze); border-radius:8px; cursor:pointer;
  color:var(--bronze); text-align:center; transition:all .2s ease;
}
body.dev-on article.active .add-paragraph-btn:hover {
  background:rgba(139,69,19,.08); border-color:var(--gold);
  color:var(--gold);
}

/* Bouton d'ajout de sous-classe */
.add-subclass-btn {
  display:none; margin:12px 0 4px 0; padding:8px 12px; background:var(--card);
  border:1px dashed var(--bronze); border-radius:8px; cursor:pointer;
  color:var(--bronze); text-align:center; font-size:13px;
  transition:all .2s ease; width:100%;
}
/* Afficher dans les pages de classes en mode dev */
body.dev-on article[data-page="guerrier"] .add-subclass-btn,
body.dev-on article[data-page="mage"] .add-subclass-btn,
body.dev-on article[data-page="pretre"] .add-subclass-btn,
body.dev-on article[data-page="rodeur"] .add-subclass-btn,
body.dev-on article[data-page="enchanteur"] .add-subclass-btn {
  display:block !important;
}
body.dev-on article[data-page="guerrier"] .add-subclass-btn:hover,
body.dev-on article[data-page="mage"] .add-subclass-btn:hover,
body.dev-on article[data-page="pretre"] .add-subclass-btn:hover,
body.dev-on article[data-page="rodeur"] .add-subclass-btn:hover,
body.dev-on article[data-page="enchanteur"] .add-subclass-btn:hover {
  background:rgba(139,69,19,.08); border-color:var(--gold);
  color:var(--gold); transform:translateY(-1px);
  box-shadow:0 4px 8px rgba(0,0,0,.1);
}

/* Modales */
.category-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.category-modal.visible {
  display:flex;
}
.category-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:500px; width:90%; box-shadow:var(--shadow);
  position:relative;
}

/* Modal pour les icônes */
.icons-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.icons-modal.visible {
  display:flex;
}
.icons-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:600px; width:90%; max-height:80vh; overflow-y:auto;
  box-shadow:var(--shadow); position:relative;
}
.icons-grid {
  display:grid; grid-template-columns:repeat(auto-fill, minmax(60px, 1fr));
  gap:var(--space-md); margin:var(--space-xl) 0; max-height:400px; overflow-y:auto;
  border:1px solid var(--rule); border-radius:var(--space-md); padding:var(--space-xl);
}
.icon-item {
  display:flex; align-items:center; justify-content:center;
  padding:var(--space-lg); border:1px solid var(--rule); border-radius:var(--space-md);
  cursor:pointer; transition:var(--transition-fast); font-size:24px;
  background:var(--paper);
}
.icon-item:hover {
  background:var(--bronze); color:white; transform:scale(1.1);
  box-shadow:0 4px 8px rgba(0,0,0,.2);
}
.icon-item.copied {
  background:var(--gold); color:white; animation:copyFlash .5s ease;
}
@keyframes copyFlash {
  0% { transform:scale(1.1); }
  50% { transform:scale(1.3); }
  100% { transform:scale(1.1); }
}

/* Modal pour les éléments */
.elements-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.elements-modal.visible {
  display:flex;
}
.elements-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:400px; width:90%; 
  box-shadow:var(--shadow); position:relative;
}
.elements-list {
  display:flex; flex-direction:column; gap:var(--space-md); margin:var(--space-xl) 0;
}
.element-item {
  display:flex; align-items:center; gap:var(--space-md); padding:var(--space-md);
  border:2px solid var(--rule); border-radius:var(--space-md); cursor:pointer;
  transition:var(--transition-fast); background:var(--card);
}
.element-item:hover {
  background:var(--paper); border-color:var(--bronze); transform:translateY(-2px);
  box-shadow:0 4px 12px rgba(0,0,0,.1);
}
.element-item:active {
  transform:translateY(0) scale(0.98);
}
.element-icon {
  width:24px; height:24px; border-radius:50%; flex-shrink:0;
}
.element-name {
  font-weight:600; flex-grow:1;
}
.copy-indicator {
  font-size:12px; color:var(--paper-muted); opacity:0;
  transition:opacity 0.3s ease;
}
.element-item.copied .copy-indicator {
  opacity:1;
}

/* === UNIFIED EDIT BUTTONS FOR ALL SECTIONS === */
.editable-section {
  position: relative;
  margin: 8px 0;
}

.editable-section .edit-btn {
  position: absolute;
  right: 8px;
  top: 8px;
  background: var(--bronze);
  color: white;
  border: none;
  border-radius: 6px;
  padding: 4px 8px;
  cursor: pointer;
  font-size: 12px;
  opacity: 0.6;
  transition: all 0.2s ease;
  z-index: 10;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.editable-section:hover .edit-btn {
  opacity: 1;
  transform: scale(1.05);
  background: var(--gold);
}

.editable-section .edit-btn:hover {
  background: var(--gold) !important;
  transform: scale(1.1) !important;
  box-shadow: 0 3px 8px rgba(0,0,0,0.2);
}

.editable-section .edit-btn:active {
  transform: scale(0.95) !important;
}

/* Special positioning for different types */
.editable-list-container .edit-btn {
  right: 16px;
  top: 16px;
}

.editable-section[data-section-type="intro"] .edit-btn {
  right: 12px;
  top: 12px;
}

/* Title edit buttons */
.edit-title-btn {
  position: relative !important;
  right: auto !important;
  top: auto !important;
  margin-left: 12px;
  transform: none !important;
}

.edit-title-btn:hover {
  transform: scale(1.1) !important;
}

/* When editing, hide the button and expand content */
.editable-section[data-editing="true"] .edit-btn {
  display: none;
}

/* Visual feedback for editable sections */
.editable-section:hover {
  background: rgba(184, 134, 11, 0.05);
  border-radius: 8px;
  transition: background 0.2s ease;
}

.editable-section[data-editing="true"] {
  background: rgba(255, 255, 0, 0.1);
  border: 1px dashed var(--bronze);
  border-radius: 8px;
  padding: 8px;
}

/* Legacy support for old list items */
.editable-item {
  position: relative;
  padding-right: 40px;
}

.editable-content {
  display: block;
  margin-right: 35px;
}
</style>
</head>
<body class="dev-off">

<div class="shell">
  <button aria-controls="sidebar" aria-expanded="false" aria-label="Ouvrir le sommaire" class="menu-toggle" id="menuToggle" style="display:none">☰ Sommaire</button>
  <div class="backdrop" hidden="" id="backdrop"></div>
  
  <main class="page">
    <aside class="sidebar" id="sidebar">
      <div class="panel">
        <div class="searchbar">
          <input autocomplete="off" id="search" placeholder="Rechercher une règle, une classe…">
          <button class="btn" id="clear" title="Effacer">✖</button>
        </div>
        <div class="tools">
          <!-- Dev mode disabled in standalone version -->
        </div>
        <div class="toc" id="toc">
          <!-- Table of contents will be generated by JavaScript -->
        </div>
      </div>
    </aside>
    
    <div id="views">
      <!-- Main content will be generated by JavaScript -->
      <div id="app-loading">Chargement...</div>
    </div>
  </main>
  
  <footer>
    <p>JDR‑BAB — Règles et contenus sous licence libre</p>
  </footer>
</div>

<script>

    // Global data from modular files
    window.SORTS = [
  {
    "nom": "Sorts de Mage",
    "description": "Sorts de destruction.",
    "sorts": [
      {
        "nom": "Boule de Feu",
        "description": "Lance une boule de Feu sur un adversaire.",
        "categorie": "Mage",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> 20m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 3",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige 5 dégats de <span style=\"color: #e25822; font-weight: bold;\">Feu</span> à la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Double les dégâts et enflamme la cible, infligeant 2 dégats de Feu au prochain tour du lanceur.",
        "effetEchec": "<strong>Échec Critique:&nbsp;</strong>Le sort inflige ses dégats à un allié dans la trajectoire."
      },
      {
        "nom": "Éclair",
        "description": "Frappe une cible avec un éclair électrique.",
        "categorie": "Mage",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 2",
        "portee": "🎯 <strong>Portée:</strong> 20m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 5",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> Aucune",
        "effetNormal": "<strong>Effet:</strong> &nbsp;Inflige 6 dégats d'<span style=\"color: #22c55e; font-weight: bold;\">Air</span> à la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>Double les dégâts et inflige les dégats à un enemy à moins de 5m de la cible.",
        "effetEchec": "<strong>Échec Critique:&nbsp;</strong>Le sort inflige ses dégats à un allié dans la trajectoire."
      },
      {
        "nom": "Vague déferlante",
        "description": "Une puissante vague d'eau s'abat sur vos ennemis.",
        "categorie": "Sorts de Mage",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 3",
        "portee": "🎯 <strong>Portée:</strong> 5m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 6",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> Volant.",
        "effetNormal": "<strong>Effet:</strong> &nbsp;Inflige 6 dégats d'<span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span> aux créature devant le lanceur (largeur 1.5m distance 5m) et les repousse jusqu'à 5m.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>Double dégats et portée.",
        "effetEchec": "<strong>Échec Critique:&nbsp;</strong>Sans effet."
      }
    ]
  },
  {
    "nom": "Sorts de Prêtre",
    "description": "Sorts de soutiens et anti mort-vivants.",
    "sorts": [
      {
        "nom": "Châtiment",
        "description": "Invoque un magie divine qui blesse les morts-vivants",
        "categorie": "Anti-mort-vivant",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> 20m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 3",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> &nbsp;<br>- Non mort-vivant <br>- Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige *Intelligence* dégâts <span style=\"color: #ffd700; font-weight: bold;\">Divin</span> à la cible.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>Double dégâts.",
        "effetEchec": "<strong>Échec Critique:&nbsp;</strong>Sans effet."
      },
      {
        "nom": "Soin mineur",
        "description": "Une magie divine soigne les blessures du héros ou d'un allié proche.",
        "categorie": "Sorts de Prêtre",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> 10m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 5",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> &nbsp;mort-vivant.",
        "effetNormal": "<strong>Effet:</strong> Soigne la cible de 5 points de vie. Tous les 5 points d'intelligence, augmente le soin de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>Double le soin.",
        "effetEchec": "<strong>Échec Critique:&nbsp;</strong>Sans effet."
      },
      {
        "nom": "Protection",
        "description": "Protège le lanceur ou un allié.",
        "categorie": "Sorts de Prêtre",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 2",
        "portee": "🎯 <strong>Portée:</strong> 3m",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "🔵 <strong>Coût mana:</strong> 5",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Augmente l'armure de 3 pendant 5 tours.<br> Tous les 5 d'Intelligence, augmente l'armure de 1 supplémentaire.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> Double l'armure prodiguée.",
        "effetEchec": "<strong>Échec Critique:&nbsp;</strong> Sans effet."
      }
    ]
  },
  {
    "nom": "Sorts d'Enchanteur",
    "description": "Sorts d'amélioration et d'affaiblissement.",
    "sorts": [
      {
        "nom": "Accroche terrestre",
        "description": "Le sol se soulève et s'agrippe aux jambes de la cible, alourdissant ses pas d'une étreinte de pierre vivante.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> 30m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 3",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> <br>- Volonté &gt; Intelligence du lanceur<br>- Element <span style=\"color: #8b5e34; font-weight: bold;\">Terre</span><br>- Lévitation ou Volant.",
        "effetNormal": "<strong>Effet:</strong>&nbsp;La cible voit sa vitesse de déplacement réduite de moitiée et ne peut plus esquiver ou sauter.",
        "effetCritique": "<strong>&nbsp;</strong>&nbsp;La cible est immobilisée pendant la durée du sort.",
        "effetEchec": "<strong>&nbsp;</strong>&nbsp;Aucun effet."
      },
      {
        "nom": "Accélération",
        "description": "Une magie des vents accélère un allié ou le lanceur.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 1",
        "portee": "🎯 <strong>Portée:</strong> 5m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 4",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> Aucune",
        "effetNormal": "<strong>Effet:</strong> &nbsp;La vitesse de déplacement de la cible est augmentée de 50% pendant 5 tours.<br>Non Cumulable. Si le sort est lancé à nouveau, les anciennes cibles perdent l'amélioration.&nbsp;",
        "effetCritique": "La vitesse est augmentée de 100%.",
        "effetEchec": "Aucun effet."
      },
      {
        "nom": "Sommeil",
        "description": "Un voile d'ombre caresse la cible, l'enveloppant dans un sommeil surnaturel.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "📋 <strong>Prérequis:</strong> Niveau 2",
        "portee": "🎯 <strong>Portée:</strong> 5m",
        "coutMana": "🔵 <strong>Coût mana:</strong> 8",
        "tempsIncantation": "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "⏳ <strong>Durée:</strong> Instantané",
        "resistance": "<strong>Sans effet si:</strong> <br>- Volonté &gt; Intelligence du lanceur<br>- Element <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span>",
        "effetNormal": "<strong>Effet:</strong> La cible devient inactive pendant ses 2 prochains tours. Si la cible subit des dégats, elle est reveillée.",
        "effetCritique": "L'effet dure 4 tours.",
        "effetEchec": "Le lanceur est endormi à son prochain tour."
      }
    ]
  },
  {
    "nom": "Sorts de Monstres",
    "description": "Sorts divers de monstres.",
    "sorts": []
  }
];
    window.CLASSES = [
  {
    "nom": "Guerrier",
    "resume": "Héros sans égal au combat au corp à corp.",
    "capacites": [
      "<em>Expert de l'équipement</em>: Toutes les armes, armures (légères/lourdes), bouclier.",
      "<em>Hardiesse</em>: Gagne la compétence Hardiesse rang 1."
    ],
    "sousClasses": [
      {
        "nom": "Nain des montagnes",
        "base": {
          "Force": "5",
          "Agilité": "2",
          "Endurance": "7",
          "Intelligence": "1",
          "Volonté": "5",
          "Chance": "1"
        },
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Force 💪, +3 Endurance 🛡️, +1 Volonté⚡",
        "capacites": [
          "<em>Brise rocher</em>: Gagne 1 de compétence sur les tests de compétence Hardiesse pour une destruction d'objet.",
          "<em>Volonté inflexible</em>: Les nains possèdent une volonté inflexible qui les rendent résistants aux sortilèges (caractéristique Volonté élevée)."
        ]
      },
      {
        "nom": "Berserker",
        "base": {
          "Force": 5,
          "Agilité": 4,
          "Endurance": 5,
          "Intelligence": 1,
          "Volonté": 1,
          "Chance": 1
        },
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Force 💪, +1 Agilité 🏃, +2 Endurance 🛡️",
        "capacites": [
          "<em>Frappe en chaîne</em>: Sur un critique au corps à corps, touche aussi un adversaire à moins de 2m.",
          "<em>Risque sauvage</em>: +1 chance de critique physique s'il ne porte pas de bouclier."
        ]
      }
    ]
  },
  {
    "nom": "Mage",
    "resume": "Spécialiste de la magie destructrice.",
    "capacites": [
      "<em>Équipement de mage</em>: bâtons, robes.",
      "<em>Sorts de mage</em>: Apprend et lance des sorts de mage."
    ],
    "sousClasses": [
      {
        "nom": "Érudit",
        "base": {
          "Force": 1,
          "Agilité": 1,
          "Endurance": 2,
          "Intelligence": 5,
          "Volonté": 3,
          "Chance": 1
        },
        "progression": "<strong>📈 Progression par niveau:</strong> +3 Intelligence 🧠, +2 Volonté ⚡",
        "capacites": [
          "<em>Instruit</em>: Gagne la compétence Réflexion rang 1.",
          "<em>Apprentissage accéléré</em>: Le niveau de l'érudit est considéré comme deux fois plus grand pour les prérequis d'apprentissage de sorts."
        ]
      },
      {
        "nom": "Elfe",
        "base": {
          "Force": 2,
          "Agilité": 2,
          "Endurance": 3,
          "Intelligence": 3,
          "Volonté": 2,
          "Chance": 1
        },
        "progression": "<strong>📈 Progression par niveau:</strong> +1 Force 💪, +1 Agilité 🏃, +1 Endurance 🛡️, +1 Intelligence 🧠, +1 Volonté ⚡",
        "capacites": [
          "<em>Instinct elfique</em>: Gagne la compétence Coordination rang 1.",
          "<em>Équipement d'elfe</em>: Epées à une main, armures légères.",
          "<em>Briseur de sceaux</em>: Gagne 1 de compétence sur les tests de compétence pour comprendre ou ouvrir une porte scellée magiquement"
        ]
      }
    ]
  },
  {
    "nom": "Prêtre",
    "resume": "Spécialiste de la magie de soutien et anti morts-vivants.",
    "capacites": [
      "<em>Équipement de prêtre</em>: bâtons, robes.",
      "<em>Sorts de prêtre</em>: Apprend et lance des sorts de Prêtre.",
      "<em>Eloquence</em>: Gagne la compétence Eloquence rang 1."
    ],
    "sousClasses": [
      {
        "nom": "Inquisiteur",
        "base": {
          "Force": 3,
          "Agilité": 1,
          "Endurance": 4,
          "Intelligence": 3,
          "Volonté": 5,
          "Chance": 1
        },
        "progression": "<strong>📈 Progression par niveau:</strong> +1 Force 💪, +2 Intelligence 🧠, +1 Volonté ⚡, +1 Endurance 🛡️",
        "capacites": [
          "<em>Magie purificatrice</em>: Les sorts visant les morts-vivants ne ratent jamais.",
          "<em>Port du bouclier</em>: Peut s'équiper d'un bouclier."
        ]
      },
      {
        "nom": "Clerc Divin",
        "base": {
          "Force": 1,
          "Agilité": 1,
          "Endurance": 2,
          "Intelligence": 3,
          "Volonté": 5,
          "Chance": 5
        },
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Intelligence 🧠, +2 Volonté ⚡, + 1 Chance 🍀",
        "capacites": [
          "<em>Maître des soins</em>: Augmente les chances de critiques pour les sorts de soins de 1.",
          "<em>Bien né</em>: Réduit les dégats <span style=\"color: #ffd700; font-weight: bold;\">Divin</span> reçu de 50%. Si son élément d'affiliation est <span style=\"color: #ffd700; font-weight: bold;\">Divin</span>, il devient insensible aux dégats <span style=\"color: #ffd700; font-weight: bold;\">Divin</span>."
        ]
      }
    ]
  },
  {
    "nom": "Rôdeur",
    "resume": "Héros très agile.",
    "capacites": [
      "<em>Équipement de rôdeur</em>: armures légères, dagues.",
      "<em>Coordination</em>: Gagne la compétence Coordination rang 1."
    ],
    "sousClasses": [
      {
        "nom": "Voleur",
        "base": {
          "Force": 3,
          "Agilité": 5,
          "Endurance": 2,
          "Intelligence": 2,
          "Volonté": 2,
          "Chance": 5
        },
        "progression": "<strong>📈 Progression par niveau:</strong> +3 Agilité 🏃, +1 Force 💪, +1 Endurance 🛡️",
        "capacites": [
          "<em>Mains expertes</em>: Gagne la compétence Finesse rang 1.",
          "<em>Sprint</em>: Peut utiliser une Action secondaire pour doubler sa vitesse.",
          "<em>Vicieux</em>: Un coup critique dans le dos triple les dégats au lieu de les doubler."
        ]
      },
      {
        "nom": "Chasseur",
        "base": {
          "Force": 3,
          "Agilité": 5,
          "Endurance": 2,
          "Intelligence": 4,
          "Volonté": 2,
          "Chance": 1
        },
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Agilité 🏃, +1 Force 💪, +1 Endurance 🛡️, +1 Intelligence 🧠",
        "capacites": [
          "<em>Maîtrise des plantes</em>: Peut utiliser des plantes médicinales. Leur utilisation nécessite un niveau d'Intelligence.",
          "<em>Armes du Chasseur</em>: Peut utiliser les épées courtes et les arcs.",
          "<em>Connaissance de la nature</em>: Gagne 1 de compétence sur les tests de Réflexion lié à animal ou une plante."
        ]
      }
    ]
  },
  {
    "nom": "Enchanteur",
    "resume": "Détenteur d'une magie singulière, qui fait de lui un allié précieux.",
    "capacites": [
      "<em>Équipement d'enchanteur</em>: robes, bâtons, baguettes.",
      "<em>Sorts d'enchanteur</em>: Apprend et lance des sorts d'Enchanteur."
    ],
    "sousClasses": [
      {
        "nom": "Esprit de la grande Fée",
        "base": {
          "Force": 1,
          "Agilité": 5,
          "Endurance": 1,
          "Intelligence": 5,
          "Volonté": 2,
          "Chance": 1
        },
        "progression": "<strong>📈 Progression par niveau:</strong> +1 Agilité 🏃, +2 Intelligence 🧠, +1 Volonté ⚡, +1 Chance 🍀",
        "capacites": [
          "<em>Tatillon</em>: Gagne la compétence Finesse rang 1.",
          "<em>Lévitation</em>: ignore dégâts/ralentissements venant du sol.",
          "<em>Rayon de l'Amitié</em>: les sorts bénéfiques ciblent 1 allié supplémentaire."
        ]
      },
      {
        "nom": "Lutin",
        "base": {
          "Force": 1,
          "Agilité": 1,
          "Endurance": 1,
          "Intelligence": 5,
          "Volonté": 2,
          "Chance": 5
        },
        "progression": "<strong>📈 Progression par niveau:</strong> +2 Intelligence 🧠, +1 Volonté ⚡, +2 Chance 🍀",
        "capacites": [
          "<em>Secrets bien gardés</em>: Gagne la compétence Reflexion rang 1.",
          "<em>Expert des baguettes</em>: sur critique à la baguette, la charge n'est pas consommée.",
          "<em>Sourire malicieux</em>: les sorts à effets négatifs peuvent cibler 1 adversaire supplémentaire."
        ]
      }
    ]
  }
];
    window.DONS = [
  {
    "nom": "Guerrier",
    "description": "Dons accessibles aux guerriers.",
    "dons": [
      {
        "nom": "Expertise du bouclier",
        "description": "Si le héros a un bouclier équipé, il peut utiliser une action secondaire pour doubler son armure physique jusqu'au prochain tour.",
        "prerequis": "-",
        "cout": "1 point de don"
      },
      {
        "nom": "Charge",
        "description": "Une fois par combat, peut utiliser une action secondaire pour doubler sa vitesse de déplacement et forcer un coup critique sur la prochaine attaque physique de ce tour (si elle réussie).",
        "prerequis": "🏃Agilité 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Volonté de fer",
        "description": "Une fois par jour, le héros peut utiliser une action secondaire pour se débarasser de toutes ses alterations magiques.",
        "prerequis": "⚡Volonté 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Coup de bouclier",
        "description": "Si le héros a un bouclier équipé, lorsque le héros subit des dégats aux corps à corps, il peut choisir d'utiliser une action secondaire pour infliger à l'attaquant des dégats équivalents à l'armure du bouclier.",
        "prerequis": "-",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Rôdeur",
    "description": "Description de cette catégorie de dons.",
    "dons": [
      {
        "nom": "Croche-patte",
        "description": "Peut utiliser une action secondaire pour mettre un adversaire au corp à corp, de moins de 2m, et qui se trouve au sol, à <span style=\"color: #8b5e34; font-weight: bold;\">Terre</span>.",
        "prerequis": "-",
        "cout": "1 point de don"
      },
      {
        "nom": "Chasse et pêche",
        "description": "Le héros n'as plus besoin de sa ratio de nourriture quotidienne.",
        "prerequis": "-",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Mage",
    "description": "Description de cette catégorie de dons.",
    "dons": [
      {
        "nom": "Gemme de mana",
        "description": "Une fois par jour, le héros peut récupérer l'intégralité de son Mana en utilisant une action secondaire.",
        "prerequis": "-",
        "cout": "1 point de don"
      },
      {
        "nom": "Resistance élémentaire 1",
        "description": "Le héros gagne 5 d'armure élémentaire de <span style=\"color: #e25822; font-weight: bold;\">Feu</span>, <span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span>, <span style=\"color: #8b5e34; font-weight: bold;\">Terre</span>, <span style=\"color: #22c55e; font-weight: bold;\">Air</span>.",
        "prerequis": "Non cumulable.",
        "cout": "1 point de don"
      },
      {
        "nom": "Resistance magique 1",
        "description": "Le héros gagne 5 d'armure élémentaire de <span style=\"color: #fbbf24; font-weight: bold;\">Lumière</span>, <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span>, <span style=\"color: #ffd700; font-weight: bold;\">Divin</span>, <span style=\"color: #a855f7; font-weight: bold;\">Maléfique</span>.",
        "prerequis": "Non cumulable.",
        "cout": "1 point de don"
      },
      {
        "nom": "Spécialisation élémentaire 1",
        "description": "Le héros peut choisir un élément et augmenter de 5 les dégats infligés avec les sorts de cet élément.",
        "prerequis": "Non cumulable",
        "cout": "1 point de don"
      },
      {
        "nom": "Infusion élémentaire",
        "description": "Le héros peut, en utilisant une action secondaire, choisir un de ses sorts et dépenser son coût en mana. Son arme est alors imprégnée de l'élement du sort, et infligera à sa prochaine attaque des dégats de cet l'élément à la place des dégats physiques.",
        "prerequis": "-",
        "cout": "1 point de don"
      },
      {
        "nom": "Polyglotte",
        "description": "Peut lire et parler toutes les langues.",
        "prerequis": "Reflexion rang 2.",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Pretre",
    "description": "Description de cette catégorie de dons.",
    "dons": [
      {
        "nom": "Mécréants",
        "description": "Les dégats physiques infligés aux créatures de l'élément <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span> ou <span style=\"color: #a855f7; font-weight: bold;\">Maléfique</span> sont doublés.",
        "prerequis": "-",
        "cout": "1 point de don"
      },
      {
        "nom": "Au milieu du combat",
        "description": "Permet de porter une armure légère.",
        "prerequis": "💪Force 3",
        "cout": "1 point de don"
      },
      {
        "nom": "Jugement éclair",
        "description": "Si le Prêtre a effectué un sort ce tour ci, il peut effectuer une attaque au corp à corp avec une action secondaire.",
        "prerequis": "💪Force 3",
        "cout": "1 point de don"
      },
      {
        "nom": "Musique",
        "description": "Permet d'apprendre un instrument de musique (ou de savoir chanter) au choix, gagnant 2 de compétences sur les tests de compétence éloquence le nécéssitant.",
        "prerequis": "-",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Enchanteur",
    "description": "Description de cette catégorie de dons.",
    "dons": [
      {
        "nom": "Réparateur de baguettes",
        "description": "Permet de regagner une charge de baguette, une fois par jour.",
        "prerequis": "-",
        "cout": "1 point de don"
      },
      {
        "nom": "Magie aléatoire destructrice",
        "description": "Permet de choisir et d'apprendre un sort de mage et de pouvoir le lancer à volonté. Le sort ne peut pas être changé par la suite.",
        "prerequis": "Non cumulable.",
        "cout": "1 point de don"
      },
      {
        "nom": "Magie aléatoire de prêtre",
        "description": "Permet de choisir et d'apprendre un sort de prêtre et de pouvoir le lancer à volonté. Le sort ne peut pas être changé par la suite.",
        "prerequis": "Non cumulable",
        "cout": "1 point de don"
      },
      {
        "nom": "Alteration risquée",
        "description": "Lorsque un sort d'alteration magique est effectué alors que la cible est au corps à corps, il ne peut plus être resisté par la Volonté de la cible.",
        "prerequis": "-",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Generaux",
    "description": "Dons accessibles à toutes les classes.",
    "dons": [
      {
        "nom": "Toujours pret",
        "description": "Le maximum d'efforts passe à 6.",
        "prerequis": "Aucun prérequis",
        "cout": "1 point de don"
      },
      {
        "nom": "Doué",
        "description": "Gagne une compétence rang 1.",
        "prerequis": "N'as pas ce don.",
        "cout": "1 points de don"
      },
      {
        "nom": "Brillant",
        "description": "Gagne une compétence rang 2.",
        "prerequis": "La compétence rang 1.",
        "cout": "2 points de don"
      },
      {
        "nom": "Prodigieux",
        "description": "Gagne une compétence rang 3.",
        "prerequis": "La compétence rang 2.",
        "cout": "3 point de don"
      },
      {
        "nom": "Hyperactif",
        "description": "Le héros dispose maintenant de deux actions secondaires par tour.",
        "prerequis": "Niveau 3",
        "cout": "2 points de don"
      },
      {
        "nom": "Equitation",
        "description": "Permet de monter à cheval ou équivalent.",
        "prerequis": "Niveau 5",
        "cout": "1 point de don"
      }
    ]
  }
];
    window.IMAGES = {
  "images": {
    "subclass:Guerrier:Nain des montagnes": "https://i.ibb.co/Zpv02X9p/e8c10c36dc90.jpg",
    "subclass:Guerrier:Berserker": "https://i.ibb.co/DPYjyGVd/b85000c2afa4.jpg",
    "subclass:Mage:Érudit": "https://i.ibb.co/M5pcNmF9/05fa4e535010.jpg",
    "subclass:Mage:Elfe": "https://i.ibb.co/K1SMkgb/d738588e0528.jpg",
    "subclass:Prêtre:Inquisiteur": "https://i.ibb.co/dJ02RNMc/c9cd3553df7e.jpg",
    "subclass:Prêtre:Clerc Divin": "https://i.ibb.co/8gFGZYqJ/698304cc75ee.jpg",
    "subclass:Rôdeur:Voleur": "https://i.ibb.co/q3jSxDnQ/90e89c692b47.jpg",
    "subclass:Rôdeur:Chasseur": "https://i.ibb.co/70wP75z/53de7da9e55c.jpg",
    "subclass:Enchanteur:Esprit de la grande Fée": "https://i.ibb.co/Cswfsyzz/9920a4e75242.jpg",
    "subclass:Enchanteur:Lutin": "https://i.ibb.co/Fbspq9hP/dd5e7b366e0f.jpg",
    "sort:Sorts de Mage:Boule de Feu": "https://i.ibb.co/vCWmgrQ5/Boule-De-Feu.png",
    "sort:Sorts de Mage:Éclair": "https://i.ibb.co/h194qhvd/Eclair.png",
    "sort:Sorts de Mage:Vague déferlante": "https://i.ibb.co/BSHtL8K/Vague.png",
    "sort:Sorts de Prêtre:Châtiment": "https://i.ibb.co/JRPyXx1L/Chatiment-Sacr.png",
    "sort:Sorts de Prêtre:Soin mineur": "https://i.ibb.co/YBC2HSnK/Soin-Mineur.png",
    "sort:Sorts d'Enchanteur:Accroche terrestre": "https://i.ibb.co/27W4NtSQ/Accroche-Terre.png",
    "sort:Sorts d'Enchanteur:Accélération": "https://i.ibb.co/Vc072qQB/Acceleration.png",
    "sort:Sorts d'Enchanteur:Sommeil": "https://i.ibb.co/rKyTh27C/Sleep.png",
    "sort:Sorts de Prêtre:Nouveau Sort": "https://i.ibb.co/QvK52kxH/Protection.png",
    "sort:Sorts de Prêtre:Protection": "https://i.ibb.co/QvK52kxH/Protection.png",
    "subclass:Guerrier:Nain des montagnes:1": "https://i.ibb.co/FL9m5HJn/Nain.png",
    "subclass:Guerrier:Nain des montagnes:2": "https://i.ibb.co/wNnJxSbj/NaineF.png",
    "subclass:Guerrier:Berserker:1": "https://i.ibb.co/YBWFbTKv/berseker.png",
    "subclass:Guerrier:Berserker:2": "https://i.ibb.co/20b74x2R/Berseker-F.png",
    "subclass:Mage:Érudit:1": "https://i.ibb.co/N8qT2Hf/Mage.png",
    "subclass:Mage:Érudit:2": "https://i.ibb.co/LdcPDSJQ/MageF.png",
    "subclass:Mage:Elfe:2": "https://i.ibb.co/7xvD2mdt/ElfeF.png",
    "subclass:Mage:Elfe:1": "https://i.ibb.co/gFVKrTcV/Elfe.png",
    "subclass:Prêtre:Inquisiteur:1": "https://i.ibb.co/tMcsCB8s/Inquisiteur.png",
    "subclass:Prêtre:Clerc Divin:1": "https://i.ibb.co/209W4ZHW/Pr-tre.png",
    "subclass:Rôdeur:Voleur:1": "https://i.ibb.co/NghMq11n/Voleur-min.png",
    "subclass:Rôdeur:Voleur:2": "https://i.ibb.co/h1BtkGMX/VoleurF.png",
    "subclass:Rôdeur:Chasseur:1": "https://i.ibb.co/yF8jrJYr/Chasseur-min.png",
    "subclass:Rôdeur:Chasseur:2": "https://i.ibb.co/3mQjLJbp/Chasseur-F.png",
    "subclass:Enchanteur:Esprit de la grande Fée:1": "https://i.ibb.co/9k9ywvnP/F-eM.png",
    "subclass:Enchanteur:Esprit de la grande Fée:2": "https://i.ibb.co/pjxDfXBC/F-e.png",
    "subclass:Enchanteur:Lutin:1": "https://i.ibb.co/6cxkMW1d/Lutin.png",
    "subclass:Enchanteur:Lutin:2": "https://i.ibb.co/qLbjJhxw/LutinF.png",
    "subclass:Prêtre:Inquisiteur:2": "https://i.ibb.co/LXwmWYR3/Inquisiteur-F.png",
    "subclass:Prêtre:Clerc Divin:2": "https://i.ibb.co/HfBVNLM3/PretreF.png"
  },
  "meta": {
    "total_images": 40,
    "exported_date": "2025-08-19",
    "note": "Ces images incluent les nouvelles images uploadées"
  }
};
    
    // Build STATIC_PAGES correctly by combining individual page data
    window.STATIC_PAGES = {
      'creation': {
  "page": "creation",
  "title": "Création d'un personnage",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "Guide pour créer un personnage dans le JDR BAB."
    },
    {
      "type": "card",
      "title": "Étapes de création",
      "content": {
        "type": "ordered_list",
        "editType": "creation",
        "items": [
          "Choisir une <strong>classe</strong> puis une <strong>sous‑classe</strong>.",
          "Choisir un <strong>élément</strong>.",
          "Choisir les <strong>dons</strong> (avec 2 points de dons).",
          "Choisir l'<strong>équipement</strong> de départ (avec 100 éclats).",
          "Choisir un <strong>métier</strong>.",
          "Remplir sa feuille de personnage (Efforts, Argent...).",
          "Définir le <strong>nom</strong>, l'<strong>histoire</strong> et l'<strong>apparence</strong>."
        ]
      }
    }
  ]
},
      'elements': {
  "page": "elements",
  "title": "Elements",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "Introduction au système d'éléments du JDR BAB."
    },
    {
      "type": "card",
      "title": "Système d'éléments",
      "content": [
        {
          "type": "paragraph",
          "editType": "elements",
          "editSection": "general",
          "content": "Il existe huit éléments, chacun ayant un opposé. Chaqué Héros où monstre possède un élément d'affiliation. Une créature affiliée à un élément reçoit deux fois moins de dégats venant de cette élément, et deux fois plus venant de l'élément opposé.&nbsp;<br>"
        },
        {
          "type": "paragraph",
          "editType": "elements",
          "editSection": "example",
          "content": "Par exemple, une créature d'élément <span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span>&nbsp;subissant une attaque de 10 dégats <span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span> ne recevra que 5 dégats au final. Si elle subit une attaque de 10 dégats de <span style=\"color: #e25822; font-weight: bold;\">Feu</span> , elle en subira 20 au final. Et si elle subit une attaque de 10 dégats d'<span style=\"color: #22c55e; font-weight: bold;\">Air</span>, elle en subira 10 au final."
        }
      ]
    },
    {
      "type": "card",
      "title": "Paires opposées",
      "content": {
        "type": "element_pairs",
        "pairs": [
          {
            "element1": {
              "name": "Feu",
              "color": "#e25822"
            },
            "element2": {
              "name": "Eau",
              "color": "#2b6cb0"
            }
          },
          {
            "element1": {
              "name": "Terre",
              "color": "#8b5e34"
            },
            "element2": {
              "name": "Air",
              "color": "#22c55e"
            }
          },
          {
            "element1": {
              "name": "Lumière",
              "color": "#fbbf24"
            },
            "element2": {
              "name": "Nuit",
              "color": "#0f172a"
            }
          },
          {
            "element1": {
              "name": "Divin",
              "color": "#ffd700"
            },
            "element2": {
              "name": "Maléfique",
              "color": "#a855f7"
            }
          }
        ]
      }
    },
    {
      "type": "grid",
      "cols": 2,
      "content": [
        {
          "type": "card",
          "title": "Défense",
          "content": [
            {
              "type": "paragraph",
              "editType": "elements",
              "editSection": "defense",
              "content": "Certaines armures/objets/bonus peuvent procurer une armure spécifique à un élément.  Il faudra alors déduire au resultat final. le calcul de dégats se fait dans cette ordre : <br><div> Dégats -> x 2 si critique -> x 0.5 ou x 2 si affilisation élément -> reduction de l'armure</div>"
            }
          ],
          "deletable": true,
          "sectionName": "Défense"
        },
        {
          "type": "card",
          "title": "Attaque",
          "content": [
            {
              "type": "paragraph",
              "editType": "elements",
              "editSection": "attack",
              "content": "Une attaque ne peut avoir qu'un seul élément. Si plusieurs objets/équipements/bonus donne un élément à l'attaque, le héros qui choisi devra choisir quel est l'élément utilisé."
            }
          ],
          "deletable": true,
          "sectionName": "Attaque"
        }
      ]
    }
  ]
},
      'stats': {
  "page": "stats",
  "title": "Statistiques",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "Les six statistiques principales des personnages et leurs effets."
    },
    {
      "type": "card",
      "title": "Statistiques de base",
      "content": {
        "type": "grid",
        "cols": 2,
        "items": [
          {
            "type": "card",
            "title": "💪 Force",
            "content": [
              {
                "type": "paragraph",
                "editType": "stat",
                "editSection": "force",
                "content": "Améliore les dégâts physiques."
              }
            ],
            "deletable": true,
            "sectionName": "Force"
          },
          {
            "type": "card",
            "title": "🛡️ Endurance",
            "content": [
              {
                "type": "paragraph",
                "editType": "stat",
                "editSection": "endurance",
                "content": "-Les points de vie maximum sont de :<br><strong>(10 + 2 x Endurance)</strong><br>- Un repos régénère des points de vie égaux à l'endurance<br>"
              }
            ],
            "deletable": true,
            "sectionName": "Endurance"
          },
          {
            "type": "card",
            "title": "🏃 Agilité",
            "content": [
              {
                "type": "paragraph",
                "editType": "stat",
                "editSection": "agilite",
                "content": "Chaque 5 points ajoutent <strong>+1</strong> aux jets d'esquive et de critique physique."
              }
            ],
            "deletable": true,
            "sectionName": "Agilité"
          },
          {
            "type": "card",
            "title": "🧠 Intelligence",
            "content": [
              {
                "type": "paragraph",
                "editType": "stat",
                "editSection": "intelligence",
                "content": "Détermine la puissance des sorts."
              }
            ],
            "deletable": true,
            "sectionName": "Intelligence"
          },
          {
            "type": "card",
            "title": "⚡ Volonté",
            "content": [
              {
                "type": "paragraph",
                "editType": "stat",
                "editSection": "volonte",
                "content": "- Le mana maximum est de : <strong>(20 + 2 x Volonté)</strong><br>- Réduit les chances de subir des altérations magiques."
              }
            ],
            "deletable": true,
            "sectionName": "Volonté"
          },
          {
            "type": "card",
            "title": "🍀 Chance",
            "content": [
              {
                "type": "paragraph",
                "editType": "stat",
                "editSection": "chance",
                "content": "- Améliore le butin des coffres et les événements aléatoires.<br>- Chaque 5 points ajoutent <strong>+1</strong> aux chances de coup critique avec les sorts et les baguettes."
              }
            ],
            "deletable": true,
            "sectionName": "Chance"
          }
        ]
      }
    }
  ]
},
      'competences-tests': {
  "page": "competences-tests",
  "title": "Compétences & Tests",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "Système de compétences et de tests du JDR BAB."
    },
    {
      "type": "grid",
      "cols": 2,
      "items": [
        {
          "type": "card",
          "title": "Efforts",
          "content": {
            "type": "list",
            "editType": "efforts",
            "items": [
              "<em>Chaque héros dispose de 5 Efforts maximum.</em>",
              "<em>Repos</em>: +1 Effort • Sommeil&nbsp;: +3 Efforts.",
              "<em>Les Efforts peuvent être dépensés pour améliorer un test de compétence.</em>"
            ]
          }
        },
        {
          "type": "card",
          "title": "Compétences",
          "content": {
            "type": "list",
            "editType": "competences",
            "items": [
              "<em>Hardiesse</em>: Pousser, casser, sauter…",
              "<em>Finesse</em>: Crocheter, fabriquer, être discret…",
              "<em>Coordination</em>: Percevoir, équilibre, piloter…",
              "<em>Réflexion</em>: Savoir, comprendre, deviner…",
              "<em>Éloquence</em>: Persuader, mentir, intimider…"
            ]
          }
        }
      ]
    },
    {
      "type": "card",
      "title": "Tests de compétences",
      "content": [
        {
          "type": "paragraph",
          "editType": "tests",
          "editSection": "regles",
          "content": "Quand un Mj annonce un test de compétence, un héros peut choisir de dépenser des efforts pour booster sa compétence. La difficulté d'un test est cachée et est entre 1 et 4 (facile, normale, difficile, expert)."
        },
        {
          "type": "paragraph",
          "editType": "tests",
          "editSection": "resolution",
          "content": "Une fois le test résolu, le Maître de Jeu annonce le résultat. Si le joueur a dépensé plus d'Efforts que nécessaire, l'excédent est perdu."
        }
      ]
    }
  ]
},
      'etats': {
  "page": "etats",
  "title": "Etats",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "Différents états possibles d'une créature ou d'un héros."
    },
    {
      "type": "card",
      "title": "A terre",
      "deletable": true,
      "sectionType": "section1755517689257",
      "content": [
        {
          "type": "paragraph",
          "editType": "custom",
          "editSection": "section1755517689257-content",
          "content": "Ne peut plus faire d'action.<br>Ne peut plus esquiver, et les attaques à l'encontre de la créature sont équivalentes à des attaques dans le dos.<br>Doit dépenser une action secondaire pour se relever."
        }
      ]
    },
    {
      "type": "card",
      "title": "Endormi/assomé/Effrayé",
      "deletable": true,
      "sectionType": "section1755543246768",
      "content": [
        {
          "type": "paragraph",
          "editType": "custom",
          "editSection": "section1755543246768-content",
          "content": "Ne peut plus faire d'action.<br>Ne peut plus esquiver, et les attaques à l'encontre de la créature sont équivalentes à des attaques dans le dos.<br>Une attaque sur la créature la sort de son état."
        }
      ]
    }
  ]
}
    };
    
    // Static pages configuration
    window.STATIC_PAGES_CONFIG = {};
    
    // Mark as standalone version for renderer
    window.STANDALONE_VERSION = true;
    
    // Initialize app when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      // Ensure dev mode is off
      document.body.className = 'dev-off';
      
      // Initialize JdrApp if it exists
      if (window.JdrApp && window.JdrApp.init) {
        window.JdrApp.init();
      }
    });
  
// ============================================================================
// JDR-BAB APPLICATION - CORE MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // MAIN APPLICATION NAMESPACE
  // ========================================
  window.JdrApp = {
    // Core data
    data: {
      SORTS: null,
      CLASSES: null,
      DONS: null,
      STATIC_PAGES: {},
      editedData: {}
    },
    
    // Core modules
    modules: {
      router: {},
      renderer: {},
      editor: {},
      storage: {},
      images: {}
    },
    
    // Utilities
    utils: {
      dom: {},
      events: {},
      data: {}
    },

    // Initialization
    async init() {
      try {
        await this.loadData();
        await this.loadContent();
        this.initializeModules();
      } catch (error) {
        console.error('Failed to initialize JdrApp:', error);
      }
    },

    async loadData() {
      try {
        // Check if we're in standalone mode (data already injected)
        if (window.SORTS && window.CLASSES && window.DONS && window.STATIC_PAGES) {
          const sorts = window.SORTS;
          const classes = window.CLASSES;
          const dons = window.DONS;
          const staticPagesData = window.STATIC_PAGES;
          const staticPagesConfig = window.STATIC_PAGES_CONFIG || {};
          
          this.data.SORTS = sorts;
          this.data.CLASSES = classes;
          this.data.DONS = dons;
          this.data.STATIC_PAGES = staticPagesData;
          this.data.STATIC_PAGES_CONFIG = staticPagesConfig;
          
          window.SORTS = sorts;
          window.CLASSES = classes;
          window.DONS = dons;
          window.STATIC_PAGES = staticPagesData;
          window.STATIC_PAGES_CONFIG = staticPagesConfig;
          
          // Load stored edits AFTER setting up the data structure
          this.loadStoredEditsEarly();
          return;
        }
        
        // Development mode - fetch files
        const [sorts, classes, dons, staticPagesConfig] = await Promise.all([
          fetch('data/sorts.json').then(r => r.json()),
          fetch('data/classes.json').then(r => r.json()),
          fetch('data/dons.json').then(r => r.json()),
          fetch('data/static-pages-config.json').then(r => r.json())
        ]);

        const staticPagesData = {};
        const activePages = staticPagesConfig.pages.filter(page => page.active);
        
        for (const pageConfig of activePages) {
          try {
            const pageData = await fetch(`data/${pageConfig.file}`).then(r => r.json());
            staticPagesData[pageConfig.id] = pageData;
          } catch (error) {
            console.warn(`Failed to load static page ${pageConfig.id}:`, error);
          }
        }

        this.data.SORTS = sorts;
        this.data.CLASSES = classes;
        this.data.DONS = dons;
        this.data.STATIC_PAGES = staticPagesData;
        this.data.STATIC_PAGES_CONFIG = staticPagesConfig;

        window.SORTS = sorts;
        window.CLASSES = classes;
        window.DONS = dons;
        window.STATIC_PAGES = this.data.STATIC_PAGES;
        window.STATIC_PAGES_CONFIG = this.data.STATIC_PAGES_CONFIG;
        
        // Load stored edits in development mode (after data is loaded)
        this.loadStoredEditsEarly();
      } catch (error) {
        console.error('Failed to load data:', error);
        throw error;
      }
    },

    async loadContent() {
      try {
        const viewsDiv = document.getElementById('views');
        if (viewsDiv) {
          const loadingDiv = document.getElementById('app-loading');
          if (loadingDiv) {
            loadingDiv.innerHTML = '<!-- Content will be generated by renderer -->';
          }
        } else {
          const contentHTML = await this.getContentHTML();
          const loadingDiv = document.getElementById('app-loading');
          if (loadingDiv) {
            loadingDiv.outerHTML = contentHTML;
          }
        }
      } catch (error) {
        console.error('Failed to load content:', error);
        throw error;
      }
    },

    async getContentHTML() {
      // This would ideally load from a separate HTML file
      // For now, we'll return the content structure
      return `
        <div class="shell">
          <button aria-controls="sidebar" aria-expanded="false" aria-label="Ouvrir le sommaire" class="menu-toggle" id="menuToggle" style="display:none">☰ Sommaire</button>
          <div class="backdrop" hidden="" id="backdrop"></div>
          <main class="page">
            <aside class="sidebar" id="sidebar">
              <div class="panel">
                <div class="searchbar">
                  <input autocomplete="off" id="search" placeholder="Rechercher une règle, une classe…">
                  <button class="btn" id="clear" title="Effacer">✖</button>
                </div>
                <div class="tools">
                  <button class="btn small" id="devToggle" title="Activer/désactiver le mode développeur">🛠 Dev Mode: OFF</button>
                </div>
                <div class="dev-toolbox" id="devToolbox" style="display: none;">
                  <!-- Dev toolbox content will be injected here -->
                </div>
                <div class="toc" id="toc">
                  <!-- Table of contents will be injected here -->
                </div>
              </div>
            </aside>
            <div id="views">
              <!-- Dynamic content will be injected here -->
            </div>
          </main>
          <footer></footer>
        </div>
      `;
    },

    // Load stored edits early in the loading process (before rendering)
    loadStoredEditsEarly() {
      // Ne plus charger automatiquement le localStorage
      // Laisser les JSON files être la source de vérité
    },

    initializeModules() {
      if (this.utils.events.init) this.utils.events.init();
      if (this.utils.dom.init) this.utils.dom.init();
      if (this.modules.images.init) this.modules.images.init();
      if (this.modules.renderer.init) this.modules.renderer.init();
      if (this.modules.router.init) this.modules.router.init();
      if (this.modules.editor.init) this.modules.editor.init();
      if (this.modules.storage.init) this.modules.storage.init();
      if (this.modules.ui.init) this.modules.ui.init();
    },

    // Force reload JSON data (clear localStorage cache)
    forceReloadData() {
      // Effacer seulement les éditions temporaires
      localStorage.removeItem('jdr-bab-edits');
      localStorage.removeItem('jdr-bab-last-modified');
      window.location.reload();
    }
  };

  // Auto-initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => window.JdrApp.init());
  } else {
    window.JdrApp.init();
  }

})();
// ============================================================================
// JDR-BAB APPLICATION - UTILITIES MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // CENTRALIZED EVENT MANAGEMENT
  // ========================================
  JdrApp.utils.events = {
    listeners: new Map(),
    
    // Centralized event registration
    register(type, selector, handler, options = {}) {
      const key = `${type}-${selector || 'window'}-${Date.now()}`;
      const wrapper = (e) => {
        if (!selector || e.target.matches(selector) || e.target.closest(selector)) {
          handler(e);
        }
      };
      
      if (selector) {
        document.addEventListener(type, wrapper, options);
      } else {
        window.addEventListener(type, wrapper, options);
      }
      
      this.listeners.set(key, { type, wrapper, options });
      return key;
    },
    
    // Delayed execution manager
    delayed: new Map(),
    timeout(key, fn, delay = 0) {
      if (this.delayed.has(key)) {
        clearTimeout(this.delayed.get(key));
      }
      const id = setTimeout(() => {
        fn();
        this.delayed.delete(key);
      }, delay);
      this.delayed.set(key, id);
    },
    
    // Common event handlers
    onDOMReady(fn) {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', fn);
      } else {
        fn();
      }
    },
    
    onHashChange(fn) {
      window.addEventListener('hashchange', fn);
    },
    
    onRouteChange(fn) {
      this.onHashChange(() => this.timeout('route-change', fn, 0));
      this.onDOMReady(() => this.timeout('dom-ready-route', fn, 0));
    }
  };

  // ========================================
  // DOM UTILITIES LIBRARY
  // ========================================
  JdrApp.utils.dom = {
    // Common selectors
    $(selector) { return document.querySelector(selector); },
    $(selector) { return document.querySelectorAll(selector); },
    
    // Element creation with common patterns
    create(tag, className = '', innerHTML = '', attributes = {}) {
      const el = document.createElement(tag);
      if (className) el.className = className;
      if (innerHTML) el.innerHTML = innerHTML;
      Object.entries(attributes).forEach(([key, value]) => {
        el.setAttribute(key, value);
      });
      return el;
    },
    
    
    // Safe innerHTML replacement
    safeSetHTML(element, html) {
      if (element) {
        element.innerHTML = html;
      }
    },
    
    // Safe text content setting
    safeSetText(element, text) {
      if (element) {
        element.textContent = text;
      }
    },
    
    // Toggle class utility
    toggleClass(element, className, force = null) {
      if (element) {
        if (force !== null) {
          element.classList.toggle(className, force);
        } else {
          element.classList.toggle(className);
        }
      }
    },
    
    // Show/hide utilities
    show(element, display = 'block') {
      if (element) {
        element.style.display = display;
      }
    },
    
    hide(element) {
      if (element) {
        element.style.display = 'none';
      }
    }
  };

  // ========================================
  // DATA UTILITIES
  // ========================================
  JdrApp.utils.data = {
    // Find spell by name across all categories
    findSpell(name) {
      if (!window.SORTS) return null;
      
      for (const category of window.SORTS) {
        const spell = category.sorts.find(s => s.nom === name);
        if (spell) return { spell, category: category.nom };
      }
      return null;
    },
    
    // Find class by name
    findClass(name) {
      if (!window.CLASSES) return null;
      return window.CLASSES.find(c => c.nom === name);
    },
    
    // Find don by name across all categories
    findDon(name) {
      if (!window.DONS) return null;
      
      for (const category of window.DONS) {
        const don = category.dons.find(d => d.nom === name);
        if (don) return { don, category: category.nom };
      }
      return null;
    },
    
    // Get spell category by name
    getSpellCategory(categoryName) {
      if (!window.SORTS) return null;
      return window.SORTS.find(cat => cat.nom === categoryName);
    },
    
    // Get don category by name
    getDonCategory(categoryName) {
      if (!window.DONS) return null;
      return window.DONS.find(cat => cat.nom === categoryName);
    },
    
    // Deep clone object
    deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    },
    
    // Sanitize string for use as identifier
    sanitizeId(str) {
      return str.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    },
    
    // Generate unique ID
    generateId(prefix = 'id') {
      return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    },
    
    // Escape HTML
    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  };

  // ========================================
  // IMAGE UTILITIES
  // ========================================
  
  // Compress image function
  JdrApp.utils.compressImage = function(file, maxWidth = 800, quality = 0.85) {
    return new Promise((resolve, reject) => {
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      img.onload = function() {
        // Calculate new dimensions
        let { width, height } = img;
        
        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }
        
        // Set canvas size
        canvas.width = width;
        canvas.height = height;
        
        // Detect if image has transparency (PNG)
        const isPNG = file.type === 'image/png' || file.name.toLowerCase().endsWith('.png');
        
        if (isPNG) {
          // For PNG, don't compress at all to preserve quality
          resolve(file);
        } else {
          // For JPEG/other formats, use white background
          ctx.fillStyle = '#FFFFFF';
          ctx.fillRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);
          
          canvas.toBlob((blob) => {
            resolve(blob);
          }, 'image/jpeg', quality);
        }
      };
      
      img.onerror = (error) => {
        reject(error);
      };
      
      img.src = URL.createObjectURL(file);
    });
  };

  // Upload to ImageBB function
  JdrApp.utils.uploadToImageBB = function(file) {
    return new Promise((resolve, reject) => {
      // ImageBB API key
      const API_KEY = '06a98f5c0c2dad952e6ab94b03040f36';
      
      const formData = new FormData();
      formData.append('image', file);
      
      fetch(`https://api.imgbb.com/1/upload?key=${API_KEY}`, {
        method: 'POST',
        body: formData
      })
      .then(response => {
        return response.json();
      })
      .then(data => {
        if (data.success) {
          resolve(data.data.url);
        } else {
          throw new Error('Upload failed: ' + (data.error ? data.error.message : 'Unknown error'));
        }
      })
      .catch(error => {
        // Fallback to local storage
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    });
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - IMAGES MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // IMAGES MANAGEMENT MODULE
  // ========================================
  JdrApp.modules.images = {
    // Store for preloaded images
    imageStore: {},
    
    async init() {
      await this.loadImageData();
      this.initImageHandlers();
    },

    // Load image data from JSON file or embedded data
    async loadImageData() {
      try {
        if (window.IMAGES) {
          this.imageStore = window.IMAGES.images || window.IMAGES || {};
          return;
        }
        
        const response = await fetch('./data/images.json');
        if (response.ok) {
          const data = await response.json();
          this.imageStore = data.images || {};
        } else {
          this.imageStore = {};
        }
      } catch (error) {
        this.imageStore = {};
      }
    },

    // Get image URL for a given key
    getImageUrl(illusKey) {
      return this.imageStore[illusKey] || null;
    },

    // Apply image to an illustration element
    applyImage(illusElement, imageUrl) {
      if (!illusElement || !imageUrl) return;

      const img = illusElement.querySelector('img.thumb');
      if (!img) return;

      // Set image source and make it visible
      img.src = this.processImageUrl(imageUrl);
      img.style.display = 'inline-block';
      img.style.opacity = '1'; // Reset opacity after upload
      
      // Show remove button if it exists
      const removeBtn = illusElement.querySelector('.rm');
      if (removeBtn) {
        removeBtn.style.display = 'inline-flex';
      }

    },

    // Process image URL to handle proxying for mobile compatibility
    processImageUrl(originalUrl) {
      // If it's an i.ibb.co URL, use proxy for better mobile compatibility
      if (originalUrl.includes('i.ibb.co') && !originalUrl.includes('images.weserv.nl')) {
        return `https://images.weserv.nl/?url=${encodeURIComponent(originalUrl)}`;
      }
      return originalUrl;
    },

    autoLoadImages() {
      const illusElements = document.querySelectorAll('[data-illus-key]');
      let loadedCount = 0;

      illusElements.forEach(illusElement => {
        const illusKey = illusElement.dataset.illusKey;
        const imageUrl = this.getImageUrl(illusKey);
        
        if (imageUrl) {
          this.applyImage(illusElement, imageUrl);
          loadedCount++;
        }
      });

      return loadedCount;
    },

    // Initialize image upload handlers
    initImageHandlers() {
      // Delegate image upload handling
      document.addEventListener('change', (event) => {
        if (event.target.matches('.illus input[type="file"]')) {
          this.handleImageUpload(event.target);
        }
      });

      // Delegate image removal handling  
      document.addEventListener('click', (event) => {
        if (event.target.matches('.illus .rm')) {
          this.handleImageRemoval(event.target);
        }
      });
    },

    // Handle image upload
    async handleImageUpload(fileInput) {
      const file = fileInput.files[0];
      if (!file) return;

      const illusElement = fileInput.closest('.illus');
      if (!illusElement) return;

      const illusKey = illusElement.dataset.illusKey;
      
      try {
        // Show loading state
        const img = illusElement.querySelector('img.thumb');
        if (img) {
          img.style.opacity = '0.5';
        }

        // Compress and upload image
        const compressedFile = await JdrApp.utils.compressImage(file, 800, 0.8);
        const imageUrl = await JdrApp.utils.uploadToImageBB(compressedFile);
        
        // Apply the uploaded image
        this.applyImage(illusElement, imageUrl);
        
        // Update local store
        this.imageStore[illusKey] = imageUrl;
        
        
      } catch (error) {
        // Reset loading state
        const img = illusElement.querySelector('img.thumb');
        if (img) {
          img.style.opacity = '1';
        }
        
        alert('Erreur lors du téléchargement de l\'image. Veuillez réessayer.');
      }
      
      // Clear file input
      fileInput.value = '';
    },

    // Handle image removal
    handleImageRemoval(removeBtn) {
      const illusElement = removeBtn.closest('.illus');
      if (!illusElement) return;

      const illusKey = illusElement.dataset.illusKey;
      const img = illusElement.querySelector('img.thumb');
      
      if (img) {
        img.src = '';
        img.style.display = 'none';
      }
      
      removeBtn.style.display = 'none';
      
      // Remove from store
      delete this.imageStore[illusKey];
      
    },

    // Manually add/update an image
    setImage(illusKey, imageUrl) {
      this.imageStore[illusKey] = imageUrl;
      
      // Apply to any existing elements with this key
      const illusElements = document.querySelectorAll(`[data-illus-key="${illusKey}"]`);
      illusElements.forEach(element => {
        this.applyImage(element, imageUrl);
      });
    },

    // Get all current images for export
    getAllImages() {
      return { ...this.imageStore };
    },

    // Import images from external data
    importImages(imageData) {
      if (typeof imageData === 'object' && imageData !== null) {
        Object.assign(this.imageStore, imageData);
        this.autoLoadImages();
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - STORAGE MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // STORAGE MODULE
  // ========================================
  JdrApp.modules.storage = {
    
    init() {
      
      // Load stored edits immediately on startup
      this.loadStoredEdits();
      
      // Set up save handlers
      JdrApp.utils.events.register('click', '#saveAndExport', () => this.saveAndExportZip());
      
      // Set up force reload handler
      JdrApp.utils.events.register('click', '#forceReload', () => JdrApp.forceReloadData());
      
      
      // Auto-save functionality
      this.setupAutoSave();
    },

    setupAutoSave() {
      // Auto-save disabled - we save immediately on each edit instead
      // Previously: Auto-save every 30 seconds if in dev mode
    },

    saveChanges(silent = false) {
      try {
        // Force collect all pending edits
        const editedData = JdrApp.modules.editor.forceCollectAllEdits();
        
        // Save only current edits (not full data to avoid overwriting JSON changes)
        localStorage.setItem('jdr-bab-edits', JSON.stringify(editedData));
        localStorage.setItem('jdr-bab-last-modified', Date.now().toString());
        
        if (!silent) {
          this.showNotification('💾 Modifications sauvegardées localement', 'success');
        }
        
      } catch (error) {
        console.error('❌ Failed to save changes:', error);
        if (!silent) {
          this.showNotification('❌ Erreur lors de la sauvegarde', 'error');
        }
      }
    },

    async saveAndExportZip() {
      try {
        this.showNotification('📦 Création de l\'archive ZIP...', 'info');
        
        // Force collect all pending edits
        JdrApp.modules.editor.forceCollectAllEdits();
        
        // Check if JSZip is available
        if (typeof JSZip === 'undefined') {
          await this.loadJSZip();
        }
        
        const zip = new JSZip();
        
        // Add main HTML file
        const mainHTML = await this.getMainHTML();
        zip.file('index.html', mainHTML);
        
        // Add CSS files
        const cssFiles = ['theme.css', 'utilities.css', 'components.css', 'layout.css', 'editor.css'];
        for (const cssFile of cssFiles) {
          const cssContent = await this.fetchFileContent(`css/${cssFile}`);
          if (cssContent) {
            zip.file(`css/${cssFile}`, cssContent);
          }
        }
        
        // Add JS files
        const jsFiles = ['core.js', 'utils.js', 'router.js', 'renderer.js', 'editor.js', 'storage.js', 'ui.js'];
        for (const jsFile of jsFiles) {
          const jsContent = await this.fetchFileContent(`js/${jsFile}`);
          if (jsContent) {
            zip.file(`js/${jsFile}`, jsContent);
          }
        }
        
        // Add modules
        const moduleFiles = ['images.js'];
        for (const moduleFile of moduleFiles) {
          const moduleContent = await this.fetchFileContent(`js/modules/${moduleFile}`);
          if (moduleContent) {
            zip.file(`js/modules/${moduleFile}`, moduleContent);
          }
        }
        
        // Add data files with current edits
        zip.file('data/sorts.json', JSON.stringify(window.SORTS, null, 2));
        zip.file('data/classes.json', JSON.stringify(window.CLASSES, null, 2));
        zip.file('data/dons.json', JSON.stringify(window.DONS, null, 2));
        
        // Add static pages config and data
        if (window.STATIC_PAGES_CONFIG) {
          zip.file('data/static-pages-config.json', JSON.stringify(window.STATIC_PAGES_CONFIG, null, 2));
        }
        
        if (window.STATIC_PAGES) {
          for (const [pageId, pageData] of Object.entries(window.STATIC_PAGES)) {
            zip.file(`data/${pageId}.json`, JSON.stringify(pageData, null, 2));
          }
        }
        
        // Note: All static pages are now handled via window.STATIC_PAGES above
        
        // Add current images (including newly uploaded ones)
        if (JdrApp.modules.images && JdrApp.modules.images.getAllImages) {
          const currentImages = JdrApp.modules.images.getAllImages();
          const imagesData = {
            images: currentImages,
            meta: {
              total_images: Object.keys(currentImages).length,
              exported_date: new Date().toISOString().slice(0, 10),
              note: "Ces images incluent les nouvelles images uploadées"
            }
          };
          zip.file('data/images.json', JSON.stringify(imagesData, null, 2));
        }
        
        // Add package.json and other config files
        const configFiles = ['package.json'];
        for (const configFile of configFiles) {
          const configContent = await this.fetchFileContent(configFile);
          if (configContent) {
            zip.file(configFile, configContent);
          }
        }
        
        // Generate and download ZIP
        const zipBlob = await zip.generateAsync({type: 'blob'});
        const timestamp = new Date().toISOString().slice(0, 16).replace(/[:-]/g, '');
        this.downloadFile(`JdrBab-${timestamp}.zip`, zipBlob, 'application/zip');
        
        this.showNotification('📦 Archive ZIP créée et téléchargée!', 'success');
        
      } catch (error) {
        console.error('❌ Failed to create ZIP:', error);
        this.showNotification('❌ Erreur lors de la création du ZIP', 'error');
      }
    },

    async loadJSZip() {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    },

    async fetchFileContent(filePath) {
      try {
        const response = await fetch(filePath);
        if (response.ok) {
          return await response.text();
        }
        // Could not fetch file
        return null;
      } catch (error) {
        // Error fetching file
        return null;
      }
    },

    async getMainHTML() {
      // Get the current index.html content or reconstruct it
      try {
        const response = await fetch('index.html');
        if (response.ok) {
          return await response.text();
        }
      } catch (error) {
        // Could not fetch index.html, generating from current state
      }
      
      // Fallback: generate HTML from current document state
      return `<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta name="referrer" content="no-referrer-when-downgrade">
<title>JDR‑BAB — Livret de règles</title>
<meta content="Livret web multipages des règles JDR‑BAB, thème parchemin, illustrations par catégorie/classe/sous‑classe, export HTML autonome." name="description">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&amp;family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600&amp;display=swap" rel="stylesheet">

<!-- CSS Modulaire -->
<link rel="stylesheet" href="css/theme.css">
<link rel="stylesheet" href="css/utilities.css">
<link rel="stylesheet" href="css/components.css">
<link rel="stylesheet" href="css/layout.css">
<link rel="stylesheet" href="css/editor.css">
</head>
<body class="dev-off" style="">

<!-- Le contenu HTML complet sera injecté ici par le JavaScript -->
<div id="app-loading">Chargement...</div>

<!-- JavaScript Modulaire -->
<script src="js/core.js"></script>
<script src="js/utils.js"></script>
<script src="js/modules/images.js"></script>
<script src="js/router.js"></script>
<script src="js/renderer.js"></script>
<script src="js/editor.js"></script>
<script src="js/storage.js"></script>
<script src="js/ui.js"></script>

</body>
</html>`;
    },


    downloadJSON(filename, data) {
      const json = JSON.stringify(data, null, 2);
      this.downloadFile(filename, json, 'application/json');
    },

    downloadFile(filename, content, mimeType = 'text/html') {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.style.display = 'none';
      
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      URL.revokeObjectURL(url);
    },

    showNotification(message, type = 'info') {
      // Simple notification system
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${type === 'success' ? '#10B981' : type === 'error' ? '#EF4444' : '#3B82F6'};
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        font-weight: 500;
        z-index: 10000;
        animation: slideIn 0.3s ease;
      `;
      
      // Add animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      notification.textContent = message;
      document.body.appendChild(notification);
      
      // Auto-remove after 3 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    },

    // Load edits from localStorage on startup
    loadStoredEdits() {
      try {
        const storedEdits = localStorage.getItem('jdr-bab-edits');
        
        if (storedEdits) {
          JdrApp.modules.editor.editedData = JSON.parse(storedEdits);
        }
        
        // Ne plus charger jdr-bab-data - laisser les JSON être la source de vérité
        
      } catch (error) {
        // Failed to load stored edits
      }
    },

    // Handle ZIP file import
    async handleZipImport(event) {
      const file = event.target.files[0];
      if (!file || file.type !== 'application/zip') {
        this.showNotification('❌ Veuillez sélectionner un fichier ZIP', 'error');
        return;
      }

      try {
        this.showNotification('📥 Import en cours...', 'info');

        // Check if JSZip is available
        if (typeof JSZip === 'undefined') {
          await this.loadJSZip();
        }

        const zip = new JSZip();
        const contents = await zip.loadAsync(file);

        // Import data files
        const dataFiles = ['sorts.json', 'classes.json', 'dons.json'];
        for (const dataFile of dataFiles) {
          const zipFile = contents.file(`data/${dataFile}`);
          if (zipFile) {
            const content = await zipFile.async('text');
            const data = JSON.parse(content);
            
            if (dataFile === 'sorts.json') {
              window.SORTS = data;
            } else if (dataFile === 'classes.json') {
              window.CLASSES = data;
            } else if (dataFile === 'dons.json') {
              window.DONS = data;
            }
          }
        }

        // Import static pages config
        const configFile = contents.file('data/static-pages-config.json');
        if (configFile) {
          const configContent = await configFile.async('text');
          window.STATIC_PAGES_CONFIG = JSON.parse(configContent);
        }

        // Import static pages data
        if (window.STATIC_PAGES_CONFIG && window.STATIC_PAGES_CONFIG.pages) {
          window.STATIC_PAGES = {};
          for (const pageConfig of window.STATIC_PAGES_CONFIG.pages) {
            if (pageConfig.active) {
              const pageFile = contents.file(`data/${pageConfig.file}`);
              if (pageFile) {
                const pageContent = await pageFile.async('text');
                window.STATIC_PAGES[pageConfig.id] = JSON.parse(pageContent);
              }
            }
          }
        }

        // Import images
        const imagesFile = contents.file('data/images.json');
        if (imagesFile && JdrApp.modules.images && JdrApp.modules.images.importImages) {
          const imagesContent = await imagesFile.async('text');
          const imagesData = JSON.parse(imagesContent);
          if (imagesData.images) {
            JdrApp.modules.images.importImages(imagesData.images);
          }
        }

        // Save imported data to localStorage
        this.saveChanges(true);

        this.showNotification('✅ Import réussi! Rechargement...', 'success');

        // Reload page to show imported data
        setTimeout(() => {
          window.location.reload();
        }, 1000);

      } catch (error) {
        this.showNotification('❌ Erreur lors de l\'import', 'error');
      }

      // Reset file input
      event.target.value = '';
    },


  };

})();
// ============================================================================
// JDR-BAB APPLICATION - ROUTER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // ROUTING SYSTEM
  // ========================================
  JdrApp.modules.router = {
    currentRoute: '',
    
    init() {
      
      // Set up route change listeners
      JdrApp.utils.events.onHashChange(() => this.parseRoute());
      JdrApp.utils.events.onDOMReady(() => this.parseRoute());
      
      // Set up TOC click handlers
      JdrApp.utils.events.register('click', '.toc a', (e) => {
        e.preventDefault();
        const route = e.target.getAttribute('data-route');
        if (route) {
          this.navigate(route);
        }
      });

      // Set up category collapse/expand
      JdrApp.utils.events.register('click', '.toc-category > a', (e) => {
        e.preventDefault();
        const category = e.target.closest('.toc-category');
        if (category) {
          category.classList.toggle('collapsed');
        }
      });
    },
    
    parseRoute() {
      const hash = location.hash.replace('#/', '');
      const page = hash || 'creation';
      const exists = JdrApp.utils.dom.$(`article[data-page="${page}"]`);
      
      this.currentRoute = page;
      
      // Handle category routing
      if (page.startsWith('sorts-') && exists) {
        JdrApp.modules.renderer.renderSortCategory(page);
      }
      
      this.show(exists ? page : 'creation');
    },
    
    show(page) {
      document.querySelectorAll('article').forEach(a => a.classList.remove('active'));
      const target = document.querySelector(`article[data-page="${page}"]`);
      if (target) target.classList.add('active');
      
      document.querySelectorAll('.toc a').forEach(a => a.classList.remove('active'));
      const activeLink = document.querySelector(`a[href="#/${page}"]`);
      if (activeLink) activeLink.classList.add('active');
    },
    
    navigate(route) {
      location.hash = `#/${route}`;
    },
    
    getCurrentRoute() {
      return this.currentRoute;
    },
    
    // Generate table of contents based on data
    generateTOC() {
      const tocContainer = document.querySelector('#toc');
      if (!tocContainer) return;

      const tocHTML = `
        <h4>Sommaire</h4>
        <a class="" data-route="creation" href="#/creation">🧙‍♂️ Création d'un personnage</a>
        
        <div class="toc-category">
          <a data-route="classes" href="#/classes" class="">⚔️ Classes</a>
          <div class="toc-sub">
            ${window.CLASSES ? window.CLASSES.map(classe => 
              `<a data-route="${JdrApp.utils.data.sanitizeId(classe.nom)}" href="#/${JdrApp.utils.data.sanitizeId(classe.nom)}" class="">${this.getClassIcon(classe.nom)} ${classe.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <div class="toc-category">
          <a data-route="sorts" href="#/sorts">🔮 Sorts</a>
          <div class="toc-sub">
            ${window.SORTS ? window.SORTS.map(category => 
              `<a data-route="sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getSortCategoryIcon(category.nom)} ${category.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <div class="toc-category">
          <a data-route="dons" href="#/dons" class="">🎖️ Dons</a>
          <div class="toc-sub">
            ${window.DONS ? window.DONS.map(category => 
              `<a data-route="dons-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/dons-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getDonCategoryIcon(category.nom)} ${category.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <a data-route="elements" href="#/elements" class="">🌟 Éléments</a>
        <a data-route="stats" href="#/stats" class="">📊 Statistiques</a>
        <a data-route="competences-tests" href="#/competences-tests" class="">🎯 Compétences & Tests</a>
        <a data-route="etats" href="#/etats" class="">⚡ Etats</a>
      `;
      
      tocContainer.innerHTML = tocHTML;
    },
    
    getClassIcon(className) {
      const icons = {
        'Guerrier': '🗡️',
        'Mage': '🔮',
        'Prêtre': '⛪',
        'Rôdeur': '🏃',
        'Enchanteur': '✨'
      };
      return icons[className] || '⚔️';
    },
    
    getSortCategoryIcon(categoryName) {
      const icons = {
        'Sorts de Mage': '🔮',
        'Sorts de Prêtre': '⛪',
        'Sorts d\'Enchanteur': '✨',
        'Sorts de Monstres': '💀'
      };
      return icons[categoryName] || '🔮';
    },
    
    getDonCategoryIcon(categoryName) {
      const icons = {
        'Guerrier': '🗡️',
        'Mage': '🔮',
        'Prêtre': '⛪',
        'Rôdeur': '🏃',
        'Enchanteur': '✨',
        'Généraux': '🎖️'
      };
      return icons[categoryName] || '🎖️';
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - RENDERER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // CONTENT RENDERER MODULE
  // ========================================
  JdrApp.modules.renderer = {
    // Current search and filter state
    currentSearch: '',
    
    // Helper to check if we should render editing buttons
    shouldRenderEditButtons() {
      return !window.STANDALONE_VERSION;
    },
    
    init() {
      this.generateContent();
      this.autoLoadImages();
    },

    generateContent() {
      JdrApp.modules.router.generateTOC();
      this.generateArticles();
      this.generateDevToolbox();
      
      // Show/hide edit buttons based on dev mode state
      if (JdrApp.modules.editor) {
        setTimeout(() => {
          if (JdrApp.modules.editor.isDevMode) {
            JdrApp.modules.editor.forceShowAllEditButtons();
          } else {
            JdrApp.modules.editor.forceHideAllEditButtons();
          }
        }, 100);
      }
    },

    generateArticles() {
      const viewsContainer = document.querySelector('#views');
      if (!viewsContainer) return;

      let articlesHTML = '';
      articlesHTML += this.generateCreationPage();
      
      articlesHTML += this.generateElementsPage();
      articlesHTML += this.generateStatsPage();
      articlesHTML += this.generateCompetencesPage();
      articlesHTML += this.generateEtatsPage();

      if (window.CLASSES) {
        window.CLASSES.forEach(classe => {
          articlesHTML += this.generateClassPage(classe);
        });
      }

      if (window.SORTS) {
        window.SORTS.forEach(category => {
          articlesHTML += this.generateSortCategoryPage(category);
        });
      }

      if (window.DONS) {
        window.DONS.forEach(category => {
          articlesHTML += this.generateDonCategoryPage(category);
        });
      }

      viewsContainer.innerHTML = articlesHTML;
      setTimeout(() => this.autoLoadImages(), 100);
    },

    generateCreationPage() {
      return this.generateStaticPage('creation');
    },

    generateClassPage(classe) {
      const pageId = JdrApp.utils.data.sanitizeId(classe.nom);
      
      return `
        <article class="" data-page="${pageId}" data-page-title="${classe.nom}">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2 class="editable editable-title" data-edit-type="class-name" data-edit-section="${classe.nom}">${classe.nom}</h2>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-title-btn" title="Éditer le nom de la classe">✏️</button>' : ''}
              ${this.createIllustration(`class:${classe.nom}`)}
            </div>
            
            <div class="editable-section" data-section-type="class-resume">
              <p class="lead editable editable-paragraph" data-edit-type="class-resume" data-edit-section="${classe.nom}">${classe.resume}</p>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-paragraph-btn" title="Éditer la description de la classe">✏️</button>' : ''}
            </div>
            
            <h3>Capacités de classe</h3>
            <div class="editable-section editable-list-container" data-section-type="class-capacites">
              <ul class="editable editable-list" data-edit-type="class-capacites" data-edit-section="${classe.nom}">
                ${classe.capacites.map(cap => `<li>${cap}</li>`).join('')}
              </ul>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-list-btn" title="Éditer les capacités de classe">✏️</button>' : ''}
            </div>
            
            <h3>Sous-classes</h3>
            <div class="subclass-stack">
              ${classe.sousClasses.map(sousClasse => this.generateSubClassCard(classe.nom, sousClasse)).join('')}
            </div>
            ${this.shouldRenderEditButtons() ? '<div class="add-subclass-btn">➕ Ajouter une sous-classe</div>' : ''}
          </section>
        </article>
      `;
    },

    generateSubClassCard(className, sousClasse) {
      return `
        <div class="card editable-section" data-section-type="subclass" data-class-name="${className}" data-subclass-name="${sousClasse.nom}">
          <div class="editable-section" data-section-type="subclass-name">
            <h4 class="editable editable-title subclass-title" data-edit-type="subclass-name" data-edit-section="${className}-${sousClasse.nom}">${sousClasse.nom}</h4>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-title-btn" title="Éditer le nom de la sous-classe">✏️</button>' : ''}
          </div>
          
          ${this.createSubclassIllustrations(className, sousClasse.nom)}
          
          <div class="editable-section" data-section-type="subclass-stats">
            <div class="editable editable-stats" data-edit-type="subclass-stats" data-edit-section="${className}-${sousClasse.nom}">
              <div class="chips">
                ${Object.entries(sousClasse.base).map(([stat, value]) => {
                  const statIcons = {
                    'Force': '💪',
                    'Agilité': '🏃',
                    'Endurance': '🛡️',
                    'Intelligence': '🧠',
                    'Volonté': '⚡',
                    'Chance': '🍀'
                  };
                  const icon = statIcons[stat] || '⚡';
                  return `<span class="chip">${icon} ${stat}: <strong>${value}</strong></span>`;
                }).join('')}
              </div>
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-stats-btn" title="Éditer les statistiques de base">✏️</button>' : ''}
          </div>
          
          <div class="editable-section" data-section-type="subclass-progression">
            <div class="editable editable-field" data-edit-type="subclass-progression" data-edit-section="${className}-${sousClasse.nom}">
              ${sousClasse.progression}
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-field-btn" title="Éditer la progression par niveau">✏️</button>' : ''}
          </div>
          
          <h5>Capacités</h5>
          <div class="editable-section editable-list-container" data-section-type="subclass-capacites">
            <ul class="editable editable-list" data-edit-type="subclass-capacites" data-edit-section="${className}-${sousClasse.nom}">
              ${sousClasse.capacites.map(cap => `<li>${cap}</li>`).join('')}
            </ul>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-list-btn" title="Éditer les capacités">✏️</button>' : ''}
          </div>
          
          ${this.shouldRenderEditButtons() ? '<button class="delete-subclass-btn" title="Supprimer cette sous-classe" data-class-name="' + className + '" data-subclass-name="' + sousClasse.nom + '">🗑️ Supprimer</button>' : ''}
        </div>
      `;
    },

    generateSortCategoryPage(category) {
      const pageId = `sorts-${JdrApp.utils.data.sanitizeId(category.nom)}`;
      
      return `
        <article class="" data-page="${pageId}">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2 class="editable editable-title" data-edit-type="spell-category-name" data-edit-section="${category.nom}">${category.nom}</h2>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-title-btn" title="Éditer le nom de la catégorie">✏️</button>' : ''}
              ${this.createIllustration(`spellcategory:${category.nom}`)}
            </div>
            
            <div class="editable-section" data-section-type="spell-category-description">
              <p class="lead editable editable-paragraph" data-edit-type="spell-category-description" data-edit-section="${category.nom}">${category.description}</p>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-paragraph-btn" title="Éditer la description de la catégorie">✏️</button>' : ''}
            </div>
            
            ${this.shouldRenderEditButtons() ? `<button class="spell-add" data-category-name="${category.nom}" type="button">➕ Ajouter un sort</button>` : ''}
            
            <div class="grid cols-2">
              ${category.sorts.map((sort, index) => this.generateSpellCard(category, sort, index)).join('')}
            </div>
          </section>
        </article>
      `;
    },

    generateSpellCard(category, sort, index) {
      return `
        <div class="card editable-section" data-section-type="spell" data-spell-name="${sort.nom}" data-category-name="${category.nom}">
          <div class="editable-section" data-section-type="spell-name">
            <h4 style="margin: 0 0 1rem 0; text-align: center;" class="editable editable-title" data-edit-type="spell-name" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}">${sort.nom}</h4>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-title-btn" title="Éditer le nom du sort">✏️</button>' : ''}
          </div>
          
          ${this.createIllustration(`sort:${category.nom}:${sort.nom}`, sort.nom)}
          
          <div class="editable-section" data-section-type="spell-description">
            <p class="muted editable editable-paragraph" data-edit-type="spell-description" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}" style="margin: 0 0 1rem 0; text-align: center;">${sort.description}</p>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-paragraph-btn" title="Éditer la description">✏️</button>' : ''}
          </div>
          
          <div class="editable-section" data-section-type="spell-prerequis">
            <div class="editable editable-field" data-edit-type="spell-prerequis" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}">
              ${sort.prerequis}
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-field-btn" title="Éditer les prérequis">✏️</button>' : ''}
          </div>
          
          <div class="editable-section" data-section-type="spell-portee">
            <div class="editable editable-field" data-edit-type="spell-portee" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}">
              ${sort.portee}
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-field-btn" title="Éditer la portée">✏️</button>' : ''}
          </div>
          
          <div class="editable-section" data-section-type="spell-mana">
            <div class="editable editable-field" data-edit-type="spell-mana" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}">
              ${sort.coutMana}
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-field-btn" title="Éditer le coût mana">✏️</button>' : ''}
          </div>

          <div class="editable-section" data-section-type="spell-temps-incantation">
            <div class="editable editable-field" data-edit-type="spell-temps-incantation" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}">
              ${sort.tempsIncantation}
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-field-btn" title="Éditer le temps d\'incantation">✏️</button>' : ''}
          </div>
          
          <hr style="margin: 0.5rem 0; border: none; border-top: 1px solid var(--rule);">
          
          <div class="editable-section" data-section-type="spell-resistance">
            <div class="editable editable-field" data-edit-type="spell-resistance" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}">
              ${sort.resistance}
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-field-btn" title="Éditer la résistance">✏️</button>' : ''}
          </div>
          
          <div class="editable-section" data-section-type="spell-effect-normal">
            <div class="editable editable-effect" data-edit-type="spell-effect-normal" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}" style="margin: 1rem 0;">
              ${sort.effetNormal}
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-effect-btn" title="Éditer l\'effet normal">✏️</button>' : ''}
          </div>
          
          <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
          
          ${sort.effetCritique ? `
            <div class="editable-section" data-section-type="spell-effect-critical">
              <div class="editable editable-effect" data-edit-type="spell-effect-critical" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}" style="margin: 1rem 0;">
                ${sort.effetCritique}
              </div>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-effect-btn" title="Éditer l\'effet critique">✏️</button>' : ''}
            </div>
          ` : ''}
          
          ${sort.effetEchec ? `
            <div class="editable-section" data-section-type="spell-effect-failure">
              <div class="editable editable-effect" data-edit-type="spell-effect-failure" data-edit-spell="${sort.nom}" data-edit-section="${sort.nom}" style="margin: 1rem 0;">
                ${sort.effetEchec}
              </div>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-effect-btn" title="Éditer l\'effet d\'échec">✏️</button>' : ''}
            </div>
          ` : ''}
          
          ${this.shouldRenderEditButtons() ? `<button class="spell-delete btn small" data-category-name="${category.nom}" data-spell-name="${sort.nom}" type="button" style="background: #ff6b6b; color: white; margin-top: 8px;">🗑 Supprimer</button>` : ''}
        </div>
      `;
    },

    generateDonCategoryPage(category) {
      const pageId = `dons-${JdrApp.utils.data.sanitizeId(category.nom)}`;
      
      return `
        <article class="" data-page="${pageId}">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2 class="editable editable-title" data-edit-type="don-category-name" data-edit-section="${category.nom}">${category.nom}</h2>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-title-btn" title="Éditer le nom de la catégorie">✏️</button>' : ''}
              ${this.createIllustration(`doncategory:${category.nom}`)}
            </div>
            
            <div class="editable-section" data-section-type="don-category-description">
              <p class="lead editable editable-paragraph" data-edit-type="don-category-description" data-edit-section="${category.nom}">${category.description}</p>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-paragraph-btn" title="Éditer la description de la catégorie">✏️</button>' : ''}
            </div>
            
            ${this.shouldRenderEditButtons() ? `<button class="don-add" data-category-name="${category.nom}" type="button">➕ Ajouter un don</button>` : ''}
            
            <div class="grid cols-2">
              ${category.dons.map((don, index) => this.generateDonCard(category, don, index)).join('')}
            </div>
          </section>
        </article>
      `;
    },

    generateDonCard(category, don, index) {
      return `
        <div class="card editable-section" data-section-type="don" data-don-name="${don.nom}" data-category-name="${category.nom}">
          <div class="editable-section" data-section-type="don-name">
            <h4 style="margin: 0 0 1rem 0; text-align: center;" class="editable editable-title" data-edit-type="don-name" data-edit-section="${don.nom}">${don.nom}</h4>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-title-btn" title="Éditer le nom du don">✏️</button>' : ''}
          </div>
          
          ${this.createIllustration(`don:${don.nom}`, don.nom)}
          
          <div class="editable-section" data-section-type="don-description">
            <p class="editable editable-paragraph" data-edit-type="don-description" data-edit-section="${don.nom}">${don.description}</p>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-paragraph-btn" title="Éditer la description">✏️</button>' : ''}
          </div>
          
          <div class="editable-section" data-section-type="don-prerequis">
            <div class="editable editable-field" data-edit-type="don-prerequis" data-edit-section="${don.nom}">
              ${don.prerequis}
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-field-btn" title="Éditer les prérequis">✏️</button>' : ''}
          </div>
          
          <div class="editable-section" data-section-type="don-cout">
            <div class="editable editable-field" data-edit-type="don-cout" data-edit-section="${don.nom}" style="color: var(--bronze); font-weight: 600;">
              ${don.cout}
            </div>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-field-btn" title="Éditer le coût">✏️</button>' : ''}
          </div>
          
          ${this.shouldRenderEditButtons() ? `
          <div style="display: flex; gap: 4px; margin-top: 8px; flex-wrap: wrap;">
            <button class="don-delete btn small" data-category-name="${category.nom}" data-don-name="${don.nom}" style="background: #ff6b6b; color: white;">🗑 Supprimer</button>
            <button class="don-move-up btn small" data-category-name="${category.nom}" data-don-name="${don.nom}" data-don-index="${index}" style="background: var(--bronze); color: white;" ${index === 0 ? 'disabled' : ''}>⬆️ Haut</button>
            <button class="don-move-down btn small" data-category-name="${category.nom}" data-don-name="${don.nom}" data-don-index="${index}" style="background: var(--bronze); color: white;" ${index === category.dons.length - 1 ? 'disabled' : ''}>⬇️ Bas</button>
          </div>
          ` : ''}
        </div>
      `;
    },

    // Generic method to generate static pages from JSON data
    generateStaticPage(pageId) {
      if (!window.STATIC_PAGES || !window.STATIC_PAGES[pageId]) {
        return '';
      }

      const pageData = window.STATIC_PAGES[pageId];
      const isActive = pageId === 'creation' ? 'active' : '';
      
      return `
        <article class="${isActive}" data-page="${pageData.page}" data-static-page="true" data-page-title="${pageData.title}">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2 class="editable editable-title" data-edit-type="page-title" data-edit-section="${pageData.page}">${pageData.title}</h2>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-title-btn" title="Éditer le titre de la page">✏️</button>' : ''}
              ${this.createIllustration(`page:${pageData.page}`)}
            </div>
            ${this.renderSections(pageData.sections)}
            ${this.shouldRenderEditButtons() ? '<div class="add-paragraph-btn" data-target="section">➕ Ajouter une nouvelle section</div>' : ''}
          </section>
        </article>
      `;
    },

    // Helper method to render sections from JSON data
    renderSections(sections) {
      return sections.map((section, sectionIndex) => {
        switch (section.type) {
          case 'intro':
            return `
              <div class="editable-section" data-section-type="intro" data-section-index="${sectionIndex}">
                <p class="editable editable-intro" data-edit-type="intro" data-edit-section="intro">${section.content}</p>
                ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-section-btn" title="Éditer cette introduction">✏️</button>' : ''}
              </div>
              ${this.shouldRenderEditButtons() ? '<div class="add-paragraph-btn" data-target="intro">➕ Ajouter un paragraphe ici</div>' : ''}
            `;
          
          case 'card':
            return this.renderCard(section, sectionIndex);
          
          case 'grid':
            return this.renderGrid(section, sectionIndex);
          
          default:
            return `<div><!-- Unknown section type: ${section.type} --></div>`;
        }
      }).join('');
    },

    // Helper method to render a card section
    renderCard(cardData, sectionIndex) {
      let cardHTML = `<div class="card editable-section" data-section-type="card" data-section-index="${sectionIndex}">`;
      
      if (cardData.deletable && cardData.sectionType) {
        cardHTML += `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="card-title" data-edit-section="${cardData.sectionType}-title">${cardData.title}</h3>
            ${this.shouldRenderEditButtons() ? `<button class="edit-btn edit-title-btn" title="Éditer le titre">✏️</button>` : ''}
            ${this.shouldRenderEditButtons() ? `<button class="remove-section-btn" data-section-type="${cardData.sectionType}" type="button" style="background: #dc2626; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 12px;">🗑 Supprimer section</button>` : ''}
          </div>
        `;
      } else {
        cardHTML += `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="card-title" data-edit-section="card-${sectionIndex}">${cardData.title}</h3>
            ${this.shouldRenderEditButtons() ? `<button class="edit-btn edit-title-btn" title="Éditer le titre">✏️</button>` : ''}
          </div>
        `;
      }

      // Handle different content types
      if (Array.isArray(cardData.content)) {
        cardHTML += cardData.content.map(item => this.renderContentItem(item)).join('');
      } else if (typeof cardData.content === 'object') {
        cardHTML += this.renderComplexContent(cardData.content);
      } else {
        cardHTML += `<div>${cardData.content}</div>`;
      }

      if (cardData.deletable && cardData.sectionName && this.shouldRenderEditButtons()) {
        cardHTML += `
          <div style="margin-top: 1rem; text-align: center;">
            <button class="section-delete btn small" data-section-name="${cardData.sectionName}" type="button" style="background: #ff6b6b; color: white;">🗑 Supprimer section</button>
          </div>
        `;
      }
      
      cardHTML += `</div>`; // Close the card div!
      return cardHTML;
    },

    // Helper method to render content items
    renderContentItem(item) {
      if (item.type === 'paragraph') {
        const content = `
          <div class="editable-section" data-section-type="paragraph">
            <p class="editable editable-paragraph" data-edit-type="paragraph" data-edit-section="${item.editSection}">${item.content}</p>
            ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-paragraph-btn" title="Éditer ce paragraphe">✏️</button>' : ''}
          </div>
        `;
        const addBtn = this.shouldRenderEditButtons() ? `<div class="add-paragraph-btn" data-target="${item.editSection}">➕ Ajouter un paragraphe</div>` : '';
        return content + addBtn;
      }
      return `<div>${item.content}</div>`;
    },

    // Helper method to render complex content (lists, grids, etc.)
    renderComplexContent(content) {
      switch (content.type) {
        case 'ordered_list':
          return `
            <div class="editable-section editable-list-container" data-section-type="ordered_list">
              <ol class="editable editable-list" data-edit-type="ordered-list" data-edit-section="${content.editType}">
                ${content.items.map(item => `<li>${item}</li>`).join('')}
              </ol>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-list-btn" title="Éditer cette liste complète">✏️</button>' : ''}
            </div>
            ${this.shouldRenderEditButtons() ? '<div class="add-paragraph-btn" data-target="creation-steps">➕ Ajouter un paragraphe</div>' : ''}
          `;
        
        case 'list':
          return `
            <div class="editable-section editable-list-container" data-section-type="list">
              <ul class="editable editable-list" data-edit-type="list" data-edit-section="${content.editType}">
                ${content.items.map(item => `<li>${item}</li>`).join('')}
              </ul>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-list-btn" title="Éditer cette liste complète">✏️</button>' : ''}
            </div>
            ${this.shouldRenderEditButtons() ? `<div class="add-paragraph-btn" data-target="${content.editType}">➕ Ajouter un paragraphe</div>` : ''}
          `;
        
        case 'element_pairs':
          return this.renderElementPairs(content.pairs);
        
        case 'grid':
          return this.renderGrid(content);
        
        default:
          return `<div><!-- Unknown content type: ${content.type} --></div>`;
      }
    },

    // Helper method to render element pairs
    renderElementPairs(pairs) {
      return `
        <div class="pairs">
          ${pairs.map(pair => `
            <div class="cell">
              <svg aria-hidden="true" class="eico" viewBox="0 0 24 24">
                <circle cx="12" cy="12" fill="${pair.element1.color}" r="9"></circle>
              </svg>
              <span><span style="color: ${pair.element1.color}; font-weight: bold;${pair.element1.textShadow ? ` text-shadow: ${pair.element1.textShadow};` : ''}">${pair.element1.name}</span></span>
            </div>
            <div class="vs">⇆</div>
            <div class="cell right">
              <svg aria-hidden="true" class="eico" viewBox="0 0 24 24">
                <circle cx="12" cy="12" fill="${pair.element2.color}" r="9"></circle>
              </svg>
              <span><span style="color: ${pair.element2.color}; font-weight: bold;${pair.element2.textShadow ? ` text-shadow: ${pair.element2.textShadow};` : ''}">${pair.element2.name}</span></span>
            </div>
          `).join('')}
        </div>
      `;
    },

    // Helper method to render grids
    renderGrid(gridData) {
      return `
        <div class="grid cols-${gridData.cols}">
          ${gridData.content ? gridData.content.map(item => this.renderCard(item)).join('') : 
            gridData.items ? gridData.items.map(item => this.renderCard(item)).join('') : ''}
        </div>
      `;
    },

    generateElementsPage() {
      return this.generateStaticPage('elements');
    },

    generateStatsPage() {
      return this.generateStaticPage('stats');
    },

    generateCompetencesPage() {
      return this.generateStaticPage('competences-tests');
    },

    generateEtatsPage() {
      return this.generateStaticPage('etats');
    },


    generateDevToolbox() {
      const devToolbox = JdrApp.utils.dom.$('#devToolbox');
      if (!devToolbox) return;

      const toolboxHTML = `
        <!-- En-tête de la toolbox -->
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--rule);">
          <span style="font-size: 18px;">🛠</span>
          <strong style="color: var(--accent-ink); font-family: 'Cinzel', serif;">Outils de développement</strong>
        </div>
        
        <!-- Groupe : Édition et sauvegarde -->
        <div style="margin-bottom: 12px;">
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">✏️ Édition</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="saveAndExport" title="Sauvegarder et exporter tout en ZIP">💾 Export ZIP</button>
            <button class="btn small" id="forceReload" title="Recharger les données JSON (efface le cache)">🔄 Recharger JSON</button>
          </div>
        </div>
        
        <!-- Groupe : Création de contenu -->
        <div style="margin-bottom: 12px;">
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">📝 Création</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="addCategory" title="Créer une nouvelle catégorie/page">📄 Nouvelle page</button>
            <button class="btn small" id="addSpellCategory" title="Créer une nouvelle catégorie de sorts">🔮 Catégorie de sorts</button>
            <button class="btn small" id="addDonCategory" title="Créer une nouvelle catégorie de dons">🎖️ Catégorie de dons</button>
          </div>
        </div>
        
        <!-- Groupe : Ressources -->
        <div>
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">🎭 Ressources</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="elementsBtn" title="Choisir un élément pour copier sa balise HTML colorée">🎨 Éléments</button>
            <button class="btn small" id="showIcons" title="Afficher la liste des icônes disponibles">🔥 Icônes</button>
          </div>
        </div>
      `;

      devToolbox.innerHTML = toolboxHTML;
    },

    // General image renderer with style options
    renderImage(illusKey, options = {}) {
      const {
        altText = '',
        styleType = 'default', // 'spell', 'class', 'subclass', 'don', 'default'
        size = 'medium', // 'small', 'medium', 'large'
        frame = true
      } = options;

      // Check if image is available in images module
      let imageUrl = '';
      let imageStyle = 'display: none;';
      let removeStyle = 'display: none;';
      
      if (JdrApp.modules.images && JdrApp.modules.images.getImageUrl) {
        imageUrl = JdrApp.modules.images.getImageUrl(illusKey);
        if (imageUrl) {
          imageUrl = JdrApp.modules.images.processImageUrl(imageUrl);
          imageStyle = 'display: inline-block;';
          removeStyle = 'display: inline-flex;';
        }
      }

      // Build CSS classes based on style type
      let containerClasses = 'illus';
      let imageClasses = 'thumb';
      
      if (frame && ['spell', 'class', 'subclass', 'don'].includes(styleType)) {
        containerClasses += ` illus-${styleType}`;
      }
      
      if (size !== 'medium') {
        containerClasses += ` illus-${size}`;
      }

      // In standalone version, don't render editing buttons
      if (window.STANDALONE_VERSION) {
        return `
          <div class="${containerClasses}" data-illus-key="${illusKey}" data-style-type="${styleType}" data-bound="1">
            <img alt="Illustration ${altText}" class="${imageClasses}" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
          </div>
        `;
      }
      
      return `
        <div class="${containerClasses}" data-illus-key="${illusKey}" data-style-type="${styleType}" data-bound="1">
          <img alt="Illustration ${altText}" class="${imageClasses}" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
          <label class="up">📷 Ajouter<input accept="image/*" hidden="" type="file"></label>
          <button class="rm" type="button" style="${removeStyle}">🗑 Retirer</button>
        </div>
      `;
    },

    // Simplified wrapper for backward compatibility
    createIllustration(illusKey, altText = '') {
      // Determine style type from illus key
      let styleType = 'default';
      if (illusKey.startsWith('spell:') || illusKey.startsWith('sort:')) styleType = 'spell';
      else if (illusKey.startsWith('class:')) styleType = 'class';
      else if (illusKey.startsWith('subclass:')) styleType = 'subclass';
      else if (illusKey.startsWith('don:')) styleType = 'don';
      
      return this.renderImage(illusKey, { altText, styleType });
    },

    createSubclassIllustrations(className, subclassName) {
      const illusKey1 = `subclass:${className}:${subclassName}:1`;
      const illusKey2 = `subclass:${className}:${subclassName}:2`;
      
      return `
        <div class="subclass-images">
          ${this.renderImage(illusKey1, { altText: `${subclassName} (Image 1)`, styleType: 'subclass' })}
          ${this.renderImage(illusKey2, { altText: `${subclassName} (Image 2)`, styleType: 'subclass' })}
        </div>
      `;
    },

    // Simplified dynamic rendering
    renderSortCategory(page) {
      const categoryId = page.replace('sorts-', '');
      const category = window.SORTS?.find(cat => 
        JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
      );
      
      if (!category) {
        return;
      }
      
      const article = document.querySelector(`article[data-page="${page}"]`);
      if (!article) {
        return;
      }
      
      // Generate content directly
      const content = `
        <section>
          <header>
            <h1>${category.nom}</h1>
            <div class="hero-illus">
              ${this.createIllustration(`spellcategory:${category.nom}`)}
            </div>
            
            <div class="editable-section" data-section-type="spell-category-description">
              <p class="lead editable editable-paragraph" data-edit-type="spell-category-description" data-edit-section="${category.nom}">${category.description}</p>
              ${this.shouldRenderEditButtons() ? '<button class="edit-btn edit-paragraph-btn" title="Éditer la description de la catégorie">✏️</button>' : ''}
            </div>
            
            ${this.shouldRenderEditButtons() ? `<button class="spell-add" data-category-name="${category.nom}" type="button">➕ Ajouter un sort</button>` : ''}
          </header>
          
          <div class="grid cols-2">
            ${category.sorts.map((sort, index) => this.generateSpellCard(category, sort, index)).join('')}
          </div>
        </section>
      `;
      
      article.innerHTML = content;
    },




    // Auto-load images for all illustration slots
    autoLoadImages() {
      // Use images module if available
      if (JdrApp.modules.images) {
        return JdrApp.modules.images.autoLoadImages();
      }
      return 0;
    },

  };

})();
// ============================================================================
// JDR-BAB APPLICATION - EDITOR MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // EDITOR MODULE
  // ========================================
  JdrApp.modules.editor = {
    editedData: {},
    modifiedElements: new Map(), // Track what was actually modified
    isDevMode: false, // Always false by default, no localStorage read

    init() {
      
      // Set up dev mode toggle
      JdrApp.utils.events.register('click', '#devToggle', () => this.toggleDevMode());
      
      // Set up editable element handlers
      this.setupEditableHandlers();
      
      // Set up creation handlers for new elements
      this.setupCreationHandlers();
      
      // Set up image upload handlers
      this.setupImageHandlers();
      
      // Initialize dev mode state - enable automatically in development
      this.updateDevModeState();
    },

    toggleDevMode() {
      // In standalone version, prevent dev mode toggle
      if (window.STANDALONE_VERSION) {
        return;
      }
      
      this.isDevMode = !this.isDevMode;
      document.body.classList.toggle('dev-on', this.isDevMode);
      document.body.classList.toggle('dev-off', !this.isDevMode);
      
      // Note: No localStorage save - dev mode resets on page reload
      this.updateDevModeState();
    },

    updateDevModeState() {
      if (window.STANDALONE_VERSION) {
        document.body.className = 'dev-off';
        this.forceHideAllEditButtons();
        return;
      }
      
      // Apply correct body classes
      document.body.classList.toggle('dev-on', this.isDevMode);
      document.body.classList.toggle('dev-off', !this.isDevMode);
      
      const devToggle = document.querySelector('#devToggle');
      const devToolbox = document.querySelector('#devToolbox');
      
      if (devToggle) {
        devToggle.textContent = `🛠 Dev Mode: ${this.isDevMode ? 'ON' : 'OFF'}`;
      }
      
      if (devToolbox) {
        devToolbox.style.display = this.isDevMode ? 'block' : 'none';
      }
      
      // Show/hide edit buttons based on dev mode state
      if (this.isDevMode) {
        this.forceShowAllEditButtons();
      } else {
        this.forceHideAllEditButtons();
      }
    },
    
    forceHideAllEditButtons() {
      // Only hide buttons if dev mode is actually OFF
      if (this.isDevMode || window.STANDALONE_VERSION === false) {
        return; // Don't hide buttons in dev mode ON
      }
      
      // Aggressively hide ALL edit buttons using JavaScript when dev mode is OFF
      const editButtonSelectors = [
        '.edit-btn',
        '.edit-title-btn', 
        '.edit-paragraph-btn',
        '.edit-list-btn',
        '.edit-field-btn',
        '.edit-effect-btn',
        '.edit-stats-btn',
        '.edit-section-btn',
        'button[class*="edit"]',
        'button[title*="✏️"]',
        'button[title*="diter"]',
        'button[title*="Edit"]',
        '.spell-add',
        '.don-add',
        '.spell-delete',
        '.don-delete',
        '.don-move-up',
        '.don-move-down',
        '.section-delete',
        '.remove-section-btn',
        '.add-paragraph-btn',
        '.add-subclass-btn',
        '.delete-subclass-btn',
        'button[data-category-name]',
        'button[data-spell-name]',
        'button[data-don-name]',
        'button[data-section-name]',
        'button[data-section-type]',
        '.illus .up',
        '.illus .rm',
        '.illus label',
        '.illus input[type="file"]'
      ];
      
      editButtonSelectors.forEach(selector => {
        try {
          const elements = document.querySelectorAll(selector);
          elements.forEach(element => {
            element.style.display = 'none';
            element.style.visibility = 'hidden';
            element.style.opacity = '0';
            element.style.pointerEvents = 'none';
            element.setAttribute('aria-hidden', 'true');
          });
        } catch (error) {
          // Silently handle selector errors
        }
      });
    },
    
    forceShowAllEditButtons() {
      // Show edit buttons when dev mode is ON
      const editButtonSelectors = [
        '.edit-btn',
        '.edit-title-btn', 
        '.edit-paragraph-btn',
        '.edit-list-btn',
        '.edit-field-btn',
        '.edit-effect-btn',
        '.edit-stats-btn',
        '.edit-section-btn',
        'button[class*="edit"]',
        'button[title*="✏️"]',
        'button[title*="diter"]',
        'button[title*="Edit"]',
        '.spell-add',
        '.don-add',
        '.spell-delete',
        '.don-delete',
        '.don-move-up',
        '.don-move-down',
        '.section-delete',
        '.remove-section-btn',
        '.add-paragraph-btn',
        '.add-subclass-btn',
        '.delete-subclass-btn',
        'button[data-category-name]',
        'button[data-spell-name]',
        'button[data-don-name]',
        'button[data-section-name]',
        'button[data-section-type]',
        '.illus .up',
        '.illus .rm',
        '.illus label',
        '.illus input[type="file"]'
      ];
      
      editButtonSelectors.forEach(selector => {
        try {
          const elements = document.querySelectorAll(selector);
          elements.forEach(element => {
            element.style.display = '';
            element.style.visibility = '';
            element.style.opacity = '';
            element.style.pointerEvents = '';
            element.removeAttribute('aria-hidden');
          });
        } catch (error) {
          // Silently handle selector errors
        }
      });
    },

    setupEditableHandlers() {
      // Edit button click
      JdrApp.utils.events.register('click', '.edit-btn', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!this.isDevMode) {
          return;
        }
        
        // Find the parent editable section
        const editableSection = e.target.closest('.editable-section');
        if (editableSection) {
          this.makeEditableSection(editableSection);
          return;
        }
        
        // Fallback: Find the parent list item (legacy support)
        const listItem = e.target.closest('.editable-item');
        if (listItem) {
          this.makeEditableItem(listItem);
          return;
        }
        
        // No editable element found
      });

      // Completely disable any double-click editing by blocking ALL events on .editable elements
      JdrApp.utils.events.register('dblclick', '.editable', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      });

      JdrApp.utils.events.register('click', '.editable', (e) => {
        // Only allow clicks for keyboard navigation, no editing triggers
      });

      // Click outside to save
      JdrApp.utils.events.register('click', 'body', (e) => {
        if (!e.target.closest('.editable') && !e.target.matches('.editable') && !e.target.matches('.edit-btn')) {
          this.saveAllEdits();
        }
      });

      // Enter to save, Escape to save and exit
      JdrApp.utils.events.register('keydown', '.editable', (e) => {
        if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey) {
            e.preventDefault();
          // Find the parent editable section or item
          const editableContainer = e.target.closest('.editable-section, .editable-item') || e.target;
          this.saveEdit(editableContainer);
        } else if (e.key === 'Escape') {
            e.preventDefault();
          // Find the parent editable section or item
          const editableContainer = e.target.closest('.editable-section, .editable-item') || e.target;
          this.saveEdit(editableContainer);
        }
      });
    },

    // Find the best editable target element
    findEditableTarget(clickedElement) {
      // If the clicked element itself has edit attributes, use it
      if (clickedElement.dataset.editType && clickedElement.dataset.editSection !== undefined) {
        return clickedElement;
      }
      
      // Otherwise, look for the closest parent with edit attributes
      let current = clickedElement;
      while (current && current !== document.body) {
        if (current.classList && current.classList.contains('editable') && 
            current.dataset.editType && current.dataset.editSection !== undefined) {
          // Found parent editable element
          return current;
        }
        current = current.parentElement;
      }
      
      // Fallback: return the original clicked element if it's at least .editable
      if (clickedElement.classList && clickedElement.classList.contains('editable')) {
        // Using fallback editable element
        return clickedElement;
      }
      
      // No suitable editable element found
      return null;
    },

    makeEditableSection(section) {
      
      if (section.dataset.editing === 'true') {
        return;
      }
      
      // Find the editable element inside the section
      const editableElement = section.querySelector('.editable');
      if (!editableElement) {
        return;
      }
      
      // STRICT VALIDATION: Ensure editableElement has required data attributes
      if (!editableElement.dataset.editType || !editableElement.dataset.editSection) {
        return;
      }
      
      // Store original content on the section itself (which has the data attributes)
      section.dataset.originalContent = editableElement.innerHTML;
      section.dataset.editing = 'true';
      
      
      // Show HTML source for editing
      const htmlSource = editableElement.innerHTML;
      editableElement.textContent = htmlSource; // Show HTML as text
      
      // Make the editable element editable
      editableElement.contentEditable = true;
      editableElement.style.backgroundColor = 'rgba(255, 255, 0, 0.1)';
      editableElement.style.border = '1px dashed var(--bronze)';
      editableElement.style.borderRadius = '4px';
      editableElement.style.padding = '4px';
      editableElement.style.fontFamily = 'monospace'; // Monospace font for HTML editing
      editableElement.style.whiteSpace = 'pre-wrap'; // Preserve whitespace
      editableElement.focus();
      
      // Select all text
      const range = document.createRange();
      range.selectNodeContents(editableElement);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
    },

    makeEditableItem(listItem) {
      
      if (listItem.dataset.editing === 'true') {
        return;
      }
      
      // Find the content div inside the list item
      const contentDiv = listItem.querySelector('.editable-content');
      if (!contentDiv) {
        return;
      }
      
      // Store original content on the list item itself (which has the data attributes)
      listItem.dataset.originalContent = contentDiv.innerHTML;
      listItem.dataset.editing = 'true';
      
      // List item made editable
      
      // Make the content div editable
      contentDiv.contentEditable = true;
      contentDiv.style.backgroundColor = 'rgba(255, 255, 0, 0.1)';
      contentDiv.style.border = '1px dashed var(--bronze)';
      contentDiv.style.borderRadius = '4px';
      contentDiv.style.padding = '4px';
      contentDiv.focus();
      
      // Select all text
      const range = document.createRange();
      range.selectNodeContents(contentDiv);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
    },

    makeEditable(element) {
      
      if (element.dataset.editing === 'true') {
        return;
      }
      
      // Store original content
      element.dataset.originalContent = element.innerHTML;
      element.dataset.editing = 'true';
      
      // Element made editable
      
      // Make contenteditable
      element.contentEditable = true;
      element.style.backgroundColor = 'rgba(255, 255, 0, 0.1)';
      element.style.border = '1px dashed var(--bronze)';
      element.focus();
      
      // Select all text
      const range = document.createRange();
      range.selectNodeContents(element);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
    },

    saveEdit(element) {
      // For editable sections, get the edit type from the .editable element inside
      let editType = element.dataset.editType;
      let editSection = element.dataset.editSection;
      
      // For list items, get content from the .editable-content div
      let newContent;
      if (element.classList.contains('editable-item')) {
        const contentDiv = element.querySelector('.editable-content');
        newContent = contentDiv ? contentDiv.innerHTML.trim() : element.innerHTML.trim();
      } else if (element.classList.contains('editable-section')) {
        // For editable sections, get content from the .editable element inside
        const editableElement = element.querySelector('.editable');
        if (editableElement) {
          // Get the text content (HTML source) and use it as the new HTML
          newContent = editableElement.textContent.trim();
          editType = editableElement.dataset.editType;
          editSection = editableElement.dataset.editSection;
        } else {
          newContent = element.innerHTML.trim();
        }
      } else {
        newContent = element.innerHTML.trim();
      }
      
      const originalContent = element.dataset.originalContent;
      
      // Normalize HTML content to ensure consistency
      newContent = this.normalizeHTMLContent(newContent);
      
      
      if (newContent !== originalContent) {
        
        // Store edit in editedData
        this.storeEdit(element, newContent);
        
        // Track this element as modified (only if editType is valid)
        if (editType && typeof editType === 'string') {
          const elementId = this.getElementId(element);
          
          this.modifiedElements.set(elementId, {
            element: element,
            content: newContent,
            editType: editType,
            timestamp: Date.now()
          });
          
        } else {
          // Skipping element with invalid editType
        }
        
        // For editable sections, update the visual content immediately
        if (element.classList.contains('editable-section')) {
          const editableElement = element.querySelector('.editable');
          if (editableElement) {
            // Update the visible content with the new HTML
            editableElement.innerHTML = newContent;
          }
        } else if (element.classList.contains('editable-item')) {
          const contentDiv = element.querySelector('.editable-content');
          if (contentDiv) {
            // Update the visible content for list items
            contentDiv.innerHTML = newContent;
          }
        } else {
          // For direct editable elements, the content is already updated
        }
        
        // Apply element coloring if needed
        this.applyElementColoring(element);
        
        // IMMEDIATELY save changes to localStorage to persist edits
        this.saveChangesToStorage();
      } else {
        // No content change detected
      }
      
      // Reset editing state
      this.resetEditingState(element);
    },

    cancelEdit(element) {
      
      // Restore original content
      if (element.classList.contains('editable-section')) {
        const editableElement = element.querySelector('.editable');
        if (editableElement && element.dataset.originalContent) {
          editableElement.innerHTML = element.dataset.originalContent;
        }
      } else if (element.classList.contains('editable-item')) {
        const contentDiv = element.querySelector('.editable-content');
        if (contentDiv && element.dataset.originalContent) {
          contentDiv.innerHTML = element.dataset.originalContent;
        }
      } else {
        if (element.dataset.originalContent) {
          element.innerHTML = element.dataset.originalContent;
        }
      }
      
      this.resetEditingState(element);
    },

    resetEditingState(element) {
      // For list items, reset the .editable-content div
      if (element.classList.contains('editable-item')) {
        const contentDiv = element.querySelector('.editable-content');
        if (contentDiv) {
          contentDiv.contentEditable = false;
          contentDiv.style.backgroundColor = '';
          contentDiv.style.border = '';
          contentDiv.style.borderRadius = '';
          contentDiv.style.padding = '';
          // Note: We don't restore original content here - the new content should stay
        }
      } else if (element.classList.contains('editable-section')) {
        // For editable sections, reset the .editable element inside
        const editableElement = element.querySelector('.editable');
        if (editableElement) {
          editableElement.contentEditable = false;
          editableElement.style.backgroundColor = '';
          editableElement.style.border = '';
          editableElement.style.borderRadius = '';
          editableElement.style.padding = '';
          editableElement.style.fontFamily = ''; // Reset font
          editableElement.style.whiteSpace = ''; // Reset whitespace
          
          // Note: We don't restore original content here - the updated content should stay
          // The content has already been updated in the saveEdit method
        }
      } else {
        element.contentEditable = false;
        element.style.backgroundColor = '';
        element.style.border = '';
        // Note: We don't restore original content here - the new content should stay
      }
      
      element.dataset.editing = 'false';
      delete element.dataset.originalContent;
    },

    saveAllEdits() {
      // Save both old-style editable elements and new-style editable sections
      JdrApp.utils.dom.$('.editable[data-editing="true"], .editable-section[data-editing="true"], .editable-item[data-editing="true"]').forEach(element => {
        // STRICT VALIDATION: Only save elements with proper data attributes
        if (this.hasValidEditData(element)) {
          this.saveEdit(element);
        } else {
          this.resetEditingState(element);
        }
      });
    },
    
    hasValidEditData(element) {
      // For editable sections, check the .editable element inside
      if (element.classList.contains('editable-section')) {
        const editableElement = element.querySelector('.editable');
        return editableElement && editableElement.dataset.editType && editableElement.dataset.editSection;
      }
      
      // For editable items and direct editable elements
      return element.dataset.editType && (element.dataset.editSection || element.dataset.editSpell || element.dataset.editDon || element.dataset.editClass);
    },

    storeEdit(element, content) {
      // Find the actual editable element that has the data attributes
      let editableElement = element;
      let editType = element.dataset.editType;
      
      // If this is an editable section, get the data from the .editable element inside
      if (element.classList.contains('editable-section')) {
        const innerEditable = element.querySelector('.editable');
        if (innerEditable && innerEditable.dataset.editType) {
          editableElement = innerEditable;
          editType = innerEditable.dataset.editType;
        }
      }
      
      // Validate editType before proceeding
      if (!editType || typeof editType !== 'string') {
        return;
      }
      
      // Update data directly in global structures based on element attributes
      this.updateGlobalData(editableElement, content, editType);
    },

    getEditKey(element) {
      // Generate a unique key based on element data attributes
      const editType = element.dataset.editType;
      
      if (element.dataset.editSpell) {
        return element.dataset.editSpell;
      } else if (element.dataset.editDon) {
        return element.dataset.editDon;
      } else if (element.dataset.editClass) {
        return element.dataset.editClass;
      } else if (element.dataset.editCategory) {
        return element.dataset.editCategory;
      } else if (element.dataset.editSection) {
        return element.dataset.editSection;
      }
      
      return 'default';
    },

    getElementId(element) {
      // Find the actual editable element that has the data attributes
      let editableElement = element;
      
      // If this is an editable section, get the data from the .editable element inside
      if (element.classList.contains('editable-section')) {
        const innerEditable = element.querySelector('.editable');
        if (innerEditable && innerEditable.dataset.editType) {
          editableElement = innerEditable;
        }
      }
      
      // Create a unique ID for tracking modifications
      const editType = editableElement.dataset.editType;
      const editSpell = editableElement.dataset.editSpell;
      const editDon = editableElement.dataset.editDon;
      const editClass = editableElement.dataset.editClass;
      const editSubclass = editableElement.dataset.editSubclass;
      const editCategory = editableElement.dataset.editCategory;
      const editSection = editableElement.dataset.editSection;
      
      if (editSpell) return `spell:${editSpell}:${editType}`;
      if (editDon) return `don:${editDon}:${editType}`;
      if (editClass && editSubclass) return `subclass:${editClass}:${editSubclass}:${editType}`;
      if (editClass) return `class:${editClass}:${editType}`;
      if (editCategory) return `category:${editCategory}:${editType}`;
      if (editSection) return `section:${editSection}:${editType}`;
      
      // Fallback: use element position in DOM
      const allEditables = Array.from(document.querySelectorAll('.editable'));
      const index = allEditables.indexOf(editableElement);
      return `element:${index}:${editType}`;
    },



    updateStaticPageData(element, content) {
      const editSection = element.dataset.editSection;
      
      if (!window.STATIC_PAGES) return false;
      
      const article = element.closest('article[data-static-page="true"]');
      if (!article) return false;
      
      const pageId = article.dataset.page;
      const pageData = window.STATIC_PAGES[pageId];
      
      if (!pageData || !pageData.sections) return false;
      
      return this.updateSectionContent(pageData.sections, editSection, content, element);
    },

    updateStaticPageDataByEditType(element, content) {
      const editType = element.dataset.editType;
      
      if (!window.STATIC_PAGES) return false;
      
      const article = element.closest('article[data-static-page="true"]');
      if (!article) return false;
      
      const pageId = article.dataset.page;
      const pageData = window.STATIC_PAGES[pageId];
      
      if (!pageData || !pageData.sections) return false;
      
      return this.updateSectionContentByEditType(pageData.sections, editType, content, element);
    },

    updateSectionContentByEditType(sections, editType, content, element) {
      const editSection = element.dataset.editSection;
      
      for (let i = 0; i < sections.length; i++) {
        const section = sections[i];
        
        // Handle card content with ordered lists
        if (section.type === 'card' && section.content) {
          if (section.content.type === 'ordered_list' && section.content.editType === editSection) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            const listItems = tempDiv.querySelectorAll('li');
            section.content.items = Array.from(listItems).map(li => li.innerHTML);
            return true;
          }
          
          if (section.content.type === 'list' && section.content.editType === editSection) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            const listItems = tempDiv.querySelectorAll('li');
            section.content.items = Array.from(listItems).map(li => li.innerHTML);
            return true;
          }
        }
        
        // Handle grid content
        if (section.type === 'grid' && section.content) {
          for (let j = 0; j < section.content.length; j++) {
            const gridItem = section.content[j];
            if (gridItem.content && Array.isArray(gridItem.content)) {
              const result = this.updateSectionContentByEditType([{content: gridItem.content}], editType, content, element);
              if (result) return true;
            }
          }
        }
      }
      
      return false;
    },

    updateSectionContent(sections, editSection, content, element) {
      
      for (let i = 0; i < sections.length; i++) {
        const section = sections[i];
        // Checking section
        
        // Check if this is the section we're looking for
        if (section.type === 'intro' && editSection === 'intro') {
          section.content = content;
          return true;
        }
        
        // Handle card content
        if (section.type === 'card' && section.content) {
          // Check if this is a card title edit
          if (editSection.endsWith('-title') && section.sectionType) {
            const sectionId = editSection.replace('-title', '');
            if (section.sectionType === sectionId) {
              section.title = content;
              return true;
            }
          }
          
          if (section.content.type === 'ordered_list' && section.content.editType === editSection) {
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            const listItems = tempDiv.querySelectorAll('li');
            section.content.items = Array.from(listItems).map(li => li.innerHTML);
            return true;
          }
          
          // Handle array content in cards
          if (Array.isArray(section.content)) {
            for (let j = 0; j < section.content.length; j++) {
              const contentItem = section.content[j];
              if (contentItem.editSection === editSection) {
                contentItem.content = content;
                return true;
              }
            }
          }
        }
        
        // Handle grid content
        if (section.type === 'grid' && section.content) {
          for (let j = 0; j < section.content.length; j++) {
            const gridItem = section.content[j];
            if (gridItem.content && Array.isArray(gridItem.content)) {
              const result = this.updateSectionContent([{content: gridItem.content}], editSection, content, element);
              if (result) return true;
            }
          }
        }
      }
      
      return false;
    },

    applyElementColoring(element) {
      // Apply element coloring with delay
      setTimeout(() => {
        this.colorizeElements(element);
      }, 500);
    },

    colorizeElements(container = document) {
      const elementMap = {
        'Feu': { color: '#ff6b35', weight: 'bold' },
        'Air': { color: '#87ceeb', weight: 'bold' },
        'Eau': { color: '#4682b4', weight: 'bold' },
        'Terre': { color: '#8b7355', weight: 'bold' },
        'Divin': { color: '#ffd700', weight: 'bold' },
        'Maléfique': { color: '#8b008b', weight: 'bold' }
      };

      const walker = document.createTreeWalker(
        container,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );

      const textNodes = [];
      let node;
      while (node = walker.nextNode()) {
        textNodes.push(node);
      }

      textNodes.forEach(textNode => {
        let content = textNode.textContent;
        let hasChanges = false;

        Object.entries(elementMap).forEach(([element, style]) => {
          const regex = new RegExp(`\\b${element}\\b`, 'g');
          if (regex.test(content)) {
            content = content.replace(regex, `<span style="color: ${style.color}; font-weight: ${style.weight};">${element}</span>`);
            hasChanges = true;
          }
        });

        if (hasChanges) {
          const wrapper = document.createElement('span');
          wrapper.innerHTML = content;
          textNode.parentNode.replaceChild(wrapper, textNode);
        }
      });
    },

    setupCreationHandlers() {
      // Add new subclass
      JdrApp.utils.events.register('click', '.add-subclass-btn', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!this.isDevMode) {
          return;
        }
        
        this.addNewSubclass(e.target);
      });

      // Delete subclass
      JdrApp.utils.events.register('click', '.delete-subclass-btn', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!this.isDevMode) {
          return;
        }
        
        this.deleteSubclass(e.target);
      });
    },

    addNewSubclass(button) {
      // Find the parent class article
      const article = button.closest('article');
      if (!article) return;
      
      // Try to get class name from article attributes or from URL
      let className = article.dataset.class;
      if (!className) {
        const currentHash = window.location.hash;
        const match = currentHash.match(/#\/([^\/]+)/);
        if (match) {
          className = match[1].charAt(0).toUpperCase() + match[1].slice(1);
        }
      }
      
      if (!className || !window.CLASSES) return;
      
      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe) return;
      
      // Create new subclass with default values including proper labels
      const newSubclass = {
        nom: "Nouvelle sous-classe",
        base: {
          Force: 3,
          Agilité: 3,
          Endurance: 3,
          Intelligence: 3,
          Volonté: 3,
          Chance: 3
        },
        progression: "<strong>📈 Progression par niveau:</strong> +1 Force 💪, +1 Agilité 🏃",
        capacites: [
          "<em>Capacité unique</em>: Description de la capacité spéciale de cette sous-classe."
        ]
      };
      
      // Add to the class
      if (!classe.sousClasses) {
        classe.sousClasses = [];
      }
      classe.sousClasses.push(newSubclass);
      
      // Save immediately
      this.saveChangesToStorage();
      
      // Refresh the current page to show the new subclass
      window.location.reload();
    },

    deleteSubclass(button) {
      const className = button.dataset.className;
      const subclassName = button.dataset.subclassName;
      
      if (!className || !subclassName) {
        console.error('❌ Missing class or subclass name');
        return;
      }

      // Confirm deletion
      if (!confirm(`Êtes-vous sûr de vouloir supprimer la sous-classe "${subclassName}" ?`)) {
        return;
      }

      if (!window.CLASSES) {
        console.error('❌ No CLASSES data');
        return;
      }

      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe || !classe.sousClasses) {
        console.error('❌ Class or subclasses not found');
        return;
      }

      // Find and remove the subclass
      const subclassIndex = classe.sousClasses.findIndex(sc => sc.nom === subclassName);
      if (subclassIndex === -1) {
        console.error('❌ Subclass not found');
        return;
      }

      classe.sousClasses.splice(subclassIndex, 1);

      // Save immediately
      this.saveChangesToStorage();

      // Refresh the current page
      window.location.reload();
    },

    setupImageHandlers() {
      // Image upload
      JdrApp.utils.events.register('change', '.illus input[type="file"]', (e) => {
        this.handleImageUpload(e);
      });

      // Image removal
      JdrApp.utils.events.register('click', '.illus .rm', (e) => {
        this.handleImageRemoval(e);
      });

      // Image enlargement
      JdrApp.utils.events.register('click', '.illus img', (e) => {
        this.toggleImageEnlargement(e.target);
      });
    },

    handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const illus = event.target.closest('.illus');
        const img = illus.querySelector('img');
        const rmButton = illus.querySelector('.rm');
        const illusKey = illus.dataset.illusKey;

        // Set image source and display
        img.src = e.target.result;
        img.style.display = 'block';
        if (rmButton) rmButton.style.display = 'block';

        // Save to images module if available
        if (JdrApp.modules.images && JdrApp.modules.images.setImageUrl) {
          JdrApp.modules.images.setImageUrl(illusKey, e.target.result);
        } else {
          // Fallback: save to localStorage with quota management
          try {
            localStorage.setItem(`illustration:${illusKey}`, e.target.result);
          } catch (error) {
            if (error.name === 'QuotaExceededError') {
              this.clearOldImages();
              
              // Try again after clearing
              try {
                localStorage.setItem(`illustration:${illusKey}`, e.target.result);
              } catch (secondError) {
                alert('Espace de stockage insuffisant. Veuillez supprimer quelques images pour continuer.');
                // Reset image display
                img.src = '';
                img.style.display = 'none';
                if (rmButton) rmButton.style.display = 'none';
                return;
              }
            } else {
              throw error;
            }
          }
        }
      };
      
      reader.onerror = (e) => {
        alert('Erreur lors de la lecture du fichier image');
      };
      
      reader.readAsDataURL(file);
    },

    handleImageRemoval(event) {
      const illus = event.target.closest('.illus');
      const img = illus.querySelector('img');
      const rmButton = illus.querySelector('.rm');
      const illusKey = illus.dataset.illusKey;

      // Remove image display
      img.src = '';
      img.style.display = 'none';
      if (rmButton) rmButton.style.display = 'none';

      // Remove from images module if available
      if (JdrApp.modules.images && JdrApp.modules.images.removeImage) {
        JdrApp.modules.images.removeImage(illusKey);
      } else {
        // Fallback: remove from localStorage
        localStorage.removeItem(`illustration:${illusKey}`);
      }
    },

    toggleImageEnlargement(img) {
      if (img.classList.contains('enlarged')) {
        img.classList.remove('enlarged');
        this.removeImageBackdrop();
      } else {
        img.classList.add('enlarged');
        this.createImageBackdrop();
      }
    },

    createImageBackdrop() {
      let backdrop = document.querySelector('.image-backdrop');
      if (!backdrop) {
        backdrop = document.createElement('div');
        backdrop.className = 'image-backdrop';
        document.body.appendChild(backdrop);
      }
      
      backdrop.classList.add('visible');
      
      // Click to close
      backdrop.onclick = () => {
        JdrApp.utils.dom.$('img.enlarged').forEach(img => {
          img.classList.remove('enlarged');
        });
        this.removeImageBackdrop();
      };
    },

    removeImageBackdrop() {
      const backdrop = document.querySelector('.image-backdrop');
      if (backdrop) {
        backdrop.classList.remove('visible');
      }
    },

    // Clear old images from localStorage to free space
    clearOldImages() {
      const illustrationKeys = [];
      
      // Find all illustration keys in localStorage
      for (let i = 0; i < localStorage.length; i++) {
        const key = localStorage.key(i);
        if (key && key.startsWith('illustration:')) {
          illustrationKeys.push(key);
        }
      }
      
      // Sort by key (oldest first, roughly)
      illustrationKeys.sort();
      
      // Remove the oldest half
      const toRemove = Math.ceil(illustrationKeys.length / 2);
      for (let i = 0; i < toRemove; i++) {
        localStorage.removeItem(illustrationKeys[i]);
      }
    },

    forceCollectAllEdits() {
      this.saveAllEdits();
      
      // All data is already updated in global structures during editing
      // No need to process modifiedElements again since updateGlobalData
      // is called immediately when each edit is saved
      
      return this.editedData;
    },

    // Ultra-simple generic method - just save text as-is
    updateGlobalData(element, content, editType) {
      try {
        // Find the target in global data and update it directly with the raw content
        this.updateDataByPath(element, content);
      } catch (error) {
        // Silently handle errors
      }
    },

    // Ultra-simple method to save any text content to the right place
    updateDataByPath(element, content) {
      const editType = element.dataset.editType;
      
      // SPELLS
      if (element.dataset.editSpell) {
        let property = editType.replace('spell-', '');
        this.saveToSpell(element.dataset.editSpell, property, content);
        return;
      }
      
      // DONS
      if (element.dataset.editDon) {
        this.saveToDon(element.dataset.editDon, editType.replace('don-', ''), content);
        return;
      }
      
      // CLASSES/SUBCLASSES
      if (element.dataset.editSection && (element.dataset.editSection.includes('-') || editType.startsWith('subclass-'))) {
        this.saveToSubclass(element.dataset.editSection, editType, content);
        return;
      }
      
      if (element.dataset.editClass) {
        this.saveToClass(element.dataset.editClass, editType, content);
        return;
      }
      
      // STATIC PAGES
      this.updateStaticPageDataByEditType(element, content);
    },

    // Simple save methods - just store text as-is
    saveToSpell(spellName, property, content) {
      if (!window.SORTS) return;
      
      for (const category of window.SORTS) {
        const spell = category.sorts.find(s => s.nom === spellName);
        if (spell) {
          const propertyMap = {
            'name': 'nom', 
            'description': 'description', 
            'prerequis': 'prerequis',
            'portee': 'portee', 
            'mana': 'coutMana', 
            'temps-incantation': 'tempsIncantation',
            'duree': 'duree',
            'resistance': 'resistance', 
            'effect-normal': 'effetNormal',
            'effect-critical': 'effetCritique', 
            'effect-failure': 'effetEchec'
          };
          const targetProperty = propertyMap[property] || property;
          spell[targetProperty] = content;
          return true;
        }
      }
      
      return false;
    },

    saveToDon(donName, property, content) {
      if (!window.DONS) return;
      for (const category of window.DONS) {
        const don = category.dons.find(d => d.nom === donName);
        if (don) {
          const propertyMap = { 'name': 'nom', 'description': 'description', 'prerequis': 'prerequis', 'cout': 'cout' };
          don[propertyMap[property] || property] = content;
          break;
        }
      }
    },

    saveToClass(className, editType, content) {
      if (!window.CLASSES) return;
      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe) return;
      
      if (editType === 'resume') {
        classe.resume = content;
      } else if (editType === 'capacites') {
        classe.capacites = this.parseListContent(content);
      }
    },

    saveToSubclass(editSection, editType, content) {
      if (!editSection || !window.CLASSES) return;
      
      const parts = editSection.split('-');
      if (parts.length < 2) return;
      
      const className = parts[0];
      const subClassName = parts.slice(1).join('-');
      
      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe || !classe.sousClasses) return;
      
      const sousClasse = classe.sousClasses.find(sc => sc.nom === subClassName);
      if (!sousClasse) return;
      
      if (editType === 'subclass-progression') {
        sousClasse.progression = content;
      } else if (editType === 'subclass-capacites') {
        sousClasse.capacites = this.parseListContent(content);
      } else if (editType === 'subclass-stats') {
        sousClasse.base = this.parseStatsContent(content);
      }
    },

    // Helper methods for parsing content (only when needed)
    parseListContent(content) {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = content;
      const listItems = tempDiv.querySelectorAll('li');
      return Array.from(listItems).map(li => li.innerHTML);
    },

    parseStatsContent(content) {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = content;
      const chips = tempDiv.querySelectorAll('.chip');
      const stats = {};
      
      chips.forEach(chip => {
        const text = chip.textContent.trim();
        const match = text.match(/(.+?):\s*(.+)/);
        if (match) {
          const statName = match[1].replace(/^[^\w]+/, '').trim(); // Remove emoji
          const statValue = match[2].trim();
          stats[statName] = statValue;
        }
      });
      
      return stats;
    },

    // Update individual list item in static pages
    updateListItem(element, content) {
      const editSection = element.dataset.editSection;
      const editIndex = parseInt(element.dataset.editIndex);
      
      if (!window.STATIC_PAGES) {
        return false;
      }
      
      const article = element.closest('article[data-static-page="true"]');
      if (!article) {
        return false;
      }
      
      const pageId = article.dataset.page;
      const pageData = window.STATIC_PAGES[pageId];
      
      if (!pageData || !pageData.sections) {
        return false;
      }
      
      // Find the list in the page data
      for (let i = 0; i < pageData.sections.length; i++) {
        const section = pageData.sections[i];
        
        if (section.type === 'card' && section.content) {
          if (section.content.type === 'ordered_list' && section.content.editType === editSection) {
            section.content.items[editIndex] = content;
            return true;
          }
          
          if (section.content.type === 'list' && section.content.editType === editSection) {
            section.content.items[editIndex] = content;
            return true;
          }
        }
      }
      
      // List not found
      return false;
    },

    // Normalize HTML content to ensure consistency across browsers and editing
    normalizeHTMLContent(html) {
      // Create a temporary div to parse and normalize the HTML
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;
      
      // Remove any contenteditable artifacts
      this.removeContentEditableArtifacts(tempDiv);
      
      // Normalize whitespace and formatting
      let normalized = tempDiv.innerHTML;
      
      // Preserve important HTML entities and structure
      normalized = this.preserveHTMLStructure(normalized);
      
      return normalized.trim();
    },

    // Remove contenteditable artifacts that browsers might add
    removeContentEditableArtifacts(container) {
      // Remove any empty text nodes or unnecessary spans
      const walker = document.createTreeWalker(
        container,
        NodeFilter.SHOW_ALL,
        null,
        false
      );

      const nodesToRemove = [];
      let node;
      
      while (node = walker.nextNode()) {
        // Remove empty text nodes with only whitespace
        if (node.nodeType === Node.TEXT_NODE && node.textContent.trim() === '') {
          // But preserve intentional &nbsp; and single spaces in specific contexts
          if (node.textContent !== '\u00a0' && node.parentNode.tagName !== 'SPAN') {
            nodesToRemove.push(node);
          }
        }
        
        // Remove empty spans without attributes or with only style="font-weight: normal" etc.
        if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'SPAN') {
          if (!node.hasAttributes() && node.textContent.trim() === '') {
            nodesToRemove.push(node);
          }
        }
        
        // Remove Firefox/Chrome artifacts like <div><br></div>
        if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'DIV') {
          if (node.innerHTML === '<br>' || node.innerHTML === '<br/>') {
            // Replace with just <br>
            const br = document.createElement('br');
            node.parentNode.replaceChild(br, node);
          }
        }
      }
      
      // Remove identified nodes
      nodesToRemove.forEach(node => {
        if (node.parentNode) {
          node.parentNode.removeChild(node);
        }
      });
    },

    // Preserve important HTML structure and entities
    preserveHTMLStructure(html) {
      // Ensure consistent formatting for common patterns
      
      // Normalize <br> tags (some browsers use <br/>, others <br>)
      html = html.replace(/<br\s*\/?>/gi, '<br>');
      
      // Preserve color styling (ensure it's properly formatted)
      html = html.replace(/style\s*=\s*["']([^"']*color\s*:\s*[^;"']+[^"']*)["']/gi, (match, styleContent) => {
        // Clean up the style content
        const cleanStyle = styleContent.trim().replace(/\s+/g, ' ');
        return `style="${cleanStyle}"`;
      });
      
      // Preserve &nbsp; entities
      html = html.replace(/\u00a0/g, '&nbsp;');
      
      // Ensure consistent quote usage in attributes
      html = html.replace(/(\w+)\s*=\s*'([^']*)'/g, '$1="$2"');
      
      return html;
    },

    // Save changes to localStorage immediately when edits are made
    saveChangesToStorage() {
      try {
        // Save only edited data overlay (not full data)
        localStorage.setItem('jdr-bab-edits', JSON.stringify(this.editedData));
        
        // Save timestamp of last modification
        localStorage.setItem('jdr-bab-last-modified', Date.now().toString());
        
        
      } catch (error) {
        console.error('❌ Failed to save changes to localStorage:', error);
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - UI MODULE
// ============================================================================

(() => {
  "use strict";


  // ========================================
  // UI INTERACTIONS MODULE
  // ========================================
  JdrApp.modules.ui = {
    
    init() {
      
      // Set up search functionality
      this.setupSearch();
      
      // Set up modal handlers
      this.setupModals();
      
      // Set up content creation handlers
      this.setupContentCreation();
      
      // Set up resource tools
      this.setupResourceTools();
      
      // Set up responsive handlers
      this.setupResponsive();
    },

    setupSearch() {
      const searchInput = JdrApp.utils.dom.$('#search');
      const clearButton = JdrApp.utils.dom.$('#clear');
      
      if (searchInput) {
        // Search as you type
        JdrApp.utils.events.register('input', '#search', (e) => {
          this.performSearch(e.target.value);
        });
        
        // Enter key
        JdrApp.utils.events.register('keydown', '#search', (e) => {
          if (e.key === 'Enter') {
            this.performSearch(e.target.value);
          }
        });
      }
      
      if (clearButton) {
        JdrApp.utils.events.register('click', '#clear', () => {
          if (searchInput) {
            searchInput.value = '';
            this.performSearch('');
          }
        });
      }
    },

    performSearch(query) {
      const normalizedQuery = query.toLowerCase().trim();
      
      if (!normalizedQuery) {
        // Show all content
        JdrApp.utils.dom.$('article, .toc a').forEach(el => {
          el.style.display = '';
        });
        return;
      }

      // Search in TOC
      JdrApp.utils.dom.$('.toc a').forEach(link => {
        const text = link.textContent.toLowerCase();
        const isMatch = text.includes(normalizedQuery);
        link.style.display = isMatch ? '' : 'none';
        
        // Expand parent category if child matches
        if (isMatch) {
          const category = link.closest('.toc-category');
          if (category) {
            category.classList.remove('collapsed');
          }
        }
      });

      // Search in article content
      JdrApp.utils.dom.$('article').forEach(article => {
        const text = article.textContent.toLowerCase();
        const isMatch = text.includes(normalizedQuery);
        
        if (isMatch) {
          // Highlight search terms
          this.highlightSearchTerms(article, normalizedQuery);
        }
      });
    },

    highlightSearchTerms(container, query) {
      // Simple highlighting implementation
      const walker = document.createTreeWalker(
        container,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );

      const textNodes = [];
      let node;
      while (node = walker.nextNode()) {
        if (node.textContent.toLowerCase().includes(query)) {
          textNodes.push(node);
        }
      }

      textNodes.forEach(textNode => {
        const regex = new RegExp(`(${query})`, 'gi');
        const content = textNode.textContent;
        
        if (regex.test(content)) {
          const highlightedContent = content.replace(regex, '<mark>$1</mark>');
          const wrapper = document.createElement('span');
          wrapper.innerHTML = highlightedContent;
          textNode.parentNode.replaceChild(wrapper, textNode);
        }
      });
    },

    setupModals() {
      // Generic modal close handler
      JdrApp.utils.events.register('click', '.modal-overlay, .modal-close', (e) => {
        const modal = e.target.closest('.modal') || document.querySelector('.modal.visible');
        if (modal) {
          this.closeModal(modal);
        }
      });

      // Prevent modal close when clicking inside modal content
      JdrApp.utils.events.register('click', '.modal-content', (e) => {
        e.stopPropagation();
      });

      // Escape key to close modals
      JdrApp.utils.events.register('keydown', 'body', (e) => {
        if (e.key === 'Escape') {
          const openModal = document.querySelector('.modal.visible');
          if (openModal) {
            this.closeModal(openModal);
          }
        }
      });
    },

    openModal(modalId) {
      const modal = JdrApp.utils.dom.$(`#${modalId}`);
      if (modal) {
        modal.classList.add('visible');
        modal.style.display = 'flex';
        
        // Focus first input if available
        const firstInput = modal.querySelector('input, textarea, select');
        if (firstInput) {
          firstInput.focus();
        }
      }
    },

    closeModal(modal) {
      if (modal) {
        modal.classList.remove('visible');
        modal.style.display = 'none';
        
        // Clear form if present
        const form = modal.querySelector('form');
        if (form) {
          form.reset();
        }
      }
    },

    setupContentCreation() {
      // Add spell handlers
      JdrApp.utils.events.register('click', '.spell-add', (e) => {
        const categoryName = e.target.dataset.categoryName;
        this.addNewSpell(categoryName);
      });

      // Delete spell handlers
      JdrApp.utils.events.register('click', '.spell-delete', (e) => {
        const categoryName = e.target.dataset.categoryName;
        const spellName = e.target.dataset.spellName;
        this.deleteSpell(categoryName, spellName);
      });

      // Add don handlers
      JdrApp.utils.events.register('click', '.don-add', (e) => {
        const categoryName = e.target.dataset.categoryName;
        this.addNewDon(categoryName);
      });

      // Delete don handlers
      JdrApp.utils.events.register('click', '.don-delete', (e) => {
        const categoryName = e.target.dataset.categoryName;
        const donName = e.target.dataset.donName;
        this.deleteDon(categoryName, donName);
      });

      // Move don handlers
      JdrApp.utils.events.register('click', '.don-move-up', (e) => {
        const categoryName = e.target.dataset.categoryName;
        const donName = e.target.dataset.donName;
        const index = parseInt(e.target.dataset.donIndex);
        this.moveDon(categoryName, donName, index, -1);
      });

      JdrApp.utils.events.register('click', '.don-move-down', (e) => {
        const categoryName = e.target.dataset.categoryName;
        const donName = e.target.dataset.donName;
        const index = parseInt(e.target.dataset.donIndex);
        this.moveDon(categoryName, donName, index, 1);
      });

      // Add paragraph handlers
      JdrApp.utils.events.register('click', '.add-paragraph-btn', (e) => {
        const target = e.target.dataset.target;
        this.addParagraph(target, e.target);
      });
    },

    addNewSpell(categoryName) {
      const category = JdrApp.utils.data.getSpellCategory(categoryName);
      if (!category) return;

      const newSpell = {
        nom: "Nouveau Sort",
        description: "Lance une boule de Feu sur un adversaire.",
        categorie: categoryName,
        prerequis: "📋 <strong>Prérequis:</strong> Niveau 1",
        portee: "🎯 <strong>Portée:</strong> 20m",
        tempsIncantation: "⏰ <strong>Temps d'incantation:</strong> 1 tour",
        coutMana: "🔵 <strong>Coût mana:</strong> 3",
        resistance: "<strong>Sans effet si:</strong> Esquive.",
        effetNormal: "<strong>Effet:</strong> Inflige 5 dégats de <span style=\"color: #e25822; font-weight: bold;\">Feu</span> à la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dégats de 1.",
        effetCritique: "<strong>Coup Critique:&nbsp;</strong>&nbsp;Double les dégâts et enflamme la cible, infligeant 2 dégats de Feu au prochain tour du lanceur.",
        effetEchec: "<strong>Échec Critique:&nbsp;</strong>Le sort inflige ses dégats à un allié dans la trajectoire."
      };

      category.sorts.push(newSpell);
      
      // Re-render the category page
      JdrApp.modules.renderer.renderSortCategory(`sorts-${JdrApp.utils.data.sanitizeId(categoryName)}`);
      
      this.showNotification('🔮 Nouveau sort ajouté');
    },

    deleteSpell(categoryName, spellName) {
      if (!confirm(`Supprimer le sort "${spellName}" ?`)) return;

      const category = JdrApp.utils.data.getSpellCategory(categoryName);
      if (!category) return;

      const index = category.sorts.findIndex(s => s.nom === spellName);
      if (index !== -1) {
        category.sorts.splice(index, 1);
        
        // Re-render the category page
        JdrApp.modules.renderer.renderSortCategory(`sorts-${JdrApp.utils.data.sanitizeId(categoryName)}`);
        
        this.showNotification('🗑 Sort supprimé');
      }
    },

    addNewDon(categoryName) {
      const category = JdrApp.utils.data.getDonCategory(categoryName);
      if (!category) return;

      const newDon = {
        nom: "Nouveau Don",
        description: "Description du don.",
        prerequis: "Aucun prérequis",
        cout: "1 point de don"
      };

      category.dons.push(newDon);
      
      // Re-render the category page
      JdrApp.modules.renderer.renderDonCategory(`dons-${JdrApp.utils.data.sanitizeId(categoryName)}`);
      
      this.showNotification('🎖️ Nouveau don ajouté');
    },

    deleteDon(categoryName, donName) {
      if (!confirm(`Supprimer le don "${donName}" ?`)) return;

      const category = JdrApp.utils.data.getDonCategory(categoryName);
      if (!category) return;

      const index = category.dons.findIndex(d => d.nom === donName);
      if (index !== -1) {
        category.dons.splice(index, 1);
        
        // Re-render the category page
        JdrApp.modules.renderer.renderDonCategory(`dons-${JdrApp.utils.data.sanitizeId(categoryName)}`);
        
        this.showNotification('🗑 Don supprimé');
      }
    },

    moveDon(categoryName, donName, currentIndex, direction) {
      const category = JdrApp.utils.data.getDonCategory(categoryName);
      if (!category) return;

      const newIndex = currentIndex + direction;
      if (newIndex < 0 || newIndex >= category.dons.length) return;

      // Swap positions
      const temp = category.dons[currentIndex];
      category.dons[currentIndex] = category.dons[newIndex];
      category.dons[newIndex] = temp;
      
      // Re-render the category page
      JdrApp.modules.renderer.renderDonCategory(`dons-${JdrApp.utils.data.sanitizeId(categoryName)}`);
      
      this.showNotification(`🔄 Don ${direction > 0 ? 'descendu' : 'monté'}`);
    },

    addParagraph(target, button) {
      const newParagraph = JdrApp.utils.dom.create('p', 'editable', 'Nouveau paragraphe.', {
        'data-edit-type': 'custom',
        'data-edit-section': target
      });
      
      button.parentNode.insertBefore(newParagraph, button);
      
      // Make it immediately editable
      if (JdrApp.modules.editor.isDevMode) {
        JdrApp.modules.editor.makeEditable(newParagraph);
      }
    },

    setupResourceTools() {
      // Elements button
      JdrApp.utils.events.register('click', '#elementsBtn', () => {
        this.showElementsModal();
      });

      // Icons button
      JdrApp.utils.events.register('click', '#showIcons', () => {
        this.showIconsModal();
      });
    },

    showElementsModal() {
      // Create elements modal if it doesn't exist
      let modal = JdrApp.utils.dom.$('#elementsModal');
      if (!modal) {
        modal = this.createElementsModal();
        document.body.appendChild(modal);
      }
      
      this.openModal('elementsModal');
    },

    createElementsModal() {
      const elements = [
        { name: 'Feu', color: '#ff6b35', icon: '🔥' },
        { name: 'Air', color: '#87ceeb', icon: '💨' },
        { name: 'Eau', color: '#4682b4', icon: '💧' },
        { name: 'Terre', color: '#8b7355', icon: '🌍' },
        { name: 'Divin', color: '#ffd700', icon: '✨' },
        { name: 'Maléfique', color: '#8b008b', icon: '💀' }
      ];

      const elementsHTML = elements.map(element => `
        <div class="element-item" data-element="${element.name}" data-color="${element.color}">
          <div class="element-icon" style="background: ${element.color};">${element.icon}</div>
          <div class="element-name">${element.name}</div>
          <div class="copy-indicator">Copié!</div>
        </div>
      `).join('');

      const modal = JdrApp.utils.dom.create('div', 'modal elements-modal', `
        <div class="modal-content elements-modal-content">
          <h3>🎨 Éléments</h3>
          <p>Cliquez sur un élément pour copier sa balise HTML colorée.</p>
          <div class="elements-list">
            ${elementsHTML}
          </div>
          <button class="modal-close btn">Fermer</button>
        </div>
      `, { id: 'elementsModal' });

      // Add click handlers for elements
      modal.addEventListener('click', (e) => {
        const elementItem = e.target.closest('.element-item');
        if (elementItem) {
          const elementName = elementItem.dataset.element;
          const color = elementItem.dataset.color;
          const html = `<span style="color: ${color}; font-weight: bold;">${elementName}</span>`;
          
          this.copyToClipboard(html);
          
          // Show copied indicator
          elementItem.classList.add('copied');
          setTimeout(() => {
            elementItem.classList.remove('copied');
          }, 1000);
        }
      });

      return modal;
    },

    showIconsModal() {
      this.showNotification('🔥 Fonctionnalité des icônes à implémenter', 'info');
    },

    copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        this.showNotification('📋 Copié dans le presse-papiers', 'success');
      }).catch(() => {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        this.showNotification('📋 Copié dans le presse-papiers', 'success');
      });
    },

    setupResponsive() {
      // Menu toggle for mobile
      JdrApp.utils.events.register('click', '#menuToggle', () => {
        const sidebar = JdrApp.utils.dom.$('#sidebar');
        const backdrop = JdrApp.utils.dom.$('#backdrop');
        
        if (sidebar && backdrop) {
          sidebar.classList.toggle('mobile-open');
          backdrop.hidden = !sidebar.classList.contains('mobile-open');
        }
      });

      // Close sidebar when clicking backdrop
      JdrApp.utils.events.register('click', '#backdrop', () => {
        const sidebar = JdrApp.utils.dom.$('#sidebar');
        const backdrop = JdrApp.utils.dom.$('#backdrop');
        
        if (sidebar && backdrop) {
          sidebar.classList.remove('mobile-open');
          backdrop.hidden = true;
        }
      });
    },

    showNotification(message, type = 'info') {
      // Reuse the storage module's notification system
      if (JdrApp.modules.storage.showNotification) {
        JdrApp.modules.storage.showNotification(message, type);
      } else {
        // Fallback: simple console log
      }
    }
  };

})();

</script>
</body>
</html>