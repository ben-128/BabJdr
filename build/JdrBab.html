<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta name="referrer" content="no-referrer-when-downgrade">
<!-- Generated on 2025-09-03T11:52:32.448Z by JdrBab Build System -->
<title>JDRâ€‘BAB â€” Livret de rÃ¨gles</title>
<meta content="Livret web multipages des rÃ¨gles JDRâ€‘BAB, thÃ¨me parchemin, illustrations par catÃ©gorie/classe/sousâ€‘classe, export HTML autonome." name="description">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&amp;family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600&amp;display=swap" rel="stylesheet">
<style>
/* â€”â€” ThÃ¨me Heroic Fantasy - Enhanced Parchment â€”â€” */
:root{
  --paper:#f4f0e6;        /* parchemin ancien */
  --paper-ink:#2c1810;    /* encre noire profonde */
  --paper-muted:#8b6f47;  /* bronze ancien */
  --accent:#d4af37;       /* accent dorÃ© pour backgrounds */
  --accent-ink:#4a2c17;   /* titres sombres */
  --rule:#d4c4a8;         /* bordures dorÃ©es */
  --card:#faf6ee;         /* cartes parchemin */
  --link:#8b4513;         /* liens cuivre */
  --gold:#d4af37;         /* or */
  --bronze:#cd7f32;       /* bronze */
  --shadow:0 8px 32px rgba(0,0,0,.15), 0 2px 8px rgba(139,69,19,.1);
  --card-shadow:0 6px 20px rgba(0,0,0,.1), 0 2px 6px rgba(139,69,19,.08);
  --image-border:3px solid #8b4513;
  --image-shadow:0 4px 12px rgba(0,0,0,.2), inset 0 1px 2px rgba(212,175,55,.3);
  
  /* Enhanced Parchment Textures */
  --parchment-texture: 
    radial-gradient(circle at 20% 80%, rgba(139,69,19,.03) 0%, transparent 50%),
    radial-gradient(circle at 80% 20%, rgba(212,175,55,.02) 0%, transparent 50%),
    radial-gradient(circle at 40% 40%, rgba(139,69,19,.01) 0%, transparent 30%),
    linear-gradient(45deg, rgba(139,69,19,.005) 25%, transparent 25%),
    linear-gradient(-45deg, rgba(212,175,55,.005) 25%, transparent 25%);
    
  --parchment-border:
    linear-gradient(45deg, 
      rgba(139,69,19,.8) 0%, 
      rgba(212,175,55,.6) 25%, 
      rgba(139,69,19,.4) 50%, 
      rgba(212,175,55,.6) 75%, 
      rgba(139,69,19,.8) 100%);
      
  --aged-paper: 
    radial-gradient(ellipse at top left, rgba(139,69,19,.04), transparent 60%),
    radial-gradient(ellipse at top right, rgba(212,175,55,.03), transparent 60%),
    radial-gradient(ellipse at bottom left, rgba(139,69,19,.02), transparent 60%),
    radial-gradient(ellipse at bottom right, rgba(212,175,55,.025), transparent 60%);
  
  /* Enhanced Element Colors System - Improved Contrast & Accessibility */
  --feu:#e63946; --feu-bg:rgba(230,57,70,.12); --feu-border:rgba(230,57,70,.4);
  --air:#457b9d; --air-bg:rgba(69,123,157,.12); --air-border:rgba(69,123,157,.4);
  --eau:#1d3557; --eau-bg:rgba(29,53,87,.12); --eau-border:rgba(29,53,87,.4);
  --terre:#6f4e37; --terre-bg:rgba(111,78,55,.12); --terre-border:rgba(111,78,55,.4);
  --divin:#f1c40f; --divin-bg:rgba(241,196,15,.12); --divin-border:rgba(241,196,15,.4);
  --malefique:#6a2c70; --malefique-bg:rgba(106,44,112,.12); --malefique-border:rgba(106,44,112,.4);
  
  /* Spacing system */
  --space-xs:4px; --space-sm:6px; --space-md:8px; --space-lg:12px; --space-xl:16px; --space-2xl:24px;
  
  /* Common transitions */
  --transition-fast:.2s ease; --transition-normal:.3s ease; --transition-slow:.5s ease;
}

/* Enhanced Accessibility & High Contrast Support */
@media (prefers-color-scheme: dark) { 
  :root{ 
    --paper:#f4f0e6; /* Keep light theme for fantasy aesthetic */
    --card:#faf6ee; 
    --paper-ink:#2c1810; 
  } 
}

@media (prefers-contrast: high) {
  :root {
    --paper-ink: #000000;
    --accent-ink: #1a0d08;
    --bronze: #8b4513;
    --gold: #b8860b;
    --rule: #8b4513;
  }
  
  .card, .card-base {
    border-width: 3px;
  }
  
  .btn-base {
    border-width: 3px;
  }
}

/* Base styles */
html,body{height:100%}
body{
  margin:0;
  background:
    radial-gradient(1600px 800px at 50% -10%, rgba(212,175,55,.08), transparent 45%),
    radial-gradient(1400px 700px at 120% 10%, rgba(139,69,19,.06), transparent 40%),
    radial-gradient(800px 400px at 20% 80%, rgba(205,127,50,.04), transparent 30%),
    repeating-linear-gradient(90deg, rgba(74,44,23,.02) 0 1px, transparent 1px 3px),
    repeating-linear-gradient(0deg, rgba(139,69,19,.015) 0 1px, transparent 1px 4px),
    var(--paper);
  color:var(--paper-ink); 
  font:17px/1.65 "Source Serif Pro", "Cinzel", ui-serif, Georgia, Cambria, "Times New Roman", Times, serif; 
  -webkit-font-smoothing:antialiased; 
  text-rendering:optimizeLegibility;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ¨ ENHANCED TYPOGRAPHY SYSTEM - Centered & Harmonized
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Link Styling */
a {
  color: var(--link);
  text-decoration: none;
  transition: all var(--transition-fast);
  position: relative;
}

a:hover {
  text-decoration: underline;
  color: var(--gold);
  text-shadow: 0 1px 3px rgba(212,175,55,0.3);
}

/* Text Emphasis */
strong, b {
  font-weight: 700;
  font-family: "Source Serif Pro", serif;
  color: var(--accent-ink);
  text-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

em, i {
  font-style: italic;
  font-weight: 400;
  color: var(--bronze);
}

/* Enhanced Headings System */
h1, h2, h3, h4, h5, h6 {
  font-family: "Cinzel", "Trajan Pro", ui-serif, Georgia, Cambria, Times, serif;
  color: var(--accent-ink);
  text-shadow: 2px 2px 4px rgba(0,0,0,.1);
  text-align: center;
  margin: 1.5rem auto 1rem;
  position: relative;
  line-height: 1.2;
  letter-spacing: 0.02em;
}

/* Main Title */
h1 {
  font-size: clamp(28px, 4.5vw, 48px);
  letter-spacing: 0.05em;
  margin: 2rem auto 1.5rem;
  font-weight: 700;
  background: linear-gradient(135deg, var(--gold), var(--bronze), var(--gold));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-shadow: none;
  position: relative;
}

h1::before {
  content: 'â—†';
  position: absolute;
  left: -20px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--gold);
  font-size: 0.6em;
  opacity: 0.7;
}

h1::after {
  content: 'â—†';
  position: absolute;
  right: -20px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--gold);
  font-size: 0.6em;
  opacity: 0.7;
}

/* Section Headings */
h2 {
  font-size: clamp(22px, 3.2vw, 32px);
  margin: 1.8rem auto 1.2rem;
  font-weight: 600;
  color: var(--bronze);
  position: relative;
}

h2::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 80px;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--bronze), transparent);
  opacity: 0.8;
}

/* Subsection Headings */
h3 {
  font-size: clamp(18px, 2.4vw, 26px);
  margin: 1.5rem auto 1rem;
  font-weight: 500;
  color: var(--accent-ink);
  position: relative;
}

h3::before {
  content: 'â€»';
  position: absolute;
  left: -15px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--bronze);
  font-size: 0.8em;
  opacity: 0.6;
}

h3::after {
  content: 'â€»';
  position: absolute;
  right: -15px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--bronze);
  font-size: 0.8em;
  opacity: 0.6;
}

/* Smaller Headings */
h4 {
  font-size: clamp(16px, 2vw, 20px);
  margin: 1.2rem auto 0.8rem;
  font-weight: 500;
  color: var(--paper-muted);
}

h5, h6 {
  font-size: clamp(14px, 1.8vw, 18px);
  margin: 1rem auto 0.6rem;
  font-weight: 500;
  color: var(--paper-muted);
}

/* Text Utilities */
.muted {
  color: var(--paper-muted);
  font-style: italic;
}

.lead {
  font-size: 18px;
  line-height: 1.6;
  text-align: center;
  margin: 1.5rem auto;
  color: var(--accent-ink);
  font-weight: 400;
}

/* Enhanced Separator Rule */
.rule {
  height: 3px;
  background: linear-gradient(90deg, 
    transparent, 
    var(--bronze), 
    var(--gold), 
    var(--bronze), 
    transparent);
  margin: 2rem auto;
  border-radius: 2px;
  opacity: 0.8;
  position: relative;
}

.rule::before {
  content: 'â‹';
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  background: var(--paper);
  color: var(--gold);
  padding: 0 8px;
  font-size: 14px;
}

/* Decorative Separators */
.separator-ornate {
  text-align: center;
  margin: 2.5rem auto;
  font-size: 1.5em;
  color: var(--gold);
  opacity: 0.7;
}

.separator-ornate::before {
  content: 'â—† â‹ â—†';
}

/* Centered Text Blocks */
.text-center {
  text-align: center;
}

.text-center-block {
  text-align: center;
  margin: 1.5rem auto;
  max-width: 800px;
}

/* Mobile Typography Adjustments */
@media (max-width: 480px) {
  h1::before, h1::after,
  h3::before, h3::after {
    display: none;
  }
  
  .rule::before {
    font-size: 12px;
    padding: 0 6px;
  }
  
  .lead {
    font-size: 16px;
    margin: 1rem auto;
  }
}
/* === UTILITY CLASSES === */

/* Spacing utilities */
.m-0{margin:0} .m-1{margin:var(--space-xs)} .m-2{margin:var(--space-md)} .m-3{margin:var(--space-lg)} .m-4{margin:var(--space-xl)}
.mt-0{margin-top:0} .mt-1{margin-top:var(--space-xs)} .mt-2{margin-top:var(--space-md)} .mt-3{margin-top:var(--space-lg)}
.mb-0{margin-bottom:0} .mb-1{margin-bottom:var(--space-xs)} .mb-2{margin-bottom:var(--space-md)} .mb-3{margin-bottom:var(--space-lg)}
.p-0{padding:0} .p-1{padding:var(--space-xs)} .p-2{padding:var(--space-md)} .p-3{padding:var(--space-lg)} .p-4{padding:var(--space-xl)}

/* Flex utilities */
.flex{display:flex} .flex-col{flex-direction:column} .flex-wrap{flex-wrap:wrap}
.items-center{align-items:center} .items-start{align-items:flex-start} .items-end{align-items:flex-end}
.justify-center{justify-content:center} .justify-start{justify-content:flex-start} .justify-end{justify-content:flex-end}
.gap-1{gap:var(--space-xs)} .gap-2{gap:var(--space-md)} .gap-3{gap:var(--space-lg)}

/* Element color utilities */
.text-feu{color:var(--feu)} .text-air{color:var(--air)} .text-eau{color:var(--eau)} .text-terre{color:var(--terre)} .text-divin{color:var(--divin)} .text-malefique{color:var(--malefique)}
.bg-feu{background:var(--feu-bg);border-color:var(--feu-border)} .bg-air{background:var(--air-bg);border-color:var(--air-border)}
.bg-eau{background:var(--eau-bg);border-color:var(--eau-border)} .bg-terre{background:var(--terre-bg);border-color:var(--terre-border)}
.bg-divin{background:var(--divin-bg);border-color:var(--divin-border)} .bg-malefique{background:var(--malefique-bg);border-color:var(--malefique-border)}

/* Grid utilities */
.grid{display:grid;gap:var(--space-lg)}
.cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}
.cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}
@media (max-width: 900px){ .cols-3{grid-template-columns:1fr} }
@media (max-width: 768px){ .cols-2{grid-template-columns:1fr !important} }

/* Misc utilities */
.subclass-stack{display:flex;flex-direction:column;gap:var(--space-lg)}
.chip{font-size:14px;border:2px solid var(--rule);border-radius:999px;padding:6px 12px;background:rgba(155,107,47,.12);font-weight:600;box-shadow:0 2px 6px rgba(0,0,0,.1)}
.chips{display:flex;flex-wrap:wrap;gap:8px;justify-content:center}
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ—ï¸ LAYOUT SYSTEM - Enhanced Responsive Design
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Main Shell Layout */
.shell {
  display: grid;
  grid-template-rows: 1fr auto;
  min-height: 100svh;
  position: relative;
}

/* Main Content Area - Enhanced Parchment Background */
.page {
  position: relative;
  min-height: 100vh;
  padding: 18px; /* Equal padding all around */
  transition: padding var(--transition-normal);
  background: 
    var(--parchment-texture),
    var(--aged-paper),
    var(--paper);
}

/* Content Container - Dynamic Centering (handled by JavaScript) */
#views {
  max-width: 1400px;
  /* Fallback positioning - will be overridden by DynamicCentering.js */
  margin-left: 370px; /* Just clear the sidebar */
  margin-right: 20px;
  padding: 0 var(--space-lg);
  animation: fadeInUp 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

/* Mobile Responsiveness */
@media (max-width: 980px) { 
  .page {
    padding: 12px;
    background: var(--paper);
  }
  
  #views {
    margin-left: 0; /* Reset sidebar margin on mobile */
    margin-right: 0;
    padding: 0 var(--space-md);
    max-width: 100%;
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Enhanced Sidebar Navigation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.sidebar {
  position: fixed;
  top: 0;
  left: 0;
  width: 350px;
  height: 100vh;
  overflow-y: auto;
  overflow-x: hidden;
  z-index: 100;
  background: 
    var(--parchment-texture),
    linear-gradient(180deg, var(--paper), rgba(244,240,230,0.95)),
    var(--aged-paper);
  backdrop-filter: blur(8px);
  border-right: 4px solid transparent;
  border-image: var(--parchment-border) 1;
  box-shadow: 
    4px 0 20px rgba(0,0,0,0.08),
    inset -1px 0 0 rgba(212,175,55,0.1);
  transition: transform var(--transition-normal);
}

.sidebar::before {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  width: 2px;
  height: 100%;
  background: linear-gradient(180deg, 
    var(--gold) 0%, 
    var(--bronze) 50%, 
    var(--gold) 100%);
  opacity: 0.6;
}

/* Mobile Sidebar with Collapsible Navigation */
@media (max-width: 980px) { 
  .sidebar {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: auto;
    max-height: 80vh;
    background: 
      linear-gradient(135deg, var(--card), rgba(244,240,230,0.98)),
      radial-gradient(circle at 50% 30%, rgba(212,175,55,0.05), transparent 70%);
    border-right: none;
    border-bottom: 3px solid var(--rule);
    backdrop-filter: blur(8px);
    box-shadow: 
      0 8px 32px rgba(0,0,0,0.15),
      inset 0 -1px 0 rgba(212,175,55,0.1);
    transform: translateY(-100%);
    transition: transform var(--transition-normal);
    z-index: 200;
    overflow-y: auto;
  }
  
  .sidebar.mobile-open {
    transform: translateY(0);
  }
  
  /* Adjust page layout for mobile */
  .page {
    padding: 80px 12px 12px 12px; /* Top padding for mobile nav button */
  }
  
  .sidebar::before {
    display: none;
  }
  
  /* Mobile Navigation Toggle Button */
  .mobile-nav-toggle {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 300;
    background: linear-gradient(135deg, var(--gold), var(--bronze));
    color: white;
    border: 2px solid var(--rule);
    border-radius: 12px;
    padding: 12px 16px;
    cursor: pointer;
    box-shadow: 
      0 6px 20px rgba(0,0,0,.15),
      inset 0 1px 0 rgba(255,255,255,.2);
    transition: all var(--transition-fast);
    font-family: 'Cinzel', serif;
    font-weight: 600;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 44px;
    min-height: 44px;
    justify-content: center;
  }
  
  .mobile-nav-toggle:hover {
    transform: scale(1.05);
    box-shadow: 
      0 8px 25px rgba(0,0,0,.2),
      inset 0 1px 0 rgba(255,255,255,.3);
  }
  
  .mobile-nav-toggle:active {
    transform: scale(0.98);
  }
  
  .mobile-nav-toggle .icon {
    font-size: 16px;
    transition: transform var(--transition-fast);
  }
  
  .mobile-nav-toggle.open .icon {
    transform: rotate(180deg);
  }
  
  /* Hide toggle on desktop */
  @media (min-width: 981px) {
    .mobile-nav-toggle {
      display: none;
    }
  }
}
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Enhanced Panel System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.panel {
  background: 
    linear-gradient(135deg, var(--card), rgba(250,246,238,0.9)),
    radial-gradient(circle at 20% 30%, rgba(212,175,55,0.03), transparent 70%);
  border: 2px solid var(--rule);
  border-radius: 18px;
  box-shadow: 
    var(--card-shadow),
    inset 0 1px 0 rgba(255,255,255,0.1);
  padding: 18px;
  position: relative;
  overflow: hidden;
  margin: 12px;
  transition: all var(--transition-normal);
  backdrop-filter: blur(2px);
}

.panel::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, 
    transparent, 
    var(--gold), 
    var(--bronze), 
    var(--gold), 
    transparent);
  opacity: .6;
}

.panel::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--bronze), transparent);
  opacity: .3;
}

.panel:hover {
  transform: translateY(-1px);
  box-shadow: 
    0 8px 32px rgba(0,0,0,.12),
    0 2px 8px rgba(139,69,19,.1),
    inset 0 1px 0 rgba(255,255,255,.15);
}

/* Table of Contents */
.toc {
  max-height: calc(100vh - 150px);
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-width: thin;
  scrollbar-color: var(--bronze) transparent;
}

.toc::-webkit-scrollbar {
  width: 6px;
}

.toc::-webkit-scrollbar-track {
  background: transparent;
}

.toc::-webkit-scrollbar-thumb {
  background: var(--bronze);
  border-radius: 3px;
}

.toc::-webkit-scrollbar-thumb:hover {
  background: var(--gold);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Enhanced TOC Styling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.toc h4 {
  margin: 8px 10px 12px;
  color: var(--bronze);
  text-transform: uppercase;
  font-size: 13px;
  letter-spacing: 0.15em;
  font-weight: 700;
  font-family: 'Cinzel', serif;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
  position: relative;
  padding-bottom: 6px;
  text-align: center;
}

.toc h4::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 2px;
  background: linear-gradient(90deg, var(--bronze), transparent);
  border-radius: 1px;
}

/* Hierarchical TOC Sections */
.toc-section {
  margin-bottom: 8px;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid rgba(139,69,19,0.1);
  background: linear-gradient(135deg, 
    rgba(255,248,220,0.3) 0%, 
    rgba(212,175,55,0.05) 100%);
}

.toc-section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 12px;
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.15) 0%, 
    rgba(139,69,19,0.08) 100%);
  cursor: pointer;
  transition: all var(--transition-normal);
  border-bottom: 1px solid rgba(139,69,19,0.1);
}

.toc-section-header:hover {
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.25) 0%, 
    rgba(139,69,19,0.15) 100%);
  transform: translateY(-1px);
}

.toc-section-title {
  font-weight: 600;
  font-family: 'Cinzel', serif;
  color: var(--bronze);
  font-size: 14px;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
}

.toc-section-toggle {
  color: var(--bronze);
  font-size: 12px;
  transition: transform var(--transition-normal);
  opacity: 0.7;
}

.toc-section.collapsed .toc-section-toggle {
  transform: rotate(-90deg);
}

.toc-section-content {
  padding: 6px;
  max-height: none; /* Permettre l'expansion automatique par dÃ©faut */
  overflow: visible;
  transition: max-height var(--transition-normal), opacity var(--transition-normal);
}

.toc-section-content .toc-category {
  /* Remove scroll limits - let everything be visible naturally */
  max-height: none;
  overflow: visible;
}

.toc-section.collapsed .toc-section-content {
  max-height: 0 !important;
  opacity: 0 !important;
  padding-top: 0;
  padding-bottom: 0;
  overflow: hidden;
}
.toc a {
  display: flex;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 12px;
  color: inherit;
  border: 2px solid transparent;
  transition: all var(--transition-normal);
  position: relative;
  overflow: hidden;
  font-weight: 500;
  margin: 2px 0;
  backdrop-filter: blur(1px);
}
.toc a::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, 
    transparent, 
    rgba(212,175,55,.2), 
    rgba(139,69,19,.1), 
    transparent);
  transition: left 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  z-index: 0;
}
.toc a:hover {
  transform: translateX(6px) scale(1.02);
  background: 
    linear-gradient(135deg, rgba(212,175,55,.12), rgba(139,69,19,.08));
  border-color: rgba(139,69,19,.4);
  box-shadow: 
    0 6px 20px rgba(139,69,19,.2),
    inset 0 1px 3px rgba(212,175,55,.25),
    inset 0 -1px 1px rgba(139,69,19,.1);
  color: var(--accent-ink);
}

.toc a:hover::before {
  left: 100%;
}
.toc a > *{position:relative; z-index:1}
.toc a.active {
  background: linear-gradient(135deg, 
    rgba(212,175,55,.18), 
    rgba(139,69,19,.12));
  border-color: var(--gold);
  box-shadow: 
    inset 0 2px 6px rgba(212,175,55,.3),
    inset 0 -1px 2px rgba(139,69,19,.2),
    0 2px 8px rgba(139,69,19,.1);
  transform: translateX(4px) scale(1.01);
  color: var(--accent-ink);
  font-weight: 600;
}
.toc-category{margin:0}
.toc-category > a{position:relative; cursor:pointer}
.toc-category > a::after{content:'â–¼'; position:absolute; right:8px; top:50%; transform:translateY(-50%); 
                         font-size:10px; transition:transform .3s ease; color:var(--bronze)}
.toc-category.collapsed > a::after{transform:translateY(-50%) rotate(-90deg)}
.toc-sub{margin-left:24px;border-left:2px solid var(--rule);padding-left:8px; 
         overflow:hidden; transition:all .3s ease}
.toc-category.collapsed .toc-sub{max-height:0; opacity:0; padding-top:0; padding-bottom:0; margin-top:0; margin-bottom:0}
.toc-category:not(.collapsed) .toc-sub{max-height: none; opacity:1}
.toc-sub a{font-size:14px;padding:6px 8px; margin-left:4px}
.toc-sub a:hover{transform:translateX(6px); margin-left:0}

/* Outils latÃ©raux */
.tools{display:flex;gap:var(--space-md);flex-wrap:wrap;margin:var(--space-md) 0}

/* Article and section layout */
article{display:none}
article.active{display:block}
section{background:var(--card);border:1px solid var(--rule);border-radius:14px;box-shadow:var(--shadow);padding:18px;margin:0 0 14px}

/* Footer */
footer{padding:24px;text-align:center;color:var(--paper-muted)}

/* Print styles */
@media print{ 
  .sidebar, .tools{display:none} 
  .page{grid-template-columns:1fr;padding:0} 
  section{break-inside:avoid;box-shadow:none} 
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Enhanced Mobile & Tablet Responsiveness â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* Tablet Landscape (1024px and below) */
@media (max-width: 1024px) {
  .sidebar {
    width: 320px;
  }
  
  .page {
    padding-left: 340px;
  }
  
  #views {
    margin-left: 340px; /* Adjust for smaller sidebar */
    margin-right: 0;
    max-width: 100%;
    padding: 0 var(--space-md);
  }
}

/* Tablet Portrait (768px and below) */
@media (max-width: 768px) {
  #views {
    margin-left: 0; /* Reset margins for tablet portrait */
    margin-right: 0;
  }
  
  .illus .thumb { 
    width: 100%; 
    max-width: 280px; 
    height: auto; 
  }
  
  .card, .card-base {
    margin: 1rem 0;
    padding: 16px;
  }
  
  .btn-base {
    padding: var(--space-sm) var(--space-md);
    font-size: 0.9em;
  }
  
  .filter-chips {
    gap: 0.5rem;
  }
  
  .filter-chip {
    padding: 6px 12px;
    font-size: 0.85em;
  }
}

/* Mobile (480px and below) - Standalone Version Optimized */
@media (max-width: 480px) {
  .page {
    padding: 8px;
  }
  
  #views {
    padding: 0 var(--space-sm);
  }
  
  .panel {
    margin: 8px;
    padding: 12px;
    border-radius: 12px;
  }
  
  .card, .card-base {
    padding: 12px;
    margin: 0.8rem 0;
    border-radius: 12px;
  }
  
  .spell-title {
    font-size: clamp(1rem, 3vw, 1.2rem) !important;
    margin: 0 0 0.8rem 0 !important;
  }
  
  .btn-base {
    padding: var(--space-sm);
    font-size: 0.85em;
    gap: var(--space-sm);
  }
  
  .filter-chips {
    gap: 0.4rem;
  }
  
  .filter-chip {
    padding: 4px 8px;
    font-size: 0.8em;
    border-radius: 16px;
  }
  
  /* Mobile-optimized images */
  .illus img {
    max-width: 100% !important;
    width: auto !important;
    height: auto !important;
  }
  
  .illus-spell img,
  .card .illus img {
    max-width: 240px !important;
    max-height: 180px !important;
  }
  
  /* Mobile TOC enhancements */
  .toc a {
    padding: 8px 10px;
    font-size: 0.9em;
  }
  
  .toc-sub a {
    padding: 6px 8px;
    font-size: 0.85em;
  }
  
  /* Mobile search optimizations */
  .searchbar {
    flex-direction: column;
    gap: var(--space-sm);
  }
  
  .searchbar input {
    width: 100%;
    font-size: 16px; /* Prevents zoom on iOS */
  }
  
  .search-results-grid {
    grid-template-columns: 1fr;
    gap: var(--space-md);
  }
  
  .search-result-card {
    min-height: 120px;
    padding: var(--space-md);
  }
}
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ¨ COMPONENT SYSTEM - Modern Heroic Fantasy Design
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Typography Components â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.spell-title {
  font-family: "Cinzel", serif !important;
  font-size: clamp(1.2rem, 2.5vw, 1.4rem) !important;
  background: linear-gradient(135deg, var(--gold), var(--bronze), var(--gold)) !important;
  -webkit-background-clip: text !important;
  -webkit-text-fill-color: transparent !important;
  background-clip: text !important;
  font-weight: 600 !important;
  text-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
  letter-spacing: 0.8px !important;
  text-transform: uppercase !important;
  text-align: center !important;
  margin: 0 0 1rem 0 !important;
  position: relative !important;
}

.spell-title::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 60px;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--gold), transparent);
  opacity: 0.7;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Page Header Components â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.page-header {
  text-align: center;
  margin: 2rem auto;
  max-width: 1200px;
  padding: 0 var(--space-lg);
}

.page-header h1 {
  color: var(--gold);
  font-family: "Cinzel", serif;
  font-size: 2.5rem;
  margin-bottom: 1rem;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
}

/* Content centering for all page types */
.page-content {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 var(--space-lg);
}

/* Fallback centering for collections and similar content without specific containers */
.editable-section {
  max-width: 1200px;
  margin-left: auto;
  margin-right: auto;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Collections Page Components â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.collections-search {
  margin: 2rem auto;
  text-align: center;
  max-width: 1200px;
  padding: 0 var(--space-lg);
}

.search-container {
  display: flex;
  gap: 1rem;
  justify-content: center;
  align-items: center;
  flex-wrap: wrap;
}

.search-input {
  padding: 12px 16px;
  font-size: 1.1rem;
  border: 2px solid var(--bronze);
  border-radius: 8px;
  background: var(--card);
  color: var(--text);
  min-width: 300px;
  font-family: "Source Serif Pro", serif;
}

.search-input:focus {
  outline: none;
  border-color: var(--gold);
  box-shadow: 0 0 8px rgba(212, 175, 55, 0.3);
}

.search-button {
  padding: 12px 20px;
  background: linear-gradient(135deg, var(--gold), var(--bronze));
  color: var(--dark-text);
  border: none;
  border-radius: 8px;
  font-weight: 600;
  cursor: pointer;
  font-size: 1rem;
  transition: all 0.3s ease;
}

.search-button:hover {
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(212, 175, 55, 0.4);
}

.collections-grid {
  display: grid;
  gap: 1.5rem; /* Balanced gap */
  margin: 2rem auto;
  max-width: 1400px; /* More space = more columns possible */
  justify-content: center;
  
  /* Use auto-fit with smaller minmax - collections can be smaller */
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
}

.collection-card {
  background: var(--card);
  border: 2px solid var(--bronze);
  border-radius: 12px;
  padding: 1.5rem;
  text-align: center;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
  width: 100%; /* Take full column width */
  margin: 0; /* No margin, use grid gap */
  box-sizing: border-box; /* Include padding and border in width */
}

.collection-card:hover {
  transform: translateY(-2px);
  border-color: var(--gold);
  box-shadow: 0 8px 20px rgba(212, 175, 55, 0.2);
}

.collection-icon {
  font-size: 3rem;
  margin-bottom: 1rem;
}

.collection-card h3 {
  color: var(--gold);
  font-family: "Cinzel", serif;
  margin: 0.5rem 0;
  font-size: 1.3rem;
}

.collection-card p {
  color: var(--text-muted);
  font-size: 0.95rem;
  line-height: 1.4;
  margin: 0;
}

.collection-error {
  background: linear-gradient(135deg, #fee2e2 0%, #fef2f2 100%);
  border: 2px solid #f87171;
  border-radius: 12px;
  padding: 2rem;
  text-align: center;
  margin: 1rem 0;
  animation: fadeIn 0.5s ease;
}

.collection-error h2 {
  color: #dc2626;
  font-family: "Cinzel", serif;
  margin: 0 0 1rem 0;
  font-size: 1.5rem;
}

.collection-error p {
  color: #7f1d1d;
  font-size: 1rem;
  line-height: 1.6;
  margin: 0.5rem 0;
}

.collection-error strong {
  color: #b91c1c;
  font-weight: 600;
}

/* Collection Development Controls */
.collection-dev-controls {
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid var(--bronze);
  display: flex;
  gap: 0.5rem;
  justify-content: center;
}

.collection-dev-actions {
  text-align: center;
  margin: 1rem 0;
}

.edit-object-btn {
  background: var(--gold);
  color: var(--bg);
  border: none;
  padding: 0.4rem 0.8rem;
  border-radius: 6px;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.edit-object-btn:hover {
  background: #c9a96e;
  transform: translateY(-1px);
}

.delete-object-btn {
  background: #ef4444;
  color: white;
  border: none;
  padding: 0.4rem 0.8rem;
  border-radius: 6px;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.delete-object-btn:hover {
  background: #dc2626;
  transform: translateY(-1px);
}

.remove-from-collection-btn {
  background: #f59e0b;
  color: white;
  border: none;
  padding: 0.4rem 0.8rem;
  border-radius: 6px;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.remove-from-collection-btn:hover {
  background: #d97706;
  transform: translateY(-1px);
}

.add-object-btn {
  background: #10B981;
  color: white;
  border: none;
  padding: 0.6rem 1rem;
  border-radius: 8px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
  font-weight: 500;
}

.add-object-btn:hover {
  background: #059669;
  transform: translateY(-1px);
  box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
}

/* New collection card styling */
.new-collection-card {
  border: 2px dashed var(--bronze) !important;
  background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%) !important;
}

.new-collection-card:hover {
  border-color: var(--gold) !important;
  background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%) !important;
}

.create-collection-btn {
  background: var(--gold);
  color: var(--bg);
  border: none;
  padding: 0.5rem 1rem;
  border-radius: 6px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.2s ease;
  font-weight: 500;
  margin-top: 0.5rem;
}

.create-collection-btn:hover {
  background: #c9a96e;
  transform: translateY(-1px);
}

/* Hide dev controls in dev-off mode */
body.dev-off .collection-dev-controls,
body.dev-off .collection-dev-actions,
body.dev-off .new-collection-card {
  display: none !important;
}

.collection-results {
  margin: 2rem 0;
}

.collection-header {
  text-align: center;
  margin-bottom: 2rem;
  padding: 1.5rem;
  background: var(--accent-bg);
  border-radius: 12px;
  border: 2px solid var(--gold);
}

.collection-header h2 {
  color: var(--gold);
  font-family: "Cinzel", serif;
  margin: 0 0 0.5rem 0;
  font-size: 1.8rem;
}

.back-button {
  background: var(--secondary-bg);
  color: var(--text);
  border: 1px solid var(--bronze);
  padding: 8px 16px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.9rem;
  margin-top: 1rem;
  transition: all 0.3s ease;
}

.back-button:hover {
  background: var(--bronze);
  color: white;
}

.tag-filters {
  margin: 1.5rem 0;
  text-align: center;
}

.tag-filters h3 {
  color: var(--text);
  font-family: "Cinzel", serif;
  margin-bottom: 1rem;
  font-size: 1.2rem;
}

.tag-buttons {
  display: flex;
  gap: 0.5rem;
  justify-content: center;
  flex-wrap: wrap;
}

.tag-filter-btn {
  padding: 8px 16px;
  background: var(--secondary-bg);
  color: var(--text);
  border: 1px solid var(--bronze);
  border-radius: 20px;
  cursor: pointer;
  font-size: 0.9rem;
  transition: all 0.3s ease;
}

.tag-filter-btn:hover,
.tag-filter-btn.active {
  background: var(--gold);
  color: var(--dark-text);
  border-color: var(--gold);
}

.collection-items {
  display: grid;
  gap: 1.5rem; /* Balanced gap */
  margin: 2rem auto;
  max-width: 1400px; /* More space = more columns possible */
  justify-content: center;
  
  /* Use auto-fit with smaller minmax to allow more columns */
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
}

/* Consistent sizing for object cards within collections */
.collection-items .card {
  width: 100%; /* Take full column width */
  margin: 0; /* Remove default margin, use grid gap instead */
  box-sizing: border-box; /* Include padding and border in width calculation */
}

/* Objects page container optimization for better space usage */
#objets-container {
  display: grid;
  gap: 1.5rem;
  justify-content: center;
  align-items: start;
  padding: 0;
  margin: 2rem auto;
  max-width: 1400px; /* Increase max width for better space usage */
  
  /* Responsive grid: 1 to 4 objects per row based on screen size */
  grid-template-columns: 1fr;
}

/* 2 objects per row on small tablets */
@media (min-width: 640px) {
  #objets-container {
    grid-template-columns: repeat(2, 1fr);
  }
}

/* 3 objects per row on tablets/small desktop */
@media (min-width: 960px) {
  #objets-container {
    grid-template-columns: repeat(3, 1fr);
  }
}

/* 4 objects per row on large desktop */
@media (min-width: 1280px) {
  #objets-container {
    grid-template-columns: repeat(4, 1fr);
  }
}

/* 5 objects per row on extra large desktop */
@media (min-width: 1600px) {
  #objets-container {
    grid-template-columns: repeat(5, 1fr);
    max-width: 1600px;
  }
}

/* Object cards sizing optimization */
#objets-container .card {
  min-width: 280px;
  max-width: 350px;
  width: 100%;
  margin: 0; /* Remove default margin, use grid gap instead */
}

/* Mobile optimization for objects page */
@media (max-width: 640px) {
  #objets-container {
    padding: 0 1rem;
    gap: 1rem;
  }
  
  #objets-container .card {
    min-width: auto;
    max-width: none;
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Card System Enhanced - Authentic Parchment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.card,
.card-base {
  background: 
    var(--parchment-texture),
    var(--aged-paper),
    var(--card);
  border: 3px solid transparent;
  border-image: var(--parchment-border) 1;
  border-radius: 16px;
  box-shadow: 
    0 8px 32px rgba(139,69,19,.2),
    0 2px 8px rgba(139,69,19,.15),
    inset 0 1px 0 rgba(255,255,255,.2),
    inset 0 -1px 0 rgba(139,69,19,.08);
  padding: 20px;
  position: relative;
  overflow: hidden;
  transition: all var(--transition-normal);
  backdrop-filter: blur(1px);
}

.card::before,
.card-base::before {
  content: '';
  position: absolute;
  top: 2px;
  left: 2px;
  right: 2px;
  bottom: 2px;
  border: 1px solid rgba(139,69,19,.15);
  border-radius: 13px;
  pointer-events: none;
}

.card::after,
.card-base::after {
  content: '';
  position: absolute;
  top: 4px;
  left: 4px;
  right: 4px;
  height: 2px;
  background: 
    radial-gradient(ellipse at center, rgba(212,175,55,.3) 0%, transparent 60%),
    linear-gradient(90deg, transparent, rgba(139,69,19,.2), transparent);
  opacity: .6;
}

.card:hover,
.card-base:hover {
  transform: translateY(-3px) scale(1.01);
  box-shadow: 
    0 16px 48px rgba(139,69,19,.25),
    0 6px 16px rgba(139,69,19,.18),
    inset 0 1px 0 rgba(255,255,255,.3),
    inset 0 -1px 0 rgba(139,69,19,.12);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Button System Enhanced â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.btn-base {
  display: inline-flex;
  gap: var(--space-md);
  align-items: center;
  background: linear-gradient(135deg, var(--card), rgba(244,240,230,0.8));
  border: 2px solid var(--rule);
  border-radius: 12px;
  padding: var(--space-md) var(--space-lg);
  box-shadow: 
    0 4px 16px rgba(0,0,0,.08),
    0 2px 4px rgba(139,69,19,.1),
    inset 0 1px 0 rgba(255,255,255,.2);
  cursor: pointer;
  transition: all var(--transition-fast);
  font-weight: 500;
  font-family: "Source Serif Pro", serif;
  text-transform: capitalize;
  position: relative;
  overflow: hidden;
}

.btn-base::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(212,175,55,.15), transparent);
  transition: left var(--transition-normal);
}

.btn-base:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow: 
    0 8px 32px rgba(0,0,0,.15),
    0 4px 8px rgba(139,69,19,.12),
    inset 0 1px 0 rgba(255,255,255,.3);
  border-color: var(--bronze);
}

.btn-base:hover::before {
  left: 100%;
}

.btn-base:active {
  transform: translateY(-1px) scale(1.01);
  transition: all 0.1s ease;
}

.btn-small {
  padding: var(--space-sm) var(--space-md);
  font-size: 0.9em;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Card Variants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.card-enhanced {
  margin: 1.5rem 0;
  animation: cardEntry 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.card.spell-card {
  border-left: 4px solid var(--feu);
  background: linear-gradient(135deg, var(--card), rgba(255,107,53,0.02));
}

.card.don-card {
  border-left: 4px solid var(--bronze);
  background: linear-gradient(135deg, var(--card), rgba(205,127,50,0.02));
}

.card.class-card {
  border-left: 4px solid var(--gold);
  background: linear-gradient(135deg, var(--card), rgba(212,175,55,0.02));
}

@keyframes cardEntry {
  0% {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Enhanced Tags & Filters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.tag-filters {
  margin: 1.5rem 0;
  padding: 1.5rem;
  background: 
    linear-gradient(135deg, var(--card), rgba(244,240,230,0.9)),
    radial-gradient(circle at 20% 50%, rgba(212,175,55,0.05), transparent),
    radial-gradient(circle at 80% 50%, rgba(139,69,19,0.03), transparent);
  border: 2px solid var(--rule);
  border-radius: 16px;
  box-shadow: 
    0 4px 20px rgba(0,0,0,.08),
    inset 0 1px 0 rgba(255,255,255,.1);
  position: relative;
  overflow: hidden;
}

.tag-filters::before {
  content: 'ğŸ·ï¸ Filtres';
  position: absolute;
  top: -1px;
  left: 20px;
  background: var(--card);
  padding: 4px 12px;
  font-size: 0.85em;
  font-weight: 600;
  color: var(--bronze);
  border: 2px solid var(--rule);
  border-top: none;
  border-radius: 0 0 8px 8px;
  font-family: "Cinzel", serif;
}

.filter-chips {
  display: flex;
  gap: 0.75rem;
  flex-wrap: wrap;
  margin-top: 0.5rem;
}

.filter-chip {
  padding: 8px 16px;
  background: linear-gradient(135deg, var(--bronze), rgba(205,127,50,0.9));
  color: white;
  border-radius: 20px;
  font-size: 0.9em;
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition-fast);
  border: 2px solid transparent;
  box-shadow: 
    0 2px 8px rgba(0,0,0,.1),
    inset 0 1px 0 rgba(255,255,255,.2);
  position: relative;
  overflow: hidden;
}

.filter-chip::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,.2), transparent);
  transition: left var(--transition-fast);
}

.filter-chip:hover {
  background: linear-gradient(135deg, var(--gold), rgba(212,175,55,0.9));
  transform: translateY(-2px) scale(1.05);
  box-shadow: 
    0 6px 20px rgba(0,0,0,.15),
    inset 0 1px 0 rgba(255,255,255,.3);
}

.filter-chip:hover::before {
  left: 100%;
}

.filter-chip.active {
  background: linear-gradient(135deg, var(--accent-ink), rgba(74,44,23,0.9));
  border-color: var(--gold);
  transform: scale(1.02);
  box-shadow: 
    0 4px 16px rgba(0,0,0,.2),
    inset 0 1px 0 rgba(255,255,255,.1);
}

.tag-chip {
  display: inline-block;
  padding: 2px 8px;
  background: var(--bronze);
  color: white;
  border-radius: 8px;
  font-size: 0.8em;
  font-weight: 500;
  margin: 2px;
}

/* Gestionnaire de filtres */
.filter-manager-btn {
  background: var(--bronze) !important;
  color: white !important;
}

.filter-manager-btn:hover {
  background: var(--accent) !important;
}

.modal{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);z-index:999999;display:flex;align-items:center;justify-content:center}
.modal-base{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);z-index:99999;display:none;align-items:center;justify-content:center}
.modal-base.visible{display:flex}
.modal-content-base{background:var(--card);border:2px solid var(--rule);border-radius:16px;padding:var(--space-2xl);box-shadow:var(--shadow);position:relative}

/* Legacy Cards - Enhanced with Modern Styling */
.card{
  border:2px solid var(--rule);
  border-radius:16px;
  padding:20px;
  background:linear-gradient(145deg, #faf7f0, var(--card), #f8f4e8);
  box-shadow:
    0 8px 32px rgba(0,0,0,.12),
    0 2px 8px rgba(139,69,19,.08),
    inset 0 1px 0 rgba(255,255,255,.1);
  position:relative;
  overflow:hidden;
  transition: all var(--transition-normal);
  backdrop-filter: blur(1px);
}

.card::before{
  content:'';
  position:absolute;
  top:0;
  left:0;
  right:0;
  height:3px;
  background:linear-gradient(90deg, transparent, var(--gold), var(--bronze), var(--gold), transparent);
  opacity:.8;
}

.card::after{
  content:'';
  position:absolute;
  bottom:0;
  left:0;
  right:0;
  height:1px;
  background:linear-gradient(90deg, transparent, var(--bronze), transparent);
  opacity:.5;
}

.card:hover {
  transform: translateY(-2px);
  box-shadow: 
    0 12px 48px rgba(0,0,0,.15),
    0 4px 12px rgba(139,69,19,.12),
    inset 0 1px 0 rgba(255,255,255,.15);
  border-color: var(--gold);
}
.card ul, ul{padding-left:35px !important;margin-left:0 !important}

/* Buttons */
.btn{display:inline-flex;gap:var(--space-md);align-items:center;background:var(--card);border:2px solid var(--rule);border-radius:12px;padding:var(--space-md) var(--space-lg);box-shadow:var(--card-shadow);cursor:pointer;
     transition:var(--transition-fast); font-weight:500}
.btn:hover{transform:translateY(-1px); box-shadow:0 8px 25px rgba(0,0,0,.15); border-color:var(--bronze)}
.btn.small{padding:var(--space-sm) var(--space-md)}

/* Search bar */
.searchbar{display:flex;gap:var(--space-md);align-items:center}
.searchbar input{flex:1 1 auto;max-width:100%;height:38px;font-size:15px;padding:var(--space-md) 10px;border-radius:10px;border:1px solid var(--rule);background:#fff6e8;color:inherit}
.searchbar button{height:38px}

/* Search results */
.search-results-container {
  font-size: 14px;
  line-height: 1.4;
}

.search-results-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: var(--gold);
  color: #4a4a4a;
  font-weight: 500;
  border-bottom: 1px solid var(--bronze);
}

.search-close {
  background: none;
  border: none;
  font-size: 16px;
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 4px;
  transition: background-color 0.2s;
}

.search-close:hover {
  background: rgba(0,0,0,0.1);
}

.search-results-list {
  max-height: 320px;
  overflow-y: auto;
}

.search-result-item {
  padding: 10px 12px;
  border-bottom: 1px solid #f0f0f0;
  cursor: pointer;
  transition: background-color 0.2s;
}

.search-result-item:hover {
  background: #f8f4e8;
}

.search-result-item:last-child {
  border-bottom: none;
}

.search-result-summary {
  font-weight: 500;
  color: #333;
  margin-bottom: 2px;
}

.search-result-category {
  font-size: 12px;
  color: #666;
  opacity: 0.8;
}

.search-no-results {
  padding: 20px;
  text-align: center;
  color: #666;
}

.search-no-results p {
  margin: 0;
  font-style: italic;
}

/* Search results page */
.search-page {
  padding: var(--space-lg);
}

.search-page-header {
  margin-bottom: var(--space-xl);
  text-align: center;
  border-bottom: 2px solid var(--rule);
  padding-bottom: var(--space-lg);
}

.search-page-header h1 {
  color: var(--gold);
  margin-bottom: var(--space-md);
  font-family: var(--font-title);
}

.search-results-count {
  color: #666;
  margin-bottom: var(--space-lg);
  font-style: italic;
}

.search-results-grid {
  display: grid;
  gap: var(--space-lg);
  max-width: 800px;
  margin: 0 auto;
  grid-template-columns: 1fr;
}

.search-result-card {
  cursor: pointer;
  transition: all 0.2s ease;
  border: 2px solid var(--rule);
  background: var(--card);
  padding: var(--space-lg);
  border-radius: 14px;
  box-shadow: var(--card-shadow);
  /* Force visibility */
  display: block !important;
  visibility: visible !important;
  opacity: 1 !important;
  min-height: 150px;
}

.search-result-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(0,0,0,0.15);
  border-color: var(--bronze);
}

.search-result-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: var(--space-md);
}

.search-result-header h3 {
  margin: 0;
  color: var(--bronze);
  font-size: 1.2em;
  text-align: center;
}

.search-result-type {
  background: var(--gold);
  color: #4a4a4a;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 0.8em;
  font-weight: 500;
}

.search-result-content {
  margin-bottom: var(--space-lg);
}

.search-result-summary {
  font-weight: 500;
  margin-bottom: var(--space-md);
  color: #333;
  font-size: 1.05em;
  padding: var(--space-sm);
  background: linear-gradient(90deg, var(--gold), transparent);
  border-radius: 4px;
  opacity: 0.9;
}

.search-result-category {
  font-size: 0.9em;
  color: #666;
  margin-bottom: var(--space-md);
}

.search-result-preview {
  background: #f8f4e8;
  padding: var(--space-md);
  border-radius: 8px;
  border-left: 3px solid var(--bronze);
}

.preview-field {
  margin-bottom: var(--space-sm);
  line-height: 1.4;
  font-size: 0.9em;
  padding: var(--space-sm);
  background: rgba(0,0,0,0.02);
  border-left: 3px solid var(--gold);
  border-radius: 0 4px 4px 0;
}

.preview-field:last-child {
  margin-bottom: 0;
}

.preview-field strong {
  color: var(--bronze);
  font-weight: 600;
}

.search-result-footer {
  text-align: right;
  padding-top: var(--space-md);
  border-top: 1px solid #eee;
}

.search-result-btn {
  background: var(--bronze);
  color: white;
  border-color: var(--bronze);
}

.search-result-btn:hover {
  background: #b8860b;
  border-color: #b8860b;
}

/* Force search results visibility */
.search-page .search-results-grid .search-result-card {
  display: block !important;
  visibility: visible !important;
  opacity: 1 !important;
  height: auto !important;
  min-height: 150px !important;
  background: var(--card) !important;
  border: 2px solid var(--bronze) !important;
  margin-bottom: var(--space-lg) !important;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Advanced Animations & Transitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* Page Transitions */
@keyframes pageSlideIn {
  0% {
    opacity: 0;
    transform: translateX(30px);
  }
  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes pageSlideInFromTop {
  0% {
    opacity: 0;
    transform: translateY(-20px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Content Animation */
article {
  animation: pageSlideIn 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

article.active {
  animation: pageSlideInFromTop 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

/* Staggered Entry Animation for Lists */
.staggered-entry > * {
  opacity: 0;
  animation: staggeredEntry 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}

.staggered-entry > *:nth-child(1) { animation-delay: 0.1s; }
.staggered-entry > *:nth-child(2) { animation-delay: 0.2s; }
.staggered-entry > *:nth-child(3) { animation-delay: 0.3s; }
.staggered-entry > *:nth-child(4) { animation-delay: 0.4s; }
.staggered-entry > *:nth-child(5) { animation-delay: 0.5s; }
.staggered-entry > *:nth-child(n+6) { animation-delay: 0.6s; }

@keyframes staggeredEntry {
  0% {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* Loading Animation */
@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.loading-shimmer {
  position: relative;
  overflow: hidden;
  background: linear-gradient(90deg, #f0f0f0, #e0e0e0, #f0f0f0);
  animation: shimmer 1.5s infinite linear;
}

.loading-shimmer::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
  animation: shimmer 1.5s infinite linear;
}

/* Floating Elements Animation */
@keyframes float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}

.floating {
  animation: float 3s ease-in-out infinite;
}

.floating:nth-child(2n) {
  animation-delay: 1s;
}

.floating:nth-child(3n) {
  animation-delay: 2s;
}

/* Pulse Animation for Important Elements */
@keyframes pulse {
  0%, 100% { 
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(212, 175, 55, 0.4);
  }
  50% { 
    transform: scale(1.02);
    box-shadow: 0 0 0 10px rgba(212, 175, 55, 0);
  }
}

.pulse-attention {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Text Glow Effect */
@keyframes textGlow {
  0%, 100% {
    text-shadow: 
      0 0 5px rgba(212, 175, 55, 0.2),
      0 0 10px rgba(212, 175, 55, 0.1);
  }
  50% {
    text-shadow: 
      0 0 10px rgba(212, 175, 55, 0.4),
      0 0 20px rgba(212, 175, 55, 0.2),
      0 0 30px rgba(212, 175, 55, 0.1);
  }
}

.text-glow {
  animation: textGlow 3s ease-in-out infinite;
}

/* Enhanced Hover Transitions */
.interactive-element {
  transition: 
    transform var(--transition-fast),
    box-shadow var(--transition-fast),
    background-color var(--transition-fast),
    border-color var(--transition-fast),
    color var(--transition-fast);
}

.interactive-element:hover {
  transform: translateY(-2px) scale(1.02);
}

/* Magical Sparkle Effect */
@keyframes sparkle {
  0%, 100% { opacity: 0; transform: scale(0); }
  50% { opacity: 1; transform: scale(1); }
}

.sparkle-effect::before {
  content: 'âœ¨';
  position: absolute;
  top: -5px;
  right: -5px;
  font-size: 0.8em;
  animation: sparkle 2s ease-in-out infinite;
  animation-delay: 0.5s;
}

.sparkle-effect::after {
  content: 'â­';
  position: absolute;
  bottom: -5px;
  left: -5px;
  font-size: 0.6em;
  animation: sparkle 2s ease-in-out infinite;
  animation-delay: 1.5s;
}

/* Smooth Content Transitions */
.content-transition {
  transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

.content-fade-in {
  animation: fadeInUp 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

@keyframes fadeInUp {
  0% {
    opacity: 0;
    transform: translateY(30px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Clean up card styling */

/* Illustrations */
.illus{display:flex;gap:12px;align-items:center;justify-content:center;flex-wrap:wrap;margin:.6rem 0}
.illus img{max-width:100%;height:auto;border-radius:12px; transition:all .3s ease}
.illus img.enlarged{transition:none !important}
.illus .thumb{max-width:500px;max-height:300px;width:auto;height:auto;object-fit:contain}

/* Images avec cadres - systÃ¨me unifiÃ© */
.illus-spell, .illus-class, .illus-subclass, .illus-don,
article[data-page="guerrier"] .illus,
article[data-page="mage"] .illus,
article[data-page="pretre"] .illus,
article[data-page="rodeur"] .illus,
article[data-page="enchanteur"] .illus,
.illus[data-illus-key^="class:"],
.illus[data-illus-key^="subclass:"],
.illus[data-illus-key^="spell:"],
.illus[data-illus-key^="sort:"],
.illus[data-illus-key^="spellcategory:"],
.illus[data-illus-key^="don:"] {
  display:flex !important; flex-direction:column !important; align-items:center !important;
  justify-content:center !important; margin:1rem auto !important;
}

.illus-spell img, .illus-class img, .illus-subclass img, .illus-don img,
article[data-page="guerrier"] .illus img,
article[data-page="mage"] .illus img,
article[data-page="pretre"] .illus img,
article[data-page="rodeur"] .illus img,
article[data-page="enchanteur"] .illus img,
.illus[data-illus-key^="class:"] img,
.illus[data-illus-key^="subclass:"] img,
.illus[data-illus-key^="spell:"] img,
.illus[data-illus-key^="sort:"] img,
.illus[data-illus-key^="spellcategory:"] img,
.illus[data-illus-key^="don:"] img {
  border:var(--image-border) !important; 
  box-shadow:var(--image-shadow) !important;
  padding:4px !important; 
  background:transparent !important;
  border-radius:16px !important; 
  max-width:fit-content !important;
  width:auto !important;
  cursor:pointer !important;
}

.illus-spell img:hover, .illus-class img:hover, .illus-subclass img:hover, .illus-don img:hover,
article[data-page="guerrier"] .illus img:hover,
article[data-page="mage"] .illus img:hover,
article[data-page="pretre"] .illus img:hover,
article[data-page="rodeur"] .illus img:hover,
article[data-page="enchanteur"] .illus img:hover,
.illus[data-illus-key^="class:"] img:hover,
.illus[data-illus-key^="subclass:"] img:hover,
.illus[data-illus-key^="spell:"] img:hover,
.illus[data-illus-key^="sort:"] img:hover,
.illus[data-illus-key^="spellcategory:"] img:hover,
.illus[data-illus-key^="don:"] img:hover {
  transform:scale(1.03) !important; 
  box-shadow:var(--image-shadow), 0 8px 25px rgba(139,69,19,.25) !important;
}

/* Variantes de taille d'images */
.illus-small img { max-width: 150px !important; }
.illus-large img { max-width: 400px !important; }

/* Style spÃ©cial pour les sorts - cadre dorÃ© et taille augmentÃ©e */
.illus-spell img,
.card .illus img {
  border: 3px solid var(--gold) !important;
  box-shadow: var(--image-shadow), 0 0 10px rgba(212,175,55,.3) !important;
  max-width: 350px !important;
  max-height: 250px !important;
  object-fit: contain !important;
}

/* Style spÃ©cial pour les sous-classes - 2 images centrÃ©es et collÃ©es */
.subclass-images {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0;
  margin: 0.6rem 0;
}

.subclass-images .illus {
  margin: 0;
  flex: 0 0 auto;
}

.subclass-images .illus img {
  max-width: 400px !important;
  max-height: 300px !important;
  object-fit: contain !important;
  border-radius: 12px 0 0 12px !important;
}

.subclass-images .illus:last-child img {
  border-radius: 0 12px 12px 0 !important;
}

/* Mobile: Stack subclass images vertically */
@media (max-width: 980px) {
  .subclass-images {
    flex-direction: column !important;
    gap: 8px !important;
  }
  
  .subclass-images .illus img {
    border-radius: 12px !important;
    max-width: 100% !important;
    width: 100% !important;
  }
  
  /* RÃ©duire l'espace des cadres d'images sur mobile */
  .illus-spell img, .illus-class img, .illus-subclass img, .illus-don img,
  article[data-page="guerrier"] .illus img,
  article[data-page="mage"] .illus img,
  article[data-page="pretre"] .illus img,
  article[data-page="rodeur"] .illus img,
  article[data-page="enchanteur"] .illus img,
  .illus[data-illus-key^="class:"] img,
  .illus[data-illus-key^="subclass:"] img,
  .illus[data-illus-key^="spell:"] img,
  .illus[data-illus-key^="sort:"] img,
  .illus[data-illus-key^="spellcategory:"] img,
  .illus[data-illus-key^="don:"] img {
    padding: 2px !important; /* RÃ©duire le padding de 4px Ã  2px */
    border-width: 2px !important; /* RÃ©duire l'Ã©paisseur des bordures */
    max-width: 100% !important;
    width: auto !important;
    height: auto !important;
    object-fit: contain !important;
  }
  
  /* RÃ©duire l'espace entre les images de classe et sous-classe */
  .illus {
    gap: 4px !important; /* RÃ©duire de 12px Ã  4px */
    margin: 0.3rem 0 !important; /* RÃ©duire les marges */
  }
  
  /* Images de sorts plus compactes sur mobile */
  .illus-spell img,
  .card .illus img {
    max-width: 100% !important;
    max-height: 180px !important; /* RÃ©duire de 250px Ã  180px */
    border-width: 2px !important; /* Bordure plus fine */
  }
  
  .subclass-images .illus:last-child img {
    border-radius: 12px !important;
  }
}

/* Style spÃ©cial pour les titres de sous-classes */
.subclass-title {
  font-size: 2.2rem !important;
  font-weight: 800 !important;
  text-align: center !important;
  margin: 0 0 1.5rem 0 !important;
  color: var(--accent-ink) !important;
  font-family: 'Cinzel', serif !important;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.2) !important;
  letter-spacing: 0.8px !important;
}

/* Style spÃ©cial pour les descriptions de sous-classes */
.card[data-section-type="subclass"] .editable[data-edit-section*="description"] {
  text-align: center !important;
  color: var(--paper-ink) !important;
}

.card[data-section-type="subclass"] .editable[data-edit-section*="description"] em,
.card[data-section-type="subclass"] .editable[data-edit-section*="description"] i {
  color: var(--paper-ink) !important;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ“± MOBILE & TOUCH OPTIMIZATION - Final Enhancements
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Touch-friendly interactions for mobile devices */
@media (hover: none) and (pointer: coarse) {
  .btn-base, .filter-chip, .toc a, .card {
    min-height: 44px; /* iOS/Android minimum touch target */
    min-width: 44px;
  }
  
  .toc a {
    padding: 12px;
    margin: 4px 0;
  }
  
  .filter-chip {
    padding: 8px 16px;
    margin: 2px;
  }
  
  /* Disable hover effects on touch devices */
  .card:hover, .btn-base:hover, .filter-chip:hover, .toc a:hover {
    transform: none;
    box-shadow: initial;
    background: initial;
    border-color: initial;
  }
  
  /* Add tap feedback instead */
  .btn-base:active, .filter-chip:active, .toc a:active, .card:active {
    transform: scale(0.98);
    transition: transform 0.1s ease;
    opacity: 0.8;
  }
}

/* Reduce animation complexity on low-performance devices */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
  
  .floating, .pulse-attention, .text-glow, 
  .shimmer-effect, .sparkle-effect {
    animation: none !important;
  }
  
  .card, .btn-base, .filter-chip {
    transition: none !important;
  }
}

/* Mobile-specific improvements */
@media (max-width: 480px) {
  /* Improve text readability on small screens */
  body {
    font-size: 16px;
    line-height: 1.6;
    -webkit-text-size-adjust: 100%;
  }
  
  /* Ensure images don't break layout */
  img {
    max-width: 100% !important;
    height: auto !important;
  }
  
  /* Optimize cards for mobile */
  .card, .card-base {
    border-radius: 12px;
    box-shadow: 0 4px 16px rgba(0,0,0,.1);
  }
  
  /* Mobile-friendly buttons */
  .btn-base {
    border-radius: 8px;
    font-size: 16px; /* Prevent iOS zoom */
  }
  
  /* Improve modal sizing on mobile */
  .modal-content-base {
    margin: 10px;
    max-width: calc(100vw - 20px);
    max-height: calc(100vh - 20px);
    overflow-y: auto;
  }
  
  /* Mobile search optimization */
  .searchbar input {
    font-size: 16px; /* Prevents zoom on iOS */
    padding: 12px;
    border-radius: 8px;
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ“„ SECTION SELECTION MODAL
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

.section-selection-modal {
  z-index: 999999 !important;
}

.section-selection-modal .modal-content {
  max-width: 500px;
  padding: 2rem;
}

.sections-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin: 1.5rem 0;
}

.section-option {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  border: 2px solid var(--rule);
  border-radius: 12px;
  cursor: pointer;
  transition: all var(--transition-normal);
  background: var(--card);
}

.section-option:hover {
  border-color: var(--bronze);
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.1) 0%, 
    rgba(139,69,19,0.05) 100%);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(139,69,19,0.15);
}

.section-option.selected {
  border-color: var(--gold);
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.2) 0%, 
    rgba(139,69,19,0.1) 100%);
  box-shadow: 
    0 0 0 2px rgba(212,175,55,0.3),
    0 4px 16px rgba(139,69,19,0.2);
}

.section-icon {
  font-size: 2rem;
  width: 60px;
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 12px;
  background: linear-gradient(135deg, var(--bronze), var(--gold));
  color: white;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
}

.section-info {
  flex: 1;
}

.section-title {
  font-weight: 600;
  font-size: 1.1em;
  color: var(--accent-ink);
  margin-bottom: 0.25rem;
  font-family: 'Cinzel', serif;
}

.section-description {
  color: var(--paper-muted);
  font-size: 0.9em;
  line-height: 1.4;
}

.page-details {
  padding: 1.5rem;
  background: var(--paper-soft);
  border: 1px solid var(--rule);
  border-radius: 12px;
  margin: 1rem 0;
}

.form-group {
  margin-bottom: 1rem;
}

.form-group:last-child {
  margin-bottom: 0;
}

.form-group label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 600;
  color: var(--accent-ink);
}

.form-group input {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid var(--rule);
  border-radius: 8px;
  font-size: 1em;
  background: var(--card);
  color: var(--paper-ink);
}

.form-group input:focus {
  outline: none;
  border-color: var(--bronze);
  box-shadow: 0 0 0 2px rgba(212,175,55,0.2);
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 1rem;
  margin-top: 1.5rem;
}

.btn-primary {
  background: var(--bronze) !important;
  color: white !important;
  border-color: var(--bronze) !important;
}

.btn-primary:hover {
  background: var(--gold) !important;
  border-color: var(--gold) !important;
}

/* Mobile optimization for section selection modal */
@media (max-width: 480px) {
  .section-selection-modal .modal-content {
    padding: 1rem;
    margin: 1rem;
  }
  
  .section-option {
    padding: 0.75rem;
    gap: 0.75rem;
  }
  
  .section-icon {
    width: 48px;
    height: 48px;
    font-size: 1.5rem;
  }
  
  .modal-actions {
    flex-direction: column;
  }
  
  .modal-actions .btn {
    width: 100%;
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ–¨ï¸ PRINT STYLES - Ã‰tats imprimables
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

.print-button {
  background: var(--bronze) !important;
  color: white !important;
  border: 2px solid var(--gold) !important;
  border-radius: 8px;
  padding: 0.5rem 1rem;
  font-family: "Cinzel", serif;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.print-button:hover {
  background: var(--gold) !important;
  border-color: var(--bronze) !important;
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
}

/* Styles pour la version imprimable */
@media print {
  @page {
    margin: 0 !important;
    size: A4 !important;
  }
  
  html, body {
    font-family: "Times New Roman", serif !important;
    background: white !important;
    color: black !important;
    margin: 0 !important;
    padding: 0 !important;
    height: auto !important;
    overflow: visible !important;
  }
  
  .printable-states {
    display: block !important;
    padding: 15mm !important;
    margin: 0 !important;
    background: white !important;
    color: black !important;
    font-size: 10pt !important;
    line-height: 1.2 !important;
    width: 100% !important;
    height: auto !important;
    position: relative !important;
    top: 0 !important;
    left: 0 !important;
  }
  
  .printable-states h1 {
    font-size: 16pt !important;
    font-weight: bold !important;
    text-align: center !important;
    margin-bottom: 5mm !important;
    color: black !important;
    text-shadow: none !important;
    background: none !important;
    -webkit-text-fill-color: initial !important;
  }
  
  .printable-states-grid {
    display: grid !important;
    grid-template-columns: 1fr 1fr !important;
    gap: 3mm !important;
    margin: 0 !important;
  }
  
  .printable-state-item {
    background: white !important;
    border: 1pt solid #ccc !important;
    border-radius: 2mm !important;
    padding: 2mm !important;
    margin: 0 !important;
    page-break-inside: avoid !important;
    font-size: 9pt !important;
    line-height: 1.1 !important;
  }
  
  .printable-state-item h3 {
    font-size: 11pt !important;
    font-weight: bold !important;
    margin: 0 0 1mm 0 !important;
    color: black !important;
    text-shadow: none !important;
    background: none !important;
    -webkit-text-fill-color: initial !important;
  }
  
  .printable-state-item p {
    margin: 0.5mm 0 !important;
    color: black !important;
    font-size: 9pt !important;
  }
  
  /* Masquer les Ã©lÃ©ments de l'interface lors de l'impression */
  #sidebar, #views, .print-button, nav, header, footer, .edit-btn, .btn {
    display: none !important;
  }
  
  /* Afficher uniquement le contenu imprimable */
  .printable-states {
    display: block !important;
  }
  
  .printable-states-grid {
    display: grid !important;
  }
  
  .printable-state-item {
    display: block !important;
  }
  
  .printable-state-item h3 {
    display: block !important;
  }
  
  .printable-state-item div {
    display: block !important;
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸµ AUDIO CONTROLS - Lecteur audio flottant
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

.audio-controls {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 1000;
  background: var(--card);
  border: 2px solid var(--bronze);
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.3);
  backdrop-filter: blur(10px);
  min-width: 280px;
  font-family: "Cinzel", serif;
}

.audio-panel {
  padding: 1rem;
}

.audio-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 0.75rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--rule);
}

.audio-icon {
  font-size: 1.2rem;
}

.audio-title {
  font-weight: 600;
  color: var(--gold);
  font-size: 0.9rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.audio-toggle-btn {
  background: none;
  border: none;
  font-size: 1.1rem;
  cursor: pointer;
  padding: 0.25rem;
  border-radius: 4px;
  transition: background 0.2s ease;
}

.audio-toggle-btn:hover {
  background: var(--rule);
}

.audio-info {
  margin-bottom: 0.75rem;
  text-align: center;
}

.playlist-name {
  font-weight: 600;
  color: var(--accent-ink);
  font-size: 0.85rem;
  margin-bottom: 0.25rem;
}

.track-name {
  font-size: 0.75rem;
  color: var(--paper-muted);
  font-style: italic;
}

.audio-controls-row {
  display: flex;
  justify-content: center;
  gap: 0.5rem;
  margin-bottom: 0.75rem;
}

.audio-btn {
  background: var(--bronze);
  border: 1px solid var(--gold);
  border-radius: 6px;
  padding: 0.5rem;
  cursor: pointer;
  font-size: 0.9rem;
  color: white;
  transition: all 0.2s ease;
  min-width: 36px;
  height: 36px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.audio-btn:hover {
  background: var(--gold);
  transform: translateY(-1px);
}

.audio-btn:active {
  transform: translateY(0);
}

.audio-volume-row {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.8rem;
}

.volume-icon {
  font-size: 0.9rem;
  min-width: 20px;
}

.volume-slider {
  flex: 1;
  height: 4px;
  background: var(--rule);
  border-radius: 2px;
  outline: none;
  -webkit-appearance: none;
  appearance: none;
}

.volume-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--bronze);
  cursor: pointer;
  border: 2px solid var(--gold);
}

.volume-slider::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: var(--bronze);
  cursor: pointer;
  border: 2px solid var(--gold);
}

.volume-value {
  min-width: 35px;
  text-align: right;
  font-weight: 600;
  color: var(--accent-ink);
}

/* Responsive pour mobile */
@media (max-width: 480px) {
  .audio-controls {
    bottom: 10px;
    right: 10px;
    left: 10px;
    min-width: auto;
  }
  
  .audio-panel {
    padding: 0.75rem;
  }
  
  .audio-title {
    font-size: 0.8rem;
  }
  
  .audio-controls-row {
    gap: 0.75rem;
  }
  
  .audio-btn {
    min-width: 40px;
    height: 40px;
    font-size: 1rem;
  }
}

/* Masquer lors de l'impression */
@media print {
  .audio-controls {
    display: none !important;
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ”§ AUDIO PAGE CONTROLS - Boutons stables pour la page audio
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

.audio-control-btn {
  background: var(--bronze) !important;
  color: white !important;
  border: none !important;
  padding: 1rem 2rem !important;
  border-radius: 8px !important;
  cursor: pointer !important;
  font-family: "Cinzel", serif !important;
  font-size: 1rem !important;
  font-weight: 600 !important;
  text-transform: uppercase !important;
  letter-spacing: 0.5px !important;
  transition: none !important;
  min-width: 160px !important;
  min-height: 50px !important;
  user-select: none !important;
  -webkit-user-select: none !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  text-align: center !important;
}

.audio-control-btn:hover {
  background: var(--gold) !important;
  transform: none !important;
  box-shadow: none !important;
}

.audio-control-btn:active {
  background: var(--bronze) !important;
  transform: scale(0.98) !important;
}

.playlist-select-btn {
  background: var(--bronze) !important;
  color: white !important;
  border: none !important;
  padding: 1rem 1.5rem !important;
  border-radius: 6px !important;
  cursor: pointer !important;
  font-family: "Cinzel", serif !important;
  font-size: 0.95rem !important;
  font-weight: 600 !important;
  transition: none !important;
  min-width: 120px !important;
  min-height: 45px !important;
  user-select: none !important;
  -webkit-user-select: none !important;
  display: inline-flex !important;
  align-items: center !important;
  justify-content: center !important;
  text-align: center !important;
}

.playlist-select-btn:hover {
  background: var(--gold) !important;
  transform: none !important;
  box-shadow: none !important;
}

.playlist-select-btn:active {
  transform: scale(0.98) !important;
}

/* Slider de volume amÃ©liorÃ© */
#master-volume {
  -webkit-appearance: none !important;
  appearance: none !important;
  height: 6px !important;
  background: var(--rule) !important;
  border-radius: 3px !important;
  outline: none !important;
  cursor: pointer !important;
  transition: none !important;
}

#master-volume::-webkit-slider-thumb {
  -webkit-appearance: none !important;
  appearance: none !important;
  width: 20px !important;
  height: 20px !important;
  border-radius: 50% !important;
  background: var(--bronze) !important;
  cursor: pointer !important;
  border: 2px solid var(--gold) !important;
  transition: none !important;
}

#master-volume::-webkit-slider-thumb:hover {
  background: var(--gold) !important;
  border-color: var(--bronze) !important;
}

#master-volume::-moz-range-thumb {
  width: 20px !important;
  height: 20px !important;
  border-radius: 50% !important;
  background: var(--bronze) !important;
  cursor: pointer !important;
  border: 2px solid var(--gold) !important;
  transition: none !important;
}

#master-volume::-moz-range-thumb:hover {
  background: var(--gold) !important;
  border-color: var(--bronze) !important;
}


/* Editor and Dev Mode styles */

/* === HIDE ALL EDITING ELEMENTS IN STANDALONE MODE === */
/* Hide all editing elements when dev mode is OFF */

/* ULTRA NUCLEAR OPTION - Hide ALL editing buttons when dev mode is OFF */
/* This rule will override ANY other CSS that might be showing edit buttons */
body.dev-off button[title*="âœï¸"],
body.dev-off *[class*="edit"],
body.dev-off *[class*="Edit"],

body.dev-off button[data-category-name],
body.dev-off button[data-spell-name], 
body.dev-off button[data-don-name],
body.dev-off button[data-section-name],
body.dev-off button[data-section-type],
body.dev-off .btn:is([class*="add"], [class*="delete"], [class*="remove"], [class*="move"], [class*="edit"]),
body.dev-off .add-paragraph-btn,
body.dev-off .section-delete,
body.dev-off .spell-delete,
body.dev-off .don-delete,
body.dev-off .objet-delete,
body.dev-off .spell-category-delete,
body.dev-off .don-category-delete,
body.dev-off .objet-category-delete,
body.dev-off .don-move-up,
body.dev-off .don-move-down,
body.dev-off .remove-section-btn,
body.dev-off .illus .up,
body.dev-off .illus .rm,
body.dev-off .illus label.up,
body.dev-off .illus button.rm,
body.dev-off .illus label,
body.dev-off .illus input[type="file"],
body.dev-off button[class*="add"]:not(.menu-toggle),
body.dev-off button[class*="delete"],
body.dev-off button[class*="remove"],
body.dev-off button[class*="move"],
body.dev-off button[class*="edit"],
body.dev-off .spell-add,
body.dev-off .don-add,
body.dev-off .objet-add,
body.dev-off .category-add,
body.dev-off .add-*,
body.dev-off [data-bound] .up,
body.dev-off [data-bound] .rm,
body.dev-off [data-bound] label,
body.dev-off [data-bound] button,
body.dev-off .illus[data-bound] .up,
body.dev-off .illus[data-bound] .rm,
body.dev-off .illus[data-bound] label,
body.dev-off .illus[data-bound] button,
body.dev-off .illus[data-bound] input[type="file"],
body.dev-off [data-dev-only],
body.dev-off div[data-dev-only],
body.dev-off .dev-mode-buttons,
body.dev-off .manage-tags-btn,
body.dev-off .add-monster-btn,
body.dev-off button[data-content-type],
body.dev-off .tags-manager-btn,
body.dev-off .filter-manager-btn,
body.dev-off button[class*="tags"],
body.dev-off button[class*="manage"],
/* Specific button selectors */
body.dev-off button[data-category-name],
body.dev-off button[data-spell-name],
body.dev-off button[data-don-name],
body.dev-off button[data-section-name],
body.dev-off button[data-section-type],
/* Input file upload elements */
body.dev-off input[type="file"],
body.dev-off label[for*="file"],
/* Additional specific selectors */
body.dev-off .add-subclass-btn,
body.dev-off .add-new-section,
/* COMPREHENSIVE EDIT BUTTON HIDING */
body.dev-off .edit-btn,
body.dev-off .edit-title-btn,
body.dev-off .edit-paragraph-btn,
body.dev-off .edit-list-btn,
body.dev-off .edit-field-btn,
body.dev-off .edit-effect-btn,
body.dev-off .edit-stats-btn,
body.dev-off .edit-section-btn,
body.dev-off button.edit-btn,
body.dev-off button.edit-title-btn,
body.dev-off button.edit-paragraph-btn,
body.dev-off button.edit-list-btn,
body.dev-off button.edit-field-btn,
body.dev-off button.edit-effect-btn,
body.dev-off button.edit-stats-btn,
body.dev-off button.edit-section-btn,
body.dev-off .editable-section .edit-btn,
body.dev-off .editable-section button[class*="edit"],
body.dev-off .card .edit-btn,
body.dev-off .card button[class*="edit"],
body.dev-off .editable-item .edit-btn,
body.dev-off .editable-item button[class*="edit"],
body.dev-off [data-section-type] .edit-btn,
body.dev-off [data-section-type] button[class*="edit"],
body.dev-off .add-*-btn,
/* Very specific selectors for inline styled buttons */
body.dev-off button[style*="background: #ff6b6b"],
body.dev-off button[style*="background: var(--bronze)"],
body.dev-off button[style*="background: #dc2626"],
body.dev-off button[style*="background: var(--accent)"],
/* Target buttons by text content patterns */
body.dev-off .btn.small[data-category-name],
body.dev-off .btn.small[data-spell-name],  
body.dev-off .btn.small[data-don-name],
body.dev-off .btn.small[data-section-name],
body.dev-off .btn.small[data-don-index],
/* ULTRA FORCÃ‰ - Cacher TOUS les boutons de gestion des tags */
/* ULTRA-SPECIFIC RULES FOR IMAGE UPLOAD BUTTONS */
body.dev-off .illus label.up,
body.dev-off .illus button.rm,
body.dev-off label:contains("ğŸ“·"),
body.dev-off label:contains("Ajouter"),
body.dev-off button:contains("ğŸ—‘"),
body.dev-off button:contains("Retirer"),
body.dev-off .card .illus .up,
body.dev-off .card .illus .rm,
body.dev-off .card .illus label,
body.dev-off .card .illus button,
body.dev-off .card [data-bound] .up,
body.dev-off .card [data-bound] .rm,
/* ULTRA-SPECIFIC RULES FOR OBJECTS PAGE */
body.dev-off article[data-page="objets"] .illus label.up,
body.dev-off article[data-page="objets"] .illus button.rm,
body.dev-off article[data-page="objets"] .card .illus label,
body.dev-off article[data-page="objets"] .card .illus button,
body.dev-off #objets-container .illus label.up,
body.dev-off #objets-container .illus button.rm,
body.dev-off #objets-container .card .illus label,
body.dev-off #objets-container .card .illus button,
/* RULES WITH DATA ATTRIBUTES FOR OBJECTS */
body.dev-off .card[data-type="objet"] .illus label.up,
body.dev-off .card[data-type="objet"] .illus button.rm,
body.dev-off .card[data-type="objet"] .illus label,
body.dev-off .card[data-type="objet"] .illus button,
body.dev-off .card[data-category="objets"] .illus label.up,
body.dev-off .card[data-category="objets"] .illus button.rm,
body.dev-off .card[data-category="objets"] .illus label,
body.dev-off .card[data-category="objets"] .illus button,
/* Collections d'objets page specific rules */
body.dev-off article[data-page="collections-objets"] .illus label.up,
body.dev-off article[data-page="collections-objets"] .illus button.rm,
body.dev-off article[data-page="collections-objets"] .illus label,
body.dev-off article[data-page="collections-objets"] .illus button,
body.dev-off #collection-items .illus label.up,
body.dev-off #collection-items .illus button.rm,
body.dev-off #collection-items .illus label,
body.dev-off #collection-items .illus button,
/* ULTRA-SPECIFIC RULES FOR TAG MANAGER BUTTONS */
body.dev-off button.manage-tags-btn,
body.dev-off button.tags-manager-btn,
body.dev-off .btn.manage-tags-btn,
body.dev-off .btn.tags-manager-btn,
body.dev-off button[data-content-type="monster"],
body.dev-off button[data-content-type="objet"],
body.dev-off button[data-content-type="tableTresor"],
body.dev-off .dev-mode-buttons button,
body.dev-off div[data-dev-only] button,
body.dev-off div[data-dev-only],
body.dev-off .btn.btn-small.manage-tags-btn,
body.dev-off button.btn.btn-small.manage-tags-btn,
body.dev-off .dev-mode-buttons .manage-tags-btn,
body.dev-off [data-dev-only] .manage-tags-btn,
body.dev-off .tableTresor-add,
body.dev-off .add-monster-btn,
body.dev-off .btn.add-monster-btn,
body.dev-off .tags-manager-btn,
body.dev-off .filter-manager-btn,
body.dev-off button[title*="GÃ©rer les tags"],
body.dev-off button[title*="gÃ©rer les tags"],
body.dev-off button[onclick*="showTagsManagementModal"],
body.dev-off button[onclick*="showMonsterTagsManagement"],
/* Additional super specific selectors for any possible generated button */
html body.dev-off button.manage-tags-btn,
html body.dev-off button.tags-manager-btn,
html body.dev-off .btn.manage-tags-btn,
html body.dev-off .btn.tags-manager-btn,
/* Text content matching */
body.dev-off button:contains("ğŸ·ï¸ GÃ©rer les tags"),
body.dev-off button:contains("GÃ©rer les tags") {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  position: absolute !important;
  left: -9999px !important;
  width: 0 !important;
  height: 0 !important;
  overflow: hidden !important;
  pointer-events: none !important;
}

/* Styles for dev buttons container */
.dev-buttons-container {
  display: flex;
  gap: 8px;
  margin-bottom: 1rem;
  flex-wrap: wrap;
}

/* Hide dev buttons container completely in dev-off mode */
body.dev-off .dev-buttons-container,
body.dev-off div[data-dev-only] {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
}

/* Element selectors for spells and monsters - Solution ultra-forcÃ©e */
.spell-element-selector,
.spell-element-selector *,
div.spell-element-selector,
.card .spell-element-selector,
.monster-element-selector,
.monster-element-selector *,
div.monster-element-selector,
.card .monster-element-selector {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  position: absolute !important;
  left: -9999px !important;
  width: 0 !important;
  height: 0 !important;
  overflow: hidden !important;
}

/* Modal buttons should always be visible */
dialog .delete-monster-tag-btn,
dialog .btn,
dialog button {
  display: inline-flex !important;
  visibility: visible !important;
  opacity: 1 !important;
  pointer-events: auto !important;
  position: static !important;
  left: auto !important;
  width: auto !important;
  height: auto !important;
  overflow: visible !important;
}

/* SEULEMENT visible en mode dev */
body.dev-on .spell-element-selector,
body.dev-on .spell-element-selector *,
body.dev-on div.spell-element-selector,
body.dev-on .card .spell-element-selector,
body.dev-on .monster-element-selector,
body.dev-on .monster-element-selector *,
body.dev-on div.monster-element-selector,
body.dev-on .card .monster-element-selector {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  position: static !important;
  left: auto !important;
  width: auto !important;
  height: auto !important;
  overflow: visible !important;
}

body.dev-off .spell-element-display,
body.dev-off .monster-element-display {
  display: block !important;
}

body.dev-on .spell-element-display,
body.dev-on .monster-element-display {
  display: none !important;
}

/* COMPREHENSIVE SHOW RULES FOR DEV MODE - High specificity to override dev-off hiding */
body.dev-on .edit-btn,
body.dev-on button.edit-btn,
body.dev-on button[class*="edit"],
body.dev-on button[class*="add"]:not(.menu-toggle),
body.dev-on button[class*="delete"],
body.dev-on button[class*="remove"],
body.dev-on button[class*="move"],
body.dev-on .section-delete,
body.dev-on .spell-delete,
body.dev-on .don-delete,
body.dev-on .add-subclass-btn,
body.dev-on .delete-subclass-btn,
body.dev-on .add-paragraph-btn,
body.dev-on .remove-section-btn,
body.dev-on .illus .up,
body.dev-on .illus .rm,
body.dev-on .illus label,
body.dev-on .illus input[type="file"],
body.dev-on button[data-category-name],
body.dev-on button[data-spell-name],
body.dev-on button[data-don-name],
body.dev-on button[data-section-name],
body.dev-on button[data-section-type],
/* Extra specific selectors to match the hiding rules exactly */
body.dev-on .spell-add,
body.dev-on .don-add,
body.dev-on .objet-add,
body.dev-on .category-add,
body.dev-on .spell-category-delete,
body.dev-on .don-category-delete,
body.dev-on .objet-category-delete,
body.dev-on .don-move-up,
body.dev-on .don-move-down,
body.dev-on button[title*="Ã‰diter"],
body.dev-on button[title*="Edit"],
body.dev-on button[title*="Supprimer"],
body.dev-on button[title*="Ajouter"],
body.dev-on [data-dev-only],
body.dev-on .dev-mode-buttons,
body.dev-on .manage-tags-btn,
body.dev-on .add-monster-btn,
body.dev-on .tags-manager-btn {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  pointer-events: auto !important;
  position: relative !important;
}

/* Limit objects to max 4 per row in dev mode */
body.dev-on #objets-container {
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  max-width: 1300px; /* Ensures max 4 columns on most screens */
}

/* Force max 4 columns on larger screens in dev mode */
@media (min-width: 1600px) {
  body.dev-on #objets-container {
    grid-template-columns: repeat(4, 1fr);
    max-width: 1300px;
  }
}

/* ULTIMATE SOLUTION: Force dimensions to prevent 0x0 collapse */
html body.dev-on .edit-btn,
html body.dev-on button[class*="edit"],
html body.dev-on button[class*="add"],
html body.dev-on button[class*="delete"],
html body.dev-on .section-delete,
html body.dev-on .add-paragraph-btn {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  width: 28px !important;
  height: 28px !important;
  min-width: 28px !important;
  min-height: 28px !important;
  background: rgba(139,69,19,0.1) !important;
  border: 1px solid var(--bronze) !important;
  border-radius: 6px !important;
  color: var(--bronze) !important;
  font-size: 14px !important;
  padding: 4px !important;
  margin-left: 8px !important;
  box-sizing: border-box !important;
  line-height: 1 !important;
  cursor: pointer !important;
  position: relative !important;
  top: 0 !important;
  left: 0 !important;
  transform: none !important;
  z-index: 10 !important;
}
/* Target specific button classes from renderer */
body.dev-off .spell-add,
body.dev-off .don-add,
body.dev-off .objet-add,
body.dev-off .spell-delete,
body.dev-off .don-delete,
body.dev-off .objet-delete,
body.dev-off .spell-category-delete,
body.dev-off .don-category-delete,
body.dev-off .objet-category-delete,
body.dev-off .don-move-up,
body.dev-off .don-move-down,
body.dev-off .section-delete,
body.dev-off .remove-section-btn,
/* Universal button selectors with edit-related titles */
body.dev-off button[title*="diter"],
body.dev-off button[title*="Edit"],
body.dev-off button[title*="Supprimer"],
body.dev-off button[title*="Ajouter"],
body.dev-off button[title*="Haut"],
body.dev-off button[title*="Bas"],
/* AJOUT: SÃ©lecteurs pour les boutons add/delete */
body.dev-off button[class*="add"],
body.dev-off button[class*="delete"],
body.dev-off button[class*="remove"],
body.dev-off button[class*="move"],
body.dev-off button[class*="upload"],
body.dev-off button[class*="edit"] {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  pointer-events: none !important;
}

/* SPÃ‰CIFIQUE: RÃ¨gles avec spÃ©cificitÃ© maximale pour forcer le masquage */
body.dev-off button.spell-add.btn,
body.dev-off button.don-add.btn,
body.dev-off button.objet-add.btn,
body.dev-off button.spell-category-delete.btn,
body.dev-off button.don-category-delete.btn,
body.dev-off button.objet-category-delete.btn,
/* ULTRA-SPÃ‰CIFIQUE: Tags manager buttons */
body.dev-off button.tags-manager-btn.btn,
body.dev-off button.filter-manager-btn.btn,
html body.dev-off .tags-manager-btn,
html body.dev-off .filter-manager-btn,
html body.dev-off button.tags-manager-btn,
html body.dev-off button.filter-manager-btn {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  pointer-events: none !important;
}

/* Ancien systÃ¨me d'agrandissement - dÃ©sactivÃ© */
.illus img.enlarged {
  /* Plus de style ici - gÃ©rÃ© par JavaScript modal */
}

/* Forcer l'Ã©tat stable sur hover pour les images agrandies */
.illus img.enlarged:hover,
article[data-page="guerrier"] .illus img.enlarged:hover,
article[data-page="mage"] .illus img.enlarged:hover,
article[data-page="pretre"] .illus img.enlarged:hover,
article[data-page="rodeur"] .illus img.enlarged:hover,
article[data-page="enchanteur"] .illus img.enlarged:hover,
.illus[data-illus-key^="class:"] img.enlarged:hover,
article[data-page="sorts-mage"] .illus img.enlarged:hover,
article[data-page="sorts-pretre"] .illus img.enlarged:hover,
article[data-page="sorts-enchanteur"] .illus img.enlarged:hover,
.illus[data-illus-key^="spellcategory:"] img.enlarged:hover {
  transform:translate(-50%, -50%) !important;
  transition:none !important;
}

/* Ancien backdrop - plus utilisÃ© */
.image-backdrop {
  display: none !important;
}

/* Interactive buttons */
.btn-action{display:inline-flex;gap:var(--space-sm);align-items:center;padding:var(--space-sm) 10px;border-radius:10px;cursor:pointer;border:1px solid}
.btn-upload{border-color:rgba(0,0,0,.25);border-style:dashed;background:#fff8ee}
.btn-remove{border-color:rgba(120,0,0,.25);background:#fee2e2}
.btn-add{border-color:rgba(0,120,0,.25);background:#f0fff4;margin-bottom:10px}
.btn-delete{padding:var(--space-xs) var(--space-md);border-radius:6px;font-size:12px;margin-left:10px}
.illus .up{border-color:rgba(0,0,0,.25);border-style:dashed;background:#fff8ee}
.illus .rm, .spell-delete{border-color:rgba(120,0,0,.25);background:#fee2e2}
.spell-add{border-color:rgba(0,120,0,.25);background:#f0fff4;margin-bottom:10px}
.spell-delete{padding:var(--space-xs) var(--space-md);border-radius:6px;font-size:12px;margin-left:10px}

/* Bouton d'ajout de paragraphe - seulement dans les articles */
.add-paragraph-btn {
  display:none !important;
}
/* Masquer explicitement dans la sidebar et le sommaire */
.sidebar .add-paragraph-btn,
.toc .add-paragraph-btn,
#toc .add-paragraph-btn {
  display:none !important;
  visibility:hidden !important;
}
/* Afficher SEULEMENT dans les articles actifs en mode dev */
body.dev-on article.active .add-paragraph-btn {
  display:block !important; margin:10px 0; padding:8px 12px; background:var(--card); 
  border:2px dashed var(--bronze); border-radius:8px; cursor:pointer;
  color:var(--bronze); text-align:center; transition:all .2s ease;
}
body.dev-on article.active .add-paragraph-btn:hover {
  background:rgba(139,69,19,.08); border-color:var(--gold);
  color:var(--gold);
}

/* Bouton d'ajout de sous-classe */
.add-subclass-btn {
  display:none; margin:12px 0 4px 0; padding:8px 12px; background:var(--card);
  border:1px dashed var(--bronze); border-radius:8px; cursor:pointer;
  color:var(--bronze); text-align:center; font-size:13px;
  transition:all .2s ease; width:100%;
}
/* Afficher dans les pages de classes en mode dev */
body.dev-on article[data-page="guerrier"] .add-subclass-btn,
body.dev-on article[data-page="mage"] .add-subclass-btn,
body.dev-on article[data-page="pretre"] .add-subclass-btn,
body.dev-on article[data-page="rodeur"] .add-subclass-btn,
body.dev-on article[data-page="enchanteur"] .add-subclass-btn {
  display:block !important;
}
body.dev-on article[data-page="guerrier"] .add-subclass-btn:hover,
body.dev-on article[data-page="mage"] .add-subclass-btn:hover,
body.dev-on article[data-page="pretre"] .add-subclass-btn:hover,
body.dev-on article[data-page="rodeur"] .add-subclass-btn:hover,
body.dev-on article[data-page="enchanteur"] .add-subclass-btn:hover {
  background:rgba(139,69,19,.08); border-color:var(--gold);
  color:var(--gold); transform:translateY(-1px);
  box-shadow:0 4px 8px rgba(0,0,0,.1);
}

/* Modales */
.category-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.category-modal.visible {
  display:flex;
}
.category-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:500px; width:90%; box-shadow:var(--shadow);
  position:relative;
}

/* Modal pour les icÃ´nes */
.icons-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.icons-modal.visible {
  display:flex;
}
.icons-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:600px; width:90%; max-height:80vh; overflow-y:auto;
  box-shadow:var(--shadow); position:relative;
}
.icons-grid {
  display:grid; grid-template-columns:repeat(auto-fill, minmax(60px, 1fr));
  gap:var(--space-md); margin:var(--space-xl) 0; max-height:400px; overflow-y:auto;
  border:1px solid var(--rule); border-radius:var(--space-md); padding:var(--space-xl);
}
.icon-item {
  display:flex; align-items:center; justify-content:center;
  padding:var(--space-lg); border:1px solid var(--rule); border-radius:var(--space-md);
  cursor:pointer; transition:var(--transition-fast); font-size:24px;
  background:var(--paper);
}
.icon-item:hover {
  background:var(--bronze); color:white; transform:scale(1.1);
  box-shadow:0 4px 8px rgba(0,0,0,.2);
}
.icon-item.copied {
  background:var(--gold); color:white; animation:copyFlash .5s ease;
}
@keyframes copyFlash {
  0% { transform:scale(1.1); }
  50% { transform:scale(1.3); }
  100% { transform:scale(1.1); }
}

/* Modal pour les Ã©lÃ©ments */
.elements-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:2147483647; display:none; align-items:center; justify-content:center;
}
.elements-modal.visible {
  display:flex;
}
.elements-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:400px; width:90%; 
  box-shadow:var(--shadow); position:relative;
}
.elements-list {
  display:flex; flex-direction:column; gap:var(--space-md); margin:var(--space-xl) 0;
}
.element-item {
  display:flex; align-items:center; gap:var(--space-md); padding:var(--space-md);
  border:2px solid var(--rule); border-radius:var(--space-md); cursor:pointer;
  transition:var(--transition-fast); background:var(--card);
}
.element-item:hover {
  background:var(--paper); border-color:var(--bronze); transform:translateY(-2px);
  box-shadow:0 4px 12px rgba(0,0,0,.1);
}
.element-item:active {
  transform:translateY(0) scale(0.98);
}
.element-icon {
  width:24px; height:24px; border-radius:50%; flex-shrink:0;
}
.element-name {
  font-weight:600; flex-grow:1;
}
.copy-indicator {
  font-size:12px; color:var(--paper-muted); opacity:0;
  transition:opacity 0.3s ease;
}
.element-item.copied .copy-indicator {
  opacity:1;
}

/* Ã‰tats modal styles */
.etats-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:2147483647; display:none; align-items:center; justify-content:center;
}
.etats-modal.visible {
  display:flex;
}
.etats-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:500px; width:90%; 
  box-shadow:var(--shadow); position:relative; max-height:80vh; overflow-y:auto;
}
.etats-list {
  display:flex; flex-direction:column; gap:var(--space-md); margin:var(--space-xl) 0;
}
.etat-item {
  display:flex; align-items:flex-start; gap:var(--space-md); padding:var(--space-md);
  border:2px solid var(--rule); border-radius:var(--space-md); cursor:pointer;
  transition:var(--transition-fast); background:var(--card); position:relative;
}
.etat-content {
  flex:1; display:flex; flex-direction:column;
}
.etat-item:hover {
  background:var(--paper); border-color:var(--bronze); transform:translateY(-2px);
  box-shadow:0 4px 12px rgba(0,0,0,.1);
}
.etat-item:active {
  transform:translateY(0) scale(0.98);
}
.etat-icon {
  width:24px; height:24px; border-radius:50%; flex-shrink:0;
  background:var(--bronze); color:white; display:flex; align-items:center;
  justify-content:center; font-size:14px;
}
.etat-name {
  font-weight:600; color:var(--accent-ink); margin-bottom:4px;
}
.etat-description {
  font-size:12px; color:var(--paper-muted); line-height:1.4;
}
.etat-item .copy-indicator {
  position:absolute; top:50%; right:var(--space-md); transform:translateY(-50%);
  font-size:12px; color:var(--bronze); opacity:0; font-weight:600;
  transition:opacity 0.3s ease;
}
.etat-item.copied .copy-indicator {
  opacity:1;
}

/* Styles pour les tooltips d'Ã©tats */
span[title] {
  cursor: help;
  border-bottom: 2px solid var(--bronze);
  position: relative;
  display: inline-block;
  background: linear-gradient(135deg, rgba(205,127,50,0.1), rgba(212,175,55,0.05));
  padding: 2px 4px;
  border-radius: 3px;
  font-weight: 700;
}

/* Styles pour les liens de sorts */
.spell-link {
  color: #ea7332 !important; /* Orange au lieu du jaune */
  cursor: pointer;
  text-decoration: underline;
  font-weight: 600;
  transition: color 0.2s ease;
}

.spell-link:hover {
  color: var(--bronze) !important;
}

/* Styles pour les liens d'Ã©tats */
.etat-link {
  color: #ea7332 !important; /* Orange au lieu du jaune */
  cursor: pointer;
  text-decoration: underline;
  font-weight: 600;
  transition: color 0.2s ease;
}

.etat-link:hover {
  color: var(--bronze) !important;
}

/* Modal des liens de sorts */
.spell-links-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  z-index: 2147483647;
  display: none;
  align-items: center;
  justify-content: center;
}

.spell-links-modal.visible {
  display: flex;
}

.spell-links-modal-content {
  background: var(--card);
  border: 2px solid var(--rule);
  border-radius: 16px;
  padding: var(--space-2xl);
  max-width: 600px;
  width: 90%;
  box-shadow: var(--shadow);
  position: relative;
  max-height: 80vh;
  overflow-y: auto;
}

.spell-item {
  display: flex;
  align-items: flex-start;
  gap: var(--space-md);
  padding: var(--space-md);
  border: 2px solid var(--rule);
  border-radius: var(--space-md);
  cursor: pointer;
  transition: var(--transition-fast);
  background: var(--card);
  position: relative;
  margin-bottom: 8px;
}

.spell-item:hover {
  background: var(--paper);
  border-color: var(--bronze);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.spell-item:active {
  transform: translateY(0) scale(0.98);
}

.spell-info {
  flex: 1;
  display: flex;
  flex-direction: column;
}

.spell-name {
  font-weight: 600;
  margin-bottom: 4px;
  font-size: 14px;
}

.spell-meta {
  font-size: 12px;
  color: var(--paper-muted);
  margin-bottom: 6px;
}

.spell-description {
  font-size: 14px;
  color: var(--paper-muted);
  line-height: 1.4;
}

.spell-item .copy-indicator {
  position: absolute;
  top: 50%;
  right: var(--space-md);
  transform: translateY(-50%);
  font-size: 12px;
  color: var(--bronze);
  opacity: 0;
  font-weight: 600;
  transition: opacity 0.3s ease;
}

.spell-item.copied .copy-indicator {
  opacity: 1;
}

/* Popup de prÃ©visualisation des sorts */
.spell-preview-popup {
  position: fixed;
  z-index: 10001;
  background: var(--card);
  border-radius: 8px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  max-width: 400px;
  max-height: 500px;
  overflow-y: auto;
  font-family: 'Roboto', sans-serif;
  line-height: 1.4;
}

.spell-preview-content {
  padding: 0;
}

.spell-preview-header {
  padding: 16px;
  background: var(--paper);
  border-radius: 8px 8px 0 0;
  position: relative;
  border-left: 4px solid var(--accent);
}

.spell-title {
  font-size: 18px;
  font-weight: bold;
  margin-bottom: 4px;
  font-family: 'Cinzel', serif;
}

/* RÃ¨gle gÃ©nÃ©rale pour spell-element dans les cartes */
.card .spell-element {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  /* Pas de couleur par dÃ©faut - utilise les couleurs inline des Ã©lÃ©ments */
}

/* Couleur de fallback uniquement si aucune couleur inline n'est dÃ©finie */
.card .spell-element:not([style*="color"]) {
  color: var(--paper-muted);
}

/* Badge d'Ã©lÃ©ment avec texte noir pour lisibilitÃ© */
.element-badge {
  color: var(--paper-ink) !important;
  text-shadow: none !important;
}

/* S'assurer que la toolbox dev reste cliquable mÃªme avec modale ouverte */
#devToggle,
#devToolbox,
.tools,
.dev-toolbox {
  position: relative;
  z-index: 999999 !important;
}

/* Boutons de la toolbox dev toujours cliquables */
body.dev-on #devToggle,
body.dev-on #devToolbox *,
body.dev-on .tools *,
body.dev-on .dev-toolbox * {
  z-index: 999999 !important;
  pointer-events: auto !important;
}

/* Z-index maximum pour l'interface dev au-dessus des modales et dialogues */
.tools button,
.dev-toolbox button,
#devToggle,
#devToolbox button {
  z-index: 9999999 !important;
  position: relative;
}

/* Conteneur principal des outils dev */
.tools,
.dev-toolbox {
  z-index: 9999999 !important;
  position: relative;
}

/* Forcer les modales toolbox Ã  apparaÃ®tre devant les dialogues d'Ã©dition HTML */
.elements-modal,
.etats-modal, 
.spell-links-modal {
  z-index: 2147483647 !important; /* Maximum z-index possible */
}

.elements-modal-content,
.etats-modal-content,
.spell-links-modal-content {
  z-index: 2147483647 !important;
  position: relative;
}

/* RÃ¨gle spÃ©cifique pour spell-element dans les popups de prÃ©visualisation */
.spell-preview-popup .spell-element {
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  /* Pas de couleur dÃ©finie ici - elle sera dÃ©finie en inline */
}

/* Force les couleurs des Ã©lÃ©ments - spÃ©cificitÃ© maximale */
.spell-links-modal .spell-meta[style*="color"],
.spell-preview-popup .spell-element[style*="color"] {
  color: var(--accent-ink) !important;
}

/* RÃ¨gles pour les nouveaux attributs de donnÃ©es */
[data-element-display],
[data-spell-meta] {
  color: inherit !important;
  font-weight: 600;
}

/* Alternative: couleurs directes par Ã©lÃ©ment */
.spell-preview-popup .spell-element[style*="#e25822"] { color: #e25822 !important; }
.spell-preview-popup .spell-element[style*="#2563eb"] { color: #2563eb !important; }
.spell-preview-popup .spell-element[style*="#92400e"] { color: #92400e !important; }
.spell-preview-popup .spell-element[style*="#059669"] { color: #059669 !important; }
.spell-preview-popup .spell-element[style*="#d97706"] { color: #d97706 !important; }
.spell-preview-popup .spell-element[style*="#6b21a8"] { color: #6b21a8 !important; }
.spell-preview-popup .spell-element[style*="#7c2d12"] { color: #7c2d12 !important; }
.spell-preview-popup .spell-element[style*="#7c3aed"] { color: #7c3aed !important; }

.spell-links-modal .spell-meta[style*="#e25822"] { color: #e25822 !important; }
.spell-links-modal .spell-meta[style*="#2563eb"] { color: #2563eb !important; }
.spell-links-modal .spell-meta[style*="#92400e"] { color: #92400e !important; }
.spell-links-modal .spell-meta[style*="#059669"] { color: #059669 !important; }
.spell-links-modal .spell-meta[style*="#d97706"] { color: #d97706 !important; }
.spell-links-modal .spell-meta[style*="#6b21a8"] { color: #6b21a8 !important; }
.spell-links-modal .spell-meta[style*="#7c2d12"] { color: #7c2d12 !important; }
.spell-links-modal .spell-meta[style*="#7c3aed"] { color: #7c3aed !important; }

/* Page Links Modal */
.page-links-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  z-index: 2147483647;
  display: none;
  align-items: center;
  justify-content: center;
}

.page-links-modal.visible {
  display: flex;
}

.page-links-modal-content {
  background: var(--card);
  border: 2px solid var(--rule);
  border-radius: 16px;
  padding: var(--space-2xl);
  max-width: 600px;
  width: 90%;
  box-shadow: var(--shadow);
  position: relative;
  max-height: 80vh;
  overflow-y: auto;
}

.page-item {
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  padding: 12px;
  margin-bottom: 8px;
  border: 1px solid var(--rule);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  background: var(--surface);
}

.page-item:hover {
  background: var(--accent-bg);
  border-color: var(--accent);
  transform: translateX(4px);
}

.page-item.copied {
  background: rgba(34, 197, 94, 0.1);
  border-color: #22c55e;
}

.page-info {
  flex: 1;
}

.page-name {
  font-weight: 600;
  color: var(--accent-ink);
  margin-bottom: 4px;
  font-size: 14px;
}

.page-section {
  font-size: 12px;
  color: var(--paper-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.copy-indicator {
  position: absolute;
  top: 50%;
  right: 12px;
  transform: translateY(-50%);
  background: #22c55e;
  color: white;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.page-item.copied .copy-indicator {
  opacity: 1;
}

@media (max-width: 768px) {
  .page-links-modal-content {
    max-width: calc(100vw - 16px);
    padding: 16px;
  }
}

.spell-preview-close {
  position: absolute;
  top: 12px;
  right: 12px;
  background: none;
  border: none;
  font-size: 16px;
  cursor: pointer;
  color: var(--paper-muted);
  padding: 4px;
  border-radius: 4px;
  transition: all 0.2s ease;
}

.spell-preview-close:hover {
  background: var(--rule);
  color: var(--accent-ink);
}

.spell-preview-body {
  padding: 16px;
}

/* Ã‰tats preview popup */
.etat-preview-popup {
  position: fixed;
  z-index: 10001;
  background: var(--card);
  border: 2px solid #7c2d12;
  border-radius: 12px;
  box-shadow: 0 8px 24px rgba(0,0,0,0.3);
  max-width: 300px;
  padding: 1rem;
  font-size: 14px;
  line-height: 1.4;
  color: var(--paper-ink);
  pointer-events: auto;
}

.etat-preview-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
  padding-bottom: 0.5rem;
  border-bottom: 1px solid var(--rule);
}

.etat-title {
  font-weight: 600;
  font-size: 16px;
  color: #7c2d12;
}

.etat-preview-close {
  background: none;
  border: none;
  font-size: 16px;
  cursor: pointer;
  color: var(--paper-muted);
  padding: 4px;
  border-radius: 4px;
  transition: all 0.2s ease;
}

.etat-preview-close:hover {
  background: var(--rule);
  color: var(--accent-ink);
}

.etat-preview-body {
  margin-top: 0.5rem;
}

.etat-description {
  white-space: pre-line;
}

.spell-field {
  margin-bottom: 12px;
  font-size: 14px;
  line-height: 1.5;
}

.spell-field:last-child {
  margin-bottom: 0;
}

.spell-description {
  margin-bottom: 16px;
  font-style: italic;
  color: var(--paper-muted);
  font-size: 14px;
}

/* Responsive pour mobile */
@media (max-width: 768px) {
  .spell-preview-popup {
    max-width: calc(100vw - 16px);
    max-height: calc(100vh - 32px);
    left: 8px !important;
    top: 16px !important;
  }
  
  .spell-links-modal-content {
    max-width: calc(100vw - 16px);
    padding: 16px;
  }
}

span[title]:hover {
  border-bottom-color: var(--gold);
  border-bottom-width: 3px;
  background: linear-gradient(135deg, rgba(212,175,55,0.2), rgba(205,127,50,0.1));
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* Tooltip personnalisÃ© pour une meilleure visibilitÃ© */
span[title]:hover::after {
  content: attr(title);
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: var(--accent-ink);
  color: white;
  padding: 10px 15px;
  border-radius: 8px;
  font-size: 13px;
  white-space: pre-line;
  z-index: 999999;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  pointer-events: none;
  min-width: 200px;
  max-width: 320px;
  text-align: center;
  line-height: 1.5;
  animation: tooltipFadeIn 0.3s ease;
  border: 2px solid var(--gold);
  word-wrap: break-word;
}

span[title]:hover::before {
  content: '';
  position: absolute;
  bottom: calc(100% + 2px);
  left: 50%;
  transform: translateX(-50%);
  border: 6px solid transparent;
  border-top-color: var(--accent-ink);
  z-index: 999999;
  pointer-events: none;
}

/* Forcer l'overflow visible pour les tooltips */
.card:has(span[title]:hover),
.editable:has(span[title]:hover),
article:has(span[title]:hover) {
  overflow: visible !important;
}

/* Fallback pour navigateurs sans :has() */
.card,
.editable,
article {
  position: relative;
}

.card span[title]:hover::after,
.editable span[title]:hover::after,
article span[title]:hover::after {
  z-index: 99999 !important;
}

@keyframes tooltipFadeIn {
  from { opacity: 0; transform: translateX(-50%) translateY(5px); }
  to { opacity: 1; transform: translateX(-50%) translateY(0); }
}

/* === UNIFIED EDIT BUTTONS FOR ALL SECTIONS === */
.editable-section {
  position: relative;
  margin: 8px 0;
}

.edit-btn {
  background: var(--bronze);
  color: white;
  border: none;
  border-radius: 6px;
  padding: 4px 8px;
  cursor: pointer;
  font-size: 12px;
  opacity: 0.7;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.edit-btn:hover {
  opacity: 1;
  transform: scale(1.05);
  background: var(--gold);
}

/* Inline edit buttons (titles, etc.) */
.edit-btn.edit-title-btn,
.edit-btn.edit-paragraph-btn {
  position: relative;
  margin-left: 8px;
}

/* Section edit buttons (absolute positioning) */
.editable-section .edit-btn.edit-section-btn,
[style*="position:relative"] .edit-btn.edit-section-btn {
  position: absolute;
  right: 8px;
  top: 8px;
  z-index: 10;
}

.editable-section:hover .edit-btn {
  opacity: 1;
  transform: scale(1.05);
  background: var(--gold);
}

.editable-section .edit-btn:hover {
  background: var(--gold) !important;
  transform: scale(1.1) !important;
  box-shadow: 0 3px 8px rgba(0,0,0,0.2);
}

.editable-section .edit-btn:active {
  transform: scale(0.95) !important;
}

/* Special positioning for different types */
.editable-list-container .edit-btn {
  right: 16px;
  top: 16px;
}

.editable-section[data-section-type="intro"] .edit-btn {
  right: 12px;
  top: 12px;
}

/* Title edit buttons */
.edit-title-btn {
  position: relative !important;
  right: auto !important;
  top: auto !important;
  margin-left: 12px;
  transform: none !important;
}

.edit-title-btn:hover {
  transform: scale(1.1) !important;
}

/* When editing, hide the button and expand content */
.editable-section[data-editing="true"] .edit-btn {
  display: none;
}

/* Visual feedback for editable sections */
.editable-section:hover {
  background: rgba(184, 134, 11, 0.05);
  border-radius: 8px;
  transition: background 0.2s ease;
}

.editable-section[data-editing="true"] {
  background: rgba(255, 255, 0, 0.1);
  border: 1px dashed var(--bronze);
  border-radius: 8px;
  padding: 8px;
}

/* Legacy support for old list items */
.editable-item {
  position: relative;
  padding-right: 40px;
}

.editable-content {
  display: block;
  margin-right: 35px;
}

/* === MJ-ONLY VISIBILITY CONTROLS === */
/* Show MJ-only elements when MJ state is active */
body.mj-on .mj-only {
  display: block !important;
}

/* Hide MJ-only elements by default and when MJ is off */
.mj-only,
body.mj-off .mj-only {
  display: none !important;
}

/* Show non-MJ elements by default and when MJ is off */
.non-mj-only,
body.mj-off .non-mj-only {
  display: block !important;
}

/* Hide non-MJ elements when MJ is on */
body.mj-on .non-mj-only {
  display: none !important;
}

/* For flex and inline-flex elements */
body.mj-on .mj-only[style*="display: flex"] {
  display: flex !important;
}

body.mj-on .mj-only[style*="display: inline-flex"] {
  display: inline-flex !important;
}

/* === DEV-ONLY VISIBILITY CONTROLS === */
/* Show dev-only elements when dev mode is active */
body.dev-on .dev-only {
  display: block !important;
}

/* Hide dev-only elements by default and when dev is off */
.dev-only,
body.dev-off .dev-only {
  display: none !important;
}

/* Show non-dev elements by default and when dev is off */
.non-dev-only,
body.dev-off .non-dev-only {
  display: block !important;
}

/* Hide non-dev elements when dev is on */
body.dev-on .non-dev-only {
  display: none !important;
}

/* For flex and inline-flex elements in dev mode */
body.dev-on .dev-only[style*="display: flex"] {
  display: flex !important;
}

body.dev-on .dev-only[style*="display: inline-flex"] {
  display: inline-flex !important;
}
</style>
</head>
<body class="dev-off">

<div class="shell">
  <button aria-controls="sidebar" aria-expanded="false" aria-label="Ouvrir le sommaire" class="menu-toggle" id="menuToggle" style="display:none">â˜° Sommaire</button>
  <div class="backdrop" hidden="" id="backdrop"></div>
  
  <main class="page">
    <aside class="sidebar" id="sidebar">
      <div class="panel">
        <div class="searchbar">
          <input autocomplete="off" id="search" placeholder="Rechercher une rÃ¨gle, une classeâ€¦">
          <button class="btn" id="clear" title="Effacer">âœ–</button>
        </div>
        <div class="tools">
          <!-- Dev mode disabled in standalone version -->
        </div>
        <div class="toc" id="toc">
          <!-- Table of contents will be generated by JavaScript -->
        </div>
      </div>
    </aside>
    
    <div id="views">
      <!-- Main content will be generated by JavaScript -->
      <div id="app-loading">Chargement...</div>
    </div>
  </main>
  
  <footer></footer>
</div>

<script>

    // Ensure window object exists
    window = window || {};
    
    // Global data from modular files
    window.SORTS = [
  {
    "nom": "Sorts de Mage",
    "description": "Sorts de destruction.",
    "sorts": [
      {
        "nom": "Boule de Feu",
        "element": "Feu",
        "description": "Lance une boule de feu sur un adversaire, qui peut s'enflammer.",
        "categorie": "Mage",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 15m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 3",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige 5 dÃ©gats de <span style=\"color: #e25822; font-weight: bold;\">Feu</span> Ã  la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Les dÃ©gats passent Ã  7 et la cible s'enflamme, infligeant 5 dÃ©gats de feu au prochain tour du lanceur."
      },
      {
        "nom": "Ã‰clair",
        "element": "Air",
        "description": "Frappe instantannÃ©ment une cible avec un Ã©clair Ã©lectrique, ne laissant aucune chance Ã  l'esquive.",
        "categorie": "Mage",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 2",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 12m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 5",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> &nbsp;Inflige 6 dÃ©gats d'<span style=\"color: #22c55e; font-weight: bold;\">Air</span> Ã  la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> Les dÃ©gÃ¢ts passent Ã  10 et ils sont aussi infligÃ© Ã  un ennemi Ã  moins de 3m de la cible."
      },
      {
        "nom": "Vague dÃ©ferlante",
        "element": "Eau",
        "description": "Une puissante vague d'eau s'abat sur vos ennemis et les repousse.",
        "categorie": "Sorts de Mage",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 3",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 6m",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 6",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> Volant.",
        "effetNormal": "<strong>Effet:</strong> &nbsp;Inflige 6 dÃ©gats d'<span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span> aux crÃ©ature devant le lanceur (largeur 3m distance 6m) et les repousse jusqu'Ã  6m.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> les dÃ©gats passent Ã  10 et les enemis sont touchÃ©s/repoussÃ©s Ã  12m."
      },
      {
        "nom": "VolÃ©e de pierres",
        "element": "Terre",
        "description": "Invoque une volÃ©e de pierres qui tournoient autour du lanceur, puis qui sont Ã©jectÃ©es devant lui.",
        "categorie": "Sorts de Mage",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 4",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 6m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 10",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige 7 dÃ©gats de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> aux crÃ©atures autour du lanceur (3m). <br>Puis inflige le mÃªme montant aux crÃ©atures devant le lanceur sur 6m.<br><br>&nbsp;Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Les dÃ©gats passent Ã  12. Les cibles non volantes et de taille moyennes sont <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span> pendant 1 tour."
      }
    ]
  },
  {
    "nom": "Sorts de PrÃªtre",
    "description": "Sorts de soutiens et anti mort-vivants.",
    "sorts": [
      {
        "nom": "ChÃ¢timent",
        "element": "Divin",
        "description": "Invoque un magie divine qui blesse les morts-vivants",
        "categorie": "Anti-mort-vivant",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 3",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 18m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 3",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> &nbsp;<br>- Non mort-vivant <br>- Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige *Intelligence* dÃ©gÃ¢ts <span style=\"color: #d0d0d0; font-weight: bold; background: rgba(0, 0, 0, 0.4); padding: 2px 4px; border-radius: 3px;\">Divin</span> Ã  la cible.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>Double dÃ©gÃ¢ts."
      },
      {
        "nom": "Refermer les blessures",
        "element": "Divin",
        "description": "Une magie divine soigne les blessures rÃ©centes du hÃ©ros ou d'un alliÃ© proche.",
        "categorie": "Sorts de PrÃªtre",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 3m",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 5",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> &nbsp;\n<br>- Hors combat.\n<br>- La cible n'a pas Ã©tÃ© blessÃ©e pendant plus de 3 tours.",
        "effetNormal": "<strong>Effet:</strong> Soigne la cible de 5 points de vie. Tous les 5 points d'intelligence, augmente le soin de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>Double le soin."
      },
      {
        "nom": "Protection",
        "element": "LumiÃ¨re",
        "description": "ProtÃ¨ge le lanceur ou un alliÃ©.",
        "categorie": "Sorts de PrÃªtre",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 2",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 3m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 5",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Augmente l'armure de 2 pendant 5 tours.<br> Tous les 5 d'Intelligence, augmente l'armure de 1 supplÃ©mentaire.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> L'armure est augmentÃ©e de 4."
      },
      {
        "nom": "Arme de lumiÃ¨re",
        "element": "LumiÃ¨re",
        "description": "Une lumiÃ¨re destructrice s'imprÃ¨gne de l'arme du prÃªtre.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> -",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 5",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> L'arme du prÃªtre infligera 2 dÃ©gats de lumiÃ¨re Ã  chaque coup, pendant 4 tours.<br> Tous les 5 d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Les dÃ©gats passent Ã  4."
      }
    ]
  },
  {
    "nom": "Sorts d'Enchanteur",
    "description": "Sorts d'amÃ©lioration et d'affaiblissement.",
    "sorts": [
      {
        "nom": "Accroche terrestre",
        "element": "Terre",
        "description": "Le sol se soulÃ¨ve et s'agrippe aux jambes de la cible, alourdissant ses pas d'une Ã©treinte de pierre vivante.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 30m",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 3",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> <br>- RÃ©sistance altÃ©rations &gt; Intelligence du lanceur<br>- LÃ©vitation ou Volant.",
        "effetNormal": "<strong>Effet:</strong>&nbsp;La cible contracte l'Ã©tat <span class=\"etat-link\" data-etat=\"Ralenti\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Ralenti</span> pendant 5 tours.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>La cible ne peut plus effectuer de dÃ©placement pendant la durÃ©e du sort."
      },
      {
        "nom": "AccÃ©lÃ©ration",
        "element": "Air",
        "description": "Une magie des vents accÃ©lÃ¨re un alliÃ© ou le lanceur.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 6m",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 4",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> Aucune",
        "effetNormal": "<strong>Effet:</strong> &nbsp;La vitesse de dÃ©placement de la cible est augmentÃ©e de 3m pendant 5 tours. Non Cumulable.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> La vitesse est augmentÃ©e de 6m."
      },
      {
        "nom": "Sommeil",
        "element": "Nuit",
        "description": "Un voile d'ombre caresse la cible, l'enveloppant dans un sommeil surnaturel.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 2",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 6m",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 8",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> <br>- RÃ©sistance altÃ©rations &gt; Intelligence du lanceur<br>- Element <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span>",
        "effetNormal": "<strong>Effet:</strong> La cible passe dans l'Ã©tat <span class=\"etat-link\" data-etat=\"Endormi/assomÃ©/EffrayÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Endormi</span> pendant ses 2 prochains tours.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> L'effet dure 4 tours."
      }
    ]
  }
];
    window.CLASSES = [
  {
    "nom": "Guerrier",
    "resume": "HÃ©ros sans Ã©gal au combat au corp Ã  corp.",
    "capacites": "<ul><li><em>Expert de l'Ã©quipement</em> : Capable d'utiliser toutes les armes (Ã©pÃ©es, arcs, batons, dagues, exotiques, une main et deux mains), armures (robes, lÃ©gÃ¨res, lourdes), et boucliers.</li><li><em>Hardiesse</em> : Gagne la compÃ©tence Hardiesse rang 1.</li></ul>",
    "sousClasses": [
      {
        "nom": "Nain des montagnes",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>5</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>1</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>7</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>1</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>5</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>1</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +2 Force ğŸ’ª, +3 Endurance ğŸ›¡ï¸, +1 VolontÃ©âš¡   <strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Brise rocher : </em> Gagne 1 de compÃ©tence sur les tests de compÃ©tence Hardiesse pour une destruction d'objet.</li><li><em>VolontÃ© inflexible :</em> Les nains possÃ¨dent une volontÃ© inflexible qui les rendent rÃ©sistants aux sortilÃ¨ges (caractÃ©ristique VolontÃ© Ã©levÃ©e).</li></ul>",
        "description": "<i>Race robuste et inflexible, dotÃ©e dâ€™une endurance exceptionnelle. ForgÃ©s par la roche et les sommets, ils rÃ©sistent aux Ã©preuves et possÃ¨dent une force colossale capable de briser murs, armures et crÃ©atures cuirassÃ©es.</i>"
      },
      {
        "nom": "Berserker",
        "base": {
          "Force": 5,
          "AgilitÃ©": 4,
          "Endurance": 5,
          "Intelligence": 1,
          "VolontÃ©": 1,
          "Chance": 1
        },
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +3 Force ğŸ’ª, +1 AgilitÃ© ğŸƒ, +1 Endurance ğŸ›¡ï¸<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Tourbillon de rage :</em> Sur un critique au corps Ã  corps, touche aussi tous les adversaires Ã  moins de 3m.</li><li><em>Risque sauvage :</em> +1 chance de critique physique s'il ne porte pas de bouclier.</li></ul>",
        "description": "<i>Combattant sauvage, maÃ®tre des armes Ã  deux mains. Sa rage dÃ©cuple sa force, lui permettant dâ€™abattre ses ennemis dans un dÃ©chaÃ®nement de puissance brute et de coups imparables.</i>"
      },
      {
        "nom": "Aventurier",
        "description": "<i>HÃ©ros polyvalent et ingÃ©nieux, il affronte lâ€™inconnu avec courage, et manie tous les outils Ã  sa portÃ©e pour triompher.</i>",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>5</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>2</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>5</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>1</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>1</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>5</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +2 Force ğŸ’ª, +2 Endurance ğŸ›¡ï¸, +1 Chance ğŸ€, <strong> +2 Au choix</strong>",
        "capacites": "<ul><em>PassÃ© glorieux : </em>  Gagne la compÃ©tence Eloquence rang 1.<br><em>Sans failles :</em>  Dispose d'un Effort maximum supplÃ©mentaire .<br><em>Polyvalent : </em> Dispose d'un point de Don supplÃ©mentaire.</ul>"
      },
      {
        "nom": "MaÃ®tre dâ€™armes",
        "description": "<i>Guerrier Ã©rudit et redoutable, il manie avec aisance toutes les armes, des plus communes aux plus exotiques, transformant chaque outil de guerre en prolongement de son bras.</i>",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>5</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>2</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>5</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>1</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>3</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>1</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +3 Force ğŸ’ª, +2 Endurance ğŸ›¡ï¸<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Volte dâ€™armes :</em> Peut changer d'arme sans utiliser d'action secondaire.\n</li>\n               <li><em>Expert martial :</em> Lorsqu'il utilise une arme exotique, relance le dÃ© en cas d'echec critique.\n</li>\n   <li><em>Erudit des lames :</em> Gagne 1 de compÃ©tence sur les tests de compÃ©tence RÃ©flexion sur l'effet ou la provenance d'une arme.\n</li>\n\n</ul>"
      }
    ]
  },
  {
    "nom": "Mage",
    "resume": "SpÃ©cialiste de la magie destructrice.",
    "capacites": "<ul><li><em>Ã‰quipement de mage</em> : bÃ¢tons (une et deux mains), robes.</li><li><em>Sorts de mage</em> : Apprend et lance des sorts de mage.</li></ul>",
    "sousClasses": [
      {
        "nom": "Ã‰rudit",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>1</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>1</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>1</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>6</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>3</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>1</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +3 Intelligence ğŸ§ , +2 VolontÃ© âš¡<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Instruit</em> : Gagne la compÃ©tence RÃ©flexion rang 1.</li><li><em>Apprentissage accÃ©lÃ©rÃ©</em> : Le niveau de l'Ã©rudit est considÃ©rÃ© comme deux fois plus Ã©levÃ© pour les prÃ©requis d'apprentissage de sorts.</li></ul>",
        "description": "<i>Mage avide de savoir, dotÃ© dâ€™une mÃ©moire prodigieuse. Il assimile les arcanes avec une rapiditÃ© fulgurante et maÃ®trise de nouveaux sorts bien plus vite que ses pairs.</i>"
      },
      {
        "nom": "Elfe",
        "base": {
          "Force": 2,
          "AgilitÃ©": 2,
          "Endurance": 3,
          "Intelligence": 3,
          "VolontÃ©": 2,
          "Chance": 1
        },
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +1 Force ğŸ’ª, +1 AgilitÃ© ğŸƒ, +1 Endurance ğŸ›¡ï¸, +1 Intelligence ğŸ§ , +1 VolontÃ© âš¡<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Instinct elfique</em> : Gagne la compÃ©tence Coordination rang 1.</li><li><em>Ã‰quipement d'elfe</em> : EpÃ©es Ã  une main, armures lÃ©gÃ¨res.</li><li><em>Briseur de sceaux</em> : Gagne 1 de compÃ©tence sur les tests de compÃ©tence pour comprendre ou ouvrir une porte scellÃ©e magiquement</li></ul>",
        "description": "<i>Guerrier-mage polyvalent, aussi agile quâ€™Ã©lÃ©gant. MaÃ®tre des arcanes comme du combat rapprochÃ©, il allie puissance magique et adresse martiale avec une grÃ¢ce inÃ©galÃ©e.</i>"
      }
    ]
  },
  {
    "nom": "PrÃªtre",
    "resume": "SpÃ©cialiste de la magie de soutien et anti morts-vivants.",
    "capacites": "<ul><li><em>Ã‰quipement de prÃªtre</em> : bÃ¢tons (une et deux mains), robes.</li><li><em>Sorts de prÃªtre</em> : Apprend et lance des sorts de PrÃªtre.</li><li><em>Eloquence</em> : Gagne la compÃ©tence Eloquence rang 1.</li></ul>",
    "sousClasses": [
      {
        "nom": "Inquisiteur",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>3</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>1</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>4</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>3</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>5</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>1</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +1 Force ğŸ’ª, +1 Intelligence ğŸ§ , +2 VolontÃ© âš¡, +1 Endurance ğŸ›¡ï¸<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Equipement d'inquisiteur</em> : Peut s'Ã©quiper d'armures lÃ©gÃ¨res et de boucliers.</li><li><em>FlÃ©au des morts-vivants</em> : Les sorts visant les morts-vivants ne ratent jamais.</li><li><em>LumiÃ¨re purificatrice</em> : Double l'effet de l'intelligence sur les dÃ©gats des sorts d'Ã©lÃ©ment <span style=\"color: #ffd700; font-weight: bold;\">LumiÃ¨re</span> ou <span style=\"color: #f5f5f5; font-weight: bold; background: rgba(100, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;\">Divin</span>.</li></ul>",
        "description": "<i>Champion de la foi, il renforce ses alliÃ©s par la magie sacrÃ©e et traque sans relÃ¢che les morts-vivants. Quand la lumiÃ¨re seule ne suffit plus, il nâ€™hÃ©site pas Ã  prendre les armes et combattre en premiÃ¨re ligne.</i>"
      },
      {
        "nom": "Clerc Divin",
        "base": {
          "Force": 1,
          "AgilitÃ©": 1,
          "Endurance": 2,
          "Intelligence": 3,
          "VolontÃ©": 5,
          "Chance": 5
        },
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +2 Intelligence ğŸ§ , +2 VolontÃ© âš¡, +1 Chance ğŸ€<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>MaÃ®tre des soins</em> : Double l'effet de l'intelligence sur les sorts de soins.</li><li><em> Pieu </em>:  Gagne 1 de compÃ©tence sur les tests de compÃ©tence Reflexion sur un dieu ou une religion.</li><li><em> Protection divine </em>:  Dispose d'une armure Ã©lementaire <span style=\"color: #f5f5f5; font-weight: bold; background: rgba(100, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;\">Divin</span> de 10.</li></ul>",
        "description": "<i>Serviteur sacrÃ©, maÃ®tre des arts de guÃ©rison. Sa puissante magie de soins protÃ¨ge ses alliÃ©s et les relÃ¨ve mÃªme aux portes de la mort.</i>"
      }
    ]
  },
  {
    "nom": "RÃ´deur",
    "resume": "HÃ©ros trÃ¨s agile.",
    "capacites": "<ul><li><em>Ã‰quipement de rÃ´deur</em> : Dagues, robes, armures lÃ©gÃ¨res.</li><li><em>Coordination</em> : Gagne la compÃ©tence Coordination rang 1.</li></ul>",
    "sousClasses": [
      {
        "nom": "Voleur",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>3</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>5</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>2</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>2</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>2</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>5</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +2 AgilitÃ© ğŸƒ, +2 Force ğŸ’ª, +1 Endurance ğŸ›¡ï¸<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Mains expertes :</em> Gagne la compÃ©tence Finesse rang 1.</li><li><em>Sprint :</em> Peut utiliser une action secondaire pour doubler sa vitesse de dÃ©placement.</li><li><em>Vicieux :</em> Double les chances de critiques physiques sur les cibles subissant un Ã©tat qui les empeche d'esquiver.</li></ul>",
        "description": "<i>MaÃ®tre de la finesse et de lâ€™agilitÃ©, il se dÃ©place avec rapiditÃ© fulgurante et frappe lÃ  oÃ¹ Ã§a fait le plus mal. </i>"
      },
      {
        "nom": "Chasseur",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>3</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>5</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>2</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>4</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>2</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>1</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +2 AgilitÃ© ğŸƒ, +1 Force ğŸ’ª, +1 Endurance ğŸ›¡ï¸, +1 Intelligence ğŸ§ <strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Armes du Chasseur</em> : Peut utiliser les arcs.</li><li><em>Cueillette</em> : Une fois par jour, lors dâ€™un repos, le personnage peut rÃ©colter 5 plantes locales (au choix du MJ). Leur efficacitÃ© dÃ©pend de lâ€™Intelligence de lâ€™utilisateur.</li><li><em>Connaissance du milieu naturel</em> : Gagne 1 de compÃ©tence sur les tests de RÃ©flexion liÃ© Ã  animal, un monstre, une plante, ou la dÃ©couverte de passages dÃ©robÃ©s en milieu naturel.</li></ul>",
        "description": "<i>PrÃ©cis et agile, il complÃ¨te son art de lâ€™arc par la science des herbes anciennes.</i>"
      }
    ]
  },
  {
    "nom": "Enchanteur",
    "resume": "DÃ©tenteur d'une magie singuliÃ¨re, qui fait de lui un alliÃ© prÃ©cieux.",
    "capacites": "<ul><li><em>Ã‰quipement d'enchanteur</em> : bÃ¢tons (une et deux mains), dagues, Robes.</li><li><em>Sorts d'enchanteur</em> : Apprend et lance des sorts d'Enchanteur.</li></ul>",
    "sousClasses": [
      {
        "nom": "Esprit de la grande FÃ©e",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>1</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>5</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>2</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>5</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>2</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>1</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +1 AgilitÃ© ğŸƒ, +1 Intelligence ğŸ§ , +1 Endurance ğŸ›¡ï¸, +1 VolontÃ© âš¡, +1 Chance ğŸ€<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Tatillon</em> : Gagne la compÃ©tence Finesse rang 1.</li><li><em>LÃ©vitation</em> : Ignore dÃ©gÃ¢ts/ralentissements venant du sol.</li><li><em>Rayon de l'AmitiÃ©</em> : Par une action secondaire, peut rÃ©pÃ©ter sur une autre cible Ã  portÃ©e un sort bÃ©nÃ©fique qui a ciblÃ© un alliÃ© se tour ci, sans coÃ»t en mana supplÃ©mentaire.</li></ul>",
        "description": "<i>ÃŠtre mystique qui flotte au-dessus du sol, il invoque des sorts imprÃ©visibles pour soutenir ses alliÃ©s.</i>"
      },
      {
        "nom": "Lutin",
        "base": {
          "Force": 1,
          "AgilitÃ©": 1,
          "Endurance": 1,
          "Intelligence": 5,
          "VolontÃ©": 2,
          "Chance": 5
        },
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +1 Intelligence ğŸ§ , +2 VolontÃ© âš¡, +2 Chance ğŸ€<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Secrets bien gardÃ©s</em> : Gagne la compÃ©tence Reflexion rang 1.</li><li><em>Expert des baguettes</em> : Sur un critique Ã  la baguette, la charge n'est pas consommÃ©e.</li><li><em>Rire malicieux</em> : Par une action secondaire, peut rÃ©pÃ©ter sur une autre cible Ã  portÃ©e un sort d'altÃ©ration qui a ciblÃ© un enemi ce tour ci, sans coÃ»t en mana supplÃ©mentaire.</li></ul>",
        "description": "<i>Esprit espiÃ¨gle et rusÃ©, passÃ© maÃ®tre dans lâ€™art des altÃ©rations magiques. </i>"
      }
    ]
  }
];
    window.DONS = [
  {
    "nom": "Generaux",
    "description": "Dons accessibles Ã  toutes les classes.",
    "dons": [
      {
        "nom": "DouÃ©",
        "description": "Gagne une compÃ©tence rang 1.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 points de don"
      },
      {
        "nom": "Toujours pret",
        "description": "Le maximum d'efforts maximum augmente de 1.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Brillant",
        "description": "Gagne une compÃ©tence rang 2.",
        "prerequis": "<strong> PrÃ©requis :</strong> La compÃ©tence rang 1.",
        "cout": "2 points de don"
      },
      {
        "nom": "Prodigieux",
        "description": "Gagne une compÃ©tence rang 3.",
        "prerequis": "<strong> PrÃ©requis :</strong> La compÃ©tence rang 2.",
        "cout": "3 point de don"
      },
      {
        "nom": "Hyperactif",
        "description": "Le hÃ©ros dispose maintenant de deux actions secondaires par tour.",
        "prerequis": "<strong> PrÃ©requis :</strong> Niveau 3",
        "cout": "2 points de don"
      },
      {
        "nom": "Equitation",
        "description": "Permet de monter Ã  cheval ou Ã©quivalent.",
        "prerequis": "<strong> PrÃ©requis :</strong> Niveau 5",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Guerrier",
    "description": "Dons accessibles aux guerriers.",
    "dons": [
      {
        "nom": "Expertise du bouclier",
        "description": "Si le hÃ©ros a un bouclier Ã©quipÃ©, il peut utiliser une action secondaire pour doubler l'armure physique du bouclier jusqu'au prochain tour.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Charge",
        "description": "Une fois par combat, peut utiliser une action secondaire pour doubler sa vitesse de dÃ©placement et forcer un coup critique sur la prochaine attaque physique de ce tour (si elle rÃ©ussie).",
        "prerequis": "<strong> PrÃ©requis :</strong> ğŸƒAgilitÃ© 5",
        "cout": "1 point de don"
      },
      {
        "nom": "VolontÃ© de fer",
        "description": "Une fois par jour, le hÃ©ros peut utiliser une action secondaire pour se dÃ©barasser de toutes ses alterations magiques.",
        "prerequis": "<strong> PrÃ©requis :</strong> âš¡VolontÃ© 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Coup de bouclier",
        "description": "Si le hÃ©ros a un bouclier Ã©quipÃ©, lorsque le hÃ©ros subit des dÃ©gats aux corps Ã  corps, il peut choisir d'utiliser une action secondaire pour infliger Ã  l'attaquant des dÃ©gats Ã©quivalents Ã  l'armure du bouclier.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Coup de pommeau",
        "description": "Description du don.",
        "prerequis": "Aucun prÃ©requis",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "RÃ´deur",
    "description": "Dons accessibles aux rodeurs.",
    "dons": [
      {
        "nom": "Croche-patte",
        "description": "Peut utiliser une action principale pour effectuer un croche- patte :\n\n\n<br><br><b>Sans effet si :</b> \n<br>- Esquive.\n<br>- Volant ou lÃ©vitant.\n<br>- Taille supÃ©rieure Ã  Moyen.\n\n<br><br><b>Effet :</b> Inflige (Force) dÃ©gats Physiques Ã  la cible. Met la cible dans l'Ã©tat <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span>.\nâœï¸\n<br><br><b>Coup Critique :</b>  Les dÃ©gats sont doublÃ©s et la cible est <span class=\"etat-link\" data-etat=\"Endormi/assomÃ©/EffrayÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">AssomÃ©</span> 1 tour.\n\n<br><br><hr>",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Chasse et pÃªche",
        "description": "Le hÃ©ros n'as plus besoin de sa ratio de nourriture quotidienne.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Attaque d'opportunitÃ©",
        "description": "Description du don.",
        "prerequis": "Aucun prÃ©requis",
        "cout": "1 point de don"
      },
      {
        "nom": "D",
        "description": "Description du don.",
        "prerequis": "Aucun prÃ©requis",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Mage",
    "description": "Description de cette catÃ©gorie de dons.",
    "dons": [
      {
        "nom": "Gemme de mana",
        "description": "Une fois par jour, le hÃ©ros peut rÃ©cupÃ©rer l'intÃ©gralitÃ© de son Mana en utilisant une action secondaire.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Resistance Ã©lÃ©mentaire 1",
        "description": "Le hÃ©ros gagne 5 d'armure Ã©lÃ©mentaire de <span style=\"color: #e25822; font-weight: bold;\">Feu</span>, <span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span>, <span style=\"color: #8b5e34; font-weight: bold;\">Terre</span>, <span style=\"color: #22c55e; font-weight: bold;\">Air</span>.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Resistance magique 1",
        "description": "Le hÃ©ros gagne 5 d'armure Ã©lÃ©mentaire de <span style=\"color: #ffd700; font-weight: bold;\">LumiÃ¨re</span>, <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span>, <span style=\"color: #d0d0d0; font-weight: bold; background: rgba(0, 0, 0, 0.4); padding: 2px 4px; border-radius: 3px;\">Divin</span>, <span style=\"color: #a855f7; font-weight: bold;\">MalÃ©fique</span>.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "SpÃ©cialisation Ã©lÃ©mentaire 1",
        "description": "Le hÃ©ros peut choisir un Ã©lÃ©ment et augmenter de 5 les dÃ©gats infligÃ©s avec les sorts de cet Ã©lÃ©ment.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Infusion Ã©lÃ©mentaire",
        "description": "AprÃ©s avoir lancÃ© un sort, le hÃ©ros peut, en utilisant une action secondaire, imprÃ©gner son arme de l'Ã©lÃ©ment du sort. Elle infligera Ã  sa prochaine attaque physique des dÃ©gats de cet Ã©lÃ©ment Ã©quivalents au niveau du sort.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Polyglotte",
        "description": "Peut lire et parler toutes les langues.",
        "prerequis": "<strong> PrÃ©requis :</strong> Reflexion rang 2.",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Pretre",
    "description": "Description de cette catÃ©gorie de dons.",
    "dons": [
      {
        "nom": "MÃ©crÃ©ants",
        "description": "Les dÃ©gats physiques infligÃ©s aux crÃ©atures de l'Ã©lÃ©ment <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span> ou <span style=\"color: #a855f7; font-weight: bold;\">MalÃ©fique</span> sont doublÃ©s.",
        "prerequis": "<strong> PrÃ©requis :</strong>-",
        "cout": "1 point de don"
      },
      {
        "nom": "Au milieu du combat",
        "description": "Permet d'utiliser s'Ã©quiper de dagues.",
        "prerequis": "<strong> PrÃ©requis :</strong>ğŸƒAgilitÃ© 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Jugement Ã©clair",
        "description": "Si le PrÃªtre a effectuÃ© un sort ce tour ci, il peut effectuer une attaque au corp Ã  corp avec une action secondaire.",
        "prerequis": "<strong> PrÃ©requis :</strong>ğŸ’ªForce 3",
        "cout": "1 point de don"
      },
      {
        "nom": "Musique",
        "description": "Permet d'apprendre un instrument de musique (ou de savoir chanter) au choix, gagnant 2 de compÃ©tences sur les tests de compÃ©tence Ã©loquence le nÃ©cÃ©ssitant.",
        "prerequis": "<strong> PrÃ©requis :</strong>-",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Enchanteur",
    "description": "Dons accessibles aux enchanteurs.",
    "dons": [
      {
        "nom": "RÃ©parateur de baguettes",
        "description": "Permet de regagner une charge de baguette, une fois par jour.",
        "prerequis": "<strong> PrÃ©requis :</strong>-",
        "cout": "1 point de don"
      },
      {
        "nom": "Magie alÃ©atoire destructrice",
        "description": "Permet de choisir et d'apprendre un sort de mage et de pouvoir le lancer Ã  volontÃ©. Le sort ne peut pas Ãªtre changÃ© par la suite.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Magie alÃ©atoire de soutien",
        "description": "Permet de choisir et d'apprendre un sort de prÃªtre et de pouvoir le lancer Ã  volontÃ©. Le sort ne peut pas Ãªtre changÃ© par la suite.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Alteration risquÃ©e",
        "description": "Lorsque un sort d'alteration magique est effectuÃ© alors que la cible est au corps Ã  corps, ses chances de critiques sont doublÃ©es.",
        "prerequis": "<strong> PrÃ©requis :</strong>-",
        "cout": "1 point de don"
      }
    ]
  }
];
    window.OBJETS = {
  "objets": [
    {
      "nom": "Espadon",
      "numero": 1,
      "image": "",
      "description": "<i>Longue Ã©pÃ©e Ã  deux mains, lourde mais puissante.</i>",
      "tags": [
        "Arme",
        "Ã‰pÃ©e",
        "Deux mains"
      ],
      "effet": "<strong>DÃ©gÃ¢ts: </strong> Inflige (5  + Force) points de dÃ©gats physiques.",
      "prix": "ğŸ”· <strong>Prix:</strong> 35",
      "poids": "âš–ï¸ <strong>Poids:</strong> 2"
    },
    {
      "nom": "Simple Ã©pÃ©e",
      "numero": 2,
      "image": "",
      "description": "<i>Arme droite et Ã©quilibrÃ©e, conÃ§ue pour Ãªtre maniÃ©e dâ€™une seule main</i>",
      "tags": [
        "Arme",
        "Ã‰pÃ©e",
        "Une main"
      ],
      "effet": "<span style=\"font-weight: 700; font-family: \" source=\"\" serif=\"\" pro\",=\"\" serif;=\"\" color:=\"\" rgb(74,=\"\" 44,=\"\" 23);=\"\" text-shadow:=\"\" rgba(0,=\"\" 0,=\"\" 0.05)=\"\" 0px=\"\" 1px=\"\" 2px;\"=\"\">DÃ©gÃ¢ts: </span> Inflige (2  + Force) points de dÃ©gats physiques.",
      "prix": "ğŸ”· <strong>Prix:</strong> 20",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Dague en fer",
      "numero": 3,
      "image": "",
      "description": "<i>Petite lame simple, lÃ©gÃ¨re et maniable.</i>",
      "tags": [
        "Arme",
        "Une main",
        "Dague"
      ],
      "effet": "<strong>DÃ©gÃ¢ts: </strong> Inflige (1  + Force) points de dÃ©gats physiques.",
      "prix": "ğŸ”· <strong>Prix:</strong> 10",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "BÃ¢ton en bois",
      "numero": 4,
      "image": "",
      "description": "<i>Long bÃ¢ton solide, utilisÃ© comme arme et appui.</i>",
      "tags": [
        "Arme",
        "Deux mains",
        "Baton"
      ],
      "effet": "<strong>DÃ©gÃ¢ts: </strong> Inflige (2  + Force) points de dÃ©gats physiques.",
      "prix": "ğŸ”· <strong>Prix:</strong> 5",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Gourdin",
      "numero": 5,
      "image": "",
      "description": "<i>Arme rudimentaire faite de bois dur. </i>",
      "tags": [
        "Arme",
        "Une main",
        "Baton"
      ],
      "effet": "<strong>DÃ©gÃ¢ts: </strong> Inflige (1  + Force) points de dÃ©gats physiques.",
      "prix": "ğŸ”· <strong>Prix:</strong> 10",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Arc simple",
      "numero": 6,
      "image": "",
      "description": "<i>Arc basique en bois, sans ornement.</i>",
      "tags": [
        "Arme",
        "Deux mains",
        "Arc"
      ],
      "effet": "<strong>PortÃ©e: </strong> 12m.<br>\n<strong>DÃ©gÃ¢ts: </strong> Inflige (Force) points de dÃ©gats physiques.",
      "prix": "ğŸ”· <strong>Prix:</strong> 30",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Bouclier en bois",
      "numero": 7,
      "image": "",
      "description": "<i>Un bouclier grossier taillÃ© dans des planches Ã©paisses, marquÃ© de cicatrices de bataille.</i>",
      "tags": [
        "Bouclier"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 2.",
      "prix": "ğŸ”· <strong>Prix:</strong> 15",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Robe simple",
      "numero": 8,
      "image": "",
      "description": "<i>Une robe de toile modeste, aux plis fatiguÃ©s mais encore emplis de dignitÃ©.</i>",
      "tags": [
        "Armure",
        "Robe"
      ],
      "effet": "<strong>Effet:</strong> Augmente la VolontÃ© de 1.",
      "prix": "ğŸ”· <strong>Prix:</strong> 20",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Armure de cuir",
      "numero": 9,
      "image": "",
      "description": "<i>Une armure souple en cuir tannÃ©, taillÃ©e pour offrir une protection rudimentaire.</i>",
      "tags": [
        "Armure",
        "Armure lÃ©gÃ¨re"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 1.",
      "prix": "ğŸ”· <strong>Prix:</strong> 30",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Armure en maille",
      "numero": 10,
      "image": "",
      "description": "<i>Une cotte de mailles dont chaque anneau forgÃ© promet rÃ©sistance et endurance au combat.</i>",
      "tags": [
        "Armure",
        "Armure lourde"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 3.",
      "prix": "ğŸ”· <strong>Prix:</strong> 65",
      "poids": "âš–ï¸ <strong>Poids:</strong> 2"
    },
    {
      "nom": "Armure de plaque",
      "numero": 11,
      "image": "",
      "description": "<i>Une imposante armure de mÃ©tal poli, dont les plaques luisantes forment une carapace presque impÃ©nÃ©trable.</i>",
      "tags": [
        "Armure",
        "Armure lourde"
      ],
      "effet": "<strong>Effet:</strong> Augmente l'armure physique de 6.",
      "prix": "ğŸ”· <strong>Prix:</strong> 200",
      "poids": "âš–ï¸ <strong>Poids:</strong> 2"
    },
    {
      "nom": "Petite potion de vie",
      "numero": 12,
      "image": "",
      "description": "<i>Une fiole Ã©carlate dont le liquide vif rÃ©gÃ©nÃ¨re les blessures et ranime les forces vitales.</i>",
      "tags": [
        "Consommable"
      ],
      "effet": "<strong>Effet:</strong> Rend 15 (critique : 25) points de vie au hÃ©ros.",
      "prix": "ğŸ”· <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Petite potion de mana",
      "numero": 13,
      "image": "",
      "description": "<i>Une essence azur miroitante qui restaure lâ€™Ã©nergie magique et ravive le flux des arcanes.</i>",
      "tags": [
        "Consommable"
      ],
      "effet": "<strong>Effet:</strong> Rend 20 (critique : 35) points de mana au hÃ©ros.",
      "prix": "ğŸ”· <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Baguette de boule de feu",
      "numero": 14,
      "image": "",
      "description": "<i>Une fine tige runique qui libÃ¨re des flammes brÃ»lantes au commandement de son porteur.</i>",
      "tags": [
        "Consommable",
        "Catalyseur"
      ],
      "effet": "<strong>Effet:</strong> Remplace votre prochaine action principale par le sort de mage <span class=\"spell-link\" data-spell=\"Boule de Feu\" data-category=\"Sorts de Mage\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Boule de Feu</span>. <br><i>Les prÃ©requis pour le sort ne sont pas requis mais le mana et l'intelligence du hÃ©ros sont utilisÃ©s.</i>\n    <br><br><strong>Charges :</strong> 3",
      "prix": "ğŸ”· <strong>Prix:</strong> 25",
      "poids": ""
    },
    {
      "nom": "Feuilleclaire",
      "numero": 15,
      "image": "",
      "description": "<i>Herbe des forÃªts profondes, aux feuilles luisantes et aux petites fleurs rosÃ©es. AppliquÃ©e directement sur la peau, elle referme les plaies et apaise la douleur presque instantanÃ©ment.</i>",
      "tags": [
        "Consommable",
        "Plante"
      ],
      "effet": "<strong>Effet:</strong> Rend 10 (critique : 20) points de vie au hÃ©ros ou Ã  une cible proche.\n<br>Tous les 5 points d'intelligence, augmente les soins de 1.",
      "prix": "ğŸ”· <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Nocteline",
      "numero": 16,
      "image": "",
      "description": "<i>une plante sombre aux fleurs violettes dont lâ€™essence neutralise les venins et purifie le sang.</i>",
      "tags": [
        "Consommable",
        "Plante"
      ],
      "effet": "<strong>PrÃ©requis:</strong> Intelligence 5.<br>\n<strong>Effet:</strong> Soigne le hÃ©ros ou une cible proche du poison.",
      "prix": "ğŸ”· <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "Baguette de d'accÃ©lÃ©ration",
      "numero": 17,
      "image": "",
      "description": "<i>Une fine tige de cristal rayonnant, dont lâ€™Ã©clat sacrÃ© nimbe son porteur dâ€™une aura Ã©clatante, lui confÃ©rant une vitesse surnaturelle et des rÃ©flexes fulgurants.</i>",
      "tags": [
        "Consommable",
        "Catalyseur"
      ],
      "effet": "<strong>Effet:</strong> Remplace votre prochaine action principale par le sort d'enchanteur <span class=\"spell-link\" data-spell=\"AccÃ©lÃ©ration\" data-category=\"Sorts d'Enchanteur\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">AccÃ©lÃ©ration</span>. <br><i>Les prÃ©requis pour le sort ne sont pas requis mais le mana et l'intelligence du hÃ©ros sont utilisÃ©s.</i>\n    <br><br><strong>Charges :</strong> 3",
      "prix": "ğŸ”· <strong>Prix:</strong> 30",
      "poids": ""
    },
    {
      "nom": "Baguette de sommeil",
      "numero": 18,
      "image": "",
      "description": "<i>Une tige sombre incrustÃ©e de gemmes lunaires, qui libÃ¨re une aura tÃ©nÃ©breuse plongeant ses cibles dans un profond sommeil enchantÃ©.</i>",
      "tags": [
        "Consommable",
        "Catalyseur"
      ],
      "effet": "<strong>Effet:</strong> Remplace votre prochaine action principale par le sort d'enchanteur <span class=\"spell-link\" data-spell=\"Sommeil\" data-category=\"Sorts d'Enchanteur\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Sommeil</span>. <br><i>Les prÃ©requis pour le sort ne sont pas requis mais le mana et l'intelligence du hÃ©ros sont utilisÃ©s.</i>\n    <br><br><strong>Charges :</strong> 3",
      "prix": "ğŸ”· <strong>Prix:</strong> 30",
      "poids": ""
    },
    {
      "nom": "Ration de nourriture",
      "numero": 19,
      "image": "",
      "description": "<i>Un paquet frugal de pain sec et de viande salÃ©e.</i>",
      "tags": [
        "Nourriture"
      ],
      "effet": "Inutilisable en combat.\n<br><strong>Effet:</strong> Restore (Endurance) points de vie. <br>CouplÃ© Ã  un sommeil de 8h, permet d'Ã©viter l'etat <span class=\"etat-link\" data-etat=\"FatiguÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">FatiguÃ©</span>.",
      "prix": "ğŸ”· <strong>Prix:</strong> 5",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Ration copieuse de nourriture",
      "numero": 20,
      "image": "",
      "description": "<i>Un coffret garni de mets fins et de vin Ã©picÃ©, offrant rÃ©confort et vigueur bien au-delÃ  de la simple survie</i>",
      "tags": [
        "Nourriture"
      ],
      "effet": "Inutilisable en combat.\n<br><strong>Effet:</strong> Restore (Endurance) points de vie. <br>CouplÃ© Ã  un sommeil de 8h, permet d'Ã©viter l'etat <span class=\"etat-link\" data-etat=\"FatiguÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">FatiguÃ©</span>.\n<br><b>Charges :</b> 3",
      "prix": "ğŸ”· <strong>Prix:</strong> 15",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Fruits de la forÃªt",
      "numero": 21,
      "image": "",
      "description": "<i>Des baies juteuses et sucrÃ©es, cueillies Ã  lâ€™ombre des grands arbres, qui redonnent fraÃ®cheur et Ã©nergie.</i>",
      "tags": [
        "Nourriture"
      ],
      "effet": "Inutilisable en combat.\n<br><strong>Effet:</strong> Restore (Endurance) points de vie. <br>CouplÃ© Ã  un sommeil, permet d'Ã©viter l'etat <span class=\"etat-link\" data-etat=\"FatiguÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">FatiguÃ©</span>. <br>De plus, lorsque consommÃ©, le mangeur ne neccessite plus que 4 heures de sommeil ce jour-ci.\n<br><br><b>Charges :</b> 3",
      "prix": "ğŸ”· <strong>Prix:</strong> 20",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "Ration de survie",
      "numero": 22,
      "image": "",
      "description": "<i>Un maigre assemblage de galettes sÃ¨ches, de viande fumÃ©e et dâ€™eau amÃ¨re, conÃ§u pour soutenir la flamme vitale dans les heures les plus sombres.</i>",
      "tags": [
        "Nourriture"
      ],
      "effet": "Inutilisable en combat.\n<br><strong>Effet:</strong> CouplÃ© Ã  un sommeil de 8h, permet d'Ã©viter l'etat <span class=\"etat-link\" data-etat=\"FatiguÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">FatiguÃ©</span>.",
      "prix": "",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1"
    },
    {
      "nom": "FlÃ¨che aiguisÃ©e",
      "numero": 23,
      "image": "",
      "description": "<i>Un trait finement taillÃ©, dont la pointe acÃ©rÃ©e perce lâ€™armure avec une prÃ©cision mortelle.</i>",
      "tags": [
        "Consommable",
        "FlÃ¨che"
      ],
      "effet": "<b>Effet :</b> Renforce la prochaine attaque Ã  l'arc et lui rajoute +3 points de dÃ©gats physiques en cas de rÃ©ussite de l'attaque.\n\n<br><br><b>Charges :</b> 3",
      "prix": "ğŸ”· <strong>Prix:</strong> 10",
      "poids": ""
    },
    {
      "nom": "FlÃ¨che de la terre",
      "numero": 24,
      "image": "",
      "description": "<i>Une flÃ¨che alourdie de pierres runiques, qui libÃ¨re la force brutale de lâ€™Ã©lÃ©ment Terre Ã  lâ€™impact.</i>",
      "tags": [
        "Consommable",
        "FlÃ¨che"
      ],
      "effet": "<b>Effet :</b> Renforce la prochaine attaque Ã  l'arc et lui rajoute +5 points de dÃ©gats Ã©lÃ©mentaire de <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> en cas de rÃ©ussite de l'attaque.\n\n<br><br><b>Charges :</b> 3",
      "prix": "ğŸ”· <strong>Prix:</strong> 20",
      "poids": ""
    }
  ],
  "filterSettings": {
    "visibleTags": [
      "Consommable"
    ],
    "displayedFilterButtons": [
      "Arme",
      "Armure",
      "Consommable",
      "Bouclier"
    ]
  },
  "categoryDescription": "Ã‰quipements, armes, armures et objets divers que peuvent possÃ©der les personnages.",
  "description": "Fortune + d20"
};
    window.MONSTRES = [
  {
    "nom": "AraignÃ©e GÃ©ante",
    "tags": [
      "ForÃªt"
    ],
    "image": "data/images/Monstres/foret/Monstre_ForÃªt_AraignÃ©eGÃ©ante.png",
    "element": "Nuit",
    "pointsDeVie": 15,
    "armurePhysique": "0",
    "esquive": "2",
    "initiative": "3",
    "coupCritique": "1",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "3",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": "2",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": "5",
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Morsure venimeuse:</strong> Inflige 5 dÃ©gÃ¢ts Physiques. <br> Si (resistance altÃ©rations &lt; 3)  + <span class=\"etat-link\" data-etat=\"EmpoisonnÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">EmpoisonnÃ©</span> 1 pendant 5 tours.<br><br><strong>Toile:</strong> PortÃ©e 9m, equivable, <span class=\"etat-link\" data-etat=\"EntravÃ©/EntoilÃ©/EmbourbÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Entoile</span> la cible pendant 2 tour.",
    "butin": "<strong>Butin:</strong>",
    "monster-abilites": "AAAAAAAA",
    "monster-armurephysique": "0",
    "monster-coupcritique": "1",
    "monster-esquive": "2",
    "monster-resistancealterations": "3",
    "monster-coupcritiquesorts": "0",
    "monster-armureterre": "2",
    "monster-armureobscurite": "5",
    "monster-initiative": "3"
  },
  {
    "nom": "Crabe des Bois",
    "tags": [
      "ForÃªt"
    ],
    "image": "data/images/Monstres/foret/Monstre_ForÃªt_CrabedesBois.png",
    "element": "Eau",
    "pointsDeVie": "30",
    "armurePhysique": "5",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "1",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "5",
    "armureFeu": 0,
    "armureEau": "5",
    "armureTerre": "2",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "Attaque deux fois<br>  <strong>Pinces acÃ©rÃ©es:</strong> Inflige 7 dÃ©gÃ¢ts",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "Groink",
    "tags": [
      "ForÃªt"
    ],
    "image": "data/images/Monstres/foret/Monstre_ForÃªt_Groink.png",
    "element": "Terre",
    "pointsDeVie": "15",
    "armurePhysique": "0",
    "esquive": "1",
    "initiative": 1,
    "coupCritique": "0",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": 3,
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": "3",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": "2",
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Charge brutale:</strong> Fonce et Inflige 5 dÃ©gÃ¢ts. Critique : <span class=\"etat-link\" data-etat=\"A terre\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">A terre</span><br><strong>Lance rocher:</strong> PortÃ©e 15m,  4 dÃ©gats physiques.",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "Groinka",
    "tags": [
      "ForÃªt"
    ],
    "image": "data/images/Monstres/foret/Monstre_ForÃªt_Groinka.png",
    "element": "Terre",
    "pointsDeVie": "15",
    "armurePhysique": "0",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "0",
    "coupCritiqueSorts": "1",
    "resistanceAlterations": "4",
    "armureFeu": "0",
    "armureEau": "0",
    "armureTerre": "3",
    "armureAir": "0",
    "armureLumiere": 0,
    "armureObscurite": 2,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "Attaque : <span class=\"spell-link\" data-spell=\"VolÃ©e de pierres\" data-category=\"Sorts de Mage\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">VolÃ©e de pierres</span>  <br>Soin : <span class=\"spell-link\" data-spell=\"Soin mineur\" data-category=\"Sorts de PrÃªtre\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Soin mineur</span> <br> Alteration: \n<span class=\"spell-link\" data-spell=\"Accroche terrestre\" data-category=\"Sorts d'Enchanteur\" style=\"color: var(--accent); cursor: pointer; text-decoration: underline;\">Accroche terrestre</span>",
    "butin": "<strong>Butin:</strong>"
  },
  {
    "nom": "GuÃªpe GÃ©ante",
    "tags": [
      "ForÃªt"
    ],
    "image": "data/images/Monstres/foret/Monstre_ForÃªt_GuÃªpeGÃ©ante.png",
    "element": "Air",
    "pointsDeVie": "15",
    "armurePhysique": 0,
    "esquive": "5",
    "initiative": 1,
    "coupCritique": "3",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "3",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": 0,
    "armureAir": "5",
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Volant</strong>: Necessite de sauter pour attaque au corps Ã  corps.<br><strong>Dard: </strong> Inflige 5 degats physiques + 3 <span style=\"color: #22c55e; font-weight: bold;\">Air</span>. Critique : <span class=\"etat-link\" data-etat=\"EmpoisonnÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">EmpoisonnÃ©</span> 1 , 5 tours",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "5"
  },
  {
    "nom": "Ours des Bois",
    "tags": [
      "ForÃªt"
    ],
    "image": "data/images/Monstres/foret/Monstre_ForÃªt_OursdesBois.png",
    "element": "Terre",
    "pointsDeVie": "40",
    "armurePhysique": 4,
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "1",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "4",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": 2,
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 1,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Griffes dÃ©vastatrices:</strong> Inflige 7 dÃ©gÃ¢ts physiques Ã  une cible.<br><strong>Rugissement:</strong> Cible Ã  9m  <span class=\"etat-link\" data-etat=\"Affaibli\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Affaibli</span> , si  (resistance altÃ©rations &lt; 4)",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "1"
  },
  {
    "nom": "Pouple de la forÃªt",
    "tags": [
      "ForÃªt"
    ],
    "image": "",
    "element": "Eau",
    "pointsDeVie": "10",
    "armurePhysique": "0",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "0",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "0",
    "armureFeu": 0,
    "armureEau": "5",
    "armureTerre": 0,
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Accroche:</strong> Inflige 4 dÃ©gÃ¢ts physiques. S'attache Ã  la cible, qui devient <span class=\"etat-link\" data-etat=\"Ralenti\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Ralenti</span>.",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "2"
  },
  {
    "nom": "Serpent de la forÃªt",
    "tags": [
      "ForÃªt"
    ],
    "image": "",
    "element": "Terre",
    "pointsDeVie": 20,
    "armurePhysique": "0",
    "esquive": 5,
    "initiative": 1,
    "coupCritique": "2",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": 3,
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": "5",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": 0,
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Morsure venimeuse:</strong> Inflige 5 dÃ©gÃ¢ts Physiques. <br> Si (resistance altÃ©rations &lt; 4)  + <span title=\"Des dÃ©gats sont appliquÃ©s Ã  chaque dÃ©but de tour du lanceur, rÃ©duits ni par l'armure physique ni par l'armure Ã©lÃ©mentaire.\">EmpoisonnÃ©</span>2 pendant 5 tours.<br><br>",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "4"
  },
  {
    "nom": "ScarabÃ©e gÃ©ant",
    "tags": [
      "ForÃªt"
    ],
    "image": "",
    "element": "Air",
    "pointsDeVie": 20,
    "armurePhysique": "3",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "0",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "5",
    "armureFeu": 0,
    "armureEau": 0,
    "armureTerre": 0,
    "armureAir": "5",
    "armureLumiere": 0,
    "armureObscurite": "5",
    "armureDivin": 0,
    "armureMalefique": 0,
    "abilites": "<strong>Volant</strong>: Necessite de sauter pour attaque au corps Ã  corps.<br><strong>Morsure: </strong> inflige 5 physique.\n<br><strong>Vent aveuglant: </strong> PortÃ©e 6m, esquivable, inflige 5 <span style=\"color: #22c55e; font-weight: bold;\">Air</span>. Si (Res Alt &lt; 4) <span class=\"etat-link\" data-etat=\"AveuglÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">AveuglÃ©</span>",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "5"
  },
  {
    "nom": "Boss ForÃªt",
    "tags": [
      "ForÃªt"
    ],
    "image": "",
    "element": "Terre",
    "pointsDeVie": "200",
    "armurePhysique": "3",
    "esquive": "0",
    "initiative": 1,
    "coupCritique": "2",
    "coupCritiqueSorts": "0",
    "resistanceAlterations": "10",
    "armureFeu": 0,
    "armureEau": "0",
    "armureTerre": "10",
    "armureAir": 0,
    "armureLumiere": 0,
    "armureObscurite": "5",
    "armureDivin": 0,
    "armureMalefique": "5",
    "abilites": "Double attaque.<br><strong>Attaque basique:</strong> Inflige 10 dÃ©gÃ¢ts physiques. <br><strong>Hurlement:</strong> Tous les adversaires Ã  15m, avec Resistance altÃ©ration &lt; 6, sont <span class=\"etat-link\" data-etat=\"Affaibli\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">Affaibli</span>.  \n<br><b>Repoussoir</b>: Repousse une une cible Ã  9m. Inflige 5 dÃ©gats.\n<br><b>Appel </b>: Hurle et fait venir 2 Groinkas.\n<br><b>Tremblement de terre </b>: Tous les adversaires Ã  15m, 7 dÃ©gats <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> , critique 12.",
    "butin": "<strong>Butin:</strong>",
    "monster-initiative": "3"
  }
];
    window.TABLES_TRESORS = {
  "tables": [
    {
      "nom": "Monstre forÃªt commun",
      "description": "feffez",
      "tags": [
        "ForÃªt"
      ],
      "fourchettes": [
        {
          "min": 1,
          "max": 3,
          "objet": {
            "type": "reference",
            "numero": 15,
            "nom": "Feuilleclaire"
          }
        },
        {
          "min": 4,
          "max": 6,
          "objet": {
            "type": "reference",
            "numero": 16,
            "nom": "Nocteline"
          }
        },
        {
          "min": 7,
          "max": 9,
          "objet": {
            "type": "reference",
            "numero": 13,
            "nom": "Petite potion de mana"
          }
        },
        {
          "min": 10,
          "max": 12,
          "objet": {
            "type": "reference",
            "numero": 12,
            "nom": "Petite potion de vie"
          }
        },
        {
          "min": 13,
          "max": 15,
          "objet": {
            "type": "reference",
            "numero": 21,
            "nom": "Fruits de la forÃªt"
          }
        },
        {
          "min": 16,
          "max": 19,
          "objet": {
            "type": "reference",
            "numero": 17,
            "nom": "Baguette de d'accÃ©lÃ©ration"
          }
        }
      ]
    },
    {
      "nom": "Boss forÃªt",
      "description": "BBB",
      "tags": [
        "ForÃªt",
        "Boss"
      ],
      "fourchettes": [
        {
          "min": 1,
          "max": 3,
          "objet": {
            "type": "reference",
            "numero": 21,
            "nom": "Fruits de la forÃªt"
          }
        },
        {
          "min": 4,
          "max": 8,
          "objet": {
            "type": "reference",
            "numero": 11,
            "nom": "Armure de plaque"
          }
        },
        {
          "min": 9,
          "max": 12,
          "objet": {
            "type": "reference",
            "numero": 18,
            "nom": "Baguette de sommeil"
          }
        },
        {
          "min": 13,
          "max": 16,
          "objet": {
            "type": "reference",
            "numero": 8,
            "nom": "Robe simple"
          }
        },
        {
          "min": 17,
          "max": 20,
          "objet": {
            "type": "reference",
            "numero": 4,
            "nom": "BÃ¢ton en bois"
          }
        }
      ]
    }
  ],
  "_metadata": {
    "availableTags": [
      "ForÃªt",
      "Boss",
      "Coffre"
    ]
  }
};
    window.COLLECTIONS = {
  "collections": [
    {
      "id": "d-part",
      "nom": "DÃ©part",
      "description": "Objets disponibles Ã  la crÃ©ation du personnage.",
      "icon": "ğŸ“¦",
      "objets": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        12,
        16,
        15,
        14,
        18,
        13,
        19,
        20,
        23
      ]
    }
  ]
};
    window.IMAGES = {
  "images": {
    "subclass:Guerrier:Nain des montagnes": "https://i.ibb.co/Zpv02X9p/e8c10c36dc90.jpg",
    "subclass:Guerrier:Berserker": "https://i.ibb.co/DPYjyGVd/b85000c2afa4.jpg",
    "subclass:Mage:Ã‰rudit": "https://i.ibb.co/M5pcNmF9/05fa4e535010.jpg",
    "subclass:Mage:Elfe": "https://i.ibb.co/K1SMkgb/d738588e0528.jpg",
    "subclass:PrÃªtre:Inquisiteur": "https://i.ibb.co/dJ02RNMc/c9cd3553df7e.jpg",
    "subclass:PrÃªtre:Clerc Divin": "https://i.ibb.co/8gFGZYqJ/698304cc75ee.jpg",
    "subclass:RÃ´deur:Voleur": "https://i.ibb.co/q3jSxDnQ/90e89c692b47.jpg",
    "subclass:RÃ´deur:Chasseur": "https://i.ibb.co/70wP75z/53de7da9e55c.jpg",
    "subclass:Enchanteur:Esprit de la grande FÃ©e": "https://i.ibb.co/Cswfsyzz/9920a4e75242.jpg",
    "subclass:Enchanteur:Lutin": "https://i.ibb.co/Fbspq9hP/dd5e7b366e0f.jpg",
    "sort:Sorts de Mage:Boule de Feu": "https://i.ibb.co/vCWmgrQ5/Boule-De-Feu.png",
    "sort:Sorts de Mage:Ã‰clair": "https://i.ibb.co/h194qhvd/Eclair.png",
    "sort:Sorts de Mage:Vague dÃ©ferlante": "https://i.ibb.co/BSHtL8K/Vague.png",
    "sort:Sorts de PrÃªtre:ChÃ¢timent": "https://i.ibb.co/JRPyXx1L/Chatiment-Sacr.png",
    "sort:Sorts de PrÃªtre:Soin mineur": "https://i.ibb.co/YBC2HSnK/Soin-Mineur.png",
    "sort:Sorts d'Enchanteur:Accroche terrestre": "https://i.ibb.co/27W4NtSQ/Accroche-Terre.png",
    "sort:Sorts d'Enchanteur:AccÃ©lÃ©ration": "https://i.ibb.co/Vc072qQB/Acceleration.png",
    "sort:Sorts d'Enchanteur:Sommeil": "https://i.ibb.co/rKyTh27C/Sleep.png",
    "sort:Sorts de PrÃªtre:Nouveau Sort": "https://i.ibb.co/cXh57Pdn/ArmeLum.png",
    "sort:Sorts de PrÃªtre:Protection": "https://i.ibb.co/QvK52kxH/Protection.png",
    "subclass:Guerrier:Nain des montagnes:1": "https://i.ibb.co/FL9m5HJn/Nain.png",
    "subclass:Guerrier:Nain des montagnes:2": "https://i.ibb.co/wNnJxSbj/NaineF.png",
    "subclass:Guerrier:Berserker:1": "https://i.ibb.co/YBWFbTKv/berseker.png",
    "subclass:Guerrier:Berserker:2": "https://i.ibb.co/20b74x2R/Berseker-F.png",
    "subclass:Mage:Ã‰rudit:1": "https://i.ibb.co/N8qT2Hf/Mage.png",
    "subclass:Mage:Ã‰rudit:2": "https://i.ibb.co/LdcPDSJQ/MageF.png",
    "subclass:Mage:Elfe:2": "https://i.ibb.co/VWDTjY8H/ElfeF.png",
    "subclass:Mage:Elfe:1": "https://i.ibb.co/gFVKrTcV/Elfe.png",
    "subclass:PrÃªtre:Inquisiteur:1": "https://i.ibb.co/tMcsCB8s/Inquisiteur.png",
    "subclass:PrÃªtre:Clerc Divin:1": "https://i.ibb.co/209W4ZHW/Pr-tre.png",
    "subclass:RÃ´deur:Voleur:1": "https://i.ibb.co/NghMq11n/Voleur-min.png",
    "subclass:RÃ´deur:Voleur:2": "https://i.ibb.co/h1BtkGMX/VoleurF.png",
    "subclass:RÃ´deur:Chasseur:1": "https://i.ibb.co/yF8jrJYr/Chasseur-min.png",
    "subclass:RÃ´deur:Chasseur:2": "https://i.ibb.co/3mQjLJbp/Chasseur-F.png",
    "subclass:Enchanteur:Esprit de la grande FÃ©e:1": "https://i.ibb.co/VY9cQHNh/F-eM.png",
    "subclass:Enchanteur:Esprit de la grande FÃ©e:2": "https://i.ibb.co/pjxDfXBC/F-e.png",
    "subclass:Enchanteur:Lutin:1": "https://i.ibb.co/6cxkMW1d/Lutin.png",
    "subclass:Enchanteur:Lutin:2": "https://i.ibb.co/qLbjJhxw/LutinF.png",
    "subclass:PrÃªtre:Inquisiteur:2": "https://i.ibb.co/LXwmWYR3/Inquisiteur-F.png",
    "subclass:PrÃªtre:Clerc Divin:2": "https://i.ibb.co/HfBVNLM3/PretreF.png",
    "sort:Sorts de PrÃªtre:Arme de lumiÃ¨re": "https://i.ibb.co/cXh57Pdn/ArmeLum.png",
    "objet:Ã‰pÃ©e Longue": "https://i.ibb.co/35rpP6ZS/Epee2M1.png",
    "objet:Espadon": "https://i.ibb.co/35rpP6ZS/Epee2M1.png",
    "objet:Simple Ã©pÃ©e": "https://i.ibb.co/PsSXvSXx/Epee1.png",
    "objet:Dague en fer": "https://i.ibb.co/1fCwy6cR/Dague1.png",
    "objet:BÃ¢ton en bois": "https://i.ibb.co/PsyCNw86/Baton1.png",
    "objet:Gourdin": "https://i.ibb.co/whZCKww0/Baton2.png",
    "objet:Arc simple": "https://i.ibb.co/cKb1JKZQ/Arc1.png",
    "objet:Bouclier en bois": "https://i.ibb.co/67bK4Bw8/Bouclier1.png",
    "objet:Robe simple": "https://i.ibb.co/VYFpnz8h/Robe1.png",
    "objet:Armure de cuir": "https://i.ibb.co/9Hkw2VFb/Armure-Cuir1.png",
    "objet:Armure en maille": "https://i.ibb.co/cXtwzw5b/Armure-Lourde1.png",
    "objet:Armure de plaque": "https://i.ibb.co/fVg5Fp6h/Armure-Lourde2.png",
    "subclass:Guerrier:Aventurier:1": "https://i.ibb.co/9HcQkbb2/Aventurier.png",
    "subclass:Guerrier:Aventurier:2": "https://i.ibb.co/nH8Yj3h/Aventurier-F.png",
    "objet:Petite potion de vie": "https://i.ibb.co/Mw2Qb8Y/LifePot1.png",
    "objet:Petite potion de mana": "https://i.ibb.co/MkwzbQ3S/Potion-Mana1.png",
    "objet:Baguette de boule de feu": "https://i.ibb.co/JwXs3k2V/Baguette-Feu.png",
    "objet:Feuilleclaire": "https://i.ibb.co/bMDstDVV/Herb1.png",
    "objet:Nocteline": "https://i.ibb.co/7JpQ7Kr7/Herb2.png",
    "objet:Nouvel Objet": "https://i.ibb.co/Py57FHy/Food0.png",
    "objet:Baguette de sommeil": "https://i.ibb.co/bMXNS4gy/Baguette-Nuit.png",
    "monster:AraignÃ©e GÃ©ante": "https://i.ibb.co/b0XHjQJ/Monstre-For-t-Araign-e.png",
    "monster:Crabe des Bois": "https://i.ibb.co/7dY3GgJS/Monstre-For-t-Crab.png",
    "monster:Groink": "https://i.ibb.co/MDngQGcS/Monstre-For-t-Groink.png",
    "monster:Groinka": "https://i.ibb.co/YThB7Q29/Monstre-For-t-Groink-Chaman.png",
    "monster:GuÃªpe GÃ©ante": "https://i.ibb.co/bjSq3pPj/Monstre-For-t-Guepe-Geante.png",
    "monster:Ours des Bois": "https://i.ibb.co/N2NcD6n2/Monstre-For-t-Ours.png",
    "monster:Pouple de la forÃªt": "https://i.ibb.co/0jG2WLsv/Monstre-For-t-Poulpe.png",
    "monster:Serpent de la forÃªt": "https://i.ibb.co/svhHLvKZ/Monstre-For-t-Serpent.png",
    "monster:ScarabÃ©e gÃ©ant": "https://i.ibb.co/wF5bRvts/Monstre-For-t-Scarabe-Geant.png",
    "monster:Boss ForÃªt": "https://i.ibb.co/1JR11CC7/Monstre-For-t-Boss.png",
    "sort:Sorts de Mage:VolÃ©e de pierres": "https://i.ibb.co/GfPFdZPG/Volee-Pierre.png",
    "objet:Baguette de d'accÃ©lÃ©ration": "https://i.ibb.co/zT29mKBd/Baguette-Lumiere.png",
    "objet:Ration de nourriture": "https://i.ibb.co/tT6gW6p0/Food1.png",
    "objet:Ration copieuse de nourriture": "https://i.ibb.co/7JZW2ZZT/Food2.png",
    "objet:Fruits de la forÃªt": "https://i.ibb.co/svC0cDH6/food3.png",
    "sort:Sorts de PrÃªtre:Refermer les blessures": "https://i.ibb.co/zV1rzFkd/Soin-Mineur.png",
    "objet:Ration de survie": "https://i.ibb.co/Py57FHy/Food0.png",
    "subclass:Guerrier:Nouvelle sous-classe:1": "https://i.ibb.co/dsPhMWkY/Ma-tre-d-armes.png",
    "subclass:Guerrier:MaÃ®tre dâ€™armes:1": "https://i.ibb.co/dsPhMWkY/Ma-tre-d-armes.png",
    "subclass:Guerrier:MaÃ®tre dâ€™armes:2": "https://i.ibb.co/BVD015MF/Ma-tre-d-armes-F.png",
    "objet:FlÃ¨che aiguisÃ©e": "https://i.ibb.co/4Z7qKXCx/Fleche-Aiguis-e.png",
    "objet:FlÃ¨che de la terre": "https://i.ibb.co/ZpScRTwS/Fleche-Terre.png",
    "page:geographie": "https://i.ibb.co/svmYXJbN/Carte-fantastique-d-taill-e-et-color-e.png"
  },
  "meta": {
    "total_images": 85,
    "exported_date": "2025-09-03",
    "note": "Ces images incluent les nouvelles images uploadÃ©es"
  }
};
    
    // Page descriptions
    window.MONSTRES_PAGE_DESC = {
  "description": "CrÃ©atures, ennemis et adversaires que peuvent affronter les hÃ©ros dans leurs aventures."
};
    window.TABLES_TRESORS_PAGE_DESC = {
  "description": "Fortune + d20"
};
    
    // Custom page descriptions for collections and other dynamic pages
    window.CUSTOM_PAGE_DESCRIPTIONS = {
  "collections-objets": "Recherchez et explorez des collections d'objets.\n<br>Par exemple, tapez <b>DÃ©part</b> pour voir les objets disponnibles lors de la crÃ©ation du personnage.\n<br>Les collections sont cachÃ©es de base pour Ã©viter le <b>spoil</b>."
};
    
    // TOC Structure for advanced navigation
    window.TOC_STRUCTURE = {
  "sections": [
    {
      "id": "heros",
      "title": "ğŸ¦¸ HÃ©ros",
      "icon": "ğŸ¦¸",
      "description": "CrÃ©ation et dÃ©veloppement des personnages",
      "collapsed": false,
      "items": [
        {
          "type": "page",
          "id": "creation",
          "title": "CrÃ©ation d'un personnage",
          "icon": "ğŸ­"
        },
        {
          "type": "category",
          "id": "classes",
          "title": "Classes",
          "icon": "âš”ï¸",
          "items": "CLASSES"
        },
        {
          "type": "category",
          "id": "dons",
          "title": "Dons",
          "icon": "ğŸ–ï¸",
          "items": "DONS"
        },
        {
          "type": "page",
          "id": "feuille-personnage",
          "title": "Feuille de personnage",
          "icon": "ğŸ“‹"
        }
      ]
    },
    {
      "id": "arsenal",
      "title": "âš”ï¸ Arsenal",
      "icon": "âš”ï¸",
      "description": "Sorts, objets et Ã©quipements",
      "collapsed": false,
      "items": [
        {
          "type": "category",
          "id": "sorts",
          "title": "Sorts",
          "icon": "ğŸ”®",
          "items": "SORTS"
        },
        {
          "type": "page",
          "id": "objets",
          "title": "Objets",
          "icon": "ğŸ“¦"
        },
        {
          "type": "page",
          "id": "collections-objets",
          "title": "Collections d'Objets",
          "icon": "ğŸ“š"
        }
      ]
    },
    {
      "id": "regles",
      "title": "ğŸ“š RÃ¨gles",
      "icon": "ğŸ“š",
      "description": "MÃ©caniques de jeu et rÃ©fÃ©rences",
      "collapsed": false,
      "items": [
        {
          "type": "page",
          "id": "elements",
          "title": "Ã‰lÃ©ments",
          "icon": "ğŸŒŸ"
        },
        {
          "type": "page",
          "id": "stats",
          "title": "Statistiques",
          "icon": "ğŸ“Š"
        },
        {
          "type": "page",
          "id": "competences-tests",
          "title": "CompÃ©tences & Tests",
          "icon": "ğŸ¯"
        },
        {
          "type": "page",
          "id": "etats",
          "title": "Ã‰tats",
          "icon": "âš¡"
        },
        {
          "type": "page",
          "id": "combat",
          "title": "Combat",
          "icon": "âš”ï¸"
        },
        {
          "type": "page",
          "id": "gestion-des-ressources",
          "title": "Gestion des ressources",
          "icon": "ğŸ’"
        }
      ]
    },
    {
      "id": "maitre-de-jeu",
      "title": "ğŸ­ MaÃ®tre de jeu",
      "icon": "ğŸ­",
      "description": "Outils et ressources pour le MaÃ®tre de jeu",
      "collapsed": false,
      "requiresMJ": true,
      "items": [
        {
          "type": "page",
          "id": "monstres",
          "title": "Monstres",
          "icon": "ğŸ‘¹"
        },
        {
          "type": "page",
          "id": "tables-tresors",
          "title": "Tables de trÃ©sors",
          "icon": "ğŸ’"
        },
        {
          "type": "page",
          "id": "audio",
          "title": "Musiques d'ambiance",
          "icon": "ğŸµ"
        },
        {
          "type": "page",
          "id": "traumas",
          "title": "Traumas",
          "icon": "ğŸ©¹"
        },
        {
          "type": "page",
          "id": "campagne",
          "title": "Campagne",
          "icon": "ğŸ“–"
        }
      ]
    },
    {
      "id": "monde",
      "title": "ğŸŒ Monde",
      "icon": "ğŸŒ",
      "description": "Univers et connaissances du monde",
      "collapsed": false,
      "items": [
        {
          "type": "page",
          "id": "histoire",
          "title": "Histoire",
          "icon": "ğŸ“œ"
        },
        {
          "type": "page",
          "id": "dieux",
          "title": "Dieux",
          "icon": "ğŸ›ï¸"
        },
        {
          "type": "page",
          "id": "geographie",
          "title": "Geographie",
          "icon": "ğŸ“œ"
        }
      ]
    }
  ]
};
    
    // Build STATIC_PAGES dynamically from all loaded page data
    window.STATIC_PAGES = {
      'creation': {
  "page": "creation",
  "title": "CrÃ©ation d'un personnage",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "",
      "id": "section-0"
    },
    {
      "type": "card",
      "id": "etapes-creation",
      "title": "Ã‰tapes de crÃ©ation",
      "content": "<ol><li>Choisir une <strong>classe</strong> puis une <strong>sousâ€‘classe</strong> : <a href=\"#/guerrier\" style=\"color: var(--accent); text-decoration: underline;\">Guerrier</a>.</li><li>Choisir un <strong>Ã©lÃ©ment</strong> d'affiliation : <a href=\"#/elements\" style=\"color: var(--accent); text-decoration: underline;\">Ã‰lÃ©ments</a>.</li><li>Choisir les <strong>dons</strong> (avec 2 points de dons) : <a href=\"#/dons-generaux\" style=\"color: var(--accent); text-decoration: underline;\">Generaux (dons)</a>.</li><li>Choisir l'<strong>Ã©quipement</strong> de dÃ©part (avec 100 Ã©clats) : <a href=\"#/collections-objets\" style=\"color: var(--accent); text-decoration: underline;\">Collections d'Objets</a>.</li><li>DÃ©finir le <strong>nom</strong>, l'<strong>histoire</strong> et l'<strong>apparence</strong>.</li><li>Remplir sa feuille de personnage : <a href=\"#/feuille-personnage\" style=\"color: var(--accent); text-decoration: underline;\">Feuille de personnage</a>.</li></ol>",
      "deletable": true,
      "sectionName": "Ã‰tapes de crÃ©ation"
    }
  ]
},
      'elements': {
  "page": "elements",
  "title": "Elements",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "elements-system",
      "title": "SystÃ¨me d'Ã©lÃ©ments",
      "content": "<p>Il existe huit Ã©lÃ©ments, chacun ayant un opposÃ©. ChaquÃ© HÃ©ros oÃ¹ monstre possÃ¨de un Ã©lÃ©ment d'affiliation.<br><br> Une crÃ©ature affiliÃ©e Ã  un Ã©lÃ©ment :<br> - ReÃ§oit <strong>deux fois moins </strong>de dÃ©gats venant des sorts et attaques de cet Ã©lÃ©ment, et ne peut pas recevoir d'effet critique d'une alteration magique de cet Ã©lÃ©ment.<br>- Recevra systÃ©matiquement des <strong>effets critiques</strong> venant des sorts et altÃ©rations de l'Ã©lÃ©ment opposÃ©. Les dÃ©gats Ã©lÃ©mentaires rattachÃ©s Ã  une attaque physique (venant d'un objet ou sort) voit ses dÃ©gats doublÃ©s s'il est d'un Ã©lÃ©ment opposÃ©.</p>"
    },
    {
      "type": "card",
      "id": "element-pairs",
      "title": "Paires opposÃ©es",
      "content": "<div class=\"element-pairs\"><div class=\"pair\">ğŸ”¥ <span style=\"color: #ff6b35; font-weight: bold;\">Feu</span> âŸ· ğŸ’§ <span style=\"color: #4682b4; font-weight: bold;\">Eau</span></div><div class=\"pair\">ğŸ¤ <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> âŸ· ğŸŸ¢ <span style=\"color: #22c55e; font-weight: bold;\">Air</span></div><div class=\"pair\">â˜€ï¸ <span style=\"color: #ffd700; font-weight: bold;\">LumiÃ¨re</span> âŸ· âš« <span style=\"color: #1a1a1a; font-weight: bold;\">Nuit</span></div><div class=\"pair\">âšª <span style=\"color: #f5f5f5; font-weight: bold; background: rgba(100, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;\">Divin</span> âŸ· ğŸŸ£ <span style=\"color: #8b5cf6; font-weight: bold;\">MalÃ©fique</span></div></div>"
    },
    {
      "type": "card",
      "id": "element-defense",
      "title": "DÃ©fense",
      "content": "<p>Certaines armures/objets/bonus peuvent procurer une armure spÃ©cifique Ã  un Ã©lÃ©ment. Il faudra alors dÃ©duire au resultat final. Le calcul de dÃ©gats se fait dans cet ordre :</p><div><strong>DÃ©gats â†’ critique â†’ Ã—0.5 si affiliation Ã©lÃ©ment â†’ rÃ©duction de l'armure</strong></div>",
      "deletable": true,
      "sectionName": "DÃ©fense"
    },
    {
      "type": "card",
      "id": "element-attack",
      "title": "Attaque",
      "content": "<p>Une attaque ne peut avoir qu'<strong>un seul Ã©lÃ©ment</strong> (en plus d'Ã©ventuels dÃ©gats physiques). Si plusieurs sorts/Ã©quipements/bonus donnent un Ã©lÃ©ment Ã  l'attaque, le hÃ©ros devra choisir quel est l'Ã©lÃ©ment utilisÃ©.</p> Plusieurs bonus d'un mÃªme Ã©lÃ©ment peuvent se cumuler.\n<br><br> Si l'Ã©lÃ©ment rattachÃ© Ã  une attaque physiques est opposÃ© Ã  l'Ã©lÃ©ment d'affiliation de la cible, alors les dÃ©gats Ã©lÃ©mentaires sont doublÃ©s.",
      "deletable": true,
      "sectionName": "Attaque"
    }
  ]
},
      'stats': {
  "page": "stats",
  "title": "Statistiques",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "stats-base",
      "title": "Statistiques de base",
      "content": "<hr><div class=\"stats-grid\"><div class=\"stat-card\"><h4>ğŸ’ª Force</h4><p>AmÃ©liore les dÃ©gÃ¢ts physiques.</p></div><hr><div class=\"stat-card\"><h4>ğŸ›¡ï¸ Endurance</h4><p>Les points de vie maximum sont de : <strong>(10 + 2 x Endurance)</strong></p><p>Augmente les soins prodiguÃ©s par la consommation de nourriture.</p></div><hr><div class=\"stat-card\">\n<h4>ğŸƒ AgilitÃ©</h4><p>Chaque 5 points ajoutent <strong>+1</strong> aux jets d'esquive et de critique physique.<br><br>Augmente l'initiative d'autant.</p></div><hr><div class=\"stat-card\"><h4>ğŸ§  Intelligence</h4><p>DÃ©termine la puissance des sorts.</p></div><hr><div class=\"stat-card\"><h4>âš¡ VolontÃ©</h4><p>Le mana maximum est de : <strong>(20 + 2 x VolontÃ©)</strong></p><p>Augmente la RÃ©sistance altÃ©rations.</p></div><hr><div class=\"stat-card\"><h4>ğŸ€ Chance</h4><p>AmÃ©liore la Fortune d'autant.</p><p>De plus, chaque 5 points ajoutent <strong>+1</strong> aux chances de coup critique avec les sorts et les consommables.</p></div></div>",
      "deletable": true,
      "sectionName": "Statistiques de base"
    },
    {
      "type": "card",
      "id": "stats-new-3-1755784997112",
      "title": "Statistiques secondaires",
      "content": "<hr><br><br><strong>Chance de coup critique (physique) </strong> : Lors d'une attaque physique, le lanceur de l'attaque lance un d20. S'il fait 20, alors les dÃ©gats physiques (et seulement physiques) sont doublÃ©s.<br> Augmenter les chances de coup critique rÃ©duit la valeur du dÃ© nÃ©cÃ©ssaire pour faire un critique. Par exemple, avec 3 de chance de coup critique, si le dÃ© fait de 17 Ã  20, l'attaque est critique.\n\n<br><br><hr><br><strong>Chance de coup critique (sorts et consommables)</strong> : Lorsque un hÃ©ros ou un monstre lance un sort ou utilise un consommable, il lance un d20. S'il fait 20, alors le sort est critique, chaque sort/consommable ayant un effet critique diffÃ©rent (indiquÃ© dans sa description).<br> Augmenter les chances de coup critique des sorts et consommables rÃ©duit la valeur du dÃ© nÃ©cÃ©ssaire pour faire un critique. Par exemple, avec 3 de chance de coup critique, si le dÃ© fait de 17 Ã  20, le resultat est critique. \n\n<br><br><hr><br><strong>Esquive </strong> : Lors d'une attaque physique, ou d'un sort sans effet si esquive (indiquÃ© dans la fiche du sort), lorsque le lanceur lance son d20, si le resultat est 1, l'attaque est sans effet. Avoir de l'esquive pour la cible de l'attaque augmente la valeur du dÃ© jusqu'a laquelle l'attaque Ã©choue. Par exemple, avec 3 d'esquive, si le dÃ© fait 4 ou moins, l'attaque Ã©choue. La valeur d'esquive ne peut jamais dÃ©passer 9, quel que soit l'equipement ou bonus d'un joueur ou monstre.\n\n\n<br><br><hr><br><strong>RÃ©sistance altÃ©rations </strong> : Lorsqu'un lanceur de sort tente d'infliger une alteration magique Ã  une cible, on compare la valeur de l'intelligence du lanceur Ã  la RÃ©sistance altÃ©rations de la cible. Si l'intelligence est strictement supÃ©rieure, alors l'ateration rÃ©ussit, sinon elle est sans effet.\n\n\n<br><br><hr><br><strong>Armure physique </strong> : Lorsqu'un hÃ©ros ou monstre reÃ§oit des dÃ©gats physiques, ils sont alors rÃ©duit de la valeur de l'armure physique pour savoir combien de points de vies sont retirÃ©s Ã  la cible. Cette valeur est retirÃ© en dernier sur les degats (aprÃ©s avoir Ã©ventuellement doublÃ© les dÃ©gats si critique etc...)\n\n<br><br><hr><br><strong>Armure Ã©lÃ©mentaire </strong> : L'armure Ã©lÃ©mentaire est spÃ©cifique pour chaque Ã©lÃ©ment, il y a donc 8 types d'armure Ã©lÃ©mentaire. Lorsqu'un hÃ©ros ou monstre subit des dÃ©gats Ã©lÃ©mentaire correspondant Ã  l'armure Ã©lÃ©mentaire, ils sont alors rÃ©duit de la valeur de l'armure pour savoir combien de points de vies sont retirÃ©s Ã  la cible. Cette valeur est retirÃ© en dernier sur les degats (aprÃ©s avoir Ã©ventuellement doublÃ© les dÃ©gats si critique etc...).\n\n<br><br><hr><br><strong>Mana </strong> : Il s'agit de la ressource utilisÃ©e pour lancer des sorts. Hors combat, il revient automatiquement au maximum aprÃ©s plus d'une heure sans Ãªtre en combat. En combat, il est consommÃ© aprÃ©s le lancement de chaque sort (le coÃ»t en mana Ã©tant indiquÃ© dans la description de chaque sort). Si un sort devait faire passer le mana d'un hÃ©ros en dessous de 0, alors le sort n'est pas effectif et le hÃ©ros devient <span class=\"etat-link\" data-etat=\"Endormi/assomÃ©/EffrayÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">paralysÃ©</span> pendant 2 tours.\n\n<br><br><hr><br><strong>Vie </strong> : Les points de vie reprÃ©sentent la vitalitÃ© dâ€™un hÃ©ros ou dâ€™un monstre, la mesure de son endurance face aux blessures. Tant quâ€™il lui reste des PV, le personnage peut continuer Ã  se battre, Ã  courir et Ã  agir. Quand ses PV tombent Ã  zÃ©ro, il sâ€™effondre, mourant. Voir la page <a href=\"#/combat\" style=\"color: var(--accent); text-decoration: underline;\">Combat</a>.\nUn personnage qui effectue un repos rÃ©gÃ©nÃ¨re un nombre de points de vie Ã©gal Ã  sa valeur dâ€™Endurance.<br>\n\n<hr><br><strong>Fortune</strong> : Lorsquâ€™un Ã©vÃ©nement fait appel Ã  la Fortune (par exemple ouvrir un coffre et espÃ©rer y trouver un objet rare), le joueur lance un d20 et ajoute sa valeur de Fortune. Plus le total est Ã©levÃ©, meilleur sera le butin obtenu. \n\n<br><hr><br> <strong>Initiative</strong> : Cette valeur est comparÃ©e au dÃ©but du combat avec tous les hÃ©ros/monstres pour determiner l'ordre des tours de combat. Plus la valeur est Ã©levÃ©e, plus le hÃ©ros commence en premier.\n\n\n<br><hr><br> <strong>Taille </strong> : DÃ©termine la taille dâ€™une crÃ©ature. Certains effets ne fonctionnent que sur certaines tailles :\n<ul>\n  <li><b>Petit</b> : 1 mÃ¨tre ou moins</li>\n  <li><b>Moyen</b> : moins de 2 mÃ¨tres</li>\n  <li><b>Grand</b> : moins de 3,5 mÃ¨tres</li>\n  <li><b>GÃ©ant</b> : plus de 3,5 mÃ¨tres</li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'competences-tests': {
  "page": "competences-tests",
  "title": "CompÃ©tences & Tests",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "grid",
      "cols": 2,
      "content": [
        {
          "type": "card",
          "id": "efforts",
          "title": "Efforts",
          "content": "<ul><li>Chaque hÃ©ros dispose de 3 Efforts maximum.</li><li>Les hÃ©ros rÃ©cupÃ¨rent des efforts lors de repos courts ou longs.</li><li>Les Efforts peuvent Ãªtre dÃ©pensÃ©s pour amÃ©liorer un test de compÃ©tence.</li></ul>",
          "deletable": true,
          "sectionName": "Efforts"
        },
        {
          "type": "card",
          "id": "competences-list",
          "title": "CompÃ©tences",
          "content": "<ul><li><em>Hardiesse</em>: Pousser, casser, sauterâ€¦</li><li><em>Finesse</em>: Crocheter, fabriquer, Ãªtre discretâ€¦</li><li><em>Coordination</em>: Percevoir, Ã©quilibre, piloterâ€¦</li><li><em>RÃ©flexion</em>: Savoir, comprendre, devinerâ€¦</li><li><em>Ã‰loquence</em>: Persuader, mentir, intimiderâ€¦</li></ul>",
          "deletable": true,
          "sectionName": "CompÃ©tences"
        }
      ]
    },
    {
      "type": "card",
      "id": "tests",
      "title": "Tests de compÃ©tences",
      "content": "<p>Quand un MJ annonce un test de compÃ©tence, un hÃ©ros peut choisir de dÃ©penser des efforts pour booster sa compÃ©tence. La difficultÃ© d'un test est seule connue du MJ, et est entre 1 et 5 (Exigeant, Complexe , Ã‰prouvant, Prodigieux , <strong>Impossible</strong>).</p><p>Une fois le test rÃ©solu, le MaÃ®tre de Jeu annonce le rÃ©sultat. Si le joueur a dÃ©pensÃ© plus d'Efforts que nÃ©cessaire, l'excÃ©dent est perdu.</p><br> A noter que certaines actions sont impossibles Ã  rÃ©aliser et un hÃ©ros peut alors s'Ã©puiser pour rien, s'il n'a pas bien Ã©valuÃ© la difficultÃ© de la tÃ¢che. A l'inverse, les tÃ¢ches simples ne demandent pas de test de compÃ©tences.",
      "deletable": true,
      "sectionName": "Tests de compÃ©tences"
    }
  ]
},
      'etats': {
  "page": "etats",
  "title": "Etats",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "Lorsque un joueur subit un Ã©tat, vous pouvez prendre une carte ou note pour avoir un rappel de l'effet. De plus, si c'est un Ã©tat Ã  durÃ©e limitÃ©, vous pouvez prendre un dÃ© et le placer face au nombre de tour restant (en oubliant pas de changer sa valeur chaque dÃ©but de tour).<br> Quand vous infligez des effets/alterations Ã  un monstre, vous pouvez Ã©galement utiliser un dÃ© pour rappel (potentiellement d'une autre couleur, pour aider).\n<br>"
    },
    {
      "type": "card",
      "id": "a-terre",
      "title": "A terre",
      "content": "<p>Ne peut plus faire d'actions.</p><p> Ne peut plus esquiver.</p><p> Doit dÃ©penser une action secondaire pour se relever.</p>",
      "deletable": true,
      "sectionName": "A terre"
    },
    {
      "type": "card",
      "id": "endormi-effraye",
      "title": "Endormi/assomÃ©/EffrayÃ©",
      "content": "<p>Ne peut plus faire d'actions.</p><p> Ne peut plus esquiver.</p><p> Des dÃ©gats infligÃ©s Ã  la crÃ©ature la sort de son Ã©tat.</p>",
      "deletable": true,
      "sectionName": "Endormi/assomÃ©/EffrayÃ©"
    },
    {
      "type": "card",
      "id": "etats-new-4-1755725440741",
      "title": "Ralenti",
      "content": "Vitesse de dÃ©placement rÃ©duite de 6m.<br> Impossible de sauter ou d'esquiver.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-5-1755762657383",
      "title": "EmpoisonnÃ©",
      "content": "Des dÃ©gats sont appliquÃ©s Ã  chaque dÃ©but de tour du lanceur, rÃ©duits ni par l'armure physique ni par l'armure Ã©lÃ©mentaire.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-6-1755762796465",
      "title": "EntravÃ©/EntoilÃ©/EmbourbÃ©",
      "content": "<p>Ne peut plus faire d'actions.</p><p>Ne peut plus esquiver.</p> Le hÃ©ros ou un alliÃ© peut sortir le hÃ©ros de l'Ã©tat via un test de compÃ©tence hardiesse.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-7-1755762977439",
      "title": "Affaibli",
      "content": "Les dÃ©gats physiques effectuÃ©s sont rÃ©duits de moitiÃ©s. Les tests de hardiesse ont une difficultÃ© de 2 plus Ã©levÃ©s.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-para-8-1755891140510",
      "title": "Silence",
      "content": "Incapable de lancer des sorts.",
      "deletable": true,
      "sectionName": "Nouveau paragraphe"
    },
    {
      "type": "card",
      "id": "etats-new-9-1756400691334",
      "title": "VulnÃ©rable",
      "content": "Plus aucune protection apportÃ© par l'armure physique ou Ã©lÃ©mentaire.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-10-1756400890785",
      "title": "Confus",
      "content": "A chaque dÃ©but de tour, lancez un d20. si le resultat est de 10 ou moins, passe sont tour Ã  se dÃ©placer et attaquer au corp Ã  corp la cible la plus proche.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-11-1756401053782",
      "title": "Maudit",
      "content": "Impossible d'effectuer des coups critiques (physiques ou magiques), et la resistance altÃ©ration est divisÃ© par 2.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-12-1756401063266",
      "title": "DÃ©bilitÃ©",
      "content": "La cible est incpable d'effectuer la moindre action ou d'esquiver. A chaque dÃ©but de tour, elle perd des points de vie, rÃ©duits ni par l'armure physique ni par l'armure Ã©lÃ©mentaire.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-13-1756408622987",
      "title": "FatiguÃ©",
      "content": "Incapable d'utiliser des efforts. CoÃ»t en mana des sorts doublÃ©s. DÃ©gats physiques infligÃ©s rÃ©duits de moitiÃ©.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-14-1756637917339",
      "title": "AveuglÃ©",
      "content": "Toutes les attaques et sorts ont une portÃ©e maximum de 3m. Incapable d'esquiver.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'combat': {
  "page": "combat",
  "title": "Combat",
  "sections": [
    {
      "type": "intro",
      "content": "Lorsqu'un combat commence, on compare l'Initiative de tous les participants (hÃ©ros et monstres), et on dÃ©termine alors un ordre de tour. Celui qui a la plus grande initiative commence, puis c'est au tour du second avec la plus grande initiative , etc...\n\n<br><br>Chaque participant joue son tour (dÃ©placement et actions), puis on passe au suivant. Lorsque tous les monstres ou tous les hÃ©ros sont morts ou hors d'Ã©tat de se battre, le combat s'arrÃ¨te."
    },
    {
      "type": "card",
      "id": "combat-new-2-1756401371776",
      "title": "DÃ©placement",
      "content": "Ã€ chaque tour, un hÃ©ros peut se dÃ©placer de 9 mÃ¨tres (plus sâ€™il bÃ©nÃ©ficie de bonus), en plus de ses actions.\n<br><br>Certains terrains, comme la boue ou le sable, sont considÃ©rÃ©s comme des terrains difficiles : la vitesse y est alors rÃ©duite de moitiÃ©.\n<br><br>Un hÃ©ros ou un monstre ne peut pas traverser un adversaire occupant une largeur de 3 mÃ¨tres. Si plusieurs ennemis se tiennent cÃ´te Ã  cÃ´te, ils forment un vÃ©ritable mur infranchissable.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-3-1756401384086",
      "title": "Actions",
      "content": "Chaque tour, un hÃ©ros dispose d'une <b>action principale</b>, pour effectuer une attaque physique ou un sort.\nElle est perdue si elle n'est pas utilisÃ© pendant son tour. Elle permet Ã©galement de faire toute action qui nÃ©cÃ©ssite un test de compÃ©tence (ouvrir une porte, casser un rocher...).\n\n<br><br>Il dispose Ã©galement d'une <b>action secondaire</b>, qui permet de faire un certains nombre de choses :\n<br>- Sauter.\n<br>- Utiliser un objet.\n<br>- Changer d'arme.\n<br>Certains dons ou abilitÃ©s permettent Ã©galement d'effectuer d'autres choses en utilisant l'action secondaire.\n\n<br><br> Les hÃ©ros peuvent effectuer leur dÃ©placement, action principale et secondaire dans l'ordre qui leur plait.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-4-1756401409186",
      "title": "Attaques, sorts, armure",
      "content": "<b>Attaque physique</b>\n\n<ul>\n  <li>Il faut Ãªtre Ã  bonne portÃ©e (1,5 m pour une arme de mÃªlÃ©e, ou selon la portÃ©e indiquÃ©e sur lâ€™arme).</li>\n  <li>Il faut effectuer un saut pour toucher un monstre volant.</li>\n</ul>\n\n<p>\nEnsuite lâ€™attaquant lance un <b>d20</b> :\n</p>\n\n<ul>\n  <li>Si le rÃ©sultat est â‰¤ <b>(1 + Esquive)</b> du dÃ©fenseur, lâ€™attaque rate.</li>\n  <li>Si le rÃ©sultat est â‰¥ <b>(20 - Chance de Critique)</b> de lâ€™attaquant, lâ€™attaque est un <b>coup critique</b> et les dÃ©gÃ¢ts physiques sont doublÃ©s.</li>\n</ul>\n\n<p>\nSi des <b>dÃ©gÃ¢ts Ã©lÃ©mentaires</b> sont rattachÃ©s Ã  lâ€™arme (via sort, objet ou autre), ils ne sont critiques que si lâ€™Ã©lÃ©ment de lâ€™attaque est opposÃ© Ã  lâ€™Ã©lÃ©ment dâ€™affiliation de la cible.\n</p>\n\n<p>\nSi lâ€™attaque rÃ©ussit :\n</p>\n<ul>\n  <li>On soustrait lâ€™armure physique aux dÃ©gÃ¢ts physiques, puis on retire ce total aux points de vie du dÃ©fenseur.</li>\n  <li>On fait de mÃªme avec les dÃ©gÃ¢ts Ã©lÃ©mentaires en utilisant lâ€™armure Ã©lÃ©mentaire correspondante.</li>\n</ul>\n\n<hr>\n\n<br><b>Lancer un sort</b>\n\n<ul>\n  <li>Le lanceur doit Ãªtre Ã  portÃ©e de la cible.</li>\n  <li>Le lanceur dÃ©pense le mana en fonction du coÃ»t du sort. S'il passe en dessous de 0, le sort Ã©choue et le lanceur devient <span class=\"etat-link\" data-etat=\"Endormi/assomÃ©/EffrayÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">ParalysÃ©</span> pendant 2 tours.</li>\n</ul>\n\n<p>\nEnsuite le lanceur lance un <b>d20</b> :\n</p>\n\n<ul>\n  <li>Si le rÃ©sultat est â‰¤ 1, le sort Ã©choue.</li>\n  <li>Si le rÃ©sultat est â‰¥ <b>(20 - Chance de Critique des sorts)</b> du lanceur, lâ€™effet du sort sera <b>critique</b> (sâ€™il rÃ©ussit).</li>\n</ul>\n\n<b>Cas Â« Sans effet si Â» :</b>\n<br>Chaque sort indique sans sa decription dans quels cas le sort peut Ã©chouer.\n<ul>\n  <li>Sâ€™il est annulÃ© en cas dâ€™esquive, on vÃ©rifie si le rÃ©sultat du dÃ© est â‰¤ <b>(1 + Esquive)</b> du dÃ©fenseur.</li>\n  <li>Sâ€™il nâ€™affecte pas certaines crÃ©atures en fonction de leur Ã©lÃ©ment dâ€™assignation, le MJ indiquera si le sort est sans effet.</li>\n  <li>Sâ€™il sâ€™agit dâ€™un sort dâ€™altÃ©ration magique, on compare lâ€™<b>Intelligence</b> du lanceur avec la <b>RÃ©sistance Ã  lâ€™altÃ©ration</b> du dÃ©fenseur : si elle nâ€™est pas strictement supÃ©rieure, le sort est sans effet.</li>\n</ul>\n\n<p>\nSi aucun des cas Â« Sans effet si Â» ne sâ€™applique, on rÃ©sout le sort :\n</p>\n\n<ul>\n  <li>Si lâ€™Ã©lÃ©ment du sort est opposÃ© Ã  lâ€™affiliation de la cible, lâ€™effet est <b>forcÃ©ment critique</b>.</li>\n  <li>Son effet est appliquÃ© (en cas d'effet critique, la description du sort indique les effets).</li>\n  <li>Si le sort inflige des dÃ©gÃ¢ts Ã©lÃ©mentaires, on soustrait lâ€™armure Ã©lÃ©mentaire correspondante.</li>\n  <li>Si le sort inflige une altÃ©ration, on place un dÃ© indiquant le nombre de tours restants.</li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-5-1756401438556",
      "title": "Coup critique et esquive",
      "content": "<hr><br><br><strong>Chance de coup critique (physique) </strong> : Lors d'une attaque physique, le lanceur de l'attaque lance un d20. S'il fait 20, alors les dÃ©gats physiques (et seulement physiques) sont doublÃ©s.<br> Augmenter les chances de coup critique rÃ©duit la valeur du dÃ© nÃ©cÃ©ssaire pour faire un critique. Par exemple, avec 3 de chance de coup critique, si le dÃ© fait de 17 Ã  20, l'attaque est critique.\n\n<br><br><hr><br><strong>Chance de coup critique (sorts et consommables)</strong> : Lorsque un hÃ©ros ou un monstre lance un sort ou utilise un consommable, il lance un d20. S'il fait 20, alors le sort est critique, chaque sort/consommable ayant un effet critique diffÃ©rent (indiquÃ© dans sa description).<br> Augmenter les chances de coup critique des sorts et consommables rÃ©duit la valeur du dÃ© nÃ©cÃ©ssaire pour faire un critique. Par exemple, avec 3 de chance de coup critique, si le dÃ© fait de 17 Ã  20, le resultat est critique. \n\n<br><br><hr><br><strong>Esquive </strong> : Lors d'une attaque physique, ou d'un sort sans effet si esquive (indiquÃ© dans la fiche du sort), lorsque le lanceur lance son d20, si le resultat est 1, l'attaque est sans effet. Avoir de l'esquive pour la cible de l'attaque augmente la valeur du dÃ© jusqu'a laquelle l'attaque Ã©choue. Par exemple, avec 3 d'esquive, si le dÃ© fait 4 ou moins, l'attaque Ã©choue. La valeur d'esquive ne peut jamais dÃ©passer 9, quel que soit l'equipement ou bonus d'un joueur ou monstre.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-6-1756401461053",
      "title": "Mort",
      "content": "<p>\nLorsque les <b>points de vie</b> dâ€™un hÃ©ros passent sous la barre des 0, il devient <b>inconscient</b> jusquâ€™Ã  la fin du combat. \nAprÃ¨s le combat, si un alliÃ© le soigne (via objet ou sort), il redevient capable dâ€™agir. \nCependant, il gagne <b>1 point de trauma</b>, reprÃ©sentant un handicap dÃ©finitif en fonction de ce qui lâ€™a abattu. \nAu bout du <b>troisiÃ¨me trauma</b>, le hÃ©ros <b>meurt dÃ©finitivement</b>.\n</p>\n\n<p>\nLe joueur devra alors crÃ©er un nouveau personnage.  \nIl se murmure que certaines <b>magies trÃ¨s puissantes</b> sont capables de ressusciter un hÃ©ros mort, Ã  condition quâ€™elles soient pratiquÃ©es rapidement aprÃ¨s le dÃ©cÃ¨s.\n</p>\n\n<p>\n<b>Exemples de traumas</b>\n</p>\n<ul>\n  <li><b>Cicatrice profonde</b> : â€“1 en compÃ©tence Ã‰loquence.</li>\n  <li><b>AmnÃ©sie partielle</b> : Oubli dâ€™un sort, dâ€™une langue ou dâ€™une compÃ©tence.</li>\n  <li><b>Claudication</b> : Vitesse de dÃ©placement rÃ©duite de 3 m.</li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "combat-new-7-1756407955417",
      "title": "Incantation sur plusieurs tours",
      "content": "Certains sorts puissants nÃ©cÃ©ssitent plusieurs tours d'incantation.\n\n<br>AprÃ©s avoir commencÃ© une incantation, aucun dÃ©placement/action n'est possible. Les effets du sort sont effectuÃ©s au dernier tour de l'incantation, tour oÃ¹ la crÃ©ature pourra de nouveau effectuer des actions/dÃ©placement.\n<br> Les dÃ©gÃ¢ts subis nâ€™interrompent pas lâ€™incantation, sauf en cas de mort ou dâ€™effet particulier.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'gestion-des-ressources': {
  "page": "gestion-des-ressources",
  "title": "Gestion des ressources",
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-2-1756401478745",
      "title": "Inventaire",
      "content": "<p>Chaque hÃ©ros dispose de <b>quatre inventaires</b> :</p>\n\n<ul>\n  <li>\n    <b>Ã‰quipement</b> : Toujours portÃ© et actif, il est constituÃ© dâ€™une arme, dâ€™une armure, \n    dâ€™un Ã©ventuel bouclier et de <b>3 accessoires</b>.\n  </li>\n  <li>\n    <b>Sac de consommables</b> : Peut contenir jusquâ€™Ã  <b>10 consommables</b>. MÃªme si un hÃ©ro possÃ¨de plusieur fois le mÃªme consommable, ils prendront chacun une place.\n  </li>\n  <li>\n    <b>Sac gÃ©nÃ©ral</b> : Dispose dâ€™une capacitÃ© maximale de <b>10 points de poids</b>. \n    Chaque objet entreposÃ© y possÃ¨de une valeur de poids indiquÃ©e dans sa description.\n  </li>\n <li>\n    <b>Objets de quÃªte</b> : Aucune limite pour ces objets, utiles pour l'aventure (clÃ©s, cartes...).\n  </li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-3-1756401493443",
      "title": "Mana",
      "content": "Il s'agit de la ressource utilisÃ©e pour lancer des sorts. Hors combat, il revient automatiquement au maximum aprÃ©s plus d'une heure sans Ãªtre en combat. En combat, il est consommÃ© aprÃ©s le lancement de chaque sort (le coÃ»t en mana Ã©tant indiquÃ© dans la description de chaque sort). Si un sort devait faire passer le mana d'un hÃ©ros en dessous de 0, alors le sort n'est pas effectif et le hÃ©ros devient <span class=\"etat-link\" data-etat=\"Endormi/assomÃ©/EffrayÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">paralysÃ©</span> pendant 2 tours.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-4-1756401498518",
      "title": "Vie",
      "content": "Les points de vie reprÃ©sentent la vitalitÃ© dâ€™un hÃ©ros ou dâ€™un monstre, la mesure de son endurance face aux blessures. Tant quâ€™il lui reste des PV, le personnage peut continuer Ã  se battre, Ã  courir et Ã  agir. Quand ses PV tombent Ã  zÃ©ro, il sâ€™effondre, mourant. Voir la page <a href=\"#/combat\" style=\"color: var(--accent); text-decoration: underline;\">Combat</a>.\nUn personnage qui effectue un repos rÃ©gÃ©nÃ¨re un nombre de points de vie Ã©gal Ã  sa valeur dâ€™Endurance.<br>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-5-1756401504961",
      "title": "Fortune",
      "content": "Lorsquâ€™un Ã©vÃ©nement fait appel Ã  la Fortune (par exemple ouvrir un coffre et espÃ©rer y trouver un objet rare), le joueur lance un d20 et ajoute sa valeur de Fortune. Plus le total est Ã©levÃ©, meilleur sera le butin obtenu.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-7-1756408519770",
      "title": "Sommeil et repas",
      "content": "Chaque jour, un hÃ©ros doit manger une ration et dormir au moins 8 heures sous peine d'Ãªtre dans l'Ã©tat <span class=\"etat-link\" data-etat=\"FatiguÃ©\" style=\"color: #ea7332; cursor: pointer; text-decoration: underline;\">FatiguÃ©</span>.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-7-1756634178476",
      "title": "Experience et niveau",
      "content": "<p>Lorsquâ€™un groupe trouve et utilise un <b>cristal dâ€™expÃ©rience</b>, tous les membres du groupe <b>gagnent</b> des points dâ€™expÃ©rience.</p>\n<p>Les <b>cristaux dâ€™expÃ©rience</b> provenant dâ€™un mÃªme type de monstre sont de moins en moins efficaces, car la magie quâ€™ils renferment a dÃ©jÃ  Ã©tÃ© assimilÃ©e.</p>\n\n\n<p>Lorsquâ€™un hÃ©ros atteint <b>10 points dâ€™expÃ©rience</b>, il gagne un niveau et son expÃ©rience revient Ã  <b>0</b>. Il obtient alors :</p>\n<ul>\n  <li><b>1 point de don</b> (quâ€™il peut dÃ©penser ou cumuler).</li>\n  <li>Des <b>statistiques fixes</b> (selon la sous-classe).</li>\n  <li><b>2 points de statistiques</b> Ã  rÃ©partir.</li>\n  <li>Lâ€™<b>accÃ¨s Ã  de nouveaux sorts</b> (pour les classes qui le peuvent).</li>\n</ul>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "gestion-des-ressources-new-8-1756658008017",
      "title": "Equipements",
      "content": "<li>Que l'on porte une arme Ã  une main ou Ã  deux mains, il est uniquement possible d'Ãªtre Ã©quipÃ© d'une seule arme.\n</li><li>Lorsque on porte une arme Ã  deux mains, il est impossible de porter un bouclier.\n</li><li>Il est possible via une action secondaire de changer l'arme active en plein combat, mais pas l'armure ou les accessoires, qui ne peuvent Ãªtre changÃ©s que hors combat.</li>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'histoire': {
  "page": "histoire",
  "title": "Histoire",
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "ere-legendaire",
      "title": "",
      "content": "<b>Foresia, royaume ancien aux mille visages</b><br>\nDans les terres de <b>Foresia</b>, un royaume ancien aux mille visages, la <b>magie</b> imprÃ¨gne chaque pierre et chaque souffle de vent. \nForÃªts luminescentes, volcans grondants, temples enfouis et ruines cyclopÃ©ennes rappellent que les dieux et les anciens peuples ont marquÃ© cette terre de leur puissance.\n\n<br><br><b>La rÃ©gion de Mabresia</b><br>\nAu cÅ“ur de ce royaume sâ€™Ã©tend la rÃ©gion de <b>Mabresia</b>, autrefois fertile et paisible, oÃ¹ se dressaient des citÃ©s marchandes prospÃ¨res et des villages agricoles nourris par des riviÃ¨res cristallines.\n\n<br><br><b>La malÃ©diction des cristaux</b><br>\nMais depuis quelques dÃ©cennies, un mal mystÃ©rieux sâ€™est abattu sur la contrÃ©e. \nDes <b>cristaux magiques</b> surgis des profondeurs de la terre altÃ¨rent la nature et les Ãªtres vivants : animaux, monstres, et mÃªme parfois les races intelligentes. \nCes cristaux provoquent des <b>mutations</b> et une <b>soif de violence</b> incontrÃ´lable.\n\n<br><br><b>Peuples et tensions</b><br>\nLes habitants de Foresia â€” <b>humains</b>, <b>elfes</b>, <b>nains</b>, mais aussi des crÃ©atures plus sombres comme <b>dÃ©mons</b> et <b>morts-vivants</b> â€” vivent dÃ©sormais dans une tension permanente, oscillant entre alliances fragiles et guerres ouvertes. \nChacun cherche Ã  <b>exploiter</b> ou <b>dÃ©truire</b> ces cristaux, selon ses croyances et ambitions.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "chronologie",
      "title": "ğŸ“… Chronologie",
      "content": "<b>Il y a 300 ans</b> â€“ Lâ€™Empire des Anciens, peuple oubliÃ©, Ã©rige dâ€™immenses temples et scelle dans leurs fondations des secrets de magie que nul ne comprendra jamais entiÃ¨rement.<br><br>\n\n<b>Il y a 200 ans</b> â€“ Chute de lâ€™Empire : guerres entre dieux mineurs et rois mortels. Les temples sont abandonnÃ©s, et les ruines se couvrent de vÃ©gÃ©tation.<br><br>\n\n<b>Il y a 80 ans</b> â€“ Premiers rÃ©cits dâ€™Ã©tranges cristaux luminescents dÃ©couverts dans les montagnes de Mabresia. Au dÃ©but considÃ©rÃ©s comme bÃ©nÃ©dictions, certains se rÃ©vÃ¨lent instables.<br><br>\n\n<b>Il y a 50 ans</b> â€“ Des bÃªtes sauvages commencent Ã  muter et deviennent plus fÃ©roces. Les premiers villages sont dÃ©truits par des crÃ©atures altÃ©rÃ©es.<br><br>\n\n<b>Il y a 30 ans</b> â€“ Les cristaux se rÃ©pandent : on les retrouve dans les forÃªts, les marÃ©cages et mÃªme les ruines anciennes. De plus en plus de crÃ©atures sont transformÃ©es.<br><br>\n\n<b>Il y a 20 ans</b> â€“ Les premiÃ¨res guerres Ã©clatent entre royaumes frontaliers : certains veulent sâ€™emparer des cristaux comme armes, dâ€™autres cherchent Ã  les dÃ©truire.<br><br>\n\n<b>Aujourdâ€™hui</b> â€“ La rÃ©gion de Mabresia est devenue une terre sauvage, oÃ¹ nul nâ€™est Ã  lâ€™abri : les routes sont envahies de crÃ©atures mutÃ©es, les villages se fortifient, et des aventuriers de tous horizons sâ€™y aventurent Ã  la recherche de gloire, de savoirâ€¦ ou de pouvoir.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'dieux': {
  "page": "dieux",
  "title": "Dieux",
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "dieux-new-2-1756899335313",
      "title": "Dieu des Humains â€“ Aedor, le Forgeron-Soleil",
      "content": "Symbole : un marteau aurÃ©olÃ© dâ€™un disque solaire.<br>\nDomaine : courage, guerre juste, travail artisanal.<br>\nCroyances : les humains voient en lui celui qui Ã©claire leur chemin et leur donne la force de bÃ¢tir des citÃ©s.<br>\nParticularitÃ© : ses prÃªtres prÃ´nent la discipline et la reconstruction, mais certains royaumes lâ€™utilisent aussi pour justifier leurs conquÃªtes.<br><br>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "dieux-para-3-1756899336921",
      "title": "Dieu des Nains â€“ Durnak, le CÅ“ur-de-Pierre",
      "content": "Symbole : une enclume fissurÃ©e dâ€™oÃ¹ sâ€™Ã©coule une lueur rouge.<br>\nDomaine : terre, montagne, persÃ©vÃ©rance, serments.<br>\nCroyances : gardien des mines et des profondeurs, il protÃ¨ge les clans nains et punit sÃ©vÃ¨rement ceux qui trahissent leur parole.<br>\nParticularitÃ© : les nains affirment que ses battements rÃ©sonnent dans les montagnes, guidant les mineurs vers les mÃ©taux rares.<br><br>",
      "deletable": true,
      "sectionName": "Nouveau paragraphe"
    },
    {
      "type": "card",
      "id": "dieux-new-4-1756899338873",
      "title": "DÃ©esse des Elfes â€“ Liryel, la Dame des Brumes",
      "content": "Symbole : une feuille argentÃ©e flottant sur lâ€™eau.<br>\nDomaine : forÃªts, magie ancienne, mÃ©moire.<br>\nCroyances : les elfes la vÃ©nÃ¨rent comme gardienne du cycle de la vie et de la magie pure.<br>\nParticularitÃ© : ses temples sont souvent des clairiÃ¨res protÃ©gÃ©es par des enchantements, oÃ¹ les brumes recouvrent les intrus.<br><br>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "dieux-new-5-1756899431837",
      "title": "Dieu des FÃ©es et des Lutins â€“ Myrin, lâ€™Ã‰clat-Changeant",
      "content": "Symbole : une luciole ou une Ã©toile facÃ©tieuse Ã  cinq branches.<br>\nDomaine : illusions, rÃªves, joie, malice.<br>\nCroyances : les fÃ©es et lutins croient quâ€™il danse entre les mondes, semant Ã  la fois la protection et la farce.<br>\nParticularitÃ© : ses fidÃ¨les accordent beaucoup dâ€™importance aux fÃªtes, Ã  la musique et aux pactes imprÃ©visibles.<br><br>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'geographie': {
  "page": "geographie",
  "title": "Geographie",
  "sections": [
    {
      "type": "intro",
      "content": "Voici la carte de la rÃ©gion de Mabresia, dans le Royaume de Foresia"
    }
  ]
},
      'campagne': {
  "id": "campagne",
  "title": "Campagne",
  "icon": "ğŸ“–",
  "sections": [
    {
      "type": "intro",
      "content": "<strong>ğŸ­ Espace Campagne</strong><br>CrÃ©ez et gÃ©rez vos campagnes avec leurs sous-pages personnalisÃ©es. Cette section est uniquement visible en mode MaÃ®tre de Jeu."
    },
    {
      "type": "campaign-manager",
      "content": {
        "title": "Gestionnaire de Campagnes",
        "campaigns": {}
      }
    }
  ],
  "subPages": {
    "Classique": {
      "name": "Classique",
      "description": "",
      "subPages": {
        "Long terme": {
          "title": "Long terme",
          "content": "ğŸ•¯ï¸ Le Dieu MalÃ©fique\n\nNerhaz, le SÃ©pulcral\n\nSymbole : un cristal noir fendu, entourÃ© de chaÃ®nes.\n\nDomaine : mort, corruption, secrets interdits.\n\nHistoire : banni par lâ€™Empire des Anciens, il fut scellÃ© dans leurs temples. Mais les cristaux magiques, instables, ont servi de rÃ©ceptacles Ã  ses murmures.\n\nParticularitÃ© : Nerhaz attire les ambitieux et les dÃ©sespÃ©rÃ©s, promettant pouvoir en Ã©change de sacrifices. Son retour progressif est liÃ© Ã  lâ€™altÃ©ration des crÃ©atures par les cristaux."
        },
        "Auberge": {
          "title": "Auberge",
          "content": "<p>Contenu de la sous-page...</p>"
        },
        "ForÃªt": {
          "title": "ForÃªt",
          "content": "<p>Contenu de la sous-page...</p>"
        }
      }
    }
  },
  "meta": {
    "requiresMJ": true,
    "allowSubPages": true,
    "lastModified": "2025-01-01T00:00:00.000Z"
  }
}
    };
    
    // Static pages configuration
    window.STATIC_PAGES_CONFIG = {
  "pages": [
    {
      "id": "creation",
      "title": "CrÃ©ation d'un personnage",
      "file": "creation.json",
      "active": true,
      "order": 1
    },
    {
      "id": "elements",
      "title": "Elements",
      "file": "elements.json",
      "active": true,
      "order": 2
    },
    {
      "id": "stats",
      "title": "Statistiques",
      "file": "stats.json",
      "active": true,
      "order": 3
    },
    {
      "id": "competences-tests",
      "title": "CompÃ©tences & Tests",
      "file": "competences-tests.json",
      "active": true,
      "order": 4
    },
    {
      "id": "etats",
      "title": "Etats",
      "file": "etats.json",
      "active": true,
      "order": 5
    },
    {
      "id": "histoire",
      "title": "Histoire",
      "file": "histoire.json",
      "active": true,
      "order": 6
    },
    {
      "id": "combat",
      "title": "Combat",
      "file": "combat.json",
      "active": true,
      "order": 7
    },
    {
      "id": "gestion-des-ressources",
      "title": "Gestion des ressources",
      "file": "gestion-des-ressources.json",
      "active": true,
      "order": 8
    },
    {
      "id": "dieux",
      "title": "Dieux",
      "file": "dieux.json",
      "active": true,
      "order": 9
    },
    {
      "id": "geographie",
      "title": "Geographie",
      "file": "geographie.json",
      "active": true,
      "order": 10
    },
    {
      "id": "audio",
      "title": "Musiques d'ambiance",
      "file": "audio.json",
      "active": true,
      "order": 11
    },
    {
      "id": "traumas",
      "title": "Traumas",
      "file": "traumas.json",
      "active": true,
      "order": 12
    },
    {
      "id": "campagne",
      "title": "Campagne",
      "file": "campagne.json",
      "active": true,
      "order": 13,
      "requiresMJ": true
    }
  ],
  "template": {
    "page": "new-page",
    "title": "Nouvelle page",
    "static": true,
    "sections": [
      {
        "type": "intro",
        "content": "Contenu de la nouvelle page."
      }
    ]
  }
};
    
    // Mark as standalone version for renderer
    window.STANDALONE_VERSION = true;
    
    // Initialize app when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      // Ensure dev mode is off
      document.body.className = 'dev-off';
      
      // Initialize in standalone mode with embedded data
      
      // Wait a bit to ensure all modules are loaded
      setTimeout(function() {
        // Initialize JdrApp if it exists
        if (window.JdrApp && window.JdrApp.init) {
          window.JdrApp.init();
        } else {
          console.error('JdrApp not found!', window.JdrApp);
        }
      }, 100);
    });
  
// ============================================================================
// JDR-BAB APPLICATION - CORE MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // MAIN APPLICATION NAMESPACE
  // ========================================
  window.JdrApp = {
    // Core data
    data: {
      SORTS: null,
      CLASSES: null,
      DONS: null,
      OBJETS: null,
      MONSTRES: null,
      STATIC_PAGES: {},
      editedData: {},
      customPageDescriptions: {
        'collections-objets': 'Recherchez et explorez des collections d\'objets organisÃ©es par thÃ¨me'
      }
    },
    
    // Application state
    state: {
      isMJ: false // Boolean pour contrÃ´ler l'accÃ¨s MJ
    },
    
    // Core modules
    modules: {
      router: {},
      renderer: {},
      editor: {},
      storage: {},
      images: {}
    },
    
    // Utilities
    utils: {
      dom: {},
      events: {},
      data: {}
    },

    // Initialization
    async init() {
      try {
        await this.loadData();
        await this.loadContent();
        this.initializeModules();
        
        // Execute data validation after all modules are loaded
        setTimeout(() => {
          this.validateDataIntegrity();
        }, 500);
        
        // Auto-enable MJ mode with additional delay to ensure router is ready
        setTimeout(() => {
          this.autoEnableMJModeInDevelopment();
        }, 800);
      } catch (error) {
        // Silent error handling for initialization
      }
    },

    async loadData() {
      try {
        // Check if we're in standalone mode (data already injected)
        if (window.SORTS && window.CLASSES && window.DONS && window.OBJETS && window.STATIC_PAGES) {
          const sorts = window.SORTS;
          const classes = window.CLASSES;
          const dons = window.DONS;
          const objets = window.OBJETS;
          let monstres = window.MONSTRES || [];
          let tablesTresors = window.TABLES_TRESORS || { tables: [] };
          let collections = window.COLLECTIONS || { collections: [] };
          
          // Safety check - if MONSTRES is not an array, it might be page config
          if (!Array.isArray(monstres)) {
            this.clearCorruptedMonsterData();
            monstres = [];
          }
          
          const staticPagesData = window.STATIC_PAGES;
          const staticPagesConfig = window.STATIC_PAGES_CONFIG || {};
          
          // Ensure custom page descriptions are available in standalone mode
          // In standalone mode, CUSTOM_PAGE_DESCRIPTIONS might be injected, sync with JdrApp.data
          if (window.CUSTOM_PAGE_DESCRIPTIONS) {
            this.data.customPageDescriptions = { ...this.data.customPageDescriptions, ...window.CUSTOM_PAGE_DESCRIPTIONS };
          } else {
            window.CUSTOM_PAGE_DESCRIPTIONS = { ...this.data.customPageDescriptions };
          }
          
          this.data.SORTS = sorts;
          this.data.CLASSES = classes;
          this.data.DONS = dons;
          this.data.OBJETS = objets;
          this.data.MONSTRES = monstres;
          this.data.TABLES_TRESORS = tablesTresors;
          this.data.COLLECTIONS = collections;
          this.data.STATIC_PAGES = staticPagesData;
          this.data.STATIC_PAGES_CONFIG = staticPagesConfig;
          
          window.SORTS = sorts;
          window.CLASSES = classes;
          window.DONS = dons;
          window.OBJETS = objets;
          window.MONSTRES = monstres;
          window.TABLES_TRESORS = tablesTresors;
          window.COLLECTIONS = collections;
          window.STATIC_PAGES = staticPagesData;
          window.STATIC_PAGES_CONFIG = staticPagesConfig;
          
          // Load stored edits AFTER setting up the data structure
          this.loadStoredEditsEarly();
          
          // Initialize default filters for objects
          this.initializeDefaultFilters();
          return;
        }
        
        // Development mode - fetch files
        const [sorts, classes, dons, objets, monstres, tablesTresors, collections, staticPagesConfig, tocStructure, audioConfig] = await Promise.all([
          fetch('data/sorts.json').then(r => r.json()),
          fetch('data/classes.json').then(r => r.json()),
          fetch('data/dons.json').then(r => r.json()),
          fetch('data/objets.json').then(r => r.json()),
          fetch('data/monstres.json').then(r => r.json()),
          fetch('data/tables-tresors.json').then(r => r.json()),
          fetch('data/collections.json').then(r => r.json()),
          fetch('data/static-pages-config.json').then(r => r.json()),
          fetch('data/toc-structure.json').then(r => r.json()),
          fetch('data/audio-config.json').then(r => r.json()).catch(() => null)
        ]);

        // Load page descriptions (optional, with fallbacks)
        try {
          window.MONSTRES_PAGE_DESC = await fetch('data/monstres-page-desc.json').then(r => r.json());
        } catch (error) {
          // Fallback if file doesn't exist
          window.MONSTRES_PAGE_DESC = {
            description: "CrÃ©atures, ennemis et adversaires que peuvent affronter les hÃ©ros dans leurs aventures."
          };
        }

        try {
          window.TABLES_TRESORS_PAGE_DESC = await fetch('data/tables-tresors-page-desc.json').then(r => r.json());
        } catch (error) {
          // Fallback if file doesn't exist
          window.TABLES_TRESORS_PAGE_DESC = {
            description: "Tables de butin permettant de gÃ©nÃ©rer alÃ©atoirement des rÃ©compenses selon les fourchettes dÃ©finies. Lancez un dÃ© 20 et consultez la table correspondante pour dÃ©terminer l'objet obtenu."
          };
        }

        // Load custom page descriptions (collections, etc.)
        try {
          const customDescriptions = await fetch('data/custom-page-descriptions.json').then(r => r.json());
          this.data.customPageDescriptions = { ...this.data.customPageDescriptions, ...customDescriptions };
          // Make it available globally for ContentFactory (keep in sync)
          window.CUSTOM_PAGE_DESCRIPTIONS = { ...this.data.customPageDescriptions };
        } catch (error) {
          // Keep default values if file doesn't exist
          window.CUSTOM_PAGE_DESCRIPTIONS = { ...this.data.customPageDescriptions };
        }

        const staticPagesData = {};
        const activePages = staticPagesConfig.pages.filter(page => page.active);
        
        for (const pageConfig of activePages) {
          try {
            const pageData = await fetch(`data/${pageConfig.file}`).then(r => r.json());
            staticPagesData[pageConfig.id] = pageData;
          } catch (error) {
            // Silent handling for missing static pages
          }
        }

        this.data.SORTS = sorts;
        this.data.CLASSES = classes;
        this.data.DONS = dons;
        this.data.OBJETS = objets;
        this.data.MONSTRES = monstres;
        this.data.TABLES_TRESORS = tablesTresors;
        this.data.COLLECTIONS = collections;
        this.data.STATIC_PAGES = staticPagesData;
        this.data.STATIC_PAGES_CONFIG = staticPagesConfig;
        this.data.AUDIO_CONFIG = audioConfig;
        this.data.TOC_STRUCTURE = tocStructure;

        window.SORTS = sorts;
        window.CLASSES = classes;
        window.DONS = dons;
        window.OBJETS = objets;
        window.MONSTRES = monstres;
        window.TABLES_TRESORS = tablesTresors;
        window.COLLECTIONS = collections;
        window.STATIC_PAGES = this.data.STATIC_PAGES;
        window.STATIC_PAGES_CONFIG = this.data.STATIC_PAGES_CONFIG;
        window.TOC_STRUCTURE = this.data.TOC_STRUCTURE;
        window.AUDIO_CONFIG = audioConfig;
        
        // Load stored edits in development mode (after data is loaded)
        this.loadStoredEditsEarly();
        
        // Initialize default filters for objects
        this.initializeDefaultFilters();
      } catch (error) {
        throw error;
      }
    },

    async loadContent() {
      try {
        // Check if we're in standalone mode (already has HTML structure)
        const viewsDiv = document.getElementById('views');
        const loadingDiv = document.getElementById('app-loading');
        
        if (viewsDiv) {
          // Standalone mode - HTML structure already exists
          if (loadingDiv) {
            loadingDiv.innerHTML = '<!-- Content will be generated by renderer -->';
          }
        } else if (loadingDiv) {
          // Development mode - need to inject HTML structure
          const contentHTML = await this.getContentHTML();
          loadingDiv.outerHTML = contentHTML;
        }
      } catch (error) {
        throw error;
      }
    },

    async getContentHTML() {
      // This would ideally load from a separate HTML file
      // For now, we'll return the content structure
      return `
        <div class="shell">
          <button aria-controls="sidebar" aria-expanded="false" aria-label="Ouvrir le sommaire" class="menu-toggle" id="menuToggle" style="display:none">â˜° Sommaire</button>
          <div class="backdrop" hidden="" id="backdrop"></div>
          <main class="page">
            <aside class="sidebar" id="sidebar">
              <div class="panel">
                <div class="searchbar">
                  <input autocomplete="off" id="search" placeholder="Rechercher une rÃ¨gle, une classeâ€¦">
                  <button class="btn" id="clear" title="Effacer">âœ–</button>
                </div>
                <div class="tools">
                  <button class="btn small" id="devToggle" title="Activer/dÃ©sactiver le mode dÃ©veloppeur">ğŸ›  Dev Mode: OFF</button>
                </div>
                <div class="dev-toolbox" id="devToolbox" style="display: none;">
                  <!-- Dev toolbox content will be injected here -->
                </div>
                <div class="toc" id="toc">
                  <!-- Table of contents will be injected here -->
                </div>
              </div>
            </aside>
            <div id="views">
              <!-- Dynamic content will be injected here -->
            </div>
          </main>
          <footer></footer>
        </div>
      `;
    },

    // Load stored edits early in the loading process (before rendering)
    loadStoredEditsEarly() {
      // Ne plus charger automatiquement le localStorage
      // Laisser les JSON files Ãªtre la source de vÃ©ritÃ©
    },

    initializeModules() {
      if (this.utils.events && this.utils.events.init) this.utils.events.init();
      if (this.utils.dom && this.utils.dom.init) this.utils.dom.init();
      if (this.modules.images && this.modules.images.init) this.modules.images.init();
      if (this.modules.audio && this.modules.audio.init) this.modules.audio.init();
      if (this.modules.renderer && this.modules.renderer.init) this.modules.renderer.init();
      if (this.modules.router && this.modules.router.init) this.modules.router.init();
      if (this.modules.editor && this.modules.editor.init) this.modules.editor.init();
      if (this.modules.storage && this.modules.storage.init) this.modules.storage.init();
      if (this.modules.ui && this.modules.ui.init) this.modules.ui.init();
    },

    // Force reload JSON data (clear localStorage cache)
    forceReloadData() {
      // Effacer seulement les Ã©ditions temporaires
      localStorage.removeItem('jdr-bab-edits');
      localStorage.removeItem('jdr-bab-last-modified');
      window.location.reload();
    },

    // Clear corrupted localStorage data specifically for monsters
    clearCorruptedMonsterData() {
      const edits = JSON.parse(localStorage.getItem('jdr-bab-edits') || '{}');
      
      // Remove any MONSTRES data that might be corrupted
      if (edits.MONSTRES) {
        delete edits.MONSTRES;
        localStorage.setItem('jdr-bab-edits', JSON.stringify(edits));
      }
      
      // Also clear any other monster-related storage
      if (edits.monster) {
        delete edits.monster;
        localStorage.setItem('jdr-bab-edits', JSON.stringify(edits));
      }
    },

    // Public method to manually clear storage via console
    clearMonsterStorage() {
      this.clearCorruptedMonsterData();
      this.forceReloadData();
    },

    // Initialize default filters for objects on page load
    initializeDefaultFilters() {
      try {
        // Only initialize if OBJETS exists and ContentTypes is available
        if (window.OBJETS && window.ContentTypes?.objet?.filterConfig) {
          const defaultTags = window.ContentTypes.objet.filterConfig.defaultVisibleTags || [];
          
          // Initialize filterSettings only if it doesn't exist or is empty
          if (!window.OBJETS.filterSettings || !window.OBJETS.filterSettings.visibleTags) {
            window.OBJETS.filterSettings = {
              visibleTags: [...defaultTags], // Active filters (defaults only)
              displayedFilterButtons: [...defaultTags] // Displayed filter buttons (defaults initially)
            };
          }
          
          // Ensure displayedFilterButtons exists even if visibleTags already existed
          if (!window.OBJETS.filterSettings.displayedFilterButtons) {
            window.OBJETS.filterSettings.displayedFilterButtons = [...defaultTags];
          }
          
        }
      } catch (error) {
        // Silent error handling for filter initialization
      }
    },

    // Validate data integrity on application startup
    validateDataIntegrity() {
      try {
        // Validate monster data if available
        if (window.MONSTRES && Array.isArray(window.MONSTRES) && JdrApp.modules.images) {
          // Force sync monster images and paths
          JdrApp.modules.images.forceSyncMonsterImages();
        }
        
        // Validate UnifiedEditor if available
        if (JdrApp.modules.editor && JdrApp.modules.editor.validateAndRepairMonsterData) {
          JdrApp.modules.editor.validateAndRepairMonsterData();
        }
        
      } catch (error) {
        // Silent error handling for data validation
      }
    },

    autoEnableMJModeInDevelopment() {
      try {
        // Better detection: Check if we're in standalone mode
        // Standalone mode sets window.STANDALONE_VERSION = true in the build
        const isStandalone = window.STANDALONE_VERSION === true;
        
        
        if (!isStandalone) {
          
          // Enable MJ mode (not dev mode!) automatically in development
          if (!this.state.isMJ) {
            this.state.isMJ = true;
            
            // Update MJ button visual if available and regenerate TOC
            if (JdrApp.modules.router && JdrApp.modules.router.updateMJButtonVisual) {
              JdrApp.modules.router.updateMJButtonVisual();
              JdrApp.modules.router.generateTOC();
              
              // Refresh current page if it's tables-tresors to show edit buttons
              const currentHash = window.location.hash;
              if (currentHash === '#/tables-tresors') {
                setTimeout(() => {
                  if (JdrApp.modules.router && JdrApp.modules.router.renderTablesTresorsPage) {
                    JdrApp.modules.router.renderTablesTresorsPage();
                  }
                }, 200);
              }
              
            } else {
              // Router not ready yet, retry
              setTimeout(() => this.autoEnableMJModeInDevelopment(), 1000);
              return;
            }
            
          }
        }
      } catch (error) {
        // Retry once more after error
        setTimeout(() => this.autoEnableMJModeInDevelopment(), 2000);
      }
    }
  };

  // Auto-initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => window.JdrApp.init());
  } else {
    window.JdrApp.init();
  }

})();
// ============================================================================
// JDR-BAB APPLICATION - CONSTANTS
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // UI CONSTANTS
  // ========================================
  window.UI_CONSTANTS = {
    // Layout dimensions
    SIDEBAR_WIDTH: 350,
    SIDEBAR_WIDTH_TABLET: 320,
    
    // Image processing defaults
    IMAGE_MAX_WIDTH: 800,
    IMAGE_QUALITY: 0.85,
    
    // Timing constants (milliseconds)
    TIMEOUTS: {
      VALIDATION_DELAY: 500,
      AUTO_MJ_DELAY: 800,
      RENDER_DELAY: 100,
      ROUTER_RETRY_DELAY: 1000,
      ERROR_RETRY_DELAY: 2000,
      DYNAMIC_CENTERING_DELAY: 50
    },
    
    // Breakpoints
    BREAKPOINTS: {
      MOBILE: 480,
      TABLET_PORTRAIT: 768,
      TABLET_LANDSCAPE: 1024,
      DESKTOP: 980
    }
  };

  // ========================================
  // ELEMENT COLORS
  // ========================================
  window.ELEMENT_COLORS = {
    FEU: { color: '#ff6b35', weight: 'bold' },
    EAU: { color: '#4682b4', weight: 'bold' },
    TERRE: { color: '#8b4513', weight: 'bold' },
    AIR: { color: '#87ceeb', weight: 'bold' },
    DIVIN: { color: '#ffd700', weight: 'bold' },
    MALEFIQUE: { color: '#8b008b', weight: 'bold' },
    NEUTRE: { color: '#696969', weight: 'normal' }
  };

  // ========================================
  // STORAGE KEYS
  // ========================================
  window.STORAGE_KEYS = {
    EDITS: 'jdr-bab-edits',
    LAST_MODIFIED: 'jdr-bab-last-modified',
    MONSTER_BACKUPS: 'jdr-bab-monster-backups',
    FILTER_SETTINGS: 'jdr-bab-filter-settings'
  };

  // ========================================
  // EVENT CONSTANTS
  // ========================================
  window.Events = {
    STORAGE_SAVE: 'storage:save',
    PAGE_RENDER: 'page:render',
    CONTENT_UPDATE: 'content:update'
  };

  // ========================================
  // DEFAULT VALUES
  // ========================================
  window.DEFAULT_VALUES = {
    // Monster backup retention
    MAX_MONSTER_BACKUPS: 10,
    
    // Filter defaults
    DEFAULT_VISIBLE_TAGS: ['Arme', 'Armure', 'Bouclier', 'Consommable'],
    
    // Image defaults
    DEFAULT_MONSTER_IMAGE: 'data/images/Monstres/foret/default-monster.png',
    DEFAULT_SPELL_IMAGE: 'data/images/Sorts/default-spell.png',
    DEFAULT_CLASS_IMAGE: 'data/images/Classes/default-class.png'
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - CONTENT TYPES CONFIGURATION
// ============================================================================

(() => {
  "use strict";

  window.ContentTypes = {
    spell: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        element: { type: 'select', label: 'Ã‰lÃ©ment', required: true, options: ['Feu', 'Eau', 'Terre', 'Air', 'LumiÃ¨re', 'Nuit', 'Divin', 'MalÃ©fique'] },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'PrÃ©requis', required: true },
        portee: { type: 'richtext', label: 'PortÃ©e', required: true },
        tempsIncantation: { type: 'richtext', label: "Temps d'incantation", required: true },
        coutMana: { type: 'richtext', label: 'CoÃ»t mana', required: true },
        resistance: { type: 'richtext', label: 'RÃ©sistance', required: true },
        effetNormal: { type: 'richtext', label: 'Effet normal', required: true },
        effetCritique: { type: 'richtext', label: 'Effet critique', required: false }
      },
      editMapping: {
        'spell-name': 'nom',
        'spell-element': 'element',
        'spell-description': 'description',
        'spell-prerequis': 'prerequis',
        'spell-portee': 'portee',
        'spell-mana': 'coutMana',
        'spell-temps-incantation': 'tempsIncantation',
        'spell-resistance': 'resistance',
        'spell-effect-normal': 'effetNormal',
        'spell-effect-critical': 'effetCritique'
      },
      identifiers: {
        name: 'nom',
        category: 'sorts'
      },
      template: 'spell-card',
      container: 'sorts',
      dataKey: 'SORTS',
      icons: { 
        category: 'ğŸ”®', 
        item: 'âœ¨',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      defaultValues: {
        nom: "Nouveau Sort",
        element: "Feu",
        description: "Lance une boule de Feu sur un adversaire.",
        prerequis: "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        portee: "ğŸ¯ <strong>PortÃ©e:</strong> 20m",
        tempsIncantation: "â° <strong>Temps d'incantation:</strong> 1 tour",
        coutMana: "ğŸ”µ <strong>CoÃ»t mana:</strong> 3",
        resistance: "<strong>Sans effet si:</strong> Esquive.",
        effetNormal: "<strong>Effet:</strong> Inflige 5 dÃ©gats de <span style='color: #e25822; font-weight: bold;'>Feu</span> Ã  la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        effetCritique: "<strong>Coup Critique:&nbsp;</strong>&nbsp;Double les dÃ©gÃ¢ts et enflamme la cible."
      }
    },

    don: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'PrÃ©requis', required: true },
        cout: { type: 'richtext', label: 'CoÃ»t', required: true }
      },
      editMapping: {
        'don-name': 'nom',
        'don-description': 'description',
        'don-prerequis': 'prerequis',
        'don-cout': 'cout'
      },
      identifiers: {
        name: 'nom',
        category: 'dons'
      },
      template: 'don-card',
      container: 'dons',
      dataKey: 'DONS',
      icons: { 
        category: 'ğŸ–ï¸', 
        item: 'ğŸ†',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      defaultValues: {
        nom: "Nouveau Don",
        description: "Description du don.",
        prerequis: "Aucun prÃ©requis",
        cout: "1 point de don"
      }
    },

    class: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        resume: { type: 'textarea', label: 'RÃ©sumÃ©', required: true },
        capacites: { type: 'list', label: 'CapacitÃ©s', required: true }
      },
      editMapping: {
        'class-name': 'nom',
        'class-resume': 'resume',
        'class-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: null
      },
      template: 'class-page',
      container: 'classes',
      dataKey: 'CLASSES',
      icons: { 
        category: 'âš”ï¸', 
        item: 'ğŸ›¡ï¸',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      }
    },

    subclass: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        base: { type: 'stats', label: 'Statistiques de base', required: true },
        progression: { type: 'richtext', label: 'Progression', required: true },
        capacites: { type: 'list', label: 'CapacitÃ©s', required: true }
      },
      editMapping: {
        'subclass-name': 'nom',
        'subclass-description': 'description',
        'subclass-stats': 'base',
        'subclass-progression': 'progression',
        'subclass-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: 'sousClasses',
        parent: 'class'
      },
      template: 'subclass-card',
      icons: { 
        item: 'âš¡',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      defaultValues: {
        nom: "Nouvelle sous-classe",
        description: "Description de la sous-classe",
        base: {
          Force: 3,
          AgilitÃ©: 3,
          Endurance: 3,
          Intelligence: 3,
          VolontÃ©: 3,
          Chance: 3
        },
        progression: "<strong>ğŸ“ˆ Progression par niveau:</strong> +1 Force ğŸ’ª, +1 AgilitÃ© ğŸƒ",
        capacites: [
          "<em>CapacitÃ© unique</em>: Description de la capacitÃ© spÃ©ciale de cette sous-classe."
        ]
      }
    },

    objet: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        numero: { type: 'number', label: 'NumÃ©ro', required: true },
        image: { type: 'text', label: 'Image', required: false },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        effet: { type: 'richtext', label: 'Effet', required: true },
        prix: { type: 'richtext', label: 'Prix', required: true },
        poids: { type: 'richtext', label: 'Poids', required: true }
      },
      editMapping: {
        'objet-name': 'nom',
        'objet-numero': 'numero',
        'objet-image': 'image',
        'objet-description': 'description',
        'objet-tags': 'tags',
        'objet-effet': 'effet',
        'objet-prix': 'prix',
        'objet-poids': 'poids'
      },
      identifiers: {
        name: 'nom',
        category: 'objets'
      },
      template: 'objet-card',
      container: 'objets',
      dataKey: 'OBJETS',
      pageType: 'single', // Page unique avec filtres
      icons: { 
        category: 'ğŸ“¦', 
        item: 'ğŸ’',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      // Configuration des filtres disponibles (MISE Ã€ JOUR AUTOMATIQUE)
      filterConfig: {
        availableTags: [
          "Arme",
          "Armure",
          "Consommable",
          "Bouclier",
          "Ã‰pÃ©e",
          "Arme exotique",
          "Une main",
          "Deux mains",
          "Baton",
          "Dague",
          "Arc",
          "Armure lourde",
          "Armure lÃ©gÃ¨re",
          "Robe",
          "Plante",
          "Catalyseur",
          "Nouvel objet",
          "Nourriture",
          "Non identifiÃ©",
          "FlÃ¨che"
],
        defaultVisibleTags: [
          "Arme"
] // Filtres affichÃ©s par dÃ©faut
      },
      defaultValues: {
        nom: "Nouvel Objet",
        numero: 1,
        image: "",
        description: "Description de l'objet.",
        tags: ["Nouvel objet"],
        effet: "<strong>Effet:</strong> Description de l'effet de l'objet.",
        prix: "ğŸ”· <strong>Prix:</strong> 10",
        poids: "âš–ï¸ <strong>Poids:</strong> 1"
      }
    },

    monster: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        image: { type: 'text', label: 'Image', required: false },
        element: { 
          type: 'select', 
          label: "Ã‰lÃ©ment d'affiliation", 
          required: true,
          options: [
            { value: 'Feu', label: 'ğŸ”¥ Feu' },
            { value: 'Eau', label: 'ğŸ’§ Eau' },
            { value: 'Terre', label: 'ğŸ¤ Terre' },
            { value: 'Air', label: 'ğŸŸ¢ Air' },
            { value: 'Lumiere', label: 'â˜€ï¸ LumiÃ¨re' },
            { value: 'Nuit', label: 'âš« Nuit' },
            { value: 'Divin', label: 'âšª Divin' },
            { value: 'Malefique', label: 'ğŸŸ£ MalÃ©fique' }
          ]
        },
        pointsDeVie: { type: 'number', label: 'Points de vie', required: true },
        armurePhysique: { type: 'number', label: 'Armure physique', required: true },
        esquive: { type: 'number', label: 'Esquive', required: true },
        coupCritique: { type: 'number', label: 'Coup critique', required: true },
        coupCritiqueSorts: { type: 'number', label: 'Critique sorts', required: true },
        resistanceAlterations: { type: 'number', label: 'RÃ©sistance altÃ©rations', required: true },
        armureFeu: { type: 'number', label: 'Armure Feu', required: true },
        armureEau: { type: 'number', label: 'Armure Eau', required: true },
        armureTerre: { type: 'number', label: 'Armure Terre', required: true },
        armureAir: { type: 'number', label: 'Armure Air', required: true },
        armureLumiere: { type: 'number', label: 'Armure LumiÃ¨re', required: true },
        armureObscurite: { type: 'number', label: 'Armure ObscuritÃ©', required: true },
        armureDivin: { type: 'number', label: 'Armure Divin', required: true },
        armureMalefique: { type: 'number', label: 'Armure MalÃ©fique', required: true },
        abilites: { type: 'richtext', label: 'AbilitÃ©s', required: false },
        butin: { type: 'richtext', label: 'Butin', required: false }
      },
      editMapping: {
        'monster-name': 'nom',
        'monster-tags': 'tags',
        'monster-image': 'image',
        'monster-element': 'element',
        // Stats principaux
        'monster-pointsdevie': 'pointsDeVie',
        'monster-armurephysique': 'armurePhysique', 
        'monster-esquive': 'esquive',
        'monster-coupcritique': 'coupCritique',
        'monster-coupcritiquesorts': 'coupCritiqueSorts',
        'monster-resistancealterations': 'resistanceAlterations',
        // Armures Ã©lÃ©mentaires
        'monster-armurefeu': 'armureFeu',
        'monster-armureeau': 'armureEau',
        'monster-armureterre': 'armureTerre',
        'monster-armureair': 'armureAir',
        'monster-armurelumiere': 'armureLumiere',
        'monster-armureobscurite': 'armureObscurite',
        'monster-armuredivin': 'armureDivin',
        'monster-armuremalefique': 'armureMalefique',
        // Contenu narratif
        'monster-abilites': 'abilites',
        'monster-butin': 'butin'
      },
      identifiers: {
        name: 'nom',
        category: 'monstres'
      },
      template: 'monster-card',
      container: 'monstres',
      dataKey: 'MONSTRES',
      pageType: 'single',
      filterMode: 'AND',
      icons: { 
        category: 'ğŸ²', 
        item: 'ğŸ‘¾',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      filterConfig: {
        availableTags: [
          "ForÃªt",
          "Boss"
],
        defaultVisibleTags: [
          "ForÃªt"
]
      },
      defaultValues: {
        nom: "Nouveau Monstre",
        tags: ["ForÃªt"],
        image: "",
        element: "Feu",
        pointsDeVie: 20,
        armurePhysique: 2,
        esquive: 5,
        coupCritique: 10,
        coupCritiqueSorts: 8,
        resistanceAlterations: 3,
        armureFeu: 0,
        armureEau: 0,
        armureTerre: 0,
        armureAir: 0,
        armureLumiere: 0,
        armureObscurite: 0,
        armureDivin: 0,
        armureMalefique: 0,
        abilites: "<strong>Attaque basique:</strong> Inflige 5 dÃ©gÃ¢ts physiques.",
        butin: "<strong>Butin:</strong> 10-50 piÃ¨ces d'or."
      }
    },

    tableTresor: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        fourchettes: { type: 'list', label: 'Fourchettes', required: true }
      },
      editMapping: {
        'table-tresor-name': 'nom',
        'table-tresor-description': 'description',
        'table-tresor-tags': 'tags'
      },
      identifiers: {
        name: 'nom',
        category: 'tables'
      },
      template: 'table-tresor-card',
      container: 'tables-tresors',
      dataKey: 'TABLES_TRESORS',
      pageType: 'single',
      filterMode: 'OR',
      icons: { 
        category: 'ğŸ’', 
        item: 'ğŸ“¦',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      filterConfig: {
        // availableTags managed dynamically via window.TABLES_TRESORS._metadata.availableTags
        defaultVisibleTags: [
          "ForÃªt",
          "Boss"
        ]
      },
      defaultValues: {
        nom: "Nouvelle Table de TrÃ©sor",
        description: "Table de butin pour une situation spÃ©cifique.",
        tags: ["ForÃªt"],
        fourchettes: [
          {
            min: 1,
            max: 10,
            objet: {
              type: "reference",
              numero: 1,
              nom: "Objet par dÃ©faut"
            }
          }
        ]
      }
    },

    staticPage: {
      fields: {
        title: { type: 'text', label: 'Titre', required: true },
        sections: { type: 'sections', label: 'Sections', required: true }
      },
      template: 'static-page',
      icons: { 
        category: 'ğŸ“„', 
        item: 'ğŸ“'
      }
    }
  };

  window.StatIcons = {
    'Force': 'ğŸ’ª',
    'AgilitÃ©': 'ğŸƒ',
    'Endurance': 'ğŸ›¡ï¸',
    'Intelligence': 'ğŸ§ ',
    'VolontÃ©': 'âš¡',
    'Chance': 'ğŸ€'
  };

  window.ElementColors = {
    'Feu': { color: '#ff6b35', weight: 'bold' },
    'Eau': { color: '#4682b4', weight: 'bold' },
    'Terre': { color: '#8b4513', weight: 'bold' },
    'Air': { color: '#22c55e', weight: 'bold' },
    'LumiÃ¨re': { color: '#ffd700', weight: 'bold' },
    'Nuit': { color: '#1a1a1a', weight: 'bold' },
    'Divin': { color: '#f5f5f5', weight: 'bold', background: 'rgba(100, 100, 100, 0.3)', padding: '2px 4px', borderRadius: '3px' },
    'MalÃ©fique': { color: '#8b5cf6', weight: 'bold' }
  };

  window.ElementIcons = {
    'Feu': 'ğŸ”¥',
    'Eau': 'ğŸ’§',
    'Terre': 'ğŸ¤',
    'Air': 'ğŸŸ¢',
    'LumiÃ¨re': 'â˜€ï¸',
    'Nuit': 'âš«',
    'Divin': 'âšª',
    'MalÃ©fique': 'ğŸŸ£'
  };

  // Campaign content type
  window.ContentTypes.campaign = {
    fields: {
      name: { type: 'text', label: 'Nom', required: true },
      description: { type: 'textarea', label: 'Description', required: false }
    },
    template: 'campaign',
    container: 'campaigns',
    dataKey: 'CAMPAIGNS',
    icons: { category: 'ğŸ—‚ï¸', item: 'ğŸ“‹', add: 'â•', delete: 'ğŸ—‘ï¸' },
    defaultValues: {
      name: 'Nouvelle Campagne',
      description: 'Description de la campagne'
    }
  };

  // Campaign sub-page content type  
  window.ContentTypes.campaignSubPage = {
    fields: {
      title: { type: 'text', label: 'Titre', required: true },
      content: { type: 'textarea', label: 'Contenu', required: false }
    },
    template: 'campaign-subpage',
    container: 'campaign-subpages', 
    dataKey: 'CAMPAIGN_SUBPAGES',
    icons: { category: 'ğŸ“„', item: 'ğŸ“', add: 'â•', delete: 'ğŸ—‘ï¸' },
    defaultValues: {
      title: 'Nouvelle sous-page',
      content: 'Contenu de la sous-page...'
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - EVENT BUS
// ============================================================================

(() => {
  "use strict";

  class EventBus {
    constructor() {
      this.listeners = new Map();
    }

    static getInstance() {
      if (!EventBus.instance) {
        EventBus.instance = new EventBus();
      }
      return EventBus.instance;
    }

    on(eventType, callback) {
      if (!this.listeners.has(eventType)) {
        this.listeners.set(eventType, []);
      }
      this.listeners.get(eventType).push(callback);
      return () => this.off(eventType, callback);
    }

    off(eventType, callback) {
      const callbacks = this.listeners.get(eventType);
      if (callbacks) {
        const index = callbacks.indexOf(callback);
        if (index > -1) {
          callbacks.splice(index, 1);
        }
      }
    }

    emit(eventType, payload = {}) {
      const callbacks = this.listeners.get(eventType);
      if (callbacks) {
        callbacks.forEach(callback => {
          try {
            callback(payload);
          } catch (error) {
            console.error(`Error in event callback for ${eventType}:`, error);
          }
        });
      }
    }

    once(eventType, callback) {
      const unsubscribe = this.on(eventType, (payload) => {
        callback(payload);
        unsubscribe();
      });
      return unsubscribe;
    }
  }

  window.EventBus = EventBus.getInstance();

  window.Events = {
    CONTENT_ADD: 'content:add',
    CONTENT_DELETE: 'content:delete',
    CONTENT_UPDATE: 'content:update',
    CONTENT_MOVE: 'content:move',
    PAGE_RENDER: 'page:render',
    EDITOR_TOGGLE: 'editor:toggle',
    IMAGE_UPLOAD: 'image:upload',
    IMAGE_DELETE: 'image:delete',
    STORAGE_SAVE: 'storage:save',
    SEARCH_PERFORM: 'search:perform',
    MODAL_OPEN: 'modal:open',
    MODAL_CLOSE: 'modal:close',
    NOTIFICATION_SHOW: 'notification:show'
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - BASE ENTITY
// ============================================================================

(() => {
  "use strict";

  class BaseEntity {
    constructor(type, dataArray) {
      this.type = type;
      this.data = dataArray || [];
      this.config = window.ContentTypes[type];
      
      // Handle special case for objects with new structure
      if (type === 'objet' && this.data && !Array.isArray(this.data) && this.data.objets) {
        // Convert to pseudo-category structure for compatibility
        this.objectsData = this.data; // Keep reference to original structure
        this.data = [{ nom: 'objets', objets: this.data.objets }]; // Wrap in array format
      }
      
      // Handle special case for treasure tables with structure: { tables: [...], _metadata: {...} }
      if (type === 'tableTresor' && this.data && !Array.isArray(this.data) && this.data.tables) {
        // Convert to pseudo-category structure for compatibility
        this.tablesData = this.data; // Keep reference to original structure
        this.data = [{ nom: 'tables', tables: this.data.tables }]; // Wrap in array format
      }
    }

    getAll() {
      return this.data;
    }

    findCategory(categoryName) {
      return this.data.find(category => category.nom === categoryName);
    }

    findItem(itemName, categoryName = null) {
      if (categoryName) {
        const category = this.findCategory(categoryName);
        if (!category || !category[this.getItemsProperty()]) return null;
        
        const item = category[this.getItemsProperty()].find(item => item.nom === itemName);
        return item ? { item, category: category.nom } : null;
      }

      for (const category of this.data) {
        if (!category[this.getItemsProperty()]) continue;
        const item = category[this.getItemsProperty()].find(item => item.nom === itemName);
        if (item) {
          return { item, category: category.nom };
        }
      }
      return null;
    }

    addItem(categoryName, itemData) {
      const category = this.findCategory(categoryName);
      if (!category) return false;

      const itemsProperty = this.getItemsProperty();
      if (!category[itemsProperty]) {
        category[itemsProperty] = [];
      }

      const defaultValues = this.config?.defaultValues || {};
      const newItem = { ...defaultValues, ...itemData };
      category[itemsProperty].push(newItem);

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_ADD, {
        type: this.type,
        category: categoryName,
        item: newItem
      });

      return newItem;
    }

    deleteItem(categoryName, itemName) {
      const category = this.findCategory(categoryName);
      if (!category) return false;

      const itemsProperty = this.getItemsProperty();
      const items = category[itemsProperty];
      if (!items) return false;

      const index = items.findIndex(item => item.nom === itemName);
      if (index === -1) return false;

      const deletedItem = items.splice(index, 1)[0];

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_DELETE, {
        type: this.type,
        category: categoryName,
        item: deletedItem
      });

      return true;
    }

    updateItem(categoryName, itemName, property, value) {
      const result = this.findItem(itemName, categoryName);
      if (!result) return false;

      const { item } = result;
      
      if (property === 'capacites' && Array.isArray(value)) {
        item[property] = value;
      } else if (property === 'base' && typeof value === 'object') {
        item[property] = { ...item[property], ...value };
      } else {
        item[property] = value;
      }

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_UPDATE, {
        type: this.type,
        category: categoryName,
        item: item,
        property: property,
        value: value
      });

      return true;
    }

    moveItem(categoryName, itemName, direction) {
      const category = this.findCategory(categoryName);
      if (!category) return false;

      const itemsProperty = this.getItemsProperty();
      const items = category[itemsProperty];
      if (!items) return false;

      const currentIndex = items.findIndex(item => item.nom === itemName);
      if (currentIndex === -1) return false;

      const newIndex = currentIndex + direction;
      if (newIndex < 0 || newIndex >= items.length) return false;

      [items[currentIndex], items[newIndex]] = [items[newIndex], items[currentIndex]];

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_MOVE, {
        type: this.type,
        category: categoryName,
        itemName: itemName,
        direction: direction
      });

      return true;
    }

    getItemsProperty() {
      switch (this.type) {
        case 'spell': return 'sorts';
        case 'don': return 'dons';
        case 'objet': return 'objets';
        case 'class': return 'sousClasses';
        case 'tableTresor': return 'tables';
        default: return 'items';
      }
    }

    search(query) {
      const results = [];
      const normalizedQuery = query.toLowerCase().trim();

      this.data.forEach(category => {
        const itemsProperty = this.getItemsProperty();
        if (!category[itemsProperty]) return;

        category[itemsProperty].forEach(item => {
          const searchableText = Object.values(item).join(' ').toLowerCase();
          if (searchableText.includes(normalizedQuery)) {
            results.push({
              item,
              category: category.nom,
              type: this.type
            });
          }
        });
      });

      return results;
    }

    // Sync changes back to original objects data structure
    syncObjectsData() {
      // Sync objects data
      if (this.type === 'objet' && this.objectsData && this.data.length > 0) {
        const objectsCategory = this.data[0];
        if (objectsCategory && objectsCategory.objets) {
          this.objectsData.objets = objectsCategory.objets;
        }
      }
      
      // Sync treasure tables data
      if (this.type === 'tableTresor' && this.tablesData && this.data.length > 0) {
        const tablesCategory = this.data[0];
        if (tablesCategory && tablesCategory.tables) {
          this.tablesData.tables = tablesCategory.tables;
        }
      }
      
      // Sync monsters data - CRITICAL for preventing data reversion
      if (this.type === 'monster' && window.MONSTRES && Array.isArray(this.data)) {
        // Ensure window.MONSTRES stays synchronized with our internal data
        window.MONSTRES.length = 0; // Clear array
        window.MONSTRES.push(...this.data); // Replace with current data
        
        // Also sync image mappings
        if (JdrApp.modules.images && typeof JdrApp.modules.images.ensureMonsterImageMappings === 'function') {
          JdrApp.modules.images.ensureMonsterImageMappings();
        }
      }
    }
  }

  window.BaseEntity = BaseEntity;

})();
// ============================================================================
// JDR-BAB APPLICATION - CONTENT FACTORY
// ============================================================================

(() => {
  "use strict";

  class ContentFactory {
    constructor() {
      this.entities = new Map();
      this.initialize();
    }

    static getInstance() {
      if (!ContentFactory.instance) {
        ContentFactory.instance = new ContentFactory();
      }
      return ContentFactory.instance;
    }

    initialize() {
      // Lazy initialization - only create entities when data is available
      if (window.SORTS) {
        this.entities.set('spell', new BaseEntity('spell', window.SORTS));
      }
      if (window.DONS) {
        this.entities.set('don', new BaseEntity('don', window.DONS));
      }
      if (window.CLASSES) {
        this.entities.set('class', new BaseEntity('class', window.CLASSES));
      }
      if (window.OBJETS) {
        this.entities.set('objet', new BaseEntity('objet', window.OBJETS));
      }
      if (window.MONSTRES) {
        this.entities.set('monster', new BaseEntity('monster', window.MONSTRES));
      }
      if (window.TABLES_TRESORS) {
        this.entities.set('tableTresor', new BaseEntity('tableTresor', window.TABLES_TRESORS));
      }
    }

    getEntity(type) {
      // Ensure entity exists, create if data is available but entity is missing
      if (!this.entities.has(type)) {
        this.initializeEntity(type);
      }
      return this.entities.get(type);
    }

    initializeEntity(type) {
      switch (type) {
        case 'spell':
          if (window.SORTS) {
            this.entities.set('spell', new BaseEntity('spell', window.SORTS));
          }
          break;
        case 'don':
          if (window.DONS) {
            this.entities.set('don', new BaseEntity('don', window.DONS));
          }
          break;
        case 'class':
          if (window.CLASSES) {
            this.entities.set('class', new BaseEntity('class', window.CLASSES));
          }
          break;
        case 'objet':
          if (window.OBJETS) {
            this.entities.set('objet', new BaseEntity('objet', window.OBJETS));
          }
          break;
        case 'monster':
          if (window.MONSTRES) {
            this.entities.set('monster', new BaseEntity('monster', window.MONSTRES));
          }
          break;
        case 'tableTresor':
          if (window.TABLES_TRESORS) {
            this.entities.set('tableTresor', new BaseEntity('tableTresor', window.TABLES_TRESORS));
          }
          break;
      }
    }

    getSpells() {
      return this.getEntity('spell');
    }

    getDons() {
      return this.getEntity('don');
    }

    getClasses() {
      return this.getEntity('class');
    }

    getObjets() {
      return this.getEntity('objet');
    }

    getMonsters() {
      return this.getEntity('monster');
    }

    getTablesTresors() {
      return this.getEntity('tableTresor');
    }

    findItem(type, itemName, categoryName = null) {
      const entity = this.getEntity(type);
      return entity ? entity.findItem(itemName, categoryName) : null;
    }

    addItem(type, categoryName, itemData) {
      const entity = this.getEntity(type);
      return entity ? entity.addItem(categoryName, itemData) : false;
    }

    deleteItem(type, categoryName, itemName) {
      const entity = this.getEntity(type);
      return entity ? entity.deleteItem(categoryName, itemName) : false;
    }

    updateItem(type, categoryName, itemName, property, value) {
      const entity = this.getEntity(type);
      return entity ? entity.updateItem(categoryName, itemName, property, value) : false;
    }

    moveItem(type, categoryName, itemName, direction) {
      const entity = this.getEntity(type);
      return entity ? entity.moveItem(categoryName, itemName, direction) : false;
    }

    searchAll(query) {
      const allResults = [];
      
      this.entities.forEach((entity, type) => {
        const results = entity.search(query);
        allResults.push(...results);
      });

      return allResults;
    }

    refreshData() {
      this.entities.clear();
      this.initialize();
    }

    // ============================================================================
    // UNIFIED PAGE DESCRIPTION SYSTEM
    // ============================================================================

    getPageDescription(type) {
      const config = window.ContentTypes[type];
      
      if (!config || !config.pageDescription) {
        return '';
      }
      
      const pageDesc = config.pageDescription;
      
      if (pageDesc.dataSource === 'external') {
        // Utilisation d'un fichier externe via dataKey
        const dataObj = window[pageDesc.dataKey];
        if (!dataObj) {
          // CrÃ©er l'objet externe s'il n'existe pas
          window[pageDesc.dataKey] = { [pageDesc.storageKey]: pageDesc.defaultValue };
          return pageDesc.defaultValue;
        }
        return dataObj[pageDesc.storageKey] || pageDesc.defaultValue;
      } else {
        // Source de donnÃ©es intÃ©grÃ©e dans le dataKey principal
        const mainDataKey = config.dataKey;
        const mainData = window[mainDataKey];
        
        if (!mainData) {
          return pageDesc.defaultValue;
        }
        
        // Initialiser la description si elle n'existe pas
        if (!mainData[pageDesc.storageKey]) {
          mainData[pageDesc.storageKey] = pageDesc.defaultValue;
        }
        
        return mainData[pageDesc.storageKey];
      }
    }

    updatePageDescription(type, newDescription) {
      
      // Ensure collections type exists (fallback injection)
      if (type === 'collections' && (!window.ContentTypes || !window.ContentTypes.collections)) {
        this.ensureCollectionsType();
      }
      
      const config = window.ContentTypes[type];
      
      if (!config || !config.pageDescription) {
        // No page description config found for type
        return false;
      }
      
      const pageDesc = config.pageDescription;
      
      try {
        if (pageDesc.dataSource === 'external') {
          // Mise Ã  jour d'un fichier externe via dataKey
          const dataObj = window[pageDesc.dataKey];
          if (!dataObj) {
            window[pageDesc.dataKey] = {};
          }
          window[pageDesc.dataKey][pageDesc.storageKey] = newDescription;
          
          // Also update JdrApp.data.customPageDescriptions for consistency with router and storage
          if (!JdrApp.data.customPageDescriptions) {
            JdrApp.data.customPageDescriptions = {};
          }
          JdrApp.data.customPageDescriptions[pageDesc.storageKey] = newDescription;
        } else {
          // Mise Ã  jour dans le dataKey principal
          const mainDataKey = config.dataKey;
          const mainData = window[mainDataKey];
          
          if (!mainData) {
            return false;
          }
          
          mainData[pageDesc.storageKey] = newDescription;
        }
        
        // Ã‰mettre un Ã©vÃ©nement pour notifier le changement
        if (window.EventBus) {
          window.EventBus.emit('pageDescriptionUpdated', { type, description: newDescription });
        }
        
        return true;
      } catch (error) {
        return false;
      }
    }

    getConfig(type) {
      return window.ContentTypes[type];
    }

    createDefaultItem(type, overrides = {}) {
      const config = this.getConfig(type);
      if (!config?.defaultValues) return {};

      return { ...config.defaultValues, ...overrides };
    }

    ensureCollectionsType() {
      if (!window.ContentTypes) {
        window.ContentTypes = {};
      }
      
      // Inject collections type if missing
      window.ContentTypes.collections = {
        fields: {
          description: { type: 'richtext', label: 'Description', required: true }
        },
        template: 'collections-page',
        container: 'collections',
        icons: { 
          category: 'ğŸ“š', 
          item: 'ğŸ“¦'
        },
        pageDescription: {
          dataSource: 'external',
          dataKey: 'CUSTOM_PAGE_DESCRIPTIONS',
          storageKey: 'collections-objets',
          defaultValue: "Recherchez et explorez des collections d'objets organisÃ©es par thÃ¨me"
        },
        defaultValues: {
          description: "Recherchez et explorez des collections d'objets organisÃ©es par thÃ¨me"
        }
      };
      
      // Collections type injected into ContentTypes
    }
  }

  window.ContentFactory = ContentFactory.getInstance();

})();
// ============================================================================
// JDR-BAB APPLICATION - CARD BUILDER
// ============================================================================

(() => {
  "use strict";

  class CardBuilder {
    constructor(type, data, categoryName = null, index = null) {
      this.type = type;
      this.data = data;
      this.categoryName = categoryName;
      this.index = index;
      this.config = window.ContentTypes[type];
    }

    static create(type, data, categoryName = null, index = null) {
      return new CardBuilder(type, data, categoryName, index);
    }

    // Simple unified dev mode check
    get shouldShowEditButtons() {
      return JdrApp.utils.isDevMode();
    }

    build() {
      switch (this.type) {
        case 'spell':
          return this.buildSpellCard();
        case 'don':
          return this.buildDonCard();
        case 'subclass':
          return this.buildSubclassCard();
        case 'objet':
          return this.buildObjetCard();
        case 'monster':
          return this.buildMonsterCard();
        case 'tableTresor':
          return this.buildTableTresorCard();
        default:
          return this.buildGenericCard();
      }
    }

    buildSpellCard() {
      return `
        <div class="card editable-section" data-section-type="spell" data-spell-name="${this.data.nom}" data-spell-index="${this.index}" data-category-name="${this.categoryName}">
          ${this.buildEditableTitle(this.data.nom, 'spell-name')}
          ${this.buildSpellElement()}
          ${this.buildIllustration(`sort:${this.categoryName}:${this.data.nom}`, this.data.nom)}
          ${this.buildEditableField(this.data.description, 'spell-description', 'Description', { style: 'text-align: center; font-style: italic; margin: 1rem 0;' })}
          <hr style="margin: 1rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.6;">
          ${this.buildEditableField(this.data.prerequis, 'spell-prerequis', 'PrÃ©requis')}
          ${this.buildEditableField(this.data.portee, 'spell-portee', 'PortÃ©e')}
          ${this.buildEditableField(this.data.coutMana, 'spell-mana', 'CoÃ»t mana')}
          ${this.buildEditableField(this.data.tempsIncantation, 'spell-temps-incantation', 'Temps d\'incantation')}
          <hr style="margin: 0.5rem 0; border: none; border-top: 1px solid var(--rule);">
          ${this.buildEditableField(this.data.resistance, 'spell-resistance', 'RÃ©sistance')}
          ${this.buildEditableEffect(this.data.effetNormal, 'spell-effect-normal', 'Effet normal')}
          <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
          ${this.data.effetCritique ? this.buildEditableEffect(this.data.effetCritique, 'spell-effect-critical', 'Effet critique') : ''}
          ${this.buildDeleteButton('spell')}
        </div>
      `;
    }

    buildDonCard() {
      const index = this.index !== null ? this.index : (this.categoryName ? this.getCategoryData().dons?.indexOf(this.data) || 0 : 0);
      const totalItems = this.categoryName ? this.getCategoryData().dons?.length || 1 : 1;

      return `
        <div class="card editable-section" data-section-type="don" data-don-name="${this.data.nom}" data-don-index="${this.index}" data-category-name="${this.categoryName}">
          ${this.buildEditableTitle(this.data.nom, 'don-name')}
          ${this.buildIllustration(`don:${this.data.nom}`, this.data.nom)}
          ${this.buildEditableField(this.data.description, 'don-description', 'Description')}
          ${this.buildEditableField(this.data.prerequis, 'don-prerequis', 'PrÃ©requis')}
          ${this.buildEditableField(this.data.cout, 'don-cout', 'CoÃ»t', { style: 'color: var(--bronze); font-weight: 600;' })}
          ${this.buildMoveButtons('don', index, totalItems)}
        </div>
      `;
    }

    buildSubclassCard() {
      return `
        <div class="card editable-section" data-section-type="subclass" data-class-name="${this.categoryName}" data-subclass-name="${this.data.nom}">
          ${this.buildEditableTitle(this.data.nom, 'subclass-name')}
          ${this.buildEditableField(this.data.description || 'Description de la sous-classe', 'subclass-description', 'Description', { style: 'text-align: center; color: inherit;' })}
          ${this.buildSubclassImages()}
          <div style="margin-bottom: 1rem;">
            ${this.buildStatsSection()}
          </div>
          ${this.buildEditableField(this.data.progression, 'subclass-progression', 'Progression')}
          <div class="rule" style="margin: 1.5rem auto; height: 2px; background: linear-gradient(90deg, transparent, var(--bronze), transparent); opacity: 0.6;"></div>
          ${this.buildEditableList(this.data.capacites, 'subclass-capacites', 'CapacitÃ©s')}
          ${this.buildDeleteButton('subclass')}
        </div>
      `;
    }

    buildObjetCard() {
      // Pour les objets en page unique, l'index est basÃ© sur tous les objets
      const allObjects = window.OBJETS?.objets || [];
      const index = allObjects.indexOf(this.data) || 0;
      const totalItems = allObjects.length;
      
      // Construire l'affichage des tags
      const tagsDisplay = this.data.tags && this.data.tags.length > 0 
        ? this.data.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';

      return `
        <div class="card editable-section" data-section-type="objet" data-objet-name="${this.data.nom}" data-category-name="${this.categoryName}">
          ${this.buildEditableTitle(this.data.nom, 'objet-name')}
          ${this.buildIllustration(`objet:${this.data.nom}`, this.data.nom)}
          <div style="display: flex; justify-content: space-between; align-items: center; margin: 0.5rem 0; font-size: 0.9em; color: var(--bronze);">
            ${this.buildEditableField(`NÂ°${this.data.numero}`, 'objet-numero', 'NumÃ©ro', { style: 'font-weight: bold;' })}
            <div style="flex: 1; text-align: right;">
              <div style="margin: 2px 0;">
                ${this.buildEditableTagsField(tagsDisplay, 'objet-tags', 'Tags')}
              </div>
            </div>
          </div>
          ${this.buildEditableField(this.data.description, 'objet-description', 'Description')}
          <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
          ${this.buildEditableField(this.data.effet, 'objet-effet', 'Effet')}
          <div style="display: flex; justify-content: space-between; gap: 1rem; margin: 0.5rem 0;">
            <div style="flex: 1;">${this.buildEditableField(this.data.prix, 'objet-prix', 'Prix')}</div>
            <div style="flex: 1;">${this.buildEditableField(this.data.poids, 'objet-poids', 'Poids')}</div>
          </div>
        </div>
      `;
    }

    buildMonsterCard() {
      const allMonsters = window.MONSTRES || [];
      const index = allMonsters.indexOf(this.data) || 0;
      const totalItems = allMonsters.length;
      
      // Construire l'affichage des tags
      const tagsDisplay = this.data.tags && this.data.tags.length > 0 
        ? this.data.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';

      return `
        <div class="card editable-section" data-section-type="monster" data-monster-name="${this.data.nom}">
          ${this.buildEditableTitle(this.data.nom, 'monster-name')}
          ${this.buildIllustration(`monster:${this.data.nom}`, this.data.nom)}
          
          <div style="display: flex; justify-content: space-between; align-items: flex-start; margin: 0.5rem 0; gap: 1rem;">
            <div style="flex: 1;">
              ${this.buildEditableTagsField(tagsDisplay, 'monster-tags', 'Tags')}
            </div>
            <div style="flex-shrink: 0;">
              ${this.buildMonsterElement()}
            </div>
          </div>
          
          <!-- SÃ©paration avant les stats principales -->
          <hr style="margin: 1.5rem 0 1rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.3;">
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; margin: 1rem 0; font-size: 0.9em;">
            <div>${this.buildEditableStatField('ğŸ¯ Initiative', this.data.initiative, 'monster-initiative', 'Initiative')}</div>
            <div>${this.buildEditableStatField('â¤ï¸ PV', this.data.pointsDeVie, 'monster-pointsdevie', 'Points de vie')}</div>
            <div>${this.buildEditableStatField('âš¡ Critique', this.data.coupCritique, 'monster-coupcritique', 'Coup critique')}</div>
            <div>${this.buildEditableStatField('ğŸ›¡ï¸ Armure', this.data.armurePhysique, 'monster-armurephysique', 'Armure physique')}</div>
            <div>${this.buildEditableStatField('ğŸ”® Crit. Sorts', this.data.coupCritiqueSorts, 'monster-coupcritiquesorts', 'Critique sorts')}</div>
            <div>${this.buildEditableStatField('ğŸƒ Esquive', this.data.esquive, 'monster-esquive', 'Esquive')}</div>
            <div></div>
            <div>${this.buildEditableStatField('âœ¨ RÃ©s. Alt.', this.data.resistanceAlterations, 'monster-resistancealterations', 'RÃ©sistance altÃ©rations')}</div>
          </div>

          <!-- SÃ©paration aprÃ¨s les stats principales -->
          <hr style="margin: 1rem 0 1.5rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.3;">

          <div style="margin: 1rem 0;">
            <strong>ğŸŒŸ Armures Ã‰lÃ©mentaires:</strong>
            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 0.25rem; font-size: 0.8em; margin-top: 0.5rem;">
              <div>${this.buildEditableStatField(this.getElementIcon('Feu'), this.data.armureFeu, 'monster-armurefeu', 'Armure Feu')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Eau'), this.data.armureEau, 'monster-armureeau', 'Armure Eau')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Terre'), this.data.armureTerre, 'monster-armureterre', 'Armure Terre')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Air'), this.data.armureAir, 'monster-armureair', 'Armure Air')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('LumiÃ¨re'), this.data.armureLumiere, 'monster-armurelumiere', 'Armure LumiÃ¨re')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Nuit'), this.data.armureObscurite, 'monster-armureobscurite', 'Armure ObscuritÃ©')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('Divin'), this.data.armureDivin, 'monster-armuredivin', 'Armure Divin')}</div>
              <div>${this.buildEditableStatField(this.getElementIcon('MalÃ©fique'), this.data.armureMalefique, 'monster-armuremalefique', 'Armure MalÃ©fique')}</div>
            </div>
          </div>

          ${this.data.abilites ? `
            <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
            ${this.buildEditableField(this.data.abilites, 'monster-abilites', 'AbilitÃ©s', { style: 'margin-top: 0.5rem;' })}
          ` : ''}

          ${this.data.butin ? `
            <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
            ${this.buildEditableField(this.data.butin, 'monster-butin', 'Butin', { style: 'margin-top: 0.5rem;' })}
          ` : ''}

          ${this.buildDeleteButton('monster')}
        </div>
      `;
    }

    buildEditableTitle(content, editType, centerAlign = true) {
      const style = centerAlign ? 'margin: 0 0 1rem 0; text-align: center;' : '';
      const spellTitleClass = this.type === 'spell' ? ' spell-title' : '';
      const subclassTitleClass = this.type === 'subclass' ? ' subclass-title' : '';
      const editTypeClass = editType ? ` ${editType}` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <h4 style="${style}" class="editable editable-title${spellTitleClass}${subclassTitleClass}${editTypeClass}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}">${content}</h4>
          ${this.buildEditButton('title')}
        </div>
      `;
    }

    buildEditableField(content, editType, label, options = {}) {
      const style = options.style ? `style="${options.style}"` : '';
      const className = options.className || 'editable-field';
      
      // Add the editType as a class for reliable detection
      const editTypeClass = editType ? ` ${editType}` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable ${className}${editTypeClass}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" ${style}>
            ${content}
          </div>
          ${this.buildEditButton('field')}
        </div>
      `;
    }

    buildEditableStatField(title, value, editType, label, options = {}) {
      const style = options.style ? `style="${options.style}"` : '';
      const className = options.className || 'editable-stat';
      
      // Display the value only as editable, but show title + value visually
      return `
        <div class="editable-section" data-section-type="html">
          <div style="display: flex; align-items: center;">
            <strong style="margin-right: 0.25rem;">${title}:</strong>
            <div class="editable ${className}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" ${style}>
              ${value}
            </div>
          </div>
          ${this.buildEditButton('field')}
        </div>
      `;
    }
    
    buildEditableTagsField(content, editType, label, options = {}) {
      const style = options.style ? `style="${options.style}"` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable editable-tags" data-edit-type="tags" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" ${style}>
            ${content}
          </div>
          ${this.buildEditButton('field')}
        </div>
      `;
    }

    buildEditableEffect(content, editType, label) {
      const editTypeClass = editType ? ` ${editType}` : '';
      
      // Use the editType directly instead of creating compound identifier
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable editable-effect${editTypeClass}" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}" style="margin: 1rem 0;">
            ${content}
          </div>
          ${this.buildEditButton('effect')}
        </div>
      `;
    }

    buildEditableList(items, editType, label) {
      // Everything should be HTML format only
      let listHTML;
      if (typeof items === 'string') {
        // HTML string format
        listHTML = items;
      } else {
        // Fallback if somehow still array format - convert once
        if (Array.isArray(items)) {
          listHTML = '<ul>' + items.map(item => '<li>' + item + '</li>').join('') + '</ul>';
        } else {
          listHTML = '<ul><li>Aucune capacitÃ© dÃ©finie</li></ul>';
        }
      }
      
      // Use the editType directly instead of creating compound identifier
      return `
        <h5>${label}</h5>
        <div class="editable-section" data-section-type="html">
          <div class="editable" data-edit-type="generic" data-edit-section="${editType}" data-item-identifier="${this.data.nom}">
            ${listHTML}
          </div>
          ${this.buildEditButton('list')}
        </div>
      `;
    }

    buildStatsSection() {
      // Stats are special - they remain as objects since they're structured data
      // But check if they were converted to HTML string by editing
      let statsHTML;
      
      if (typeof this.data.base === 'string') {
        // Already converted to HTML by editing
        statsHTML = this.data.base;
      } else if (typeof this.data.base === 'object') {
        // Original object format - convert to HTML
        statsHTML = '<div class="chips">' + 
          Object.entries(this.data.base).map(([stat, value]) => {
            const icon = window.StatIcons[stat] || 'âš¡';
            return '<span class="chip">' + icon + ' ' + stat + ': <strong>' + value + '</strong></span>';
          }).join('') + 
          '</div>';
      } else {
        statsHTML = '<div>Aucune statistique dÃ©finie</div>';
      }
      
      // Use subclass-stats directly
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable editable-stats" data-edit-type="generic" data-edit-section="subclass-stats" data-item-identifier="${this.data.nom}">
            ${statsHTML}
          </div>
          ${this.buildEditButton('stats')}
        </div>
      `;
    }

    buildSubclassImages() {
      const illusKey1 = `subclass:${this.categoryName}:${this.data.nom}:1`;
      const illusKey2 = `subclass:${this.categoryName}:${this.data.nom}:2`;
      
      return `
        <div class="subclass-images">
          ${this.buildIllustration(illusKey1, `${this.data.nom} (Image 1)`, 'subclass')}
          ${this.buildIllustration(illusKey2, `${this.data.nom} (Image 2)`, 'subclass')}
        </div>
      `;
    }

    buildIllustration(illusKey, altText = '', styleType = 'default') {
      let imageUrl = '';
      let imageStyle = 'display: none;';
      let removeStyle = 'display: none;';
      
      if (window.JdrApp?.modules?.images?.getImageUrl) {
        imageUrl = window.JdrApp.modules.images.getImageUrl(illusKey);
        if (imageUrl) {
          imageUrl = window.JdrApp.modules.images.processImageUrl(imageUrl);
          imageStyle = 'display: inline-block;';
          removeStyle = 'display: inline-flex;';
        }
      }

      let containerClasses = 'illus';
      if (['spell', 'class', 'subclass', 'don', 'objet', 'monster'].includes(styleType)) {
        containerClasses += ` illus-${styleType}`;
      }

      // HYBRID APPROACH: Never generate buttons in standalone, always generate in dev mode
      const isStandalone = window.STANDALONE_VERSION === true;
      
      if (isStandalone) {
        // STANDALONE: Never generate image buttons at all
        return `
          <div class="${containerClasses}" data-illus-key="${illusKey}" data-style-type="${styleType}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
          </div>
        `;
      } else {
        // DEV MODE: Always generate buttons, let CSS handle visibility
        return `
          <div class="${containerClasses}" data-illus-key="${illusKey}" data-style-type="${styleType}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
            <label class="up">ğŸ“· Ajouter<input accept="image/*" hidden="" type="file"></label>
            <button class="rm" type="button" style="${removeStyle}">ğŸ—‘ Retirer</button>
          </div>
        `;
      }
    }

    buildSpellElement() {
      return `
        <div class="spell-element-section">
          <div class="spell-element-display" style="text-align: center; margin: 0.5rem 0;">
            <span class="element-badge" style="display: inline-block; padding: 4px 12px; background: var(--accent); color: white; border-radius: 16px; font-size: 0.9em; font-weight: 600;">
              ${this.getElementIcon(this.data.element)} ${this.data.element}
            </span>
          </div>
          <div class="spell-element-selector" style="text-align: center; margin: 0.5rem 0; display: none;">
            <label for="spell-element-${this.data.nom}" style="display: block; margin-bottom: 0.25rem; font-weight: 600;">Ã‰lÃ©ment:</label>
            <select id="spell-element-${this.data.nom}" class="editable" data-edit-type="select" data-edit-section="spell-element" data-item-identifier="${this.data.nom}">
              <option value="Feu" ${this.data.element === 'Feu' ? 'selected' : ''}>${this.getElementIcon('Feu')} Feu</option>
              <option value="Eau" ${this.data.element === 'Eau' ? 'selected' : ''}>${this.getElementIcon('Eau')} Eau</option>
              <option value="Terre" ${this.data.element === 'Terre' ? 'selected' : ''}>${this.getElementIcon('Terre')} Terre</option>
              <option value="Air" ${this.data.element === 'Air' ? 'selected' : ''}>${this.getElementIcon('Air')} Air</option>
              <option value="LumiÃ¨re" ${this.data.element === 'LumiÃ¨re' ? 'selected' : ''}>${this.getElementIcon('LumiÃ¨re')} LumiÃ¨re</option>
              <option value="Nuit" ${this.data.element === 'Nuit' ? 'selected' : ''}>${this.getElementIcon('Nuit')} Nuit</option>
              <option value="Divin" ${this.data.element === 'Divin' ? 'selected' : ''}>${this.getElementIcon('Divin')} Divin</option>
              <option value="MalÃ©fique" ${this.data.element === 'MalÃ©fique' ? 'selected' : ''}>${this.getElementIcon('MalÃ©fique')} MalÃ©fique</option>
            </select>
          </div>
        </div>
      `;
    }

    buildMonsterElement() {
      const elementColor = this.getElementColor(this.data.element);
      
      return `
        <div class="monster-element-section">
          <div class="monster-element-display">
            <span class="element-badge" style="
              display: inline-flex; 
              align-items: center; 
              padding: 4px 8px; 
              background: rgba(${parseInt(elementColor.slice(1,3), 16)}, ${parseInt(elementColor.slice(3,5), 16)}, ${parseInt(elementColor.slice(5,7), 16)}, 0.1); 
              border-radius: 6px; 
              border: 1px solid ${elementColor};
              font-size: 0.8em;
              font-weight: 600;
            ">
              <span style="margin-right: 4px;">${this.getElementIcon(this.data.element)}</span>
              <span style="color: ${elementColor};">${this.data.element}</span>
            </span>
          </div>
          <div class="monster-element-selector" style="margin-top: 0.5rem; display: none;">
            <select class="editable" data-edit-type="select" data-edit-section="monster-element" data-item-identifier="${this.data.nom}" style="width: 100%; padding: 4px; border: 1px solid ${elementColor}; border-radius: 4px; font-size: 0.8em;">
              <option value="Feu" ${this.data.element === 'Feu' ? 'selected' : ''}>${this.getElementIcon('Feu')} Feu</option>
              <option value="Eau" ${this.data.element === 'Eau' ? 'selected' : ''}>${this.getElementIcon('Eau')} Eau</option>
              <option value="Terre" ${this.data.element === 'Terre' ? 'selected' : ''}>${this.getElementIcon('Terre')} Terre</option>
              <option value="Air" ${this.data.element === 'Air' ? 'selected' : ''}>${this.getElementIcon('Air')} Air</option>
              <option value="LumiÃ¨re" ${this.data.element === 'LumiÃ¨re' ? 'selected' : ''}>${this.getElementIcon('LumiÃ¨re')} LumiÃ¨re</option>
              <option value="Nuit" ${this.data.element === 'Nuit' ? 'selected' : ''}>${this.getElementIcon('Nuit')} Nuit</option>
              <option value="Divin" ${this.data.element === 'Divin' ? 'selected' : ''}>${this.getElementIcon('Divin')} Divin</option>
              <option value="MalÃ©fique" ${this.data.element === 'MalÃ©fique' ? 'selected' : ''}>${this.getElementIcon('MalÃ©fique')} MalÃ©fique</option>
            </select>
          </div>
        </div>
      `;
    }

    getElementIcon(element) {
      return window.ElementIcons?.[element] || 'âš¡';
    }

    getElementColor(element) {
      return window.ElementColors?.[element]?.color || '#666';
    }

    buildTableTresorCard() {
      const tableIndex = window.TABLES_TRESORS?.tables ? window.TABLES_TRESORS.tables.indexOf(this.data) : 0;
      const totalTables = window.TABLES_TRESORS?.tables?.length || 1;
      
      // Condition amÃ©liorÃ©e pour afficher les boutons d'Ã©dition des fourchettes
      const shouldShowFourchetteButtons = this.shouldShowEditButtons || 
                                         (!window.STANDALONE_VERSION && window.location.search.includes('dev=1')) ||
                                         (document.body.classList.contains('dev-on')) ||
                                         (window.location.protocol === 'file:' && !window.STANDALONE_VERSION) ||
                                         // Condition de fallback pour le dÃ©veloppement
                                         (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1');
      
      // Construire l'affichage des tags
      const tagsDisplay = this.data.tags && this.data.tags.length > 0 
        ? this.data.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';
      
      // Construire l'affichage des fourchettes
      const fourchetteDisplay = this.data.fourchettes?.map((fourchette, index) => {
        const objet = fourchette.objet;
        const objetLink = objet?.type === 'reference' 
          ? `<a href="#" class="object-preview-link" data-object-numero="${objet.numero}" style="color: var(--accent); text-decoration: none;" title="Cliquer pour prÃ©visualiser l'objet #${objet.numero}">ğŸ“¦ ${objet.nom} (NÂ°${objet.numero})</a>`
          : `ğŸ“¦ ${objet?.nom || 'Objet inconnu'}`;
        
        const editButtons = shouldShowFourchetteButtons ? `
          <div class="fourchette-actions" style="margin-left: 8px; display: flex; gap: 4px;">
            <button class="edit-fourchette-btn" data-table-name="${this.data.nom}" data-fourchette-index="${index}" title="Ã‰diter cette fourchette" style="background: #3b82f6; color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;">âœï¸</button>
            <button class="delete-fourchette-btn" data-table-name="${this.data.nom}" data-fourchette-index="${index}" title="Supprimer cette fourchette" style="background: #dc2626; color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;">ğŸ—‘ï¸</button>
          </div>
        ` : '';
        
        return `
          <div class="fourchette-row" style="display: flex; justify-content: space-between; align-items: center; padding: 8px; margin: 4px 0; background: rgba(139, 92, 23, 0.1); border-radius: 6px; border-left: 3px solid var(--bronze);">
            <div class="fourchette-range" style="font-weight: bold; color: var(--bronze); min-width: 80px;">
              ğŸ² ${fourchette.min}-${fourchette.max}
            </div>
            <div class="fourchette-objet" style="flex: 1; margin-left: 12px;">
              ${objetLink}
            </div>
            ${editButtons}
          </div>
        `;
      }).join('') || '<div style="font-style: italic; color: #666; text-align: center; padding: 1rem;">Aucune fourchette dÃ©finie</div>';

      return `
        <div class="card editable-section" data-section-type="tableTresor" data-table-tresor-name="${this.data.nom}" data-category-name="${this.categoryName}">
          ${this.buildEditableTitle(this.data.nom, 'table-tresor-name')}
          <div style="text-align: center; margin: 0.5rem 0;">
            ${this.buildEditableTagsField(tagsDisplay, 'table-tresor-tags', 'Tags')}
          </div>
          
          <hr style="margin: 1rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.6;">
          
          <div class="fourchettes-section">
            <h4 style="color: var(--bronze); margin: 1rem 0 0.5rem 0; display: flex; align-items: center; gap: 8px;">
              ğŸ² Fourchettes de butin
            </h4>
            <div class="fourchettes-list">
              ${fourchetteDisplay}
            </div>
          </div>
          
          ${shouldShowFourchetteButtons ? `
            <div class="edit-actions" style="margin-top: 1rem; text-align: center; display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: center;">
              <button class="table-tresor-add-fourchette btn" data-table-tresor-name="${this.data.nom}" type="button" style="background: var(--accent); color: white;">
                â• Ajouter fourchette
              </button>
              ${this.buildMoveButtons('table-tresor', tableIndex, totalTables)}
            </div>
            ${this.buildDeleteButton('table-tresor')}
          ` : ''}
        </div>
      `;
    }

    buildGenericCard() {
      return `
        <div class="card">
          <h4>${this.data.nom || 'Unknown'}</h4>
          <p>Generic card for type: ${this.type}</p>
        </div>
      `;
    }

    buildEditButton(buttonType) {
      return `<button class="edit-btn" type="button" title="âœï¸ Ã‰diter" data-button-type="${buttonType}">âœï¸</button>`;
    }

    buildDeleteButton(type) {
      const config = this.config;
      const deleteIcon = config?.icons?.delete || 'ğŸ—‘ï¸';
      
      return `
        <div class="delete-button-container" style="margin-top: 1rem; text-align: center;">
          <button class="${type}-delete btn" data-${type}-name="${this.data.nom}" ${this.categoryName ? `data-category-name="${this.categoryName}"` : ''} type="button" style="background: #dc2626; color: white; border: 2px solid #b91c1c;">
            ${deleteIcon} Supprimer ${type}
          </button>
        </div>
      `;
    }

    buildMoveButtons(type, index, totalItems) {
      if (totalItems <= 1) {
        return '';
      }

      return `
        <div class="move-buttons" style="display: flex; gap: 0.5rem; justify-content: center; margin-top: 1rem;">
          <button class="${type}-move-up btn small" data-${type}-name="${this.data.nom}" data-category-name="${this.categoryName}" type="button" style="background: #3b82f6; color: white; padding: 4px 8px; font-size: 0.8em;" ${index === 0 ? 'disabled' : ''}>
            â†‘ Haut
          </button>
          <button class="${type}-move-down btn small" data-${type}-name="${this.data.nom}" data-category-name="${this.categoryName}" type="button" style="background: #3b82f6; color: white; padding: 4px 8px; font-size: 0.8em;" ${index >= totalItems - 1 ? 'disabled' : ''}>
            â†“ Bas
          </button>
        </div>
      `;
    }

    getCategoryData() {
      if (this.type === 'don' && this.categoryName) {
        const categoryData = window.DONS.find(cat => cat.nom === this.categoryName);
        return categoryData || { dons: [] };
      }
      return { [this.type + 's']: [] };
    }
  }

  window.CardBuilder = CardBuilder;

})();
// ============================================================================
// JDR-BAB APPLICATION - PAGE BUILDER
// ============================================================================

(() => {
  "use strict";

  class PageBuilder {
    constructor() {
      // Will use unified dev mode check
    }

    // Simple unified dev mode check
    get shouldShowEditButtons() {
      return JdrApp.utils.isDevMode();
    }

    static getInstance() {
      if (!PageBuilder.instance) {
        PageBuilder.instance = new PageBuilder();
      }
      return PageBuilder.instance;
    }

    buildCategoryPage(type, category) {
      const config = window.ContentTypes[type];
      
      // Gestion spÃ©ciale pour les objets (page unique avec filtres)
      if (type === 'objet' && config.pageType === 'single') {
        return this.buildSingleObjectPage(category);
      }
      
      // Gestion spÃ©ciale pour les tables de trÃ©sors (page unique)
      if (type === 'tableTresor' && config.pageType === 'single') {
        return this.buildSingleTableTresorPage(category);
      }
      
      const pageId = `${config.container}-${this.sanitizeId(category.nom || 'unknown')}`;
      const itemsProperty = this.getItemsProperty(type);
      
      // Get items and sort them for spells
      let items = category[itemsProperty] || [];
      if (type === 'spell') {
        items = this.sortSpellsByLevel([...items]);
      }

      return `
        <article class="" data-page="${pageId}">
          <section>
            ${this.buildCategoryHeader(category, type)}
            ${type === 'spell' ? this.buildSpellLevelFilter() : ''}
            <div style="display: flex; gap: 8px; margin-bottom: 1rem; flex-wrap: wrap;">
              ${this.buildAddButton(type, category.nom)}
              ${this.buildDeleteCategoryButton(type, category.nom)}
            </div>
            <div class="grid cols-2" id="${config.container}-container-${this.sanitizeId(category.nom)}">
              ${items.map((item, index) => 
                CardBuilder.create(type, item, category.nom, index).build()
              ).join('')}
            </div>
            ${this.buildGeneralDonsSection(type, category.nom)}
          </section>
        </article>
      `;
    }
    
    buildSingleObjectPage(objectData) {
      const config = window.ContentTypes['objet'];
      const allObjects = objectData.objets || [];
      // SIMPLIFIÃ‰: SystÃ¨me simple avec variable globale pour les tags actifs
      const availableTags = config.filterConfig.availableTags || [];
      
      // Initialiser la variable globale pour les tags actifs si elle n'existe pas
      if (!window.ACTIVE_OBJECT_TAGS) {
        window.ACTIVE_OBJECT_TAGS = []; // Aucun tag actif par dÃ©faut
      }
      const activeTags = window.ACTIVE_OBJECT_TAGS;
      
      // Filtrer les objets selon le mode actuel
      const isDevMode = JdrApp.utils.isDevMode();
      
      // console.log('ğŸ¯ Object filtering - isDevMode:', isDevMode, 'activeIdSearch:', !!window.activeIdSearch, 'activeTags:', activeTags.length);
      
      const filteredObjects = window.activeIdSearch 
        ? allObjects // TOUJOURS afficher tous les objets quand recherche par ID est active
        : !isDevMode
          ? [] // Mode dev OFF: aucun objet affichÃ© par dÃ©faut (seule recherche ID fonctionne)
          : activeTags.length === 0 
            ? allObjects // Mode dev ON + aucun tag actif = TOUS les objets
            : allObjects.filter(obj => {
                // Mode dev ON: LOGIQUE ET - l'objet doit avoir TOUS les tags actifs
                if (!obj.tags || obj.tags.length === 0) return false;
                // VÃ©rifier que l'objet a TOUS les tags actifs (logique AND)
                return activeTags.every(activeTag => obj.tags.includes(activeTag));
              });
      
      // console.log('ğŸ“Š Filtered objects count:', filteredObjects.length, '/ Total objects:', allObjects.length);
      
      return `
        <article class="" data-page="objets">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2>ğŸ“¦ Objets</h2>
              ${this.buildIllustration('page:objets')}
            </div>
            
            ${this.buildPageDescription('objet')}
            
            ${this.buildIdSearchFilter()}
            ${this.buildTagFilters(activeTags, availableTags)}
            
            <div style="display: flex; gap: 8px; margin-bottom: 1rem; flex-wrap: wrap;">
              ${this.buildAddButton('objet', 'objets')}
              ${this.buildTagsManagerButton()}
            </div>
            
            <div class="grid cols-2" id="objets-container">
              ${filteredObjects.map((item, index) => 
                CardBuilder.create('objet', item, 'objets', index).build()
              ).join('')}
            </div>
            
            ${filteredObjects.length === 0 && !window.activeIdSearch ? '<p style="text-align: center; color: #666; margin: 2rem 0;">Aucun objet ne correspond aux filtres sÃ©lectionnÃ©s.</p>' : ''}
          </section>
        </article>
      `;
    }

    buildSingleMonsterPage(monsterData) {
      let config = window.ContentTypes?.['monster'];
      const allMonsters = monsterData || [];
      const instance = PageBuilder.getInstance(); // CrÃ©er une instance pour accÃ©der aux mÃ©thodes
      
      // Defensive check for config with fallback
      if (!config || !config.filterConfig) {
        console.warn('Monster config not loaded, using fallback defaults');
        console.log('ContentTypes available:', window.ContentTypes ? Object.keys(window.ContentTypes) : 'undefined');
        config = {
          filterConfig: {
            defaultVisibleTags: ['ForÃªt'],
            availableTags: ['ForÃªt', 'Boss', 'Minion', 'Volant', 'Aquatique', 'Terrestre']
          }
        };
      }
      
      // Utiliser le state du filtre s'il existe, sinon les tags par dÃ©faut
      const visibleTags = window.MONSTRES_FILTER_STATE?.visibleTags || config.filterConfig.defaultVisibleTags;
      
      // Filter monsters according to visible tags (AND mode)
      const filteredMonsters = visibleTags.length === 0 
        ? [] // If no tags are visible, show nothing
        : allMonsters.filter(monster => {
            // Check that the monster has the required tags to be visible
            if (!monster.tags) return false;
            
            // In AND mode: monster must have ALL visible tags
            const hasAllVisibleTags = visibleTags.every(tag => monster.tags.includes(tag));
            if (!hasAllVisibleTags) return false;
            
            return true;
          });
      
      return `
        <article class="" data-page="monstres">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2>ğŸ² Monstres</h2>
              ${instance.buildIllustration('page:monstres')}
            </div>
            
            ${instance.buildPageDescription('monster')}
            
            ${instance.buildTagFilters(visibleTags, config.filterConfig.availableTags, 'monster')}
            
            <div style="display: flex; gap: 8px; margin-bottom: 1rem; flex-wrap: wrap;">
              ${instance.buildAddButton('monster', 'monstres')}
              ${instance.buildTagsManagerButton()}
            </div>
            
            <div class="grid cols-2" id="monstres-container">
              ${filteredMonsters.map((item, index) => 
                CardBuilder.create('monster', item, 'monstres', index).build()
              ).join('')}
            </div>
            
            ${filteredMonsters.length === 0 ? '<p style="text-align: center; color: #666; margin: 2rem 0;">Aucun monstre ne correspond aux filtres sÃ©lectionnÃ©s.</p>' : ''}
          </section>
        </article>
      `;
    }

    buildClassPage(classData) {
      const pageId = this.sanitizeId(classData.nom);
      
      return `
        <article class="" data-page="${pageId}" data-page-title="${classData.nom}">
          <section>
            ${this.buildClassHeader(classData)}
            ${this.buildEditableSection(classData.resume, 'class-resume', 'paragraph', classData.nom)}
            <h3>CapacitÃ©s de classe</h3>
            ${this.buildSimpleEditableContent(classData.capacites, 'class-capacites', classData.nom)}
            <h3>Sous-classes</h3>
            <div class="subclass-stack">
              ${classData.sousClasses ? classData.sousClasses.map(sousClasse => 
                CardBuilder.create('subclass', sousClasse, classData.nom).build()
              ).join('') : ''}
            </div>
            ${this.buildAddSubclassButton()}
          </section>
        </article>
      `;
    }

    buildStaticPage(pageId, pageData) {
      const isActive = pageId === 'creation' ? 'active' : '';
      
      // Defense against missing or malformed pageData
      if (!pageData || typeof pageData !== 'object') {
        console.warn('buildStaticPage: invalid pageData', pageData);
        return `<article class="${isActive}" data-page="${pageId}"><section><h2>Page non disponible</h2><p>Les donnÃ©es de cette page ne sont pas disponibles.</p></section></article>`;
      }
      
      const title = pageData.title || pageId;
      const page = pageData.page || pageId;
      
      // Special handling for campaign page
      if (pageId === 'campagne') {
        return this.buildCampaignPage(pageId, pageData);
      }
      
      return `
        <article class="${isActive}" data-page="${page}" data-static-page="true" data-page-title="${title}">
          <section>
            ${this.buildStaticPageHeader(pageData)}
            ${this.buildSections(pageData.sections)}
            ${this.buildAddSectionButton()}
          </section>
        </article>
      `;
    }

    buildCategoryHeader(category, type) {
      const config = window.ContentTypes[type];
      
      return `
        <div style="text-align:center;margin-bottom:2rem;">
          ${this.buildEditableTitle(category.nom, `${type}-category-name`)}
          ${this.buildIllustration(`${type}category:${category.nom}`)}
        </div>
        ${this.buildEditableSection(category.description, `${type}-category-description`, 'paragraph', category.nom)}
      `;
    }

    buildClassHeader(classData) {
      return `
        <div style="text-align:center;margin-bottom:2rem;">
          ${this.buildEditableTitle(classData.nom, 'class-name', classData.nom)}
          ${this.buildIllustration(`class:${classData.nom}`)}
        </div>
      `;
    }

    buildStaticPageHeader(pageData) {
      const printButton = pageData.page === 'etats' ? this.buildPrintButton() : '';
      
      return `
        <div style="text-align:center;margin-bottom:2rem;">
          <div style="display:inline-flex;align-items:center;gap:8px;">
            <h2 class="editable editable-title" data-edit-type="generic" data-edit-section="page-title">${pageData.title}</h2>
            ${this.buildEditButton('title')}
          </div>
          ${this.buildIllustration(`page:${pageData.page}`)}
          ${printButton}
        </div>
      `;
    }

    buildCompactCampaignHeader(pageData) {
      return `
        <div style="text-align:center;margin-bottom:0.5rem;">
          <div style="display:inline-flex;align-items:center;gap:8px;">
            <h2 class="editable editable-title" data-edit-type="generic" data-edit-section="page-title">${pageData.title}</h2>
            ${this.buildEditButton('title')}
          </div>
        </div>
      `;
    }

    buildEditableTitle(content, editType, editSection = null) {
      return `
        <div style="display:inline-flex;align-items:center;gap:8px;justify-content:center;">
          <h2 class="editable editable-title" data-edit-type="generic" data-edit-section="${editSection || content}">${content}</h2>
          ${this.buildEditButton('title')}
        </div>
      `;
    }

    buildEditableSection(content, editType, sectionType, editSection) {
      const className = sectionType === 'paragraph' ? 'lead editable editable-paragraph' : 'editable editable-field';
      
      return `
        <div class="editable-section" data-section-type="${editType}">
          <p class="${className}" data-edit-type="generic" data-edit-section="${editSection}">${content}</p>
          ${this.buildEditButton(sectionType)}
        </div>
      `;
    }


    buildSimpleEditableContent(content, editType, editSection) {
      // Everything should be HTML format only
      let htmlContent;
      if (typeof content === 'string') {
        htmlContent = content || '';
      } else {
        // Fallback if somehow still array format - convert once and warn
        console.warn('Found array format in buildSimpleEditableContent, converting to HTML:', content);
        if (Array.isArray(content)) {
          htmlContent = '<ul>' + content.map(item => '<li>' + item + '</li>').join('') + '</ul>';
        } else {
          htmlContent = '';
        }
      }
      
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable" data-edit-type="generic" data-edit-section="${editSection}">
            ${htmlContent}
          </div>
          ${this.buildEditButton('section')}
        </div>
      `;
    }

    buildSections(sections) {
      // Defense against undefined sections
      if (!sections || !Array.isArray(sections)) {
        console.warn('buildSections: sections is not an array', sections);
        return '';
      }
      
      return sections.map((section, sectionIndex) => {
        switch (section.type) {
          case 'intro':
            return this.buildIntroSection(section, sectionIndex);
          case 'card':
            return this.buildCardSection(section, sectionIndex);
          case 'grid':
            return this.buildGridSection(section, sectionIndex);
          case 'filters':
            return this.buildFiltersSection(section, sectionIndex);
          case 'monster-list':
            return this.buildMonsterListSection(section, sectionIndex);
          default:
            return `<div><!-- Unknown section type: ${section.type} --></div>`;
        }
      }).join('');
    }

    buildIntroSection(section, sectionIndex) {
      const editSection = `intro-${sectionIndex}`;
      return `
        <div class="editable-section" data-section-type="intro" data-section-index="${sectionIndex}">
          <p class="editable editable-intro" data-edit-type="generic" data-edit-section="${editSection}">${section.content}</p>
          ${this.buildEditButton('section')}
        </div>
        ${this.buildAddParagraphButton('intro')}
      `;
    }

    buildCardSection(cardData, sectionIndex) {
      let cardHTML = `<div class="card editable-section" data-section-type="card" data-section-index="${sectionIndex}">`;
      
      if (cardData.deletable && cardData.sectionType) {
        cardHTML += `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${cardData.id}-title">${cardData.title}</h3>
            ${this.buildEditButton('title')}
            ${this.buildRemoveSectionButton(cardData.sectionType)}
          </div>
        `;
      } else {
        cardHTML += `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${cardData.id}-title">${cardData.title}</h3>
            ${this.buildEditButton('title')}
          </div>
        `;
      }

      // Handle different content formats
      let htmlContent = '';
      let editSection = cardData.id || 'card-' + sectionIndex;
      
      if (typeof cardData.content === 'string') {
        // Direct HTML string
        htmlContent = cardData.content;
      } else if (typeof cardData.content === 'object' && cardData.content?.content) {
        // Object with nested content property
        htmlContent = cardData.content.content;
        if (cardData.content.editSection) {
          editSection = cardData.content.editSection;
        }
      } else {
        htmlContent = cardData.content || '';
      }
      
      cardHTML += `
        <div style="position:relative;">
          <div class="editable" data-edit-type="generic" data-edit-section="${editSection}">${htmlContent}</div>
          ${this.buildEditButton('section')}
        </div>
      `;

      if (cardData.deletable && cardData.sectionName) {
        // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
        cardHTML += `
          <div style="margin-top: 1rem; text-align: center;">
            <button class="section-delete btn small" data-section-name="${cardData.sectionName}" type="button" style="background: #ff6b6b; color: white;">ğŸ—‘ Supprimer section</button>
          </div>
        `;
      }
      
      cardHTML += `</div>`;
      return cardHTML;
    }


    buildContentItem(item) {
      if (item.type === 'paragraph') {
        const content = `
          <div class="editable-section" data-section-type="paragraph">
            <p class="editable editable-paragraph" data-edit-type="generic" data-edit-section="${item.editSection}">${item.content}</p>
            ${this.buildEditButton('paragraph')}
          </div>
        `;
        const addBtn = this.buildAddParagraphButton(item.editSection);
        return content + addBtn;
      }
      return `<div>${item.content}</div>`;
    }

    buildGridSection(gridSection, sectionIndex) {
      const items = gridSection.content || gridSection.items || [];
      if (!Array.isArray(items)) {
        return '<div><!-- Grid items is not an array --></div>';
      }

      const cols = gridSection.cols || 2;
      let gridHTML = `<div class="grid" style="display: grid; grid-template-columns: repeat(${cols}, 1fr); gap: 1rem;">`;
      
      items.forEach((item, itemIndex) => {
        gridHTML += this.buildCardSection(item, `${sectionIndex}-${itemIndex}`);
      });
      
      gridHTML += '</div>';
      return gridHTML;
    }

    buildComplexContent(content) {
      // Generic HTML content - no special processing
      return content || '';
    }


    buildIllustration(illusKey, altText = '') {
      let imageUrl = '';
      let imageStyle = 'display: none;';
      let removeStyle = 'display: none;';
      
      if (window.JdrApp?.modules?.images?.getImageUrl) {
        imageUrl = window.JdrApp.modules.images.getImageUrl(illusKey);
        if (imageUrl) {
          imageUrl = window.JdrApp.modules.images.processImageUrl(imageUrl);
          imageStyle = 'display: inline-block;';
          removeStyle = 'display: inline-flex;';
        }
      }

      // HYBRID APPROACH: Never generate buttons in standalone, always generate in dev mode
      const isStandalone = window.STANDALONE_VERSION === true;
      
      if (isStandalone) {
        // STANDALONE: Never generate image buttons at all
        return `
          <div class="illus" data-illus-key="${illusKey}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
          </div>
        `;
      } else {
        // DEV MODE: Always generate buttons, let CSS handle visibility
        return `
          <div class="illus" data-illus-key="${illusKey}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
            <label class="up">ğŸ“· Ajouter<input accept="image/*" hidden="" type="file"></label>
            <button class="rm" type="button" style="${removeStyle}">ğŸ—‘ Retirer</button>
          </div>
        `;
      }
    }

    buildFiltersSection(section, sectionIndex) {
      const contentType = section.contentType || 'monster';
      
      // Ensure ContentTypes is loaded
      if (!window.ContentTypes) {
        console.warn('ContentTypes not loaded yet, skipping filters');
        return '';
      }
      
      let config = window.ContentTypes[contentType];
      const filterMode = section.filterMode || 'OR';
      
      // Fallback configuration for monster if not loaded
      if (!config && contentType === 'monster') {
        config = {
          filterConfig: {
            availableTags: ["Foret", "Animal", "Humanoid", "Dragon", "Faible", "Puissant", "Boss", "Feu", "Eau", "Terre", "Air", "Rapide", "Poison"],
            defaultVisibleTags: ["Foret", "Animal", "Humanoid"]
          }
        };
      }
      
      if (!config || !config.filterConfig) {
        return '';
      }
      
      const availableTags = config.filterConfig.availableTags || [];
      const defaultTags = config.filterConfig.defaultVisibleTags || [];
      
      return `
        <div class="filter-section" data-content-type="${contentType}" data-filter-mode="${filterMode}">
          <h3>ğŸ” Filtres (${filterMode === 'AND' ? 'ET' : 'OU'})</h3>
          <div class="filter-tags" data-default-tags='${JSON.stringify(defaultTags)}'>
            ${availableTags.map(tag => `
              <label class="filter-tag ${defaultTags.includes(tag) ? 'active' : ''}">
                <input type="checkbox" value="${tag}" ${defaultTags.includes(tag) ? 'checked' : ''}>
                <span>${tag}</span>
              </label>
            `).join('')}
          </div>
          ${this.buildDevModeButtons(contentType)}
        </div>
      `;
    }

    buildMonsterListSection(section, sectionIndex) {
      const contentType = section.contentType || 'monster';
      
      return `
        <div class="monster-list-section" data-content-type="${contentType}">
          <div class="monsters-grid" id="monsters-container">
            <!-- Les monstres seront gÃ©nÃ©rÃ©s par JavaScript -->
          </div>
        </div>
      `;
    }

    buildDevModeButtons(contentType) {
      // Ensure ContentTypes is loaded for proper button generation
      if (!window.ContentTypes) {
        return '';
      }
      
      // For monster type, generate buttons even if config is missing (they'll work with fallback)
      if (contentType !== 'monster' && !window.ContentTypes[contentType]) {
        return '';
      }
      
      // Use the same approach as modal buttons - conditional rendering based on dev mode
      const isDevMode = JdrApp.utils.isDevMode();
      const displayStyle = isDevMode ? 'block' : 'none';
      
      return `
        <div class="dev-mode-buttons" style="margin-top: 1rem; display: ${displayStyle};" data-dev-only="true">
          <button class="btn btn-small add-${contentType}-btn">â• Ajouter ${contentType === 'monster' ? 'un monstre' : 'un Ã©lÃ©ment'}</button>
          <button class="btn btn-small manage-tags-btn" data-content-type="${contentType}">ğŸ·ï¸ GÃ©rer les tags</button>
        </div>
      `;
    }

    buildEditButton(type) {
      const titles = {
        title: 'Ã‰diter le titre',
        paragraph: 'Ã‰diter ce paragraphe',
        field: 'Ã‰diter ce champ',
        list: 'Ã‰diter cette liste',
        section: 'Ã‰diter cette section'
      };

      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="edit-btn edit-${type}-btn" title="${titles[type] || 'Ã‰diter'}">âœï¸</button>`;
    }

    buildAddButton(type, categoryName) {
      const config = window.ContentTypes[type];
      const icon = config?.icons?.add || 'â•';
      
      // ALWAYS generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="${type}-add btn" data-category-name="${categoryName}" type="button" style="background: var(--accent); color: white;">${icon} Ajouter un ${type === 'spell' ? 'sort' : type === 'don' ? 'don' : type === 'monster' ? 'monstre' : 'Ã©lÃ©ment'}</button>`;
    }

    buildDeleteCategoryButton(type, categoryName) {
      const config = window.ContentTypes[type];
      const deleteIcon = config?.icons?.delete || 'ğŸ—‘ï¸';
      
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="${type}-category-delete btn" data-category-name="${categoryName}" data-category-type="${type}" type="button" style="background: #dc2626; color: white;">${deleteIcon} Supprimer catÃ©gorie</button>`;
    }

    buildAddSubclassButton() {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<div class="add-subclass-btn">â• Ajouter une sous-classe</div>`;
    }

    buildAddSectionButton() {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<div class="add-paragraph-btn" data-target="section">â• Ajouter une nouvelle section</div>`;
    }

    buildAddParagraphButton(target) {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<div class="add-paragraph-btn" data-target="${target}">â• Ajouter un paragraphe</div>`;
    }

    buildRemoveSectionButton(sectionType) {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="remove-section-btn" data-section-type="${sectionType}" type="button" style="background: #dc2626; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 12px;">ğŸ—‘ Supprimer section</button>`;
    }

    getItemsProperty(type) {
      switch (type) {
        case 'spell': return 'sorts';
        case 'don': return 'dons';
        case 'objet': return 'objets';
        case 'class': return 'sousClasses';
        default: return 'items';
      }
    }

    // Extract level number from prerequis text
    extractLevelFromPrerequisite(prerequis) {
      if (!prerequis) return 0;
      const match = prerequis.match(/Niveau (\d+)/i);
      return match ? parseInt(match[1], 10) : 0;
    }

    // Sort spells by level (prerequisite level)
    sortSpellsByLevel(spells) {
      return spells.sort((a, b) => {
        const levelA = this.extractLevelFromPrerequisite(a.prerequis);
        const levelB = this.extractLevelFromPrerequisite(b.prerequis);
        return levelA - levelB;
      });
    }

    // Build spell level filter UI
    buildSpellLevelFilter() {
      return `
        <div class="spell-level-filter" style="margin: 1rem 0; padding: 1rem; background: var(--card); border: 2px solid var(--rule); border-radius: 12px;">
          <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
            <label style="font-weight: 600; color: var(--accent-ink);">
              ğŸ¯ Filtrer par niveau maximum :
            </label>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              <input 
                type="number" 
                id="spell-level-filter" 
                min="0" 
                max="20" 
                value="20"
                style="width: 80px; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px; text-align: center; font-weight: 600;"
              >
              <button 
                id="reset-spell-filter" 
                class="btn small" 
                style="background: var(--bronze); color: white; padding: 0.5rem 1rem;"
                title="RÃ©initialiser le filtre"
              >
                ğŸ”„ Tout afficher
              </button>
            </div>
          </div>
        </div>
      `;
    }

    buildIdSearchFilter() {
      const isIdSearchActive = window.activeIdSearch || false;
      const isDevMode = JdrApp.utils.isDevMode();
      const searchBorderColor = isIdSearchActive ? '#16a34a' : 'var(--rule)';
      const searchBoxShadow = isIdSearchActive ? 'box-shadow: 0 0 8px rgba(22, 163, 74, 0.3);' : '';
      const searchIndicator = isIdSearchActive ? 'ğŸ¯ ' : 'ğŸ” ';
      const buttonText = isIdSearchActive ? 'ğŸ”„ Affichage normal' : 'ğŸ”„ Tout afficher';
      const buttonTitle = isIdSearchActive ? 'Retourner Ã  l\'affichage normal avec filtres' : 'Effacer la recherche et afficher tous les objets';
      
      return `
        <div class="id-search-filter" style="margin: 0.5rem 0; background: var(--card); border: 2px solid ${searchBorderColor}; border-radius: 12px; display: flex; flex-direction: column; ${searchBoxShadow}">
          <div style="display: flex; align-items: center; justify-content: center; gap: 1rem; flex-wrap: wrap; padding: 0.375rem; min-height: 2.5rem;">
            <label for="id-search-input" style="font-weight: 600; color: var(--accent-ink); white-space: nowrap; display: flex; align-items: center; height: 100%;">
              ${searchIndicator}Recherche par ID :
            </label>
            <div style="display: flex; align-items: center; gap: 0.5rem; height: 100%;">
              <input 
                type="number" 
                id="id-search-input" 
                min="1" 
                placeholder="NumÃ©ro d'objet (ex: 42)"
                style="padding: 0.2rem; border: 1px solid ${searchBorderColor}; border-radius: 6px; font-size: 0.95em; width: 150px; height: 2rem; display: flex; align-items: center;"
              >
              <button 
                id="clear-id-search" 
                class="btn small" 
                style="background: var(--bronze); color: white; padding: 0.2rem 0.4rem; white-space: nowrap; font-size: 0.9em; display: ${!isDevMode ? 'none' : 'flex'}; align-items: center; height: 2rem; justify-content: center;"
                title="${buttonTitle}"
              >
                ${buttonText}
              </button>
            </div>
          </div>
          <div id="id-search-result" style="padding: 0 0.375rem 0.375rem; font-size: 0.85em; color: var(--paper-muted); min-height: 0.5em; line-height: 1.2; text-align: center;">
            <!-- RÃ©sultat de la recherche affichÃ© ici -->
          </div>
        </div>
      `;
    }

    buildPageDescription(type) {
      const config = window.ContentTypes[type];
      
      if (!config || !config.pageDescription) {
        return '';
      }
      
      const pageDesc = config.pageDescription;
      
      // Obtenir la description de maniÃ¨re unifiÃ©e
      let description = '';
      
      if (pageDesc.dataSource === 'external') {
        // Utilisation d'un fichier externe via dataKey
        const dataObj = window[pageDesc.dataKey];
        if (!dataObj) {
          // CrÃ©er l'objet externe s'il n'existe pas
          window[pageDesc.dataKey] = { [pageDesc.storageKey]: pageDesc.defaultValue };
        }
        description = window[pageDesc.dataKey][pageDesc.storageKey] || pageDesc.defaultValue;
      } else {
        // Source de donnÃ©es intÃ©grÃ©e dans le dataKey principal
        const mainDataKey = config.dataKey;
        const mainData = window[mainDataKey];
        
        if (!mainData) {
          console.warn(`Main data key ${mainDataKey} not found for type ${type}`);
          description = pageDesc.defaultValue;
        } else {
          // Initialiser la description si elle n'existe pas
          if (!mainData[pageDesc.storageKey]) {
            mainData[pageDesc.storageKey] = pageDesc.defaultValue;
          }
          description = mainData[pageDesc.storageKey];
        }
      }
      
      const cssClass = `${type}-category-description`;
      const sectionType = `${type}-category-description`;
      
      return `
        <div class="${cssClass}" style="margin: 1rem 0; padding: 1rem; background: var(--card); border-radius: 8px; border-left: 4px solid var(--bronze);">
          <div class="editable-section" data-section-type="${sectionType}">
            <p class="lead editable editable-paragraph" data-edit-type="generic" data-edit-section="${pageDesc.editSection}">${description}</p>
            ${this.buildEditButton('section')}
          </div>
        </div>
      `;
    }

    buildTagFilters(activeTags, availableTags, context = 'objet') {
      // For objects page, show tag filters ONLY in dev mode ON
      const isDevMode = JdrApp.utils.isDevMode();
      
      // console.log('ğŸ·ï¸ buildTagFilters - context:', context, 'isDevMode:', isDevMode, 'body class:', document.body.className);
      // console.log('ğŸ·ï¸ Available tags:', availableTags.length, 'Active tags:', activeTags.length);
      
      if (context === 'objet' && !isDevMode) {
        // console.log('ğŸš« Hiding tag filters for objects in dev mode OFF');
        return ''; // Hide tag filters in normal mode
      }
      
      // console.log('âœ… Showing tag filters for objects in dev mode ON');
      
      const isIdSearchActive = window.activeIdSearch || false;
      const containerOpacity = isIdSearchActive ? '0.4' : '1';
      const containerFilter = isIdSearchActive ? 'grayscale(1)' : 'none';
      const pointerEvents = isIdSearchActive ? 'none' : 'auto';
      
      // Afficher TOUS les tags disponibles, avec ceux actifs en vert
      const allFilterChips = availableTags.map(tag => {
        const isActive = activeTags.includes(tag);
        const bgColor = isActive ? '#16a34a' : '#6b7280'; // Vert pour actif, gris pour inactif
        const textColor = 'white';
        const opacity = isActive ? '1' : '0.6';
        
        return `<button class="filter-chip ${isActive ? 'active' : 'inactive'}" 
                        data-tag="${tag}" 
                        style="background: ${bgColor}; color: ${textColor}; opacity: ${opacity}; 
                               padding: 8px 16px; border-radius: 20px; font-size: 0.9em; font-weight: 500;
                               cursor: pointer; transition: all 0.2s ease; border: none;
                               margin: 2px; ${isActive ? 'box-shadow: 0 2px 4px rgba(22, 163, 74, 0.3);' : ''}"
                        title="${isActive ? 'Actif - Cliquer pour dÃ©sactiver' : 'Inactif - Cliquer pour activer'}">
                    ${isActive ? 'âœ“ ' : ''}${tag}
                </button>`;
      }).join('');
      
      // Supprimer les boutons Tous/Aucun - les utilisateurs cliquent directement sur les tags
      
      return `
        <div class="objects-tag-display" style="margin: 1rem 0; padding: 1rem; background: var(--card); border: 2px solid var(--rule); border-radius: 12px; opacity: ${containerOpacity}; filter: ${containerFilter}; pointer-events: ${pointerEvents}; transition: all 0.3s ease;">
          <h3 style="margin: 0 0 1rem 0; text-align: center; color: var(--accent-ink);">ğŸ” Filtres par tag (ET)</h3>
          <p style="text-align: center; color: var(--paper-muted); font-size: 0.9em; margin: 0 0 1rem 0;">
            ${activeTags.length === 0 
              ? 'Aucun filtre actif - Tous les objets affichÃ©s' 
              : activeTags.length === 1 
                ? '1 filtre actif - Objets avec ce tag uniquement'
                : `${activeTags.length} filtres actifs - Objets avec TOUS ces tags`}
          </p>
          <div class="filter-chips" style="display: flex; gap: 0.5rem; flex-wrap: wrap; justify-content: center;">
            ${allFilterChips}
          </div>
        </div>
      `;
    }
    
    // SUPPRIMÃ‰: buildFilterManagerButton - fonctionnalitÃ© retirÃ©e

    buildTagsManagerButton() {
      // Only show in dev mode - use direct utils check
      if (!JdrApp.utils.isDevMode()) {
        return '';
      }
      return `<button class="tags-manager-btn btn" type="button" style="background: #dc2626; color: white; border: 2px solid #b91c1c;">ğŸ·ï¸ GÃ©rer les tags</button>`;
    }

    buildGeneralDonsSection(type, categoryName) {
      // Only add General Dons section for 'don' type pages, and not for the 'Generaux' category itself
      if (type !== 'don' || categoryName === 'Generaux') {
        return '';
      }

      // Find the "Generaux" category in the DONS data
      const generalCategory = window.DONS?.find(cat => cat.nom === 'Generaux');
      if (!generalCategory || !generalCategory.dons || generalCategory.dons.length === 0) {
        return '';
      }

      // Generate cards for all general dons
      const generalDonsCards = generalCategory.dons.map((don, index) => 
        CardBuilder.create('don', don, 'Generaux', index).build()
      ).join('');

      return `
        <div style="margin-top: 2rem; padding-top: 1.5rem; border-top: 2px solid var(--rule);">
          <h3 style="color: var(--bronze); margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
            ğŸ–ï¸ Dons GÃ©nÃ©raux
          </h3>
          <p style="margin-bottom: 1.5rem; font-style: italic; color: var(--accent-ink); opacity: 0.8;">
            Ces dons sont accessibles Ã  toutes les classes et peuvent complÃ©ter votre build.
          </p>
          <div class="grid cols-2">
            ${generalDonsCards}
          </div>
        </div>
      `;
    }

    // SUPPRIMÃ‰: buildFilterManagerButton - fonctionnalitÃ© retirÃ©e
    
    buildTagsManagerButton() {
      // ALWAYS generate the button - CSS will control visibility based on body.dev-on/dev-off  
      if (window.STANDALONE_VERSION) return '';
      
      return `<button class="tags-manager-btn btn" type="button" style="background: #dc2626; color: white; border: 2px solid #b91c1c;">ğŸ·ï¸ GÃ©rer les tags</button>`;
    }

    buildPrintButton() {
      return `
        <div style="margin-top: 1rem;">
          <button id="print-etats-btn" class="print-button" type="button" title="Imprimer la liste des Ã©tats">
            ğŸ–¨ï¸ Version imprimable
          </button>
        </div>
      `;
    }

    buildSingleTableTresorPage(tableData) {
      let config = window.ContentTypes?.['tableTresor'];
      const allTables = tableData.tables || [];
      const instance = PageBuilder.getInstance();
      
      // Defensive check for config with fallback
      if (!config || !config.filterConfig) {
        console.warn('TableTresor config not loaded, using fallback defaults');
        config = {
          filterConfig: {
            defaultVisibleTags: ['Commun'],
            availableTags: ['Faible', 'Commun', 'Rare', 'Ã‰pique', 'LÃ©gendaire', 'Boss', 'HumanoÃ¯de', 'BÃªte', 'Dragon', 'Mort-vivant', 'Ã‰lÃ©mentaire']
          }
        };
      }
      
      // Priority: Use saved metadata tags as single source of truth
      let availableTags = window.TABLES_TRESORS?._metadata?.availableTags || [];
      
      // Utiliser le state du filtre s'il existe, sinon les tags par dÃ©faut qui existent vraiment
      let defaultVisibleTags = config.filterConfig.defaultVisibleTags || [];
      // Filter defaultVisibleTags to only include tags that actually exist in metadata
      if (availableTags.length > 0) {
        defaultVisibleTags = defaultVisibleTags.filter(tag => availableTags.includes(tag));
      }
      const visibleTags = window.TABLES_TRESORS_FILTER_STATE?.visibleTags || defaultVisibleTags;
      
      
      // Filter tables according to visible tags
      const filterMode = config.filterMode || 'OR';
      const filteredTables = visibleTags.length === 0 
        ? allTables // If no tags are visible, show all tables
        : allTables.filter(table => {
            // Check that the table has tags when filtering is active
            if (!table.tags || table.tags.length === 0) return false;
            
            if (filterMode === 'AND') {
              // In AND mode: table must have ALL visible tags
              return visibleTags.every(tag => table.tags.includes(tag));
            } else {
              // In OR mode: table must have AT LEAST ONE visible tag
              return visibleTags.some(tag => table.tags.includes(tag));
            }
          });
          
      
      return `
        <article class="" data-page="tables-tresors">
          <section>
            <header class="page-header">
              <h1 class="page-title" style="display: flex; align-items: center; gap: 0.5rem;">
                ğŸ’ Tables de trÃ©sors
              </h1>
            </header>
            
            ${instance.buildPageDescription('tableTresor')}
            
            ${instance.buildTagFilters(visibleTags, availableTags, 'tableTresor')}
            
            <div data-dev-only class="dev-buttons-container">
              ${instance.buildAddButton('tableTresor', 'tables')}
              ${instance.buildTagsManagerButton()}
            </div>
            </div>
            
            <div class="grid cols-1" id="tables-tresors-container" style="gap: 1.5rem;">
              ${filteredTables.map((table, index) => 
                CardBuilder.create('tableTresor', table, 'tables', index).build()
              ).join('')}
            </div>
            
            ${filteredTables.length === 0 ? `
              <div style="text-align: center; padding: 2rem; background: var(--card); border-radius: 12px; margin: 1rem 0;">
                <p style="color: var(--accent-ink); font-size: 1.1em; margin-bottom: 1rem;">
                  ğŸ’ ${allTables.length === 0 ? 'Aucune table de trÃ©sor dÃ©finie' : 'Aucune table ne correspond aux filtres sÃ©lectionnÃ©s'}
                </p>
                <p style="color: var(--paper-muted); font-style: italic;">
                  ${allTables.length === 0 
                    ? (instance.shouldShowEditButtons ? 'Utilisez le bouton "Ajouter une table de trÃ©sor" ci-dessus pour crÃ©er votre premiÃ¨re table.' : 'Le MaÃ®tre de jeu peut crÃ©er des tables de trÃ©sors en mode dÃ©veloppement.')
                    : 'Modifiez vos filtres pour voir d\'autres tables de trÃ©sors.'
                  }
                </p>
              </div>
            ` : ''}
            
            <div style="margin-top: 1rem; padding: 1rem; background: var(--card); border-radius: 8px; border-left: 4px solid var(--bronze);">
              <p style="color: var(--accent-ink); margin: 0;">
                ğŸ“Š RÃ©sultats: ${filteredTables.length} table${filteredTables.length !== 1 ? 's' : ''} affichÃ©e${filteredTables.length !== 1 ? 's' : ''} sur ${allTables.length} au total
              </p>
            </div>
          </section>
        </article>
      `;
    }

    buildCampaignPage(pageId, pageData) {
      const campaigns = pageData.subPages || {};
      const campaignList = Object.keys(campaigns);
      
      // Get current selections (default to first available or empty)
      const selectedCampaign = window.JdrApp?.state?.selectedCampaign || (campaignList.length > 0 ? campaignList[0] : null);
      const currentCampaign = selectedCampaign && campaigns[selectedCampaign] ? campaigns[selectedCampaign] : null;
      const subPageList = currentCampaign ? Object.keys(currentCampaign.subPages || {}) : [];
      const selectedSubPage = window.JdrApp?.state?.selectedSubPage || (subPageList.length > 0 ? subPageList[0] : null);
      const currentSubPage = selectedSubPage && currentCampaign?.subPages?.[selectedSubPage] ? currentCampaign.subPages[selectedSubPage] : null;
      
      return `
        <article class="" data-page="${pageId}" data-static-page="true" data-page-title="${pageData.title}">
          <section>
            ${pageId === 'campagne' ? this.buildCompactCampaignHeader(pageData) : this.buildStaticPageHeader(pageData)}
            ${pageId === 'campagne' ? '' : this.buildSections(pageData.sections)}
            
            <div class="campaign-manager" style="margin-top: 0.5rem;">
              <!-- Campaign Management Controls -->
              <div class="campaign-controls" style="background: var(--card); border-radius: 12px; padding: 1rem; margin-bottom: 0.5rem;">
                <div style="display: flex; justify-content: center; align-items: center; margin-bottom: 0.5rem;">
                  <div class="dev-buttons" style="display: flex; gap: 8px;">
                    <button class="btn primary small dev-only" onclick="JdrApp.modules.ui.addCampaign()" style="display: none;">
                      â• Nouvelle Campagne
                    </button>
                  </div>
                </div>
                
                ${campaignList.length === 0 ? `
                  <div style="text-align: center; padding: 2rem;">
                    <p style="color: var(--accent-ink); font-size: 1.1em; margin-bottom: 1rem;">
                      ğŸ“– Aucune campagne crÃ©Ã©e
                    </p>
                    <p style="color: var(--paper-muted); font-style: italic;">
                      <span class="dev-only" style="display: none;">Utilisez le bouton "Nouvelle Campagne" ci-dessus pour crÃ©er votre premiÃ¨re campagne.</span>
                      <span class="non-dev-only">Le MaÃ®tre de jeu peut crÃ©er des campagnes en mode dÃ©veloppement.</span>
                    </p>
                  </div>
                ` : `
                  <!-- Campaign Selector -->
                  <div class="campaign-selector" style="margin-bottom: 0.5rem; text-align: center;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--accent-ink); text-align: center;">
                      ğŸ“š Campagne Active:
                    </label>
                    <div style="display: inline-flex; align-items: center; gap: 8px;">
                      <select id="campaignSelector" onchange="JdrApp.modules.ui.selectCampaign(this.value)" 
                              style="padding: 8px; border-radius: 6px; border: 2px solid var(--rule); background: var(--paper); font-family: inherit;">
                        ${campaignList.map(name => 
                          `<option value="${name}" ${name === selectedCampaign ? 'selected' : ''}>${name}</option>`
                        ).join('')}
                      </select>
                      <button class="btn danger small dev-only" onclick="JdrApp.modules.ui.deleteCampaign('${selectedCampaign}')" 
                              style="display: none;" ${!selectedCampaign ? 'disabled' : ''}>
                        ğŸ—‘ï¸ Supprimer
                      </button>
                    </div>
                  </div>
                `}
              </div>
              <!-- Campaign Content -->
              ${selectedCampaign && currentCampaign ? this.buildSelectedCampaignContent(selectedCampaign, currentCampaign, selectedSubPage, currentSubPage) : ''}
            </div>
            
            ${this.buildAddSectionButton()}
          </section>
        </article>
      `;
    }

    buildSelectedCampaignContent(campaignName, campaign, selectedSubPage, currentSubPage) {
      const subPageList = campaign.subPages ? Object.keys(campaign.subPages) : [];
      
      return `
        <div class="selected-campaign" style="background: var(--card); border-radius: 12px; padding: 1.5rem; border-left: 4px solid var(--bronze);">
          <!-- Campaign Header -->
          <div class="campaign-header" style="margin-bottom: 1.5rem; border-bottom: 2px solid var(--rule); padding-bottom: 1rem;">
            <div style="display: flex; align-items: center; margin-bottom: 0.5rem;">
              <h3 class="editable" data-edit-type="generic" data-edit-section="campaign-${campaignName}-name" 
                  style="margin: 0; color: var(--accent-ink); flex: 1;">
                ${campaignName}
              </h3>
              ${this.buildEditButton('title')}
            </div>
            <div style="display: flex; align-items: flex-start;">
              <p class="editable" data-edit-type="generic" data-edit-section="campaign-${campaignName}-description" 
                 style="color: var(--paper-muted); margin: 0; font-style: italic; flex: 1;">
                ${campaign.description || 'Description de la campagne'}
              </p>
              ${this.buildEditButton('section')}
            </div>
          </div>
          
          <!-- Sub-pages Section -->
          <div class="campaign-subpages">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
              <h4 style="margin: 0; color: var(--accent-ink);">ğŸ“„ Sous-pages de la campagne (${subPageList.length})</h4>
              <button class="btn primary small dev-only" onclick="JdrApp.modules.ui.addCampaignSubPage('${campaignName}')" style="display: none;">
                â• Nouvelle Sous-page
              </button>
            </div>
            
            ${subPageList.length === 0 ? `
              <div style="text-align: center; padding: 2rem; background: var(--paper-light); border-radius: 8px; margin-bottom: 1rem;">
                <p style="color: var(--paper-muted); font-style: italic;">
                  Aucune sous-page crÃ©Ã©e pour cette campagne.
                </p>
                <p class="dev-only" style="color: var(--paper-muted); font-size: 0.9em; display: none;">
                  Utilisez le bouton "Nouvelle Sous-page" pour commencer.
                </p>
              </div>
            ` : `
              <!-- Sub-page Selector -->
              <div class="subpage-selector" style="margin-bottom: 1.5rem;">
                <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; color: var(--accent-ink);">
                  ğŸ“ Sous-page Active:
                </label>
                <select id="subPageSelector" onchange="JdrApp.modules.ui.selectSubPage(this.value)" 
                        style="padding: 8px; border-radius: 6px; border: 2px solid var(--rule); background: var(--paper); font-family: inherit;">
                  ${subPageList.map(name => 
                    `<option value="${name}" ${name === selectedSubPage ? 'selected' : ''}>${name}</option>`
                  ).join('')}
                </select>
                <button class="btn danger small dev-only" onclick="JdrApp.modules.ui.deleteCampaignSubPage('${campaignName}', '${selectedSubPage}')" 
                        style="margin-left: 8px; display: none;" ${!selectedSubPage ? 'disabled' : ''}>
                  ğŸ—‘ï¸ Supprimer
                </button>
              </div>
              
              <!-- Sub-page Content -->
              ${selectedSubPage && currentSubPage ? this.buildSelectedSubPageContent(campaignName, selectedSubPage, currentSubPage) : ''}
            `}
          </div>
        </div>
      `;
    }

    buildSelectedSubPageContent(campaignName, subPageName, subPage) {
      return `
        <div class="selected-subpage" style="background: var(--paper-light); border-radius: 8px; padding: 1.5rem; border: 2px solid var(--rule);">
          <!-- Sub-page Header -->
          <div class="subpage-header" style="margin-bottom: 1rem; border-bottom: 1px solid var(--rule); padding-bottom: 0.75rem;">
            <div style="display: flex; align-items: center;">
              <h5 class="editable" data-edit-type="generic" data-edit-section="subpage-${campaignName}-${subPageName}-title" 
                  style="margin: 0; color: var(--accent-ink); font-size: 1.2em; flex: 1;">
                ğŸ“„ ${subPage.title || subPageName}
              </h5>
              ${this.buildEditButton('title')}
            </div>
          </div>
          
          <!-- Sub-page Content -->
          <div style="display: flex; align-items: flex-start;">
            <div class="subpage-content editable" data-edit-type="generic" data-edit-section="subpage-${campaignName}-${subPageName}-content" 
                 style="line-height: 1.6; min-height: 200px; flex: 1;">
              ${subPage.content || '<p>Contenu de la sous-page...</p>'}
            </div>
            ${this.buildEditButton('section')}
          </div>
        </div>
      `;
    }

    buildEditButton(buttonType) {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="edit-btn" type="button" style="background: var(--accent); color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 12px; margin-left: 8px;">âœï¸</button>`;
    }
    

    sanitizeId(str) {
      return str.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    }
  }

  window.PageBuilder = PageBuilder.getInstance();

})();
// ============================================================================
// JDR-BAB APPLICATION - UTILITIES MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // DEV MODE UTILITIES
  // ========================================
  JdrApp.utils.isDevMode = function() {
    // Simple check - if it's standalone, dev mode is always false
    if (window.STANDALONE_VERSION) return false;
    
    // Use the editor's actual state instead of CSS classes for reliability
    if (JdrApp.modules && JdrApp.modules.editor) {
      return JdrApp.modules.editor.isDevMode;
    }
    
    // Fallback: check body class if editor not available yet
    return document.body.classList.contains('dev-on');
  };

  // ========================================
  // CENTRALIZED EVENT MANAGEMENT
  // ========================================
  JdrApp.utils.events = {
    listeners: new Map(),
    
    // Centralized event registration
    register(type, selector, handler, options = {}) {
      const key = `${type}-${selector || 'window'}-${Date.now()}`;
      const wrapper = (e) => {
        if (!selector) {
          handler(e);
        } else {
          // GÃ©rer les sÃ©lecteurs spÃ©ciaux comme [class$="-add"]
          if (this.matchesSelector(e.target, selector)) {
            handler(e);
          }
        }
      };
      
      if (selector) {
        document.addEventListener(type, wrapper, options);
      } else {
        window.addEventListener(type, wrapper, options);
      }
      
      this.listeners.set(key, { type, wrapper, options });
      return key;
    },

    // Helper pour matcher les sÃ©lecteurs complexes
    matchesSelector(element, selector) {
      // GÃ©rer les sÃ©lecteurs d'attributs comme [class$="-add"]
      if (selector.startsWith('[class$="') && selector.endsWith('"]')) {
        const suffix = selector.slice(9, -2); // Extraire "-add" de '[class$="-add"]'
        return element.className && element.className.split(' ').some(cls => cls.endsWith(suffix));
      }
      
      // GÃ©rer les sÃ©lecteurs d'attributs comme [class*="something"]
      if (selector.startsWith('[class*="') && selector.endsWith('"]')) {
        const substring = selector.slice(9, -2); // Extraire "something" 
        return element.className && element.className.includes(substring);
      }
      
      // Utiliser la mÃ©thode native pour les autres sÃ©lecteurs
      try {
        return element.matches(selector) || element.closest(selector);
      } catch (e) {
        // Fallback pour les sÃ©lecteurs invalides
        return false;
      }
    },
    
    // Delayed execution manager
    delayed: new Map(),
    timeout(key, fn, delay = 0) {
      if (this.delayed.has(key)) {
        clearTimeout(this.delayed.get(key));
      }
      const id = setTimeout(() => {
        fn();
        this.delayed.delete(key);
      }, delay);
      this.delayed.set(key, id);
    },
    
    // Common event handlers
    onDOMReady(fn) {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', fn);
      } else {
        fn();
      }
    },
    
    onHashChange(fn) {
      window.addEventListener('hashchange', fn);
    },
    
    onRouteChange(fn) {
      this.onHashChange(() => this.timeout('route-change', fn, 0));
      this.onDOMReady(() => this.timeout('dom-ready-route', fn, 0));
    }
  };

  // ========================================
  // DOM UTILITIES LIBRARY
  // ========================================
  JdrApp.utils.dom = {
    // Common selectors
    $(selector) { return document.querySelector(selector); },
    $(selector) { return document.querySelectorAll(selector); },
    
    // Element creation with common patterns
    create(tag, className = '', innerHTML = '', attributes = {}) {
      const el = document.createElement(tag);
      if (className) el.className = className;
      if (innerHTML) el.innerHTML = innerHTML;
      Object.entries(attributes).forEach(([key, value]) => {
        el.setAttribute(key, value);
      });
      return el;
    },
    
    
    // Safe innerHTML replacement
    safeSetHTML(element, html) {
      if (element) {
        element.innerHTML = html;
      }
    },
    
    // Safe text content setting
    safeSetText(element, text) {
      if (element) {
        element.textContent = text;
      }
    },
    
    // Toggle class utility
    toggleClass(element, className, force = null) {
      if (element) {
        if (force !== null) {
          element.classList.toggle(className, force);
        } else {
          element.classList.toggle(className);
        }
      }
    },
    
    // Show/hide utilities
    show(element, display = 'block') {
      if (element) {
        element.style.display = display;
      }
    },
    
    hide(element) {
      if (element) {
        element.style.display = 'none';
      }
    }
  };

  // ========================================
  // DATA UTILITIES
  // ========================================
  JdrApp.utils.data = {
    // Find spell by name across all categories
    findSpell(name) {
      if (!window.SORTS) return null;
      
      for (const category of window.SORTS) {
        const spell = category.sorts.find(s => s.nom === name);
        if (spell) return { spell, category: category.nom };
      }
      return null;
    },
    
    // Find class by name
    findClass(name) {
      if (!window.CLASSES) return null;
      return window.CLASSES.find(c => c.nom === name);
    },
    
    // Find don by name across all categories
    findDon(name) {
      if (!window.DONS) return null;
      
      for (const category of window.DONS) {
        const don = category.dons.find(d => d.nom === name);
        if (don) return { don, category: category.nom };
      }
      return null;
    },
    
    // Get spell category by name
    getSpellCategory(categoryName) {
      if (!window.SORTS) return null;
      return window.SORTS.find(cat => cat.nom === categoryName);
    },
    
    // Get don category by name
    getDonCategory(categoryName) {
      if (!window.DONS) return null;
      return window.DONS.find(cat => cat.nom === categoryName);
    },
    
    // Deep clone object
    deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    },
    
    // Sanitize string for use as identifier
    sanitizeId(str) {
      return str.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    },
    
    // Generate unique ID
    generateId(prefix = 'id') {
      return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    },
    
    // Escape HTML
    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  };

  // ========================================
  // IMAGE UTILITIES
  // ========================================
  
  // Compress image function
  JdrApp.utils.compressImage = function(file, maxWidth = 800, quality = 0.85) {
    return new Promise((resolve, reject) => {
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      img.onload = function() {
        // Calculate new dimensions
        let { width, height } = img;
        
        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }
        
        // Set canvas size
        canvas.width = width;
        canvas.height = height;
        
        // Detect if image has transparency (PNG)
        const isPNG = file.type === 'image/png' || file.name.toLowerCase().endsWith('.png');
        
        if (isPNG) {
          // For PNG, don't compress at all to preserve quality
          resolve(file);
        } else {
          // For JPEG/other formats, use white background
          ctx.fillStyle = '#FFFFFF';
          ctx.fillRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);
          
          canvas.toBlob((blob) => {
            resolve(blob);
          }, 'image/jpeg', quality);
        }
      };
      
      img.onerror = (error) => {
        reject(error);
      };
      
      img.src = URL.createObjectURL(file);
    });
  };

  // Upload to ImageBB function
  JdrApp.utils.uploadToImageBB = function(file) {
    return new Promise((resolve, reject) => {
      // ImageBB API key
      const API_KEY = '06a98f5c0c2dad952e6ab94b03040f36';
      
      const formData = new FormData();
      formData.append('image', file);
      
      fetch(`https://api.imgbb.com/1/upload?key=${API_KEY}`, {
        method: 'POST',
        body: formData
      })
      .then(response => {
        return response.json();
      })
      .then(data => {
        if (data.success) {
          resolve(data.data.url);
        } else {
          throw new Error('Upload failed: ' + (data.error ? data.error.message : 'Unknown error'));
        }
      })
      .catch(error => {
        // Fallback to local storage
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    });
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - IMAGES MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // IMAGES MANAGEMENT MODULE
  // ========================================
  JdrApp.modules.images = {
    // Store for preloaded images
    imageStore: {},
    
    async init() {
      await this.loadImageData();
      this.initImageHandlers();
      
      // Auto-sync monster images on startup to ensure consistency
      setTimeout(() => {
        this.ensureMonsterImageMappings();
      }, 1000);
    },

    // Load image data from JSON file or embedded data
    async loadImageData() {
      try {
        if (window.IMAGES) {
          this.imageStore = window.IMAGES.images || window.IMAGES || {};
          return;
        }
        
        const response = await fetch('./data/images.json');
        if (response.ok) {
          const data = await response.json();
          this.imageStore = data.images || {};
        } else {
          this.imageStore = {};
        }
      } catch (error) {
        this.imageStore = {};
      }
    },

    // Get image URL for a given key
    getImageUrl(illusKey) {
      return this.imageStore[illusKey] || null;
    },

    // Apply image to an illustration element
    applyImage(illusElement, imageUrl) {
      if (!illusElement || !imageUrl) return;

      const img = illusElement.querySelector('img.thumb');
      if (!img) return;

      // Set image source and make it visible
      img.src = this.processImageUrl(imageUrl);
      img.style.display = 'inline-block';
      img.style.opacity = '1'; // Reset opacity after upload
      
      // Show remove button if it exists
      const removeBtn = illusElement.querySelector('.rm');
      if (removeBtn) {
        removeBtn.style.display = 'inline-flex';
      }

    },

    // Process image URL to handle proxying for mobile compatibility
    processImageUrl(originalUrl) {
      // If it's an i.ibb.co URL, use proxy for better mobile compatibility
      if (originalUrl.includes('i.ibb.co') && !originalUrl.includes('images.weserv.nl')) {
        return `https://images.weserv.nl/?url=${encodeURIComponent(originalUrl)}`;
      }
      
      // For local monster paths, encode only the filename to handle French characters properly
      if (originalUrl.startsWith('data/images/Monstres/')) {
        const pathParts = originalUrl.split('/');
        const filename = pathParts[pathParts.length - 1];
        const pathWithoutFilename = pathParts.slice(0, -1).join('/');
        return `${pathWithoutFilename}/${encodeURIComponent(filename)}`;
      }
      
      return originalUrl;
    },

    autoLoadImages() {
      const illusElements = document.querySelectorAll('[data-illus-key]');
      let loadedCount = 0;

      illusElements.forEach(illusElement => {
        const illusKey = illusElement.dataset.illusKey;
        const imageUrl = this.getImageUrl(illusKey);
        
        if (imageUrl) {
          this.applyImage(illusElement, imageUrl);
          loadedCount++;
        }
      });

      return loadedCount;
    },

    // Initialize image upload handlers
    initImageHandlers() {
      // Delegate image upload handling
      document.addEventListener('change', (event) => {
        if (event.target.matches('.illus input[type="file"]')) {
          this.handleImageUpload(event.target);
        }
      });

      // Delegate image removal handling  
      document.addEventListener('click', (event) => {
        if (event.target.matches('.illus .rm')) {
          this.handleImageRemoval(event.target);
        }
      });
    },

    // Handle image upload
    async handleImageUpload(fileInput) {
      const file = fileInput.files[0];
      if (!file) return;

      const illusElement = fileInput.closest('.illus');
      if (!illusElement) return;

      const illusKey = illusElement.dataset.illusKey;
      
      try {
        // Show loading state
        const img = illusElement.querySelector('img.thumb');
        if (img) {
          img.style.opacity = '0.5';
        }

        // Compress and upload image
        const compressedFile = await JdrApp.utils.compressImage(file, 800, 0.8);
        const imageUrl = await JdrApp.utils.uploadToImageBB(compressedFile);
        
        // Apply the uploaded image
        this.applyImage(illusElement, imageUrl);
        
        // Update local store
        this.imageStore[illusKey] = imageUrl;
        
        // Auto-sync to prevent loss of image assignments
        this.autoSyncImages();
        
        
      } catch (error) {
        // Reset loading state
        const img = illusElement.querySelector('img.thumb');
        if (img) {
          img.style.opacity = '1';
        }
        
        alert('Erreur lors du tÃ©lÃ©chargement de l\'image. Veuillez rÃ©essayer.');
      }
      
      // Clear file input
      fileInput.value = '';
    },

    // Handle image removal
    handleImageRemoval(removeBtn) {
      const illusElement = removeBtn.closest('.illus');
      if (!illusElement) return;

      const illusKey = illusElement.dataset.illusKey;
      const img = illusElement.querySelector('img.thumb');
      
      if (img) {
        img.src = '';
        img.style.display = 'none';
      }
      
      removeBtn.style.display = 'none';
      
      // Remove from store
      delete this.imageStore[illusKey];
      
      // Auto-sync to update persistent storage
      this.autoSyncImages();
    },

    // Manually add/update an image
    setImage(illusKey, imageUrl) {
      this.imageStore[illusKey] = imageUrl;
      
      // Apply to any existing elements with this key
      const illusElements = document.querySelectorAll(`[data-illus-key="${illusKey}"]`);
      illusElements.forEach(element => {
        this.applyImage(element, imageUrl);
      });
      
      // Auto-sync to prevent loss
      this.autoSyncImages();
    },

    // Get all current images for export
    getAllImages() {
      return { ...this.imageStore };
    },

    // Import images from external data
    importImages(imageData) {
      if (typeof imageData === 'object' && imageData !== null) {
        Object.assign(this.imageStore, imageData);
        this.autoLoadImages();
      }
    },

    // Auto-sync images to prevent data loss
    autoSyncImages() {
      // Ensure we have monster image mappings for all existing monsters
      this.ensureMonsterImageMappings();
      
      // Trigger auto-save if available
      if (JdrApp.modules.storage && JdrApp.modules.storage.saveChanges) {
        JdrApp.modules.storage.saveChanges(true); // Silent save
      }
    },

    // Ensure all monsters have image mappings in images.json structure
    ensureMonsterImageMappings() {
      if (!window.MONSTRES || !Array.isArray(window.MONSTRES)) {
        return;
      }

      let hasUpdates = false;

      window.MONSTRES.forEach(monster => {
        const imageKey = `monster:${monster.nom}`;
        
        // If monster has no image mapping in store, create one
        if (!this.imageStore[imageKey]) {
          // Check if monster has a valid image path
          if (monster.image && monster.image.trim()) {
            this.imageStore[imageKey] = monster.image;
            hasUpdates = true;
            console.log(`ğŸ“· Auto-synced image for monster: ${monster.nom}`);
          }
        }
        
        // Also validate that the image file exists
        this.validateMonsterImagePath(monster);
      });

      if (hasUpdates) {
        console.log('âœ… Auto-synced monster image mappings');
      }
    },

    // Validate and fix monster image paths
    validateMonsterImagePath(monster) {
      if (!monster.image || !monster.nom) {
        return false;
      }

      // Extract filename from current path
      const currentPath = monster.image;
      const filename = currentPath.split('/').pop();
      
      // Check if path follows correct format
      const expectedPattern = /^data\/images\/Monstres\/foret\/Monstre_ForÃªt_\w+\.png$/;
      
      if (!expectedPattern.test(currentPath)) {
        // Try to fix common issues
        let correctedPath = null;
        
        // Map common filename patterns to correct paths
        const filenameMap = {
          'araignee-geante.png': 'Monstre_ForÃªt_AraignÃ©e.png',
          'crabe-des-bois.png': 'Monstre_ForÃªt_Crab.png',  
          'groink.png': 'Monstre_ForÃªt_Groink.png',
          'groink-chaman.png': 'Monstre_ForÃªt_Groink_Chaman.png',
          'guepe-geante.png': 'Monstre_ForÃªt_GuepeGeante.png',
          'ours-des-bois.png': 'Monstre_ForÃªt_Ours.png'
        };

        if (filenameMap[filename]) {
          correctedPath = `data/images/Monstres/foret/${filenameMap[filename]}`;
        } else if (!filename.startsWith('Monstre_ForÃªt_')) {
          // Try to construct path from monster name
          const safeName = monster.nom.replace(/[^a-zA-Z0-9Ã Ã¢Ã¤Ã©Ã¨ÃªÃ«Ã¯Ã®Ã´Ã¹Ã»Ã¼Ã¿Ã§Ã€Ã‚Ã„Ã‰ÃˆÃŠÃ‹ÃÃÃ”Ã™Ã›ÃœÅ¸Ã‡_]/g, '');
          correctedPath = `data/images/Monstres/foret/Monstre_ForÃªt_${safeName}.png`;
        }

        if (correctedPath && correctedPath !== currentPath) {
          console.log(`ğŸ”§ Auto-correcting image path for ${monster.nom}:`);
          console.log(`   From: ${currentPath}`);
          console.log(`   To: ${correctedPath}`);
          
          // Update monster data
          monster.image = correctedPath;
          
          // Update image mapping
          const imageKey = `monster:${monster.nom}`;
          this.imageStore[imageKey] = correctedPath;
          
          return true;
        }
      }
      
      return false;
    },

    // Force synchronization of all monster data
    forceSyncMonsterImages() {
      
      let syncCount = 0;
      
      if (window.MONSTRES && Array.isArray(window.MONSTRES)) {
        window.MONSTRES.forEach(monster => {
          const corrected = this.validateMonsterImagePath(monster);
          if (corrected) {
            syncCount++;
          }
        });
      }
      
      this.ensureMonsterImageMappings();
      
      
      // Save changes
      if (JdrApp.modules.storage && JdrApp.modules.storage.saveChanges) {
        JdrApp.modules.storage.saveChanges(true);
      }
      
      return syncCount;
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - STORAGE MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // STORAGE MODULE
  // ========================================
  JdrApp.modules.storage = {
    
    init() {
      
      // Clear localStorage on startup - JSON files are always source of truth
      this.clearStorageOnStartup();
      
      // Set up save handlers
      JdrApp.utils.events.register('click', '#saveAndExport', () => this.saveAndExportZip());
      
      // Listen for storage save events
      EventBus.on(Events.STORAGE_SAVE, () => {
        this.saveChanges(true); // Silent save
      });
      
      // Auto-save functionality
      this.setupAutoSave();
    },

    setupAutoSave() {
      // Auto-save disabled - we save immediately on each edit instead
      // Previously: Auto-save every 30 seconds if in dev mode
    },

    clearStorageOnStartup() {
      // Clear all localStorage data on page load - JSON files are source of truth
      localStorage.removeItem('jdr-bab-edits');
      localStorage.removeItem('jdr-bab-static-pages');
      localStorage.removeItem('jdr-bab-last-modified');
    },

    saveChanges(silent = false) {
      try {
        // Force collect all pending edits
        const editedData = JdrApp.modules.editor ? JdrApp.modules.editor.forceCollectAllEdits() : {};
        
        // Data is already saved in memory (window.STATIC_PAGES, window.SORTS, etc.)
        // No localStorage persistence needed - JSON files are source of truth
        
        if (!silent) {
          this.showNotification('ğŸ’¾ Modifications sauvegardÃ©es en mÃ©moire', 'success');
        }
        
      } catch (error) {
        console.error('âŒ Failed to save changes:', error);
        if (!silent) {
          this.showNotification('âŒ Erreur lors de la sauvegarde', 'error');
        }
      }
    },

    async saveAndExportZip() {
      try {
        this.showNotification('ğŸ“¦ CrÃ©ation de l\'archive ZIP...', 'info');
        
        // Force collect all pending edits
        JdrApp.modules.editor.forceCollectAllEdits();
        
        // Check if JSZip is available
        if (typeof JSZip === 'undefined') {
          await this.loadJSZip();
        }
        
        const zip = new JSZip();
        
        // Add main HTML file
        const mainHTML = await this.getMainHTML();
        zip.file('index.html', mainHTML);
        
        // Add CSS files
        const cssFiles = ['theme.css', 'utilities.css', 'components.css', 'layout.css', 'editor.css'];
        for (const cssFile of cssFiles) {
          const cssContent = await this.fetchFileContent(`css/${cssFile}`);
          if (cssContent) {
            zip.file(`css/${cssFile}`, cssContent);
          }
        }
        
        // Add JS files
        const jsFiles = ['core.js', 'utils.js', 'router.js', 'renderer.js', 'editor.js', 'storage.js', 'ui.js'];
        for (const jsFile of jsFiles) {
          const jsContent = await this.fetchFileContent(`js/${jsFile}`);
          if (jsContent) {
            zip.file(`js/${jsFile}`, jsContent);
          }
        }
        
        // Add modules
        const moduleFiles = ['images.js'];
        for (const moduleFile of moduleFiles) {
          const moduleContent = await this.fetchFileContent(`js/modules/${moduleFile}`);
          if (moduleContent) {
            zip.file(`js/modules/${moduleFile}`, moduleContent);
          }
        }
        
        // Add data files with current edits
        zip.file('data/sorts.json', JSON.stringify(window.SORTS, null, 2));
        zip.file('data/classes.json', JSON.stringify(window.CLASSES, null, 2));
        zip.file('data/dons.json', JSON.stringify(window.DONS, null, 2));
        zip.file('data/objets.json', JSON.stringify(window.OBJETS, null, 2));
        
        // Add monsters data with current edits
        if (window.MONSTRES) {
          zip.file('data/monstres.json', JSON.stringify(window.MONSTRES, null, 2));
        }
        
        // Add tables tresors data with current edits  
        if (window.TABLES_TRESORS) {
          zip.file('data/tables-tresors.json', JSON.stringify(window.TABLES_TRESORS, null, 2));
        }
        
        // Add collections data with current edits
        if (window.COLLECTIONS) {
          zip.file('data/collections.json', JSON.stringify(window.COLLECTIONS, null, 2));
        }
        
        // Add TOC structure with new pages
        if (window.TOC_STRUCTURE) {
          zip.file('data/toc-structure.json', JSON.stringify(window.TOC_STRUCTURE, null, 2));
        }
        
        // Add ContentTypes configuration (includes availableTags modifications)
        if (window.ContentTypes) {
          const updatedContentTypesJS = this.generateContentTypesJS(window.ContentTypes);
          zip.file('js/config/contentTypes.js', updatedContentTypesJS);
        }
        
        // Add static pages config and data
        if (window.STATIC_PAGES_CONFIG) {
          zip.file('data/static-pages-config.json', JSON.stringify(window.STATIC_PAGES_CONFIG, null, 2));
        }
        
        if (window.STATIC_PAGES) {
          for (const [pageId, pageData] of Object.entries(window.STATIC_PAGES)) {
            zip.file(`data/${pageId}.json`, JSON.stringify(pageData, null, 2));
          }
        }
        
        // Note: All static pages are now handled via window.STATIC_PAGES above
        
        // Add current images (including newly uploaded ones)
        if (JdrApp.modules.images && JdrApp.modules.images.getAllImages) {
          const currentImages = JdrApp.modules.images.getAllImages();
          const imagesData = {
            images: currentImages,
            meta: {
              total_images: Object.keys(currentImages).length,
              exported_date: new Date().toISOString().slice(0, 10),
              note: "Ces images incluent les nouvelles images uploadÃ©es"
            }
          };
          zip.file('data/images.json', JSON.stringify(imagesData, null, 2));
        }
        
        // Add page descriptions
        if (window.MONSTRES_PAGE_DESC) {
          zip.file('data/monstres-page-desc.json', JSON.stringify(window.MONSTRES_PAGE_DESC, null, 2));
        }
        
        if (window.TABLES_TRESORS_PAGE_DESC) {
          zip.file('data/tables-tresors-page-desc.json', JSON.stringify(window.TABLES_TRESORS_PAGE_DESC, null, 2));
        }
        
        // Add custom page descriptions (collections, etc.)
        if (JdrApp.data.customPageDescriptions) {
          zip.file('data/custom-page-descriptions.json', JSON.stringify(JdrApp.data.customPageDescriptions, null, 2));
        }
        
        // Add package.json and other config files
        const configFiles = ['package.json'];
        for (const configFile of configFiles) {
          const configContent = await this.fetchFileContent(configFile);
          if (configContent) {
            zip.file(configFile, configContent);
          }
        }
        
        // Generate and download ZIP
        const zipBlob = await zip.generateAsync({type: 'blob'});
        const timestamp = new Date().toISOString().slice(0, 16).replace(/[:-]/g, '');
        this.downloadFile(`JdrBab-${timestamp}.zip`, zipBlob, 'application/zip');
        
        this.showNotification('ğŸ“¦ Archive ZIP crÃ©Ã©e et tÃ©lÃ©chargÃ©e!', 'success');
        
      } catch (error) {
        console.error('âŒ Failed to create ZIP:', error);
        this.showNotification('âŒ Erreur lors de la crÃ©ation du ZIP', 'error');
      }
    },

    generateContentTypesJS(contentTypes) {
      // Generate the updated contentTypes.js file with current availableTags
      const availableTags = contentTypes.objet?.filterConfig?.availableTags || [];
      const defaultVisibleTags = contentTypes.objet?.filterConfig?.defaultVisibleTags || [];
      
      // Get monster tags configuration
      const monsterAvailableTags = contentTypes.monster?.filterConfig?.availableTags || [];
      const monsterDefaultVisibleTags = contentTypes.monster?.filterConfig?.defaultVisibleTags || [];
      
      return `// ============================================================================
// JDR-BAB APPLICATION - CONTENT TYPES CONFIGURATION
// ============================================================================

(() => {
  "use strict";

  window.ContentTypes = {
    spell: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        element: { type: 'select', label: 'Ã‰lÃ©ment', required: true, options: ['Feu', 'Eau', 'Terre', 'Air', 'LumiÃ¨re', 'Nuit', 'Divin', 'MalÃ©fique'] },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'PrÃ©requis', required: true },
        portee: { type: 'richtext', label: 'PortÃ©e', required: true },
        tempsIncantation: { type: 'richtext', label: "Temps d'incantation", required: true },
        coutMana: { type: 'richtext', label: 'CoÃ»t mana', required: true },
        resistance: { type: 'richtext', label: 'RÃ©sistance', required: true },
        effetNormal: { type: 'richtext', label: 'Effet normal', required: true },
        effetCritique: { type: 'richtext', label: 'Effet critique', required: false }
      },
      editMapping: {
        'spell-name': 'nom',
        'spell-element': 'element',
        'spell-description': 'description',
        'spell-prerequis': 'prerequis',
        'spell-portee': 'portee',
        'spell-mana': 'coutMana',
        'spell-temps-incantation': 'tempsIncantation',
        'spell-resistance': 'resistance',
        'spell-effect-normal': 'effetNormal',
        'spell-effect-critical': 'effetCritique'
      },
      identifiers: {
        name: 'nom',
        category: 'sorts'
      },
      template: 'spell-card',
      container: 'sorts',
      dataKey: 'SORTS',
      icons: { 
        category: 'ğŸ”®', 
        item: 'âœ¨',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      defaultValues: {
        nom: "Nouveau Sort",
        element: "Feu",
        description: "Lance une boule de Feu sur un adversaire.",
        prerequis: "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        portee: "ğŸ¯ <strong>PortÃ©e:</strong> 20m",
        tempsIncantation: "â° <strong>Temps d'incantation:</strong> 1 tour",
        coutMana: "ğŸ”µ <strong>CoÃ»t mana:</strong> 3",
        resistance: "<strong>Sans effet si:</strong> Esquive.",
        effetNormal: "<strong>Effet:</strong> Inflige 5 dÃ©gats de <span style='color: #e25822; font-weight: bold;'>Feu</span> Ã  la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        effetCritique: "<strong>Coup Critique:&nbsp;</strong>&nbsp;Double les dÃ©gÃ¢ts et enflamme la cible."
      }
    },

    don: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'PrÃ©requis', required: true },
        cout: { type: 'richtext', label: 'CoÃ»t', required: true }
      },
      editMapping: {
        'don-name': 'nom',
        'don-description': 'description',
        'don-prerequis': 'prerequis',
        'don-cout': 'cout'
      },
      identifiers: {
        name: 'nom',
        category: 'dons'
      },
      template: 'don-card',
      container: 'dons',
      dataKey: 'DONS',
      icons: { 
        category: 'ğŸ–ï¸', 
        item: 'ğŸ†',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      defaultValues: {
        nom: "Nouveau Don",
        description: "Description du don.",
        prerequis: "Aucun prÃ©requis",
        cout: "1 point de don"
      }
    },

    class: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        resume: { type: 'textarea', label: 'RÃ©sumÃ©', required: true },
        capacites: { type: 'list', label: 'CapacitÃ©s', required: true }
      },
      editMapping: {
        'class-name': 'nom',
        'class-resume': 'resume',
        'class-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: null
      },
      template: 'class-page',
      container: 'classes',
      dataKey: 'CLASSES',
      icons: { 
        category: 'âš”ï¸', 
        item: 'ğŸ›¡ï¸',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      }
    },

    subclass: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        base: { type: 'stats', label: 'Statistiques de base', required: true },
        progression: { type: 'richtext', label: 'Progression', required: true },
        capacites: { type: 'list', label: 'CapacitÃ©s', required: true }
      },
      editMapping: {
        'subclass-name': 'nom',
        'subclass-description': 'description',
        'subclass-stats': 'base',
        'subclass-progression': 'progression',
        'subclass-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: 'sousClasses',
        parent: 'class'
      },
      template: 'subclass-card',
      icons: { 
        item: 'âš¡',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      defaultValues: {
        nom: "Nouvelle sous-classe",
        description: "Description de la sous-classe",
        base: {
          Force: 3,
          AgilitÃ©: 3,
          Endurance: 3,
          Intelligence: 3,
          VolontÃ©: 3,
          Chance: 3
        },
        progression: "<strong>ğŸ“ˆ Progression par niveau:</strong> +1 Force ğŸ’ª, +1 AgilitÃ© ğŸƒ",
        capacites: [
          "<em>CapacitÃ© unique</em>: Description de la capacitÃ© spÃ©ciale de cette sous-classe."
        ]
      }
    },

    objet: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        numero: { type: 'number', label: 'NumÃ©ro', required: true },
        image: { type: 'text', label: 'Image', required: false },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        effet: { type: 'richtext', label: 'Effet', required: true },
        prix: { type: 'richtext', label: 'Prix', required: true },
        poids: { type: 'richtext', label: 'Poids', required: true }
      },
      editMapping: {
        'objet-name': 'nom',
        'objet-numero': 'numero',
        'objet-image': 'image',
        'objet-description': 'description',
        'objet-tags': 'tags',
        'objet-effet': 'effet',
        'objet-prix': 'prix',
        'objet-poids': 'poids'
      },
      identifiers: {
        name: 'nom',
        category: 'objets'
      },
      template: 'objet-card',
      container: 'objets',
      dataKey: 'OBJETS',
      pageType: 'single', // Page unique avec filtres
      icons: { 
        category: 'ğŸ“¦', 
        item: 'ğŸ’',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      // Configuration des filtres disponibles (MISE Ã€ JOUR AUTOMATIQUE)
      filterConfig: {
        availableTags: ${JSON.stringify(availableTags, null, 10)},
        defaultVisibleTags: ${JSON.stringify(defaultVisibleTags, null, 10)} // Filtres affichÃ©s par dÃ©faut
      },
      defaultValues: {
        nom: "Nouvel Objet",
        numero: 1,
        image: "",
        description: "Description de l'objet.",
        tags: ["Nouvel objet"],
        effet: "<strong>Effet:</strong> Description de l'effet de l'objet.",
        prix: "ğŸ”· <strong>Prix:</strong> 10",
        poids: "âš–ï¸ <strong>Poids:</strong> 1"
      }
    },

    monster: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        image: { type: 'text', label: 'Image', required: false },
        element: { 
          type: 'select', 
          label: "Ã‰lÃ©ment d'affiliation", 
          required: true,
          options: [
            { value: 'Feu', label: 'ğŸ”¥ Feu' },
            { value: 'Eau', label: 'ğŸ’§ Eau' },
            { value: 'Terre', label: 'ğŸ¤ Terre' },
            { value: 'Air', label: 'ğŸŸ¢ Air' },
            { value: 'Lumiere', label: 'â˜€ï¸ LumiÃ¨re' },
            { value: 'Nuit', label: 'âš« Nuit' },
            { value: 'Divin', label: 'âšª Divin' },
            { value: 'Malefique', label: 'ğŸŸ£ MalÃ©fique' }
          ]
        },
        pointsDeVie: { type: 'number', label: 'Points de vie', required: true },
        armurePhysique: { type: 'number', label: 'Armure physique', required: true },
        esquive: { type: 'number', label: 'Esquive', required: true },
        coupCritique: { type: 'number', label: 'Coup critique', required: true },
        coupCritiqueSorts: { type: 'number', label: 'Critique sorts', required: true },
        resistanceAlterations: { type: 'number', label: 'RÃ©sistance altÃ©rations', required: true },
        armureFeu: { type: 'number', label: 'Armure Feu', required: true },
        armureEau: { type: 'number', label: 'Armure Eau', required: true },
        armureTerre: { type: 'number', label: 'Armure Terre', required: true },
        armureAir: { type: 'number', label: 'Armure Air', required: true },
        armureLumiere: { type: 'number', label: 'Armure LumiÃ¨re', required: true },
        armureObscurite: { type: 'number', label: 'Armure ObscuritÃ©', required: true },
        armureDivin: { type: 'number', label: 'Armure Divin', required: true },
        armureMalefique: { type: 'number', label: 'Armure MalÃ©fique', required: true },
        abilites: { type: 'richtext', label: 'AbilitÃ©s', required: false },
        butin: { type: 'richtext', label: 'Butin', required: false }
      },
      editMapping: {
        'monster-name': 'nom',
        'monster-tags': 'tags',
        'monster-image': 'image',
        'monster-element': 'element',
        // Stats principaux
        'monster-pointsdevie': 'pointsDeVie',
        'monster-armurephysique': 'armurePhysique', 
        'monster-esquive': 'esquive',
        'monster-coupcritique': 'coupCritique',
        'monster-coupcritiquesorts': 'coupCritiqueSorts',
        'monster-resistancealterations': 'resistanceAlterations',
        // Armures Ã©lÃ©mentaires
        'monster-armurefeu': 'armureFeu',
        'monster-armureeau': 'armureEau',
        'monster-armureterre': 'armureTerre',
        'monster-armureair': 'armureAir',
        'monster-armurelumiere': 'armureLumiere',
        'monster-armureobscurite': 'armureObscurite',
        'monster-armuredivin': 'armureDivin',
        'monster-armuremalefique': 'armureMalefique',
        // Contenu narratif
        'monster-abilites': 'abilites',
        'monster-butin': 'butin'
      },
      identifiers: {
        name: 'nom',
        category: 'monstres'
      },
      template: 'monster-card',
      container: 'monstres',
      dataKey: 'MONSTRES',
      pageType: 'single',
      filterMode: 'AND',
      icons: { 
        category: 'ğŸ²', 
        item: 'ğŸ‘¾',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      filterConfig: {
        availableTags: ${JSON.stringify(monsterAvailableTags, null, 10)},
        defaultVisibleTags: ${JSON.stringify(monsterDefaultVisibleTags, null, 10)}
      },
      defaultValues: {
        nom: "Nouveau Monstre",
        tags: ["ForÃªt"],
        image: "",
        element: "Feu",
        pointsDeVie: 20,
        armurePhysique: 2,
        esquive: 5,
        coupCritique: 10,
        coupCritiqueSorts: 8,
        resistanceAlterations: 3,
        armureFeu: 0,
        armureEau: 0,
        armureTerre: 0,
        armureAir: 0,
        armureLumiere: 0,
        armureObscurite: 0,
        armureDivin: 0,
        armureMalefique: 0,
        abilites: "<strong>Attaque basique:</strong> Inflige 5 dÃ©gÃ¢ts physiques.",
        butin: "<strong>Butin:</strong> 10-50 piÃ¨ces d'or."
      }
    },

    tableTresor: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        fourchettes: { type: 'list', label: 'Fourchettes', required: true }
      },
      editMapping: {
        'table-tresor-name': 'nom',
        'table-tresor-description': 'description',
        'table-tresor-tags': 'tags'
      },
      identifiers: {
        name: 'nom',
        category: 'tables'
      },
      template: 'table-tresor-card',
      container: 'tables-tresors',
      dataKey: 'TABLES_TRESORS',
      pageType: 'single',
      filterMode: 'OR',
      icons: { 
        category: 'ğŸ’', 
        item: 'ğŸ“¦',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      filterConfig: {
        // availableTags managed dynamically via window.TABLES_TRESORS._metadata.availableTags
        defaultVisibleTags: [
          "ForÃªt",
          "Boss"
        ]
      },
      defaultValues: {
        nom: "Nouvelle Table de TrÃ©sor",
        description: "Table de butin pour une situation spÃ©cifique.",
        tags: ["ForÃªt"],
        fourchettes: [
          {
            min: 1,
            max: 10,
            objet: {
              type: "reference",
              numero: 1,
              nom: "Objet par dÃ©faut"
            }
          }
        ]
      }
    },

    staticPage: {
      fields: {
        title: { type: 'text', label: 'Titre', required: true },
        sections: { type: 'sections', label: 'Sections', required: true }
      },
      template: 'static-page',
      icons: { 
        category: 'ğŸ“„', 
        item: 'ğŸ“'
      }
    }
  };

  window.StatIcons = {
    'Force': 'ğŸ’ª',
    'AgilitÃ©': 'ğŸƒ',
    'Endurance': 'ğŸ›¡ï¸',
    'Intelligence': 'ğŸ§ ',
    'VolontÃ©': 'âš¡',
    'Chance': 'ğŸ€'
  };

  window.ElementColors = {
    'Feu': { color: '#ff6b35', weight: 'bold' },
    'Eau': { color: '#4682b4', weight: 'bold' },
    'Terre': { color: '#8b4513', weight: 'bold' },
    'Air': { color: '#22c55e', weight: 'bold' },
    'LumiÃ¨re': { color: '#ffd700', weight: 'bold' },
    'Nuit': { color: '#1a1a1a', weight: 'bold' },
    'Divin': { color: '#f5f5f5', weight: 'bold', background: 'rgba(100, 100, 100, 0.3)', padding: '2px 4px', borderRadius: '3px' },
    'MalÃ©fique': { color: '#8b5cf6', weight: 'bold' }
  };

  window.ElementIcons = {
    'Feu': 'ğŸ”¥',
    'Eau': 'ğŸ’§',
    'Terre': 'ğŸ¤',
    'Air': 'ğŸŸ¢',
    'LumiÃ¨re': 'â˜€ï¸',
    'Nuit': 'âš«',
    'Divin': 'âšª',
    'MalÃ©fique': 'ğŸŸ£'
  };

})();`;
    },

    async loadJSZip() {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    },

    async fetchFileContent(filePath) {
      try {
        const response = await fetch(filePath);
        if (response.ok) {
          return await response.text();
        }
        // Could not fetch file
        return null;
      } catch (error) {
        // Error fetching file
        return null;
      }
    },

    async getMainHTML() {
      // Get the current index.html content or reconstruct it
      try {
        const response = await fetch('index.html');
        if (response.ok) {
          return await response.text();
        }
      } catch (error) {
        // Could not fetch index.html, generating from current state
      }
      
      // Fallback: generate HTML from current document state
      return `<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta name="referrer" content="no-referrer-when-downgrade">
<title>JDRâ€‘BAB â€” Livret de rÃ¨gles</title>
<meta content="Livret web multipages des rÃ¨gles JDRâ€‘BAB, thÃ¨me parchemin, illustrations par catÃ©gorie/classe/sousâ€‘classe, export HTML autonome." name="description">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&amp;family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600&amp;display=swap" rel="stylesheet">

<!-- CSS Modulaire -->
<link rel="stylesheet" href="css/theme.css">
<link rel="stylesheet" href="css/utilities.css">
<link rel="stylesheet" href="css/components.css">
<link rel="stylesheet" href="css/layout.css">
<link rel="stylesheet" href="css/editor.css">
</head>
<body class="dev-off" style="">

<!-- Le contenu HTML complet sera injectÃ© ici par le JavaScript -->
<div id="app-loading">Chargement...</div>

<!-- JavaScript Modulaire -->
</body>
</html>`;
    },


    downloadJSON(filename, data) {
      const json = JSON.stringify(data, null, 2);
      this.downloadFile(filename, json, 'application/json');
    },

    downloadFile(filename, content, mimeType = 'text/html') {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.style.display = 'none';
      
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      URL.revokeObjectURL(url);
    },

    showNotification(message, type = 'info') {
      // Simple notification system
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${type === 'success' ? '#10B981' : type === 'error' ? '#EF4444' : '#3B82F6'};
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        font-weight: 500;
        z-index: 10000;
        animation: slideIn 0.3s ease;
      `;
      
      // Add animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      notification.textContent = message;
      document.body.appendChild(notification);
      
      // Auto-remove after 3 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    },

    // Load edits from localStorage on startup
    loadStoredEdits() {
      try {
        const storedEdits = localStorage.getItem('jdr-bab-edits');
        
        if (storedEdits && JdrApp.modules.editor) {
          JdrApp.modules.editor.editedData = JSON.parse(storedEdits);
        }
        
        // Load stored static pages data (includes dynamically created sections)
        const storedStaticPages = localStorage.getItem('jdr-bab-static-pages');
        if (storedStaticPages) {
          const staticPagesData = JSON.parse(storedStaticPages);
          
          // Merge with existing STATIC_PAGES data
          if (window.STATIC_PAGES) {
            Object.assign(window.STATIC_PAGES, staticPagesData);
          } else {
            window.STATIC_PAGES = staticPagesData;
          }
          
          console.log('Restored static pages data from localStorage:', Object.keys(staticPagesData));
        }
        
        // Ne plus charger jdr-bab-data - laisser les JSON Ãªtre la source de vÃ©ritÃ©
        
      } catch (error) {
        console.warn('Failed to load stored edits:', error);
      }
    },

    // Handle ZIP file import
    async handleZipImport(event) {
      const file = event.target.files[0];
      if (!file || file.type !== 'application/zip') {
        this.showNotification('âŒ Veuillez sÃ©lectionner un fichier ZIP', 'error');
        return;
      }

      try {
        this.showNotification('ğŸ“¥ Import en cours...', 'info');

        // Check if JSZip is available
        if (typeof JSZip === 'undefined') {
          await this.loadJSZip();
        }

        const zip = new JSZip();
        const contents = await zip.loadAsync(file);

        // Import data files
        const dataFiles = ['sorts.json', 'classes.json', 'dons.json', 'objets.json', 'monstres.json'];
        for (const dataFile of dataFiles) {
          const zipFile = contents.file(`data/${dataFile}`);
          if (zipFile) {
            const content = await zipFile.async('text');
            const data = JSON.parse(content);
            
            if (dataFile === 'sorts.json') {
              window.SORTS = data;
              JdrApp.data.SORTS = data;
            } else if (dataFile === 'classes.json') {
              window.CLASSES = data;
              JdrApp.data.CLASSES = data;
            } else if (dataFile === 'dons.json') {
              window.DONS = data;
              JdrApp.data.DONS = data;
            } else if (dataFile === 'objets.json') {
              window.OBJETS = data;
              JdrApp.data.OBJETS = data;
            } else if (dataFile === 'monstres.json') {
              window.MONSTRES = data;
              JdrApp.data.MONSTRES = data;
            } else if (dataFile === 'tables-tresors.json') {
              window.TABLES_TRESORS = data;
              JdrApp.data.TABLES_TRESORS = data;
            } else if (dataFile === 'collections.json') {
              window.COLLECTIONS = data;
              JdrApp.data.COLLECTIONS = data;
            } else if (dataFile === 'toc-structure.json') {
              window.TOC_STRUCTURE = data;
              JdrApp.data.TOC_STRUCTURE = data;
            }
          }
        }

        // Import static pages config
        const configFile = contents.file('data/static-pages-config.json');
        if (configFile) {
          const configContent = await configFile.async('text');
          window.STATIC_PAGES_CONFIG = JSON.parse(configContent);
          JdrApp.data.STATIC_PAGES_CONFIG = JSON.parse(configContent);
        }

        // Import static pages data
        if (window.STATIC_PAGES_CONFIG && window.STATIC_PAGES_CONFIG.pages) {
          window.STATIC_PAGES = {};
          JdrApp.data.STATIC_PAGES = {};
          for (const pageConfig of window.STATIC_PAGES_CONFIG.pages) {
            if (pageConfig.active) {
              const pageFile = contents.file(`data/${pageConfig.file}`);
              if (pageFile) {
                const pageContent = await pageFile.async('text');
                const pageData = JSON.parse(pageContent);
                window.STATIC_PAGES[pageConfig.id] = pageData;
                JdrApp.data.STATIC_PAGES[pageConfig.id] = pageData;
              }
            }
          }
        }

        // Import images
        const imagesFile = contents.file('data/images.json');
        if (imagesFile && JdrApp.modules.images && JdrApp.modules.images.importImages) {
          const imagesContent = await imagesFile.async('text');
          const imagesData = JSON.parse(imagesContent);
          if (imagesData.images) {
            JdrApp.modules.images.importImages(imagesData.images);
          }
        }

        // Import custom page descriptions
        const customDescFile = contents.file('data/custom-page-descriptions.json');
        if (customDescFile) {
          const customDescContent = await customDescFile.async('text');
          const customDescData = JSON.parse(customDescContent);
          window.CUSTOM_PAGE_DESCRIPTIONS = customDescData;
          JdrApp.data.customPageDescriptions = { ...JdrApp.data.customPageDescriptions, ...customDescData };
        }

        // Save imported data to localStorage
        this.saveChanges(true);

        this.showNotification('âœ… Import rÃ©ussi! Rechargement...', 'success');

        // Reload page to show imported data
        setTimeout(() => {
          window.location.reload();
        }, 1000);

      } catch (error) {
        this.showNotification('âŒ Erreur lors de l\'import', 'error');
      }

      // Reset file input
      event.target.value = '';
    },


  };

})();
// ============================================================================
// JDR-BAB APPLICATION - ROUTER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // ROUTING SYSTEM
  // ========================================
  JdrApp.modules.router = {
    currentRoute: '',
    
    init() {
      
      // Set up route change listeners
      JdrApp.utils.events.onHashChange(() => this.parseRoute());
      JdrApp.utils.events.onDOMReady(() => this.parseRoute());
      
      // Listen for dev mode changes to refresh objects page
      if (window.EventBus && window.Events) {
        EventBus.on(Events.EDITOR_TOGGLE, (payload) => {
          const currentHash = window.location.hash;
          // Refresh objects page specifically when dev mode changes
          if (currentHash === '#/objets') {
            setTimeout(() => {
              // Force a complete refresh by setting the flag
              this._forceObjectsRefresh = true;
              this.renderObjectsPage();
            }, 150);
          }
        });
      }
    },
    
    parseRoute() {
      const hash = location.hash.replace('#/', '');
      const page = hash || 'creation';
      const exists = JdrApp.utils.dom.$(`article[data-page="${page}"]`);
      
      
      this.currentRoute = page;
      
      // Handle dynamic category routing
      // Fix: check if exists is falsy OR empty NodeList
      const shouldUseRouter = !exists || (exists.length === 0);
      
      if (shouldUseRouter) {
        if (this.handleDynamicRoute(page)) {
          return; // Route was handled dynamically
        }
      }
      
      this.show(exists ? page : 'creation');
    },

    handleDynamicRoute(page) {
      // Handle sorts-* routes
      if (page.startsWith('sorts-')) {
        return this.renderDynamicCategory('sorts', 'spell', page);
      }
      
      // Handle dons-* routes  
      if (page.startsWith('dons-')) {
        return this.renderDynamicCategory('dons', 'don', page);
      }
      
      // Handle single objets page (objects now use unified page with tag filtering)
      if (page === 'objets') {
        return this.renderObjectsPage();
      }
      
      // Handle collections-objets page
      if (page === 'collections-objets') {
        return this.renderCollectionsObjectsPage();
      }
      
      // Handle single monstres page (monsters now use unified page with tag filtering)
      if (page === 'monstres') {
        return this.renderMonstersPage();
      }
      
      // Handle single tables-tresors page  
      if (page === 'tables-tresors') {
        return this.renderTablesTresorsPage();
      }
      
      // Handle feuille-personnage page
      if (page === 'feuille-personnage') {
        return this.renderFeuillePersonnagePage();
      }
      
      return false; // Route not handled
    },

    renderDynamicCategory(prefix, type, page) {
      const categoryId = page.replace(`${prefix}-`, '');
      const dataKey = prefix.toUpperCase();
      const dataSource = window[dataKey];
      
      if (!dataSource) return false;
      
      const category = dataSource.find(cat => 
        JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
      );
      
      if (category) {
        // Render the category page dynamically
        JdrApp.modules.renderer.renderCategoryPage(type, category);
        
        // Update active states
        this.updateActiveStates(page);
        
        return true;
      }
      
      return false;
    },

    updateActiveStates(page) {
      // Remove active class from all articles and links
      document.querySelectorAll('article').forEach(a => a.classList.remove('active'));
      document.querySelectorAll('.toc a').forEach(a => a.classList.remove('active'));
      
      // Set active link in TOC
      const activeLink = document.querySelector(`a[href="#/${page}"]`);
      if (activeLink) {
        activeLink.classList.add('active');
        
        // Expand parent category if needed
        const category = activeLink.closest('.toc-category');
        if (category) {
          category.classList.remove('collapsed');
        }
      }
    },
    
    show(page) {
      document.querySelectorAll('article').forEach(a => a.classList.remove('active'));
      const target = document.querySelector(`article[data-page="${page}"]`);
      if (target) {
        target.classList.add('active');
      }
      
      document.querySelectorAll('.toc a').forEach(a => a.classList.remove('active'));
      const activeLink = document.querySelector(`a[href="#/${page}"]`);
      if (activeLink) activeLink.classList.add('active');

      
      // Ensure edit buttons state is properly applied after navigation
      if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
        setTimeout(() => {
          if (JdrApp.modules.editor.isDevMode) {
            JdrApp.modules.editor.forceShowAllEditButtons();
          } else {
            JdrApp.modules.editor.forceHideAllEditButtons();
          }
        }, 50);
      }
    },
    
    navigate(route) {
      location.hash = `#/${route}`;
      // Force parseRoute() in case hashchange event doesn't fire
      setTimeout(() => {
        this.parseRoute();
      }, 10);
    },
    
    getCurrentRoute() {
      return this.currentRoute;
    },
    
    // Generate table of contents based on hierarchical structure
    generateTOC() {
      const tocContainer = document.querySelector('#toc');
      if (!tocContainer) return;

      if (!window.TOC_STRUCTURE) {
        console.warn('TOC_STRUCTURE not loaded, falling back to basic TOC');
        this.generateBasicTOC();
        return;
      }

      const tocHTML = `
        <h4>Sommaire</h4>
        ${window.TOC_STRUCTURE.sections
          .filter(section => !section.requiresMJ || window.JdrApp.state.isMJ)
          .map(section => this.generateTOCSection(section)).join('')}
        <div class="mj-toggle-container" style="margin: 1rem 0; text-align: center; border-top: 2px solid var(--rule); padding-top: 1rem;">
          <button id="mjToggleBtn" class="btn-base btn-small" style="background: var(--bronze); color: white; border-color: var(--bronze); position: relative;">
            ğŸ­ MaÃ®tre de jeu
            <span id="mjStatusIndicator" style="position: absolute; top: -5px; right: -5px; width: 12px; height: 12px; border-radius: 50%; background: #dc2626; border: 2px solid white; display: none;"></span>
          </button>
        </div>
      `;
      
      tocContainer.innerHTML = tocHTML;
      
      // Attacher les Ã©vÃ©nements directement aux Ã©lÃ©ments aprÃ¨s crÃ©ation
      this.attachFoldoutEvents();
      
      // Initialiser les hauteurs dynamiques pour toutes les sections ouvertes
      this.initializeDynamicHeights();
      
      // Ajouter l'event listener pour le bouton MJ
      this.setupMJToggle();
    },

    initializeDynamicHeights() {
      // Calculer et appliquer les hauteurs dynamiques pour toutes les sections non-collapsÃ©es
      document.querySelectorAll('.toc-section:not(.collapsed) .toc-section-content').forEach(content => {
        const childCount = content.querySelectorAll('a, .toc-category').length;
        const itemHeight = 50; // Hauteur approximative par Ã©lÃ©ment
        const baseHeight = 100; // Hauteur de base pour le padding
        const dynamicHeight = Math.max(500, (childCount * itemHeight) + baseHeight);
        
        content.style.maxHeight = `${dynamicHeight}px`;
      });
    },

    setupMJToggle() {
      const mjBtn = document.getElementById('mjToggleBtn');
      if (!mjBtn) return;

      // Initialize visual state based on current MJ status
      this.updateMJButtonVisual();
      this.updateMJBodyClass();

      const handleMJToggle = () => {
        if (window.JdrApp.state.isMJ) {
          // DÃ©jÃ  en mode MJ, dÃ©sactiver
          window.JdrApp.state.isMJ = false;
          this.updateMJButtonVisual();
          this.updateMJBodyClass();
          this.generateTOC(); // RÃ©gÃ©nÃ©rer le TOC pour cacher les sections MJ
          
          // Refresh objects display if currently on objects page
          this.refreshObjectsPageIfActive();
        } else {
          // Demander confirmation avant d'activer le mode MJ
          this.showMJConfirmation(() => {
            window.JdrApp.state.isMJ = true;
            this.updateMJButtonVisual();
            this.updateMJBodyClass();
            this.generateTOC(); // RÃ©gÃ©nÃ©rer le TOC pour afficher les sections MJ
            
            // Refresh objects display if currently on objects page
            this.refreshObjectsPageIfActive();
          });
        }
      };

      // Ajouter support tactile pour mobile
      mjBtn.addEventListener('click', handleMJToggle);
      mjBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleMJToggle();
      });
    },

    attachFoldoutEvents() {
      // Attacher les Ã©vÃ©nements directement aux headers de section
      document.querySelectorAll('.toc-section-header').forEach(header => {
        header.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const section = header.closest('.toc-section');
          if (section) {
            const wasCollapsed = section.classList.contains('collapsed');
            section.classList.toggle('collapsed');
            const isCollapsed = section.classList.contains('collapsed');
            
            const toggle = section.querySelector('.toc-section-toggle');
            if (toggle) {
              toggle.textContent = isCollapsed ? 'â–¶' : 'â–¼';
            }
            
            const content = section.querySelector('.toc-section-content');
            if (content) {
              // Force les styles directement en JavaScript pour compatibilitÃ© standalone
              if (isCollapsed) {
                content.style.maxHeight = '0px';
                content.style.opacity = '0';
                content.style.paddingTop = '0';
                content.style.paddingBottom = '0';
                content.style.overflow = 'hidden';
              } else {
                // Calculer dynamiquement la hauteur nÃ©cessaire en fonction du contenu
                const childCount = content.querySelectorAll('a, .toc-category').length;
                const itemHeight = 50; // Hauteur approximative par Ã©lÃ©ment (incluant padding et marge)
                const baseHeight = 100; // Hauteur de base pour le padding
                const dynamicHeight = Math.max(500, (childCount * itemHeight) + baseHeight);
                
                content.style.maxHeight = `${dynamicHeight}px`;
                content.style.opacity = '1';
                content.style.paddingTop = '';
                content.style.paddingBottom = '';
                content.style.overflow = 'visible';
              }
            }
          }
        });
      });

      // Attacher les Ã©vÃ©nements aux liens de catÃ©gorie
      document.querySelectorAll('.toc-category > a').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const category = link.closest('.toc-category');
          if (category) {
            category.classList.toggle('collapsed');
          }
        });
      });

      // Attacher les Ã©vÃ©nements aux liens de navigation normaux
      document.querySelectorAll('.toc a:not(.toc-category > a)').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const route = link.getAttribute('data-route');
          if (route) {
            // Special handling for objects page - force refresh when navigating to it
            if (route === 'objets') {
              // Set a flag to force refresh objects page after navigation
              JdrApp.modules.router._forceObjectsRefresh = true;
            }
            JdrApp.modules.router.navigate(route);
          }
        });
      });
    },

    updateMJButtonVisual() {
      const mjBtn = document.getElementById('mjToggleBtn');
      const mjIndicator = document.getElementById('mjStatusIndicator');
      
      if (!mjBtn) return;
      
      if (window.JdrApp.state.isMJ) {
        // Mode MJ activÃ© - bouton dorÃ© avec indicateur vert
        mjBtn.style.background = 'var(--gold)';
        mjBtn.style.borderColor = 'var(--gold)';
        mjBtn.innerHTML = 'ğŸ­ Mode MJ activÃ© <span id="mjStatusIndicator" style="position: absolute; top: -5px; right: -5px; width: 12px; height: 12px; border-radius: 50%; background: #16a34a; border: 2px solid white; display: inline-block;"></span>';
      } else {
        // Mode normal - bouton bronze sans indicateur
        mjBtn.style.background = 'var(--bronze)';
        mjBtn.style.borderColor = 'var(--bronze)';
        mjBtn.innerHTML = 'ğŸ­ MaÃ®tre de jeu <span id="mjStatusIndicator" style="position: absolute; top: -5px; right: -5px; width: 12px; height: 12px; border-radius: 50%; background: #dc2626; border: 2px solid white; display: none;"></span>';
      }
    },

    updateMJBodyClass() {
      const body = document.body;
      if (window.JdrApp.state.isMJ) {
        body.classList.remove('mj-off');
        body.classList.add('mj-on');
      } else {
        body.classList.remove('mj-on');
        body.classList.add('mj-off');
      }
    },

    showMJConfirmation(onConfirm) {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0,0,0,0.7);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
      `;
      
      modal.innerHTML = `
        <div style="
          background: var(--card);
          border: 3px solid var(--bronze);
          border-radius: 16px;
          padding: 2rem;
          max-width: 500px;
          margin: 1rem;
          text-align: center;
          box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        ">
          <h3 style="color: var(--bronze); margin-top: 0;">âš ï¸ Mode MaÃ®tre de jeu</h3>
          <p style="margin: 1.5rem 0; line-height: 1.6;">
            ÃŠtes-vous sÃ»r de vouloir activer le mode MaÃ®tre de jeu?<br><br>
            <strong style="color: var(--bronze);">Si vous Ãªtes juste un joueur, vous risquez d'Ãªtre spoilÃ©!</strong>
          </p>
          <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 2rem;">
            <button id="mjConfirmYes" class="btn-base" style="background: var(--bronze); color: white; border-color: var(--bronze);">
              Oui, je suis MJ
            </button>
            <button id="mjConfirmNo" class="btn-base" style="background: var(--rule); color: var(--accent-ink); border-color: var(--rule);">
              Non, annuler
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      modal.querySelector('#mjConfirmYes').addEventListener('click', () => {
        document.body.removeChild(modal);
        onConfirm();
      });
      
      modal.querySelector('#mjConfirmNo').addEventListener('click', () => {
        document.body.removeChild(modal);
      });
      
      // Fermer en cliquant sur le fond
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
        }
      });
    },

    generateTOCSection(section) {
      const sectionClass = section.collapsed ? 'toc-section collapsed' : 'toc-section';
      const toggleIcon = section.collapsed ? 'â–¶' : 'â–¼';
      
      return `
        <div class="${sectionClass}" data-section="${section.id}">
          <div class="toc-section-header">
            <span class="toc-section-title">${section.title}</span>
            <span class="toc-section-toggle">${toggleIcon}</span>
          </div>
          <div class="toc-section-content">
            ${section.items.map(item => this.generateTOCItem(item)).join('')}
          </div>
        </div>
      `;
    },

    generateTOCItem(item) {
      if (item.type === 'page') {
        return `<a data-route="${item.id}" href="#/${item.id}" class="">${item.icon} ${item.title}</a>`;
      } else if (item.type === 'category') {
        return this.generateTOCCategory(item);
      }
      return '';
    },

    generateTOCCategory(item) {
      const dataSource = window[item.items]; // CLASSES, SORTS, DONS
      if (!dataSource) return '';

      if (item.id === 'classes') {
        return `
          <div class="toc-category">
            <a data-route="classes" href="#/classes" class="">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource.map(classe => 
                `<a data-route="${JdrApp.utils.data.sanitizeId(classe.nom)}" href="#/${JdrApp.utils.data.sanitizeId(classe.nom)}" class="">${this.getClassIcon(classe.nom)} ${classe.nom}</a>`
              ).join('')}
            </div>
          </div>
        `;
      } else if (item.id === 'sorts') {
        return `
          <div class="toc-category">
            <a data-route="sorts" href="#/sorts">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource.map(category => 
                `<a data-route="sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getSortCategoryIcon(category.nom)} ${category.nom}</a>`
              ).join('')}
            </div>
          </div>
        `;
      } else if (item.id === 'dons') {
        return `
          <div class="toc-category">
            <a data-route="dons" href="#/dons" class="">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource.map(category => 
                `<a data-route="dons-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/dons-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getDonCategoryIcon(category.nom)} ${category.nom}</a>`
              ).join('')}
            </div>
          </div>
        `;
      }

      return '';
    },

    generateBasicTOC() {
      const tocContainer = document.querySelector('#toc');
      if (!tocContainer) return;

      const tocHTML = `
        <h4>Sommaire</h4>
        <a class="" data-route="creation" href="#/creation">ğŸ§™â€â™‚ï¸ CrÃ©ation d'un personnage</a>
        
        <div class="toc-category">
          <a data-route="classes" href="#/classes" class="">âš”ï¸ Classes</a>
          <div class="toc-sub">
            ${window.CLASSES ? window.CLASSES.map(classe => 
              `<a data-route="${JdrApp.utils.data.sanitizeId(classe.nom)}" href="#/${JdrApp.utils.data.sanitizeId(classe.nom)}" class="">${this.getClassIcon(classe.nom)} ${classe.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <div class="toc-category">
          <a data-route="sorts" href="#/sorts">ğŸ”® Sorts</a>
          <div class="toc-sub">
            ${window.SORTS ? window.SORTS.map(category => 
              `<a data-route="sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getSortCategoryIcon(category.nom)} ${category.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <div class="toc-category">
          <a data-route="dons" href="#/dons" class="">ğŸ–ï¸ Dons</a>
          <div class="toc-sub">
            ${window.DONS ? window.DONS.map(category => 
              `<a data-route="dons-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/dons-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getDonCategoryIcon(category.nom)} ${category.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <a data-route="objets" href="#/objets" class="">ğŸ“¦ Objets</a>
        
        <a data-route="elements" href="#/elements" class="">ğŸŒŸ Ã‰lÃ©ments</a>
        <a data-route="stats" href="#/stats" class="">ğŸ“Š Statistiques</a>
        <a data-route="competences-tests" href="#/competences-tests" class="">ğŸ¯ CompÃ©tences & Tests</a>
        <a data-route="etats" href="#/etats" class="">âš¡ Etats</a>
      `;
      
      tocContainer.innerHTML = tocHTML;
    },
    
    renderObjectsPage() {
      if (!window.OBJETS) return false;
      
      // Ensure the page is shown as active first
      this.show('objets');
      
      // Force complete regeneration if coming from navigation or MJ mode change
      const shouldForceRefresh = this._forceObjectsRefresh || false;
      this._forceObjectsRefresh = false; // Reset the flag
      
      // Force complete regeneration of the objects page content
      // This ensures that objects filtered out by MJ restrictions are now properly generated in the DOM
      setTimeout(() => {
        if (JdrApp.modules.renderer && JdrApp.modules.renderer.regenerateCurrentPage) {
          JdrApp.modules.renderer.regenerateCurrentPage();
        }
      }, shouldForceRefresh ? 100 : 50); // Slightly longer delay when forced refresh
      
      return true;
    },


    // Helper method to refresh objects page if currently active
    refreshObjectsPageIfActive() {
      const currentHash = window.location.hash;
      if (currentHash === '#/objets' || currentHash === '#objets') {
        setTimeout(() => {
          // Force full page regeneration to ensure objects filtered by MJ mode are now visible
          // This calls renderObjectsPage() which will regenerate the entire page with current filters
          this.renderObjectsPage();
        }, 150); // Slightly longer delay to ensure MJ state is updated
      }
    },
    
    getClassIcon(className) {
      const icons = {
        'Guerrier': 'ğŸ—¡ï¸',
        'Mage': 'ğŸ”®',
        'PrÃªtre': 'â›ª',
        'RÃ´deur': 'ğŸƒ',
        'Enchanteur': 'âœ¨'
      };
      return icons[className] || 'âš”ï¸';
    },
    
    getSortCategoryIcon(categoryName) {
      const icons = {
        'Sorts de Mage': 'ğŸ”®',
        'Sorts de PrÃªtre': 'â›ª',
        'Sorts d\'Enchanteur': 'âœ¨',
        'Sorts de Monstres': 'ğŸ’€'
      };
      return icons[categoryName] || 'ğŸ”®';
    },
    
    getDonCategoryIcon(categoryName) {
      const icons = {
        'Guerrier': 'ğŸ—¡ï¸',
        'Mage': 'ğŸ”®',
        'Pretre': 'â›ª',  // Sans accent comme dans les donnÃ©es
        'PrÃªtre': 'â›ª',  // Avec accent au cas oÃ¹
        'RÃ´deur': 'ğŸƒ',
        'Enchanteur': 'âœ¨',
        'GÃ©nÃ©raux': 'ğŸ–ï¸',
        'Generaux': 'ğŸ–ï¸'  // Sans accent comme dans les donnÃ©es
      };
      return icons[categoryName] || 'ğŸ–ï¸';
    },

    getMonstreCategoryIcon(categoryName) {
      const icons = {
        'ForÃªt': 'ğŸŒ²',
        'Foret': 'ğŸŒ²',  // Sans accent
        'Donjon': 'ğŸ°',
        'Dragons': 'ğŸ‰',
        'Mort-vivants': 'ğŸ’€',
        'DÃ©mons': 'ğŸ‘¹',
        'Demons': 'ğŸ‘¹',  // Sans accent
        'Animaux': 'ğŸ¦',
        'HumanoÃ¯des': 'ğŸ§Œ',
        'HumanoÃ¯des': 'ğŸ§Œ'  // Sans accent
      };
      return icons[categoryName] || 'ğŸ‘¹';
    },
    
    getObjetCategoryIcon(categoryName) {
      const icons = {
        'Armes': 'âš”ï¸',
        'Armures': 'ğŸ›¡ï¸',
        'Potions': 'ğŸ§ª',
        'Herbes Magiques': 'ğŸŒ¿',
        'Objets Magiques': 'âœ¨',
        'Accessoires': 'ğŸ’',
        'Consommables': 'ğŸ',
        'Composants': 'ğŸ”®',
        'Outils': 'ğŸ”¨'
      };
      return icons[categoryName] || 'ğŸ“¦';
    },

    renderObjectsPage() {
      // Use PageBuilder to generate the objets page dynamically
      JdrApp.modules.renderer.renderUnifiedContentPage('objet', window.OBJETS || []);
      this.updateActiveStates('objets');
      this.show('objets'); // Activer la page
      return true;
    },

    renderMonstersPage() {
      // Use PageBuilder to generate the monstres page dynamically
      JdrApp.modules.renderer.renderUnifiedContentPage('monster', window.MONSTRES || []);
      this.updateActiveStates('monstres');
      this.show('monstres'); // Activer la page
      return true;
    },
    
    renderTablesTresorsPage() {
      // Use PageBuilder to generate the tables-tresors page dynamically
      JdrApp.modules.renderer.renderUnifiedContentPage('tableTresor', window.TABLES_TRESORS || { tables: [] });
      this.updateActiveStates('tables-tresors');
      this.show('tables-tresors'); // Activer la page
      return true;
    },

    renderCollectionsObjectsPage() {
      // Safety check - if collections data is not available, try to wait a bit
      if (!window.COLLECTIONS || !window.COLLECTIONS.collections || window.COLLECTIONS.collections.length === 0) {
        setTimeout(() => this.renderCollectionsObjectsPage(), 100);
        return false;
      }
      
      // Create or find the page element
      let pageElement = document.getElementById('collections-objets');
      
      // If the page doesn't exist, create it
      if (!pageElement) {
        pageElement = document.createElement('article');
        pageElement.id = 'collections-objets';
        pageElement.setAttribute('data-page', 'collections-objets');
        pageElement.className = 'page';
        
        // Insert it into the views container
        const viewsContainer = document.querySelector('#views');
        
        if (viewsContainer) {
          viewsContainer.appendChild(pageElement);
        } else {
          console.error('Views container not found');
          return false;
        }
      }
      
      // Create the collections page content
      const collectionsContent = `
        <div class="page-header">
          <h1>ğŸ“š Collections d'Objets</h1>
          <div class="editable-section" data-section-type="pageDescription">
            <p class="editable" data-edit-type="generic" data-edit-section="description" data-item-identifier="collections-objets" data-page-type="collections">${this.getCollectionsDescription()}</p>
            <button class="edit-btn" data-edit-type="collections-description" style="display: none;">âœï¸ Modifier</button>
          </div>
        </div>
        
        <div class="collections-search">
          <div class="search-container">
            <input 
              type="text" 
              id="collection-search-input" 
              placeholder="Tapez le nom d'une collection..." 
              class="search-input"
              value="DÃ©part"
            />
            <button id="collection-search-btn" class="search-button">ğŸ” Rechercher</button>
          </div>
        </div>
        
        <div id="collection-results" class="collection-results" style="display: none;">
          <div id="collection-header" class="collection-header"></div>
          <div id="tag-filters" class="tag-filters"></div>
          <div id="collection-items" class="collection-items"></div>
        </div>
        
        <div id="available-collections" class="available-collections" style="display: none;">
          <h2>Collections disponibles</h2>
          <div class="collections-grid">
            <!-- Collections will be generated dynamically -->
          </div>
        </div>
      `;
      
      // Insert content into the page
      pageElement.innerHTML = collectionsContent;
      this.setupCollectionsEventListeners();
      
      // Show collections grid in dev mode, auto-fill search in normal mode
      const availableCollections = document.getElementById('available-collections');
      const searchInput = document.getElementById('collection-search-input');
      const isDevMode = this.isDevModeActive();
      
      
      // Generate collections dynamically
      this.generateCollectionsGrid();
      
      if (availableCollections) {
        if (isDevMode) {
          availableCollections.style.display = 'block';
          // In dev mode, show all collections without needing search
          // But keep the search functional for filtering
        } else {
          availableCollections.style.display = 'none';
          // In normal mode, collections are hidden - user must search manually
        }
      } else {
        console.error('âŒ available-collections element not found');
      }
      
      // Setup dev mode change listener
      this.setupDevModeListener();
      
      // Show and activate page after content is inserted
      this.show('collections-objets');
      this.updateActiveStates('collections-objets');
      
      // Ensure the page is visible regardless of dev mode
      if (pageElement) {
        pageElement.classList.add('active');
      }
      
      return true;
    },

    setupCollectionsEventListeners() {
      // console.log('Setting up collections event listeners...');
      const searchInput = document.getElementById('collection-search-input');
      const searchBtn = document.getElementById('collection-search-btn');
      const collectionCards = document.querySelectorAll('.collection-card');
      
      // console.log('Found elements:', {
      //   searchInput: !!searchInput,
      //   searchBtn: !!searchBtn,
      //   collectionCards: collectionCards.length
      // });
      
      // Search functionality
      const performSearch = () => {
        const searchTerm = searchInput.value.trim();
        if (searchTerm) {
          this.displayCollection(searchTerm);
        }
      };
      
      searchBtn.addEventListener('click', performSearch);
      searchInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          performSearch();
        }
      });
      
      // Collection card clicks
      collectionCards.forEach(card => {
        card.addEventListener('click', () => {
          const collection = card.getAttribute('data-collection');
          searchInput.value = collection;
          this.displayCollection(collection);
        });
      });
    },

    displayCollection(collectionName) {
      if (!window.OBJETS || !window.OBJETS.objets || !window.COLLECTIONS || !window.COLLECTIONS.collections) return;
      
      // Find the collection by name or ID
      const collection = window.COLLECTIONS.collections.find(coll => 
        coll.id === collectionName || 
        coll.nom.toLowerCase() === collectionName.toLowerCase()
      );
      
      if (!collection) {
        this.showCollectionNotFound(collectionName);
        return;
      }
      
      // Filter objects by collection (using object numbers/IDs defined in collection)
      const filteredObjects = window.OBJETS.objets.filter(obj => {
        return collection.objets && collection.objets.includes(obj.numero);
      });
      
      const resultsContainer = document.getElementById('collection-results');
      const headerContainer = document.getElementById('collection-header');
      const itemsContainer = document.getElementById('collection-items');
      const tagFiltersContainer = document.getElementById('tag-filters');
      const availableCollections = document.getElementById('available-collections');
      
      // Hide available collections and show results
      if (availableCollections) {
        availableCollections.style.display = 'none';
      }
      if (resultsContainer) {
        resultsContainer.style.display = 'block';
      }
      
      const isDevMode = JdrApp.utils.isDevMode();
      
      // Update header with collection info
      if (headerContainer) {
        headerContainer.innerHTML = `
          ${isDevMode ? `
            <div class="collection-navigation" style="margin-bottom: 1rem;">
              <button class="btn small back-to-collections-btn" style="background: #6B7280;">â† Retour aux collections</button>
            </div>
          ` : ''}
          <h2>${collection.icon} ${collection.nom}</h2>
          <p class="collection-description">${collection.description}</p>
          <p>${filteredObjects.length} objet(s) dans cette collection</p>
          ${isDevMode ? `
            <div class="collection-dev-actions" style="margin-top: 1rem;">
              <button class="btn small add-object-btn" data-collection="${collection.id}">â• Ajouter un objet Ã  cette collection</button>
              <button class="btn small remove-object-btn" data-collection="${collection.id}">â– Retirer un objet de cette collection</button>
            </div>
          ` : ''}
        `;
      }
      
      // Get all unique tags from filtered objects for additional filtering
      const allTags = [...new Set(filteredObjects.flatMap(obj => obj.tags || []))];
      
      // Create tag filters if objects have multiple tags
      if (allTags.length > 1 && tagFiltersContainer) {
        tagFiltersContainer.innerHTML = `
          <h3>Filtrer par tag:</h3>
          <div class="tag-buttons">
            <button class="tag-filter-btn active" data-tag="all">Tous</button>
            ${allTags.map(tag => `
              <button class="tag-filter-btn" data-tag="${tag}">${tag}</button>
            `).join('')}
          </div>
        `;
      } else if (tagFiltersContainer) {
        tagFiltersContainer.innerHTML = '';
      }
      
      // Display objects
      this.renderCollectionItems(filteredObjects);
      
      // Setup add/remove object button listeners if in dev mode
      if (isDevMode) {
        const addObjectBtn = document.querySelector('.add-object-btn');
        if (addObjectBtn) {
          addObjectBtn.addEventListener('click', () => {
            const collection = addObjectBtn.getAttribute('data-collection');
            this.addObjectToCollection(collection);
          });
        }
        
        const removeObjectBtn = document.querySelector('.remove-object-btn');
        if (removeObjectBtn) {
          removeObjectBtn.addEventListener('click', () => {
            const collection = removeObjectBtn.getAttribute('data-collection');
            this.removeObjectFromCollection(collection);
          });
        }

        const backToCollectionsBtn = document.querySelector('.back-to-collections-btn');
        if (backToCollectionsBtn) {
          backToCollectionsBtn.addEventListener('click', () => {
            this.showCollectionsGrid();
          });
        }
      }
      
      // Tag filter event listeners
      document.querySelectorAll('.tag-filter-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          // Update active state
          document.querySelectorAll('.tag-filter-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          
          const selectedTag = btn.getAttribute('data-tag');
          let itemsToShow = filteredObjects;
          
          if (selectedTag !== 'all') {
            itemsToShow = filteredObjects.filter(obj => 
              obj.tags && obj.tags.includes(selectedTag)
            );
          }
          
          this.renderCollectionItems(itemsToShow);
        });
      });
    },

    showCollectionNotFound(collectionName) {
      const resultsContainer = document.getElementById('collection-results');
      const headerContainer = document.getElementById('collection-header');
      const itemsContainer = document.getElementById('collection-items');
      const tagFiltersContainer = document.getElementById('tag-filters');
      const availableCollections = document.getElementById('available-collections');
      
      // Show error message for non-existent collection
      if (availableCollections) {
        availableCollections.style.display = 'none';
      }
      if (resultsContainer) {
        resultsContainer.style.display = 'block';
      }
      
      if (headerContainer) {
        const isDevMode = this.isDevModeActive();
        headerContainer.innerHTML = `
          <div class="collection-error">
            <h2>âŒ Collection introuvable</h2>
            <p>Aucune collection nommÃ©e "<strong>${collectionName}</strong>" n'a Ã©tÃ© trouvÃ©e.</p>
            ${isDevMode ? 
              `<p>Les collections disponibles sont listÃ©es ci-dessous.</p>` : 
              `<p>VÃ©rifiez l'orthographe ou contactez un administrateur pour connaÃ®tre les collections disponibles.</p>`
            }
          </div>
        `;
      }
      
      if (itemsContainer) {
        itemsContainer.innerHTML = '';
      }
      if (tagFiltersContainer) {
        tagFiltersContainer.innerHTML = '';
      }
      
      // Clear search input after delay and show available collections only in dev mode
      setTimeout(() => {
        document.getElementById('collection-search-input').value = '';
        
        // Only show collections grid in dev mode
        const isDevMode = this.isDevModeActive();
        if (availableCollections) {
          availableCollections.style.display = isDevMode ? 'block' : 'none';
        }
        if (resultsContainer) {
          resultsContainer.style.display = 'none';
        }
      }, 3000);
    },

    renderCollectionItems(items) {
      const itemsContainer = document.getElementById('collection-items');
      
      // Multiple ways to detect dev mode for robustness
      const isDevMode = (
        (JdrApp && JdrApp.utils && JdrApp.utils.isDevMode && JdrApp.utils.isDevMode()) ||
        document.body.classList.contains('dev-on') ||
        (JdrApp.modules && JdrApp.modules.editor && JdrApp.modules.editor.isDevMode)
      );
      
      
      // Check if CardBuilder is available
      if (!window.CardBuilder) {
        console.error('CardBuilder not available, falling back to simple display');
        const itemsHTML = items.map(item => `
          <div class="card" data-object-numero="${item.numero}">
            <h4>${item.nom}</h4>
            <p><strong>NÂ°${item.numero}</strong></p>
            <p>${item.description}</p>
            <hr>
            <p>${item.effet}</p>
            <div style="display: flex; justify-content: space-between;">
              <span>${item.prix}</span>
              <span>${item.poids}</span>
            </div>
            ${isDevMode ? `
              <div class="dev-controls" style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #ccc;">
                <button class="btn small edit-object-btn" data-numero="${item.numero}">âœï¸ Ã‰diter</button>
                <button class="btn small remove-from-collection-btn" data-numero="${item.numero}" style="background: #f59e0b;">â– Retirer</button>
                <button class="btn small delete-object-btn" data-numero="${item.numero}" style="background: #ef4444;">ğŸ—‘ï¸ Supprimer</button>
              </div>
            ` : ''}
          </div>
        `).join('');
        itemsContainer.innerHTML = itemsHTML;
      } else {
        // Use the existing CardBuilder system to ensure consistent formatting and images
        const itemsHTML = items.map(item => {
          let cardHTML = window.CardBuilder.create('objet', item, 'objets').build();
          
          // Add dev controls if in dev mode
          if (isDevMode) {
            // Insert dev controls before the closing </article> tag
            cardHTML = cardHTML.replace('</article>', `
              <div class="dev-controls collection-dev-controls">
                <button class="btn small edit-object-btn" data-numero="${item.numero}">âœï¸ Ã‰diter</button>
                <button class="btn small remove-from-collection-btn" data-numero="${item.numero}">â– Retirer de cette collection</button>
                <button class="btn small delete-object-btn" data-numero="${item.numero}">ğŸ—‘ï¸ Supprimer dÃ©finitivement</button>
              </div>
            </article>`);
          }
          
          return cardHTML;
        }).join('');
        
        itemsContainer.innerHTML = itemsHTML;
      }
      
      // Add event listeners for dev controls
      if (isDevMode) {
        this.setupCollectionEditControls();
      }
      
      // Auto-load images and manage dev mode buttons after rendering
      setTimeout(() => {
        if (JdrApp.modules.renderer && JdrApp.modules.renderer.autoLoadImages) {
          JdrApp.modules.renderer.autoLoadImages();
        }
        
        // Force apply dev mode classes to ensure CSS rules work
        this.ensureDevModeClasses();
      }, 100);
    },

    setupCollectionEditControls() {
      // Edit object buttons
      const editBtns = document.querySelectorAll('.edit-object-btn');
      const removeBtns = document.querySelectorAll('.remove-from-collection-btn');
      const deleteBtns = document.querySelectorAll('.delete-object-btn');
      
      // console.log('ğŸ›ï¸ Setting up object controls:', {
      //   editBtns: editBtns.length,
      //   removeBtns: removeBtns.length,
      //   deleteBtns: deleteBtns.length
      // });

      editBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const objectNumero = parseInt(btn.getAttribute('data-numero'));
          // console.log('âœï¸ Edit object clicked:', objectNumero);
          this.editCollectionObject(objectNumero);
        });
      });

      // Remove from collection buttons
      removeBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const objectNumero = parseInt(btn.getAttribute('data-numero'));
          // console.log('â– Remove from collection clicked:', objectNumero);
          this.removeObjectFromCurrentCollection(objectNumero);
        });
      });

      // Delete object buttons
      deleteBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const objectNumero = parseInt(btn.getAttribute('data-numero'));
          // console.log('ğŸ—‘ï¸ Delete object clicked:', objectNumero);
          this.deleteCollectionObject(objectNumero);
        });
      });
    },

    editCollectionObject(objectNumero) {
      // Find the object in the data (normalize comparison)
      const object = window.OBJETS.objets.find(obj => parseInt(obj.numero) === objectNumero);
      if (!object) {
        console.error('Object not found:', objectNumero);
        return;
      }

      // Navigate to the objects page and trigger edit for this specific object
      // This reuses the existing object editing functionality
      window.location.hash = '#/objets';
      
      // Wait for the page to load, then trigger edit
      setTimeout(() => {
        const objectCard = document.querySelector(`[data-numero="${objectNumero}"]`);
        if (objectCard) {
          // Trigger the existing edit functionality
          const editableElements = objectCard.querySelectorAll('.editable');
          if (editableElements.length > 0) {
            // Focus on the first editable element to start editing
            editableElements[0].click();
          }
        }
      }, 500);
    },

    removeObjectFromCurrentCollection(objectNumero) {
      // Find the object in the data (normalize comparison)
      const object = window.OBJETS.objets.find(obj => parseInt(obj.numero) === objectNumero);
      if (!object) {
        console.error('Object not found:', objectNumero);
        return;
      }

      // Determine which collection we're currently viewing
      const searchInput = document.getElementById('collection-search-input');
      const currentCollectionName = searchInput ? searchInput.value : null;
      
      if (!currentCollectionName) {
        alert('Impossible de dÃ©terminer la collection actuelle.');
        return;
      }

      // Find the current collection
      const collection = window.COLLECTIONS.collections.find(coll => 
        coll.nom === currentCollectionName || coll.id === currentCollectionName
      );
      
      if (!collection) {
        alert(`Collection "${currentCollectionName}" introuvable.`);
        return;
      }

      // Check if the object is in this collection (normalize comparison)
      const objNum = parseInt(objectNumero);
      const isInCollection = collection.objets.includes(objNum) || collection.objets.includes(objectNumero);
      if (!isInCollection) {
        alert(`L'objet "${object.nom}" n'est pas dans la collection "${collection.nom}".`);
        return;
      }

      // Confirm removal
      const confirmRemove = confirm(
        `ÃŠtes-vous sÃ»r de vouloir retirer l'objet "${object.nom}" de la collection "${collection.nom}"?\n\n` +
        `L'objet ne sera pas supprimÃ©, seulement retirÃ© de cette collection.`
      );
      if (!confirmRemove) return;

      // Remove the object from the collection (normalize comparison)
      let objectIndex = collection.objets.indexOf(objNum);
      if (objectIndex === -1) {
        objectIndex = collection.objets.indexOf(objectNumero);
      }
      if (objectIndex !== -1) {
        collection.objets.splice(objectIndex, 1);
        
        // Show notification
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification(`â– Objet "${object.nom}" retirÃ© de la collection "${collection.nom}"`, 'success');
        }

        // Refresh the current collection view
        this.displayCollection(collection.id);
      }
    },

    deleteCollectionObject(objectNumero) {
      // Find the object in the data (normalize comparison)  
      const object = window.OBJETS.objets.find(obj => parseInt(obj.numero) === objectNumero);
      if (!object) {
        console.error('Object not found:', objectNumero);
        return;
      }

      // Confirm deletion
      const confirmDelete = confirm(`ÃŠtes-vous sÃ»r de vouloir supprimer l'objet "${object.nom}" (NÂ°${object.numero}) ?`);
      if (!confirmDelete) return;

      // Remove the object from the data (normalize comparison)
      const objectIndex = window.OBJETS.objets.findIndex(obj => parseInt(obj.numero) === objectNumero);
      if (objectIndex !== -1) {
        window.OBJETS.objets.splice(objectIndex, 1);
        
        // Show notification
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification(`ğŸ—‘ï¸ Objet "${object.nom}" supprimÃ©`, 'success');
        }

        // Refresh the current collection view
        const currentSearch = document.getElementById('collection-search-input').value;
        if (currentSearch) {
          this.displayCollection(currentSearch);
        }
      }
    },

    addObjectToCollection(collectionId) {
      // Find the collection
      const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
      if (!collection) {
        alert('Collection introuvable.');
        return;
      }
      
      // Show a list of all available objects to choose from
      const allObjects = window.OBJETS.objets;
      if (allObjects.length === 0) {
        alert('Aucun objet disponible Ã  ajouter.');
        return;
      }
      
      // Filter out objects already in this collection
      // Normalize number comparison to handle both string and number types
      const availableObjects = allObjects.filter(obj => {
        const objNum = parseInt(obj.numero);
        return !collection.objets.includes(objNum) && !collection.objets.includes(obj.numero);
      });
      
      if (availableObjects.length === 0) {
        alert('Tous les objets sont dÃ©jÃ  dans cette collection.');
        return;
      }
      
      // Create a selection modal with dropdown
      this.showObjectSelectionModal(
        `Ajouter un objet Ã  la collection "${collection.nom}"`,
        availableObjects,
        (selectedObject) => {
          // Add the object to the collection (normalize to number type)
          const objNum = parseInt(selectedObject.numero);
          collection.objets.push(objNum);
          
          // Show notification
          if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
            JdrApp.modules.storage.showNotification(`â• Objet "${selectedObject.nom}" ajoutÃ© Ã  la collection "${collection.nom}"`, 'success');
          }
          
          // Refresh the current collection view to show the added object
          this.displayCollection(collectionId);
          
          // Auto-scroll to the added object
          setTimeout(() => {
            const addedObjectCard = document.querySelector(`[data-numero="${selectedObject.numero}"]`);
            if (addedObjectCard) {
              addedObjectCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
              // Highlight the added object briefly
              addedObjectCard.style.border = '3px solid #10B981';
              setTimeout(() => {
                addedObjectCard.style.border = '';
              }, 2000);
            }
          }, 500);
        }
      );
    },

    removeObjectFromCollection(collectionId) {
      // Find the collection
      const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
      if (!collection) {
        alert('Collection introuvable.');
        return;
      }
      
      if (!collection.objets || collection.objets.length === 0) {
        alert('Cette collection est vide.');
        return;
      }
      
      // Get the objects in this collection
      const collectionObjects = window.OBJETS.objets.filter(obj => 
        collection.objets.includes(obj.numero)
      );
      
      // Create a selection modal with dropdown
      this.showObjectSelectionModal(
        `Retirer un objet de la collection "${collection.nom}"`,
        collectionObjects,
        (selectedObject) => {
          // Remove the object from the collection
          const objectIndex = collection.objets.indexOf(selectedObject.numero);
          if (objectIndex !== -1) {
            collection.objets.splice(objectIndex, 1);
            
            // Show notification
            if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
              JdrApp.modules.storage.showNotification(`â– Objet "${selectedObject.nom}" retirÃ© de la collection "${collection.nom}"`, 'success');
            }
            
            // Refresh the current collection view
            this.displayCollection(collectionId);
          }
        }
      );
    },

    showCollectionsGrid() {
      // Hide collection results and show collections grid only in dev mode
      const resultsContainer = document.getElementById('collection-results');
      const availableCollections = document.getElementById('available-collections');
      const searchInput = document.getElementById('collection-search-input');
      
      if (resultsContainer) {
        resultsContainer.style.display = 'none';
      }
      
      // Only show collections grid in dev mode
      const isDevMode = this.isDevModeActive();
      if (availableCollections) {
        availableCollections.style.display = isDevMode ? 'block' : 'none';
      }
      
      // Clear the search input
      if (searchInput) {
        searchInput.value = '';
      }
      
      // Refresh the collections grid to ensure it's up to date if in dev mode
      if (isDevMode) {
        this.generateCollectionsGrid();
      }
    },

    showObjectSelectionModal(title, objects, onSelectCallback) {
      // Remove any existing modal
      const existingModal = document.querySelector('#object-selection-modal');
      if (existingModal) {
        existingModal.remove();
      }

      // Create modal HTML
      const modal = document.createElement('dialog');
      modal.id = 'object-selection-modal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        border: 3px solid #8B4513;
        border-radius: 12px;
        padding: 0;
        background: transparent !important;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5) !important;
      `;

      const selectOptions = objects
        .map(obj => `<option value="${obj.numero}">NÂ°${obj.numero} - ${obj.nom}</option>`)
        .join('');

      modal.innerHTML = `
        <div style="
          background: white; 
          border-radius: 12px; 
          padding: 1.5rem; 
          border: 3px solid #8B4513;
          font-family: inherit;
          font-size: 16px;
        ">
          <h2 style="
            color: #8B4513; 
            font-family: 'Cinzel', serif; 
            margin: 0 0 1rem 0; 
            text-align: center;
          ">${title}</h2>
          
          <div style="margin: 1rem 0;">
            <label for="object-select" style="
              display: block; 
              margin-bottom: 0.5rem; 
              color: #8B4513; 
              font-weight: bold;
            ">SÃ©lectionnez un objet :</label>
            <select id="object-select" style="
              width: 100%; 
              padding: 0.5rem; 
              border: 2px solid #8B4513; 
              border-radius: 8px; 
              font-size: 16px;
              font-family: inherit;
            ">
              <option value="">-- Choisissez un objet --</option>
              ${selectOptions}
            </select>
          </div>
          
          <div style="
            display: flex; 
            gap: 1rem; 
            justify-content: center; 
            margin-top: 1.5rem;
          ">
            <button class="btn-confirm-selection" style="
              background: #10B981; 
              color: white; 
              border: none; 
              padding: 0.75rem 1.5rem; 
              border-radius: 8px; 
              cursor: pointer; 
              font-weight: bold;
            ">Confirmer</button>
            <button class="btn-cancel-selection" style="
              background: #6B7280; 
              color: white; 
              border: none; 
              padding: 0.75rem 1.5rem; 
              border-radius: 8px; 
              cursor: pointer; 
              font-weight: bold;
            ">Annuler</button>
          </div>
        </div>
      `;

      // Add to body and show
      document.body.appendChild(modal);
      modal.showModal();

      // Set up event handlers
      const select = modal.querySelector('#object-select');
      const confirmBtn = modal.querySelector('.btn-confirm-selection');
      const cancelBtn = modal.querySelector('.btn-cancel-selection');

      confirmBtn.addEventListener('click', () => {
        const selectedNumero = parseInt(select.value);
        if (selectedNumero) {
          const selectedObject = objects.find(obj => obj.numero === selectedNumero);
          if (selectedObject && onSelectCallback) {
            onSelectCallback(selectedObject);
          }
        } else {
          alert('Veuillez sÃ©lectionner un objet.');
          return;
        }
        modal.close();
        modal.remove();
      });

      cancelBtn.addEventListener('click', () => {
        modal.close();
        modal.remove();
      });

      // Handle ESC key
      modal.addEventListener('close', () => {
        modal.remove();
      });
    },

    ensureDevModeClasses() {
      // Ensure the body has the correct dev mode class
      const isDevMode = JdrApp && JdrApp.utils && JdrApp.utils.isDevMode ? JdrApp.utils.isDevMode() : false;
      
      if (isDevMode) {
        document.body.classList.remove('dev-off');
        document.body.classList.add('dev-on');
      } else {
        document.body.classList.remove('dev-on');
        document.body.classList.add('dev-off');
      }
      
      // Force hide image buttons on collections page if not in dev mode
      if (!isDevMode) {
        const collectionItems = document.getElementById('collection-items');
        if (collectionItems) {
          const imageButtons = collectionItems.querySelectorAll('.illus label.up, .illus button.rm');
          imageButtons.forEach(button => {
            button.style.setProperty('display', 'none', 'important');
          });
        }
      }
    },

    getCollectionsDescription() {
      return JdrApp.data.customPageDescriptions['collections-objets'] || 'Recherchez et explorez des collections d\'objets organisÃ©es par thÃ¨me';
    },

    generateCollectionsGrid() {
      if (!window.COLLECTIONS || !window.COLLECTIONS.collections) {
        return;
      }
      
      // Use defined collections instead of extracting from tags
      const collections = window.COLLECTIONS.collections;
      
      // Collection icons are now defined in the collections data itself
      
      const isDevMode = this.isDevModeActive();
      const collectionsGrid = document.querySelector('.collections-grid');
      
      if (!collectionsGrid) return;
      
      // Generate HTML for each collection
      const collectionsHTML = collections
        .map((collection) => {
          const count = collection.objets ? collection.objets.length : 0;
          return `
            <div class="collection-card" data-collection="${collection.id}">
              <div class="collection-icon">${collection.icon}</div>
              <h3>${collection.nom}</h3>
              <p>${count} objet(s)</p>
              <p class="collection-description">${collection.description}</p>
              ${isDevMode ? `
                <div class="collection-dev-controls">
                  <button class="btn small edit-collection-btn" data-collection="${collection.id}" title="Modifier cette collection">âœï¸ Modifier</button>
                  <button class="btn small delete-collection-btn" data-collection="${collection.id}" title="Supprimer cette collection">ğŸ—‘ï¸ Supprimer</button>
                </div>
              ` : ''}
            </div>
          `;
        }).join('');
      
      // Add "create new collection" button in dev mode
      const devActions = isDevMode ? `
        <div class="collection-card new-collection-card">
          <div class="collection-icon">â•</div>
          <h3>Nouvelle Collection</h3>
          <p>CrÃ©er une collection</p>
          <button class="btn small create-collection-btn">â• CrÃ©er</button>
        </div>
      ` : '';
      
      collectionsGrid.innerHTML = collectionsHTML + devActions;
      
      // console.log('ğŸ“¦ Collections grid generated:', {
      //   collectionsCount: collections.length,
      //   hasDevActions: !!devActions,
      //   gridContent: collectionsGrid.innerHTML.length + ' chars'
      // });
      
      // Setup event listeners for collections (always active)
      this.setupCollectionEventListeners();
      
      // Setup dev-specific controls only in dev mode
      if (isDevMode) {
        this.setupCollectionManagementControls();
      }
    },

    isDevModeActive() {
      // Multiple ways to detect dev mode for robustness
      return (
        (JdrApp && JdrApp.utils && JdrApp.utils.isDevMode && JdrApp.utils.isDevMode()) ||
        document.body.classList.contains('dev-on') ||
        (JdrApp.modules && JdrApp.modules.editor && JdrApp.modules.editor.isDevMode)
      );
    },

    setupCollectionEventListeners() {
      // Collection card click listeners (open collection for viewing/editing)
      const collectionCards = document.querySelectorAll('.collection-card:not(.new-collection-card)');
      
      collectionCards.forEach(card => {
        card.addEventListener('click', (e) => {
          // Don't trigger if clicking on control buttons
          if (e.target.closest('.collection-dev-controls')) {
            return;
          }
          
          const collectionId = card.getAttribute('data-collection');
          if (collectionId) {
            // Find collection to get its name
            const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
            if (collection) {
              // Fill search input with collection name
              const searchInput = document.getElementById('collection-search-input');
              if (searchInput) {
                searchInput.value = collection.nom;
              }
              
              // Open the collection
              this.displayCollection(collectionId);
            }
          }
        });
      });
    },

    setupCollectionManagementControls() {
      // Create new collection button
      const createBtn = document.querySelector('.create-collection-btn');
      const editBtns = document.querySelectorAll('.edit-collection-btn');
      const deleteBtns = document.querySelectorAll('.delete-collection-btn');
      
      // console.log('ğŸ›ï¸ Setting up collection controls:', {
      //   createBtn: !!createBtn,
      //   editBtns: editBtns.length,
      //   deleteBtns: deleteBtns.length
      // });
      
      if (createBtn) {
        createBtn.addEventListener('click', () => {
          // console.log('â• Create collection clicked');
          this.createNewCollection();
        });
      }

      // Edit collection buttons (rename)
      editBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const collectionName = btn.getAttribute('data-collection');
          // console.log('âœï¸ Edit collection clicked:', collectionName);
          this.renameCollection(collectionName);
        });
      });

      // Delete collection buttons
      deleteBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const collectionName = btn.getAttribute('data-collection');
          // console.log('ğŸ—‘ï¸ Delete collection clicked:', collectionName);
          this.deleteCollection(collectionName);
        });
      });
    },

    createNewCollection() {
      const collectionName = prompt('Nom de la nouvelle collection:');
      if (!collectionName || !collectionName.trim()) return;
      
      const trimmedName = collectionName.trim();
      
      // Generate an ID from the name
      const collectionId = trimmedName.toLowerCase().replace(/[^a-z0-9]/g, '-');
      
      // Check if collection already exists
      const existingCollection = window.COLLECTIONS.collections.find(coll => 
        coll.id === collectionId || coll.nom.toLowerCase() === trimmedName.toLowerCase()
      );
      
      if (existingCollection) {
        alert(`La collection "${trimmedName}" existe dÃ©jÃ .`);
        return;
      }
      
      // Get collection description and icon
      const collectionDescription = prompt('Description de la collection:', 'Nouvelle collection d\'objets');
      const collectionIcon = prompt('IcÃ´ne de la collection (emoji):', 'ğŸ“¦');
      
      // Create new collection object
      const newCollection = {
        id: collectionId,
        nom: trimmedName,
        description: collectionDescription || 'Nouvelle collection d\'objets',
        icon: collectionIcon || 'ğŸ“¦',
        objets: []
      };
      
      // Add to collections data
      window.COLLECTIONS.collections.push(newCollection);
      
      // Refresh the grid
      this.generateCollectionsGrid();
      
      if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
        JdrApp.modules.storage.showNotification(`âœ… Collection "${trimmedName}" crÃ©Ã©e avec succÃ¨s!`, 'success');
      }
    },

    renameCollection(collectionId) {
      // Find the collection by ID
      const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
      if (!collection) {
        alert('Collection introuvable.');
        return;
      }
      
      const newName = prompt(`Nouveau nom pour la collection "${collection.nom}":`, collection.nom);
      if (!newName || !newName.trim() || newName.trim() === collection.nom) return;
      
      const trimmedNewName = newName.trim();
      
      // Check if new name already exists
      const existingCollection = window.COLLECTIONS.collections.find(coll => 
        coll.id !== collectionId && coll.nom.toLowerCase() === trimmedNewName.toLowerCase()
      );
      
      if (existingCollection) {
        alert(`La collection "${trimmedNewName}" existe dÃ©jÃ .`);
        return;
      }
      
      // Update collection name
      collection.nom = trimmedNewName;
      
      // Refresh the collections grid
      this.generateCollectionsGrid();
      
      if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
        JdrApp.modules.storage.showNotification(`âœ… Collection renommÃ©e en "${trimmedNewName}"`, 'success');
      }
    },

    deleteCollection(collectionId) {
      // Find the collection by ID
      const collection = window.COLLECTIONS.collections.find(coll => coll.id === collectionId);
      if (!collection) {
        alert('Collection introuvable.');
        return;
      }
      
      const objectCount = collection.objets ? collection.objets.length : 0;
      
      const confirmDelete = confirm(
        `ÃŠtes-vous sÃ»r de vouloir supprimer la collection "${collection.nom}"?\n` +
        `Cette collection contient ${objectCount} objet(s).\n` +
        `Les objets ne seront pas supprimÃ©s, seulement la collection sera retirÃ©e.`
      );
      
      if (!confirmDelete) return;
      
      // Remove the collection from the collections array
      const collectionIndex = window.COLLECTIONS.collections.findIndex(coll => coll.id === collectionId);
      if (collectionIndex !== -1) {
        window.COLLECTIONS.collections.splice(collectionIndex, 1);
        
        // Refresh the collections grid
        this.generateCollectionsGrid();
        
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification(`ğŸ—‘ï¸ Collection "${collection.nom}" supprimÃ©e`, 'success');
        }
      }
    },

    setupDevModeListener() {
      // Listen for dev mode changes via EventBus
      if (window.EventBus && window.Events) {
        EventBus.on(Events.EDITOR_TOGGLE, (payload) => {
          // console.log('ğŸ”„ Dev mode changed via EventBus:', payload.enabled);
          setTimeout(() => this.refreshCollectionsView(), 50);
        });
      }
      
      // Also listen for body class changes (fallback)
      if (window.MutationObserver) {
        if (this.devModeObserver) {
          this.devModeObserver.disconnect();
        }
        
        // Track the previous dev mode state to avoid loops
        let lastDevMode = this.isDevModeActive();
        
        this.devModeObserver = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
              const currentDevMode = this.isDevModeActive();
              
              // Only refresh if dev mode actually changed
              if (currentDevMode !== lastDevMode) {
                // console.log('ğŸ”„ Body class changed, refreshing views - Dev mode:', currentDevMode);
                lastDevMode = currentDevMode;
                setTimeout(() => this.refreshCollectionsView(), 100);
              }
            }
          });
        });
        
        this.devModeObserver.observe(document.body, {
          attributes: true,
          attributeFilter: ['class']
        });
      }
    },

    refreshCollectionsView() {
      const currentHash = window.location.hash;
      
      // Refresh collections page if we're on it
      if (currentHash === '#/collections-objets') {
        const availableCollections = document.getElementById('available-collections');
        const isDevMode = this.isDevModeActive();
        
        // console.log('ğŸ”„ Refreshing collections view - Dev mode:', isDevMode);
        
        // Regenerate the collections grid
        this.generateCollectionsGrid();
        
        // Update visibility
        if (availableCollections) {
          if (isDevMode) {
              availableCollections.style.display = 'block';
          } else {
              availableCollections.style.display = 'none';
          }
        }
      }
      
      // Also refresh objects page if we're on it (for filter visibility)
      if (currentHash === '#/objets') {
        console.log('ğŸ”„ Refreshing objects page due to dev mode change');
        setTimeout(() => {
          this.renderObjectsPage();
        }, 100); // Augmenter le dÃ©lai pour Ãªtre sÃ»r que le dev mode est Ã  jour
      }
    },

    updateCollectionsDescription(newDescription) {
      JdrApp.data.customPageDescriptions['collections-objets'] = newDescription;
      // Also update via ContentFactory for consistency
      if (window.ContentFactory) {
        ContentFactory.updatePageDescription('collections', newDescription);
      }
    },

    renderFeuillePersonnagePage() {
      // Create or find the page element
      let pageElement = document.getElementById('feuille-personnage');
      
      // If the page doesn't exist, create it
      if (!pageElement) {
        pageElement = document.createElement('article');
        pageElement.id = 'feuille-personnage';
        pageElement.setAttribute('data-page', 'feuille-personnage');
        pageElement.className = 'page';
        
        // Insert it into the views container
        const viewsContainer = document.querySelector('#views');
        
        if (viewsContainer) {
          viewsContainer.appendChild(pageElement);
        } else {
          console.error('Views container not found');
          return false;
        }
      }
      
      // Create full PDF content for all versions  
      const feuillePersonnageContent = `
        <div class="page-header">
          <h1>ğŸ“‹ Feuille de personnage</h1>
        </div>
        
          
          
          <!-- PDF Info and Actions -->
          <div class="pdf-info-container" style="width: 100%; margin: 1rem 0; padding: 2rem; border: 2px solid var(--bronze); border-radius: 12px; background: var(--card); text-align: center;">
            <h3 style="color: var(--gold); font-family: 'Cinzel', serif; margin: 0 0 1rem 0;">ğŸ“„ Feuille de personnage PDF</h3>
            <p style="color: var(--text); margin: 1rem 0;">Feuille de personnage complÃ¨te de 3 pages pour vos aventures BabJDR</p>
            
            <div class="pdf-preview-actions" style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; margin-top: 1.5rem;">
              <button id="open-pdf-new-tab" class="btn-base" style="background: var(--bronze); color: white;">
                ğŸ“– Voir le PDF
              </button>
              <button id="download-pdf-direct" class="btn-base" style="background: var(--emerald); color: white;">
                ğŸ“¥ TÃ©lÃ©charger
              </button>
              <button id="print-pdf-direct" class="btn-base" style="background: var(--gold); color: white;">
                ğŸ–¨ï¸ Imprimer
              </button>
            </div>
            
            <p style="color: var(--text-muted); font-size: 0.9rem; margin-top: 1rem;">
              ğŸ’¡ Astuce : Cliquez sur "Voir le PDF" pour l'ouvrir dans un nouvel onglet
            </p>
          </div>
          
          <div class="pdf-fallback" style="display: none; text-align: center; padding: 2rem; background: var(--accent-bg); border-radius: 8px; margin: 1rem 0;">
            <h3 style="color: var(--bronze);">ğŸ“„ Feuille de personnage BabJDR</h3>
            <p style="color: var(--accent-ink); margin: 1rem 0;">
              Votre navigateur ne peut pas afficher le PDF directement. Utilisez les boutons ci-dessous:
            </p>
            
            <div class="pdf-info" style="background: white; border: 1px solid var(--rule); border-radius: 8px; padding: 1.5rem; margin: 1rem 0; text-align: left;">
              <h4 style="color: var(--bronze); margin-top: 0;">ğŸ“ Contenu de la feuille:</h4>
              <ul style="color: var(--accent-ink); line-height: 1.8;">
                <li><strong>Informations du personnage:</strong> Nom, classe, niveau, expÃ©rience</li>
                <li><strong>CaractÃ©ristiques:</strong> Force, Endurance, AgilitÃ©, Intelligence, VolontÃ©, Chance</li>
                <li><strong>Statistiques dÃ©rivÃ©es:</strong> Vie, Mana, Initiative, Fortune, Armure, Esquive</li>
                <li><strong>CompÃ©tences:</strong> Hardiesse, Finesse, Coordination, RÃ©flexion, Ã‰loquence</li>
                <li><strong>Ã‰lÃ©ments:</strong> Armure Ã©lÃ©mentaire (Feu, Eau, Terre, Air, LumiÃ¨re, Nuit, Divin, MalÃ©fique)</li>
                <li><strong>Sorts et capacitÃ©s:</strong> Liste des sorts connus et dons acquis</li>
                <li><strong>Inventaire:</strong> Consommables et sac gÃ©nÃ©ral</li>
                <li><strong>Background:</strong> Histoire, apparence et personnalitÃ© du personnage</li>
              </ul>
            </div>
          </div>
          
        </div>
        
        <div class="character-sheet-info" style="margin-top: 1rem; text-align: center; color: var(--accent-ink);">
          <p><strong>ğŸ’¡ Info:</strong> La feuille de personnage est un PDF imprimable de 3 pages contenant tous les champs nÃ©cessaires pour votre personnage.</p>
        </div>
      `;
      
      // Insert content into the page
      pageElement.innerHTML = feuillePersonnageContent;
      
      // Setup event listeners for print and download functionality
      this.setupCharacterSheetActions();
      
      
      // Show and activate page
      this.show('feuille-personnage');
      this.updateActiveStates('feuille-personnage');
      
      return true;
    },

    setupCharacterSheetActions() {
      const pdfUrl = 'https://github.com/ben-128/BabJdr/raw/master/data/feuille-personnage.pdf';
      
      // Setup main action buttons
      const openBtn = document.getElementById('open-character-sheet');
      const printBtn = document.getElementById('print-character-sheet');
      const downloadBtn = document.getElementById('download-character-sheet');
      
      // Setup preview action buttons
      const openTabBtn = document.getElementById('open-pdf-new-tab');
      const printDirectBtn = document.getElementById('print-pdf-direct');
      const downloadDirectBtn = document.getElementById('download-pdf-direct');
      
      // Check if PDF embed is supported and handle fallback
      const pdfEmbed = document.getElementById('pdf-embed');
      const pdfFallback = document.querySelector('.pdf-fallback');
      
      if (pdfEmbed) {
        // Add load error handler for PDF embed
        pdfEmbed.addEventListener('error', () => {
          // Hide embed and show fallback
          pdfEmbed.style.display = 'none';
          if (pdfFallback) {
            pdfFallback.style.display = 'block';
          }
        });
        
        // Test if PDF can be loaded after a delay
        setTimeout(() => {
          // Check if the embed has loaded properly
          try {
            const embedDoc = pdfEmbed.contentDocument || pdfEmbed.contentWindow.document;
            if (!embedDoc || embedDoc.body.innerHTML.includes('%PDF')) {
              // PDF is showing as raw text, use fallback
              pdfEmbed.style.display = 'none';
              if (pdfFallback) {
                pdfFallback.style.display = 'block';
              }
            }
          } catch (e) {
            // Can't access content, probably loaded correctly
          }
        }, 1000);
      }
      
      // Open PDF in new tab
      const openPDF = () => {
        window.open(pdfUrl, '_blank');
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification('ğŸ“– PDF ouvert dans un nouvel onglet', 'success');
        }
      };
      
      // Print PDF
      const printPDF = () => {
        const printWindow = window.open(pdfUrl, '_blank');
        if (printWindow) {
          printWindow.focus();
          setTimeout(() => {
            try {
              printWindow.print();
            } catch (e) {
              alert('PDF ouvert. Utilisez Ctrl+P pour imprimer.');
            }
          }, 1000);
        } else {
          alert('Impossible d\'ouvrir le PDF. VÃ©rifiez que les popups ne sont pas bloquÃ©s.');
        }
      };
      
      // Download PDF
      const downloadPDF = () => {
        const link = document.createElement('a');
        link.href = pdfUrl;
        link.download = 'Feuille-Personnage-BabJDR.pdf';
        link.style.display = 'none';
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        
        if (JdrApp.modules.storage && JdrApp.modules.storage.showNotification) {
          JdrApp.modules.storage.showNotification('ğŸ“¥ TÃ©lÃ©chargement en cours...', 'success');
        }
      };
      
      // Attach event listeners
      if (openBtn) openBtn.addEventListener('click', openPDF);
      if (printBtn) printBtn.addEventListener('click', printPDF);
      if (downloadBtn) downloadBtn.addEventListener('click', downloadPDF);
      
      if (openTabBtn) openTabBtn.addEventListener('click', openPDF);
      if (printDirectBtn) printDirectBtn.addEventListener('click', printPDF);
      if (downloadDirectBtn) downloadDirectBtn.addEventListener('click', downloadPDF);
    }
  
  };

})();

// ============================================================================
// JDR-BAB APPLICATION - RENDERER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // CONTENT RENDERER MODULE
  // ========================================
  JdrApp.modules.renderer = {
    currentSearch: '',
    
    init() {
      // Delay content generation to ensure all configurations are loaded
      setTimeout(() => {
        this.generateContent();
        this.autoLoadImages();
      }, 10);
      this.setupEventListeners();
    },

    setupEventListeners() {
      EventBus.on(Events.PAGE_RENDER, (payload) => {
        if (payload.type === 'category') {
          this.renderCategoryPage(payload.categoryType, payload.category);
        }
      });

      EventBus.on(Events.CONTENT_ADD, () => {
        setTimeout(() => this.autoLoadImages(), 100);
      });
    },

    generateContent() {
      JdrApp.modules.router.generateTOC.call(JdrApp.modules.router);
      this.generateArticles();
      this.generateDevToolbox();
      
      if (JdrApp.modules.editor) {
        setTimeout(() => {
          if (JdrApp.modules.editor.isDevMode) {
            JdrApp.modules.editor.forceShowAllEditButtons();
          } else {
            JdrApp.modules.editor.forceHideAllEditButtons();
          }
        }, 100);
      }
    },

    generateArticles() {
      const viewsContainer = document.querySelector('#views');
      if (!viewsContainer) return;

      let articlesHTML = '';
      articlesHTML += this.generateStaticPages();
      articlesHTML += this.generateClassPages();
      articlesHTML += this.generateCategoryPages();
      articlesHTML += this.generateMonstersPage();

      viewsContainer.innerHTML = articlesHTML;
      setTimeout(() => {
        this.autoLoadImages();
        // Reapply dev mode state to new elements
        this.applyDevModeToNewContent();
        // Attach image events for standalone compatibility
        if (JdrApp.modules.editor && JdrApp.modules.editor.attachImageEvents) {
          JdrApp.modules.editor.attachImageEvents();
        }
        // Create proxy buttons for new content
        if (JdrApp.modules.editor && JdrApp.modules.editor.isDevMode) {
          setTimeout(() => JdrApp.modules.editor.createProxyButtons(), 100);
        }
        // Auto-populate monsters page if it exists
        if (document.getElementById('monsters-container')) {
          setTimeout(() => this.populateMonstersPage(), 50);
        }
      }, 100);
    },

    applyDevModeToNewContent() {
      if (JdrApp.modules.editor) {
        if (JdrApp.utils.isDevMode()) {
          JdrApp.modules.editor.forceShowAllEditButtons();
        } else {
          JdrApp.modules.editor.forceHideAllEditButtons();
        }
      }
    },


    generateStaticPages() {
      let html = '';
      if (window.STATIC_PAGES) {
        Object.entries(window.STATIC_PAGES).forEach(([pageId, pageData]) => {
          html += PageBuilder.buildStaticPage(pageId, pageData);
        });
      }
      return html;
    },


    generateClassPages() {
      if (!window.CLASSES) return '';
      
      return window.CLASSES.map(classe => 
        PageBuilder.buildClassPage(classe)
      ).join('');
    },

    generateCategoryPages() {
      let html = '';
      
      if (window.SORTS) {
        html += window.SORTS.map(category => 
          PageBuilder.buildCategoryPage('spell', category)
        ).join('');
      }

      if (window.DONS) {
        html += window.DONS.map(category => 
          PageBuilder.buildCategoryPage('don', category)
        ).join('');
      }

      // Generate single objects page (different from category pages)
      if (window.OBJETS) {
        html += PageBuilder.buildSingleObjectPage(window.OBJETS);
      }

      return html;
    },

    generateMonstersPage() {
      if (!window.MONSTRES) return '';
      
      return PageBuilder.buildSingleMonsterPage(window.MONSTRES);
    },


    renderCategoryPage(type, category) {
      const config = window.ContentTypes[type];
      
      // Handle special case for objects (single page, no category name)
      let pageId;
      if (type === 'objet') {
        pageId = 'objets'; // Objects use fixed page ID
      } else {
        pageId = `${config.container}-${JdrApp.utils.data.sanitizeId(category.nom)}`;
      }
      
      let article = document.querySelector(`article[data-page="${pageId}"]`);
      
      // Create article if it doesn't exist (for dynamically created categories)
      if (!article) {
        article = document.createElement('article');
        article.setAttribute('data-page', pageId);
        article.className = 'active'; // Make it active since we're showing it
        
        const viewsContainer = document.querySelector('#views');
        if (viewsContainer) {
          viewsContainer.appendChild(article);
        } else {
          // Views container not found
          return;
        }
      }
      
      const newContent = PageBuilder.buildCategoryPage(type, category);
      const parser = new DOMParser();
      const newDoc = parser.parseFromString(newContent, 'text/html');
      const newArticle = newDoc.querySelector('article');
      
      if (newArticle) {
        article.innerHTML = newArticle.innerHTML;
        
        // Make sure only this article is active
        document.querySelectorAll('article').forEach(a => a.classList.remove('active'));
        article.classList.add('active');
        
        // Plus simple et plus fiable
        this.autoLoadImages();
        
        // Attach image events for standalone compatibility
        if (JdrApp.modules.editor && JdrApp.modules.editor.attachImageEvents) {
          JdrApp.modules.editor.attachImageEvents();
        }
        
        // Ensure dev mode state is applied after content change
        setTimeout(() => {
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          } else if (window.STANDALONE_VERSION) {
            // FORCE STANDALONE MODE: Ensure dev-off class and hide all dev buttons
            document.body.className = 'dev-off';
          }
        }, 50);
      }
    },

    renderSortCategory(page) {
      const categoryId = page.replace('sorts-', '');
      const category = window.SORTS?.find(cat => 
        JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
      );
      
      if (category) {
        this.renderCategoryPage('spell', category);
      }
    },

    generateDevToolbox() {
      const devToolbox = JdrApp.utils.dom.$('#devToolbox');
      if (!devToolbox) return;

      const toolboxHTML = `
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--rule);">
          <span style="font-size: 18px;">ğŸ› </span>
          <strong style="color: var(--accent-ink); font-family: 'Cinzel', serif;">Outils de dÃ©veloppement</strong>
        </div>
        
        <div style="margin-bottom: 12px;">
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">âœï¸ Ã‰dition</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="saveAndExport" title="Sauvegarder et exporter tout en ZIP">ğŸ’¾ Export ZIP</button>
          </div>
        </div>
        
        <div style="margin-bottom: 12px;">
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">ğŸ“ CrÃ©ation</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="addCategory" title="CrÃ©er une nouvelle catÃ©gorie/page">ğŸ“„ Nouvelle page</button>
            <button class="btn small" id="addSpellCategory" title="CrÃ©er une nouvelle catÃ©gorie de sorts">ğŸ”® CatÃ©gorie de sorts</button>
            <button class="btn small" id="addDonCategory" title="CrÃ©er une nouvelle catÃ©gorie de dons">ğŸ–ï¸ CatÃ©gorie de dons</button>
          </div>
        </div>
        
        <div>
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">ğŸ­ Ressources</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="elementsBtn" title="Choisir un Ã©lÃ©ment pour copier sa balise HTML colorÃ©e">ğŸ¨ Ã‰lÃ©ments</button>
            <button class="btn small" id="etatsBtn" title="Choisir un Ã©tat pour copier sa balise HTML avec tooltip">âš¡ Ã‰tats</button>
            <button class="btn small" id="spellLinksBtn" title="CrÃ©er un lien vers un sort avec aperÃ§u">ğŸ”® Liens sorts</button>
            <button class="btn small" id="pageLinksBtn" title="CrÃ©er un lien vers une page du projet">ğŸ”— Liens pages</button>
          </div>
        </div>
      `;

      devToolbox.innerHTML = toolboxHTML;
    },

    autoLoadImages() {
      if (JdrApp.modules.images) {
        return JdrApp.modules.images.autoLoadImages();
      }
      return 0;
    },

    regenerateCurrentPage() {
      // Find the currently active article
      const activeArticle = document.querySelector('article.active');
      if (!activeArticle) return;

      const pageId = activeArticle.dataset.page;
      if (!pageId) return;

      // Determine what type of page it is and regenerate only that page
      if (pageId.startsWith('sorts-')) {
        const categoryId = pageId.replace('sorts-', '');
        const category = window.SORTS?.find(cat => 
          JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
        );
        if (category) {
          this.renderCategoryPage('spell', category);
        }
      } else if (pageId.startsWith('dons-')) {
        const categoryId = pageId.replace('dons-', '');
        const category = window.DONS?.find(cat => 
          JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
        );
        if (category) {
          this.renderCategoryPage('don', category);
        }
      } else if (pageId === 'objets') {
        // Regenerate objects page using the generic approach
        const newHTML = this.generatePageContent(pageId);
        if (newHTML) {
          activeArticle.innerHTML = newHTML;
          this.autoLoadImages();
          
          // Apply dev mode state immediately
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          } else if (window.STANDALONE_VERSION) {
            // FORCE STANDALONE MODE: Ensure dev-off class and hide all dev buttons
            document.body.className = 'dev-off';
          }
        }
      } else {
        // For class pages, static pages, etc. - regenerate the specific content
        const newHTML = this.generatePageContent(pageId);
        if (newHTML) {
          activeArticle.innerHTML = newHTML;
          this.autoLoadImages();
          
          // Apply dev mode state immediately
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          } else if (window.STANDALONE_VERSION) {
            // FORCE STANDALONE MODE: Ensure dev-off class and hide all dev buttons
            document.body.className = 'dev-off';
          }
        }
      }
    },

    generatePageContent(pageId) {
      // Generate content for a specific page without affecting navigation
      if (window.CLASSES) {
        const classe = window.CLASSES.find(c => JdrApp.utils.data.sanitizeId(c.nom) === pageId);
        if (classe) {
          const content = PageBuilder.buildClassPage(classe);
          const parser = new DOMParser();
          const doc = parser.parseFromString(content, 'text/html');
          const article = doc.querySelector('article');
          return article ? article.innerHTML : null;
        }
      }

      if (window.STATIC_PAGES && window.STATIC_PAGES[pageId]) {
        const content = PageBuilder.buildStaticPage(pageId, window.STATIC_PAGES[pageId]);
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        const article = doc.querySelector('article');
        return article ? article.innerHTML : null;
      }

      // Handle objects page
      if (pageId === 'objets' && window.OBJETS) {
        const content = PageBuilder.buildSingleObjectPage(window.OBJETS);
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        const article = doc.querySelector('article');
        return article ? article.innerHTML : null;
      }

      return null;
    },

    populateMonstersPage() {
      const monstersContainer = document.getElementById('monstres-container');
      if (!monstersContainer || !window.MONSTRES) return;

      // Clear existing content
      monstersContainer.innerHTML = '';

      // Generate monster cards directly
      const cardsHTML = window.MONSTRES.map((monster, index) => 
        CardBuilder.create('monster', monster, 'monstres', index).build()
      ).join('');
      
      monstersContainer.innerHTML = cardsHTML;

      // Apply dev mode styling and load images
      this.applyDevModeToNewContent();
      this.autoLoadImages();
    },

    renderUnifiedContentPage(contentType, data) {
      // This method dynamically creates a unified content page (like objets or monstres)
      // using the PageBuilder with the appropriate build method
      let content = '';
      let pageId = '';
      
      if (contentType === 'objet' && data) {
        content = PageBuilder.buildSingleObjectPage(data);
        pageId = 'objets';
      } else if (contentType === 'monster' && data) {
        content = PageBuilder.buildSingleMonsterPage(data);
        pageId = 'monstres';
      } else if (contentType === 'tableTresor' && data) {
        content = PageBuilder.buildSingleTableTresorPage(data);
        pageId = 'tables-tresors';
      }
      
      if (content && pageId) {
        // Find or create the specific article element in #views
        const viewsContainer = document.querySelector('#views');
        if (viewsContainer) {
          // Remove existing article for this page if it exists
          const existingArticle = document.querySelector(`article[data-page="${pageId}"]`);
          if (existingArticle) {
            existingArticle.remove();
          }
          
          // Add the new content to the views container
          viewsContainer.insertAdjacentHTML('beforeend', content);
          
          this.autoLoadImages();
          
          // Apply dev mode state with slight delay to ensure DOM is processed
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            setTimeout(() => {
              if (JdrApp.modules.editor.isDevMode) {
                JdrApp.modules.editor.forceShowAllEditButtons();
              } else {
                JdrApp.modules.editor.forceHideAllEditButtons();
              }
            }, 10);
          }
        }
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - UNIFIED EDITOR SYSTEM
// ============================================================================

(() => {
  "use strict";

  class UnifiedEditor {
    constructor() {
      this.currentEditSession = null;
    }

    /*
     * IMPORTANT: Content Restoration Best Practices
     * =============================================
     * ALWAYS use restoreElementContent() for any content that has been edited
     * NEVER directly assign to innerHTML in editing contexts
     * This prevents HTML tags from being displayed as visible text
     */

    static getInstance() {
      if (!UnifiedEditor.instance) {
        UnifiedEditor.instance = new UnifiedEditor();
      }
      return UnifiedEditor.instance;
    }

    // Parse edit context from DOM element
    parseEditContext(element) {
      // Force reset any stuck elements FIRST
      this.forceResetAllEditingElements();
      
      const editableElement = element.classList.contains('editable-section') 
        ? element.querySelector('.editable') 
        : element;

      if (!editableElement) {
        return null;
      }

      const editType = editableElement.dataset.editType;
      const editSection = editableElement.dataset.editSection;
      
      // For simplified HTML editing, everything is treated as HTML content
      if (editType === 'html') {
        return this.parseHtmlEditContext(element, editSection);
      }
      
      // Generic editing - use contextual detection, don't force type
      if (editType === 'generic') {
        // Use the full parsing logic and keep the detected contentType
        return this.parseHtmlEditContext(element, editSection);
      }

      // Tags editing for objects
      if (editType === 'tags') {
        return this.parseTagsEditContext(element, editSection);
      }

      // Select element editing (for dropdowns like monster elements)
      if (editType === 'select') {
        return this.parseSelectEditContext(element, editSection);
      }

      // All legacy edit types have been migrated to 'generic'
      return null;
    }

    parseHtmlEditContext(element, editSection) {
      // Detect context automatically based on page structure
      // Order matters: check most specific first (spells, dons, classes, then static pages)
      
      // Check if we're in a spell card first (most specific)
      const spellCard = element.closest('.card[data-spell-name]');
      if (spellCard) {
        const spellName = spellCard.dataset.spellName;
        const spellIndex = spellCard.dataset.spellIndex;
        const categoryName = spellCard.dataset.categoryName;
        
        // Use class-based detection for spell sections to avoid index mismatches
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        // Detect the spell property from the element's classes or data attributes
        let spellEditSection = 'description'; // default fallback
        
        // Check for specific section classes to determine the property
        if (editableElement.classList.contains('spell-name') || editableElement.dataset.editSection === 'spell-name') {
          spellEditSection = 'nom';
        } else if (editableElement.classList.contains('spell-description') || editableElement.dataset.editSection === 'spell-description') {
          spellEditSection = 'description';
        } else if (editableElement.classList.contains('spell-prerequis') || editableElement.dataset.editSection === 'spell-prerequis') {
          spellEditSection = 'prerequis';
        } else if (editableElement.classList.contains('spell-portee') || editableElement.dataset.editSection === 'spell-portee') {
          spellEditSection = 'portee';
        } else if (editableElement.classList.contains('spell-mana') || editableElement.dataset.editSection === 'spell-mana') {
          spellEditSection = 'coutMana';
        } else if (editableElement.classList.contains('spell-temps-incantation') || editableElement.dataset.editSection === 'spell-temps-incantation') {
          spellEditSection = 'tempsIncantation';
        } else if (editableElement.classList.contains('spell-resistance') || editableElement.dataset.editSection === 'spell-resistance') {
          spellEditSection = 'resistance';
        } else if (editableElement.classList.contains('spell-effect-normal') || editableElement.dataset.editSection === 'spell-effect-normal') {
          spellEditSection = 'effetNormal';
        } else if (editableElement.classList.contains('spell-effect-critical') || editableElement.dataset.editSection === 'spell-effect-critical') {
          spellEditSection = 'effetCritique';
        }
        
        return {
          contentType: 'spell',
          itemIdentifier: spellName,
          itemIndex: spellIndex,
          categoryName: categoryName,
          property: 'html',
          editType: 'html',
          editSection: spellEditSection,
          config: window.ContentTypes.spell,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a don card
      const donCard = element.closest('.card[data-don-name]');
      if (donCard) {
        const donName = donCard.dataset.donName;
        const donIndex = donCard.dataset.donIndex;
        const categoryName = donCard.dataset.categoryName;
        
        // Use index-based detection for don sections
        const allEditables = Array.from(donCard.querySelectorAll('.editable'));
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const currentIndex = allEditables.indexOf(editableElement);
        
        // Map index to don property based on CardBuilder order
        // 0=nom, 1=description, 2=prerequis, 3=cout
        const donSections = ['nom', 'description', 'prerequis', 'cout'];
        const donEditSection = donSections[currentIndex] || 'description';
        
        return {
          contentType: 'don',
          itemIdentifier: donName,
          itemIndex: donIndex,
          categoryName: categoryName,
          property: 'html',
          editType: 'html',
          editSection: donEditSection,
          config: window.ContentTypes.don,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in an objet card
      const objetCard = element.closest('.card[data-objet-name]');
      if (objetCard) {
        const objetName = objetCard.dataset.objetName;
        const categoryName = objetCard.dataset.categoryName;
        
        // Use index-based detection for objet sections
        const allEditables = Array.from(objetCard.querySelectorAll('.editable'));
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const currentIndex = allEditables.indexOf(editableElement);
        
        // Map index to objet property based on CardBuilder order
        // 0=nom, 1=numero, 2=tags, 3=description, 4=effet, 5=prix, 6=poids
        const objetSections = ['nom', 'numero', 'tags', 'description', 'effet', 'prix', 'poids'];
        const objetEditSection = objetSections[currentIndex] || 'description';
        
        return {
          contentType: 'objet',
          itemIdentifier: objetName,
          categoryName: categoryName,
          property: 'html',
          editType: 'html',
          editSection: objetEditSection,
          config: window.ContentTypes.objet,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        // Use data-item-identifier if available, otherwise fall back to monsterName
        const itemIdentifier = editableElement?.dataset?.itemIdentifier || monsterName;
        
        // Use editSection directly (new format: "monster-fieldName")
        const editSection = editableElement?.dataset?.editSection || 'abilites';
        
        return {
          contentType: 'monster',
          itemIdentifier: itemIdentifier,
          categoryName: categoryName || 'monstres',
          property: 'html',
          editType: 'html', 
          editSection: editSection,
          config: window.ContentTypes.monster,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a table-tresor card
      const tableTresorCard = element.closest('.card[data-table-tresor-name]');
      if (tableTresorCard) {
        const tableName = tableTresorCard.dataset.tableTresorName;
        const categoryName = tableTresorCard.dataset.categoryName;
        
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        // Use data-item-identifier if available, otherwise fall back to tableName
        const itemIdentifier = editableElement?.dataset?.itemIdentifier || tableName;
        
        // Use editSection directly (new format: "table-tresor-fieldName")
        const editSection = editableElement?.dataset?.editSection || 'description';
        
        return {
          contentType: 'tableTresor',
          itemIdentifier: itemIdentifier,
          categoryName: categoryName || 'tables',
          property: 'html',
          editType: 'html', 
          editSection: editSection,
          config: window.ContentTypes.tableTresor,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a class page (before static pages!)
      // IMPORTANT: Exclude static pages even if they have data-page-title
      const classArticle = element.closest('article[data-page-title]:not([data-static-page="true"])');
      if (classArticle) {
        const className = classArticle.dataset.pageTitle;
        
        // Check if we're editing a subclass (look for subclass card)
        const subclassCard = element.closest('.card[data-subclass-name]');
        if (subclassCard) {
          // Determine what part of the subclass we're editing
          let subclassEditSection = 'content';
          
          const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
          
          if (editableElement) {
            const parentSection = editableElement.closest('.editable-section');
            
            // Use index-based detection for subclasses
            const subclassCard = editableElement.closest('.card[data-subclass-name]');
            const allEditables = subclassCard ? Array.from(subclassCard.querySelectorAll('.editable')) : [];
            const currentIndex = allEditables.indexOf(editableElement);
            
            // Map index to property based on subclass structure  
            // UPDATED ORDER: Index 0 = nom (title), Index 1 = description, Index 2 = base (stats), Index 3 = progression, Index 4+ = capacites
            if (element.closest('.stats-grid') || currentIndex === 2) {
              subclassEditSection = 'base';
            } else if (currentIndex === 0) {
              subclassEditSection = 'nom';
            } else if (currentIndex === 1) {
              subclassEditSection = 'description';
            } else if (currentIndex === 3) {
              subclassEditSection = 'progression';  
            } else if (currentIndex >= 4) {
              subclassEditSection = 'capacites';
            }
          }
          
          return {
            contentType: 'subclass',
            itemIdentifier: subclassCard.dataset.subclassName,
            categoryName: className,
            property: 'html',
            editType: 'html',
            editSection: subclassEditSection,
            config: window.ContentTypes.subclass,
            element: element.classList.contains('editable-section') ? element.querySelector('.editable') : element,
            container: element
          };
        }
        
        // Otherwise it's a class - determine what part of the class we're editing
        let classEditSection = 'content';
        
        // More specific detection based on parent elements and content
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        if (editableElement) {
          const parentCard = editableElement.closest('.card');
          const parentSection = editableElement.closest('.editable-section');
          
          // Use index-based detection instead of content analysis
          const classArticle = editableElement.closest('article[data-page-title]');
          const allEditables = classArticle ? Array.from(classArticle.querySelectorAll('.editable')) : [];
          const currentIndex = allEditables.indexOf(editableElement);
          
          // Map index to property based on class structure
          // Index 0 = resume (first editable in class)
          // Index 1+ = capacites (subsequent editables are class capabilities)
          if (currentIndex === 0) {
            classEditSection = 'resume';
          } else if (currentIndex >= 1) {
            classEditSection = 'capacites';
          }
        }
        
        return {
          contentType: 'class',
          itemIdentifier: className,
          categoryName: null,
          property: 'html',
          editType: 'html',
          editSection: classEditSection,
          config: window.ContentTypes.class,
          element: element.classList.contains('editable-section') ? element.querySelector('.editable') : element,
          container: element
        };
      }
      
      // Check if we're editing a page description (unified system)
      const pageDescSection = element.closest('.editable-section[data-section-type*="-category-description"], .editable-section[data-section-type="pageDescription"]');
      if (pageDescSection) {
        const sectionType = pageDescSection.dataset.sectionType;
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const editSection = editableElement ? editableElement.dataset.editSection : '';
        
        let contentType;
        
        // Handle different types of page descriptions
        if (sectionType === 'pageDescription') {
          // For generic page descriptions, get the content type from the editable element
          const pageType = editableElement?.dataset?.pageType;
          contentType = pageType || 'collections'; // fallback to collections
        } else {
          // Extract content type from section type (e.g., "objet-category-description" -> "objet")
          contentType = sectionType.replace('-category-description', '');
        }
        
        // Use unified page description system via ContentFactory
        return {
          contentType: 'pageDescription',
          pageType: contentType, // The actual content type (spell, don, objet, collections, etc.)
          itemIdentifier: contentType,
          categoryName: null,
          property: 'description',
          editType: 'html',
          editSection: editSection,
          element: editableElement,
          container: element,
          applyEdit: (content) => {
            const success = ContentFactory.updatePageDescription(contentType, content);
            if (!success) {
              console.error(`âŒ Failed to update page description for ${contentType}`);
            }
            return success;
          }
        };
      }
        
      // Check if we're editing a category description (spell/don category pages - fallback for old system)
      const categorySection = element.closest('.editable-section');
      if (categorySection && categorySection.dataset.sectionType && categorySection.dataset.sectionType.includes('category-description')) {
        const sectionType = categorySection.dataset.sectionType;
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const editSection = editableElement ? editableElement.dataset.editSection : '';
        
        // Extract content type from section type
        const contentType = sectionType.replace('-category-description', '');
        
        return {
          contentType: 'category',
          itemIdentifier: editSection, // This is the category name
          categoryName: editSection,
          property: 'description',
          editType: 'html',
          editSection: 'description',
          categoryType: contentType,
          config: window.ContentTypes[contentType],
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're editing campaign or sub-page content (specific handling before static page fallback)
      const campaignArticle = element.closest('article[data-static-page="true"]');
      if (campaignArticle && campaignArticle.dataset.page === 'campagne') {
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const editSection = editableElement?.dataset?.editSection || '';
        
        // Handle campaign-specific edit sections
        if (editSection.startsWith('campaign-')) {
          // Parse campaign edit section: campaign-{campaignName}-{property}
          const parts = editSection.split('-');
          if (parts.length >= 3) {
            const campaignName = parts.slice(1, -1).join('-'); // Handle campaign names with hyphens
            const property = parts[parts.length - 1]; // last part is the property
            
            return {
              contentType: 'campaign',
              itemIdentifier: campaignName,
              categoryName: null,
              property: 'html',
              editType: 'html',
              editSection: property, // 'name' or 'description'
              config: window.ContentTypes.campaign,
              element: editableElement,
              container: element,
              applyEdit: (content) => {
                return this.updateCampaignData('campaign', campaignName, property, content);
              }
            };
          }
        } else if (editSection.startsWith('subpage-')) {
          // Parse sub-page edit section: subpage-{campaignName}-{subPageName}-{property}
          const parts = editSection.split('-');
          if (parts.length >= 4) {
            const campaignName = parts[1];
            const subPageName = parts.slice(2, -1).join('-'); // Handle sub-page names with hyphens
            const property = parts[parts.length - 1]; // last part is the property
            
            return {
              contentType: 'campaignSubPage',
              itemIdentifier: `${campaignName}:${subPageName}`,
              categoryName: campaignName,
              property: 'html',
              editType: 'html',
              editSection: property, // 'title' or 'content'
              config: window.ContentTypes.campaignSubPage,
              element: editableElement,
              container: element,
              applyEdit: (content) => {
                return this.updateCampaignData('subpage', campaignName, property, content, subPageName);
              }
            };
          }
        }
      }
      
      // Check if we're in a static page (LAST, as fallback)
      // Now we include ALL static pages, regardless of data-page-title
      const staticPageArticle = element.closest('article[data-static-page="true"]');
      if (staticPageArticle) {
        const pageName = staticPageArticle.dataset.page;
        
        // Enhanced page detection with ID-based fallback
        let actualPageName = pageName;
        const elementEditSection = element.dataset?.editSection || 'none';
        
        // If the element's edit section contains a page prefix, use that instead
        if (elementEditSection !== 'none' && elementEditSection.includes('-')) {
          const possiblePageId = elementEditSection.split('-')[0];
          // Check if this matches a known static page
          if (window.STATIC_PAGES && window.STATIC_PAGES[possiblePageId]) {
            actualPageName = possiblePageId;
          }
        }
        
        // Use the corrected page name
        const finalPageName = actualPageName;
        
        // Use index-based detection for static page sections
        const allEditables = Array.from(staticPageArticle.querySelectorAll('.editable'));
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const currentIndex = allEditables.indexOf(editableElement);
        
        // For static pages, use the actual edit section from the element's data attribute
        const actualEditSection = elementEditSection !== 'none' ? elementEditSection : `section-${currentIndex}`;
        
        return {
          contentType: 'staticPage',
          itemIdentifier: finalPageName,  // Use corrected page name
          categoryName: null,
          property: 'html',
          editType: 'html',
          editSection: actualEditSection,  // Use actual edit section ID
          config: window.ContentTypes.staticPage,
          element: editableElement,
          container: element
        };
      }
      
      // Default fallback
      return {
        contentType: 'unknown',
        itemIdentifier: editSection || 'content',
        categoryName: null,
        property: 'html',
        editType: 'html',
        editSection,
        config: { fields: {} },
        element: element.classList.contains('editable-section') ? element.querySelector('.editable') : element,
        container: element
      };
    }

    parseTagsEditContext(element, editSection) {
      // Check if we're in an object card
      const objetCard = element.closest('.card[data-objet-name]');
      if (objetCard) {
        const objetName = objetCard.dataset.objetName;
        const categoryName = objetCard.dataset.categoryName;
        
        return {
          contentType: 'objet',
          itemIdentifier: objetName,
          categoryName: categoryName,
          property: 'tags',
          editType: 'tags',
          editSection: editSection,
          config: window.ContentTypes.objet,
          element: element.classList.contains('editable') ? element : element.querySelector('.editable'),
          container: element
        };
      }
      
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        return {
          contentType: 'monster',
          itemIdentifier: monsterName,
          categoryName: categoryName || 'monstres',
          property: 'tags',
          editType: 'tags',
          editSection: editSection,
          config: window.ContentTypes.monster,
          element: element.classList.contains('editable') ? element : element.querySelector('.editable'),
          container: element
        };
      }
      
      return null;
    }

    parseSelectEditContext(element, editSection) {
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        return {
          contentType: 'monster',
          itemIdentifier: monsterName,
          categoryName: categoryName || 'monstres',
          property: 'element',
          editType: 'select',
          editSection: editSection,
          config: window.ContentTypes.monster,
          element: element,
          container: element.closest('.monster-element-section')
        };
      }
      
      // Check if we're in a spell card
      const spellCard = element.closest('.card[data-spell-name]');
      if (spellCard) {
        const spellName = spellCard.dataset.spellName;
        const spellIndex = spellCard.dataset.spellIndex;
        const categoryName = spellCard.dataset.categoryName;
        
        return {
          contentType: 'spell',
          itemIdentifier: spellName,
          itemIndex: spellIndex,
          categoryName: categoryName,
          property: 'element',
          editType: 'select',
          editSection: editSection,
          config: window.ContentTypes.spell,
          element: element,
          container: element.closest('.spell-element-section')
        };
      }
      
      return null;
    }

    makeElementEditable(editableElement, container) {
      const originalHtml = editableElement.innerHTML;
      container.dataset.originalContent = originalHtml;
      container.dataset.editing = 'true';

      // Decode any encoded HTML before showing for editing
      const decodedHtml = this.decodeHtmlEntities(originalHtml);
      editableElement.innerHTML = decodedHtml;
      editableElement.contentEditable = true;
      editableElement.style.cssText += `
        background-color: rgba(255, 255, 0, 0.1);
        border: 1px dashed var(--bronze);
        border-radius: 4px;
        padding: 4px;
        font-family: monospace;
        white-space: pre-wrap;
      `;
      editableElement.focus();

      const range = document.createRange();
      range.selectNodeContents(editableElement);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
    }

    makeTagsEditable(editableElement, container) {
      
      const originalHtml = editableElement.innerHTML;
      container.dataset.originalContent = originalHtml;
      container.dataset.editing = 'true';

      // Get current tags from the object
      const objetName = this.currentEditSession.itemIdentifier;
      
      const objet = window.OBJETS?.objets?.find(obj => obj.nom === objetName);
      
      const currentTags = objet?.tags || [];
      const availableTags = window.ContentTypes.objet.filterConfig.availableTags;

      // Create and show modal instead of inline editor
      this.showTagsModal(objetName, currentTags, availableTags);
    }

    showTagsModal(objetName, currentTags, availableTags) {
      // Remove any existing tags modal
      const existingModal = document.querySelector('#tagsEditModal');
      if (existingModal) {
        existingModal.remove();
      }

      // Use native HTML5 dialog element for proper z-index handling
      const modal = document.createElement('dialog');
      modal.id = 'tagsEditModal';
      modal.style.cssText = `
        max-width: 500px !important;
        width: 90% !important;
        padding: 0 !important;
        border: none !important;
        border-radius: 12px !important;
        background: transparent !important;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5) !important;
      `;

      const checkboxesHTML = availableTags.map(tag => `
        <div style="display: flex; align-items: center; gap: 0.5rem; margin: 0.5rem 0; padding: 0.5rem; background: #f5f5f5; border-radius: 8px;">
          <input 
            type="checkbox" 
            id="modal-tag-${tag}" 
            value="${tag}" 
            ${currentTags.includes(tag) ? 'checked' : ''}
            style="margin: 0;"
          >
          <label for="modal-tag-${tag}" style="flex: 1; cursor: pointer; font-weight: 500;">
            <span style="background: #8B4513; color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 0.5rem;">${tag}</span>
            ${tag}
          </label>
        </div>
      `).join('');

      modal.innerHTML = `
        <div style="
          background: white; 
          border-radius: 12px; 
          padding: 1.5rem; 
          border: 3px solid #8B4513;
          font-family: inherit;
          font-size: 16px;
          color: #333;
        ">
          <h3 style="margin: 0 0 1rem 0; color: #8B4513; font-size: 1.2em;">ğŸ·ï¸ Ã‰diter les tags de "${objetName}"</h3>
          <p style="margin: 0 0 1rem 0; color: #666; font-size: 0.9em;">SÃ©lectionnez les tags Ã  assigner Ã  cet objet :</p>
          
          <div id="tagsCheckboxes" style="margin: 1rem 0;">
            ${checkboxesHTML}
          </div>
          
          <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem;">
            <button type="button" class="btn-cancel-tags-modal" style="
              background: #666; 
              color: white; 
              border: none; 
              padding: 8px 16px; 
              border-radius: 6px; 
              cursor: pointer;
              font-weight: 500;
              font-size: 14px;
            ">
              âŒ Annuler
            </button>
            <button type="button" class="btn-save-tags-modal" style="
              background: #8B4513; 
              color: white; 
              border: none; 
              padding: 8px 16px; 
              border-radius: 6px; 
              cursor: pointer;
              font-weight: 500;
              font-size: 14px;
            ">
              ğŸ’¾ Sauvegarder
            </button>
          </div>
        </div>
      `;

      // Append to body and show modal using native dialog API
      document.body.appendChild(modal);

      // Use showModal() for proper top-level display
      try {
        modal.showModal();
      } catch (error) {
        console.error('Error calling showModal():', error);
      }

      // Set up event handlers
      modal.querySelector('.btn-save-tags-modal').addEventListener('click', () => {
        this.saveTagsFromModal(modal);
      });

      modal.querySelector('.btn-cancel-tags-modal').addEventListener('click', () => {
        this.cancelTagsModal(modal);
      });

      // Native dialog handles backdrop clicks and ESC automatically
      modal.addEventListener('cancel', (e) => {
        this.cancelTagsModal(modal);
      });

      // Close on backdrop click (for dialog elements)
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.cancelTagsModal(modal);
        }
      });
    }

    saveTagsFromModal(modal) {
      if (!this.currentEditSession) return false;

      const checkboxes = modal.querySelectorAll('input[type="checkbox"]:checked');
      const selectedTags = Array.from(checkboxes).map(cb => cb.value);

      if (selectedTags.length === 0) {
        alert('Veuillez sÃ©lectionner au moins un tag');
        return false;
      }

      // Update data based on content type
      const itemName = this.currentEditSession.itemIdentifier;
      let targetItem = null;
      
      if (this.currentEditSession.contentType === 'objet') {
        // Update the object data
        targetItem = window.OBJETS?.objets?.find(obj => obj.nom === itemName);
      } else if (this.currentEditSession.contentType === 'monster') {
        // Update the monster data
        targetItem = window.MONSTRES?.find(monster => monster.nom === itemName);
      } else if (this.currentEditSession.contentType === 'tableTresor') {
        // Update the table tresor data
        targetItem = window.TABLES_TRESORS?.tables?.find(table => table.nom === itemName);
      }
      
      if (targetItem) {
        targetItem.tags = selectedTags;
        
        // Update the display
        const tagsDisplay = selectedTags.map(tag => 
          `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`
        ).join('');
        
        // Restore the element and update its content
        this.resetEditingState(this.currentEditSession.container);
        this.restoreElementContent(this.currentEditSession, tagsDisplay);
        
        // Save to storage
        EventBus.emit(Events.STORAGE_SAVE);
        
        // Close modal and clear edit session
        modal.close();
        modal.remove();
        this.currentEditSession = null;
        
        // Show success notification
        JdrApp.modules.ui.showNotification(`ğŸ·ï¸ Tags mis Ã  jour : ${selectedTags.join(', ')}`, 'success');
        
        return true;
      }
      
      return false;
    }

    cancelTagsModal(modal) {
      // Close modal without saving
      modal.close();
      modal.remove();
      
      // Cancel the edit session
      this.cancelCurrentEdit();
    }

    // Save current editing session
    saveCurrentEdit() {
      if (!this.currentEditSession) return false;

      const session = this.currentEditSession;
      // Get the edited HTML content from innerHTML (user edited the rendered content)
      const newContent = session.element.innerHTML.trim();
      const normalizedContent = this.normalizeHTMLContent(newContent);

      // Reset editing state first to avoid interfering with content restoration
      this.resetEditingState(session.container);

      if (normalizedContent !== session.originalContent) {
        const success = this.saveContent(session, normalizedContent);
        if (success) {
          // Convert back from text to rendered HTML
          this.restoreElementContent(session, normalizedContent);
          
          EventBus.emit(Events.CONTENT_UPDATE, {
            contentType: session.contentType,
            itemIdentifier: session.itemIdentifier,
            property: session.property,
            value: normalizedContent
          });
        } else {
          // If save failed, restore original content
          this.restoreElementContent(session, session.originalContent);
        }
      } else {
        // Even if no changes, restore HTML rendering
        this.restoreElementContent(session, session.originalContent);
      }

      this.currentEditSession = null;
      return true;
    }

    // Update content in data structure - unified method for all content types
    updateContentInDataStructure(session, content) {
      try {
        switch (session.contentType) {
          case 'spell':
            return this.updateSpellData(session, content);
          case 'don':
            return this.updateDonData(session, content);
          case 'objet':
            return this.updateObjetData(session, content);
          case 'monster':
            return this.updateMonsterData(session, content);
          case 'category':
            return this.updateCategoryData(session, content);
          case 'subclass':
            return this.updateSubclassData(session, content);
          case 'class':
            return this.updateClassData(session, content);
          case 'staticPage':
            return this.updateStaticPageData(session, content);
          case 'tableTresor':
            return this.updateTableTresorData(session, content);
          case 'pageDescription':
            return this.updatePageDescriptionData(session, content);
          case 'campaign':
            return session.applyEdit(content);
          case 'campaignSubPage':
            return session.applyEdit(content);
          default:
            console.error('Unknown content type for update:', session.contentType);
            return false;
        }
      } catch (error) {
        console.error('Error updating content:', error, session);
        return false;
      }
    }

    // Update spell data
    updateSpellData(session, content) {
      const category = window.SORTS?.find(cat => cat.nom === session.categoryName);
      if (!category) return false;
      
      const spell = category.sorts?.find(s => s.nom === session.itemIdentifier);
      if (!spell) return false;
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.spell;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // If we're updating the name, we need to update the container's data-spell-name attribute
      if (propertyName === 'nom') {
        const oldName = spell.nom;
        spell[propertyName] = content;
        
        // Update the data-spell-name attribute on the card container
        const spellCard = session.container.closest('.card[data-spell-name]');
        if (spellCard && spellCard.dataset.spellName === oldName) {
          spellCard.dataset.spellName = content;
        }
      } else {
        spell[propertyName] = content;
      }
      
      return true;
    }

    // Update don data
    updateDonData(session, content) {
      const category = window.DONS?.find(cat => cat.nom === session.categoryName);
      if (!category) return false;
      
      const don = category.dons?.find(d => d.nom === session.itemIdentifier);
      if (!don) return false;
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.don;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // If we're updating the name, we need to update the container's data-don-name attribute
      if (propertyName === 'nom') {
        const oldName = don.nom;
        don[propertyName] = content;
        
        // Update the data-don-name attribute on the card container
        const donCard = session.container.closest('.card[data-don-name]');
        if (donCard && donCard.dataset.donName === oldName) {
          donCard.dataset.donName = content;
        }
      } else {
        don[propertyName] = content;
      }
      
      return true;
    }

    // Update objet data
    updateObjetData(session, content) {
      const objet = window.OBJETS?.objets?.find(o => o.nom === session.itemIdentifier);
      if (!objet) return false;
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.objet;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // If we're updating the name, we need to update the container's data-objet-name attribute
      if (propertyName === 'nom') {
        const oldName = objet.nom;
        objet[propertyName] = content;
        
        // Update the data-objet-name attribute on the card container
        const objetCard = session.container.closest('.card[data-objet-name]');
        if (objetCard && objetCard.dataset.objetName === oldName) {
          objetCard.dataset.objetName = content;
        }
      } else {
        objet[propertyName] = content;
      }
      
      return true;
    }

    // Update monster data
    updateMonsterData(session, content) {
      const monster = window.MONSTRES?.find(m => m.nom === session.itemIdentifier);
      if (!monster) {
        console.error('Monster not found:', session.itemIdentifier, 'Available monsters:', window.MONSTRES?.map(m => m.nom));
        return false;
      }
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.monster;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // Backup current value for rollback capability
      const originalValue = monster[propertyName];
      
      try {
        // If we're updating the name, we need to update the container's data-monster-name attribute
        if (propertyName === 'nom') {
          const oldName = monster.nom;
          monster[propertyName] = content;
          
          // Update the data-monster-name attribute on the card container
          const monsterCard = session.container.closest('.card[data-monster-name]');
          if (monsterCard && monsterCard.dataset.monsterName === oldName) {
            monsterCard.dataset.monsterName = content;
          }
        } else {
          // Update the monster property
          monster[propertyName] = content;
        }
        
        // Force synchronization using ContentFactory to prevent data reversion
        const contentFactory = window.ContentFactory?.getInstance ? window.ContentFactory.getInstance() : null;
        if (contentFactory && contentFactory.updateItem) {
          // Use ContentFactory to ensure proper data synchronization
          contentFactory.updateItem('monster', null, monster.nom, propertyName, content);
        }
        
        // Additional safety: ensure image mapping is maintained
        if (propertyName === 'image' && JdrApp.modules.images) {
          const imageKey = `monster:${monster.nom}`;
          JdrApp.modules.images.setImage(imageKey, content);
        }
        
        // Create backup for crash recovery
        this.createMonsterBackup(monster);
        
        return true;
        
      } catch (error) {
        // Rollback on error
        console.error('âŒ Error updating monster, rolling back:', error);
        monster[propertyName] = originalValue;
        return false;
      }
    }

    // Update table tresor data
    updateTableTresorData(session, content) {
      const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === session.itemIdentifier);
      if (!table) {
        console.error('Table tresor not found:', session.itemIdentifier, 'Available tables:', window.TABLES_TRESORS?.tables?.map(t => t.nom));
        return false;
      }
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.tableTresor;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // Backup current value for rollback capability
      const originalValue = table[propertyName];
      
      try {
        // If we're updating the name, we need to update the container's data-table-tresor-name attribute
        if (propertyName === 'nom') {
          const oldName = table.nom;
          table[propertyName] = content;
          
          // Update the data-table-tresor-name attribute on the card container
          const tableTresorCard = session.container.closest('.card[data-table-tresor-name]');
          if (tableTresorCard && tableTresorCard.dataset.tableTresorName === oldName) {
            tableTresorCard.dataset.tableTresorName = content;
          }
          
          // If we're updating the name, we need to update the session itemIdentifier
          // to prevent future saves from failing with the old name
          if (this.currentEditSession && this.currentEditSession.itemIdentifier === originalValue) {
            this.currentEditSession.itemIdentifier = content;
          }
        } else {
          // Update the table property
          table[propertyName] = content;
        }
        
        // Force synchronization using ContentFactory to prevent data reversion
        const contentFactory = window.ContentFactory?.getInstance ? window.ContentFactory.getInstance() : null;
        if (contentFactory && contentFactory.updateItem) {
          // Use ContentFactory to ensure proper data synchronization
          contentFactory.updateItem('tableTresor', 'tables', table.nom, propertyName, content);
        }
        
        return true;
        
      } catch (error) {
        // Rollback on error
        console.error('âŒ Error updating table tresor, rolling back:', error);
        table[propertyName] = originalValue;
        return false;
      }
    }

    // Update page description data (unified system)
    updatePageDescriptionData(session, content) {
      // Use the ContentFactory method that already handles the configuration
      const success = ContentFactory.updatePageDescription(session.pageType, content);
      
      if (success) {
        return true;
      } else {
        console.error(`âŒ Failed to update page description for ${session.pageType}`);
        return false;
      }
    }

    // Update category data (generic for all category types)
    updateCategoryData(session, content) {
      // Handle different category types generically
      if (session.categoryType === 'don') {
        const category = window.DONS?.find(cat => cat.nom === session.categoryName);
        if (category && session.editSection === 'description') {
          category.description = content;
          return true;
        }
      } else if (session.categoryType === 'spell') {
        const category = window.SORTS?.find(cat => cat.nom === session.categoryName);
        if (category && session.editSection === 'description') {
          category.description = content;
          return true;
        }
      }
      
      // Simple fallback - if we're editing description and nothing else matched, 
      // and we have OBJETS, assume it's the objects category
      if (session.editSection === 'description' && window.OBJETS) {
        window.OBJETS.description = content;
        return true;
      }
      
      return false;
    }

    // Update subclass data
    updateSubclassData(session, content) {
      const classe = window.CLASSES?.find(c => c.nom === session.categoryName);
      if (!classe) return false;
      
      const subclass = classe.sousClasses?.find(sc => sc.nom === session.itemIdentifier);
      if (!subclass) return false;
      
      // Use editMapping if available, otherwise use editSection directly
      const config = session.config || window.ContentTypes.subclass;
      const propertyName = config.editMapping?.[session.editSection] || session.editSection;
      
      // If we're updating the name, we need to update the container's data-subclass-name attribute
      if (propertyName === 'nom') {
        const oldName = subclass.nom;
        subclass[propertyName] = content;
        
        // Update the data-subclass-name attribute on the card container
        const subclassCard = session.container.closest('.card[data-subclass-name]');
        if (subclassCard && subclassCard.dataset.subclassName === oldName) {
          subclassCard.dataset.subclassName = content;
        }
      } else {
        subclass[propertyName] = content;
      }
      
      return true;
    }

    // Update class data
    updateClassData(session, content) {
      const classe = window.CLASSES?.find(c => c.nom === session.itemIdentifier);
      if (!classe) return false;
      
      classe[session.editSection] = content;
      return true;
    }

    // Update static page data
    updateStaticPageData(session, content) {
      const pageKey = session.itemIdentifier;
      const pageData = window.STATIC_PAGES?.[pageKey];
      
      if (!pageData) return false;
      
      // Handle page title
      if (session.editSection === 'page-title') {
        pageData.title = content;
        return true;
      }
      
      // Handle campaign data (special case for campaign page)
      if (pageKey === 'campagne') {
        return this.updateCampaignData(pageData, session, content);
      }
      
      // Handle sections
      return this.updateStaticPageSection(pageData, session, content);
    }

    // Update specific section in static page data
    updateStaticPageSection(pageData, session, content) {
      if (!pageData.sections) return false;
      
      const sections = pageData.sections;
      
      // Find section by ID or type
      for (let i = 0; i < sections.length; i++) {
        const section = sections[i];
        
        // Direct ID match
        if (section.id === session.editSection) {
          section.content = content;
          return true;
        }
        
        // Handle title updates (ID + "-title")
        if (session.editSection.endsWith('-title')) {
          const sectionId = session.editSection.replace('-title', '');
          if (section.id === sectionId) {
            section.title = content;
            return true;
          }
        }
        
        // Handle intro sections
        if (section.type === 'intro' && session.editSection.includes('intro')) {
          section.content = content;
          return true;
        }
        
        // Handle card sections
        if (section.type === 'card' && section.id === session.editSection) {
          section.content = content;
          return true;
        }
      }
      
      // If no existing section found, check if we need to create one for intro
      if (session.editSection === 'intro' || session.editSection.includes('intro')) {
        const introSection = sections.find(s => s.type === 'intro');
        if (introSection) {
          introSection.content = content;
          return true;
        }
      }
      
      return false;
    }

    // Update campaign and sub-page data
    updateCampaignData(pageData, session, content) {
      const editSection = session.editSection;
      
      // Initialize subPages if not exists
      if (!pageData.subPages) {
        pageData.subPages = {};
      }
      
      // Parse edit section: campaign-{campaignName}-{field} or subpage-{campaignName}-{subPageName}-{field}
      if (editSection.startsWith('campaign-')) {
        // Format: campaign-{campaignName}-{field}
        const parts = editSection.split('-');
        if (parts.length >= 3) {
          const campaignName = parts.slice(1, -1).join('-'); // Handle campaign names with dashes
          const field = parts[parts.length - 1];
          
          if (!pageData.subPages[campaignName]) {
            pageData.subPages[campaignName] = {
              name: campaignName,
              description: 'Description de la campagne',
              subPages: {}
            };
          }
          
          if (field === 'name') {
            // If renaming campaign, we need to move the entire campaign data
            if (campaignName !== content && !pageData.subPages[content]) {
              pageData.subPages[content] = pageData.subPages[campaignName];
              pageData.subPages[content].name = content;
              delete pageData.subPages[campaignName];
            }
          } else if (field === 'description') {
            pageData.subPages[campaignName].description = content;
          }
          
          return true;
        }
      } else if (editSection.startsWith('subpage-')) {
        // Format: subpage-{campaignName}-{subPageName}-{field}
        const parts = editSection.split('-');
        if (parts.length >= 4) {
          const campaignName = parts[1];
          const subPageName = parts.slice(2, -1).join('-'); // Handle sub-page names with dashes
          const field = parts[parts.length - 1];
          
          if (!pageData.subPages[campaignName]) {
            return false; // Campaign doesn't exist
          }
          
          if (!pageData.subPages[campaignName].subPages) {
            pageData.subPages[campaignName].subPages = {};
          }
          
          if (!pageData.subPages[campaignName].subPages[subPageName]) {
            pageData.subPages[campaignName].subPages[subPageName] = {
              title: subPageName,
              content: '<p>Contenu de la sous-page...</p>'
            };
          }
          
          if (field === 'title') {
            // If renaming sub-page, we need to move the entire sub-page data
            if (subPageName !== content && !pageData.subPages[campaignName].subPages[content]) {
              pageData.subPages[campaignName].subPages[content] = pageData.subPages[campaignName].subPages[subPageName];
              pageData.subPages[campaignName].subPages[content].title = content;
              delete pageData.subPages[campaignName].subPages[subPageName];
            }
          } else if (field === 'content') {
            pageData.subPages[campaignName].subPages[subPageName].content = content;
          }
          
          return true;
        }
      }
      
      return false;
    }

    // Save content using unified system
    saveContent(session, content) {
      try {
        // Determine which JSON category to save to
        let jsonCategory;
        
        switch (session.contentType) {
          case 'spell':
            jsonCategory = 'SORTS';
            break;
          case 'don':
            jsonCategory = 'DONS';
            break;
          case 'class':
            jsonCategory = 'CLASSES';
            break;
          case 'subclass':
            jsonCategory = 'CLASSES';  // Subclasses are stored within CLASSES
            break;
          case 'category':
            // Category descriptions can be in SORTS, DONS, or OBJETS
            if (session.categoryType === 'don') {
              jsonCategory = 'DONS';
            } else if (session.categoryType === 'spell') {
              jsonCategory = 'SORTS';
            } else {
              // Default to OBJETS for other category descriptions
              jsonCategory = 'OBJETS';
            }
            break;
          case 'objet':
            jsonCategory = 'OBJETS';
            break;
          case 'monster':
            jsonCategory = 'MONSTRES';
            break;
          case 'staticPage':
          case 'generic':
            jsonCategory = 'STATIC_PAGES';
            break;
          default:
            return false;
        }
        
        return this.saveToJson(session, content, jsonCategory);
      } catch (error) {
        console.error('Save error:', error);
        return false;
      }
    }

    // Unified save method that takes a JSON category parameter
    saveToJson(session, content, jsonCategory) {
      const jsonData = window[jsonCategory];
      if (!jsonData) {
        console.error(`JSON category ${jsonCategory} not found`);
        return false;
      }


      // Generic save - find the target object and save the content
      let targetObject = null;
      
      if (session.contentType === 'spell' || session.contentType === 'don') {
        // Find in category -> items structure
        for (const category of jsonData) {
          if (category.nom === session.categoryName) {
            const itemsKey = session.contentType === 'spell' ? 'sorts' : 'dons';
            // Use index-based identification if available, fallback to name-based
            if (session.itemIndex !== undefined && session.itemIndex !== null) {
              const index = parseInt(session.itemIndex, 10);
              targetObject = category[itemsKey]?.[index];
            } else {
              targetObject = category[itemsKey]?.find(item => item.nom === session.itemIdentifier);
            }
            break;
          }
        }
      } else if (session.contentType === 'class') {
        // Find class directly
        targetObject = jsonData.find(c => c.nom === session.itemIdentifier);
      } else if (session.contentType === 'subclass') {
        // Find subclass within a class
        const parentClass = jsonData.find(c => c.nom === session.categoryName);
        if (parentClass?.sousClasses) {
          targetObject = parentClass.sousClasses.find(sc => sc.nom === session.itemIdentifier);
        }
      } else if (session.contentType === 'objet') {
        // Find object directly in the objets array
        targetObject = jsonData.objets?.find(obj => obj.nom === session.itemIdentifier);
      } else if (session.contentType === 'monster') {
        // Find monster directly in the array
        targetObject = jsonData?.find(monster => monster.nom === session.itemIdentifier);
      } else if (session.contentType === 'tableTresor') {
        // Find table tresor directly in the array
        targetObject = jsonData?.tables?.find(table => table.nom === session.itemIdentifier);
      } else if (session.contentType === 'category') {
        // Find category by name and update its description
        targetObject = jsonData.find(category => category.nom === session.categoryName);
      } else if (session.contentType === 'staticPage' || session.contentType === 'generic') {
        return this.saveStaticPageToJson(jsonData, session, content);
      }
      
      if (targetObject) {
        targetObject[session.editSection] = content;
        return true;
      } else {
        return false;
      }
    }


    saveStaticPageToJson(jsonData, session, content) {
      const pageData = jsonData[session.itemIdentifier];
      if (!pageData?.sections) {
        console.error('Page data or sections not found for:', session.itemIdentifier);
        return false;
      }

      // Generic search by section ID or special cases
      const updateSection = (sections) => {
        for (const section of sections) {
          // Direct ID match for content
          if (section.id === session.editSection) {
            section.content = content;
            return true;
          }
          
          // Handle title updates (ID + "-title")
          if (session.editSection.endsWith('-title')) {
            const sectionId = session.editSection.replace('-title', '');
            if (section.id === sectionId) {
              section.title = content;
              return true;
            }
          }
          
          // Handle page title
          if (session.editSection === 'page-title') {
            // Page title is stored in the page data, not sections
            // This will be handled at page level
            return false;
          }
          
          // Handle intro sections
          if (section.type === 'intro' && session.editSection === 'intro') {
            section.content = content;
            return true;
          }

          // Handle nested content arrays (for grid sections)
          if (section.content && Array.isArray(section.content)) {
            if (updateSection(section.content)) {
              return true;
            }
          }
        }
        return false;
      };

      // Special handling for page title
      if (session.editSection === 'page-title') {
        pageData.title = content;
        return true;
      }

      if (updateSection(pageData.sections)) {
        return true;
      }

      console.error('Section not found for editSection:', session.editSection);
      return false;
    }

    // No special processing - everything is just HTML now
    processContentByType(content, fieldConfig) {
      return content;
    }

    // UNIFIED CONTENT RESTORATION - USE THIS FOR ALL CONTENT TYPES
    // This method ensures that HTML content is always properly rendered
    // and prevents HTML tags from being displayed as visible text
    restoreElementContent(session, content) {
      // IMPORTANT: Always use innerHTML to render HTML content properly
      // Never use textContent for edited content as it will show HTML tags
      session.element.innerHTML = content;
      
      // NOTE FOR DEVELOPERS: 
      // - For ANY new content type, use this method instead of direct innerHTML assignment
      // - This prevents the recurring issue of visible HTML tags after editing
      // - ALL content types (static pages, spells, classes, dons) go through this
    }

    resetEditingState(container) {
      const editableElement = container.querySelector('.editable') || container;
      
      // Standard editing cleanup (modal is handled separately)
      editableElement.contentEditable = false;
      // Simplified cleanup to prevent stack overflow
      editableElement.style.background = '';
      editableElement.style.border = '';
      editableElement.style.padding = '';
      editableElement.style.fontFamily = '';
      editableElement.style.whiteSpace = '';
      
      // Reset both container and editable element attributes
      container.dataset.editing = 'false';
      delete container.dataset.originalContent;
      
      // Also reset on the editable element itself in case it's the same
      if (editableElement !== container) {
        editableElement.dataset.editing = 'false';
        delete editableElement.dataset.originalContent;
      }
    }


    decodeHtmlEntities(html) {
      // Decode HTML entities step by step to prevent double-encoding
      let decoded = html
        .replace(/&amp;lt;/g, '<')  // &amp;lt; -> <
        .replace(/&amp;gt;/g, '>')  // &amp;gt; -> >
        .replace(/&lt;/g, '<')     // &lt; -> <
        .replace(/&gt;/g, '>')     // &gt; -> >
        .replace(/&quot;/g, '"')   // &quot; -> "
        .replace(/&#39;/g, "'")    // &#39; -> '
        .replace(/&amp;/g, '&');   // &amp; -> & (do this last)
      return decoded;
    }

    normalizeHTMLContent(html) {
      // SIMPLIFIED VERSION to prevent infinite loops
      // Just return the trimmed HTML without complex transformations
      if (!html || typeof html !== 'string') {
        return '';
      }
      
      // Basic cleanup only - avoid complex regex chains that can loop
      let cleaned = html.trim();
      
      // Only safe, non-recursive replacements
      cleaned = cleaned.replace(/&quot;/g, '"');
      cleaned = cleaned.replace(/&#39;/g, "'");
      cleaned = cleaned.replace(/<br\s*\/?>/gi, '<br>');
      
      return cleaned;
    }

    // Cancel current edit
    cancelCurrentEdit() {
      if (!this.currentEditSession) return false;

      const session = this.currentEditSession;
      // Reset editing state first to avoid interfering with content restoration
      this.resetEditingState(session.container);
      // Restore original content
      this.restoreElementContent(session, session.originalContent);
      this.currentEditSession = null;
      return true;
    }

    // Check if element is currently being edited
    isEditing(element) {
      return element.dataset.editing === 'true';
    }

    // Save all active edits
    saveAllEdits() {
      if (this.currentEditSession) {
        this.saveCurrentEdit();
      }

      // Handle any remaining editing elements
      document.querySelectorAll('[data-editing="true"]').forEach(element => {
        if (!this.isValidForEdit(element)) {
          this.resetEditingState(element);
        }
      });
    }

    isValidForEdit(element) {
      const context = this.parseEditContext(element);
      return context !== null;
    }

    // Handle tags editing context
    parseTagsEditContext(element, editSection) {
      // Check if we're in an objet card
      const objetCard = element.closest('.card[data-objet-name]');
      if (objetCard) {
        const objetName = objetCard.dataset.objetName;
        const categoryName = objetCard.dataset.categoryName;
        
        return {
          contentType: 'objet',
          itemIdentifier: objetName,
          categoryName: categoryName,
          property: 'tags',
          editType: 'tags',
          editSection: 'tags',
          config: window.ContentTypes.objet,
          element: element.classList.contains('editable-tags') ? element : element.querySelector('.editable-tags'),
          container: element
        };
      }
      
      // Check if we're in a monster card
      const monsterCard = element.closest('.card[data-monster-name]');
      if (monsterCard) {
        const monsterName = monsterCard.dataset.monsterName;
        const categoryName = monsterCard.dataset.categoryName;
        
        const editableElement = element.classList.contains('editable-tags') ? element : element.querySelector('.editable-tags');
        
        // Use data-item-identifier if available, otherwise fall back to monsterName
        const itemIdentifier = editableElement?.dataset?.itemIdentifier || monsterName;
        
        return {
          contentType: 'monster',
          itemIdentifier: itemIdentifier,
          categoryName: categoryName || 'monstres',
          property: 'tags',
          editType: 'tags',
          editSection: 'tags',
          config: window.ContentTypes.monster,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a table de trÃ©sor card
      const tableTresorCard = element.closest('.card[data-table-tresor-name]');
      if (tableTresorCard) {
        const tableTresorName = tableTresorCard.dataset.tableTresorName;
        const categoryName = tableTresorCard.dataset.categoryName || 'tables';
        
        const editableElement = element.classList.contains('editable-tags') ? element : element.querySelector('.editable-tags');
        
        // Use data-item-identifier if available, otherwise fall back to tableTresorName
        const itemIdentifier = editableElement?.dataset?.itemIdentifier || tableTresorName;
        
        return {
          contentType: 'tableTresor',
          itemIdentifier: itemIdentifier,
          categoryName: categoryName,
          property: 'tags',
          editType: 'tags',
          editSection: 'tags',
          config: window.ContentTypes.tableTresor,
          element: editableElement,
          container: element
        };
      }
      
      return null;
    }

    // Force reset of all elements that might be stuck in editing mode
    forceResetAllEditingElements() {
      // Reset any elements with contenteditable=true
      const editableElements = document.querySelectorAll('[contenteditable="true"]');
      editableElements.forEach(element => {
        element.contentEditable = false;
        element.style.background = '';
        element.style.border = '';
        element.style.padding = '';
        element.style.borderRadius = '';
        element.style.fontFamily = '';
        element.style.whiteSpace = '';
      });
      
      // Reset any containers with data-editing=true
      const editingContainers = document.querySelectorAll('[data-editing="true"]');
      editingContainers.forEach(container => {
        container.dataset.editing = 'false';
        delete container.dataset.originalContent;
      });
      
      // Clear any current edit session
      this.currentEditSession = null;
    }

    // Main entry point for starting edit
    startEdit(element) {
      // Force reset of any stuck editing elements first
      this.forceResetAllEditingElements();
      
      // Cancel any existing edit first
      if (this.currentEditSession) {
        this.saveCurrentEdit();
      }

      const context = this.parseEditContext(element);
      if (!context) {
        return false;
      }

      // Handle tags editing differently - show modal instead of inline editing
      if (context.editType === 'tags') {
        this.startTagsEdit(context);
        return true;
      }

      // Handle select editing differently - show dropdown instead of inline editing
      if (context.editType === 'select') {
        this.startSelectEdit(context);
        return true;
      }

      // Start normal inline editing
      return this.startInlineEdit(context);
    }

    // Start inline editing (for non-tags content)
    startInlineEdit(context) {
      const element = context.element;
      const container = context.container;

      // Store original content
      const originalContent = element.innerHTML;
      
      // Create edit session
      this.currentEditSession = {
        ...context,
        originalContent: originalContent
      };

      // Set up editing state
      container.dataset.editing = 'true';
      container.dataset.originalContent = originalContent;
      
      // Decode any encoded HTML before showing for editing
      const decodedHtml = this.decodeHtmlEntities(originalContent);
      element.innerHTML = decodedHtml;
      
      // Always use modal editing for consistency
      // Force modal editing for all content types to ensure uniform behavior
      this.showHTMLEditModal(element, decodedHtml);

      return true;
    }

    // Save current edit
    saveCurrentEdit() {
      if (!this.currentEditSession) return false;

      const session = this.currentEditSession;
      const element = session.element;
      const newContent = element.innerHTML.trim();
      
      // Normalize and clean HTML content
      const processedContent = this.normalizeHTMLContent(newContent);
      
      // Apply changes to data structure
      const success = this.updateContentInDataStructure(session, processedContent);
      
      if (success) {
        // Update display
        this.restoreElementContent(session, processedContent);
        
        // Note: Storage save is handled elsewhere to prevent loops
        // Show success notification
        if (JdrApp.modules.ui?.showNotification) {
          JdrApp.modules.ui.showNotification('ğŸ’¾ Modification sauvegardÃ©e', 'success');
        }
      } else {
        console.error('Failed to save edit:', session);
      }
      
      // Reset editing state
      this.resetEditingState(session.container);
      this.currentEditSession = null;
      
      return success;
    }

    // Show modal for editing HTML content
    showHTMLEditModal(element, htmlContent) {
      // Store the current edit session for later use
      const editSession = this.currentEditSession;
      
      const modal = document.createElement('dialog');
      modal.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        padding: 0;
        border: none;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        max-width: 80vw;
        max-height: 80vh;
        z-index: 1000000 !important;
        background: transparent;
      `;

      // CrÃ©er un backdrop manuel
      const backdrop = document.createElement('div');
      backdrop.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999999 !important;
        backdrop-filter: blur(4px);
      `;

      modal.innerHTML = `
        <div style="background: var(--paper); border-radius: 12px; padding: 1.5rem; border: 2px solid var(--rule); max-height: 80vh; overflow-y: auto; display: flex; flex-direction: column;">
          <h3 style="margin: 0 0 1rem 0; color: var(--accent-ink); flex-shrink: 0;">Ã‰dition du contenu</h3>
          
          <div style="margin-bottom: 1rem; flex-shrink: 0;">
            <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">AperÃ§u du rendu:</label>
            <div id="preview" style="border: 1px solid var(--rule); padding: 1rem; border-radius: 6px; background: var(--card); min-height: 60px; max-height: 150px; overflow-y: auto;">
              ${htmlContent}
            </div>
          </div>
          
          <div style="margin-bottom: 1rem; flex: 1; min-height: 0; display: flex; flex-direction: column;">
            <label for="htmlEditor" style="display: block; margin-bottom: 0.5rem; font-weight: 600; flex-shrink: 0;">Code HTML:</label>
            <textarea 
              id="htmlEditor" 
              style="width: 100%; flex: 1; min-height: 200px; padding: 1rem; border: 1px solid var(--rule); border-radius: 6px; font-family: monospace; font-size: 14px; resize: vertical;"
              placeholder="Entrez le HTML ici..."
            >${htmlContent}</textarea>
          </div>
          
          <div style="margin-bottom: 1rem; flex-shrink: 0;">
            <div style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 0.5rem;">
              <button id="elementsBtn" class="btn" style="background: #059669; color: white; font-size: 12px;">ğŸ”¥ Ã‰lÃ©ments</button>
              <button id="etatsBtn" class="btn" style="background: #7c2d12; color: white; font-size: 12px;">âš¡ Ã‰tats</button>
              <button id="spellLinksBtn" class="btn" style="background: #6b21a8; color: white; font-size: 12px;">ğŸ”— Liens Sorts</button>
              <button id="pageLinksBtn" class="btn" style="background: #1d4ed8; color: white; font-size: 12px;">ğŸ”— Liens Pages</button>
            </div>
            <div style="font-size: 12px; color: var(--paper-muted); line-height: 1.4;">
              ğŸ’¡ <strong>Astuce:</strong> Utilisez ces boutons pour insÃ©rer rapidement des Ã©lÃ©ments, Ã©tats, liens vers les sorts et liens vers les pages dans votre contenu HTML.
            </div>
          </div>
          
          <div style="display: flex; gap: 1rem; justify-content: flex-end; flex-shrink: 0;">
            <button id="cancelEdit" class="btn" style="background: #6b7280; color: white;">Annuler</button>
            <button id="saveEdit" class="btn" style="background: var(--accent); color: white;">ğŸ’¾ Sauvegarder</button>
          </div>
        </div>
      `;

      document.body.appendChild(backdrop);
      document.body.appendChild(modal);
      modal.show();

      const textarea = modal.querySelector('#htmlEditor');
      const preview = modal.querySelector('#preview');
      const saveBtn = modal.querySelector('#saveEdit');
      const cancelBtn = modal.querySelector('#cancelEdit');
      const elementsBtn = modal.querySelector('#elementsBtn');
      const etatsBtn = modal.querySelector('#etatsBtn');
      const spellLinksBtn = modal.querySelector('#spellLinksBtn');
      const pageLinksBtn = modal.querySelector('#pageLinksBtn');

      // Helper function to insert text at cursor position in textarea
      const insertTextAtCursor = (text) => {
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const currentValue = textarea.value;
        
        textarea.value = currentValue.substring(0, start) + text + currentValue.substring(end);
        textarea.selectionStart = textarea.selectionEnd = start + text.length;
        textarea.focus();
        
        // Update preview
        try {
          preview.innerHTML = textarea.value;
        } catch (e) {
          preview.textContent = 'AperÃ§u invalide: ' + e.message;
        }
      };

      // Store the insertTextAtCursor function globally so modals can access it
      window.editorInsertTextAtCursor = insertTextAtCursor;

      // Toolbox buttons handlers
      if (elementsBtn) {
        elementsBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showElementsModal) {
            JdrApp.modules.ui.showElementsModal();
          }
        });
      }

      if (etatsBtn) {
        etatsBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showEtatsModal) {
            JdrApp.modules.ui.showEtatsModal();
          }
        });
      }

      if (spellLinksBtn) {
        spellLinksBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showSpellLinksModal) {
            JdrApp.modules.ui.showSpellLinksModal();
          }
        });
      }

      if (pageLinksBtn) {
        pageLinksBtn.addEventListener('click', () => {
          if (JdrApp.modules.ui?.showPageLinksModal) {
            JdrApp.modules.ui.showPageLinksModal();
          }
        });
      }

      // Live preview update with debounce to prevent performance issues
      let previewUpdateTimeout;
      textarea.addEventListener('input', () => {
        clearTimeout(previewUpdateTimeout);
        previewUpdateTimeout = setTimeout(() => {
          try {
            preview.innerHTML = textarea.value;
          } catch (e) {
            preview.textContent = 'AperÃ§u invalide: ' + e.message;
          }
        }, 300); // 300ms debounce
      });

      // Save handler
      saveBtn.addEventListener('click', () => {
        const newContent = textarea.value.trim();
        const normalizedContent = this.normalizeHTMLContent(newContent);
        
        // Update the element content
        element.innerHTML = normalizedContent;
        
        // Update in data structure using stored session
        const success = this.updateContentInDataStructure(editSession, normalizedContent);
        
        if (success) {
          EventBus.emit(Events.STORAGE_SAVE);
          if (JdrApp.modules.ui?.showNotification) {
            JdrApp.modules.ui.showNotification('ğŸ’¾ Modification sauvegardÃ©e', 'success');
          }
        }
        
        // Clean up
        this.resetEditingState(editSession.container);
        this.currentEditSession = null;
        window.editorInsertTextAtCursor = null;
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Cancel handler
      cancelBtn.addEventListener('click', () => {
        this.resetEditingState(editSession.container);
        this.currentEditSession = null;
        window.editorInsertTextAtCursor = null;
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Close on backdrop click
      backdrop.addEventListener('click', () => {
        this.resetEditingState(editSession.container);
        this.currentEditSession = null;
        window.editorInsertTextAtCursor = null;
        modal.close();
        modal.remove();
        backdrop.remove();
      });

      // Focus textarea
      textarea.focus();
      textarea.select();
    }

    // Handle select editing by toggling display/selector visibility
    startSelectEdit(context) {
      const element = context.element;
      const container = context.container;

      // Store the current edit session
      this.currentEditSession = {
        ...context,
        originalContent: element.value // For select, we store the value, not innerHTML
      };

      // Find the display and selector sections
      const sectionContainer = element.closest('.monster-element-section, .spell-element-section');
      if (!sectionContainer) {
        return false;
      }

      const displaySection = sectionContainer.querySelector('.monster-element-display, .spell-element-display');
      const selectorSection = sectionContainer.querySelector('.monster-element-selector, .spell-element-selector');
      
      if (!displaySection || !selectorSection) {
        return false;
      }

      // Toggle visibility
      displaySection.style.display = 'none';
      selectorSection.style.display = 'block';

      // Set up change listener for the select element
      const selectElement = selectorSection.querySelector('select');
      if (selectElement) {
        selectElement.focus();
        
        // Add event listener for changes
        const changeHandler = () => {
          this.saveSelectEdit(selectElement);
          selectElement.removeEventListener('change', changeHandler);
          selectElement.removeEventListener('blur', blurHandler);
        };

        const blurHandler = () => {
          this.cancelSelectEdit(sectionContainer);
          selectElement.removeEventListener('change', changeHandler);
          selectElement.removeEventListener('blur', blurHandler);
        };

        selectElement.addEventListener('change', changeHandler);
        selectElement.addEventListener('blur', blurHandler);
      }

      return true;
    }

    // Save select edit
    saveSelectEdit(selectElement) {
      if (!this.currentEditSession) return false;

      const newValue = selectElement.value;
      const session = this.currentEditSession;

      // Update the data structure
      const success = this.updateContentInDataStructure(session, newValue);

      if (success) {
        // Update the display immediately
        this.updateElementDisplay(session, newValue);
        
        // Emit storage save event
        EventBus.emit(Events.STORAGE_SAVE);
        
        // Show success notification
        if (JdrApp.modules.ui?.showNotification) {
          JdrApp.modules.ui.showNotification('ğŸ’¾ Ã‰lÃ©ment mis Ã  jour', 'success');
        }
      }

      // Hide selector and show display
      this.resetSelectEdit();
      this.currentEditSession = null;
      return success;
    }

    // Cancel select edit
    cancelSelectEdit(sectionContainer) {
      this.resetSelectEdit();
      this.currentEditSession = null;
    }

    // Reset select edit UI state
    resetSelectEdit() {
      if (!this.currentEditSession) return;

      const element = this.currentEditSession.element;
      const sectionContainer = element.closest('.monster-element-section, .spell-element-section');
      if (!sectionContainer) return;

      const displaySection = sectionContainer.querySelector('.monster-element-display, .spell-element-display');
      const selectorSection = sectionContainer.querySelector('.monster-element-selector, .spell-element-selector');
      
      if (displaySection && selectorSection) {
        displaySection.style.display = 'block';
        selectorSection.style.display = 'none';
      }
    }

    // Update element display after selection change
    updateElementDisplay(session, newValue) {
      const element = session.element;
      const sectionContainer = element.closest('.monster-element-section, .spell-element-section');
      if (!sectionContainer) return;

      const displaySection = sectionContainer.querySelector('.monster-element-display, .spell-element-display');
      const badge = displaySection?.querySelector('.element-badge');
      
      if (badge) {
        // Get element icon and color
        const icon = window.ElementIcons?.[newValue] || 'âš¡';
        const color = window.ElementColors?.[newValue]?.color || '#666';
        
        // Update the badge content and style
        if (session.contentType === 'monster') {
          // For monsters, we need to update the complete badge styling
          const iconSpan = badge.querySelector('span:first-child');
          const textSpan = badge.querySelector('span:last-child');
          if (iconSpan && textSpan) {
            iconSpan.textContent = icon;
            textSpan.textContent = newValue;
            textSpan.style.color = color;
            
            // Update the complete badge background and border
            const hexColor = color;
            const rgbMatch = hexColor.match(/^#([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
            if (rgbMatch) {
              const r = parseInt(rgbMatch[1], 16);
              const g = parseInt(rgbMatch[2], 16);
              const b = parseInt(rgbMatch[3], 16);
              badge.style.background = `rgba(${r}, ${g}, ${b}, 0.1)`;
              badge.style.border = `1px solid ${hexColor}`;
            }
          }
        } else if (session.contentType === 'spell') {
          // Update spell badge
          badge.innerHTML = `${icon} ${newValue}`;
        }
      }
    }

    // Handle tags editing by showing modal
    startTagsEdit(context) {
      // For tags, we don't do inline editing, we show a modal
      this.showTagsModal(context);
    }

    // Show tags editing modal
    showTagsModal(context) {
      // Find the target item (object or monster)
      let targetItem = null;
      let availableTags = [];
      
      if (context.contentType === 'objet') {
        const allObjects = window.OBJETS?.objets || [];
        targetItem = allObjects.find(o => o.nom === context.itemIdentifier);
        availableTags = window.ContentTypes.objet.filterConfig.availableTags || [];
      } else if (context.contentType === 'monster') {
        const allMonsters = window.MONSTRES || [];
        targetItem = allMonsters.find(m => m.nom === context.itemIdentifier);
        availableTags = window.ContentTypes.monster.filterConfig.availableTags || [];
      } else if (context.contentType === 'tableTresor') {
        const allTables = window.TABLES_TRESORS?.tables || [];
        targetItem = allTables.find(t => t.nom === context.itemIdentifier);
        // Use metadata as primary source, fallback to ContentTypes config
        availableTags = window.TABLES_TRESORS?._metadata?.availableTags || 
                       window.ContentTypes.tableTresor?.filterConfig?.availableTags || [];
      }
      
      if (!targetItem) {
        console.error('Item not found for tags editing:', context.itemIdentifier, 'Type:', context.contentType);
        return;
      }

      const itemTags = targetItem.tags || [];

      // Remove existing modal if any
      const existingModal = document.querySelector('#tagsEditModal');
      if (existingModal) {
        existingModal.remove();
      }

      // Create modal
      const modal = document.createElement('dialog');
      modal.id = 'tagsEditModal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        padding: 0;
        border: none;
        border-radius: 12px;
        background: transparent;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      `;
      
      const tagsCheckboxes = availableTags.map(tag => {
        const isSelected = itemTags.includes(tag);
        return `
          <div style="display: flex; align-items: center; gap: 0.5rem; margin: 0.5rem 0; padding: 0.5rem; background: var(--card); border-radius: 8px;">
            <input 
              type="checkbox" 
              id="tag-${tag}" 
              value="${tag}" 
              ${isSelected ? 'checked' : ''}
              style="margin: 0;"
            >
            <label for="tag-${tag}" style="flex: 1; cursor: pointer; font-weight: 500;">
              <span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 0.5rem;">${tag}</span>
              ${tag}
            </label>
          </div>
        `;
      }).join('');

      modal.innerHTML = `
        <div style="background: var(--paper); border-radius: 12px; padding: 1.5rem; border: 2px solid var(--rule);">
          <h3 style="margin: 0 0 1rem 0; color: var(--accent-ink);">Ã‰dition des tags - ${targetItem.nom}</h3>
          <p style="margin: 0 0 1rem 0; color: var(--paper-muted);">SÃ©lectionnez les tags pour cet objet :</p>
          <div id="tagsCheckboxes" style="margin: 1rem 0; max-height: 300px; overflow-y: auto;">
            ${tagsCheckboxes}
          </div>
          <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem;">
            <button class="btn" id="saveTagsBtn" style="background: var(--accent); color: white;">
              ğŸ’¾ Sauvegarder
            </button>
            <button class="btn modal-close" style="background: #666; color: white;">
              âŒ Annuler
            </button>
          </div>
        </div>
      `;

      // Add event listeners
      modal.addEventListener('click', (e) => {
        if (e.target.id === 'saveTagsBtn') {
          this.saveTagsFromModal(modal, targetItem, context);
        } else if (e.target.classList.contains('modal-close')) {
          modal.close();
          modal.remove();
        }
      });

      // Handle dialog close events
      modal.addEventListener('cancel', () => {
        modal.close();
        modal.remove();
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.close();
          modal.remove();
        }
      });

      document.body.appendChild(modal);
      modal.showModal();
    }

    // Save tags from modal
    saveTagsFromModal(modal, obj, context) {
      // Get selected tags
      const checkboxes = modal.querySelectorAll('input[type="checkbox"]:checked');
      const selectedTags = Array.from(checkboxes).map(cb => cb.value);

      if (selectedTags.length === 0) {
        JdrApp.modules.ui.showNotification('âŒ Veuillez sÃ©lectionner au moins un tag', 'error');
        return;
      }

      // Update tags for the target item (works for both objects and monsters)
      obj.tags = selectedTags;

      // Update the display immediately
      const tagDisplay = context.element;
      if (tagDisplay) {
        const tagsDisplayHTML = selectedTags.map(tag => 
          `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`
        ).join('');
        tagDisplay.innerHTML = tagsDisplayHTML;
      }

      // Trigger save to storage
      EventBus.emit(Events.STORAGE_SAVE);
      
      // Close modal
      modal.close();
      modal.remove();
      
      JdrApp.modules.ui.showNotification(`ğŸ’¾ Tags sauvegardÃ©s pour "${obj.nom}"`, 'success');
    }

    // Create backup of monster data for recovery
    createMonsterBackup(monster) {
      try {
        if (!window.MonsterBackups) {
          window.MonsterBackups = new Map();
        }
        
        // Keep only last MAX_MONSTER_BACKUPS backups per monster
        const backupKey = monster.nom;
        const currentBackups = window.MonsterBackups.get(backupKey) || [];
        
        const backup = {
          timestamp: Date.now(),
          data: JSON.parse(JSON.stringify(monster)) // Deep copy
        };
        
        currentBackups.push(backup);
        const maxBackups = window.DEFAULT_VALUES?.MAX_MONSTER_BACKUPS || 10;
        if (currentBackups.length > maxBackups) {
          currentBackups.shift(); // Remove oldest
        }
        
        window.MonsterBackups.set(backupKey, currentBackups);
        
      } catch (error) {
        // Ignore backup failures - not critical
      }
    }

    // Recover monster from backup
    recoverMonsterFromBackup(monsterName, backupIndex = 0) {
      try {
        if (!window.MonsterBackups || !window.MonsterBackups.has(monsterName)) {
          console.error('No backup found for monster:', monsterName);
          return false;
        }
        
        const backups = window.MonsterBackups.get(monsterName);
        const backup = backups[backups.length - 1 - backupIndex]; // Get latest by default
        
        if (!backup) {
          console.error('Backup index out of range for monster:', monsterName);
          return false;
        }
        
        // Find monster in current data
        const monster = window.MONSTRES?.find(m => m.nom === monsterName);
        if (!monster) {
          console.error('Monster not found in current data:', monsterName);
          return false;
        }
        
        // Restore data
        Object.assign(monster, backup.data);
        
        // Force sync
        const contentFactory = window.ContentFactory?.getInstance ? window.ContentFactory.getInstance() : null;
        if (contentFactory && contentFactory.refreshData) {
          contentFactory.refreshData();
        }
        
        return true;
        
      } catch (error) {
        console.error('Failed to recover monster from backup:', error);
        return false;
      }
    }

    // Global validation and repair of monster data
    validateAndRepairMonsterData() {
      if (!window.MONSTRES || !Array.isArray(window.MONSTRES)) {
        return 0;
      }
      
      let repairCount = 0;
      const contentTypes = window.ContentTypes?.monster;
      
      window.MONSTRES.forEach((monster, index) => {
        // Ensure required properties exist
        if (!monster.nom) {
          monster.nom = `Monstre ${index + 1}`;
          repairCount++;
        }
        
        // Validate numeric properties
        if (contentTypes && contentTypes.fields) {
          Object.entries(contentTypes.fields).forEach(([fieldName, fieldConfig]) => {
            if (fieldConfig.type === 'number') {
              if (typeof monster[fieldName] !== 'number' || isNaN(monster[fieldName])) {
                const defaultValue = contentTypes.defaultValues?.[fieldName] || 0;
                monster[fieldName] = defaultValue;
                repairCount++;
              }
            }
          });
        }
        
        // Ensure image path exists and is valid
        if (!monster.image || typeof monster.image !== 'string') {
          monster.image = `data/images/Monstres/foret/Monstre_ForÃªt_${monster.nom.replace(/[^a-zA-Z0-9]/g, '')}.png`;
          repairCount++;
        }
        
        // Validate image mapping exists
        if (JdrApp.modules.images) {
          const imageKey = `monster:${monster.nom}`;
          if (!JdrApp.modules.images.getImageUrl(imageKey)) {
            JdrApp.modules.images.setImage(imageKey, monster.image);
          }
        }
      });
      
      if (repairCount > 0) {
        // Save repaired data
        if (JdrApp.modules.storage && JdrApp.modules.storage.saveChanges) {
          JdrApp.modules.storage.saveChanges(true);
        }
      }
      
      return repairCount;
    }
    
    // Update static page data method
    updateStaticPageData(session, content) {
      try {
        const pageId = session.itemIdentifier;
        const editSection = session.editSection;
        
        // Get the static page data
        const staticPageData = window.STATIC_PAGES?.[pageId];
        if (!staticPageData) {
          console.error('Static page not found:', pageId);
          return false;
        }
        
        // Handle different edit section formats
        if (editSection.startsWith('intro-')) {
          // Editing intro section
          const sectionIndex = parseInt(editSection.split('-')[1]);
          if (staticPageData.sections && staticPageData.sections[sectionIndex] && staticPageData.sections[sectionIndex].type === 'intro') {
            staticPageData.sections[sectionIndex].content = content;
          }
        } else if (editSection === 'page-title') {
          // Editing page title
          staticPageData.title = content;
        } else if (editSection.endsWith('-title')) {
          // Editing card title (e.g., "dieux-new-2-1756899335313-title")
          const cardId = editSection.slice(0, -6); // Remove "-title"
          const cardSection = staticPageData.sections?.find(s => s.id === cardId);
          if (cardSection) {
            cardSection.title = content;
          }
        } else {
          // Editing card content (e.g., "dieux-new-2-1756899335313")
          const cardSection = staticPageData.sections?.find(s => s.id === editSection);
          if (cardSection) {
            cardSection.content = content;
          } else {
            console.warn('Unhandled static page edit section:', editSection);
            return false;
          }
        }
        
        return true;
        
      } catch (error) {
        console.error('Failed to update static page data:', error);
        return false;
      }
    }

    // Campaign and sub-page data update method
    updateCampaignData(type, campaignName, property, content, subPageName = null) {
      try {
        // Get the campaign data from the static pages
        const campagneData = window.STATIC_PAGES?.campagne;
        if (!campagneData || !campagneData.subPages) {
          return false;
        }
        
        if (type === 'campaign') {
          // Update campaign property (name or description)
          if (!campagneData.subPages[campaignName]) {
            return false;
          }
          
          if (property === 'name') {
            // Renaming a campaign requires more complex handling
            // For now, just update the description property
            return false;
          } else if (property === 'description') {
            campagneData.subPages[campaignName].description = content;
          }
        } else if (type === 'subpage') {
          // Update sub-page property (title or content)
          if (!campagneData.subPages[campaignName] || !campagneData.subPages[campaignName].subPages || !subPageName) {
            return false;
          }
          
          const subPage = campagneData.subPages[campaignName].subPages[subPageName];
          if (!subPage) {
            return false;
          }
          
          if (property === 'title') {
            subPage.title = content;
          } else if (property === 'content') {
            subPage.content = content;
          }
        }
        
        // Direct save to avoid infinite loop from STORAGE_SAVE event
        try {
          if (JdrApp?.modules?.storage?.saveChanges) {
            JdrApp.modules.storage.saveChanges(true); // Silent save
          }
        } catch (saveError) {
          // Ignore save errors - data is still updated in memory
        }
        
        return true;
        
      } catch (error) {
        console.error('Failed to update campaign data:', error);
        return false;
      }
    }
  }

  window.UnifiedEditor = UnifiedEditor.getInstance();

})();
// ============================================================================
// JDR-BAB APPLICATION - EDITOR MODULE (REFACTORED)
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // EDITOR MODULE - Now uses UnifiedEditor
  // ========================================
  JdrApp.modules.editor = {
    editedData: {},
    isDevMode: false,

    init() {
      this.setupEventListeners();
      this.setupEditableHandlers();
      this.setupCreationHandlers();
      this.setupImageHandlers();
      this.updateDevModeState();
    },

    setupEventListeners() {
      JdrApp.utils.events.register('click', '#devToggle', () => this.toggleDevMode());

      EventBus.on(Events.EDITOR_TOGGLE, (payload) => {
        this.isDevMode = payload.enabled;
        this.updateDevModeState();
      });

      EventBus.on(Events.CONTENT_UPDATE, () => {
        this.saveChangesToStorage();
      });

    },

    toggleDevMode() {
      if (window.STANDALONE_VERSION) return;
      
      this.isDevMode = !this.isDevMode;
      EventBus.emit(Events.EDITOR_TOGGLE, { enabled: this.isDevMode });
    },

    updateDevModeState() {
      if (window.STANDALONE_VERSION) {
        document.body.className = 'dev-off';
        this.forceHideAllEditButtons();
        return;
      }
      
      document.body.classList.toggle('dev-on', this.isDevMode);
      document.body.classList.toggle('dev-off', !this.isDevMode);
      
      const devToggle = document.querySelector('#devToggle');
      const devToolbox = document.querySelector('#devToolbox');
      
      if (devToggle) {
        devToggle.textContent = `ğŸ›  Dev Mode: ${this.isDevMode ? 'ON' : 'OFF'}`;
      }
      
      if (devToolbox) {
        devToolbox.style.display = this.isDevMode ? 'block' : 'none';
      }
      
      // Update dev-only containers visibility - same approach as modal buttons
      const devOnlyElements = document.querySelectorAll('[data-dev-only]');
      devOnlyElements.forEach(element => {
        element.style.display = this.isDevMode ? 'block' : 'none';
      });
      
      if (this.isDevMode) {
        this.forceShowAllEditButtons();
      } else {
        this.forceHideAllEditButtons();
      }

      // Regenerate monsters page if currently viewing it
      const currentPage = window.location.hash.replace('#/', '');
      if (currentPage === 'monstres' && JdrApp.modules.renderer && JdrApp.modules.renderer.populateMonstersPage) {
        setTimeout(() => {
          JdrApp.modules.renderer.populateMonstersPage();
        }, 100);
      }
    },

    forceHideAllEditButtons() {
      if (this.isDevMode) {
        return;
      }
      
      const selectors = [
        '.edit-btn', '[class$="-add"]', '[class$="-delete"]', '[class*="-move-"]',
        '.section-delete', '.remove-section-btn', '.add-paragraph-btn', 
        '.add-subclass-btn', '.delete-subclass-btn',
        '.spell-delete', '.don-delete', // Explicit delete buttons
        '.illus .up', '.illus .rm', '.illus label', '.illus input[type="file"]',
        '.tags-manager-btn', '.filter-manager-btn' // Tags and filter manager buttons
      ];
      
      selectors.forEach(selector => {
        document.querySelectorAll(selector).forEach(element => {
          element.style.display = 'none';
          element.style.visibility = 'hidden';
          element.setAttribute('aria-hidden', 'true');
        });
      });
    },
    
    forceShowAllEditButtons() {
      if (!this.isDevMode) return;
      
      // Ensure body has the correct classes
      document.body.classList.add('dev-on');
      document.body.classList.remove('dev-off');
      
      // Force reset all CSS properties that might be causing 0x0 dimensions
      const selectors = [
        '.edit-btn', '[class$="-add"]', '[class$="-delete"]', '[class*="-move-"]',
        '.section-delete', '.remove-section-btn', '.add-paragraph-btn', 
        '.add-subclass-btn', '.delete-subclass-btn',
        '.spell-delete', '.don-delete', '.objet-delete',
        '.spell-add', '.don-add', '.objet-add',
        '.illus .up', '.illus .rm', '.illus label', '.illus input[type="file"]',
        '.tags-manager-btn', '.filter-manager-btn' // Tags and filter manager buttons
      ];
      
      selectors.forEach(selector => {
        document.querySelectorAll(selector).forEach(element => {
          // Force reset all dimension properties
          element.style.removeProperty('display');
          element.style.removeProperty('visibility');
          element.style.removeProperty('opacity');
          element.style.removeProperty('width');
          element.style.removeProperty('height');
          element.style.removeProperty('min-width');
          element.style.removeProperty('min-height');
          element.style.removeProperty('pointer-events');
          element.removeAttribute('aria-hidden');
          
          // Let CSS handle the styling
          element.style.display = '';
          element.style.visibility = '';
        });
      });
    },

    setupEditableHandlers() {
      // Unified edit button handler
      JdrApp.utils.events.register('click', '.edit-btn', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!this.isDevMode) return;
        
        // Prevent multiple edit sessions
        if (UnifiedEditor.currentEditSession) {
          console.warn('Another edit session is already active');
          return;
        }
        
        // Find the editable element near the button
        let editableElement = e.target.previousElementSibling;
        
        // If not found as previous sibling, look in parent
        if (!editableElement || !editableElement.classList.contains('editable')) {
          const parent = e.target.parentElement;
          editableElement = parent.querySelector('.editable');
        }
        
        // Fallback: look for closest editable element
        if (!editableElement || !editableElement.classList.contains('editable')) {
          editableElement = e.target.closest('.editable-section')?.querySelector('.editable') ||
                           e.target.closest('.card')?.querySelector('.editable');
        }
        
        if (editableElement && editableElement.classList.contains('editable')) {
          UnifiedEditor.startEdit(editableElement);
        } else {
          console.warn('No editable element found for edit button');
        }
      });

      // Handle select element changes directly
      JdrApp.utils.events.register('change', '.editable[data-edit-type="select"]', (e) => {
        if (!this.isDevMode) return;
        
        const selectElement = e.target;
        const newValue = selectElement.value;
        
        // Parse context and save immediately
        const context = UnifiedEditor.parseEditContext(selectElement);
        if (context) {
          // Update the data structure
          const success = UnifiedEditor.updateContentInDataStructure(context, newValue);
          if (success) {
            // Update display
            UnifiedEditor.updateElementDisplay(context, newValue);
            
            // Save to storage
            EventBus.emit(Events.STORAGE_SAVE);
            
            // Show notification
            if (JdrApp.modules.ui?.showNotification) {
              JdrApp.modules.ui.showNotification('ğŸ’¾ Ã‰lÃ©ment mis Ã  jour', 'success');
            }
          }
        }
      });

      // Click outside to save
      JdrApp.utils.events.register('click', 'body', (e) => {
        if (!e.target.closest('.editable') && !e.target.matches('.edit-btn')) {
          UnifiedEditor.saveAllEdits();
        }
      });

      // Keyboard shortcuts
      JdrApp.utils.events.register('keydown', '.editable', (e) => {
        if ((e.key === 'Enter' && !e.shiftKey) || e.key === 'Escape') {
          e.preventDefault();
          UnifiedEditor.saveCurrentEdit();
        }
      });

      // Prevent double-click editing (force button-only editing)
      JdrApp.utils.events.register('dblclick', '.editable', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      });
    },

    setupCreationHandlers() {
      // Unified subclass management
      JdrApp.utils.events.register('click', '.add-subclass-btn', (e) => {
        if (!this.isDevMode) return;
        this.addNewSubclass(e.target);
      });

      JdrApp.utils.events.register('click', '.delete-subclass-btn', (e) => {
        if (!this.isDevMode) return;
        this.deleteSubclass(e.target);
      });
    },

    addNewSubclass(button) {
      const article = button.closest('article');
      if (!article) return;
      
      let className = article.dataset.pageTitle;
      if (!className) {
        const hash = window.location.hash.match(/#\/([^\/]+)/);
        if (hash) {
          className = hash[1].charAt(0).toUpperCase() + hash[1].slice(1);
        }
      }
      
      console.log('Adding subclass to class:', className);
      
      if (!className || !window.CLASSES) {
        console.log('Missing className or CLASSES:', { className, hasClasses: !!window.CLASSES });
        return;
      }
      
      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe) {
        console.log('Class not found:', className);
        console.log('Available classes:', window.CLASSES.map(c => c.nom));
        return;
      }
      
      const config = window.ContentTypes.subclass;
      const newSubclass = { ...config.defaultValues };
      
      console.log('Creating new subclass:', newSubclass);
      
      if (!classe.sousClasses) classe.sousClasses = [];
      classe.sousClasses.push(newSubclass);
      
      console.log('Class after adding subclass:', classe);
      
      EventBus.emit(Events.CONTENT_ADD, {
        type: 'subclass',
        category: className,
        item: newSubclass
      });
      
      // Recharger juste le contenu de l'article au lieu de toute la page
      this.reloadClassPage(className);
    },

    deleteSubclass(button) {
      const className = button.dataset.className;
      const subclassName = button.dataset.subclassName;
      
      if (!className || !subclassName) return;
      if (!confirm(`ÃŠtes-vous sÃ»r de vouloir supprimer la sous-classe "${subclassName}" ?`)) return;

      const classe = window.CLASSES?.find(c => c.nom === className);
      if (!classe?.sousClasses) return;

      const index = classe.sousClasses.findIndex(sc => sc.nom === subclassName);
      if (index === -1) return;

      const deletedSubclass = classe.sousClasses.splice(index, 1)[0];
      
      EventBus.emit(Events.CONTENT_DELETE, {
        type: 'subclass',
        category: className,
        item: deletedSubclass
      });
      
      // Recharger juste le contenu de l'article au lieu de toute la page  
      this.reloadClassPage(className);
    },

    reloadClassPage(className) {
      // Trouver l'article de la classe
      const article = document.querySelector(`article[data-page-title="${className}"]`);
      if (!article) return;

      // RÃ©gÃ©nÃ©rer le contenu de la classe
      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe) return;

      // VÃ©rifier que PageBuilder existe
      if (!window.PageBuilder) {
        console.error('PageBuilder not available, falling back to page reload');
        window.location.reload();
        return;
      }

      // Utiliser PageBuilder pour rÃ©gÃ©nÃ©rer le contenu
      const newContent = window.PageBuilder.buildClassPage(classe);
      const parser = new DOMParser();
      const newDoc = parser.parseFromString(newContent, 'text/html');
      const newArticle = newDoc.querySelector('article');
      
      if (newArticle) {
        article.innerHTML = newArticle.innerHTML;
        
        // RÃ©appliquer les images et l'Ã©tat de dev mode
        setTimeout(() => {
          if (JdrApp.modules.renderer?.autoLoadImages) {
            JdrApp.modules.renderer.autoLoadImages();
          }
          // Apply dev mode state properly
          if (this.isDevMode) {
            this.forceShowAllEditButtons();
          } else {
            this.forceHideAllEditButtons();
          }
        }, 50);
      }
    },

    setupImageHandlers() {
      // Fonction pour attacher les Ã©vÃ©nements aux images existantes
      this.attachImageEvents();
      
      // Observer pour attacher les Ã©vÃ©nements aux nouvelles images crÃ©Ã©es dynamiquement
      if (typeof MutationObserver !== 'undefined') {
        const observer = new MutationObserver(() => {
          this.attachImageEvents();
        });
        observer.observe(document.body, { childList: true, subtree: true });
      }
    },

    attachImageEvents() {
      // Attacher aux inputs de fichier
      document.querySelectorAll('.illus input[type="file"]').forEach(input => {
        if (!input.hasAttribute('data-events-attached')) {
          input.addEventListener('change', (e) => this.handleImageUpload(e));
          input.setAttribute('data-events-attached', 'true');
        }
      });

      // Attacher aux boutons de suppression
      document.querySelectorAll('.illus .rm').forEach(button => {
        if (!button.hasAttribute('data-events-attached')) {
          button.addEventListener('click', (e) => this.handleImageRemoval(e));
          button.setAttribute('data-events-attached', 'true');
        }
      });

      // Attacher aux images pour agrandissement - toutes les images, pas seulement celles dans .illus
      document.querySelectorAll('img').forEach(img => {
        // Ã‰viter les images dans les Ã©diteurs ou les inputs
        if (!img.closest('.editor-content') && !img.hasAttribute('data-events-attached')) {
          // Ajouter support tactile pour mobile
          img.addEventListener('click', (e) => this.toggleImageEnlargement(e.target));
          img.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.toggleImageEnlargement(e.target);
          });
          img.setAttribute('data-events-attached', 'true');
          img.style.cursor = 'zoom-in';
        }
      });
    },

    handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const illus = event.target.closest('.illus');
        const img = illus.querySelector('img');
        const rmButton = illus.querySelector('.rm');
        const illusKey = illus.dataset.illusKey;

        img.src = e.target.result;
        img.style.display = 'block';
        if (rmButton) rmButton.style.display = 'block';

        if (JdrApp.modules.images?.setImageUrl) {
          JdrApp.modules.images.setImageUrl(illusKey, e.target.result);
        }

        EventBus.emit(Events.IMAGE_UPLOAD, { 
          illusKey, 
          src: e.target.result 
        });
      };
      
      reader.readAsDataURL(file);
    },

    handleImageRemoval(event) {
      const illus = event.target.closest('.illus');
      const img = illus.querySelector('img');
      const rmButton = illus.querySelector('.rm');
      const illusKey = illus.dataset.illusKey;

      img.src = '';
      img.style.display = 'none';
      if (rmButton) rmButton.style.display = 'none';

      if (JdrApp.modules.images?.removeImage) {
        JdrApp.modules.images.removeImage(illusKey);
      }

      EventBus.emit(Events.IMAGE_DELETE, { illusKey });
    },

    toggleImageEnlargement(img) {
      if (img.classList.contains('enlarged')) {
        this.closeEnlargedImage();
      } else {
        this.showEnlargedImage(img);
      }
    },

    showEnlargedImage(img) {
      // Fermer toute image dÃ©jÃ  ouverte
      this.closeEnlargedImage();
      
      // CrÃ©er un conteneur modal complet
      const modal = document.createElement('div');
      modal.id = 'image-enlargement-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0,0,0,0.8);
        z-index: 2147483647;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: zoom-out;
      `;
      
      // CrÃ©er une copie de l'image
      const enlargedImg = img.cloneNode(true);
      enlargedImg.style.cssText = `
        max-width: 90vw;
        max-height: 90vh;
        width: auto;
        height: auto;
        object-fit: contain;
        border: 3px solid var(--gold);
        border-radius: 8px;
        background: white;
        box-shadow: 0 20px 60px rgba(0,0,0,.8), 0 0 20px rgba(212,175,55,.3);
        cursor: zoom-out;
      `;
      
      modal.appendChild(enlargedImg);
      document.body.appendChild(modal);
      
      // Fermer au clic et au touch pour mobile
      modal.onclick = () => this.closeEnlargedImage();
      modal.addEventListener('touchend', (e) => {
        if (e.target === modal) {
          e.preventDefault();
          this.closeEnlargedImage();
        }
      });
      
      // Fermer avec Ã‰chap
      const escapeHandler = (e) => {
        if (e.key === 'Escape') {
          this.closeEnlargedImage();
          document.removeEventListener('keydown', escapeHandler);
        }
      };
      document.addEventListener('keydown', escapeHandler);
      
      // Marquer l'image originale comme agrandie
      img.classList.add('enlarged');
    },

    closeEnlargedImage() {
      const modal = document.getElementById('image-enlargement-modal');
      if (modal) {
        modal.remove();
      }
      
      // Retirer la classe de toutes les images
      document.querySelectorAll('img.enlarged').forEach(img => {
        img.classList.remove('enlarged');
      });
      
      // Nettoyer les anciens backdrops
      const oldBackdrop = document.querySelector('.image-backdrop');
      if (oldBackdrop) {
        oldBackdrop.remove();
      }
    },


    saveChangesToStorage() {
      try {
        localStorage.setItem('jdr-bab-edits', JSON.stringify(this.editedData));
        localStorage.setItem('jdr-bab-last-modified', Date.now().toString());
        EventBus.emit(Events.STORAGE_SAVE);
      } catch (error) {
        // Failed to save changes
      }
    },

    forceCollectAllEdits() {
      // Collect page description edits before general edits
      this.collectPageDescriptionEdits();
      UnifiedEditor.saveAllEdits();
      return this.editedData;
    },

    collectPageDescriptionEdits() {
      // Check for edited table tresor page description
      const tablesTresorsDesc = document.querySelector('[data-section-type="table-tresor-category-description"] .editable');
      if (tablesTresorsDesc && tablesTresorsDesc.innerHTML) {
        const content = tablesTresorsDesc.innerHTML.trim();
        if (content && content !== "Tables de butin permettant de gÃ©nÃ©rer alÃ©atoirement des rÃ©compenses selon les fourchettes dÃ©finies. Lancez un dÃ© 20 et consultez la table correspondante pour dÃ©terminer l'objet obtenu.") {
          if (!window.TABLES_TRESORS_PAGE_DESC) {
            window.TABLES_TRESORS_PAGE_DESC = {};
          }
          window.TABLES_TRESORS_PAGE_DESC.description = content;
          console.log('ğŸ’¾ Collected Tables Tresors page description:', content);
        }
      }

      // Check for edited monster page description
      const monstersDesc = document.querySelector('[data-section-type="monster-category-description"] .editable');
      if (monstersDesc && monstersDesc.innerHTML) {
        const content = monstersDesc.innerHTML.trim();
        if (content && content !== "CrÃ©atures, ennemis et adversaires que peuvent affronter les hÃ©ros dans leurs aventures.") {
          if (!window.MONSTRES_PAGE_DESC) {
            window.MONSTRES_PAGE_DESC = {};
          }
          window.MONSTRES_PAGE_DESC.description = content;
          console.log('ğŸ’¾ Collected Monsters page description:', content);
        }
      }
    },


    saveAllEdits() {
      return UnifiedEditor.saveAllEdits();
    },

    regenerateCurrentPage() {
      // Force regeneration of only the current page content (not all pages)
      if (JdrApp.modules.renderer && JdrApp.modules.renderer.regenerateCurrentPage) {
        JdrApp.modules.renderer.regenerateCurrentPage();
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - SPELL FILTER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // SPELL FILTER MODULE
  // ========================================
  const SpellFilter = {
    
    init() {
      this.setupEventListeners();
    },

    setupEventListeners() {
      // Use direct event delegation on document to catch dynamically added elements
      document.addEventListener('input', (e) => {
        if (e.target && e.target.id === 'spell-level-filter') {
          this.filterSpellsByLevel(parseInt(e.target.value, 10));
        }
      });

      document.addEventListener('click', (e) => {
        if (e.target && e.target.id === 'reset-spell-filter') {
          e.preventDefault();
          this.resetFilter();
        }
      });

      // Setup when page changes (router events)
      if (window.EventBus && window.Events) {
        EventBus.on(Events.PAGE_RENDER, (payload) => {
          if (payload.type === 'category' && payload.categoryType === 'spell') {
            // Re-setup filter after page render
            setTimeout(() => this.initializeFilter(), 200);
          }
        });
      }

      // Also listen to hash changes for direct navigation
      window.addEventListener('hashchange', () => {
        setTimeout(() => this.initializeFilter(), 200);
      });
    },

    initializeFilter() {
      const filterInput = document.querySelector('#spell-level-filter');
      if (!filterInput) return;
      
      
      // Set initial value and apply filter
      const initialValue = parseInt(filterInput.value, 10) || 20;
      this.filterSpellsByLevel(initialValue);
    },

    filterSpellsByLevel(maxLevel) {
      
      // Get current page from URL hash
      const currentHash = window.location.hash.replace('#/', '');
      
      if (!currentHash.startsWith('sorts-')) {
        return;
      }
      
      // Find all spell cards in the current page
      const spellCards = document.querySelectorAll('.card[data-spell-name]');
      
      if (spellCards.length === 0) return;

      let visibleCount = 0;

      spellCards.forEach((card) => {
        const spellName = card.dataset.spellName;
        const categoryName = card.dataset.categoryName;
        
        // Find the spell data to get its level
        const spellLevel = this.getSpellLevel(spellName, categoryName);
        
        if (spellLevel <= maxLevel) {
          card.style.display = '';
          visibleCount++;
        } else {
          card.style.display = 'none';
        }
      });

      
      // Update filter display with count
      this.updateFilterDisplay(maxLevel, visibleCount, spellCards.length);
    },

    getSpellLevel(spellName, categoryName) {
      if (!window.SORTS) return 0;

      // Find the category
      const category = window.SORTS.find(cat => cat.nom === categoryName);
      if (!category || !category.sorts) return 0;

      // Find the spell
      const spell = category.sorts.find(sort => sort.nom === spellName);
      if (!spell || !spell.prerequis) return 0;

      // Extract level from prerequisite
      const match = spell.prerequis.match(/Niveau (\d+)/i);
      return match ? parseInt(match[1], 10) : 0;
    },

    updateFilterDisplay(maxLevel, visibleCount, totalCount) {
      const filterContainer = document.querySelector('.spell-level-filter');
      if (!filterContainer) return;

      // Remove existing count display
      let countDisplay = filterContainer.querySelector('.filter-count');
      if (countDisplay) {
        countDisplay.remove();
      }

      // Add new count display
      const countText = `ğŸ“Š ${visibleCount}/${totalCount} sorts affichÃ©s (niveau â‰¤ ${maxLevel})`;
      countDisplay = document.createElement('div');
      countDisplay.className = 'filter-count';
      countDisplay.style.cssText = 'margin-top: 0.5rem; font-size: 0.9rem; color: var(--bronze); font-weight: 500;';
      countDisplay.textContent = countText;
      
      filterContainer.appendChild(countDisplay);
    },

    resetFilter() {
      const filterInput = document.querySelector('#spell-level-filter');
      if (filterInput) {
        filterInput.value = '20';
        this.filterSpellsByLevel(20);
      }
    }
  };

  // Initialize the spell filter when the app is ready
  function initializeSpellFilter() {
    
    if (window.JdrApp) {
      if (JdrApp.modules) {
        JdrApp.modules.spellFilter = SpellFilter;
      }
    }
    
    // Initialize the filter
    SpellFilter.init();
    
    // Try to initialize the filter after a delay to ensure DOM is ready
    setTimeout(() => {
      if (window.location.hash.includes('sorts-')) {
        SpellFilter.initializeFilter();
      }
    }, 500);
  }

  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeSpellFilter);
  } else {
    // DOM is already ready
    initializeSpellFilter();
  }

  window.SpellFilter = SpellFilter;

})();
// ============================================================================
// JDR-BAB APPLICATION - TABLES DE TRESORS MANAGER
// ============================================================================

(() => {
  "use strict";

  class TablesTresorsManager {
    constructor() {
      this.initialized = false;
      this.currentPreviewModal = null;
      this.currentEditModal = null;
    }

    static getInstance() {
      if (!TablesTresorsManager.instance) {
        TablesTresorsManager.instance = new TablesTresorsManager();
      }
      return TablesTresorsManager.instance;
    }

    init() {
      if (this.initialized) return;
      
      this.setupEventListeners();
      this.initialized = true;
      // TablesTresorsManager initialized
    }

    setupEventListeners() {
      // Preview d'objets
      document.addEventListener('click', (e) => {
        if (e.target.matches('.object-preview-link')) {
          e.preventDefault();
          const numeroObjet = e.target.dataset.objectNumero;
          this.showObjectPreview(numeroObjet);
        }
      });

      // Ã‰dition de fourchette
      document.addEventListener('click', (e) => {
        if (e.target.matches('.edit-fourchette-btn')) {
          const tableName = e.target.dataset.tableName;
          const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
          this.showEditFourchetteModal(tableName, fourchetteIndex);
        }
      });

      // Suppression de fourchette
      document.addEventListener('click', (e) => {
        if (e.target.matches('.delete-fourchette-btn')) {
          const tableName = e.target.dataset.tableName;
          const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
          this.deleteFourchette(tableName, fourchetteIndex);
        }
      });

      // Ajout de nouvelle fourchette
      document.addEventListener('click', (e) => {
        if (e.target.matches('.table-tresor-add-fourchette')) {
          const tableName = e.target.dataset.tableTresorName;
          this.showEditFourchetteModal(tableName, -1); // -1 pour nouvelle fourchette
        }
      });

      // Fermer les modals en cliquant Ã  l'extÃ©rieur
      document.addEventListener('click', (e) => {
        if (e.target.matches('.modal-overlay')) {
          this.closeAllModals();
        }
      });

      // Fermer avec la touche Escape
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          this.closeAllModals();
        }
      });
    }

    showObjectPreview(numeroObjet) {
      try {
        // Trouver l'objet par son numÃ©ro
        const objet = window.OBJETS?.objets?.find(obj => obj.numero == numeroObjet);
        
        if (!objet) {
          console.error('Objet non trouvÃ©:', numeroObjet);
          return;
        }

        const previewHtml = this.generateObjectPreviewHtml(objet);
        this.showModal(previewHtml, 'object-preview');
        
      } catch (error) {
        console.error('Erreur lors de l\'affichage de la preview:', error);
      }
    }

    generateObjectPreviewHtml(objet) {
      const tagsDisplay = objet.tags?.map(tag => 
        `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`
      ).join('') || 'Aucun tag';

      return `
        <div class="object-preview-content">
          <header style="text-align: center; margin-bottom: 1rem; border-bottom: 2px solid var(--bronze); padding-bottom: 1rem;">
            <h3 style="margin: 0; color: var(--accent);">ğŸ“¦ ${objet.nom}</h3>
            <div style="color: var(--bronze); font-size: 0.9em;">Objet NÂ°${objet.numero}</div>
          </header>
          
          <div style="margin: 1rem 0;">
            <strong>Tags:</strong><br>
            ${tagsDisplay}
          </div>
          
          <div style="margin: 1rem 0;">
            <strong>Description:</strong><br>
            <div style="font-style: italic; margin: 0.5rem 0;">${objet.description || 'Aucune description'}</div>
          </div>
          
          <div style="margin: 1rem 0;">
            <strong>Effet:</strong><br>
            <div>${objet.effet || 'Aucun effet spÃ©cifiÃ©'}</div>
          </div>
          
          <div style="display: flex; gap: 1rem; margin: 1rem 0;">
            <div style="flex: 1;">
              <strong>Prix:</strong><br>
              ${objet.prix || 'Non spÃ©cifiÃ©'}
            </div>
            <div style="flex: 1;">
              <strong>Poids:</strong><br>
              ${objet.poids || 'Non spÃ©cifiÃ©'}
            </div>
          </div>
          
          <div style="text-align: center; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--rule);">
            <button class="btn" onclick="window.TablesTresorsManager.closeAllModals()" style="background: var(--accent); color: white;">
              âœ“ Fermer
            </button>
            <button class="btn" onclick="window.TablesTresorsManager.goToObject(${objet.numero})" style="background: var(--bronze); color: white; margin-left: 0.5rem;">
              ğŸ”— Aller Ã  la page objets
            </button>
          </div>
        </div>
      `;
    }

    showEditFourchetteModal(tableName, fourchetteIndex) {
      try {
        const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === tableName);
        if (!table) {
          console.error('Table non trouvÃ©e:', tableName);
          return;
        }

        const isNewFourchette = fourchetteIndex === -1;
        const fourchette = isNewFourchette ? { min: 1, max: 1, objet: { type: 'reference', numero: 1, nom: 'Choisir un objet' } } : table.fourchettes[fourchetteIndex];

        if (!isNewFourchette && !fourchette) {
          console.error('Fourchette non trouvÃ©e:', fourchetteIndex);
          return;
        }

        const editHtml = this.generateEditFourchetteHtml(tableName, fourchetteIndex, fourchette, isNewFourchette);
        this.showModal(editHtml, 'edit-fourchette');

      } catch (error) {
        console.error('Erreur lors de l\'affichage du modal d\'Ã©dition:', error);
      }
    }

    generateEditFourchetteHtml(tableName, fourchetteIndex, fourchette, isNewFourchette) {
      // GÃ©nÃ©rer la liste des objets disponibles
      const objetsOptions = window.OBJETS?.objets?.map(obj => 
        `<option value="${obj.numero}" ${obj.numero == fourchette.objet.numero ? 'selected' : ''}>NÂ°${obj.numero} - ${obj.nom}</option>`
      ).join('') || '<option value="1">Aucun objet disponible</option>';

      return `
        <div class="edit-fourchette-content">
          <header style="text-align: center; margin-bottom: 1rem; border-bottom: 2px solid var(--bronze); padding-bottom: 1rem;">
            <h3 style="margin: 0; color: var(--accent);">
              ${isNewFourchette ? 'â• Ajouter une fourchette' : 'âœï¸ Ã‰diter la fourchette'}
            </h3>
            <div style="color: var(--bronze); font-size: 0.9em;">Table: ${tableName}</div>
          </header>
          
          <form id="edit-fourchette-form">
            <div style="margin: 1rem 0;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: bold; color: var(--accent);">
                ğŸ² Fourchette de dÃ© (1-20):
              </label>
              <div style="display: flex; gap: 1rem; align-items: center;">
                <div style="flex: 1;">
                  <label style="font-size: 0.9em; color: var(--paper-muted);">Minimum:</label>
                  <input 
                    type="number" 
                    id="fourchette-min" 
                    min="1" 
                    max="20" 
                    value="${fourchette.min}"
                    style="width: 100%; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px;"
                    required
                  >
                </div>
                <div style="padding: 1rem 0.5rem; color: var(--accent); font-weight: bold;">-</div>
                <div style="flex: 1;">
                  <label style="font-size: 0.9em; color: var(--paper-muted);">Maximum:</label>
                  <input 
                    type="number" 
                    id="fourchette-max" 
                    min="1" 
                    max="20" 
                    value="${fourchette.max}"
                    style="width: 100%; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px;"
                    required
                  >
                </div>
              </div>
            </div>
            
            <div style="margin: 1rem 0;">
              <label style="display: block; margin-bottom: 0.5rem; font-weight: bold; color: var(--accent);">
                ğŸ“¦ Objet associÃ©:
              </label>
              <select 
                id="fourchette-objet" 
                style="width: 100%; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px;"
                required
              >
                ${objetsOptions}
              </select>
              <div style="margin-top: 0.5rem;">
                <button 
                  type="button" 
                  id="preview-selected-object" 
                  class="btn small" 
                  style="background: var(--bronze); color: white; font-size: 0.8em;"
                >
                  ğŸ‘ï¸ AperÃ§u de l'objet sÃ©lectionnÃ©
                </button>
              </div>
            </div>
            
            <div style="text-align: center; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--rule);">
              <button type="submit" class="btn" style="background: var(--accent); color: white;">
                ${isNewFourchette ? 'â• Ajouter' : 'âœ“ Sauvegarder'}
              </button>
              <button type="button" onclick="window.TablesTresorsManager.closeAllModals()" class="btn" style="background: #6b7280; color: white; margin-left: 0.5rem;">
                âŒ Annuler
              </button>
            </div>
          </form>
        </div>
      `;
    }

    showModal(content, modalClass = '') {
      this.closeAllModals(); // Fermer les modals existants

      const modalHtml = `
        <div class="modal-overlay ${modalClass}" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 1000;">
          <div class="modal-content" style="background: var(--paper); border-radius: 12px; padding: 2rem; max-width: 90vw; max-height: 90vh; overflow-y: auto; box-shadow: 0 10px 25px rgba(0,0,0,0.3); border: 2px solid var(--rule);">
            ${content}
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML('beforeend', modalHtml);
      
      // Setup form handler si c'est le modal d'Ã©dition
      if (modalClass === 'edit-fourchette') {
        this.setupEditFormHandlers();
      }
    }

    setupEditFormHandlers() {
      const form = document.getElementById('edit-fourchette-form');
      if (!form) return;

      form.addEventListener('submit', (e) => {
        e.preventDefault();
        this.saveFourchette();
      });

      // Preview de l'objet sÃ©lectionnÃ©
      const previewBtn = document.getElementById('preview-selected-object');
      if (previewBtn) {
        previewBtn.addEventListener('click', () => {
          const selectElement = document.getElementById('fourchette-objet');
          const selectedNumero = selectElement.value;
          this.showObjectPreview(selectedNumero);
        });
      }

      // Validation en temps rÃ©el
      const minInput = document.getElementById('fourchette-min');
      const maxInput = document.getElementById('fourchette-max');
      
      const validateRange = () => {
        const min = parseInt(minInput.value);
        const max = parseInt(maxInput.value);
        
        if (min > max) {
          maxInput.value = min;
        }
      };

      minInput.addEventListener('change', validateRange);
      maxInput.addEventListener('change', validateRange);
    }

    saveFourchette() {
      try {
        const form = document.getElementById('edit-fourchette-form');
        const formData = new FormData(form);
        
        const min = parseInt(document.getElementById('fourchette-min').value);
        const max = parseInt(document.getElementById('fourchette-max').value);
        const objetNumero = parseInt(document.getElementById('fourchette-objet').value);
        
        // Trouver l'objet sÃ©lectionnÃ©
        const objet = window.OBJETS?.objets?.find(obj => obj.numero === objetNumero);
        if (!objet) {
          alert('Objet sÃ©lectionnÃ© introuvable');
          return;
        }

        const newFourchette = {
          min: min,
          max: max,
          objet: {
            type: 'reference',
            numero: objet.numero,
            nom: objet.nom
          }
        };

        // Extraire les informations depuis le modal
        const tableName = document.querySelector('.edit-fourchette-content h3 + div').textContent.replace('Table: ', '');
        const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === tableName);
        
        if (!table) {
          console.error('Table non trouvÃ©e pour la sauvegarde');
          return;
        }

        // DÃ©terminer si c'est une nouvelle fourchette ou une modification
        const currentModal = document.querySelector('.modal-overlay.edit-fourchette');
        const isNewFourchette = currentModal?.querySelector('h3')?.textContent.includes('Ajouter');

        if (isNewFourchette) {
          table.fourchettes.push(newFourchette);
        } else {
          // Trouver l'index de la fourchette Ã  modifier (pas optimal mais fonctionne)
          // Pour une vraie app, il faudrait passer l'index via les donnÃ©es du modal
          // Mode modification - non implÃ©mentÃ© complÃ¨tement dans cette demo
        }

        // Sauvegarder et regÃ©nÃ©rer la page
        this.saveToStorage();
        this.refreshTablesTresorsPage();
        this.closeAllModals();
        
        // Fourchette sauvegardÃ©e avec succÃ¨s

      } catch (error) {
        console.error('Erreur lors de la sauvegarde:', error);
        alert('Erreur lors de la sauvegarde de la fourchette');
      }
    }

    deleteFourchette(tableName, fourchetteIndex) {
      if (!confirm('ÃŠtes-vous sÃ»r de vouloir supprimer cette fourchette ?')) {
        return;
      }

      try {
        const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === tableName);
        if (!table) {
          console.error('Table non trouvÃ©e:', tableName);
          return;
        }

        if (fourchetteIndex < 0 || fourchetteIndex >= table.fourchettes.length) {
          console.error('Index de fourchette invalide:', fourchetteIndex);
          return;
        }

        table.fourchettes.splice(fourchetteIndex, 1);
        
        this.saveToStorage();
        this.refreshTablesTresorsPage();
        
        // Fourchette supprimÃ©e avec succÃ¨s

      } catch (error) {
        console.error('Erreur lors de la suppression:', error);
        alert('Erreur lors de la suppression de la fourchette');
      }
    }

    goToObject(numeroObjet) {
      this.closeAllModals();
      // Naviguer vers la page objets avec focus sur l'objet spÃ©cifique
      JdrApp.modules.router.navigate('objets');
      
      // Optionnel: highlight l'objet aprÃ¨s navigation
      setTimeout(() => {
        const objectCard = document.querySelector(`[data-objet-name*="${numeroObjet}"]`);
        if (objectCard) {
          objectCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
          objectCard.style.border = '3px solid var(--accent)';
          setTimeout(() => {
            objectCard.style.border = '';
          }, 2000);
        }
      }, 500);
    }

    closeAllModals() {
      const modals = document.querySelectorAll('.modal-overlay');
      modals.forEach(modal => modal.remove());
      this.currentPreviewModal = null;
      this.currentEditModal = null;
    }

    saveToStorage() {
      // Utiliser le systÃ¨me de stockage existant
      if (JdrApp.modules.storage) {
        JdrApp.modules.storage.save();
      }
    }

    refreshTablesTresorsPage() {
      // RegÃ©nÃ©rer la page des tables de trÃ©sors
      if (JdrApp.modules.router && JdrApp.modules.router.getCurrentRoute() === 'tables-tresors') {
        JdrApp.modules.router.renderTablesTresorsPage();
      }
    }
  }

  // Exposer globalement pour les event handlers inline
  window.TablesTresorsManager = TablesTresorsManager.getInstance();

  // Auto-initialiser quand le DOM est prÃªt
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => window.TablesTresorsManager.init());
  } else {
    window.TablesTresorsManager.init();
  }

})();
// ============================================================================
// DYNAMIC CENTERING SYSTEM
// ============================================================================

(() => {
  "use strict";

  class DynamicCentering {
    constructor() {
      this.sidebarWidth = 350; // Width of the sidebar
      this.isEnabled = false;
      this.observer = null;
      this.rafId = null;
    }

    init() {
      this.isEnabled = true;
      this.setupResizeObserver();
      this.setupWindowResize();
      // Initial calculation
      this.updateCentering();
    }

    setupResizeObserver() {
      if (!window.ResizeObserver) return;

      // Observe changes to the main content container
      const viewsContainer = document.getElementById('views');
      if (!viewsContainer) return;

      this.observer = new ResizeObserver(() => {
        if (this.rafId) {
          cancelAnimationFrame(this.rafId);
        }
        this.rafId = requestAnimationFrame(() => this.updateCentering());
      });

      this.observer.observe(viewsContainer);
    }

    setupWindowResize() {
      let resizeTimer;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => this.updateCentering(), 100);
      });
    }

    updateCentering() {
      if (!this.isEnabled) return;

      const viewsContainer = document.getElementById('views');
      if (!viewsContainer) return;

      // Get actual container dimensions
      const containerRect = viewsContainer.getBoundingClientRect();
      const actualContentWidth = containerRect.width;
      const viewportWidth = window.innerWidth;

      // Calculate available space after sidebar
      const availableSpace = viewportWidth - this.sidebarWidth;
      
      // Calculate optimal margin to center content in available space
      const optimalMarginLeft = this.sidebarWidth + (availableSpace - actualContentWidth) / 2;

      // Apply the centering with bounds checking
      const minMarginLeft = this.sidebarWidth + 20; // Minimum clearance
      const maxMarginLeft = viewportWidth - actualContentWidth - 20; // Don't overflow right
      
      const finalMarginLeft = Math.max(minMarginLeft, Math.min(optimalMarginLeft, maxMarginLeft));

      // Apply the calculated margin
      viewsContainer.style.marginLeft = `${finalMarginLeft}px`;
      viewsContainer.style.marginRight = '20px';

      // Debug info (remove in production)
      if (window.location.hash.includes('debug-centering')) {
        console.log('ğŸ¯ Dynamic Centering:', {
          viewportWidth,
          availableSpace,
          actualContentWidth,
          optimalMarginLeft,
          finalMarginLeft
        });
      }
    }

    disable() {
      this.isEnabled = false;
      if (this.observer) {
        this.observer.disconnect();
      }
      if (this.rafId) {
        cancelAnimationFrame(this.rafId);
      }
      
      // Reset to CSS default
      const viewsContainer = document.getElementById('views');
      if (viewsContainer) {
        viewsContainer.style.marginLeft = '';
        viewsContainer.style.marginRight = '';
      }
    }
  }

  // Initialize the dynamic centering system
  const dynamicCentering = new DynamicCentering();

  // Attach to JdrApp
  if (window.JdrApp) {
    JdrApp.modules.dynamicCentering = dynamicCentering;
  }

  // Auto-initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      // Delay initialization to ensure layout is stable
      setTimeout(() => dynamicCentering.init(), 500);
    });
  } else {
    setTimeout(() => dynamicCentering.init(), 500);
  }

  // Make it globally available for debugging
  window.DynamicCentering = dynamicCentering;

})();
// ============================================================================
// JSPDF LOADER - Character Sheet PDF Generation Support
// ============================================================================

(() => {
  "use strict";

  // Check if jsPDF is already loaded
  if (window.jsPDF) {
    return;
  }

  // For standalone builds, we need to handle jsPDF loading
  const loadJsPDF = () => {
    return new Promise((resolve, reject) => {
      const script = document.createElement('script');
      script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
      script.onload = () => {
        resolve();
      };
      script.onerror = () => {
        console.error('âŒ Failed to load jsPDF');
        reject();
      };
      document.head.appendChild(script);
    });
  };

  // Load jsPDF if not available
  if (typeof window.jsPDF === 'undefined') {
    loadJsPDF().catch(() => {
      // Silent fallback - PDF generation will not be available
    });
  }

})();
// ============================================================================
// JDR-BAB APPLICATION - UI MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // UI INTERACTIONS MODULE
  // ========================================
  JdrApp.modules.ui = {
    _initialized: false,
    
    init() {
      // Prevent multiple initialization to avoid duplicate event listeners
      if (this._initialized) {
        return;
      }
      
      this.setupEventListeners();
      this.setupSearch();
      this.setupModals();
      this.setupResponsive();
      this.setupNewPageHandler();
      this._initialized = true;
    },

    setupEventListeners() {
      // Content management via EventBus
      EventBus.on(Events.CONTENT_ADD, (payload) => {
        this.handleContentAdd(payload.type, payload.category, payload.item);
      });

      EventBus.on(Events.CONTENT_DELETE, (payload) => {
        this.handleContentDelete(payload.type, payload.category, payload.item);
      });

      EventBus.on(Events.CONTENT_MOVE, (payload) => {
        this.handleContentMove(payload.type, payload.category, payload.itemName, payload.direction);
      });

      // UI event handlers
      this.setupContentHandlers();
      this.setupTagsManagement();
    },

    setupContentHandlers() {
      // Generic content addition
      JdrApp.utils.events.register('click', '[class$="-add"]', (e) => {
        const type = this.extractTypeFromClass(e.target.className);
        const categoryName = e.target.dataset.categoryName;
        
        if (type && categoryName) {
          this.addContent(type, categoryName);
        }
      });

      // Generic content deletion - using multiple specific selectors
      JdrApp.utils.events.register('click', '.spell-delete, .don-delete, .delete-subclass-btn, .objet-delete, .monster-delete, .tableTresor-delete', (e) => {
        const type = this.extractTypeFromClass(e.target.className);
        const categoryName = e.target.dataset.categoryName;
        
        // Handle different dataset attribute naming patterns
        let itemName;
        if (type === 'spell') {
          itemName = e.target.dataset.spellName;
        } else if (type === 'don') {
          itemName = e.target.dataset.donName;
        } else if (type === 'objet') {
          itemName = e.target.dataset.objetName;
        } else if (type === 'monster') {
          itemName = e.target.dataset.monsterName;
        } else if (type === 'tableTresor') {
          itemName = e.target.dataset.tableTresorName;
        } else if (type === 'class') {
          itemName = e.target.dataset.className || e.target.dataset.subclassName;
        } else {
          itemName = e.target.dataset[`${type}Name`];
        }
        
        if (type && categoryName && itemName) {
          this.deleteContent(type, categoryName, itemName);
        }
      });

      // Generic content movement
      JdrApp.utils.events.register('click', '[class*="-move-"]', (e) => {
        const type = this.extractTypeFromClass(e.target.className);
        const categoryName = e.target.dataset.categoryName;
        
        // Handle different dataset attribute naming patterns
        let itemName;
        if (type === 'spell') {
          itemName = e.target.dataset.spellName;
        } else if (type === 'don') {
          itemName = e.target.dataset.donName;
        } else if (type === 'tableTresor') {
          itemName = e.target.dataset.tableTresorName;
        } else if (type === 'class') {
          itemName = e.target.dataset.className || e.target.dataset.subclassName;
        } else {
          itemName = e.target.dataset[`${type}Name`];
        }
        
        const direction = e.target.className.includes('move-up') ? -1 : 1;
        
        if (type && categoryName && itemName) {
          this.moveContent(type, categoryName, itemName, direction);
        }
      });

      // Filter manager button for objects
      JdrApp.utils.events.register('click', '.filter-manager-btn', () => {
        this.showFilterManagementModal();
      });

      // Tags manager button for objects
      JdrApp.utils.events.register('click', '.tags-manager-btn', () => {
        this.showTagsManagementModal();
      });

      // Filter chip toggle for objects
      JdrApp.utils.events.register('click', '.filter-chip', (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.toggleFilter(e.target);
      });

      // Select all tags button
      JdrApp.utils.events.register('click', '#select-all-tags', () => {
        this.selectAllTags();
      });

      // Select no tags button
      JdrApp.utils.events.register('click', '#select-no-tags', () => {
        this.selectNoTags();
      });

      // ID search functionality (only on Enter key or button click)
      JdrApp.utils.events.register('keydown', '#id-search-input', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          this.performIdSearch(e.target.value);
        } else if (e.key === 'Escape') {
          e.target.value = '';
          this.clearIdSearch();
        }
      });

      JdrApp.utils.events.register('click', '#clear-id-search', () => {
        this.clearIdSearch();
      });

      // Spell element change
      JdrApp.utils.events.register('change', '.spell-element-selector select', (e) => {
        this.updateSpellElement(e.target);
      });

      // Paragraph addition
      JdrApp.utils.events.register('click', '.add-paragraph-btn', (e) => {
        const target = e.target.dataset.target;
        this.addParagraph(target, e.target);
      });

      // Section deletion for static pages
      JdrApp.utils.events.register('click', '.section-delete', (e) => {
        const sectionName = e.target.dataset.sectionName;
        if (sectionName && confirm(`Supprimer la section "${sectionName}" ?`)) {
          this.deleteSection(sectionName, e.target);
        }
      });

      // Dev toolbox category creation buttons
      JdrApp.utils.events.register('click', '#addSpellCategory', () => {
        this.createNewCategory('spell');
      });

      JdrApp.utils.events.register('click', '#addDonCategory', () => {
        this.createNewCategory('don');
      });

      // Category deletion buttons
      JdrApp.utils.events.register('click', '[class$="-category-delete"]', (e) => {
        const categoryName = e.target.dataset.categoryName;
        const categoryType = e.target.dataset.categoryType;
        
        if (categoryName && categoryType) {
          this.deleteCategory(categoryType, categoryName);
        }
      });

      // Filter management for objects page
      JdrApp.utils.events.register('click', '.filter-manager-btn', (e) => {
        this.showFilterManagementModal();
      });

      // Tables de trÃ©sors - Edition des fourchettes
      JdrApp.utils.events.register('click', '.edit-fourchette-btn', (e) => {
        const tableName = e.target.dataset.tableName;
        const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
        
        if (tableName && fourchetteIndex >= 0) {
          this.editFourchette(tableName, fourchetteIndex);
        }
      });

      // Tables de trÃ©sors - Suppression des fourchettes
      JdrApp.utils.events.register('click', '.delete-fourchette-btn', (e) => {
        const tableName = e.target.dataset.tableName;
        const fourchetteIndex = parseInt(e.target.dataset.fourchetteIndex);
        
        if (tableName && fourchetteIndex >= 0) {
          if (confirm('ÃŠtes-vous sÃ»r de vouloir supprimer cette fourchette ?')) {
            this.deleteFourchette(tableName, fourchetteIndex);
          }
        }
      });

      // Tables de trÃ©sors - Ajout de fourchettes
      JdrApp.utils.events.register('click', '.table-tresor-add-fourchette', (e) => {
        const tableName = e.target.dataset.tableTresorName;
        
        if (tableName) {
          this.addFourchette(tableName);
        }
      });

      // Tables de trÃ©sors - PrÃ©visualisation des objets
      JdrApp.utils.events.register('click', '.object-preview-link', (e) => {
        e.preventDefault();
        const objetNumero = parseInt(e.target.dataset.objectNumero);
        
        if (objetNumero) {
          this.showObjectPreview(objetNumero);
        }
      });

      // Filter chip toggling (REMOVED - duplicate listener that was causing double toggle)

      // Element selector for spells (dev mode)
      JdrApp.utils.events.register('change', '.spell-element-selector', (e) => {
        this.updateSpellElement(e.target);
      });

      // Print button for states page
      JdrApp.utils.events.register('click', '#print-etats-btn', () => {
        this.printStates();
      });
    },

    setupTagsManagement() {
      // Handle manage tags button clicks
      JdrApp.utils.events.register('click', '.manage-tags-btn', (e) => {
        const contentType = e.target.dataset.contentType;
        if (contentType === 'monster') {
          this.showMonsterTagsManagement();
        } else if (contentType === 'tableTresor') {
          this.showTableTresorTagsManagement();
        }
      });
    },

    showMonsterTagsManagement() {
      const config = window.ContentTypes.monster;
      if (!config || !config.filterConfig) {
        this.showNotification('Configuration des tags monstres non trouvÃ©e', 'error');
        return;
      }

      // Remove existing modal if any
      const existingModal = document.querySelector('#monsterTagsModal');
      if (existingModal) {
        existingModal.remove();
      }

      const availableTags = config.filterConfig.availableTags || [];
      const modal = this.createMonsterTagsModal(availableTags);
      document.body.appendChild(modal);
      
      // Use native dialog showModal for proper z-index
      modal.showModal();
    },

    showTableTresorTagsManagement() {
      // Priority: Load tags from metadata, then config, then fallback
      let availableTags = [];
      
      if (window.TABLES_TRESORS?._metadata?.availableTags) {
        availableTags = window.TABLES_TRESORS._metadata.availableTags;
      } else {
        // Initialize metadata if missing (shouldn't happen normally)
        availableTags = ['ForÃªt', 'Boss', 'Coffre'];
        if (window.TABLES_TRESORS) {
          if (!window.TABLES_TRESORS._metadata) {
            window.TABLES_TRESORS._metadata = {};
          }
          window.TABLES_TRESORS._metadata.availableTags = [...availableTags];
        }
      }

      // Remove existing modal if any
      const existingModal = document.querySelector('#tableTresorTagsModal');
      if (existingModal) {
        existingModal.remove();
      }
      const modal = this.createTableTresorTagsModal(availableTags);
      document.body.appendChild(modal);
      
      // Use native dialog showModal for proper z-index
      modal.showModal();
    },

    createMonsterTagsModal(availableTags) {
      const modal = document.createElement('dialog');
      modal.id = 'monsterTagsModal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        padding: 0;
        border: none;
        border-radius: 12px;
        background: transparent;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      `;
      
      modal.innerHTML = `
        <div style="background: var(--paper); padding: 24px; border-radius: 12px; border: 3px solid var(--bronze);">
          <h3 style="margin: 0 0 16px 0; color: var(--bronze); display: flex; align-items: center; gap: 8px;">
            ğŸ·ï¸ GÃ©rer les tags - Monstres
          </h3>
          <p style="margin: 0 0 20px 0; color: var(--text-muted);">
            Ajoutez, modifiez ou supprimez les tags disponibles pour le filtrage des monstres.
          </p>
          
          <div class="current-tags" style="margin-bottom: 20px;">
            <h4 style="margin: 0 0 12px 0; color: var(--bronze);">Tags actuels:</h4>
            <div class="tags-list" style="display: flex; flex-wrap: wrap; gap: 12px;">
              ${availableTags.map(tag => `
                <div class="tag-item" style="display: flex; align-items: center; background: #f5f5f5; border: 2px solid #ddd; border-radius: 8px; padding: 8px 12px;">
                  <span class="tag-name" style="margin-right: 12px; font-weight: 600; color: #333;">${tag}</span>
                  <button 
                    class="delete-monster-tag-btn" 
                    data-tag="${tag}" 
                    type="button"
                    style="background: #dc2626; color: white; border: none; padding: 6px 10px; font-size: 14px; border-radius: 4px; cursor: pointer;"
                    title="Supprimer ${tag}"
                  >ğŸ—‘ï¸</button>
                </div>
              `).join('')}
            </div>
          </div>

          <div class="add-tag-section" style="margin-bottom: 20px;">
            <h4 style="margin: 0 0 12px 0; color: var(--bronze);">Ajouter un nouveau tag:</h4>
            <div style="display: flex; gap: 8px; align-items: center;">
              <input type="text" id="new-monster-tag-input" placeholder="Nom du nouveau tag" style="flex: 1; padding: 8px 12px; border: 2px solid var(--rule); border-radius: 6px; font-size: 14px;">
              <button class="btn btn-primary" id="add-monster-tag-btn" style="padding: 8px 16px; background: var(--bronze); color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">â• Ajouter</button>
            </div>
          </div>
          
          <div style="text-align: right; padding-top: 20px; border-top: 2px solid var(--rule);">
            <button type="button" class="btn modal-close" style="padding: 8px 16px; background: var(--paper-light); border: 2px solid var(--rule); border-radius: 6px; cursor: pointer;">Fermer</button>
          </div>
        </div>
      `;

      // Setup event handlers for this modal
      this.setupMonsterTagsModalEvents(modal, availableTags);

      return modal;
    },

    createTableTresorTagsModal(availableTags) {
      const modal = document.createElement('dialog');
      modal.id = 'tableTresorTagsModal';
      modal.style.cssText = `
        max-width: 500px;
        width: 90%;
        border: 2px solid var(--gold);
        border-radius: 12px;
        padding: 0;
        background: #2a2a2a;
        color: #ffffff;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(8px);
      `;
      
      const tagsListHTML = availableTags.map(tag => `
        <div class="tag-item" style="display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; margin: 4px 0; background: #3a3a3a; border-radius: 6px; border-left: 4px solid var(--gold);">
          <span style="font-weight: 500; color: #ffffff;">${tag}</span>
          <button type="button" class="delete-table-tresor-tag-btn" data-tag="${tag}" style="background: #dc2626; color: white; border: none; border-radius: 4px; padding: 4px 8px; font-size: 0.8em; cursor: pointer;" title="Supprimer ce tag">ğŸ—‘ï¸</button>
        </div>
      `).join('');
      
      modal.innerHTML = `
        <div style="padding: 24px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
            <h3 style="margin: 0; color: var(--gold); display: flex; align-items: center; gap: 8px;">
              ğŸ’ <span>GÃ©rer les Tags - Tables de TrÃ©sors</span>
            </h3>
            <button type="button" class="modal-close-btn" style="background: none; border: none; font-size: 1.5em; cursor: pointer; color: var(--text-color);" title="Fermer">Ã—</button>
          </div>
          
          <div style="margin-bottom: 20px;">
            <label style="display: block; margin-bottom: 8px; font-weight: 600;">Ajouter un nouveau tag :</label>
            <div style="display: flex; gap: 8px;">
              <input type="text" id="newTableTresorTagInput" placeholder="Ex: Boss, Mythique..." style="flex: 1; padding: 8px 12px; border: 1px solid var(--gold); border-radius: 6px; background: #1a1a1a; color: #ffffff;">
              <button type="button" id="addTableTresorTagBtn" style="background: var(--accent); color: white; border: none; border-radius: 6px; padding: 8px 16px; cursor: pointer; font-weight: 500;">
                â• Ajouter
              </button>
            </div>
          </div>
          
          <div style="margin-bottom: 20px;">
            <h4 style="margin: 0 0 12px 0; color: var(--gold);">Tags existants :</h4>
            <div id="tableTresorTagsList" style="max-height: 300px; overflow-y: auto;">
              ${tagsListHTML}
            </div>
          </div>
          
          <div style="text-align: center; padding-top: 16px; border-top: 1px solid var(--rule);">
            <button type="button" class="modal-close-btn" style="background: var(--secondary-color); color: white; border: none; border-radius: 6px; padding: 10px 20px; cursor: pointer; font-weight: 500;">
              Fermer
            </button>
          </div>
        </div>
      `;
      
      // Setup event handlers for this modal
      this.setupTableTresorTagsModalEvents(modal, availableTags);

      return modal;
    },

    setupMonsterTagsModalEvents(modal, availableTags) {
      // Close modal
      modal.querySelector('.modal-close').addEventListener('click', () => {
        modal.close();
      });

      // Add new tag
      const addBtn = modal.querySelector('#add-monster-tag-btn');
      const newTagInput = modal.querySelector('#new-monster-tag-input');
      
      const addTag = () => {
        const newTag = newTagInput.value.trim();
        if (newTag && !availableTags.includes(newTag)) {
          window.ContentTypes.monster.filterConfig.availableTags.push(newTag);
          modal.close();
          this.showMonsterTagsManagement(); // Refresh modal
          this.showNotification(`Tag "${newTag}" ajoutÃ© avec succÃ¨s`, 'success');
        } else if (newTag && availableTags.includes(newTag)) {
          this.showNotification('Ce tag existe dÃ©jÃ ', 'error');
        }
      };

      addBtn.addEventListener('click', addTag);
      newTagInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          addTag();
        }
      });

      // Delete tag buttons using event delegation
      modal.addEventListener('click', (e) => {        
        // Check if the clicked element is a delete button
        if (e.target && (e.target.classList.contains('delete-monster-tag-btn') || 
            e.target.closest('.delete-monster-tag-btn'))) {
          
          e.preventDefault();
          e.stopPropagation();
          
          // Get the button element (might be clicked on emoji inside)
          const button = e.target.classList.contains('delete-monster-tag-btn') ? 
                        e.target : e.target.closest('.delete-monster-tag-btn');
          
          const tagToDelete = button.dataset.tag;
          
          if (!tagToDelete) {
            console.error('No tag found on delete button:', button);
            this.showNotification('âŒ Erreur: tag non trouvÃ©', 'error');
            return;
          }
          
          const config = window.ContentTypes.monster;
          if (!config || !config.filterConfig || !config.filterConfig.availableTags) {
            console.error('Monster config not found or invalid');
            this.showNotification('âŒ Configuration des monstres non trouvÃ©e', 'error');
            return;
          }
          
          const index = config.filterConfig.availableTags.indexOf(tagToDelete);
          
          if (index > -1) {
            // Confirm deletion
            if (confirm(`ÃŠtes-vous sÃ»r de vouloir supprimer le tag "${tagToDelete}" ?\n\nCela supprimera aussi ce tag de tous les monstres qui l'utilisent.`)) {
              // Remove from available tags
              config.filterConfig.availableTags.splice(index, 1);
              
              // Remove the tag from all monsters
              if (window.MONSTRES && Array.isArray(window.MONSTRES)) {
                window.MONSTRES.forEach(monster => {
                  if (monster.tags && monster.tags.includes(tagToDelete)) {
                    monster.tags = monster.tags.filter(tag => tag !== tagToDelete);
                    // Ensure monster has at least one tag if possible
                    if (monster.tags.length === 0 && config.filterConfig.availableTags.length > 0) {
                      monster.tags = [config.filterConfig.availableTags[0]];
                    }
                  }
                });
              }
              
              // Update filter state to remove deleted tag
              if (window.MONSTRES_FILTER_STATE && window.MONSTRES_FILTER_STATE.visibleTags) {
                window.MONSTRES_FILTER_STATE.visibleTags = 
                  window.MONSTRES_FILTER_STATE.visibleTags.filter(tag => tag !== tagToDelete);
                // Ensure at least one visible tag remains
                if (window.MONSTRES_FILTER_STATE.visibleTags.length === 0 && 
                    config.filterConfig.availableTags.length > 0) {
                  window.MONSTRES_FILTER_STATE.visibleTags = [config.filterConfig.availableTags[0]];
                }
              }
              
              // Save the updated availableTags in the monster data for persistence
              if (window.MONSTRES && Array.isArray(window.MONSTRES)) {
                // Store availableTags in the first monster's metadata or create a special entry
                if (!window.MONSTRES._metadata) {
                  window.MONSTRES._metadata = {};
                }
                window.MONSTRES._metadata.availableTags = [...config.filterConfig.availableTags];
              }
              
              // Save changes to storage
              EventBus.emit(Events.STORAGE_SAVE);
              
              // Refresh modal and monsters page
              modal.close();
              this.showMonsterTagsManagement();
              
              // Force complete page reload for monsters page to update filters
              const currentPage = window.location.hash.replace('#/', '');
              if (currentPage === 'monstres') {
                // Trigger router to completely rebuild the page
                setTimeout(() => {
                  if (JdrApp.modules.router && JdrApp.modules.router.show) {
                    JdrApp.modules.router.show('monstres');
                  }
                }, 100);
              }
              
              this.showNotification(`âœ… Tag "${tagToDelete}" supprimÃ© avec succÃ¨s`, 'success');
            }
          } else {
            console.error(`Tag "${tagToDelete}" not found in available tags`);
            this.showNotification(`âŒ Tag "${tagToDelete}" non trouvÃ©`, 'error');
          }
        }
      });
    },

    setupTableTresorTagsModalEvents(modal, availableTags) {
      // Close modal
      const closeButtons = modal.querySelectorAll('.modal-close-btn');
      closeButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          modal.close();
          modal.remove();
        });
      });

      const newTagInput = modal.querySelector('#newTableTresorTagInput');
      const addBtn = modal.querySelector('#addTableTresorTagBtn');

      const addTag = () => {
        const newTag = newTagInput.value.trim();
        
        if (newTag && !availableTags.includes(newTag)) {
          // Add to the current available tags
          availableTags.push(newTag);
          
          // Save in TABLES_TRESORS metadata for persistence (primary storage)
          if (window.TABLES_TRESORS) {
            if (!window.TABLES_TRESORS._metadata) {
              window.TABLES_TRESORS._metadata = {};
            }
            window.TABLES_TRESORS._metadata.availableTags = [...availableTags];
          }
          
          // Note: ContentTypes.tableTresor.filterConfig.availableTags removed - metadata is single source of truth
          
          // Save changes to storage
          EventBus.emit(Events.STORAGE_SAVE);
          
          // Refresh modal and tables page
          modal.close();
          this.showTableTresorTagsManagement(); // Refresh modal
          this.showNotification(`Tag "${newTag}" ajoutÃ© avec succÃ¨s`, 'success');
        } else if (newTag && availableTags.includes(newTag)) {
          this.showNotification('Ce tag existe dÃ©jÃ ', 'error');
        }
      };

      addBtn.addEventListener('click', addTag);
      newTagInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          addTag();
        }
      });

      // Delete tag buttons using event delegation
      modal.addEventListener('click', (e) => {        
        // Check if the clicked element is a delete button
        if (e.target && (e.target.classList.contains('delete-table-tresor-tag-btn') || 
            e.target.closest('.delete-table-tresor-tag-btn'))) {
          
          e.preventDefault();
          e.stopPropagation();
          
          const deleteBtn = e.target.classList.contains('delete-table-tresor-tag-btn') 
            ? e.target 
            : e.target.closest('.delete-table-tresor-tag-btn');
          
          const tagToDelete = deleteBtn.dataset.tag;
          
          if (confirm(`ÃŠtes-vous sÃ»r de vouloir supprimer le tag "${tagToDelete}" ?\n\nCela supprimera le tag de tous les filtres et des tables qui l'utilisent.`)) {
            // Get current availableTags from metadata if available, otherwise from config
            let currentAvailableTags = window.TABLES_TRESORS?._metadata?.availableTags || 
                                     window.ContentTypes?.tableTresor?.filterConfig?.availableTags || 
                                     availableTags;
            
            const tagIndex = currentAvailableTags.indexOf(tagToDelete);
            
            if (tagIndex > -1) {
              // Remove from available tags
              currentAvailableTags.splice(tagIndex, 1);
              
              // Remove from all tables that use this tag
              if (window.TABLES_TRESORS?.tables) {
                window.TABLES_TRESORS.tables.forEach(table => {
                  if (table.tags && table.tags.includes(tagToDelete)) {
                    const tableTagIndex = table.tags.indexOf(tagToDelete);
                    table.tags.splice(tableTagIndex, 1);
                  }
                });
              }
              
              // Save in TABLES_TRESORS metadata for persistence (primary storage)
              if (window.TABLES_TRESORS) {
                if (!window.TABLES_TRESORS._metadata) {
                  window.TABLES_TRESORS._metadata = {};
                }
                window.TABLES_TRESORS._metadata.availableTags = [...currentAvailableTags];
              }
              
              // Note: ContentTypes backup removed - metadata is single source of truth
              
              // Clear filter state to force refresh
              if (window.TABLES_TRESORS_FILTER_STATE && window.TABLES_TRESORS_FILTER_STATE.visibleTags) {
                // Remove the deleted tag from visible tags if present  
                const visibleTagIndex = window.TABLES_TRESORS_FILTER_STATE.visibleTags.indexOf(tagToDelete);
                if (visibleTagIndex > -1) {
                  window.TABLES_TRESORS_FILTER_STATE.visibleTags.splice(visibleTagIndex, 1);
                }
              }
              
              // Save changes to storage
              EventBus.emit(Events.STORAGE_SAVE);
              
              // Close modal first 
              modal.close();
              
              // Force complete page reload for tables page to update filters
              const currentPage = window.location.hash.replace('#/', '');
              if (currentPage === 'tables-tresors') {
                // Trigger router to completely rebuild the page
                setTimeout(() => {
                  if (JdrApp.modules.router && JdrApp.modules.router.renderTablesTresorsPage) {
                    JdrApp.modules.router.renderTablesTresorsPage();
                  }
                }, 100);
              }
              
              // Refresh modal after page update
              setTimeout(() => {
                this.showTableTresorTagsManagement();
              }, 200);
              
              this.showNotification(`âœ… Tag "${tagToDelete}" supprimÃ© avec succÃ¨s`, 'success');
            }
          } else {
            console.error(`Tag "${tagToDelete}" not found in available tags`);
            this.showNotification(`âŒ Tag "${tagToDelete}" non trouvÃ©`, 'error');
          }
        }
      });
    },

    extractTypeFromClass(className) {
      if (className.includes('spell')) return 'spell';
      if (className.includes('don')) return 'don';
      if (className.includes('class')) return 'class';
      if (className.includes('objet')) return 'objet';
      if (className.includes('monster')) return 'monster';
      if (className.includes('tableTresor')) return 'tableTresor';
      return null;
    },

    deleteContent(type, categoryName, itemName) {
      if (!confirm(`Supprimer "${itemName}" ?`)) return;

      const success = ContentFactory.deleteItem(type, categoryName, itemName);
      
      if (success) {
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: type,
          category: ContentFactory.getEntity(type).findCategory(categoryName)
        });
        
        this.showNotification('ğŸ—‘ Ã‰lÃ©ment supprimÃ©');
      }
    },

    moveContent(type, categoryName, itemName, direction) {
      const success = ContentFactory.moveItem(type, categoryName, itemName, direction);
      
      if (success) {
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: type,
          category: ContentFactory.getEntity(type).findCategory(categoryName)
        });
        
        const directionText = direction > 0 ? 'descendu' : 'montÃ©';
        this.showNotification(`ğŸ”„ Ã‰lÃ©ment ${directionText}`);
      }
    },

    addParagraph(target, button) {
      // Handle different types of additions based on target
      if (target === 'section') {
        this.addNewSection(button);
      } else {
        this.addParagraphToSection(target, button);
      }
    },

    addNewSection(button) {
      // Generate a unique but readable ID
      const pageId = this.getCurrentPageId();
      const sectionCount = this.countExistingSections();
      const sectionId = `${pageId}-new-${sectionCount + 1}-${Date.now()}`;
      
      const newSection = document.createElement('div');
      newSection.className = 'card editable-section';
      newSection.dataset.sectionType = 'card';
      newSection.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${sectionId}-title">Nouvelle section</h3>
            <button class="edit-btn edit-title-btn" title="Ã‰diter le titre">âœï¸</button>
          </div>
        </div>
        <div style="position:relative;">
          <div class="editable" data-edit-type="generic" data-edit-section="${sectionId}">
            <p>Contenu de la nouvelle section.</p>
          </div>
          <button class="edit-btn edit-section-btn" title="Ã‰diter cette section">âœï¸</button>
        </div>
        <div style="margin-top: 1rem; text-align: center;">
          <button class="section-delete btn small" data-section-name="Nouvelle section" type="button" style="background: #ff6b6b; color: white;">ğŸ—‘ Supprimer section</button>
        </div>
      `;
      
      button.parentNode.insertBefore(newSection, button);
      
      // Immediately save the new section to JSON
      this.saveNewSectionToJSON(sectionId, "Nouvelle section", "<p>Contenu de la nouvelle section.</p>");
      
      // No need to recalculate indices - unique IDs prevent conflicts
      // this.recalculateSectionIndices();
      
      // Trigger persistent storage save
      this.triggerDataSave();
      
      this.showNotification('â• Nouvelle section ajoutÃ©e et sauvegardÃ©e');
    },

    addParagraphToSection(target, button) {
      // Generate a unique but readable ID
      const pageId = this.getCurrentPageId();
      const sectionCount = this.countExistingSections();
      const paragraphId = `${pageId}-para-${sectionCount + 1}-${Date.now()}`;
      
      const container = document.createElement('div');
      container.className = 'editable-paragraph card';
      container.dataset.sectionType = 'card';
      container.style.position = 'relative';
      container.style.marginTop = '1rem';
      
      container.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${paragraphId}-title">Nouveau paragraphe</h3>
            <button class="edit-btn edit-title-btn" title="Ã‰diter le titre">âœï¸</button>
          </div>
        </div>
        <div style="position:relative;">
          <div class="editable" data-edit-type="generic" data-edit-section="${paragraphId}">
            <p>Contenu du nouveau paragraphe.</p>
          </div>
          <button class="edit-btn edit-section-btn" title="Ã‰diter cette section">âœï¸</button>
        </div>
        <div style="margin-top: 1rem; text-align: center;">
          <button class="section-delete btn small" data-section-name="Nouveau paragraphe" type="button" style="background: #ff6b6b; color: white;">ğŸ—‘ Supprimer section</button>
        </div>
      `;
      
      button.parentNode.insertBefore(container, button);
      
      // Immediately save the new paragraph as a section to JSON
      this.saveNewSectionToJSON(paragraphId, "Nouveau paragraphe", "<p>Contenu du nouveau paragraphe.</p>");
      
      // No need to recalculate indices - unique IDs prevent conflicts
      // this.recalculateSectionIndices();
      
      // Trigger persistent storage save
      this.triggerDataSave();
      
      this.showNotification('â• Paragraphe ajoutÃ© et sauvegardÃ©');
    },

    deleteSection(sectionName, button) {
      // Find and remove the section
      const section = button.closest('.card');
      if (section) {
        // Extract the section ID from the editable elements
        const editableElement = section.querySelector('[data-edit-section]');
        let sectionId = null;
        if (editableElement) {
          sectionId = editableElement.dataset.editSection;
          // Remove "-title" suffix if present to get base ID
          if (sectionId.endsWith('-title')) {
            sectionId = sectionId.replace('-title', '');
          }
        }
        
        section.remove();
        
        // Save the deletion to JSON
        if (sectionId) {
          this.deleteSectionFromJSON(sectionId);
        }
        
        // Recalculate all section indices after deletion
        this.recalculateSectionIndices();
        
        // Trigger persistent storage save
        this.triggerDataSave();
        
        this.showNotification(`ğŸ—‘ï¸ Section "${sectionName}" supprimÃ©e et mise Ã  jour JSON`);
      }
    },

    // ========================================
    // CONTENT MANIPULATION METHODS 
    // ========================================
    
    addContent(type, categoryName) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`âŒ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Create new item with default values
      const defaultItem = ContentFactory.createDefaultItem(type);
      
      // Special handling for objects and monsters (add to single array)
      if (type === 'objet') {
        if (!window.OBJETS.objets) {
          window.OBJETS.objets = [];
        }
        
        // Get next number
        const existingNumbers = window.OBJETS.objets.map(obj => obj.numero || 0);
        const nextNumber = existingNumbers.length > 0 ? Math.max(...existingNumbers) + 1 : 1;
        defaultItem.numero = nextNumber;
        
        window.OBJETS.objets.push(defaultItem);
        this.refreshObjectsPage();
      } else if (type === 'monster') {
        if (!window.MONSTRES) {
          window.MONSTRES = [];
        }
        
        window.MONSTRES.push(defaultItem);
        this.refreshMonstersPage();
      } else {
        // Standard category-based addition
        const success = ContentFactory.addItem(type, categoryName, defaultItem);
        if (success) {
          EventBus.emit(Events.CONTENT_ADD, {
            type: type,
            category: categoryName,
            item: defaultItem
          });
          
          EventBus.emit(Events.PAGE_RENDER, {
            type: 'category',
            categoryType: type,
            category: ContentFactory.getEntity(type).findCategory(categoryName)
          });
        }
      }
      
      EventBus.emit(Events.STORAGE_SAVE);
      this.showNotification(`${config.icons.add} Nouvel Ã©lÃ©ment ajoutÃ©`, 'success');
    },

    deleteContent(type, categoryName, itemName) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`âŒ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      if (!confirm(`Supprimer "${itemName}" ?`)) {
        return;
      }

      // Special handling for objects and monsters
      if (type === 'objet') {
        if (window.OBJETS?.objets) {
          const itemIndex = window.OBJETS.objets.findIndex(obj => obj.nom === itemName);
          if (itemIndex >= 0) {
            window.OBJETS.objets.splice(itemIndex, 1);
            this.refreshObjectsPage();
          }
        }
      } else if (type === 'monster') {
        if (window.MONSTRES) {
          const itemIndex = window.MONSTRES.findIndex(monster => monster.nom === itemName);
          if (itemIndex >= 0) {
            window.MONSTRES.splice(itemIndex, 1);
            this.refreshMonstersPage();
          }
        }
      } else {
        // Standard category-based deletion
        const success = ContentFactory.deleteItem(type, categoryName, itemName);
        if (success) {
          EventBus.emit(Events.CONTENT_DELETE, {
            type: type,
            category: categoryName,
            item: itemName
          });
          
          EventBus.emit(Events.PAGE_RENDER, {
            type: 'category',
            categoryType: type,
            category: ContentFactory.getEntity(type).findCategory(categoryName)
          });
        }
      }
      
      EventBus.emit(Events.STORAGE_SAVE);
      this.showNotification(`${config.icons.delete} "${itemName}" supprimÃ©`, 'success');
    },

    moveContent(type, categoryName, itemName, direction) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`âŒ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Special handling for objects
      if (type === 'objet') {
        if (window.OBJETS?.objets) {
          const itemIndex = window.OBJETS.objets.findIndex(obj => obj.nom === itemName);
          if (itemIndex >= 0) {
            const newIndex = itemIndex + direction;
            if (newIndex >= 0 && newIndex < window.OBJETS.objets.length) {
              const item = window.OBJETS.objets.splice(itemIndex, 1)[0];
              window.OBJETS.objets.splice(newIndex, 0, item);
              this.refreshObjectsPage();
            }
          }
        }
      } else {
        // Standard category-based movement
        const success = ContentFactory.moveItem(type, categoryName, itemName, direction);
        if (success) {
          EventBus.emit(Events.CONTENT_MOVE, {
            type: type,
            category: categoryName,
            itemName: itemName,
            direction: direction
          });
          
          EventBus.emit(Events.PAGE_RENDER, {
            type: 'category',
            categoryType: type,
            category: ContentFactory.getEntity(type).findCategory(categoryName)
          });
        }
      }
      
      EventBus.emit(Events.STORAGE_SAVE);
      const directionText = direction > 0 ? 'descendu' : 'montÃ©';
      this.showNotification(`ğŸ”„ "${itemName}" ${directionText}`, 'success');
    },

    handleContentAdd(type, category, item) {
      // Additional handling after content is added
      setTimeout(() => {
        if (JdrApp.modules.renderer?.autoLoadImages) {
          JdrApp.modules.renderer.autoLoadImages();
        }
      }, 100);
    },

    handleContentDelete(type, category, item) {
      // Cleanup after content deletion
    },

    handleContentMove(type, category, itemName, direction) {
      // Additional handling after content is moved
    },

    setupSearch() {
      const searchInput = JdrApp.utils.dom.$('#search');
      const clearButton = JdrApp.utils.dom.$('#clear');
      let searchTimeout;
      
      if (searchInput) {
        // Only search on Enter key press
        JdrApp.utils.events.register('keydown', '#search', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            const query = e.target.value.trim();
            if (query.length > 0) {
              this.performSearch(query);
            } else {
              this.clearMainSearchResults();
            }
          } else if (e.key === 'Escape') {
            this.clearMainSearchResults();
            e.target.value = '';
            e.target.blur();
          }
        });
      }
      
      if (clearButton) {
        JdrApp.utils.events.register('click', '#clear', () => {
          if (searchInput) {
            searchInput.value = '';
            this.clearMainSearchResults();
          }
        });
      }

      // Remove click outside handler since we're not using dropdown anymore
      // JdrApp.utils.events.register('click', 'body', (e) => {
      //   if (!e.target.closest('.searchbar') && !e.target.closest('#search-results')) {
      //     this.hideSearchResults();
      //   }
      // });

      // Remove EventBus listener that may cause issues
      // EventBus.on(Events.SEARCH_PERFORM, (payload) => {
      //   this.performSearch(payload.query);
      // });
    },

    performSearch(query) {
      const normalizedQuery = query.toLowerCase().trim();
      
      if (!normalizedQuery) {
        this.showAllContent();
        this.clearMainSearchResults();
        return;
      }

      // Search without minimum character limit since user has to press Enter
      const results = this.searchInData(normalizedQuery);
      this.displaySearchResultsInMain(results, normalizedQuery);
      
      // Keep existing TOC search for compatibility
      this.searchInTOC(normalizedQuery);
    },

    searchInData(query) {
      const results = [];
      
      // Search in SORTS
      if (window.SORTS) {
        window.SORTS.forEach(category => {
          if (category.sorts) {
            category.sorts.forEach(sort => {
              if (this.matchesSearch(sort, query)) {
                const url = `#/sorts-${JdrApp.utils.data.sanitizeId(category.nom)}`;
                
                results.push({
                  type: 'spell',
                  category: category.nom,
                  item: sort,
                  url: url,
                  summary: this.generateSpellSummary(sort)
                });
              }
            });
          }
        });
      }

      // Search in DONS
      if (window.DONS) {
        window.DONS.forEach(category => {
          if (category.dons) {
            category.dons.forEach(don => {
              if (this.matchesSearch(don, query)) {
                results.push({
                  type: 'don',
                  category: category.nom,
                  item: don,
                  url: `#/dons-${JdrApp.utils.data.sanitizeId(category.nom)}`,
                  summary: this.generateDonSummary(don)
                });
              }
            });
          }
        });
      }

      // Search in CLASSES
      if (window.CLASSES) {
        window.CLASSES.forEach(classe => {
          if (this.matchesSearch(classe, query)) {
            results.push({
              type: 'class',
              category: null,
              item: classe,
              url: `#/${JdrApp.utils.data.sanitizeId(classe.nom)}`,
              summary: this.generateClassSummary(classe)
            });
          }
          
          // Search in subclasses
          if (classe.sousClasses) {
            classe.sousClasses.forEach(sousClasse => {
              if (this.matchesSearch(sousClasse, query)) {
                results.push({
                  type: 'subclass',
                  category: classe.nom,
                  item: sousClasse,
                  url: `#/${JdrApp.utils.data.sanitizeId(classe.nom)}`,
                  summary: this.generateSubclassSummary(sousClasse, classe.nom)
                });
              }
            });
          }
        });
      }

      // Search in static pages
      this.searchInStaticPages(query, results);
      
      return results.slice(0, 10); // Limit to 10 results
    },

    searchInStaticPages(query, results) {
      // Search in static pages data
      if (window.STATIC_PAGES) {
        Object.keys(window.STATIC_PAGES).forEach(pageId => {
          const pageData = window.STATIC_PAGES[pageId];
          if (this.matchesStaticPage(pageData, query)) {
            results.push({
              type: 'staticPage',
              category: null,
              item: pageData,
              url: `#/${pageId}`,
              summary: this.generateStaticPageSummary(pageData)
            });
          }
        });
      }

      // Also search in static page config if available
      if (window.STATIC_PAGE_CONFIG?.pages) {
        window.STATIC_PAGE_CONFIG.pages.forEach(pageConfig => {
          if (pageConfig.active && this.matchesPageConfig(pageConfig, query)) {
            // Only add if we haven't already found this page
            const alreadyExists = results.some(r => 
              r.type === 'staticPage' && r.url === `#/${pageConfig.id}`
            );
            
            if (!alreadyExists) {
              results.push({
                type: 'staticPage',
                category: null,
                item: { 
                  title: pageConfig.title, 
                  page: pageConfig.id,
                  description: `Page sur ${pageConfig.title.toLowerCase()}`
                },
                url: `#/${pageConfig.id}`,
                summary: this.generatePageConfigSummary(pageConfig)
              });
            }
          }
        });
      }
    },

    matchesStaticPage(pageData, query) {
      const searchText = [
        pageData.title || '',
        pageData.page || '',
        this.extractStaticPageContent(pageData.sections || [])
      ].join(' ').toLowerCase();
      
      return searchText.includes(query);
    },

    matchesPageConfig(pageConfig, query) {
      const searchText = [
        pageConfig.title || '',
        pageConfig.id || ''
      ].join(' ').toLowerCase();
      
      return searchText.includes(query);
    },

    extractStaticPageContent(sections) {
      return sections.map(section => {
        let content = '';
        if (section.content) {
          if (typeof section.content === 'string') {
            content += section.content;
          } else if (section.content.content) {
            // New HTML format: extract text from HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = section.content.content;
            content += tempDiv.textContent || tempDiv.innerText || '';
          } else if (section.content.items && Array.isArray(section.content.items)) {
            // Legacy format
            content += section.content.items.join(' ');
          }
        }
        return content;
      }).join(' ');
    },

    matchesSearch(item, query) {
      // Fonction pour nettoyer le HTML et extraire le texte
      const stripHtml = (text) => {
        if (!text) return '';
        if (typeof text !== 'string') text = String(text);
        return text.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
      };

      // Fonction pour traiter les listes/arrays
      const processArray = (arr) => {
        if (!arr) return '';
        if (Array.isArray(arr)) {
          return arr.map(item => stripHtml(item)).join(' ');
        }
        return stripHtml(arr);
      };

      // Collecter TOUS les champs textuels possibles
      const searchFields = [
        // Champs communs
        item.nom,
        item.description,
        item.prerequis,
        item.resume,
        
        // Champs spÃ©cifiques aux sorts
        item.element,
        item.portee,
        item.tempsIncantation,
        item.coutMana,
        item.resistance,
        item.effetNormal,
        item.effetCritique,
        
        // Champs spÃ©cifiques aux dons
        item.cout,
        
        // Champs spÃ©cifiques aux classes/sous-classes
        item.progression,
        processArray(item.capacites),
        
        // Champs spÃ©cifiques aux objets
        item.effet,
        item.prix,
        item.poids,
        item.tags ? item.tags.join(' ') : '',
        
        // Champs de statistiques (si c'est un objet)
        item.base ? Object.entries(item.base || {}).map(([key, value]) => `${key} ${value}`).join(' ') : '',
        
        // Autres champs possibles
        item.title,
        item.content,
        item.type
      ];

      // Joindre tous les champs et nettoyer
      const searchText = searchFields
        .filter(field => field !== null && field !== undefined)
        .map(field => stripHtml(field))
        .join(' ')
        .toLowerCase();
      
      // Chercher chaque mot de la requÃªte
      const queryWords = query.toLowerCase().split(/\s+/).filter(word => word.length > 0);
      
      // Tous les mots doivent Ãªtre trouvÃ©s (recherche ET logique)
      return queryWords.every(word => searchText.includes(word));
    },

    generateSpellSummary(spell) {
      // Strip HTML tags from fields to avoid breaking template
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `ğŸ”® ${stripHtml(spell.nom)} - ${stripHtml(spell.prerequis || 'Aucun prÃ©requis')} | ${stripHtml(spell.coutMana || 'CoÃ»t inconnu')}`;
    },

    generateDonSummary(don) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `ğŸ† ${stripHtml(don.nom)} - ${stripHtml(don.prerequis || 'Aucun prÃ©requis')} | ${stripHtml(don.cout || 'CoÃ»t inconnu')}`;
    },

    generateClassSummary(classe) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `âš”ï¸ ${stripHtml(classe.nom)} - ${stripHtml(classe.resume || 'Classe de combat')}`;
    },

    generateSubclassSummary(sousClasse, parentClass) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `âš¡ ${stripHtml(sousClasse.nom)} (${stripHtml(parentClass)}) - Sous-classe spÃ©cialisÃ©e`;
    },

    generateStaticPageSummary(pageData) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `ğŸ“„ ${stripHtml(pageData.title)} - ${stripHtml(pageData.description || 'Page d\'information du jeu')}`;
    },

    generatePageConfigSummary(pageConfig) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `ğŸ“„ ${stripHtml(pageConfig.title)} - Guide et informations sur ${stripHtml(pageConfig.title.toLowerCase())}`;
    },

    slugify(text) {
      return text.toLowerCase()
        .replace(/[Ã Ã¡Ã¢Ã£Ã¤Ã¥]/g, 'a')
        .replace(/[Ã¨Ã©ÃªÃ«]/g, 'e')
        .replace(/[Ã¬Ã­Ã®Ã¯]/g, 'i')
        .replace(/[Ã²Ã³Ã´ÃµÃ¶]/g, 'o')
        .replace(/[Ã¹ÃºÃ»Ã¼]/g, 'u')
        .replace(/[Ã§]/g, 'c')
        .replace(/[^a-z0-9]/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '');
    },

    showAllContent() {
      JdrApp.utils.dom.$('article, .toc a').forEach(el => {
        el.style.display = '';
      });
    },

    displaySearchResultsInMain(results, query) {
      const main = document.querySelector('main');
      if (!main) return;

      // Create search results page content
      const searchPageHTML = this.generateSearchResultsPage(results, query);
      
      // Replace main content with search results
      main.innerHTML = searchPageHTML;
      
      // Quick debug to see card dimensions
      setTimeout(() => {
        const cards = main.querySelectorAll('.search-result-card');
        console.log('Cards found:', cards.length);
        cards.forEach((card, i) => {
          console.log(`Card ${i+1} dimensions:`, {
            height: card.offsetHeight,
            width: card.offsetWidth,
            display: getComputedStyle(card).display,
            visibility: getComputedStyle(card).visibility
          });
        });
      }, 100);
      
      // Setup click handlers for results
      this.setupMainSearchHandlers();
      
      // Also setup direct handlers as fallback
      this.setupDirectHandlers();
    },

    generateSearchResultsPage(results, query) {
      if (results.length === 0) {
        return `
          <div class="search-page">
            <div class="search-page-header">
              <h1>ğŸ” Recherche: "${query}"</h1>
              <p class="search-no-results">Aucun rÃ©sultat trouvÃ©</p>
              <button class="btn small" onclick="JdrApp.modules.ui.clearMainSearchResults()">
                â† Retour au sommaire
              </button>
            </div>
          </div>
        `;
      }
      
      let resultsHTML = '';
      
      try {
        resultsHTML = results.map((result, index) => {
          const itemName = result.item.nom || result.item.title || 'Sans nom';
          
          
          // Generate preview safely
          let preview;
          try {
            preview = this.generatePreview(result.item, result.type);
          } catch (previewError) {
            console.error('Preview error:', previewError);
            preview = '<div class="preview-field">Erreur dans l\'aperÃ§u</div>';
          }
          
          // Escape potentially problematic text
          const escapeAttr = (text) => {
            if (!text) return '';
            return String(text).replace(/"/g, '&quot;');
          };
          
          const escapeText = (text) => {
            if (!text) return '';
            return String(text)
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;');
          };

          const cardHTML = `
            <article class="search-result-card" data-url="${result.url}">
              <div class="search-result-header">
                <h3>${this.getTypeIcon(result.type)} ${itemName}</h3>
                <div class="search-result-type">${this.getTypeName(result.type)}</div>
              </div>
              <div class="search-result-content">
                <div class="search-result-summary">${escapeText(result.summary || 'Pas de rÃ©sumÃ©')}</div>
                ${result.category ? `<div class="search-result-category">ğŸ“‚ CatÃ©gorie: ${escapeText(result.category)}</div>` : ''}
                <div class="search-result-preview">
                  ${preview}
                </div>
              </div>
              <div class="search-result-footer">
                <button class="btn small search-result-btn" data-url="${result.url}">
                  Voir la page â†’
                </button>
              </div>
            </article>
          `;
          
          return cardHTML;
        }).join('');
      } catch (error) {
        console.error('Error generating results HTML:', error);
        resultsHTML = '<div class="error">Erreur lors de la gÃ©nÃ©ration des rÃ©sultats</div>';
      }

      const finalHTML = `
        <div class="search-page">
          <div class="search-page-header">
            <h1>ğŸ” Recherche: "${query}"</h1>
            <p class="search-results-count">${results.length} rÃ©sultat${results.length > 1 ? 's' : ''} trouvÃ©${results.length > 1 ? 's' : ''}</p>
            <button class="btn small" onclick="JdrApp.modules.ui.clearMainSearchResults()">
              â† Retour au sommaire
            </button>
          </div>
          <div class="search-results-grid">
            ${resultsHTML}
          </div>
        </div>
      `;
      
      return finalHTML;
    },

    getTypeIcon(type) {
      const icons = {
        'spell': 'ğŸ”®',
        'don': 'ğŸ†', 
        'class': 'âš”ï¸',
        'subclass': 'âš¡',
        'staticPage': 'ğŸ“„'
      };
      return icons[type] || 'ğŸ“„';
    },

    getTypeName(type) {
      const names = {
        'spell': 'Sort',
        'don': 'Don',
        'class': 'Classe',
        'subclass': 'Sous-classe',
        'staticPage': 'Page'
      };
      return names[type] || 'Contenu';
    },

    generatePreview(item, type) {
      // Strip all HTML and clean text completely
      const cleanText = (text) => {
        if (!text) return '';
        return String(text)
          .replace(/<[^>]*>/g, '') // Remove HTML tags
          .replace(/&[^;]+;/g, ' ') // Remove HTML entities
          .replace(/\s+/g, ' ') // Normalize whitespace
          .trim()
          .substring(0, 100); // Limit length
      };

      switch (type) {
        case 'spell':
          const desc = cleanText(item.description || 'Non spÃ©cifiÃ©e');
          const portee = cleanText(item.portee || 'Non spÃ©cifiÃ©e');
          return `<div class="preview-field">Description: ${desc}</div><div class="preview-field">PortÃ©e: ${portee}</div>`;
          
        case 'don':
          const donDesc = cleanText(item.description || 'Non spÃ©cifiÃ©e');
          return `<div class="preview-field">Description: ${donDesc}</div>`;
          
        case 'class':
          const resume = cleanText(item.resume || 'Non spÃ©cifiÃ©');
          return `<div class="preview-field">RÃ©sumÃ©: ${resume}</div>`;
          
        case 'subclass':
          const progression = cleanText(item.progression || 'Non spÃ©cifiÃ©e');
          return `<div class="preview-field">Progression: ${progression}</div>`;
          
        case 'staticPage':
          const content = this.extractStaticPageContent(item.sections || []);
          const preview = cleanText(content || 'Page d\'information');
          return `<div class="preview-field">Contenu: ${preview}</div>`;
          
        default:
          return '<div class="preview-field">AperÃ§u non disponible</div>';
      }
    },

    setupMainSearchHandlers() {
      // Handle click on entire card
      JdrApp.utils.events.register('click', '.search-result-card', (e) => {
        console.log('Card clicked, currentTarget:', e.currentTarget);
        if (e.target.closest('.search-result-btn')) return; // Let button handle it
        
        const url = e.currentTarget ? e.currentTarget.dataset.url : null;
        console.log('Card URL:', url);
        
        if (url && url !== '#test') {
          console.log('Navigating to:', url);
          window.location.hash = url;
          // Force page reload to trigger router
          window.location.reload();
        } else {
          console.warn('No valid URL found on card');
        }
      });

      // Handle button clicks
      JdrApp.utils.events.register('click', '.search-result-btn', (e) => {
        console.log('Button clicked, target:', e.target);
        e.stopPropagation();
        
        const url = e.target ? e.target.dataset.url : null;
        console.log('Button URL:', url);
        
        if (url && url !== '#test') {
          console.log('Navigating to:', url);
          window.location.hash = url;
          // Force page reload to trigger router
          window.location.reload();
        } else {
          console.warn('No valid URL found on button');
        }
      });
    },

    setupDirectHandlers() {
      // Direct event listeners on the elements themselves
      setTimeout(() => {
        const cards = document.querySelectorAll('.search-result-card');
        const buttons = document.querySelectorAll('.search-result-btn');
        
        console.log('Setting up direct handlers for', cards.length, 'cards and', buttons.length, 'buttons');
        
        cards.forEach((card, index) => {
          const url = card.dataset.url;
          console.log(`Card ${index + 1} URL:`, url);
          
          card.addEventListener('click', (e) => {
            if (e.target.closest('.search-result-btn')) return;
            console.log('Direct card click, URL:', url);
            if (url && url !== '#test') {
              window.location.hash = url;
              window.location.reload();
            }
          });
        });
        
        buttons.forEach((button, index) => {
          const url = button.dataset.url;
          console.log(`Button ${index + 1} URL:`, url);
          
          button.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log('Direct button click, URL:', url);
            if (url && url !== '#test') {
              window.location.hash = url;
              window.location.reload();
            }
          });
        });
      }, 200);
    },

    clearMainSearchResults() {
      // Reload the current page or go back to homepage
      if (window.location.hash && window.location.hash !== '#/') {
        window.location.reload();
      } else {
        window.location.hash = '#/creation';
      }
    },

    searchInTOC(query) {
      JdrApp.utils.dom.$('.toc a').forEach(link => {
        const text = link.textContent.toLowerCase();
        const isMatch = text.includes(query);
        link.style.display = isMatch ? '' : 'none';
        
        if (isMatch) {
          const category = link.closest('.toc-category');
          if (category) {
            category.classList.remove('collapsed');
          }
        }
      });
    },

    searchInContent(query) {
      JdrApp.utils.dom.$('article').forEach(article => {
        const text = article.textContent.toLowerCase();
        const isMatch = text.includes(query);
        
        if (isMatch) {
          this.highlightSearchTerms(article, query);
        }
      });
    },

    highlightSearchTerms(container, query) {
      const walker = document.createTreeWalker(
        container,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );

      const textNodes = [];
      let node;
      while (node = walker.nextNode()) {
        if (node.textContent.toLowerCase().includes(query)) {
          textNodes.push(node);
        }
      }

      textNodes.forEach(textNode => {
        const regex = new RegExp(`(${query})`, 'gi');
        const content = textNode.textContent;
        
        if (regex.test(content)) {
          const highlightedContent = content.replace(regex, '<mark>$1</mark>');
          const wrapper = document.createElement('span');
          wrapper.innerHTML = highlightedContent;
          textNode.parentNode.replaceChild(wrapper, textNode);
        }
      });
    },

    setupModals() {
      JdrApp.utils.events.register('click', '.modal-overlay, .modal-close', (e) => {
        const modal = e.target.closest('.modal') || document.querySelector('.modal.visible');
        if (modal) {
          this.closeModal(modal);
        }
      });

      JdrApp.utils.events.register('click', '.modal-content', (e) => {
        e.stopPropagation();
      });

      JdrApp.utils.events.register('keydown', 'body', (e) => {
        if (e.key === 'Escape') {
          const openModal = document.querySelector('.modal.visible');
          if (openModal) {
            this.closeModal(openModal);
          }
        }
      });

      // Resource tools
      JdrApp.utils.events.register('click', '#elementsBtn', () => {
        this.showElementsModal();
      });

      JdrApp.utils.events.register('click', '#etatsBtn', () => {
        this.showEtatsModal();
      });

      JdrApp.utils.events.register('click', '#spellLinksBtn', () => {
        this.showSpellLinksModal();
      });

      JdrApp.utils.events.register('click', '#pageLinksBtn', () => {
        this.showPageLinksModal();
      });

      // Gestionnaire pour les liens de sorts dans le contenu
      JdrApp.utils.events.register('click', '.spell-link', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const spellName = e.target.dataset.spell;
        const categoryName = e.target.dataset.category;
        this.showSpellPreview(spellName, categoryName, e.target);
      });

      // Gestionnaire pour les liens d'Ã©tats dans le contenu
      JdrApp.utils.events.register('click', '.etat-link', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const etatName = e.target.dataset.etat;
        
        // RÃ©cupÃ©rer dynamiquement la description depuis les donnÃ©es statiques
        let etatDescription = '';
        if (window.STATIC_PAGES?.etats?.sections) {
          const etatSection = window.STATIC_PAGES.etats.sections.find(section => 
            section.type === 'card' && section.title === etatName
          );
          if (etatSection) {
            // Convertir le HTML en texte propre
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = etatSection.content;
            tempDiv.innerHTML = tempDiv.innerHTML
              .replace(/<\/p>/gi, '\n')
              .replace(/<br\s*\/?>/gi, '\n')
              .replace(/<\/li>/gi, '\n')
              .replace(/<\/div>/gi, '\n');
            etatDescription = (tempDiv.textContent || tempDiv.innerText || etatSection.content)
              .replace(/\n\s*\n/g, '\n')
              .trim();
          }
        }
        
        this.showEtatPreview(etatName, etatDescription, e.target);
      });

      EventBus.on(Events.MODAL_OPEN, (payload) => {
        this.openModal(payload.modalId);
      });

      EventBus.on(Events.MODAL_CLOSE, (payload) => {
        const modal = payload.modal || document.querySelector('.modal.visible');
        if (modal) {
          this.closeModal(modal);
        }
      });
    },

    openModal(modalId) {
      const modal = JdrApp.utils.dom.$(`#${modalId}`);
      if (modal) {
        if (modal.tagName === 'DIALOG') {
          modal.showModal();
        } else {
          modal.classList.add('visible');
          modal.style.display = 'flex';
        }
        
        const firstInput = modal.querySelector('input, textarea, select');
        if (firstInput) {
          firstInput.focus();
        }
      }
    },

    closeModal(modal) {
      if (modal) {
        modal.classList.remove('visible');
        modal.style.display = 'none';
        
        const form = modal.querySelector('form');
        if (form) {
          form.reset();
        }
      }
    },

    showElementsModal() {
      let modal = JdrApp.utils.dom.$('#elementsModal');
      if (!modal) {
        modal = this.createElementsModal();
        document.body.appendChild(modal);
      }
      
      this.openModal('elementsModal');
    },

    createElementsModal() {
      const elements = Object.entries(window.ElementColors).map(([name, config]) => ({
        name,
        color: config.color,
        icon: this.getElementIcon(name)
      }));

      const elementsHTML = elements.map(element => `
        <div class="element-item" data-element="${element.name}" data-color="${element.color}">
          <div class="element-icon" style="background: ${element.color};">${element.icon}</div>
          <div class="element-name">${element.name}</div>
          <div class="copy-indicator">CopiÃ©!</div>
        </div>
      `).join('');

      const modal = JdrApp.utils.dom.create('div', 'modal elements-modal', `
        <div class="modal-content elements-modal-content">
          <div style="position: relative;">
            <button class="modal-close-x" style="position: absolute; top: 0; right: 0; background: none; border: none; font-size: 20px; cursor: pointer; color: var(--paper-muted); padding: 4px 8px; border-radius: 4px; transition: all 0.2s ease;" onmouseover="this.style.background='var(--rule)'; this.style.color='var(--accent-ink)';" onmouseout="this.style.background='none'; this.style.color='var(--paper-muted)';">Ã—</button>
            <h3>ğŸ¨ Ã‰lÃ©ments</h3>
          </div>
          <p>Cliquez sur un Ã©lÃ©ment pour copier sa balise HTML colorÃ©e.</p>
          <div class="elements-list">
            ${elementsHTML}
          </div>
          <button class="modal-close btn">Fermer</button>
        </div>
      `, { id: 'elementsModal' });

      modal.addEventListener('click', (e) => {
        const elementItem = e.target.closest('.element-item');
        if (elementItem) {
          const elementName = elementItem.dataset.element;
          
          // Get the full style configuration from ElementColors
          const style = window.ElementColors[elementName];
          if (style) {
            // Build the complete style string
            let styleString = `color: ${style.color}; font-weight: ${style.weight || 'bold'};`;
            if (style.background) styleString += ` background: ${style.background};`;
            if (style.padding) styleString += ` padding: ${style.padding};`;
            if (style.borderRadius) styleString += ` border-radius: ${style.borderRadius};`;
            
            const html = `<span style="${styleString}">${elementName}</span>`;
            this.copyToClipboard(html);
          } else {
            // Fallback for elements not found
            const html = `<span style="color: ${elementItem.dataset.color}; font-weight: bold;">${elementName}</span>`;
            this.copyToClipboard(html);
          }
          
          elementItem.classList.add('copied');
          
          // Fermer la modale aprÃ¨s un court dÃ©lai pour voir l'effet "CopiÃ©!"
          setTimeout(() => {
            this.closeModal(modal);
          }, 500);
        }
      });

      // Gestionnaire pour le bouton X de fermeture
      const closeBtn = modal.querySelector('.modal-close-x');
      if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.closeModal(modal);
        });
      }

      return modal;
    },

    getElementIcon(elementName) {
      const icons = {
        'Feu': 'ğŸ”¥',
        'Air': 'ğŸ’¨',
        'Eau': 'ğŸ’§',
        'Terre': 'ğŸŒ',
        'Divin': 'âœ¨',
        'LumiÃ¨re': 'â˜€ï¸',
        'MalÃ©fique': 'ğŸ’€'
      };
      return icons[elementName] || 'âš¡';
    },

    showEtatsModal() {
      // TOUJOURS recrÃ©er la modal pour avoir les donnÃ©es Ã  jour
      let modal = JdrApp.utils.dom.$('#etatsModal');
      if (modal) {
        document.body.removeChild(modal);
      }
      
      modal = this.createEtatsModal();
      document.body.appendChild(modal);
      
      this.openModal('etatsModal');
    },

    createEtatsModal() {
      // RÃ©cupÃ©rer les donnÃ©es d'Ã©tats depuis window.STATIC_PAGES.etats
      const etatsData = window.STATIC_PAGES?.etats;
      const etats = [];
      
      if (etatsData?.sections) {
        etatsData.sections.forEach(section => {
          if (section.type === 'card' && section.title && section.content) {
            // Convertir le HTML en texte en prÃ©servant les sauts de ligne
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = section.content;
            
            // Remplacer les balises de saut de ligne par des \n avant d'extraire le texte
            tempDiv.innerHTML = tempDiv.innerHTML
              .replace(/<\/p>/gi, '\n')
              .replace(/<br\s*\/?>/gi, '\n')
              .replace(/<\/li>/gi, '\n')
              .replace(/<\/div>/gi, '\n');
            
            const description = (tempDiv.textContent || tempDiv.innerText || section.content)
              .replace(/\n\s*\n/g, '\n') // Supprimer les doubles sauts de ligne
              .trim();
            
            etats.push({
              name: section.title,
              description: description
            });
          }
        });
      }

      const etatsHTML = etats.map(etat => `
        <div class="etat-item" data-etat-name="${etat.name}" data-etat-description="${etat.description}">
          <div class="etat-icon">âš¡</div>
          <div class="etat-content">
            <div class="etat-name">${etat.name}</div>
            <div class="etat-description">${etat.description.length > 60 ? etat.description.substring(0, 60) + '...' : etat.description}</div>
          </div>
          <div class="copy-indicator">CopiÃ©!</div>
        </div>
      `).join('');

      const modal = JdrApp.utils.dom.create('div', 'modal etats-modal', `
        <div class="modal-content etats-modal-content">
          <div style="position: relative;">
            <button class="modal-close-x" style="position: absolute; top: 0; right: 0; background: none; border: none; font-size: 20px; cursor: pointer; color: var(--paper-muted); padding: 4px 8px; border-radius: 4px; transition: all 0.2s ease;" onmouseover="this.style.background='var(--rule)'; this.style.color='var(--accent-ink)';" onmouseout="this.style.background='none'; this.style.color='var(--paper-muted)';">Ã—</button>
            <h3>âš¡ Ã‰tats</h3>
          </div>
          <p>Cliquez sur un Ã©tat pour copier un lien avec prÃ©visualisation dans le presse-papiers.</p>
          <div class="etats-list">
            ${etatsHTML || '<div style="text-align: center; color: #666; padding: 2rem;">Aucun Ã©tat trouvÃ©</div>'}
          </div>
          <button class="modal-close btn">Fermer</button>
        </div>
      `, { id: 'etatsModal' });

      modal.addEventListener('click', (e) => {
        const etatItem = e.target.closest('.etat-item');
        if (etatItem) {
          const etatName = etatItem.dataset.etatName;
          const etatDescription = etatItem.dataset.etatDescription;
          
          // CrÃ©er un lien cliquable simple avec prÃ©visualisation (description rÃ©cupÃ©rÃ©e dynamiquement)
          const etatLink = `<span class="etat-link" data-etat="${etatName}" style="color: #ea7332; cursor: pointer; text-decoration: underline;">${etatName}</span>`;
          
          // Toujours copier dans le presse-papiers
          this.copyToClipboard(etatLink);
          
          etatItem.classList.add('copied');
          
          // Fermer la modale aprÃ¨s un court dÃ©lai pour voir l'effet "CopiÃ©!"
          setTimeout(() => {
            this.closeModal(modal);
          }, 500);
        }
      });

      // Gestionnaire pour le bouton X de fermeture
      const closeBtn = modal.querySelector('.modal-close-x');
      if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.closeModal(modal);
        });
      }

      return modal;
    },

    showSpellLinksModal() {
      let modal = JdrApp.utils.dom.$('#spellLinksModal');
      if (modal) {
        document.body.removeChild(modal);
      }
      
      modal = this.createSpellLinksModal();
      document.body.appendChild(modal);

      
      this.openModal('spellLinksModal');
    },

    createSpellLinksModal() {
      // RÃ©cupÃ©rer tous les sorts depuis window.SORTS
      const spells = [];
      
      if (window.SORTS && Array.isArray(window.SORTS)) {
        window.SORTS.forEach(category => {
          if (category.sorts && Array.isArray(category.sorts)) {
            category.sorts.forEach(spell => {
              spells.push({
                name: spell.nom,
                category: category.nom,
                element: spell.element,
                description: spell.description || ''
              });
            });
          }
        });
      }

      const spellsHTML = spells.map(spell => `
        <div class="spell-item" data-spell-name="${spell.name}" data-spell-category="${spell.category}">
          <div class="spell-info">
            <div class="spell-name" style="color: ${this.getElementColor(spell.element)}; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">${spell.name}</div>
            <span data-spell-meta style="color: ${this.getElementColor(spell.element)} !important; font-size: 12px; margin-bottom: 6px; display: block;">${this.getElementIcon(spell.element)} ${spell.element} â€¢ ${spell.category}</span>
            <div class="spell-description">${spell.description.length > 80 ? spell.description.substring(0, 80) + '...' : spell.description}</div>
          </div>
          <div class="copy-indicator">CopiÃ©!</div>
        </div>
      `).join('');

      const modal = JdrApp.utils.dom.create('div', 'modal spell-links-modal', `
        <div class="modal-content spell-links-modal-content">
          <div style="position: relative;">
            <button class="modal-close-x" style="position: absolute; top: 0; right: 0; background: none; border: none; font-size: 20px; cursor: pointer; color: var(--paper-muted); padding: 4px 8px; border-radius: 4px; transition: all 0.2s ease;" onmouseover="this.style.background='var(--rule)'; this.style.color='var(--accent-ink)';" onmouseout="this.style.background='none'; this.style.color='var(--paper-muted)';">Ã—</button>
            <h3>ğŸ”® Liens vers les sorts</h3>
          </div>
          <p>Cliquez sur un sort pour copier un lien avec aperÃ§u interactif.</p>
          <div class="spells-search">
            <input type="text" id="spellSearchInput" placeholder="Rechercher un sort..." style="width: 100%; padding: 8px; margin-bottom: 12px; border: 1px solid var(--rule); border-radius: 4px;">
          </div>
          <div class="spells-list" style="max-height: 400px; overflow-y: auto;">
            ${spellsHTML || '<div style="text-align: center; color: #666; padding: 2rem;">Aucun sort trouvÃ©</div>'}
          </div>
          <button class="modal-close btn">Fermer</button>
        </div>
      `, { id: 'spellLinksModal' });

      // Recherche dans la modal
      const searchInput = modal.querySelector('#spellSearchInput');
      if (searchInput) {
        searchInput.addEventListener('input', (e) => {
          const searchTerm = e.target.value.toLowerCase();
          const spellItems = modal.querySelectorAll('.spell-item');
          
          spellItems.forEach(item => {
            const spellName = item.querySelector('.spell-name').textContent.toLowerCase();
            const spellCategory = item.querySelector('.spell-meta').textContent.toLowerCase();
            
            if (spellName.includes(searchTerm) || spellCategory.includes(searchTerm)) {
              item.style.display = '';
            } else {
              item.style.display = 'none';
            }
          });
        });
      }

      // Clic sur un sort
      modal.addEventListener('click', (e) => {
        const spellItem = e.target.closest('.spell-item');
        if (spellItem) {
          const spellName = spellItem.dataset.spellName;
          const spellCategory = spellItem.dataset.spellCategory;
          
          // CrÃ©er le lien HTML avec les attributs nÃ©cessaires
          const spellLink = `<span class="spell-link" data-spell="${spellName}" data-category="${spellCategory}" style="color: var(--accent); cursor: pointer; text-decoration: underline;">${spellName}</span>`;
          
          this.copyToClipboard(spellLink);
          
          spellItem.classList.add('copied');
          
          // Fermer la modale aprÃ¨s un court dÃ©lai pour voir l'effet "CopiÃ©!"
          setTimeout(() => {
            this.closeModal(modal);
          }, 500);
        }
      });

      // Gestionnaire pour le bouton X de fermeture
      const closeBtn = modal.querySelector('.modal-close-x');
      if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.closeModal(modal);
        });
      }

      return modal;
    },

    getElementColor(element) {
      // Couleurs optimisÃ©es pour la lisibilitÃ© sur fond clair et foncÃ©
      const colorMap = {
        'Feu': '#e25822',        // Rouge-orange vif
        'Eau': '#2563eb',        // Bleu vif
        'Terre': '#92400e',      // Marron foncÃ©
        'Air': '#059669',        // Vert Ã©meraude
        'LumiÃ¨re': '#d97706',    // Orange dorÃ© (au lieu du jaune pÃ¢le)
        'Nuit': '#6b21a8',       // Violet foncÃ© (au lieu du noir)
        'Divin': '#7c2d12',      // Marron dorÃ© (au lieu du blanc)
        'MalÃ©fique': '#7c3aed'   // Violet intense
      };
      
      return colorMap[element] || '#666666';
    },

    getElementIcon(element) {
      const icons = window.ElementIcons || {};
      return icons[element] || 'âš¡';
    },

    showSpellPreview(spellName, categoryName, triggerElement) {
      // Trouver le sort dans les donnÃ©es
      let spellData = null;
      
      if (window.SORTS && Array.isArray(window.SORTS)) {
        for (const category of window.SORTS) {
          if (category.nom === categoryName && category.sorts) {
            spellData = category.sorts.find(spell => spell.nom === spellName);
            if (spellData) break;
          }
        }
      }

      if (!spellData) {
        this.showNotification(`âŒ Sort "${spellName}" non trouvÃ©`, 'error');
        return;
      }

      // Fermer toute preview existante
      const existingPreview = document.querySelector('.spell-preview-popup');
      if (existingPreview) {
        existingPreview.remove();
      }

      // Calculer la position de la popup
      const rect = triggerElement.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      
      // CrÃ©er la popup de preview
      const popup = document.createElement('div');
      popup.className = 'spell-preview-popup';
      
      const elementColor = this.getElementColor(spellData.element);
      
      popup.innerHTML = `
        <div class="spell-preview-content">
          <div class="spell-preview-header" style="border-left: 4px solid ${elementColor};">
            <div class="spell-title" style="color: ${elementColor}; text-shadow: 0 1px 2px rgba(0,0,0,0.3);">${spellData.nom}</div>
            <span data-element-display style="color: ${elementColor} !important; font-size: 12px; text-transform: uppercase; letter-spacing: 0.5px;">${this.getElementIcon(spellData.element)} ${spellData.element} â€¢ ${categoryName}</span>
            <button class="spell-preview-close">âœ•</button>
          </div>
          <div class="spell-preview-body">
            ${spellData.description ? `<div class="spell-description">${spellData.description}</div>` : ''}
            ${spellData.prerequis ? `<div class="spell-field">${spellData.prerequis}</div>` : ''}
            ${spellData.portee ? `<div class="spell-field">${spellData.portee}</div>` : ''}
            ${spellData.tempsIncantation ? `<div class="spell-field">${spellData.tempsIncantation}</div>` : ''}
            ${spellData.coutMana ? `<div class="spell-field">${spellData.coutMana}</div>` : ''}
            ${spellData.resistance ? `<div class="spell-field">${spellData.resistance}</div>` : ''}
            ${spellData.effetNormal ? `<div class="spell-field">${spellData.effetNormal}</div>` : ''}
            ${spellData.effetCritique ? `<div class="spell-field">${spellData.effetCritique}</div>` : ''}
          </div>
        </div>
      `;

      // Styles de la popup
      popup.style.cssText = `
        position: fixed;
        z-index: 10000;
        background: var(--card);
        border: 2px solid ${elementColor};
        border-radius: 8px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        max-width: 400px;
        max-height: 500px;
        overflow-y: auto;
        font-family: 'Roboto', sans-serif;
        line-height: 1.4;
      `;

      document.body.appendChild(popup);

      // FORCE les couleurs avec JavaScript aprÃ¨s ajout au DOM
      setTimeout(() => {
        const elementDisplay = popup.querySelector('[data-element-display]');
        if (elementDisplay) {
          elementDisplay.style.setProperty('color', elementColor, 'important');
        }
      }, 10);

      // Positionner la popup
      const popupRect = popup.getBoundingClientRect();
      let left = rect.left + rect.width / 2 - popupRect.width / 2;
      let top = rect.bottom + 8;

      // Ajustements si la popup sort de l'Ã©cran
      if (left < 8) left = 8;
      if (left + popupRect.width > viewportWidth - 8) left = viewportWidth - popupRect.width - 8;
      if (top + popupRect.height > viewportHeight - 8) top = rect.top - popupRect.height - 8;
      if (top < 8) top = 8;

      popup.style.left = `${left}px`;
      popup.style.top = `${top}px`;

      // Gestionnaires d'Ã©vÃ©nements
      popup.querySelector('.spell-preview-close').addEventListener('click', () => {
        popup.remove();
      });

      // Fermer en cliquant Ã  l'extÃ©rieur
      const handleOutsideClick = (e) => {
        if (!popup.contains(e.target) && e.target !== triggerElement) {
          popup.remove();
          document.removeEventListener('click', handleOutsideClick);
        }
      };
      
      setTimeout(() => {
        document.addEventListener('click', handleOutsideClick);
      }, 100);

      // Fermer avec Escape
      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          popup.remove();
          document.removeEventListener('keydown', handleEscape);
        }
      };
      document.addEventListener('keydown', handleEscape);
    },

    showEtatPreview(etatName, etatDescription, triggerElement) {
      // Fermer toute preview existante
      const existingPreview = document.querySelector('.etat-preview-popup');
      if (existingPreview) {
        existingPreview.remove();
      }

      // Calculer la position de la popup
      const rect = triggerElement.getBoundingClientRect();
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      
      // CrÃ©er la popup de preview
      const popup = document.createElement('div');
      popup.className = 'etat-preview-popup';
      
      popup.innerHTML = `
        <div class="etat-preview-content">
          <div class="etat-preview-header">
            <div class="etat-title">âš¡ ${etatName}</div>
            <button class="etat-preview-close">âœ•</button>
          </div>
          <div class="etat-preview-body">
            <div class="etat-description">${etatDescription}</div>
          </div>
        </div>
      `;

      // Styles de la popup
      popup.style.cssText = `
        position: fixed;
        z-index: 10000;
        background: var(--card);
        border: 2px solid #7c2d12;
        border-radius: 12px;
        box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        max-width: 300px;
        padding: 1rem;
        font-size: 14px;
        line-height: 1.4;
        color: var(--paper-ink);
        pointer-events: auto;
      `;

      document.body.appendChild(popup);

      // Positionner la popup
      setTimeout(() => {
        const popupRect = popup.getBoundingClientRect();
        let left = rect.left + rect.width / 2 - popupRect.width / 2;
        let top = rect.bottom + 8;

        // Ajustements si la popup sort de l'Ã©cran
        if (left < 8) left = 8;
        if (left + popupRect.width > viewportWidth - 8) left = viewportWidth - popupRect.width - 8;
        if (top + popupRect.height > viewportHeight - 8) top = rect.top - popupRect.height - 8;
        if (top < 8) top = 8;

        popup.style.left = `${left}px`;
        popup.style.top = `${top}px`;
      }, 10);

      // Gestionnaires d'Ã©vÃ©nements
      popup.querySelector('.etat-preview-close').addEventListener('click', () => {
        popup.remove();
      });

      // Fermer en cliquant Ã  l'extÃ©rieur
      const handleOutsideClick = (e) => {
        if (!popup.contains(e.target) && e.target !== triggerElement) {
          popup.remove();
          document.removeEventListener('click', handleOutsideClick);
        }
      };
      
      setTimeout(() => {
        document.addEventListener('click', handleOutsideClick);
      }, 100);

      // Fermer avec Escape
      const handleEscape = (e) => {
        if (e.key === 'Escape') {
          popup.remove();
          document.removeEventListener('keydown', handleEscape);
        }
      };
      document.addEventListener('keydown', handleEscape);
    },

    copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        this.showNotification('ğŸ“‹ CopiÃ© dans le presse-papiers', 'success');
      }).catch(() => {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        this.showNotification('ğŸ“‹ CopiÃ© dans le presse-papiers', 'success');
      });
    },

    setupResponsive() {
      this.setupMobileNavigation();
      this.setupLegacyResponsive();
    },

    setupMobileNavigation() {
      // Create mobile navigation toggle button immediately and on resize
      this.createMobileNavToggle();
      
      // Handle mobile nav toggle with delegation
      document.addEventListener('click', (e) => {
        if (e.target.closest('.mobile-nav-toggle')) {
          e.preventDefault();
          this.toggleMobileNav();
        }
      });

      // Auto-close navigation when selecting a page
      document.addEventListener('click', (e) => {
        if (e.target.closest('.toc a') && window.innerWidth <= 980) {
          this.closeMobileNav();
        }
      });

      // Handle window resize
      window.addEventListener('resize', () => {
        if (window.innerWidth <= 980) {
          this.createMobileNavToggle();
        } else {
          this.closeMobileNav();
          const existingButton = document.querySelector('.mobile-nav-toggle');
          if (existingButton) {
            existingButton.remove();
          }
        }
      });
      
      // Also create on DOM content loaded
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          this.createMobileNavToggle();
        });
      }
    },

    createMobileNavToggle() {
      // Only create if it doesn't exist and we're on mobile
      if (window.innerWidth <= 980 && !document.querySelector('.mobile-nav-toggle')) {
        const toggleButton = document.createElement('button');
        toggleButton.className = 'mobile-nav-toggle';
        toggleButton.innerHTML = `
          <span class="icon">ğŸ“œ</span>
          <span class="text">Menu</span>
        `;
        toggleButton.setAttribute('aria-label', 'Ouvrir/fermer le menu de navigation');
        toggleButton.setAttribute('title', 'Navigation');
        toggleButton.type = 'button';
        
        // Insert at the beginning of body
        if (document.body) {
          document.body.insertBefore(toggleButton, document.body.firstChild);
        }
      }
    },

    toggleMobileNav() {
      const sidebar = document.querySelector('.sidebar');
      const toggleButton = document.querySelector('.mobile-nav-toggle');
      
      if (sidebar && toggleButton) {
        const isOpen = sidebar.classList.contains('mobile-open');
        
        if (isOpen) {
          this.closeMobileNav();
        } else {
          this.openMobileNav();
        }
      }
    },

    openMobileNav() {
      const sidebar = document.querySelector('.sidebar');
      const toggleButton = document.querySelector('.mobile-nav-toggle');
      
      if (sidebar && toggleButton) {
        sidebar.classList.add('mobile-open');
        toggleButton.classList.add('open');
        
        const textSpan = toggleButton.querySelector('.text');
        if (textSpan) {
          textSpan.textContent = 'Fermer';
        }
        
        // Add event listener to close on outside click
        setTimeout(() => {
          document.addEventListener('click', this.handleOutsideClick);
        }, 100);
      }
    },

    closeMobileNav() {
      const sidebar = document.querySelector('.sidebar');
      const toggleButton = document.querySelector('.mobile-nav-toggle');
      
      if (sidebar && toggleButton) {
        sidebar.classList.remove('mobile-open');
        toggleButton.classList.remove('open');
        
        const textSpan = toggleButton.querySelector('.text');
        if (textSpan) {
          textSpan.textContent = 'Menu';
        }
        
        // Remove outside click listener
        document.removeEventListener('click', this.handleOutsideClick);
      }
    },

    handleOutsideClick: (e) => {
      const sidebar = document.querySelector('.sidebar');
      const toggleButton = document.querySelector('.mobile-nav-toggle');
      
      // Close if clicking outside sidebar and toggle button
      if (sidebar && toggleButton && 
          !sidebar.contains(e.target) && 
          !toggleButton.contains(e.target)) {
        JdrApp.modules.ui.closeMobileNav();
      }
    },

    setupLegacyResponsive() {
      // Keep existing responsive handlers for compatibility
      JdrApp.utils.events.register('click', '#menuToggle', () => {
        const sidebar = JdrApp.utils.dom.$('#sidebar');
        const backdrop = JdrApp.utils.dom.$('#backdrop');
        
        if (sidebar && backdrop) {
          sidebar.classList.toggle('mobile-open');
          backdrop.hidden = !sidebar.classList.contains('mobile-open');
        }
      });

      JdrApp.utils.events.register('click', '#backdrop', () => {
        const sidebar = JdrApp.utils.dom.$('#sidebar');
        const backdrop = JdrApp.utils.dom.$('#backdrop');
        
        if (sidebar && backdrop) {
          sidebar.classList.remove('mobile-open');
          backdrop.hidden = true;
        }
      });
    },

    showNotification(message, type = 'info') {
      EventBus.emit(Events.NOTIFICATION_SHOW, { message, type });
      
      // Fallback notification if storage module is not available
      if (!JdrApp.modules.storage?.showNotification) {
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: ${type === 'success' ? '#10B981' : type === 'error' ? '#EF4444' : '#3B82F6'};
          color: white;
          padding: 12px 16px;
          border-radius: 8px;
          font-weight: 500;
          z-index: 10000;
          animation: slideIn 0.3s ease;
        `;
        
        notification.textContent = message;
        document.body.appendChild(notification);
        
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 3000);
      } else {
        JdrApp.modules.storage.showNotification(message, type);
      }
    },

    // Get current page ID from DOM
    getCurrentPageId() {
      // Find the currently visible article (not hidden)
      const articles = document.querySelectorAll('article[data-static-page="true"]');
      let visibleArticle = null;
      
      for (const article of articles) {
        const style = window.getComputedStyle(article);
        if (style.display !== 'none' && style.visibility !== 'hidden') {
          visibleArticle = article;
          break;
        }
      }
      
      // Fallback: find by active class or current hash
      if (!visibleArticle) {
        const hash = window.location.hash.replace('#/', '');
        if (hash) {
          visibleArticle = document.querySelector(`article[data-page="${hash}"]`);
        }
      }
      
      // Last fallback: any visible article
      if (!visibleArticle) {
        visibleArticle = document.querySelector('article[data-static-page="true"]:not([style*="display: none"])');
      }
      
      const pageId = visibleArticle ? visibleArticle.dataset.page : null;
      if (visibleArticle) {
      }
      return pageId;
    },

    // Count existing sections for unique ID generation
    countExistingSections() {
      const pageId = this.getCurrentPageId();
      if (!pageId || !window.STATIC_PAGES || !window.STATIC_PAGES[pageId]) {
        return 0;
      }
      const pageData = window.STATIC_PAGES[pageId];
      return pageData.sections ? pageData.sections.length : 0;
    },

    // Save new section to JSON data
    saveNewSectionToJSON(sectionId, title, content) {
      const pageId = this.getCurrentPageId();
      
      if (!pageId || !window.STATIC_PAGES || !window.STATIC_PAGES[pageId]) {
        // Cannot save new section - page not found
        return false;
      }

      const pageData = window.STATIC_PAGES[pageId];
      
      // Create new section object
      const newSection = {
        type: "card",
        id: sectionId,
        title: title,
        content: content,
        deletable: true,
        sectionName: title
      };

      // Add to sections array
      if (!pageData.sections) {
        pageData.sections = [];
      }
      
      pageData.sections.push(newSection);
      
      return true;
    },

    // Delete section from JSON data
    deleteSectionFromJSON(sectionId) {
      const pageId = this.getCurrentPageId();
      if (!pageId || !window.STATIC_PAGES || !window.STATIC_PAGES[pageId]) {
        console.warn('Cannot delete section - page not found:', pageId);
        return false;
      }

      const pageData = window.STATIC_PAGES[pageId];
      if (!pageData.sections) {
        console.warn('No sections found in page data');
        return false;
      }

      console.log(`ğŸ—‘ï¸ SUPPRESSION JSON: Tentative de suppression "${sectionId}" de ${pageId}.json`);
      console.log('ğŸ“Š Ã‰tat JSON avant suppression:', {
        pageId,
        totalSections: pageData.sections.length,
        sectionIds: pageData.sections.map(s => s.id)
      });

      // Remove section by ID
      const initialLength = pageData.sections.length;
      pageData.sections = pageData.sections.filter(section => section.id !== sectionId);
      
      // Check if section was found and removed
      const removed = pageData.sections.length < initialLength;
      if (removed) {
        console.log(`âœ… SUPPRESSION JSON: Section "${sectionId}" supprimÃ©e de ${pageId}.json`);
        console.log('ğŸ“Š Ã‰tat JSON aprÃ¨s suppression:', {
          pageId,
          totalSections: pageData.sections.length,
          sectionIds: pageData.sections.map(s => s.id)
        });
        return true;
      } else {
        // Try to find in nested grid content
        for (let section of pageData.sections) {
          if (section.type === 'grid' && section.content) {
            const gridInitialLength = section.content.length;
            section.content = section.content.filter(item => item.id !== sectionId);
            if (section.content.length < gridInitialLength) {
              console.log(`âœ… SUPPRESSION JSON: Section "${sectionId}" supprimÃ©e de grille dans ${pageId}.json`);
              return true;
            }
          }
        }
        
        return false;
      }
    },

    // Recalculate all section indices in the current page to prevent conflicts
    recalculateSectionIndices() {
      // Disable index recalculation for now - it causes ID mismatches
      // The current approach of using timestamp-based unique IDs is more stable
      console.log('Index recalculation disabled - using stable unique IDs');
      return true;
    },

    // OLD VERSION - kept for reference but disabled
    _recalculateSectionIndicesOld() {
      const pageId = this.getCurrentPageId();
      if (!pageId) {
        console.warn('Cannot recalculate indices - no current page');
        return false;
      }

      // Update DOM data-edit-section attributes to match JSON structure
      const article = document.querySelector('article[data-static-page="true"]');
      if (!article) {
        console.warn('No static page article found');
        return false;
      }

      // Get the JSON data for this page
      const pageData = window.STATIC_PAGES?.[pageId];
      if (!pageData?.sections) {
        console.warn('No page data found for recalculation');
        return false;
      }

      // Build a mapping of DOM sections to JSON sections
      const sections = article.querySelectorAll('.editable-section, .card');
      let sectionIndex = 0;

      sections.forEach((domSection, domIndex) => {
        // Skip sections that don't have editable content
        const editableElements = domSection.querySelectorAll('[data-edit-section]');
        if (editableElements.length === 0) return;

        // Find corresponding JSON section
        let jsonSection = null;
        let jsonIndex = sectionIndex;

        // Try to match by existing ID first
        const firstEditable = editableElements[0];
        let currentId = firstEditable.dataset.editSection;
        if (currentId.endsWith('-title')) {
          currentId = currentId.replace('-title', '');
        }

        // Look for matching JSON section
        for (let i = 0; i < pageData.sections.length; i++) {
          const section = pageData.sections[i];
          if (section.id === currentId || section.type === 'intro') {
            jsonSection = section;
            jsonIndex = i;
            break;
          }
        }

        // If no match found, assign next available index
        if (!jsonSection && sectionIndex < pageData.sections.length) {
          jsonSection = pageData.sections[sectionIndex];
          jsonIndex = sectionIndex;
        }

        if (jsonSection) {
          // Update DOM attributes to match JSON structure
          editableElements.forEach(editable => {
            const currentEditSection = editable.dataset.editSection;
            
            // Determine the new ID based on JSON section
            let newEditSection;
            if (currentEditSection.endsWith('-title')) {
              newEditSection = `${jsonSection.id}-title`;
            } else {
              newEditSection = jsonSection.id;
            }

            // Update the data attribute
            editable.dataset.editSection = newEditSection;
            
            console.log(`Updated section ${domIndex}: ${currentEditSection} â†’ ${newEditSection}`);
          });

          sectionIndex++;
        }
      });

      // Also update section indices in JSON to ensure consistency
      pageData.sections.forEach((section, index) => {
        // Ensure each section has a proper ID
        if (!section.id || section.id.startsWith('section-')) {
          // Generate a stable ID based on title or position
          const baseId = section.title ? 
            section.title.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '') :
            `section-${index}`;
          section.id = baseId;
        }
      });

      console.log(`Recalculated indices for ${sectionIndex} sections in page ${pageId}`);
      return true;
    },

    // Trigger data save to localStorage/persistent storage
    triggerDataSave() {
      // Data is already saved in window.STATIC_PAGES in memory
    },

    createNewCategory(type) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`âŒ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Demander le nom de la catÃ©gorie
      const categoryName = prompt(`Nom de la nouvelle catÃ©gorie de ${config.container} :`);
      if (!categoryName || !categoryName.trim()) {
        return;
      }

      const trimmedName = categoryName.trim();

      // VÃ©rifier que la catÃ©gorie n'existe pas dÃ©jÃ 
      const entity = ContentFactory.getEntity(type);
      if (entity && entity.findCategory(trimmedName)) {
        this.showNotification(`âŒ Une catÃ©gorie "${trimmedName}" existe dÃ©jÃ `, 'error');
        return;
      }

      // Demander la description et spoilAlert pour les objets
      let description = prompt(`Description de la catÃ©gorie "${trimmedName}" :`);
      if (!description) description = '';

      let spoilAlert = false;
      if (type === 'objet') {
        spoilAlert = confirm('Cette catÃ©gorie contient-elle des Ã©lÃ©ments de spoil ?');
      }

      // CrÃ©er la nouvelle catÃ©gorie
      const newCategory = {
        nom: trimmedName,
        description: description.trim(),
        [config.identifiers.category]: []
      };

      // Ajouter spoilAlert pour les objets
      if (type === 'objet') {
        newCategory.spoilAlert = spoilAlert;
      }

      // Ajouter Ã  la structure de donnÃ©es
      const dataKey = config.dataKey;
      if (!window[dataKey]) {
        window[dataKey] = [];
      }

      window[dataKey].push(newCategory);

      // RafraÃ®chir ContentFactory
      ContentFactory.refreshData();

      // RafraÃ®chir le router TOC
      if (JdrApp.modules.router && JdrApp.modules.router.generateTOC) {
        JdrApp.modules.router.generateTOC();
      }

      // Naviguer vers la nouvelle catÃ©gorie
      const categoryRoute = `${config.container}-${JdrApp.utils.data.sanitizeId(trimmedName)}`;
      JdrApp.modules.router.navigate(categoryRoute);

      this.showNotification(`${config.icons.category} CatÃ©gorie "${trimmedName}" crÃ©Ã©e avec succÃ¨s!`, 'success');
    },

    deleteCategory(type, categoryName) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`âŒ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Confirmation avec dÃ©tails
      const entity = ContentFactory.getEntity(type);
      const category = entity?.findCategory(categoryName);
      
      if (!category) {
        this.showNotification(`âŒ CatÃ©gorie "${categoryName}" introuvable`, 'error');
        return;
      }

      const itemsProperty = this.getItemsProperty(type);
      const itemCount = category[itemsProperty]?.length || 0;
      
      const confirmMessage = itemCount > 0 
        ? `Supprimer la catÃ©gorie "${categoryName}" et ses ${itemCount} Ã©lÃ©ments ?`
        : `Supprimer la catÃ©gorie vide "${categoryName}" ?`;
        
      if (!confirm(confirmMessage)) {
        return;
      }

      // Supprimer de la structure de donnÃ©es
      const dataKey = config.dataKey;
      if (window[dataKey]) {
        const categoryIndex = window[dataKey].findIndex(cat => cat.nom === categoryName);
        
        if (categoryIndex >= 0) {
          window[dataKey].splice(categoryIndex, 1);
          
          // RafraÃ®chir ContentFactory
          ContentFactory.refreshData();

          // RafraÃ®chir le router TOC
          if (JdrApp.modules.router && JdrApp.modules.router.generateTOC) {
            JdrApp.modules.router.generateTOC();
          }

          // Naviguer vers la page principale du type
          JdrApp.modules.router.navigate(config.container);

          this.showNotification(`${config.icons.delete} CatÃ©gorie "${categoryName}" supprimÃ©e`, 'success');
        } else {
          this.showNotification(`âŒ Erreur lors de la suppression`, 'error');
        }
      }
    },

    getItemsProperty(type) {
      switch (type) {
        case 'spell': return 'sorts';
        case 'don': return 'dons';
        case 'objet': return 'objets';
        case 'class': return 'sousClasses';
        default: return 'items';
      }
    },

    // SUPPRIMÃ‰: Toutes les mÃ©thodes de gestion des filtres (showFilterManagementModal, createFilterModal, updateFilterModalContent, saveFilterSettings, resetFilterSettings, moveTagInModal)

    refreshObjectsPage() {
      // Check if we're currently on the objects page
      if (window.location.hash === '#/objets' || window.location.hash === '#/objet') {
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: 'objet',
          category: window.OBJETS
        });
      }
    },

    refreshMonstersPage() {
      // Check if we're currently on the monsters page
      if (window.location.hash === '#/monstres' || window.location.hash === '#/monstre') {
        // Use the router to refresh the monsters page
        if (JdrApp.modules.router && JdrApp.modules.router.renderMonstersPage) {
          JdrApp.modules.router.renderMonstersPage();
        }
      }
    },

    refreshTablesTresorsPage() {
      // Check if we're currently on the tables de trÃ©sors page
      if (window.location.hash === '#/tables-tresors') {
        // Use the router to refresh the tables de trÃ©sors page
        if (JdrApp.modules.router && JdrApp.modules.router.renderTablesTresorsPage) {
          JdrApp.modules.router.renderTablesTresorsPage();
        }
      }
    },

    // ==== SPELL ELEMENT MANAGEMENT ====

    updateSpellElement(selectElement) {
      // Get the selected element
      const newElement = selectElement.value;
      const spellName = selectElement.dataset.spellName;
      const categoryName = selectElement.dataset.categoryName;

      if (!newElement || !spellName || !categoryName) {
        this.showNotification('âŒ Erreur : donnÃ©es du sort manquantes', 'error');
        return;
      }

      // Find and update the spell data
      const spellEntity = ContentFactory.getEntity('spell');
      const category = spellEntity?.findCategory(categoryName);
      
      if (!category) {
        this.showNotification(`âŒ CatÃ©gorie "${categoryName}" introuvable`, 'error');
        return;
      }

      const spell = category.sorts?.find(s => s.nom === spellName);
      if (!spell) {
        this.showNotification(`âŒ Sort "${spellName}" introuvable`, 'error');
        return;
      }

      // Update the spell element
      spell.element = newElement;

      // Save the changes to storage
      EventBus.emit(Events.STORAGE_SAVE);

      // Update the visual display
      const spellCard = selectElement.closest('.card');
      if (spellCard) {
        const elementDisplay = spellCard.querySelector('.spell-element-selector').parentNode;
        if (elementDisplay) {
          // Find the icon and colors for the new element
          const icon = window.ElementIcons ? window.ElementIcons[newElement] : 'ğŸ”¥';
          const colors = window.ElementColors ? window.ElementColors[newElement] : { color: '#ff6b35', weight: 'bold' };
          
          // Build style string
          let style = `color: ${colors.color}; font-weight: ${colors.weight};`;
          if (colors.background) style += ` background: ${colors.background};`;
          if (colors.padding) style += ` padding: ${colors.padding};`;
          if (colors.borderRadius) style += ` border-radius: ${colors.borderRadius};`;
          
          // Update the dropdown options to reflect the selection
          const options = Object.keys(window.ElementIcons || {});
          const optionsHTML = options.map(elem => 
            `<option value="${elem}" ${elem === newElement ? 'selected' : ''}>${window.ElementIcons[elem]} ${elem}</option>`
          ).join('');
          
          selectElement.innerHTML = optionsHTML;
        }
      }

      // Trigger page re-render to update all spell displays
      EventBus.emit(Events.PAGE_RENDER, {
        type: 'category',
        categoryType: 'spell',
        category: category
      });

      // Show success notification
      const elementIcon = window.ElementIcons ? window.ElementIcons[newElement] : 'ğŸ”¥';
      this.showNotification(`${elementIcon} Ã‰lÃ©ment du sort "${spellName}" mis Ã  jour : ${newElement}`, 'success');
    },

    // ========================================
    // NEW PAGE CREATION WITH SECTION SELECTION
    // ========================================
    setupNewPageHandler() {
      // Set up event listener for "Nouvelle page" button
      document.addEventListener('click', (e) => {
        if (e.target && e.target.id === 'addCategory') {
          e.preventDefault();
          this.showSectionSelectionModal();
        }
      });
    },

    showSectionSelectionModal() {
      const modal = this.createSectionSelectionModal();
      document.body.appendChild(modal);
      this.openModal('sectionSelectionModal');
    },

    createSectionSelectionModal() {
      // Get available sections from TOC structure
      const sections = window.TOC_STRUCTURE?.sections || [
        { id: 'heros', title: 'ğŸ¦¸ HÃ©ros', icon: 'ğŸ¦¸' },
        { id: 'arsenal', title: 'âš”ï¸ Arsenal', icon: 'âš”ï¸' },
        { id: 'regles', title: 'ğŸ“š RÃ¨gles', icon: 'ğŸ“š' }
      ];

      // Filter sections based on MJ access if needed
      const availableSections = sections.filter(section => 
        !section.requiresMJ || window.JdrApp?.state?.isMJ
      );

      const sectionsHTML = availableSections.map(section => `
        <div class="section-option" data-section-id="${section.id}">
          <div class="section-icon">${section.icon}</div>
          <div class="section-info">
            <div class="section-title">${section.title}</div>
            <div class="section-description">${section.description || 'Section de contenu'}</div>
          </div>
        </div>
      `).join('');

      const modal = document.createElement('div');
      modal.className = 'modal section-selection-modal';
      modal.id = 'sectionSelectionModal';
      modal.innerHTML = `
        <div class="modal-overlay"></div>
        <div class="modal-content">
          <h3>ğŸ“„ Nouvelle page</h3>
          <p>Dans quelle section souhaitez-vous crÃ©er la nouvelle page ?</p>
          
          <div class="sections-list">
            ${sectionsHTML}
          </div>
          
          <div class="page-details" style="display: none;">
            <div class="form-group">
              <label for="pageTitle">Titre de la page :</label>
              <input type="text" id="pageTitle" placeholder="Nom de la nouvelle page" required>
            </div>
            <div class="form-group">
              <label for="pageIcon">IcÃ´ne (optionnel) :</label>
              <select id="pageIcon">
                <option value="ğŸ“„">ğŸ“„ Page</option>
                <option value="âš”ï¸">âš”ï¸ Combat</option>
                <option value="ğŸ”®">ğŸ”® Magie</option>
                <option value="ğŸ›ï¸">ğŸ›ï¸ Lieu</option>
                <option value="ğŸ‘¥">ğŸ‘¥ Personnages</option>
                <option value="ğŸ“š">ğŸ“š RÃ¨gles</option>
                <option value="ğŸ—¡ï¸">ğŸ—¡ï¸ Armes</option>
                <option value="ğŸ›¡ï¸">ğŸ›¡ï¸ Armures</option>
                <option value="ğŸ’°">ğŸ’° Ã‰conomie</option>
                <option value="ğŸŒŸ">ğŸŒŸ Ã‰lÃ©ments</option>
                <option value="ğŸ“Š">ğŸ“Š Statistiques</option>
                <option value="ğŸ¯">ğŸ¯ CompÃ©tences</option>
                <option value="âš¡">âš¡ Ã‰tats</option>
                <option value="ğŸ“œ">ğŸ“œ Histoire</option>
                <option value="ğŸ—ºï¸">ğŸ—ºï¸ GÃ©ographie</option>
                <option value="ğŸ‘¹">ğŸ‘¹ Monstres</option>
                <option value="ğŸ­">ğŸ­ Culture</option>
                <option value="ğŸ°">ğŸ° Royaumes</option>
                <option value="â­">â­ Important</option>
                <option value="ğŸ’">ğŸ’ TrÃ©sors</option>
              </select>
            </div>
          </div>
          
          <div class="modal-actions">
            <button type="button" class="btn modal-close">Annuler</button>
            <button type="button" class="btn btn-primary" id="createPageBtn" style="display: none;">CrÃ©er la page</button>
          </div>
        </div>
      `;

      // Set up event handlers
      this.setupSectionSelectionHandlers(modal);

      return modal;
    },

    setupSectionSelectionHandlers(modal) {
      let selectedSectionId = null;

      // Section selection
      modal.addEventListener('click', (e) => {
        const sectionOption = e.target.closest('.section-option');
        if (sectionOption) {
          // Remove previous selection
          modal.querySelectorAll('.section-option').forEach(opt => opt.classList.remove('selected'));
          
          // Select this section
          sectionOption.classList.add('selected');
          selectedSectionId = sectionOption.dataset.sectionId;
          
          // Show page details form
          const pageDetails = modal.querySelector('.page-details');
          const createBtn = modal.querySelector('#createPageBtn');
          pageDetails.style.display = 'block';
          createBtn.style.display = 'inline-block';
          
          // Focus on title input
          modal.querySelector('#pageTitle').focus();
        }
      });

      // Create page button
      modal.querySelector('#createPageBtn').addEventListener('click', () => {
        const titleInput = modal.querySelector('#pageTitle');
        const iconInput = modal.querySelector('#pageIcon');
        
        const pageTitle = titleInput.value.trim();
        const pageIcon = iconInput.value || 'ğŸ“„';
        
        if (!pageTitle) {
          this.showNotification('Veuillez saisir un titre pour la page', 'error');
          titleInput.focus();
          return;
        }

        if (!selectedSectionId) {
          this.showNotification('Veuillez sÃ©lectionner une section', 'error');
          return;
        }

        this.createNewPage(selectedSectionId, pageTitle, pageIcon);
        this.closeModal(modal);
      });

      // Handle Enter key in form
      modal.querySelector('#pageTitle').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && selectedSectionId) {
          modal.querySelector('#createPageBtn').click();
        }
      });
    },

    createNewPage(sectionId, pageTitle, pageIcon) {
      // Generate page ID from title
      const pageId = this.slugify(pageTitle);
      
      // Create new page object
      const newPage = {
        type: 'page',
        id: pageId,
        title: pageTitle,
        icon: pageIcon
      };

      // Add to TOC structure
      if (window.TOC_STRUCTURE) {
        const section = window.TOC_STRUCTURE.sections.find(s => s.id === sectionId);
        if (section) {
          section.items.push(newPage);
          
          // Create default page data
          const defaultPageData = {
            page: pageId,
            title: pageTitle,
            sections: [
              {
                type: 'intro',
                content: `Contenu de la page ${pageTitle}. Vous pouvez Ã©diter ce texte en mode dÃ©veloppement.`
              }
            ]
          };

          // Add to static pages
          if (!window.STATIC_PAGES) {
            window.STATIC_PAGES = {};
          }
          window.STATIC_PAGES[pageId] = defaultPageData;

          // Add to static pages config
          if (!window.STATIC_PAGES_CONFIG) {
            window.STATIC_PAGES_CONFIG = { pages: [] };
          }
          const newPageConfig = {
            id: pageId,
            title: pageTitle,
            file: `${pageId}.json`,
            active: true,
            order: window.STATIC_PAGES_CONFIG.pages.length + 1
          };
          window.STATIC_PAGES_CONFIG.pages.push(newPageConfig);

          // Create the article element for the new page
          this.createPageArticle(pageId, pageTitle, defaultPageData);

          // Regenerate TOC to include new page
          if (JdrApp.modules.router) {
            JdrApp.modules.router.generateTOC();
          }

          // Save changes
          if (JdrApp.modules.storage) {
            JdrApp.modules.storage.saveChanges(true);
          }

          // Navigate to new page
          window.location.hash = `#/${pageId}`;

          this.showNotification(`ğŸ“„ Page "${pageTitle}" crÃ©Ã©e avec succÃ¨s dans la section ${this.getSectionTitle(sectionId)}`, 'success');
        }
      }
    },

    createPageArticle(pageId, pageTitle, pageData) {
      // Force the renderer to generate the page content immediately
      if (JdrApp.modules.renderer && JdrApp.modules.renderer.generatePageContent) {
        const content = JdrApp.modules.renderer.generatePageContent(pageId);
        if (content) {
          // Create the article if it doesn't exist
          let article = document.querySelector(`article[data-page="${pageId}"]`);
          if (!article) {
            article = document.createElement('article');
            article.setAttribute('data-page', pageId);
            article.style.display = 'none';
            const viewsContainer = document.getElementById('views');
            if (viewsContainer) {
              viewsContainer.appendChild(article);
            }
          }
          // Set the content
          article.innerHTML = content;
        }
      }
    },

    getSectionTitle(sectionId) {
      if (window.TOC_STRUCTURE) {
        const section = window.TOC_STRUCTURE.sections.find(s => s.id === sectionId);
        return section ? section.title : sectionId;
      }
      return sectionId;
    },

    // ==== GLOBAL TAGS MANAGEMENT ====

    showTagsManagementModal() {
      // DÃ©terminer le type de contenu basÃ© sur la page actuelle
      const currentPage = window.location.hash.replace('#/', '') || 'creation';
      let contentType = 'objet'; // par dÃ©faut
      let config = null;
      
      if (currentPage === 'monstres' && window.ContentTypes.monster?.filterConfig) {
        contentType = 'monster';
        config = window.ContentTypes.monster.filterConfig;
      } else if (window.ContentTypes.objet?.filterConfig) {
        contentType = 'objet';
        config = window.ContentTypes.objet.filterConfig;
      }
      
      if (!config) {
        this.showNotification('âŒ Configuration des tags non trouvÃ©e', 'error');
        return;
      }

      // Remove any existing modal
      const existingModal = document.querySelector('#tagsManagementModal');
      if (existingModal) {
        existingModal.remove();
      }

      const modal = this.createTagsManagementModal(config, contentType);
      document.body.appendChild(modal);
      
      // Use native dialog showModal for proper z-index
      modal.showModal();
    },

    createTagsManagementModal(config, contentType = 'objet') {
      const modal = document.createElement('dialog');
      modal.id = 'tagsManagementModal';
      modal.style.cssText = `
        max-width: 600px;
        width: 90%;
        padding: 0;
        border: none;
        border-radius: 12px;
        background: transparent;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      `;

      const tagsListHTML = config.availableTags.map((tag, index) => `
        <div class="tag-item" data-tag-index="${index}" data-tag-name="${tag}">
          <span class="tag-chip" style="background: var(--bronze); color: white; padding: 4px 8px; border-radius: 8px; margin-right: 0.5rem;">${tag}</span>
          <input type="text" value="${tag}" class="tag-input" style="flex: 1; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 4px; margin-right: 0.5rem;">
          <button type="button" class="btn small delete-tag-btn" data-tag-name="${tag}" style="background: #dc2626 !important; color: white !important; padding: 0.25rem 0.5rem !important; display: inline-block !important; opacity: 1 !important; visibility: visible !important;">
            ğŸ—‘ï¸
          </button>
        </div>
      `).join('');

      modal.innerHTML = `
        <div style="background: var(--paper); border-radius: 12px; padding: 1.5rem; border: 2px solid var(--rule);">
          <h3 style="margin: 0 0 1rem 0; color: var(--accent-ink);">ğŸ·ï¸ Gestion des tags globaux</h3>
          <p style="margin: 0 0 1rem 0; color: var(--paper-muted);">GÃ©rez la liste principale des tags disponibles pour les ${contentType === 'monster' ? 'monstres' : 'objets'}.</p>
          
          <div style="margin: 1rem 0;">
            <h4 style="margin: 0 0 0.5rem 0; color: var(--accent-ink);">Tags existants :</h4>
            <div id="tagsManagementList" style="max-height: 300px; overflow-y: auto;">
              ${tagsListHTML}
            </div>
          </div>
          
          <div style="margin: 1rem 0; padding: 1rem; background: var(--card); border-radius: 8px;">
            <h4 style="margin: 0 0 0.5rem 0; color: var(--accent-ink);">Ajouter un nouveau tag :</h4>
            <div style="display: flex; gap: 0.5rem; align-items: center;">
              <input type="text" id="newTagInput" placeholder="Nom du nouveau tag" style="flex: 1; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 4px;">
              <button type="button" id="addTagBtn" class="btn" style="background: var(--accent); color: white;">
                â• Ajouter
              </button>
            </div>
          </div>
          
          <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem;">
            <button type="button" class="btn modal-close" style="background: #666; color: white;">
              âŒ Annuler
            </button>
            <button type="button" id="saveTagsManagementBtn" class="btn" style="background: var(--accent); color: white;">
              ğŸ’¾ Sauvegarder
            </button>
          </div>
        </div>
      `;

      this.setupTagsManagementHandlers(modal, config, contentType);
      return modal;
    },

    setupTagsManagementHandlers(modal, config, contentType = 'objet') {
      // Add new tag
      modal.querySelector('#addTagBtn').addEventListener('click', () => {
        const input = modal.querySelector('#newTagInput');
        const newTag = input.value.trim();
        
        if (!newTag) {
          this.showNotification('âŒ Veuillez saisir un nom de tag', 'error');
          return;
        }
        
        if (config.availableTags.includes(newTag)) {
          this.showNotification(`âŒ Le tag "${newTag}" existe dÃ©jÃ `, 'error');
          return;
        }
        
        // Add to temporary config (will be saved when user clicks save)
        config.availableTags.push(newTag);
        
        // Update the modal display
        this.refreshTagsManagementModal(modal, config);
        
        // Clear input
        input.value = '';
        this.showNotification(`â• Tag "${newTag}" ajoutÃ© Ã  la liste`, 'success');
      });

      // Handle Enter key in new tag input
      modal.querySelector('#newTagInput').addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          modal.querySelector('#addTagBtn').click();
        }
      });

      // Delete tag
      modal.addEventListener('click', (e) => {
        if (e.target.classList.contains('delete-tag-btn')) {
          const tagName = e.target.dataset.tagName;
          
          if (config.availableTags.length <= 1) {
            this.showNotification('âŒ Impossible de supprimer le dernier tag', 'error');
            return;
          }
          
          if (confirm(`Supprimer le tag "${tagName}" ?\nAttention: il sera retirÃ© de tous les objets qui l'utilisent.`)) {
            // Remove from config
            config.availableTags = config.availableTags.filter(tag => tag !== tagName);
            
            // Remove from all items that use this tag
            if (contentType === 'monster' && Array.isArray(window.MONSTRES)) {
              window.MONSTRES.forEach(monster => {
                if (monster.tags && monster.tags.includes(tagName)) {
                  monster.tags = monster.tags.filter(tag => tag !== tagName);
                  // Ensure monster has at least one tag if possible
                  if (monster.tags.length === 0 && config.availableTags.length > 0) {
                    monster.tags = [config.availableTags[0]];
                  }
                }
              });
              
              // Update filter settings to remove deleted tag for monsters
              if (window.MONSTRES_FILTER_STATE?.visibleTags) {
                window.MONSTRES_FILTER_STATE.visibleTags = window.MONSTRES_FILTER_STATE.visibleTags.filter(tag => tag !== tagName);
                // Ensure at least one visible tag remains
                if (window.MONSTRES_FILTER_STATE.visibleTags.length === 0 && config.availableTags.length > 0) {
                  window.MONSTRES_FILTER_STATE.visibleTags = [config.availableTags[0]];
                }
              }
            } else if (contentType === 'objet' && window.OBJETS?.objets) {
              window.OBJETS.objets.forEach(obj => {
                if (obj.tags && obj.tags.includes(tagName)) {
                  obj.tags = obj.tags.filter(tag => tag !== tagName);
                  // Ensure object has at least one tag if possible
                  if (obj.tags.length === 0 && config.availableTags.length > 0) {
                    obj.tags = [config.availableTags[0]];
                  }
                }
              });
              
              // Update filter settings to remove deleted tag for objects
              if (window.OBJETS?.filterSettings?.visibleTags) {
                window.OBJETS.filterSettings.visibleTags = window.OBJETS.filterSettings.visibleTags.filter(tag => tag !== tagName);
                // Ensure at least one visible tag remains
                if (window.OBJETS.filterSettings.visibleTags.length === 0 && config.availableTags.length > 0) {
                  window.OBJETS.filterSettings.visibleTags = [config.availableTags[0]];
                }
              }
            }
            
            // Update modal display
            this.refreshTagsManagementModal(modal, config);
            this.showNotification(`ğŸ—‘ï¸ Tag "${tagName}" supprimÃ©`, 'success');
          }
        }
      });

      // Save all changes
      modal.querySelector('#saveTagsManagementBtn').addEventListener('click', () => {
        // Collect all tag renames
        const tagItems = modal.querySelectorAll('.tag-item');
        const renames = [];
        
        tagItems.forEach(item => {
          const originalName = item.dataset.tagName;
          const newName = item.querySelector('.tag-input').value.trim();
          
          if (newName && newName !== originalName) {
            renames.push({ old: originalName, new: newName });
          }
        });
        
        // Apply renames to config
        renames.forEach(rename => {
          const index = config.availableTags.indexOf(rename.old);
          if (index >= 0) {
            config.availableTags[index] = rename.new;
            
            // Update all items that use this tag
            if (contentType === 'monster' && Array.isArray(window.MONSTRES)) {
              window.MONSTRES.forEach(monster => {
                if (monster.tags && monster.tags.includes(rename.old)) {
                  const tagIndex = monster.tags.indexOf(rename.old);
                  monster.tags[tagIndex] = rename.new;
                }
              });
            } else if (contentType === 'objet' && window.OBJETS?.objets) {
              window.OBJETS.objets.forEach(obj => {
                if (obj.tags && obj.tags.includes(rename.old)) {
                  const tagIndex = obj.tags.indexOf(rename.old);
                  obj.tags[tagIndex] = rename.new;
                }
              });
              
              // Update filter settings for objects
              if (window.OBJETS?.filterSettings?.visibleTags) {
                const visibleIndex = window.OBJETS.filterSettings.visibleTags.indexOf(rename.old);
                if (visibleIndex >= 0) {
                  window.OBJETS.filterSettings.visibleTags[visibleIndex] = rename.new;
                }
              }
            }
          }
        });
        
        // Save to storage
        EventBus.emit(Events.STORAGE_SAVE);
        
        // Refresh current page if it matches the content type
        if (contentType === 'monster') {
          this.refreshMonstersPage();
        } else {
          this.refreshObjectsPage();
        }
        
        // Close modal
        modal.close();
        modal.remove();
        
        const changesCount = renames.length;
        if (changesCount > 0) {
          this.showNotification(`ğŸ’¾ ${changesCount} modification(s) sauvegardÃ©e(s)`, 'success');
        } else {
          this.showNotification('ğŸ’¾ Tags sauvegardÃ©s', 'success');
        }
      });

      // Close modal events
      modal.querySelector('.modal-close').addEventListener('click', () => {
        modal.close();
        modal.remove();
      });

      modal.addEventListener('cancel', () => {
        modal.close();
        modal.remove();
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.close();
          modal.remove();
        }
      });
    },

    refreshTagsManagementModal(modal, config) {
      const container = modal.querySelector('#tagsManagementList');
      if (!container) return;

      const tagsListHTML = config.availableTags.map((tag, index) => `
        <div class="tag-item" data-tag-index="${index}" data-tag-name="${tag}">
          <span class="tag-chip" style="background: var(--bronze); color: white; padding: 4px 8px; border-radius: 8px; margin-right: 0.5rem;">${tag}</span>
          <input type="text" value="${tag}" class="tag-input" style="flex: 1; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 4px; margin-right: 0.5rem;">
          <button type="button" class="btn small delete-tag-btn" data-tag-name="${tag}" style="background: #dc2626; color: white; padding: 0.25rem 0.5rem;">
            ğŸ—‘ï¸
          </button>
        </div>
      `).join('');

      container.innerHTML = tagsListHTML;
    },

    // ==== ID SEARCH FUNCTIONALITY ====

    performIdSearch(searchValue) {
      const searchId = searchValue.trim();
      const resultDiv = document.querySelector('#id-search-result');
      
      if (!searchId) {
        this.clearIdSearch();
        return;
      }

      const searchNumber = parseInt(searchId, 10);
      if (isNaN(searchNumber)) {
        if (resultDiv) {
          resultDiv.innerHTML = 'âŒ Veuillez saisir un numÃ©ro valide';
          resultDiv.style.color = '#dc2626';
        }
        return;
      }

      // Find object by number
      const allObjects = window.OBJETS?.objets || [];
      const foundObject = allObjects.find(obj => obj.numero === searchNumber);

      if (!foundObject) {
        if (resultDiv) {
          resultDiv.innerHTML = `âŒ Aucun objet trouvÃ© avec l'ID ${searchNumber}`;
          resultDiv.style.color = '#dc2626';
        }
        // Hide all objects
        this.hideAllObjects();
        return;
      }

      // Set global flag BEFORE regenerating page
      window.activeIdSearch = true;

      // Immediately hide the container to prevent flash
      const container = document.querySelector('#objets-container');
      if (container) {
        container.style.visibility = 'hidden';
      }

      // Show success message immediately
      if (resultDiv) {
        resultDiv.innerHTML = `âœ… Objet trouvÃ© : "${foundObject.nom}" (ID: ${searchNumber})`;
        resultDiv.style.color = '#16a34a';
      }

      // Force regenerate page with all objects AND visual feedback
      if (JdrApp.modules.renderer?.regenerateCurrentPage) {
        JdrApp.modules.renderer.regenerateCurrentPage();
      }

      // After regeneration, configure display and show only target object
      requestAnimationFrame(() => {
        const newContainer = document.querySelector('#objets-container');
        if (newContainer) {
          // Hide all objects first
          this.hideAllObjects();
          
          // Show only the target object and make container visible again
          setTimeout(() => {
            this.showOnlyObjectById(searchNumber);
            newContainer.style.visibility = 'visible';
            
            // Restore the search value in the input field
            const searchInput = document.querySelector('#id-search-input');
            if (searchInput) {
              searchInput.value = searchNumber;
            }
          }, 10);
        }
      });
    },

    clearIdSearch() {
      const input = document.querySelector('#id-search-input');
      const resultDiv = document.querySelector('#id-search-result');
      
      if (input) {
        input.value = '';
      }
      
      if (resultDiv) {
        resultDiv.innerHTML = '';
        resultDiv.style.color = '';
      }

      // Clear global flag for active ID search
      window.activeIdSearch = false;

      // Reset container styles when clearing search
      const container = document.querySelector('#objets-container');
      if (container) {
        container.style.display = '';
        container.style.flexDirection = '';
        container.style.alignItems = '';
        container.style.justifyContent = '';
        container.style.minHeight = '';
        container.style.padding = '';
        container.style.visibility = ''; // Restore visibility
        
        // Reset all card sizes to normal
        const allCards = container.querySelectorAll('.card');
        allCards.forEach(card => {
          card.style.minWidth = '';
          card.style.maxWidth = '';
          card.style.width = '';
        });
      }

      // Regenerate page to update visual feedback and return to normal display
      if (JdrApp.modules.renderer?.regenerateCurrentPage) {
        JdrApp.modules.renderer.regenerateCurrentPage();
      }
    },

    hideAllObjects() {
      const container = document.querySelector('#objets-container');
      if (container) {
        const allCards = container.querySelectorAll('.card');
        allCards.forEach(card => {
          card.style.display = 'none';
        });
      }
    },

    showOnlyObjectById(objectId) {
      const container = document.querySelector('#objets-container');
      if (!container) {
        return;
      }

      const allCards = container.querySelectorAll('.card');
      let foundCard = null;

      allCards.forEach((card, index) => {
        const objetName = card.dataset.objetName;
        if (objetName) {
          // Find the object by name to get its number
          const obj = window.OBJETS?.objets?.find(o => o.nom === objetName);
          if (obj && obj.numero === objectId) {
            card.style.display = '';
            foundCard = card;
          } else {
            card.style.display = 'none';
          }
        }
      });


      // Scroll to the found card if it exists
      if (foundCard) {
        // Center the found object both horizontally and vertically
        const container = document.querySelector('#objets-container');
        if (container) {
          // Apply centering styles to the container when showing single object
          container.style.display = 'flex';
          container.style.flexDirection = 'column';
          container.style.alignItems = 'center';
          container.style.justifyContent = 'center';
          container.style.minHeight = '70vh';
          container.style.padding = '2rem';
        }

        // Enlarge the found card for better visibility when searched by ID
        // Check if we're on mobile to adjust sizing accordingly
        const isMobile = window.innerWidth <= 640;
        if (isMobile) {
          // On mobile, use slightly smaller enlargement to fit the screen
          foundCard.style.minWidth = '320px';
          foundCard.style.maxWidth = '90vw';
          foundCard.style.width = '90vw';
        } else {
          // On desktop, double the normal size
          foundCard.style.minWidth = '560px'; // Double the normal min-width (280px * 2)
          foundCard.style.maxWidth = '700px'; // Double the normal max-width (350px * 2)
          foundCard.style.width = 'auto';
        }

        setTimeout(() => {
          foundCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
          // Enhanced highlight effect for centered object
          foundCard.style.transition = 'all 0.4s ease';
          foundCard.style.boxShadow = '0 0 30px rgba(212, 175, 55, 0.6), 0 0 60px rgba(212, 175, 55, 0.3)';
          foundCard.style.transform = 'scale(1.05)';
          foundCard.style.zIndex = '10';
          
          setTimeout(() => {
            foundCard.style.boxShadow = '0 4px 20px rgba(0,0,0,0.15)';
            foundCard.style.transform = 'scale(1.02)';
            foundCard.style.zIndex = '';
          }, 2000);
        }, 100);
      }
    },

    showAllObjectsWithTagFilters() {
      // Restore normal tag filtering behavior
      const currentSettings = window.OBJETS?.filterSettings || { 
        visibleTags: window.ContentTypes.objet.filterConfig.defaultVisibleTags 
      };
      
      const container = document.querySelector('#objets-container');
      if (!container) return;

      // Reset container styles to normal grid layout
      container.style.display = '';
      container.style.flexDirection = '';
      container.style.alignItems = '';
      container.style.justifyContent = '';
      container.style.minHeight = '';
      container.style.padding = '';
      container.style.visibility = ''; // Restore visibility

      const allCards = container.querySelectorAll('.card');
      allCards.forEach(card => {
        // Reset card sizing to normal
        card.style.minWidth = '';
        card.style.maxWidth = '';
        card.style.width = '';
        
        const objetName = card.dataset.objetName;
        if (objetName) {
          // Find the object and check if it has visible tags
          const obj = window.OBJETS?.objets?.find(o => o.nom === objetName);
          if (obj && obj.tags) {
            const hasVisibleTag = obj.tags.some(tag => currentSettings.visibleTags.includes(tag));
            card.style.display = hasVisibleTag ? '' : 'none';
          } else {
            card.style.display = 'none';
          }
        }
      });
    },

    // Toggle individual filter tag
    toggleFilter(chipElement) {
      const tag = chipElement.dataset.tag;
      if (!tag) return;

      // GUARD: Prevent rapid double clicks (debounce)
      if (this._toggleInProgress) {
        return;
      }
      this._toggleInProgress = true;
      
      // Release the lock after a short delay
      setTimeout(() => {
        this._toggleInProgress = false;
      }, 100);

      // DÃ©terminer le type de contenu basÃ© sur la page actuelle
      const currentPage = window.location.hash.replace('#/', '') || 'creation';
      let contentType = 'objet'; // par dÃ©faut
      let dataObject = null;
      let visibleTags = null;
      
      if (currentPage === 'monstres') {
        contentType = 'monster';
        // Pour les monstres, on utilise une structure simplifiÃ©e dans window.MONSTRES_FILTER_STATE
        if (!window.MONSTRES_FILTER_STATE) {
          window.MONSTRES_FILTER_STATE = { visibleTags: [...window.ContentTypes.monster.filterConfig.defaultVisibleTags] };
        }
        visibleTags = window.MONSTRES_FILTER_STATE.visibleTags;
      } else if (currentPage === 'tables-tresors') {
        contentType = 'tableTresor';
        // Pour les tables de trÃ©sors
        if (!window.TABLES_TRESORS_FILTER_STATE) {
          // Use fallback default tags if ContentTypes is not available
          const defaultTags = window.ContentTypes?.tableTresor?.filterConfig?.defaultVisibleTags || ['Commun'];
          window.TABLES_TRESORS_FILTER_STATE = { visibleTags: [...defaultTags] };
        }
        visibleTags = window.TABLES_TRESORS_FILTER_STATE.visibleTags;
      } else {
        // Pour les objets - NOUVEAU SYSTÃˆME SIMPLIFIÃ‰
        if (!window.ACTIVE_OBJECT_TAGS) {
          window.ACTIVE_OBJECT_TAGS = []; // Aucun tag actif par dÃ©faut
        }
        visibleTags = window.ACTIVE_OBJECT_TAGS;
      }
      
      // IMPORTANT: Track state BEFORE modification to know if we need full regeneration
      const wasEmpty = visibleTags.length === 0;
      
      // SIMPLE LOGIC: Check visual state directly and toggle
      const isVisuallyActive = chipElement.classList.contains('active');
      

      if (isVisuallyActive) {
        // DEACTIVATE - remove from visible tags
        const tagIndex = visibleTags.indexOf(tag);
        if (tagIndex > -1) {
          visibleTags.splice(tagIndex, 1);
        }
        chipElement.classList.remove('active');
        chipElement.classList.add('inactive');
        chipElement.style.background = '#6b7280';
        chipElement.style.opacity = '0.6';
        chipElement.style.boxShadow = '';
        // Mise Ã  jour du texte du bouton
        chipElement.innerHTML = tag;
        chipElement.title = 'Inactif - Cliquer pour activer';
        this.showNotification(`ğŸ·ï¸ Tag "${tag}" dÃ©sactivÃ©`, 'info');
      } else {
        // ACTIVATE - add to visible tags
        if (!visibleTags.includes(tag)) {
          visibleTags.push(tag);
        }
        chipElement.classList.add('active');
        chipElement.classList.remove('inactive');
        chipElement.style.background = '#16a34a';
        chipElement.style.opacity = '1';
        chipElement.style.boxShadow = '0 2px 4px rgba(22, 163, 74, 0.3)';
        // Mise Ã  jour du texte du bouton
        chipElement.innerHTML = 'âœ“ ' + tag;
        chipElement.title = 'Actif - Cliquer pour dÃ©sactiver';
        this.showNotification(`ğŸ·ï¸ Tag "${tag}" activÃ©`, 'info');
      }


      // Check if we need a full page regeneration vs just visibility update
      const nowHasTags = visibleTags.length > 0;
      
      if (contentType === 'monster' || contentType === 'tableTresor') {
        // For monsters and tables de trÃ©sors, ALWAYS refresh because they have special logic
        // Any change in tags can reveal/hide different content and update UI elements
        this.refreshCurrentPage(contentType);
      } else {
        // SIMPLIFIÃ‰: Pour les objets, toujours rafraÃ®chir la page
        // C'est plus simple et Ã©vite les problÃ¨mes de synchronisation
        this.refreshCurrentPage(contentType);
        
        // Mettre Ã  jour le texte indicateur du nombre de tags actifs
        setTimeout(() => {
          const statusElement = document.querySelector('.objects-tag-display p');
          if (statusElement) {
            const activeCount = visibleTags.length;
            statusElement.innerHTML = activeCount === 0 
              ? 'Aucun filtre actif - Tous les objets affichÃ©s' 
              : activeCount === 1 
                ? '1 filtre actif - Objets avec ce tag uniquement'
                : `${activeCount} filtres actifs - Objets avec TOUS ces tags`;
          }
        }, 100);
      }

      // Save changes to storage
      EventBus.emit(Events.STORAGE_SAVE);
    },

    refreshCurrentPage(contentType) {
      if (contentType === 'monster') {
        this.refreshMonstersPage();
      } else if (contentType === 'tableTresor') {
        this.refreshTablesTresorsPage();
      } else {
        this.refreshObjectsPage();
      }
    },

    updateContentVisibility(contentType) {
      if (contentType === 'monster') {
        this.updateMonstersVisibility();
      } else if (contentType === 'tableTresor') {
        this.updateTablesTresorsVisibility();
      } else {
        this.updateObjectVisibility();
      }
    },

    updateMonstersVisibility() {
      if (!window.MONSTRES_FILTER_STATE) return;
      
      const visibleTags = window.MONSTRES_FILTER_STATE.visibleTags;
      const allMonsterCards = document.querySelectorAll('#monstres-container .card');
      
      allMonsterCards.forEach(card => {
        const monsterName = card.dataset.monsterName || card.querySelector('[data-edit-section*="nom"]')?.textContent;
        if (!monsterName) return;
        
        // Trouver le monstre correspondant dans les donnÃ©es
        const monster = window.MONSTRES.find(m => m.nom === monsterName);
        if (!monster || !monster.tags) return;
        
        // En mode "ET" : le monstre doit avoir TOUS les tags visibles
        const shouldShow = visibleTags.length === 0 || 
                          visibleTags.every(tag => monster.tags.includes(tag));
        
        card.style.display = shouldShow ? '' : 'none';
      });
    },

    updateTablesTresorsVisibility() {
      if (!window.TABLES_TRESORS_FILTER_STATE) return;
      
      const visibleTags = window.TABLES_TRESORS_FILTER_STATE.visibleTags;
      const allTableCards = document.querySelectorAll('#tables-tresors-container .card');
      
      allTableCards.forEach(card => {
        const tableName = card.dataset.tableTresorName;
        if (!tableName) return;
        
        // Trouver la table correspondante dans les donnÃ©es
        const table = window.TABLES_TRESORS?.tables?.find(t => t.nom === tableName);
        if (!table || !table.tags) return;
        
        // En mode "OR" : la table doit avoir AU MOINS UN des tags visibles
        const shouldShow = visibleTags.length === 0 || 
                          visibleTags.some(tag => table.tags.includes(tag));
        
        card.style.display = shouldShow ? '' : 'none';
      });
    },

    // Update object visibility based on current filter settings
    updateObjectVisibility() {
      const allObjects = document.querySelectorAll('.card[data-objet-name]');
      const visibleTags = window.OBJETS.filterSettings?.visibleTags || [];
      
      allObjects.forEach(card => {
        const objetName = card.dataset.objetName;
        const objet = window.OBJETS.objets?.find(o => o.nom === objetName);
        
        if (objet && objet.tags) {
          // Check if object should be visible based on current filter settings
          const hasVisibleTag = objet.tags.some(tag => visibleTags.includes(tag));
          
          // Apply same logic as PageBuilder for "DÃ©part" tag requirement
          const isMJMode = window.JdrApp?.state?.isMJ || false;
          const isDevMode = window.JdrApp?.utils?.isDevMode?.() || false;
          const bypassDepartRequirement = isMJMode || isDevMode || window.activeIdSearch;
          
          let shouldShow = hasVisibleTag && visibleTags.length > 0;
          
          // CONDITION OBLIGATOIRE : L'objet doit avoir le tag "DÃ©part" pour Ãªtre visible
          // SAUF si mode MJ activÃ©, dev mode activÃ©, ou recherche par ID active
          if (shouldShow && !bypassDepartRequirement) {
            const hasDepartTag = objet.tags.includes('DÃ©part');
            if (!hasDepartTag) {
              shouldShow = false;
            }
          }
          
          if (shouldShow) {
            card.style.display = '';
          } else {
            card.style.display = 'none';
          }
        }
      });
      
      // Update filter count display if it exists
      const filterCount = document.querySelector('.filter-count');
      if (filterCount) {
        const visibleCount = Array.from(allObjects).filter(card => card.style.display !== 'none').length;
        filterCount.textContent = `${visibleCount} objet(s) affichÃ©(s)`;
      }
    },

    // Select all tags
    selectAllTags() {
      if (!window.OBJETS.filterSettings) {
        window.OBJETS.filterSettings = { visibleTags: [] };
      }

      // Get all available tags and set them as visible
      const availableTags = window.ContentTypes.objet.filterConfig.availableTags || [];
      window.OBJETS.filterSettings.visibleTags = [...availableTags];

      // Reset regeneration flag since we're doing a full reset
      this._needsRegenerationAfterEmpty = false;

      // Save changes to storage
      EventBus.emit(Events.STORAGE_SAVE);
      
      // Regenerate the objects page to reflect changes
      this.refreshObjectsPage();
    },

    // Select no tags (allow having no tags active)
    selectNoTags() {
      if (!window.OBJETS.filterSettings) {
        window.OBJETS.filterSettings = { visibleTags: [] };
      }

      // Clear all visible tags
      window.OBJETS.filterSettings.visibleTags = [];

      // Reset regeneration flag since we're starting fresh
      this._needsRegenerationAfterEmpty = false;

      // Save changes to storage
      EventBus.emit(Events.STORAGE_SAVE);
      
      // Regenerate the objects page to reflect changes
      this.refreshObjectsPage();
    },

    // Refresh the objects page after filter changes
    refreshObjectsPage() {
      // Clean up active tags that are not in displayed buttons
      this.cleanupActiveFilters();
      
      // Don't regenerate if an ID search is active
      if (window.activeIdSearch) {
        // Just show notification, keep current display
        const tagCount = window.OBJETS.filterSettings?.visibleTags?.length || 0;
        this.showNotification(`ğŸ·ï¸ Filtres mis Ã  jour (${tagCount} tag${tagCount > 1 ? 's' : ''} actif${tagCount > 1 ? 's' : ''}) - Recherche par ID active`, 'success');
        return;
      }

      // Regenerate and update the objects page
      if (JdrApp.modules.renderer?.regenerateCurrentPage) {
        JdrApp.modules.renderer.regenerateCurrentPage();
      }
      
      // Show notification
      const tagCount = window.OBJETS.filterSettings?.visibleTags?.length || 0;
      this.showNotification(`ğŸ·ï¸ Filtres mis Ã  jour (${tagCount} tag${tagCount > 1 ? 's' : ''} actif${tagCount > 1 ? 's' : ''})`, 'success');
    },

    // Clean up active filters to ensure only displayed buttons can be active
    cleanupActiveFilters() {
      if (!window.OBJETS?.filterSettings) return;
      
      const displayedButtons = window.OBJETS.filterSettings.displayedFilterButtons || [];
      const activeFilters = window.OBJETS.filterSettings.visibleTags || [];
      
      // Remove any active filters that are not in displayed buttons
      const cleanedActiveFilters = activeFilters.filter(tag => displayedButtons.includes(tag));
      
      // Update if something was cleaned
      if (cleanedActiveFilters.length !== activeFilters.length) {
        window.OBJETS.filterSettings.visibleTags = cleanedActiveFilters;
        const removedCount = activeFilters.length - cleanedActiveFilters.length;
      }
    },

    // ========================================
    // UTILITY METHODS
    // ========================================

    // CrÃ©er une modale simple
    createModal(title, content) {
      // CrÃ©er le overlay de la modale
      const overlay = document.createElement('div');
      overlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10000;
      `;

      // CrÃ©er la modale
      const modal = document.createElement('div');
      modal.style.cssText = `
        background: var(--parchment, #f4f1e8);
        border: 2px solid var(--bronze, #8b5c17);
        border-radius: 8px;
        padding: 1.5rem;
        max-width: 500px;
        width: 90%;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      `;

      modal.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; border-bottom: 1px solid var(--bronze); padding-bottom: 0.5rem;">
          <h3 style="margin: 0; color: var(--bronze);">${title}</h3>
          <button type="button" style="background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--bronze);" title="Fermer">âœ•</button>
        </div>
        <div>${content}</div>
      `;

      overlay.appendChild(modal);

      // MÃ©thode pour fermer la modale
      overlay.close = () => {
        document.body.removeChild(overlay);
      };

      // Gestionnaires d'Ã©vÃ©nements pour fermer
      const closeBtn = modal.querySelector('button');
      closeBtn.addEventListener('click', overlay.close);

      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          overlay.close();
        }
      });

      // Ajouter au DOM
      document.body.appendChild(overlay);

      return overlay;
    },

    // ========================================
    // TABLES DE TRÃ‰SORS - GESTION DES FOURCHETTES
    // ========================================

    // Ã‰diter une fourchette existante
    editFourchette(tableName, fourchetteIndex) {
      const table = this.findTableTresor(tableName);
      if (!table || !table.fourchettes || fourchetteIndex >= table.fourchettes.length) {
        this.showNotification('Table ou fourchette introuvable', 'error');
        return;
      }

      const fourchette = table.fourchettes[fourchetteIndex];
      this.showFourchetteModal(tableName, fourchetteIndex, fourchette);
    },

    // Supprimer une fourchette
    deleteFourchette(tableName, fourchetteIndex) {
      const table = this.findTableTresor(tableName);
      if (!table || !table.fourchettes || fourchetteIndex >= table.fourchettes.length) {
        this.showNotification('Table ou fourchette introuvable', 'error');
        return;
      }

      // Supprimer la fourchette
      table.fourchettes.splice(fourchetteIndex, 1);

      // Sauvegarder les changements
      EventBus.emit(Events.STORAGE_SAVE);

      // Supprimer la fourchette du DOM et rÃ©indexer
      this.removeFourchetteFromDOM(tableName, fourchetteIndex);

      this.showNotification('Fourchette supprimÃ©e', 'success');
    },

    // Ajouter une nouvelle fourchette
    addFourchette(tableName) {
      const table = this.findTableTresor(tableName);
      if (!table) {
        this.showNotification('Table introuvable', 'error');
        return;
      }

      // Calculer les valeurs par dÃ©faut pour la nouvelle fourchette
      const lastFourchette = table.fourchettes?.[table.fourchettes.length - 1];
      const nextMin = lastFourchette ? lastFourchette.max + 1 : 1;
      const nextMax = nextMin + 4; // Fourchette de 5 valeurs par dÃ©faut

      const newFourchette = {
        min: nextMin,
        max: nextMax,
        objet: {
          type: "reference",
          numero: 1,
          nom: "Nouvel objet"
        }
      };

      // Ajouter la nouvelle fourchette
      if (!table.fourchettes) {
        table.fourchettes = [];
      }
      table.fourchettes.push(newFourchette);

      // Ouvrir immÃ©diatement le modal d'Ã©dition
      const newIndex = table.fourchettes.length - 1;
      this.showFourchetteModal(tableName, newIndex, newFourchette);
    },

    // Trouver une table de trÃ©sor par nom
    findTableTresor(tableName) {
      return window.TABLES_TRESORS?.tables?.find(table => table.nom === tableName);
    },

    // Afficher le modal d'Ã©dition d'une fourchette
    showFourchetteModal(tableName, fourchetteIndex, fourchette) {
      const modal = this.createModal('Ã‰diter la fourchette', `
        <form id="fourchette-edit-form" style="display: flex; flex-direction: column; gap: 1rem;">
          <div style="display: flex; gap: 1rem;">
            <div style="flex: 1;">
              <label for="fourchette-min" style="display: block; margin-bottom: 0.25rem; font-weight: 600;">ğŸ² Valeur minimum:</label>
              <input type="number" id="fourchette-min" value="${fourchette.min}" min="1" style="width: 100%; padding: 0.5rem; border: 1px solid var(--bronze); border-radius: 4px;">
            </div>
            <div style="flex: 1;">
              <label for="fourchette-max" style="display: block; margin-bottom: 0.25rem; font-weight: 600;">ğŸ² Valeur maximum:</label>
              <input type="number" id="fourchette-max" value="${fourchette.max}" min="1" style="width: 100%; padding: 0.5rem; border: 1px solid var(--bronze); border-radius: 4px;">
            </div>
          </div>
          
          <div>
            <label style="display: block; margin-bottom: 0.25rem; font-weight: 600;">ğŸ“¦ Objet sÃ©lectionnÃ©:</label>
            <div id="selected-object-display" style="padding: 0.75rem; border: 1px solid var(--bronze); border-radius: 4px; background: #f9f9f9; margin-bottom: 0.5rem; min-height: 2rem; display: flex; align-items: center; justify-content: space-between;">
              <span id="selected-object-text" style="flex: 1;">
                ${fourchette.objet?.nom ? `ğŸ“¦ ${fourchette.objet.nom} (NÂ°${fourchette.objet.numero})` : 'Aucun objet sÃ©lectionnÃ©'}
              </span>
              ${fourchette.objet?.nom ? `<button type="button" id="clear-object-selection" style="background: #dc2626; color: white; border: none; border-radius: 3px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;" title="Effacer la sÃ©lection">âœ•</button>` : ''}
            </div>
            <button type="button" id="select-object-btn" style="width: 100%; background: var(--accent); color: white; padding: 0.75rem; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">
              ğŸ” SÃ©lectionner un objet
            </button>
            <input type="hidden" id="fourchette-objet-numero" value="${fourchette.objet?.numero || ''}">
            <input type="hidden" id="fourchette-objet-nom" value="${fourchette.objet?.nom || ''}">
          </div>
          
          <div style="display: flex; gap: 0.5rem; margin-top: 1rem;">
            <button type="submit" style="flex: 1; background: var(--accent); color: white; padding: 0.75rem; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">
              âœ… Sauvegarder
            </button>
            <button type="button" id="cancel-fourchette-edit" style="flex: 1; background: #666; color: white; padding: 0.75rem; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">
              âŒ Annuler
            </button>
          </div>
        </form>
      `);

      // Gestionnaire de soumission
      const form = modal.querySelector('#fourchette-edit-form');
      form.addEventListener('submit', (e) => {
        e.preventDefault();
        this.saveFourchette(tableName, fourchetteIndex, modal);
      });

      // Gestionnaire d'annulation
      modal.querySelector('#cancel-fourchette-edit').addEventListener('click', () => {
        modal.close();
      });

      // Gestionnaire de sÃ©lection d'objet
      modal.querySelector('#select-object-btn').addEventListener('click', () => {
        this.showObjectSelectionModal(modal);
      });

      // Gestionnaire d'effacement de sÃ©lection (si prÃ©sent)
      const clearBtn = modal.querySelector('#clear-object-selection');
      if (clearBtn) {
        clearBtn.addEventListener('click', () => {
          this.clearObjectSelection(modal);
        });
      }
    },

    // Sauvegarder les modifications d'une fourchette
    saveFourchette(tableName, fourchetteIndex, modal) {
      const table = this.findTableTresor(tableName);
      if (!table) {
        this.showNotification('Table introuvable', 'error');
        return;
      }

      // RÃ©cupÃ©rer les valeurs du formulaire
      const minValue = parseInt(modal.querySelector('#fourchette-min').value);
      const maxValue = parseInt(modal.querySelector('#fourchette-max').value);
      const objetNumero = parseInt(modal.querySelector('#fourchette-objet-numero').value);
      const objetNom = modal.querySelector('#fourchette-objet-nom').value.trim();

      // Validation
      if (minValue <= 0 || maxValue <= 0 || minValue > maxValue) {
        this.showNotification('Les valeurs min/max doivent Ãªtre positives et min â‰¤ max', 'error');
        return;
      }

      if (!objetNumero || !objetNom) {
        this.showNotification('Veuillez sÃ©lectionner un objet', 'error');
        return;
      }

      // Mettre Ã  jour la fourchette
      const updatedFourchette = {
        min: minValue,
        max: maxValue,
        objet: {
          type: "reference",
          numero: objetNumero,
          nom: objetNom
        }
      };

      table.fourchettes[fourchetteIndex] = updatedFourchette;

      // Sauvegarder les changements
      EventBus.emit(Events.STORAGE_SAVE);

      // Fermer le modal
      modal.close();

      // Mettre Ã  jour immÃ©diatement l'affichage de la fourchette modifiÃ©e
      this.updateFourchetteDisplay(tableName, fourchetteIndex, updatedFourchette);

      this.showNotification('Fourchette mise Ã  jour', 'success');
    },

    // Afficher la prÃ©visualisation d'un objet
    showObjectPreview(objetNumero) {
      // Trouver l'objet par son numÃ©ro
      const objet = this.findObjetByNumero(objetNumero);
      
      if (!objet) {
        this.showNotification(`Objet NÂ°${objetNumero} introuvable`, 'error');
        return;
      }

      // Construire l'affichage des tags
      const tagsDisplay = objet.tags && objet.tags.length > 0 
        ? objet.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';

      // CrÃ©er le contenu de la prÃ©visualisation
      const previewContent = `
        <div style="text-align: center; margin-bottom: 1rem;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin: 0.5rem 0; font-size: 0.9em; color: var(--bronze);">
            <div style="font-weight: bold;">NÂ°${objet.numero}</div>
            <div style="flex: 1; text-align: right;">
              ${tagsDisplay}
            </div>
          </div>
        </div>
        
        <div style="margin: 1rem 0; text-align: center; font-style: italic;">
          ${objet.description}
        </div>
        
        <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
        
        <div style="margin: 1rem 0;">
          ${objet.effet}
        </div>
        
        <div style="display: flex; justify-content: space-between; gap: 1rem; margin: 1rem 0; font-size: 0.9em;">
          <div style="flex: 1;">
            ${objet.prix}
          </div>
          <div style="flex: 1;">
            ${objet.poids}
          </div>
        </div>
      `;

      // Afficher la modal de prÃ©visualisation
      const modal = this.createModal(`ğŸ“¦ ${objet.nom}`, previewContent);

      // Ajouter un bouton pour aller Ã  la page de l'objet si dÃ©sirÃ©
      const modalContent = modal.querySelector('div:last-child');
      modalContent.insertAdjacentHTML('beforeend', `
        <div style="text-align: center; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--rule);">
          <button type="button" onclick="window.location.hash = '#/objets'; this.closest('.modal-overlay, [style*=fixed]').remove();" 
                  style="background: var(--accent); color: white; padding: 0.5rem 1rem; border: none; border-radius: 4px; cursor: pointer;">
            ğŸ”— Voir tous les objets
          </button>
        </div>
      `);
    },

    // Trouver un objet par son numÃ©ro
    findObjetByNumero(numero) {
      if (!window.OBJETS || !window.OBJETS.objets) {
        return null;
      }
      
      return window.OBJETS.objets.find(objet => objet.numero === numero);
    },

    // Afficher la modal de sÃ©lection d'objets
    showObjectSelectionModal(parentModal) {
      const objets = window.OBJETS?.objets || [];
      
      if (objets.length === 0) {
        this.showNotification('Aucun objet disponible', 'error');
        return;
      }

      const selectionContent = `
        <div style="margin-bottom: 1rem;">
          <label for="object-search" style="display: block; margin-bottom: 0.5rem; font-weight: 600;">ğŸ” Rechercher un objet:</label>
          <input type="text" id="object-search" placeholder="Tapez le nom ou numÃ©ro d'un objet..." 
                 style="width: 100%; padding: 0.75rem; border: 1px solid var(--bronze); border-radius: 4px; font-size: 1rem;">
        </div>
        
        <div style="margin-bottom: 1rem; color: var(--bronze); font-size: 0.9em;">
          <span id="object-count">${objets.length} objet(s) disponible(s)</span>
        </div>
        
        <div id="objects-list" style="max-height: 400px; overflow-y: auto; border: 1px solid var(--bronze); border-radius: 4px;">
          ${this.generateObjectsList(objets)}
        </div>
        
        <div style="text-align: center; margin-top: 1rem;">
          <button type="button" id="cancel-object-selection" style="background: #666; color: white; padding: 0.75rem 1.5rem; border: none; border-radius: 4px; font-weight: 600; cursor: pointer;">
            âŒ Annuler
          </button>
        </div>
      `;

      const selectionModal = this.createModal('ğŸ“¦ SÃ©lectionner un objet', selectionContent);
      
      // RÃ©fÃ©rence au modal parent pour pouvoir le mettre Ã  jour
      selectionModal._parentModal = parentModal;

      // Gestionnaire de recherche
      const searchInput = selectionModal.querySelector('#object-search');
      const objectsList = selectionModal.querySelector('#objects-list');
      const objectCount = selectionModal.querySelector('#object-count');
      
      let searchTimeout;
      searchInput.addEventListener('input', () => {
        clearTimeout(searchTimeout);
        searchTimeout = setTimeout(() => {
          const query = searchInput.value.toLowerCase().trim();
          const filteredObjets = this.filterObjects(objets, query);
          objectsList.innerHTML = this.generateObjectsList(filteredObjets);
          objectCount.textContent = `${filteredObjets.length} objet(s) trouvÃ©(s)`;
          
          // RÃ©attacher les gestionnaires de clic
          this.attachObjectClickHandlers(selectionModal);
        }, 300);
      });

      // Gestionnaire d'annulation
      selectionModal.querySelector('#cancel-object-selection').addEventListener('click', () => {
        selectionModal.close();
      });

      // Attacher les gestionnaires de clic aux objets
      this.attachObjectClickHandlers(selectionModal);

      // Focus sur le champ de recherche
      setTimeout(() => {
        searchInput.focus();
      }, 100);
    },

    // GÃ©nÃ©rer la liste HTML des objets
    generateObjectsList(objets) {
      if (objets.length === 0) {
        return '<div style="padding: 2rem; text-align: center; color: #666; font-style: italic;">Aucun objet trouvÃ©</div>';
      }

      return objets.map(objet => {
        const tagsDisplay = objet.tags && objet.tags.length > 0 
          ? objet.tags.slice(0, 3).map(tag => `<span style="background: var(--bronze); color: white; padding: 1px 4px; border-radius: 3px; font-size: 0.7em; margin-left: 4px;">${tag}</span>`).join('')
          : '';

        return `
          <div class="object-selection-item" data-object-numero="${objet.numero}" data-object-nom="${objet.nom}" 
               style="padding: 0.75rem; border-bottom: 1px solid #ddd; cursor: pointer; transition: background 0.2s;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
              <div style="flex: 1;">
                <div style="font-weight: 600; color: var(--bronze);">
                  ğŸ“¦ ${objet.nom}
                </div>
                <div style="font-size: 0.9em; color: #666; margin-top: 2px;">
                  NÂ°${objet.numero} â€¢ ${objet.description.substring(0, 60)}${objet.description.length > 60 ? '...' : ''}
                </div>
              </div>
              <div style="text-align: right;">
                ${tagsDisplay}
              </div>
            </div>
          </div>
        `;
      }).join('');
    },

    // Filtrer les objets selon la recherche
    filterObjects(objets, query) {
      if (!query) return objets;

      return objets.filter(objet => {
        return (
          objet.nom.toLowerCase().includes(query) ||
          objet.description.toLowerCase().includes(query) ||
          objet.numero.toString().includes(query) ||
          (objet.tags && objet.tags.some(tag => tag.toLowerCase().includes(query)))
        );
      });
    },

    // Attacher les gestionnaires de clic aux objets
    attachObjectClickHandlers(selectionModal) {
      const objectItems = selectionModal.querySelectorAll('.object-selection-item');
      
      objectItems.forEach(item => {
        // Style au survol
        item.addEventListener('mouseenter', () => {
          item.style.backgroundColor = 'rgba(139, 92, 23, 0.1)';
        });
        
        item.addEventListener('mouseleave', () => {
          item.style.backgroundColor = '';
        });

        // Clic pour sÃ©lectionner
        item.addEventListener('click', () => {
          const numero = parseInt(item.dataset.objectNumero);
          const nom = item.dataset.objectNom;
          
          this.selectObject(selectionModal._parentModal, numero, nom);
          selectionModal.close();
        });
      });
    },

    // SÃ©lectionner un objet et mettre Ã  jour le modal parent
    selectObject(parentModal, numero, nom) {
      const numeroInput = parentModal.querySelector('#fourchette-objet-numero');
      const nomInput = parentModal.querySelector('#fourchette-objet-nom');
      const displayText = parentModal.querySelector('#selected-object-text');
      const displayContainer = parentModal.querySelector('#selected-object-display');

      numeroInput.value = numero;
      nomInput.value = nom;
      displayText.textContent = `ğŸ“¦ ${nom} (NÂ°${numero})`;
      
      // Ajouter le bouton d'effacement s'il n'existe pas
      if (!parentModal.querySelector('#clear-object-selection')) {
        displayContainer.insertAdjacentHTML('beforeend', `
          <button type="button" id="clear-object-selection" style="background: #dc2626; color: white; border: none; border-radius: 3px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;" title="Effacer la sÃ©lection">âœ•</button>
        `);
        
        // Attacher le gestionnaire au nouveau bouton
        parentModal.querySelector('#clear-object-selection').addEventListener('click', () => {
          this.clearObjectSelection(parentModal);
        });
      }

      this.showNotification(`ğŸ“¦ "${nom}" sÃ©lectionnÃ©`, 'success');
    },

    // Effacer la sÃ©lection d'objet
    clearObjectSelection(parentModal) {
      const numeroInput = parentModal.querySelector('#fourchette-objet-numero');
      const nomInput = parentModal.querySelector('#fourchette-objet-nom');
      const displayText = parentModal.querySelector('#selected-object-text');
      const clearBtn = parentModal.querySelector('#clear-object-selection');

      numeroInput.value = '';
      nomInput.value = '';
      displayText.textContent = 'Aucun objet sÃ©lectionnÃ©';
      
      if (clearBtn) {
        clearBtn.remove();
      }

      this.showNotification('SÃ©lection effacÃ©e', 'info');
    },

    // Mettre Ã  jour l'affichage d'une fourchette spÃ©cifique sans recharger la page
    updateFourchetteDisplay(tableName, fourchetteIndex, updatedFourchette) {
      try {
        // Trouver la table et la fourchette dans le DOM
        const tableCard = document.querySelector(`[data-table-tresor-name="${tableName}"]`);
        if (!tableCard) {
          console.warn('Table non trouvÃ©e dans le DOM:', tableName);
          this.forcePageRefresh();
          return;
        }

        // Trouver toutes les fourchettes de cette table
        const fourchetteRows = tableCard.querySelectorAll('.fourchette-row');
        if (fourchetteIndex >= fourchetteRows.length) {
          console.warn('Index de fourchette invalide:', fourchetteIndex);
          this.forcePageRefresh();
          return;
        }

        const fourchetteRow = fourchetteRows[fourchetteIndex];
        
        // GÃ©nÃ©rer le nouveau contenu pour cette fourchette
        const objet = updatedFourchette.objet;
        const objetLink = objet?.type === 'reference' 
          ? `<a href="#" class="object-preview-link" data-object-numero="${objet.numero}" style="color: var(--accent); text-decoration: none;" title="Cliquer pour prÃ©visualiser l'objet #${objet.numero}">ğŸ“¦ ${objet.nom} (NÂ°${objet.numero})</a>`
          : `ğŸ“¦ ${objet?.nom || 'Objet inconnu'}`;

        // DÃ©terminer si on doit afficher les boutons d'Ã©dition
        const shouldShowButtons = this.shouldShowFourchetteButtons();
        const editButtons = shouldShowButtons ? `
          <div class="fourchette-actions" style="margin-left: 8px; display: flex; gap: 4px;">
            <button class="edit-fourchette-btn" data-table-name="${tableName}" data-fourchette-index="${fourchetteIndex}" title="Ã‰diter cette fourchette" style="background: #3b82f6; color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;">âœï¸</button>
            <button class="delete-fourchette-btn" data-table-name="${tableName}" data-fourchette-index="${fourchetteIndex}" title="Supprimer cette fourchette" style="background: #dc2626; color: white; border: none; border-radius: 4px; padding: 2px 6px; font-size: 0.8em; cursor: pointer;">ğŸ—‘ï¸</button>
          </div>
        ` : '';

        // Mettre Ã  jour le contenu de la fourchette
        fourchetteRow.innerHTML = `
          <div class="fourchette-range" style="font-weight: bold; color: var(--bronze); min-width: 80px;">
            ğŸ² ${updatedFourchette.min}-${updatedFourchette.max}
          </div>
          <div class="fourchette-objet" style="flex: 1; margin-left: 12px;">
            ${objetLink}
          </div>
          ${editButtons}
        `;

        console.log('Fourchette mise Ã  jour dans le DOM:', tableName, fourchetteIndex);
        
      } catch (error) {
        console.error('Erreur lors de la mise Ã  jour de la fourchette:', error);
        // En cas d'erreur, on revient au rechargement complet
        this.forcePageRefresh();
      }
    },

    // Supprimer une fourchette du DOM et rÃ©indexer les autres
    removeFourchetteFromDOM(tableName, fourchetteIndex) {
      try {
        const tableCard = document.querySelector(`[data-table-tresor-name="${tableName}"]`);
        if (!tableCard) {
          console.warn('Table non trouvÃ©e dans le DOM:', tableName);
          this.forcePageRefresh();
          return;
        }

        const fourchetteRows = tableCard.querySelectorAll('.fourchette-row');
        if (fourchetteIndex >= fourchetteRows.length) {
          console.warn('Index de fourchette invalide:', fourchetteIndex);
          this.forcePageRefresh();
          return;
        }

        // Supprimer l'Ã©lÃ©ment du DOM
        fourchetteRows[fourchetteIndex].remove();

        // RÃ©indexer toutes les fourchettes restantes pour les boutons d'Ã©dition
        const remainingRows = tableCard.querySelectorAll('.fourchette-row');
        remainingRows.forEach((row, newIndex) => {
          const editBtn = row.querySelector('.edit-fourchette-btn');
          const deleteBtn = row.querySelector('.delete-fourchette-btn');
          
          if (editBtn) editBtn.dataset.fourchetteIndex = newIndex;
          if (deleteBtn) deleteBtn.dataset.fourchetteIndex = newIndex;
        });

        console.log('Fourchette supprimÃ©e du DOM:', tableName, fourchetteIndex);
        
      } catch (error) {
        console.error('Erreur lors de la suppression de la fourchette:', error);
        this.forcePageRefresh();
      }
    },

    // VÃ©rifier si on doit afficher les boutons d'Ã©dition des fourchettes
    shouldShowFourchetteButtons() {
      // Reprendre la mÃªme logique que dans CardBuilder
      return JdrApp.utils.isDevMode() || 
             (!window.STANDALONE_VERSION && window.location.search.includes('dev=1')) ||
             (document.body.classList.contains('dev-on')) ||
             (window.location.protocol === 'file:' && !window.STANDALONE_VERSION) ||
             (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1');
    },

    showPageLinksModal() {
      let modal = JdrApp.utils.dom.$('#pageLinksModal');
      if (modal) {
        document.body.removeChild(modal);
      }
      
      modal = this.createPageLinksModal();
      document.body.appendChild(modal);
      
      this.openModal('pageLinksModal');
    },

    createPageLinksModal() {
      // Construire la liste des pages Ã  partir de la structure TOC
      const pages = [];
      
      if (window.TOC_STRUCTURE && window.TOC_STRUCTURE.sections) {
        window.TOC_STRUCTURE.sections.forEach(section => {
          if (section.items && Array.isArray(section.items)) {
            section.items.forEach(item => {
              if (item.type === 'page') {
                pages.push({
                  id: item.id,
                  title: item.title,
                  icon: item.icon,
                  section: section.title
                });
              } else if (item.type === 'category') {
                // Ajouter la page principale de catÃ©gorie
                pages.push({
                  id: item.id,
                  title: item.title,
                  icon: item.icon,
                  section: section.title
                });
                
                // Ajouter les sous-catÃ©gories si elles existent
                if (item.id === 'sorts' && window.SORTS) {
                  window.SORTS.forEach(category => {
                    pages.push({
                      id: `sorts-${category.nom}`,
                      title: `${category.nom} (sorts)`,
                      icon: 'ğŸ”®',
                      section: section.title
                    });
                  });
                } else if (item.id === 'dons' && window.DONS) {
                  window.DONS.forEach(category => {
                    pages.push({
                      id: `dons-${category.nom}`,
                      title: `${category.nom} (dons)`,
                      icon: 'ğŸ–ï¸',
                      section: section.title
                    });
                  });
                } else if (item.id === 'classes' && window.CLASSES) {
                  window.CLASSES.forEach(classe => {
                    pages.push({
                      id: classe.nom.toLowerCase(),
                      title: classe.nom,
                      icon: 'âš”ï¸',
                      section: section.title
                    });
                  });
                }
              }
            });
          }
        });
      }

      const pagesHTML = pages.map(page => `
        <div class="page-item" data-page-id="${page.id}">
          <div class="page-info">
            <div class="page-name">${page.icon} ${page.title}</div>
            <div class="page-section" style="color: var(--paper-muted); font-size: 12px;">${page.section}</div>
          </div>
          <div class="copy-indicator">CopiÃ©!</div>
        </div>
      `).join('');

      const modal = JdrApp.utils.dom.create('div', 'modal page-links-modal', `
        <div class="modal-content page-links-modal-content">
          <div style="position: relative;">
            <button class="modal-close-x" style="position: absolute; top: 0; right: 0; background: none; border: none; font-size: 20px; cursor: pointer; color: var(--paper-muted); padding: 4px 8px; border-radius: 4px; transition: all 0.2s ease;" onmouseover="this.style.background='var(--rule)'; this.style.color='var(--accent-ink)';" onmouseout="this.style.background='none'; this.style.color='var(--paper-muted)';">Ã—</button>
            <h3>ğŸ”— Liens vers les pages</h3>
          </div>
          <p>Cliquez sur une page pour copier un lien vers celle-ci.</p>
          <div class="pages-search">
            <input type="text" id="pageSearchInput" placeholder="Rechercher une page..." style="width: 100%; padding: 8px; margin-bottom: 12px; border: 1px solid var(--rule); border-radius: 4px;">
          </div>
          <div class="pages-list" style="max-height: 400px; overflow-y: auto;">
            ${pagesHTML || '<div style="text-align: center; color: #666; padding: 2rem;">Aucune page trouvÃ©e</div>'}
          </div>
          <button class="modal-close btn">Fermer</button>
        </div>
      `, { id: 'pageLinksModal' });

      // Recherche dans la modal
      const searchInput = modal.querySelector('#pageSearchInput');
      if (searchInput) {
        searchInput.addEventListener('input', (e) => {
          const searchTerm = e.target.value.toLowerCase();
          const pageItems = modal.querySelectorAll('.page-item');
          
          pageItems.forEach(item => {
            const pageName = item.querySelector('.page-name').textContent.toLowerCase();
            const pageSection = item.querySelector('.page-section').textContent.toLowerCase();
            
            if (pageName.includes(searchTerm) || pageSection.includes(searchTerm)) {
              item.style.display = '';
            } else {
              item.style.display = 'none';
            }
          });
        });
      }

      // Clic sur une page
      modal.addEventListener('click', (e) => {
        const pageItem = e.target.closest('.page-item');
        if (pageItem) {
          const pageId = pageItem.dataset.pageId;
          const pageTitle = pageItem.querySelector('.page-name').textContent.replace(/^[^\s]+ /, ''); // Enlever l'icÃ´ne
          
          // CrÃ©er le lien vers la page
          const pageLink = `<a href="#/${pageId}" style="color: var(--accent); text-decoration: underline;">${pageTitle}</a>`;
          
          this.copyToClipboard(pageLink);
          
          pageItem.classList.add('copied');
          
          // Fermer la modale aprÃ¨s un court dÃ©lai pour voir l'effet "CopiÃ©!"
          setTimeout(() => {
            this.closeModal(modal);
          }, 500);
        }
      });

      // Gestionnaire pour le bouton X de fermeture
      const closeBtn = modal.querySelector('.modal-close-x');
      if (closeBtn) {
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.closeModal(modal);
        });
      }

      return modal;
    },

    // Fonction d'impression des Ã©tats
    printStates() {
      // RÃ©cupÃ©rer tous les Ã©tats depuis les donnÃ©es chargÃ©es
      let etatsData;
      
      // Essayer plusieurs sources de donnÃ©es
      if (window.ETATS) {
        etatsData = window.ETATS;
      } else if (window.STATIC_PAGES?.etats) {
        etatsData = window.STATIC_PAGES.etats;
      } else {
        // Essayer de rÃ©cupÃ©rer depuis l'article actuellement affichÃ©
        const activeArticle = document.querySelector('article[data-page="etats"]');
        if (activeArticle) {
          const cards = activeArticle.querySelectorAll('.card');
          const states = Array.from(cards).map(card => {
            const title = card.querySelector('h3')?.textContent || 'Ã‰tat';
            const content = card.querySelector('.editable')?.innerHTML || '';
            return { title, content };
          });
          
          if (states.length > 0) {
            this.generatePrintableStates(states);
            return;
          }
        }
        
        console.error('DonnÃ©es des Ã©tats non trouvÃ©es');
        return;
      }

      // Filtrer seulement les sections de type "card" (les Ã©tats)
      const states = etatsData.sections ? 
        etatsData.sections.filter(section => section.type === 'card') :
        [];
      
      if (states.length === 0) {
        console.warn('Aucun Ã©tat trouvÃ© Ã  imprimer');
        return;
      }

      this.generatePrintableStates(states);
    },

    generatePrintableStates(states) {
      // Ouvrir une nouvelle fenÃªtre pour l'impression
      const printWindow = window.open('', '_blank', 'width=800,height=600');
      
      // CrÃ©er le HTML complet pour l'impression
      const printableHTML = `
        <!DOCTYPE html>
        <html>
        <head>
          <meta charset="UTF-8">
          <title>Ã‰tats - Aide de jeu</title>
          <style>
            @page { 
              margin: 15mm !important; 
              size: A4 !important;
            }
            body { 
              font-family: "Times New Roman", serif; 
              background: white; 
              color: black; 
              margin: 0; 
              padding: 0;
              font-size: 10pt;
              line-height: 1.2;
            }
            h1 { 
              font-size: 16pt; 
              font-weight: bold; 
              text-align: center; 
              margin-bottom: 8mm; 
              color: black;
            }
            .printable-states-grid { 
              display: grid; 
              grid-template-columns: 1fr 1fr; 
              gap: 4mm; 
              margin: 0;
            }
            .printable-state-item { 
              border: 1pt solid #ccc; 
              border-radius: 2mm; 
              padding: 3mm; 
              page-break-inside: avoid; 
              font-size: 9pt;
              line-height: 1.1;
              background: white;
            }
            .printable-state-item h3 { 
              font-size: 11pt; 
              font-weight: bold; 
              margin: 0 0 2mm 0; 
              color: black;
            }
            .printable-state-item p { 
              margin: 1mm 0; 
              color: black;
            }
          </style>
        </head>
        <body>
          <h1>Ã‰tats - Aide de jeu</h1>
          <div class="printable-states-grid">
            ${states.map(state => `
              <div class="printable-state-item">
                <h3>${state.title}</h3>
                <div>${this.stripHtmlTags(state.content)}</div>
              </div>
            `).join('')}
          </div>
        </body>
        </html>
      `;

      // Ã‰crire le contenu et imprimer
      printWindow.document.write(printableHTML);
      printWindow.document.close();
      
      // Attendre que le contenu soit chargÃ© puis imprimer
      printWindow.onload = function() {
        printWindow.focus();
        printWindow.print();
        printWindow.close();
      };
    },

    // Fonction utilitaire pour nettoyer les balises HTML pour l'impression
    stripHtmlTags(html) {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = html;
      
      // Convertir les listes en texte simple avec des tirets
      const lists = tempDiv.querySelectorAll('ul');
      lists.forEach(ul => {
        const items = ul.querySelectorAll('li');
        const textItems = Array.from(items).map(li => `â€¢ ${li.textContent.trim()}`);
        ul.outerHTML = textItems.join('<br>');
      });

      // PrÃ©server les paragraphes mais simplifier le formatage
      const paragraphs = tempDiv.querySelectorAll('p');
      paragraphs.forEach(p => {
        p.style.margin = '2px 0';
      });

      return tempDiv.innerHTML;
    },

    // MÃ©thode robuste pour forcer le rafraÃ®chissement de la page (fallback)
    forcePageRefresh() {
      setTimeout(() => {
        try {
          const currentHash = window.location.hash;
          const pageName = currentHash.replace('#/', '');
          
          if (JdrApp.modules.router && JdrApp.modules.router.show) {
            JdrApp.modules.router.show(pageName);
          } else if (JdrApp.modules.renderer && JdrApp.modules.renderer.regenerateCurrentPage) {
            JdrApp.modules.renderer.regenerateCurrentPage();
          } else {
            window.location.reload();
          }
        } catch (error) {
          console.error('Erreur lors du rafraÃ®chissement:', error);
          window.location.reload();
        }
      }, 100);
    },

    // ========================================
    // CAMPAIGN MANAGEMENT
    // ========================================

    addCampaign() {
      const campaignName = prompt("Nom de la nouvelle campagne:");
      if (!campaignName || !campaignName.trim()) return;
      
      // Initialize campaigns structure if needed
      if (!window.STATIC_PAGES.campagne) {
        window.STATIC_PAGES.campagne = {
          id: 'campagne',
          title: 'Campagne',
          sections: [],
          subPages: {}
        };
      }
      
      if (!window.STATIC_PAGES.campagne.subPages) {
        window.STATIC_PAGES.campagne.subPages = {};
      }
      
      const trimmedName = campaignName.trim();
      
      // Check if campaign already exists
      if (window.STATIC_PAGES.campagne.subPages[trimmedName]) {
        this.showNotification('âŒ Une campagne avec ce nom existe dÃ©jÃ ', 'error');
        return;
      }
      
      // Create new campaign
      window.STATIC_PAGES.campagne.subPages[trimmedName] = {
        name: trimmedName,
        description: "Description de la campagne",
        subPages: {}
      };
      
      // Save and refresh
      EventBus.emit(Events.STORAGE_SAVE);
      this.refreshCurrentPage();
      this.showNotification('ğŸ“– Campagne crÃ©Ã©e avec succÃ¨s', 'success');
    },

    deleteCampaign(campaignName) {
      if (!confirm(`Supprimer la campagne "${campaignName}" et toutes ses sous-pages ?`)) {
        return;
      }
      
      if (window.STATIC_PAGES.campagne && window.STATIC_PAGES.campagne.subPages) {
        delete window.STATIC_PAGES.campagne.subPages[campaignName];
        EventBus.emit(Events.STORAGE_SAVE);
        this.refreshCurrentPage();
        this.showNotification('ğŸ—‘ï¸ Campagne supprimÃ©e', 'success');
      }
    },

    addCampaignSubPage(campaignName) {
      const subPageName = prompt("Nom de la nouvelle sous-page:");
      if (!subPageName || !subPageName.trim()) return;
      
      const trimmedName = subPageName.trim();
      
      const campaign = window.STATIC_PAGES.campagne?.subPages?.[campaignName];
      if (!campaign) {
        this.showNotification('âŒ Campagne introuvable', 'error');
        return;
      }
      
      if (!campaign.subPages) {
        campaign.subPages = {};
      }
      
      // Check if sub-page already exists
      if (campaign.subPages[trimmedName]) {
        this.showNotification('âŒ Une sous-page avec ce nom existe dÃ©jÃ ', 'error');
        return;
      }
      
      // Create new sub-page
      campaign.subPages[trimmedName] = {
        title: trimmedName,
        content: "<p>Contenu de la sous-page...</p>"
      };
      
      // Save and refresh
      EventBus.emit(Events.STORAGE_SAVE);
      this.refreshCurrentPage();
      this.showNotification('ğŸ“„ Sous-page crÃ©Ã©e avec succÃ¨s', 'success');
    },

    editCampaignSubPage(campaignName, subPageName) {
      // This would open a modal or navigate to an edit view
      // For now, just show a notification that editing is available through inline editing
      this.showNotification('âœï¸ Vous pouvez Ã©diter le contenu directement en double-cliquant dessus', 'info');
    },

    deleteCampaignSubPage(campaignName, subPageName) {
      if (!confirm(`Supprimer la sous-page "${subPageName}" ?`)) {
        return;
      }
      
      const campaign = window.STATIC_PAGES.campagne?.subPages?.[campaignName];
      if (campaign && campaign.subPages) {
        delete campaign.subPages[subPageName];
        EventBus.emit(Events.STORAGE_SAVE);
        this.refreshCurrentPage();
        this.showNotification('ğŸ—‘ï¸ Sous-page supprimÃ©e', 'success');
      }
    },

    // Campaign and Sub-page Selection
    selectCampaign(campaignName) {
      if (!window.JdrApp.state) {
        window.JdrApp.state = {};
      }
      window.JdrApp.state.selectedCampaign = campaignName;
      window.JdrApp.state.selectedSubPage = null; // Reset sub-page selection
      this.refreshCurrentPage();
      this.showNotification(`ğŸ“– Campagne "${campaignName}" sÃ©lectionnÃ©e`, 'info');
    },

    selectSubPage(subPageName) {
      if (!window.JdrApp.state) {
        window.JdrApp.state = {};
      }
      window.JdrApp.state.selectedSubPage = subPageName;
      this.refreshCurrentPage();
      this.showNotification(`ğŸ“„ Sous-page "${subPageName}" sÃ©lectionnÃ©e`, 'info');
    }
  };

})();

</script>
</body>
</html>