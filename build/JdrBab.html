<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta name="referrer" content="no-referrer-when-downgrade">
<!-- Generated on 2025-08-22T10:51:07.938Z by JdrBab Build System -->
<title>JDRâ€‘BAB â€” Livret de rÃ¨gles</title>
<meta content="Livret web multipages des rÃ¨gles JDRâ€‘BAB, thÃ¨me parchemin, illustrations par catÃ©gorie/classe/sousâ€‘classe, export HTML autonome." name="description">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&amp;family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600&amp;display=swap" rel="stylesheet">
<style>
/* â€”â€” ThÃ¨me Heroic Fantasy - Enhanced Parchment â€”â€” */
:root{
  --paper:#f4f0e6;        /* parchemin ancien */
  --paper-ink:#2c1810;    /* encre noire profonde */
  --paper-muted:#8b6f47;  /* bronze ancien */
  --accent-ink:#4a2c17;   /* titres sombres */
  --rule:#d4c4a8;         /* bordures dorÃ©es */
  --card:#faf6ee;         /* cartes parchemin */
  --link:#8b4513;         /* liens cuivre */
  --gold:#d4af37;         /* or */
  --bronze:#cd7f32;       /* bronze */
  --shadow:0 8px 32px rgba(0,0,0,.15), 0 2px 8px rgba(139,69,19,.1);
  --card-shadow:0 6px 20px rgba(0,0,0,.1), 0 2px 6px rgba(139,69,19,.08);
  --image-border:3px solid #8b4513;
  --image-shadow:0 4px 12px rgba(0,0,0,.2), inset 0 1px 2px rgba(212,175,55,.3);
  
  /* Enhanced Parchment Textures */
  --parchment-texture: 
    radial-gradient(circle at 20% 80%, rgba(139,69,19,.03) 0%, transparent 50%),
    radial-gradient(circle at 80% 20%, rgba(212,175,55,.02) 0%, transparent 50%),
    radial-gradient(circle at 40% 40%, rgba(139,69,19,.01) 0%, transparent 30%),
    linear-gradient(45deg, rgba(139,69,19,.005) 25%, transparent 25%),
    linear-gradient(-45deg, rgba(212,175,55,.005) 25%, transparent 25%);
    
  --parchment-border:
    linear-gradient(45deg, 
      rgba(139,69,19,.8) 0%, 
      rgba(212,175,55,.6) 25%, 
      rgba(139,69,19,.4) 50%, 
      rgba(212,175,55,.6) 75%, 
      rgba(139,69,19,.8) 100%);
      
  --aged-paper: 
    radial-gradient(ellipse at top left, rgba(139,69,19,.04), transparent 60%),
    radial-gradient(ellipse at top right, rgba(212,175,55,.03), transparent 60%),
    radial-gradient(ellipse at bottom left, rgba(139,69,19,.02), transparent 60%),
    radial-gradient(ellipse at bottom right, rgba(212,175,55,.025), transparent 60%);
  
  /* Enhanced Element Colors System - Improved Contrast & Accessibility */
  --feu:#e63946; --feu-bg:rgba(230,57,70,.12); --feu-border:rgba(230,57,70,.4);
  --air:#457b9d; --air-bg:rgba(69,123,157,.12); --air-border:rgba(69,123,157,.4);
  --eau:#1d3557; --eau-bg:rgba(29,53,87,.12); --eau-border:rgba(29,53,87,.4);
  --terre:#6f4e37; --terre-bg:rgba(111,78,55,.12); --terre-border:rgba(111,78,55,.4);
  --divin:#f1c40f; --divin-bg:rgba(241,196,15,.12); --divin-border:rgba(241,196,15,.4);
  --malefique:#6a2c70; --malefique-bg:rgba(106,44,112,.12); --malefique-border:rgba(106,44,112,.4);
  
  /* Spacing system */
  --space-xs:4px; --space-sm:6px; --space-md:8px; --space-lg:12px; --space-xl:16px; --space-2xl:24px;
  
  /* Common transitions */
  --transition-fast:.2s ease; --transition-normal:.3s ease; --transition-slow:.5s ease;
}

/* Enhanced Accessibility & High Contrast Support */
@media (prefers-color-scheme: dark) { 
  :root{ 
    --paper:#f4f0e6; /* Keep light theme for fantasy aesthetic */
    --card:#faf6ee; 
    --paper-ink:#2c1810; 
  } 
}

@media (prefers-contrast: high) {
  :root {
    --paper-ink: #000000;
    --accent-ink: #1a0d08;
    --bronze: #8b4513;
    --gold: #b8860b;
    --rule: #8b4513;
  }
  
  .card, .card-base {
    border-width: 3px;
  }
  
  .btn-base {
    border-width: 3px;
  }
}

/* Base styles */
html,body{height:100%}
body{
  margin:0;
  background:
    radial-gradient(1600px 800px at 50% -10%, rgba(212,175,55,.08), transparent 45%),
    radial-gradient(1400px 700px at 120% 10%, rgba(139,69,19,.06), transparent 40%),
    radial-gradient(800px 400px at 20% 80%, rgba(205,127,50,.04), transparent 30%),
    repeating-linear-gradient(90deg, rgba(74,44,23,.02) 0 1px, transparent 1px 3px),
    repeating-linear-gradient(0deg, rgba(139,69,19,.015) 0 1px, transparent 1px 4px),
    var(--paper);
  color:var(--paper-ink); 
  font:17px/1.65 "Source Serif Pro", "Cinzel", ui-serif, Georgia, Cambria, "Times New Roman", Times, serif; 
  -webkit-font-smoothing:antialiased; 
  text-rendering:optimizeLegibility;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ¨ ENHANCED TYPOGRAPHY SYSTEM - Centered & Harmonized
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Link Styling */
a {
  color: var(--link);
  text-decoration: none;
  transition: all var(--transition-fast);
  position: relative;
}

a:hover {
  text-decoration: underline;
  color: var(--gold);
  text-shadow: 0 1px 3px rgba(212,175,55,0.3);
}

/* Text Emphasis */
strong, b {
  font-weight: 700;
  font-family: "Source Serif Pro", serif;
  color: var(--accent-ink);
  text-shadow: 0 1px 2px rgba(0,0,0,0.05);
}

em, i {
  font-style: italic;
  font-weight: 400;
  color: var(--bronze);
}

/* Enhanced Headings System */
h1, h2, h3, h4, h5, h6 {
  font-family: "Cinzel", "Trajan Pro", ui-serif, Georgia, Cambria, Times, serif;
  color: var(--accent-ink);
  text-shadow: 2px 2px 4px rgba(0,0,0,.1);
  text-align: center;
  margin: 1.5rem auto 1rem;
  position: relative;
  line-height: 1.2;
  letter-spacing: 0.02em;
}

/* Main Title */
h1 {
  font-size: clamp(28px, 4.5vw, 48px);
  letter-spacing: 0.05em;
  margin: 2rem auto 1.5rem;
  font-weight: 700;
  background: linear-gradient(135deg, var(--gold), var(--bronze), var(--gold));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  text-shadow: none;
  position: relative;
}

h1::before {
  content: 'â—†';
  position: absolute;
  left: -20px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--gold);
  font-size: 0.6em;
  opacity: 0.7;
}

h1::after {
  content: 'â—†';
  position: absolute;
  right: -20px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--gold);
  font-size: 0.6em;
  opacity: 0.7;
}

/* Section Headings */
h2 {
  font-size: clamp(22px, 3.2vw, 32px);
  margin: 1.8rem auto 1.2rem;
  font-weight: 600;
  color: var(--bronze);
  position: relative;
}

h2::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 80px;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--bronze), transparent);
  opacity: 0.8;
}

/* Subsection Headings */
h3 {
  font-size: clamp(18px, 2.4vw, 26px);
  margin: 1.5rem auto 1rem;
  font-weight: 500;
  color: var(--accent-ink);
  position: relative;
}

h3::before {
  content: 'â€»';
  position: absolute;
  left: -15px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--bronze);
  font-size: 0.8em;
  opacity: 0.6;
}

h3::after {
  content: 'â€»';
  position: absolute;
  right: -15px;
  top: 50%;
  transform: translateY(-50%);
  color: var(--bronze);
  font-size: 0.8em;
  opacity: 0.6;
}

/* Smaller Headings */
h4 {
  font-size: clamp(16px, 2vw, 20px);
  margin: 1.2rem auto 0.8rem;
  font-weight: 500;
  color: var(--paper-muted);
}

h5, h6 {
  font-size: clamp(14px, 1.8vw, 18px);
  margin: 1rem auto 0.6rem;
  font-weight: 500;
  color: var(--paper-muted);
}

/* Text Utilities */
.muted {
  color: var(--paper-muted);
  font-style: italic;
}

.lead {
  font-size: 18px;
  line-height: 1.6;
  text-align: center;
  margin: 1.5rem auto;
  color: var(--accent-ink);
  font-weight: 400;
}

/* Enhanced Separator Rule */
.rule {
  height: 3px;
  background: linear-gradient(90deg, 
    transparent, 
    var(--bronze), 
    var(--gold), 
    var(--bronze), 
    transparent);
  margin: 2rem auto;
  border-radius: 2px;
  opacity: 0.8;
  position: relative;
}

.rule::before {
  content: 'â‹';
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  background: var(--paper);
  color: var(--gold);
  padding: 0 8px;
  font-size: 14px;
}

/* Decorative Separators */
.separator-ornate {
  text-align: center;
  margin: 2.5rem auto;
  font-size: 1.5em;
  color: var(--gold);
  opacity: 0.7;
}

.separator-ornate::before {
  content: 'â—† â‹ â—†';
}

/* Centered Text Blocks */
.text-center {
  text-align: center;
}

.text-center-block {
  text-align: center;
  margin: 1.5rem auto;
  max-width: 800px;
}

/* Mobile Typography Adjustments */
@media (max-width: 480px) {
  h1::before, h1::after,
  h3::before, h3::after {
    display: none;
  }
  
  .rule::before {
    font-size: 12px;
    padding: 0 6px;
  }
  
  .lead {
    font-size: 16px;
    margin: 1rem auto;
  }
}
/* === UTILITY CLASSES === */

/* Spacing utilities */
.m-0{margin:0} .m-1{margin:var(--space-xs)} .m-2{margin:var(--space-md)} .m-3{margin:var(--space-lg)} .m-4{margin:var(--space-xl)}
.mt-0{margin-top:0} .mt-1{margin-top:var(--space-xs)} .mt-2{margin-top:var(--space-md)} .mt-3{margin-top:var(--space-lg)}
.mb-0{margin-bottom:0} .mb-1{margin-bottom:var(--space-xs)} .mb-2{margin-bottom:var(--space-md)} .mb-3{margin-bottom:var(--space-lg)}
.p-0{padding:0} .p-1{padding:var(--space-xs)} .p-2{padding:var(--space-md)} .p-3{padding:var(--space-lg)} .p-4{padding:var(--space-xl)}

/* Flex utilities */
.flex{display:flex} .flex-col{flex-direction:column} .flex-wrap{flex-wrap:wrap}
.items-center{align-items:center} .items-start{align-items:flex-start} .items-end{align-items:flex-end}
.justify-center{justify-content:center} .justify-start{justify-content:flex-start} .justify-end{justify-content:flex-end}
.gap-1{gap:var(--space-xs)} .gap-2{gap:var(--space-md)} .gap-3{gap:var(--space-lg)}

/* Element color utilities */
.text-feu{color:var(--feu)} .text-air{color:var(--air)} .text-eau{color:var(--eau)} .text-terre{color:var(--terre)} .text-divin{color:var(--divin)} .text-malefique{color:var(--malefique)}
.bg-feu{background:var(--feu-bg);border-color:var(--feu-border)} .bg-air{background:var(--air-bg);border-color:var(--air-border)}
.bg-eau{background:var(--eau-bg);border-color:var(--eau-border)} .bg-terre{background:var(--terre-bg);border-color:var(--terre-border)}
.bg-divin{background:var(--divin-bg);border-color:var(--divin-border)} .bg-malefique{background:var(--malefique-bg);border-color:var(--malefique-border)}

/* Grid utilities */
.grid{display:grid;gap:var(--space-lg)}
.cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}
.cols-3{grid-template-columns:repeat(3,minmax(0,1fr))}
@media (max-width: 900px){ .cols-3{grid-template-columns:1fr} }
@media (max-width: 768px){ .cols-2{grid-template-columns:1fr !important} }

/* Misc utilities */
.subclass-stack{display:flex;flex-direction:column;gap:var(--space-lg)}
.chip{font-size:14px;border:2px solid var(--rule);border-radius:999px;padding:6px 12px;background:rgba(155,107,47,.12);font-weight:600;box-shadow:0 2px 6px rgba(0,0,0,.1)}
.chips{display:flex;flex-wrap:wrap;gap:8px;justify-content:center}
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ—ï¸ LAYOUT SYSTEM - Enhanced Responsive Design
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Main Shell Layout */
.shell {
  display: grid;
  grid-template-rows: 1fr auto;
  min-height: 100svh;
  position: relative;
}

/* Main Content Area - Enhanced Parchment Background */
.page {
  position: relative;
  min-height: 100vh;
  padding: 18px 18px 18px 368px;
  transition: padding var(--transition-normal);
  background: 
    var(--parchment-texture),
    var(--aged-paper),
    var(--paper);
}

/* Content Container - Enhanced Centering */
#views {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 var(--space-lg);
  animation: fadeInUp 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

/* Mobile Responsiveness */
@media (max-width: 980px) { 
  .page {
    padding: 12px;
    background: var(--paper);
  }
  
  #views {
    padding: 0 var(--space-md);
    max-width: 100%;
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Enhanced Sidebar Navigation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.sidebar {
  position: fixed;
  top: 0;
  left: 0;
  width: 350px;
  height: 100vh;
  overflow-y: auto;
  overflow-x: hidden;
  z-index: 100;
  background: 
    var(--parchment-texture),
    linear-gradient(180deg, var(--paper), rgba(244,240,230,0.95)),
    var(--aged-paper);
  backdrop-filter: blur(8px);
  border-right: 4px solid transparent;
  border-image: var(--parchment-border) 1;
  box-shadow: 
    4px 0 20px rgba(0,0,0,0.08),
    inset -1px 0 0 rgba(212,175,55,0.1);
  transition: transform var(--transition-normal);
}

.sidebar::before {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  width: 2px;
  height: 100%;
  background: linear-gradient(180deg, 
    var(--gold) 0%, 
    var(--bronze) 50%, 
    var(--gold) 100%);
  opacity: 0.6;
}

/* Mobile Sidebar with Collapsible Navigation */
@media (max-width: 980px) { 
  .sidebar {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: auto;
    max-height: 80vh;
    background: 
      linear-gradient(135deg, var(--card), rgba(244,240,230,0.98)),
      radial-gradient(circle at 50% 30%, rgba(212,175,55,0.05), transparent 70%);
    border-right: none;
    border-bottom: 3px solid var(--rule);
    backdrop-filter: blur(8px);
    box-shadow: 
      0 8px 32px rgba(0,0,0,0.15),
      inset 0 -1px 0 rgba(212,175,55,0.1);
    transform: translateY(-100%);
    transition: transform var(--transition-normal);
    z-index: 200;
    overflow-y: auto;
  }
  
  .sidebar.mobile-open {
    transform: translateY(0);
  }
  
  /* Adjust page layout for mobile */
  .page {
    padding: 80px 12px 12px 12px; /* Top padding for mobile nav button */
  }
  
  .sidebar::before {
    display: none;
  }
  
  /* Mobile Navigation Toggle Button */
  .mobile-nav-toggle {
    position: fixed;
    top: 20px;
    left: 20px;
    z-index: 300;
    background: linear-gradient(135deg, var(--gold), var(--bronze));
    color: white;
    border: 2px solid var(--rule);
    border-radius: 12px;
    padding: 12px 16px;
    cursor: pointer;
    box-shadow: 
      0 6px 20px rgba(0,0,0,.15),
      inset 0 1px 0 rgba(255,255,255,.2);
    transition: all var(--transition-fast);
    font-family: 'Cinzel', serif;
    font-weight: 600;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 44px;
    min-height: 44px;
    justify-content: center;
  }
  
  .mobile-nav-toggle:hover {
    transform: scale(1.05);
    box-shadow: 
      0 8px 25px rgba(0,0,0,.2),
      inset 0 1px 0 rgba(255,255,255,.3);
  }
  
  .mobile-nav-toggle:active {
    transform: scale(0.98);
  }
  
  .mobile-nav-toggle .icon {
    font-size: 16px;
    transition: transform var(--transition-fast);
  }
  
  .mobile-nav-toggle.open .icon {
    transform: rotate(180deg);
  }
  
  /* Hide toggle on desktop */
  @media (min-width: 981px) {
    .mobile-nav-toggle {
      display: none;
    }
  }
}
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Enhanced Panel System â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.panel {
  background: 
    linear-gradient(135deg, var(--card), rgba(250,246,238,0.9)),
    radial-gradient(circle at 20% 30%, rgba(212,175,55,0.03), transparent 70%);
  border: 2px solid var(--rule);
  border-radius: 18px;
  box-shadow: 
    var(--card-shadow),
    inset 0 1px 0 rgba(255,255,255,0.1);
  padding: 18px;
  position: relative;
  overflow: hidden;
  margin: 12px;
  transition: all var(--transition-normal);
  backdrop-filter: blur(2px);
}

.panel::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 3px;
  background: linear-gradient(90deg, 
    transparent, 
    var(--gold), 
    var(--bronze), 
    var(--gold), 
    transparent);
  opacity: .6;
}

.panel::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 1px;
  background: linear-gradient(90deg, transparent, var(--bronze), transparent);
  opacity: .3;
}

.panel:hover {
  transform: translateY(-1px);
  box-shadow: 
    0 8px 32px rgba(0,0,0,.12),
    0 2px 8px rgba(139,69,19,.1),
    inset 0 1px 0 rgba(255,255,255,.15);
}

/* Table of Contents */
.toc {
  max-height: calc(100vh - 150px);
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-width: thin;
  scrollbar-color: var(--bronze) transparent;
}

.toc::-webkit-scrollbar {
  width: 6px;
}

.toc::-webkit-scrollbar-track {
  background: transparent;
}

.toc::-webkit-scrollbar-thumb {
  background: var(--bronze);
  border-radius: 3px;
}

.toc::-webkit-scrollbar-thumb:hover {
  background: var(--gold);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Enhanced TOC Styling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.toc h4 {
  margin: 8px 10px 12px;
  color: var(--bronze);
  text-transform: uppercase;
  font-size: 13px;
  letter-spacing: 0.15em;
  font-weight: 700;
  font-family: 'Cinzel', serif;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.05);
  position: relative;
  padding-bottom: 6px;
  text-align: center;
}

.toc h4::after {
  content: '';
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  height: 2px;
  background: linear-gradient(90deg, var(--bronze), transparent);
  border-radius: 1px;
}

/* Hierarchical TOC Sections */
.toc-section {
  margin-bottom: 8px;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid rgba(139,69,19,0.1);
  background: linear-gradient(135deg, 
    rgba(255,248,220,0.3) 0%, 
    rgba(212,175,55,0.05) 100%);
}

.toc-section-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 12px;
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.15) 0%, 
    rgba(139,69,19,0.08) 100%);
  cursor: pointer;
  transition: all var(--transition-normal);
  border-bottom: 1px solid rgba(139,69,19,0.1);
}

.toc-section-header:hover {
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.25) 0%, 
    rgba(139,69,19,0.15) 100%);
  transform: translateY(-1px);
}

.toc-section-title {
  font-weight: 600;
  font-family: 'Cinzel', serif;
  color: var(--bronze);
  font-size: 14px;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
}

.toc-section-toggle {
  color: var(--bronze);
  font-size: 12px;
  transition: transform var(--transition-normal);
  opacity: 0.7;
}

.toc-section.collapsed .toc-section-toggle {
  transform: rotate(-90deg);
}

.toc-section-content {
  padding: 6px;
  max-height: 500px;
  overflow: visible;
  transition: max-height var(--transition-normal), opacity var(--transition-normal);
}

.toc-section-content .toc-category {
  /* Remove scroll limits - let everything be visible naturally */
  max-height: none;
  overflow: visible;
}

.toc-section.collapsed .toc-section-content {
  max-height: 0 !important;
  opacity: 0 !important;
  padding-top: 0;
  padding-bottom: 0;
  overflow: hidden;
}
.toc a {
  display: flex;
  gap: 10px;
  padding: 10px 12px;
  border-radius: 12px;
  color: inherit;
  border: 2px solid transparent;
  transition: all var(--transition-normal);
  position: relative;
  overflow: hidden;
  font-weight: 500;
  margin: 2px 0;
  backdrop-filter: blur(1px);
}
.toc a::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, 
    transparent, 
    rgba(212,175,55,.2), 
    rgba(139,69,19,.1), 
    transparent);
  transition: left 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  z-index: 0;
}
.toc a:hover {
  transform: translateX(6px) scale(1.02);
  background: 
    linear-gradient(135deg, rgba(212,175,55,.12), rgba(139,69,19,.08));
  border-color: rgba(139,69,19,.4);
  box-shadow: 
    0 6px 20px rgba(139,69,19,.2),
    inset 0 1px 3px rgba(212,175,55,.25),
    inset 0 -1px 1px rgba(139,69,19,.1);
  color: var(--accent-ink);
}

.toc a:hover::before {
  left: 100%;
}
.toc a > *{position:relative; z-index:1}
.toc a.active {
  background: linear-gradient(135deg, 
    rgba(212,175,55,.18), 
    rgba(139,69,19,.12));
  border-color: var(--gold);
  box-shadow: 
    inset 0 2px 6px rgba(212,175,55,.3),
    inset 0 -1px 2px rgba(139,69,19,.2),
    0 2px 8px rgba(139,69,19,.1);
  transform: translateX(4px) scale(1.01);
  color: var(--accent-ink);
  font-weight: 600;
}
.toc-category{margin:0}
.toc-category > a{position:relative; cursor:pointer}
.toc-category > a::after{content:'â–¼'; position:absolute; right:8px; top:50%; transform:translateY(-50%); 
                         font-size:10px; transition:transform .3s ease; color:var(--bronze)}
.toc-category.collapsed > a::after{transform:translateY(-50%) rotate(-90deg)}
.toc-sub{margin-left:24px;border-left:2px solid var(--rule);padding-left:8px; 
         overflow:hidden; transition:all .3s ease}
.toc-category.collapsed .toc-sub{max-height:0; opacity:0; padding-top:0; padding-bottom:0; margin-top:0; margin-bottom:0}
.toc-category:not(.collapsed) .toc-sub{max-height: none; opacity:1}
.toc-sub a{font-size:14px;padding:6px 8px; margin-left:4px}
.toc-sub a:hover{transform:translateX(6px); margin-left:0}

/* Outils latÃ©raux */
.tools{display:flex;gap:var(--space-md);flex-wrap:wrap;margin:var(--space-md) 0}

/* Article and section layout */
article{display:none}
article.active{display:block}
section{background:var(--card);border:1px solid var(--rule);border-radius:14px;box-shadow:var(--shadow);padding:18px;margin:0 0 14px}

/* Footer */
footer{padding:24px;text-align:center;color:var(--paper-muted)}

/* Print styles */
@media print{ 
  .sidebar, .tools{display:none} 
  .page{grid-template-columns:1fr;padding:0} 
  section{break-inside:avoid;box-shadow:none} 
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Enhanced Mobile & Tablet Responsiveness â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* Tablet Landscape (1024px and below) */
@media (max-width: 1024px) {
  .sidebar {
    width: 320px;
  }
  
  .page {
    padding-left: 340px;
  }
  
  #views {
    max-width: 100%;
    padding: 0 var(--space-md);
  }
}

/* Tablet Portrait (768px and below) */
@media (max-width: 768px) {
  .illus .thumb { 
    width: 100%; 
    max-width: 280px; 
    height: auto; 
  }
  
  .card, .card-base {
    margin: 1rem 0;
    padding: 16px;
  }
  
  .btn-base {
    padding: var(--space-sm) var(--space-md);
    font-size: 0.9em;
  }
  
  .filter-chips {
    gap: 0.5rem;
  }
  
  .filter-chip {
    padding: 6px 12px;
    font-size: 0.85em;
  }
}

/* Mobile (480px and below) - Standalone Version Optimized */
@media (max-width: 480px) {
  .page {
    padding: 8px;
  }
  
  #views {
    padding: 0 var(--space-sm);
  }
  
  .panel {
    margin: 8px;
    padding: 12px;
    border-radius: 12px;
  }
  
  .card, .card-base {
    padding: 12px;
    margin: 0.8rem 0;
    border-radius: 12px;
  }
  
  .spell-title {
    font-size: clamp(1rem, 3vw, 1.2rem) !important;
    margin: 0 0 0.8rem 0 !important;
  }
  
  .btn-base {
    padding: var(--space-sm);
    font-size: 0.85em;
    gap: var(--space-sm);
  }
  
  .filter-chips {
    gap: 0.4rem;
  }
  
  .filter-chip {
    padding: 4px 8px;
    font-size: 0.8em;
    border-radius: 16px;
  }
  
  /* Mobile-optimized images */
  .illus img {
    max-width: 100% !important;
    width: auto !important;
    height: auto !important;
  }
  
  .illus-spell img,
  .card .illus img {
    max-width: 240px !important;
    max-height: 180px !important;
  }
  
  /* Mobile TOC enhancements */
  .toc a {
    padding: 8px 10px;
    font-size: 0.9em;
  }
  
  .toc-sub a {
    padding: 6px 8px;
    font-size: 0.85em;
  }
  
  /* Mobile search optimizations */
  .searchbar {
    flex-direction: column;
    gap: var(--space-sm);
  }
  
  .searchbar input {
    width: 100%;
    font-size: 16px; /* Prevents zoom on iOS */
  }
  
  .search-results-grid {
    grid-template-columns: 1fr;
    gap: var(--space-md);
  }
  
  .search-result-card {
    min-height: 120px;
    padding: var(--space-md);
  }
}
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ¨ COMPONENT SYSTEM - Modern Heroic Fantasy Design
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Typography Components â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.spell-title {
  font-family: "Cinzel", serif !important;
  font-size: clamp(1.2rem, 2.5vw, 1.4rem) !important;
  background: linear-gradient(135deg, var(--gold), var(--bronze), var(--gold)) !important;
  -webkit-background-clip: text !important;
  -webkit-text-fill-color: transparent !important;
  background-clip: text !important;
  font-weight: 600 !important;
  text-shadow: 0 2px 4px rgba(0,0,0,0.1) !important;
  letter-spacing: 0.8px !important;
  text-transform: uppercase !important;
  text-align: center !important;
  margin: 0 0 1rem 0 !important;
  position: relative !important;
}

.spell-title::after {
  content: '';
  position: absolute;
  bottom: -8px;
  left: 50%;
  transform: translateX(-50%);
  width: 60px;
  height: 2px;
  background: linear-gradient(90deg, transparent, var(--gold), transparent);
  opacity: 0.7;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Card System Enhanced - Authentic Parchment â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.card,
.card-base {
  background: 
    var(--parchment-texture),
    var(--aged-paper),
    var(--card);
  border: 3px solid transparent;
  border-image: var(--parchment-border) 1;
  border-radius: 16px;
  box-shadow: 
    0 8px 32px rgba(139,69,19,.2),
    0 2px 8px rgba(139,69,19,.15),
    inset 0 1px 0 rgba(255,255,255,.2),
    inset 0 -1px 0 rgba(139,69,19,.08);
  padding: 20px;
  position: relative;
  overflow: hidden;
  transition: all var(--transition-normal);
  backdrop-filter: blur(1px);
}

.card::before,
.card-base::before {
  content: '';
  position: absolute;
  top: 2px;
  left: 2px;
  right: 2px;
  bottom: 2px;
  border: 1px solid rgba(139,69,19,.15);
  border-radius: 13px;
  pointer-events: none;
}

.card::after,
.card-base::after {
  content: '';
  position: absolute;
  top: 4px;
  left: 4px;
  right: 4px;
  height: 2px;
  background: 
    radial-gradient(ellipse at center, rgba(212,175,55,.3) 0%, transparent 60%),
    linear-gradient(90deg, transparent, rgba(139,69,19,.2), transparent);
  opacity: .6;
}

.card:hover,
.card-base:hover {
  transform: translateY(-3px) scale(1.01);
  box-shadow: 
    0 16px 48px rgba(139,69,19,.25),
    0 6px 16px rgba(139,69,19,.18),
    inset 0 1px 0 rgba(255,255,255,.3),
    inset 0 -1px 0 rgba(139,69,19,.12);
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Button System Enhanced â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.btn-base {
  display: inline-flex;
  gap: var(--space-md);
  align-items: center;
  background: linear-gradient(135deg, var(--card), rgba(244,240,230,0.8));
  border: 2px solid var(--rule);
  border-radius: 12px;
  padding: var(--space-md) var(--space-lg);
  box-shadow: 
    0 4px 16px rgba(0,0,0,.08),
    0 2px 4px rgba(139,69,19,.1),
    inset 0 1px 0 rgba(255,255,255,.2);
  cursor: pointer;
  transition: all var(--transition-fast);
  font-weight: 500;
  font-family: "Source Serif Pro", serif;
  text-transform: capitalize;
  position: relative;
  overflow: hidden;
}

.btn-base::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(212,175,55,.15), transparent);
  transition: left var(--transition-normal);
}

.btn-base:hover {
  transform: translateY(-2px) scale(1.02);
  box-shadow: 
    0 8px 32px rgba(0,0,0,.15),
    0 4px 8px rgba(139,69,19,.12),
    inset 0 1px 0 rgba(255,255,255,.3);
  border-color: var(--bronze);
}

.btn-base:hover::before {
  left: 100%;
}

.btn-base:active {
  transform: translateY(-1px) scale(1.01);
  transition: all 0.1s ease;
}

.btn-small {
  padding: var(--space-sm) var(--space-md);
  font-size: 0.9em;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Card Variants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.card-enhanced {
  margin: 1.5rem 0;
  animation: cardEntry 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
}

.card.spell-card {
  border-left: 4px solid var(--feu);
  background: linear-gradient(135deg, var(--card), rgba(255,107,53,0.02));
}

.card.don-card {
  border-left: 4px solid var(--bronze);
  background: linear-gradient(135deg, var(--card), rgba(205,127,50,0.02));
}

.card.class-card {
  border-left: 4px solid var(--gold);
  background: linear-gradient(135deg, var(--card), rgba(212,175,55,0.02));
}

@keyframes cardEntry {
  0% {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Enhanced Tags & Filters â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
.tag-filters {
  margin: 1.5rem 0;
  padding: 1.5rem;
  background: 
    linear-gradient(135deg, var(--card), rgba(244,240,230,0.9)),
    radial-gradient(circle at 20% 50%, rgba(212,175,55,0.05), transparent),
    radial-gradient(circle at 80% 50%, rgba(139,69,19,0.03), transparent);
  border: 2px solid var(--rule);
  border-radius: 16px;
  box-shadow: 
    0 4px 20px rgba(0,0,0,.08),
    inset 0 1px 0 rgba(255,255,255,.1);
  position: relative;
  overflow: hidden;
}

.tag-filters::before {
  content: 'ğŸ·ï¸ Filtres';
  position: absolute;
  top: -1px;
  left: 20px;
  background: var(--card);
  padding: 4px 12px;
  font-size: 0.85em;
  font-weight: 600;
  color: var(--bronze);
  border: 2px solid var(--rule);
  border-top: none;
  border-radius: 0 0 8px 8px;
  font-family: "Cinzel", serif;
}

.filter-chips {
  display: flex;
  gap: 0.75rem;
  flex-wrap: wrap;
  margin-top: 0.5rem;
}

.filter-chip {
  padding: 8px 16px;
  background: linear-gradient(135deg, var(--bronze), rgba(205,127,50,0.9));
  color: white;
  border-radius: 20px;
  font-size: 0.9em;
  font-weight: 500;
  cursor: pointer;
  transition: all var(--transition-fast);
  border: 2px solid transparent;
  box-shadow: 
    0 2px 8px rgba(0,0,0,.1),
    inset 0 1px 0 rgba(255,255,255,.2);
  position: relative;
  overflow: hidden;
}

.filter-chip::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,.2), transparent);
  transition: left var(--transition-fast);
}

.filter-chip:hover {
  background: linear-gradient(135deg, var(--gold), rgba(212,175,55,0.9));
  transform: translateY(-2px) scale(1.05);
  box-shadow: 
    0 6px 20px rgba(0,0,0,.15),
    inset 0 1px 0 rgba(255,255,255,.3);
}

.filter-chip:hover::before {
  left: 100%;
}

.filter-chip.active {
  background: linear-gradient(135deg, var(--accent-ink), rgba(74,44,23,0.9));
  border-color: var(--gold);
  transform: scale(1.02);
  box-shadow: 
    0 4px 16px rgba(0,0,0,.2),
    inset 0 1px 0 rgba(255,255,255,.1);
}

.tag-chip {
  display: inline-block;
  padding: 2px 8px;
  background: var(--bronze);
  color: white;
  border-radius: 8px;
  font-size: 0.8em;
  font-weight: 500;
  margin: 2px;
}

/* Gestionnaire de filtres */
.filter-manager-btn {
  background: var(--bronze) !important;
  color: white !important;
}

.filter-manager-btn:hover {
  background: var(--accent) !important;
}

.modal-base{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.7);z-index:99999;display:none;align-items:center;justify-content:center}
.modal-base.visible{display:flex}
.modal-content-base{background:var(--card);border:2px solid var(--rule);border-radius:16px;padding:var(--space-2xl);box-shadow:var(--shadow);position:relative}

/* Legacy Cards - Enhanced with Modern Styling */
.card{
  border:2px solid var(--rule);
  border-radius:16px;
  padding:20px;
  background:linear-gradient(145deg, #faf7f0, var(--card), #f8f4e8);
  box-shadow:
    0 8px 32px rgba(0,0,0,.12),
    0 2px 8px rgba(139,69,19,.08),
    inset 0 1px 0 rgba(255,255,255,.1);
  position:relative;
  overflow:hidden;
  transition: all var(--transition-normal);
  backdrop-filter: blur(1px);
}

.card::before{
  content:'';
  position:absolute;
  top:0;
  left:0;
  right:0;
  height:3px;
  background:linear-gradient(90deg, transparent, var(--gold), var(--bronze), var(--gold), transparent);
  opacity:.8;
}

.card::after{
  content:'';
  position:absolute;
  bottom:0;
  left:0;
  right:0;
  height:1px;
  background:linear-gradient(90deg, transparent, var(--bronze), transparent);
  opacity:.5;
}

.card:hover {
  transform: translateY(-2px);
  box-shadow: 
    0 12px 48px rgba(0,0,0,.15),
    0 4px 12px rgba(139,69,19,.12),
    inset 0 1px 0 rgba(255,255,255,.15);
  border-color: var(--gold);
}
.card ul, ul{padding-left:35px !important;margin-left:0 !important}

/* Buttons */
.btn{display:inline-flex;gap:var(--space-md);align-items:center;background:var(--card);border:2px solid var(--rule);border-radius:12px;padding:var(--space-md) var(--space-lg);box-shadow:var(--card-shadow);cursor:pointer;
     transition:var(--transition-fast); font-weight:500}
.btn:hover{transform:translateY(-1px); box-shadow:0 8px 25px rgba(0,0,0,.15); border-color:var(--bronze)}
.btn.small{padding:var(--space-sm) var(--space-md)}

/* Search bar */
.searchbar{display:flex;gap:var(--space-md);align-items:center}
.searchbar input{flex:1 1 auto;max-width:100%;height:38px;font-size:15px;padding:var(--space-md) 10px;border-radius:10px;border:1px solid var(--rule);background:#fff6e8;color:inherit}
.searchbar button{height:38px}

/* Search results */
.search-results-container {
  font-size: 14px;
  line-height: 1.4;
}

.search-results-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: var(--gold);
  color: #4a4a4a;
  font-weight: 500;
  border-bottom: 1px solid var(--bronze);
}

.search-close {
  background: none;
  border: none;
  font-size: 16px;
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 4px;
  transition: background-color 0.2s;
}

.search-close:hover {
  background: rgba(0,0,0,0.1);
}

.search-results-list {
  max-height: 320px;
  overflow-y: auto;
}

.search-result-item {
  padding: 10px 12px;
  border-bottom: 1px solid #f0f0f0;
  cursor: pointer;
  transition: background-color 0.2s;
}

.search-result-item:hover {
  background: #f8f4e8;
}

.search-result-item:last-child {
  border-bottom: none;
}

.search-result-summary {
  font-weight: 500;
  color: #333;
  margin-bottom: 2px;
}

.search-result-category {
  font-size: 12px;
  color: #666;
  opacity: 0.8;
}

.search-no-results {
  padding: 20px;
  text-align: center;
  color: #666;
}

.search-no-results p {
  margin: 0;
  font-style: italic;
}

/* Search results page */
.search-page {
  padding: var(--space-lg);
}

.search-page-header {
  margin-bottom: var(--space-xl);
  text-align: center;
  border-bottom: 2px solid var(--rule);
  padding-bottom: var(--space-lg);
}

.search-page-header h1 {
  color: var(--gold);
  margin-bottom: var(--space-md);
  font-family: var(--font-title);
}

.search-results-count {
  color: #666;
  margin-bottom: var(--space-lg);
  font-style: italic;
}

.search-results-grid {
  display: grid;
  gap: var(--space-lg);
  max-width: 800px;
  margin: 0 auto;
  grid-template-columns: 1fr;
}

.search-result-card {
  cursor: pointer;
  transition: all 0.2s ease;
  border: 2px solid var(--rule);
  background: var(--card);
  padding: var(--space-lg);
  border-radius: 14px;
  box-shadow: var(--card-shadow);
  /* Force visibility */
  display: block !important;
  visibility: visible !important;
  opacity: 1 !important;
  min-height: 150px;
}

.search-result-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(0,0,0,0.15);
  border-color: var(--bronze);
}

.search-result-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: var(--space-md);
}

.search-result-header h3 {
  margin: 0;
  color: var(--bronze);
  font-size: 1.2em;
  text-align: center;
}

.search-result-type {
  background: var(--gold);
  color: #4a4a4a;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 0.8em;
  font-weight: 500;
}

.search-result-content {
  margin-bottom: var(--space-lg);
}

.search-result-summary {
  font-weight: 500;
  margin-bottom: var(--space-md);
  color: #333;
  font-size: 1.05em;
  padding: var(--space-sm);
  background: linear-gradient(90deg, var(--gold), transparent);
  border-radius: 4px;
  opacity: 0.9;
}

.search-result-category {
  font-size: 0.9em;
  color: #666;
  margin-bottom: var(--space-md);
}

.search-result-preview {
  background: #f8f4e8;
  padding: var(--space-md);
  border-radius: 8px;
  border-left: 3px solid var(--bronze);
}

.preview-field {
  margin-bottom: var(--space-sm);
  line-height: 1.4;
  font-size: 0.9em;
  padding: var(--space-sm);
  background: rgba(0,0,0,0.02);
  border-left: 3px solid var(--gold);
  border-radius: 0 4px 4px 0;
}

.preview-field:last-child {
  margin-bottom: 0;
}

.preview-field strong {
  color: var(--bronze);
  font-weight: 600;
}

.search-result-footer {
  text-align: right;
  padding-top: var(--space-md);
  border-top: 1px solid #eee;
}

.search-result-btn {
  background: var(--bronze);
  color: white;
  border-color: var(--bronze);
}

.search-result-btn:hover {
  background: #b8860b;
  border-color: #b8860b;
}

/* Force search results visibility */
.search-page .search-results-grid .search-result-card {
  display: block !important;
  visibility: visible !important;
  opacity: 1 !important;
  height: auto !important;
  min-height: 150px !important;
  background: var(--card) !important;
  border: 2px solid var(--bronze) !important;
  margin-bottom: var(--space-lg) !important;
}

/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Advanced Animations & Transitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

/* Page Transitions */
@keyframes pageSlideIn {
  0% {
    opacity: 0;
    transform: translateX(30px);
  }
  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes pageSlideInFromTop {
  0% {
    opacity: 0;
    transform: translateY(-20px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Content Animation */
article {
  animation: pageSlideIn 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

article.active {
  animation: pageSlideInFromTop 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

/* Staggered Entry Animation for Lists */
.staggered-entry > * {
  opacity: 0;
  animation: staggeredEntry 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
}

.staggered-entry > *:nth-child(1) { animation-delay: 0.1s; }
.staggered-entry > *:nth-child(2) { animation-delay: 0.2s; }
.staggered-entry > *:nth-child(3) { animation-delay: 0.3s; }
.staggered-entry > *:nth-child(4) { animation-delay: 0.4s; }
.staggered-entry > *:nth-child(5) { animation-delay: 0.5s; }
.staggered-entry > *:nth-child(n+6) { animation-delay: 0.6s; }

@keyframes staggeredEntry {
  0% {
    opacity: 0;
    transform: translateY(20px) scale(0.95);
  }
  100% {
    opacity: 1;
    transform: translateY(0) scale(1);
  }
}

/* Loading Animation */
@keyframes shimmer {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100%); }
}

.loading-shimmer {
  position: relative;
  overflow: hidden;
  background: linear-gradient(90deg, #f0f0f0, #e0e0e0, #f0f0f0);
  animation: shimmer 1.5s infinite linear;
}

.loading-shimmer::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
  animation: shimmer 1.5s infinite linear;
}

/* Floating Elements Animation */
@keyframes float {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-10px); }
}

.floating {
  animation: float 3s ease-in-out infinite;
}

.floating:nth-child(2n) {
  animation-delay: 1s;
}

.floating:nth-child(3n) {
  animation-delay: 2s;
}

/* Pulse Animation for Important Elements */
@keyframes pulse {
  0%, 100% { 
    transform: scale(1);
    box-shadow: 0 0 0 0 rgba(212, 175, 55, 0.4);
  }
  50% { 
    transform: scale(1.02);
    box-shadow: 0 0 0 10px rgba(212, 175, 55, 0);
  }
}

.pulse-attention {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Text Glow Effect */
@keyframes textGlow {
  0%, 100% {
    text-shadow: 
      0 0 5px rgba(212, 175, 55, 0.2),
      0 0 10px rgba(212, 175, 55, 0.1);
  }
  50% {
    text-shadow: 
      0 0 10px rgba(212, 175, 55, 0.4),
      0 0 20px rgba(212, 175, 55, 0.2),
      0 0 30px rgba(212, 175, 55, 0.1);
  }
}

.text-glow {
  animation: textGlow 3s ease-in-out infinite;
}

/* Enhanced Hover Transitions */
.interactive-element {
  transition: 
    transform var(--transition-fast),
    box-shadow var(--transition-fast),
    background-color var(--transition-fast),
    border-color var(--transition-fast),
    color var(--transition-fast);
}

.interactive-element:hover {
  transform: translateY(-2px) scale(1.02);
}

/* Magical Sparkle Effect */
@keyframes sparkle {
  0%, 100% { opacity: 0; transform: scale(0); }
  50% { opacity: 1; transform: scale(1); }
}

.sparkle-effect::before {
  content: 'âœ¨';
  position: absolute;
  top: -5px;
  right: -5px;
  font-size: 0.8em;
  animation: sparkle 2s ease-in-out infinite;
  animation-delay: 0.5s;
}

.sparkle-effect::after {
  content: 'â­';
  position: absolute;
  bottom: -5px;
  left: -5px;
  font-size: 0.6em;
  animation: sparkle 2s ease-in-out infinite;
  animation-delay: 1.5s;
}

/* Smooth Content Transitions */
.content-transition {
  transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

.content-fade-in {
  animation: fadeInUp 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
}

@keyframes fadeInUp {
  0% {
    opacity: 0;
    transform: translateY(30px);
  }
  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Clean up card styling */

/* Illustrations */
.illus{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap;margin:.6rem 0}
.illus img{max-width:100%;height:auto;border-radius:12px; transition:all .3s ease}
.illus img.enlarged{transition:none !important}
.illus .thumb{width:500px;height:300px;object-fit:contain}

/* Images avec cadres - systÃ¨me unifiÃ© */
.illus-spell, .illus-class, .illus-subclass, .illus-don,
article[data-page="guerrier"] .illus,
article[data-page="mage"] .illus,
article[data-page="pretre"] .illus,
article[data-page="rodeur"] .illus,
article[data-page="enchanteur"] .illus,
.illus[data-illus-key^="class:"],
.illus[data-illus-key^="subclass:"],
.illus[data-illus-key^="spell:"],
.illus[data-illus-key^="sort:"],
.illus[data-illus-key^="spellcategory:"],
.illus[data-illus-key^="don:"] {
  display:flex !important; flex-direction:column !important; align-items:center !important;
  justify-content:center !important; margin:1rem auto !important;
}

.illus-spell img, .illus-class img, .illus-subclass img, .illus-don img,
article[data-page="guerrier"] .illus img,
article[data-page="mage"] .illus img,
article[data-page="pretre"] .illus img,
article[data-page="rodeur"] .illus img,
article[data-page="enchanteur"] .illus img,
.illus[data-illus-key^="class:"] img,
.illus[data-illus-key^="subclass:"] img,
.illus[data-illus-key^="spell:"] img,
.illus[data-illus-key^="sort:"] img,
.illus[data-illus-key^="spellcategory:"] img,
.illus[data-illus-key^="don:"] img {
  border:var(--image-border) !important; 
  box-shadow:var(--image-shadow) !important;
  padding:4px !important; 
  background:transparent !important;
  border-radius:16px !important; 
  max-width:fit-content !important;
  width:auto !important;
  cursor:pointer !important;
}

.illus-spell img:hover, .illus-class img:hover, .illus-subclass img:hover, .illus-don img:hover,
article[data-page="guerrier"] .illus img:hover,
article[data-page="mage"] .illus img:hover,
article[data-page="pretre"] .illus img:hover,
article[data-page="rodeur"] .illus img:hover,
article[data-page="enchanteur"] .illus img:hover,
.illus[data-illus-key^="class:"] img:hover,
.illus[data-illus-key^="subclass:"] img:hover,
.illus[data-illus-key^="spell:"] img:hover,
.illus[data-illus-key^="sort:"] img:hover,
.illus[data-illus-key^="spellcategory:"] img:hover,
.illus[data-illus-key^="don:"] img:hover {
  transform:scale(1.03) !important; 
  box-shadow:var(--image-shadow), 0 8px 25px rgba(139,69,19,.25) !important;
}

/* Variantes de taille d'images */
.illus-small img { max-width: 150px !important; }
.illus-large img { max-width: 400px !important; }

/* Style spÃ©cial pour les sorts - cadre dorÃ© et taille augmentÃ©e */
.illus-spell img,
.card .illus img {
  border: 3px solid var(--gold) !important;
  box-shadow: var(--image-shadow), 0 0 10px rgba(212,175,55,.3) !important;
  max-width: 350px !important;
  max-height: 250px !important;
  object-fit: contain !important;
}

/* Style spÃ©cial pour les sous-classes - 2 images centrÃ©es et collÃ©es */
.subclass-images {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 0;
  margin: 0.6rem 0;
}

.subclass-images .illus {
  margin: 0;
  flex: 0 0 auto;
}

.subclass-images .illus img {
  max-width: 400px !important;
  max-height: 300px !important;
  object-fit: contain !important;
  border-radius: 12px 0 0 12px !important;
}

.subclass-images .illus:last-child img {
  border-radius: 0 12px 12px 0 !important;
}

/* Mobile: Stack subclass images vertically */
@media (max-width: 980px) {
  .subclass-images {
    flex-direction: column !important;
    gap: 8px !important;
  }
  
  .subclass-images .illus img {
    border-radius: 12px !important;
    max-width: 100% !important;
    width: 100% !important;
  }
  
  /* RÃ©duire l'espace des cadres d'images sur mobile */
  .illus-spell img, .illus-class img, .illus-subclass img, .illus-don img,
  article[data-page="guerrier"] .illus img,
  article[data-page="mage"] .illus img,
  article[data-page="pretre"] .illus img,
  article[data-page="rodeur"] .illus img,
  article[data-page="enchanteur"] .illus img,
  .illus[data-illus-key^="class:"] img,
  .illus[data-illus-key^="subclass:"] img,
  .illus[data-illus-key^="spell:"] img,
  .illus[data-illus-key^="sort:"] img,
  .illus[data-illus-key^="spellcategory:"] img,
  .illus[data-illus-key^="don:"] img {
    padding: 2px !important; /* RÃ©duire le padding de 4px Ã  2px */
    border-width: 2px !important; /* RÃ©duire l'Ã©paisseur des bordures */
    max-width: 100% !important;
    width: auto !important;
    height: auto !important;
    object-fit: contain !important;
  }
  
  /* RÃ©duire l'espace entre les images de classe et sous-classe */
  .illus {
    gap: 4px !important; /* RÃ©duire de 12px Ã  4px */
    margin: 0.3rem 0 !important; /* RÃ©duire les marges */
  }
  
  /* Images de sorts plus compactes sur mobile */
  .illus-spell img,
  .card .illus img {
    max-width: 100% !important;
    max-height: 180px !important; /* RÃ©duire de 250px Ã  180px */
    border-width: 2px !important; /* Bordure plus fine */
  }
  
  .subclass-images .illus:last-child img {
    border-radius: 12px !important;
  }
}

/* Style spÃ©cial pour les titres de sous-classes */
.subclass-title {
  font-size: 2.2rem !important;
  font-weight: 800 !important;
  text-align: center !important;
  margin: 0 0 1.5rem 0 !important;
  color: var(--accent-ink) !important;
  font-family: 'Cinzel', serif !important;
  text-shadow: 2px 2px 4px rgba(0,0,0,0.2) !important;
  letter-spacing: 0.8px !important;
}

/* Style spÃ©cial pour les descriptions de sous-classes */
.card[data-section-type="subclass"] .editable[data-edit-section*="description"] {
  text-align: center !important;
  color: var(--paper-ink) !important;
}

.card[data-section-type="subclass"] .editable[data-edit-section*="description"] em,
.card[data-section-type="subclass"] .editable[data-edit-section*="description"] i {
  color: var(--paper-ink) !important;
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ“± MOBILE & TOUCH OPTIMIZATION - Final Enhancements
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

/* Touch-friendly interactions for mobile devices */
@media (hover: none) and (pointer: coarse) {
  .btn-base, .filter-chip, .toc a, .card {
    min-height: 44px; /* iOS/Android minimum touch target */
    min-width: 44px;
  }
  
  .toc a {
    padding: 12px;
    margin: 4px 0;
  }
  
  .filter-chip {
    padding: 8px 16px;
    margin: 2px;
  }
  
  /* Disable hover effects on touch devices */
  .card:hover, .btn-base:hover, .filter-chip:hover, .toc a:hover {
    transform: none;
    box-shadow: initial;
    background: initial;
    border-color: initial;
  }
  
  /* Add tap feedback instead */
  .btn-base:active, .filter-chip:active, .toc a:active, .card:active {
    transform: scale(0.98);
    transition: transform 0.1s ease;
    opacity: 0.8;
  }
}

/* Reduce animation complexity on low-performance devices */
@media (prefers-reduced-motion: reduce) {
  *, *::before, *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
    scroll-behavior: auto !important;
  }
  
  .floating, .pulse-attention, .text-glow, 
  .shimmer-effect, .sparkle-effect {
    animation: none !important;
  }
  
  .card, .btn-base, .filter-chip {
    transition: none !important;
  }
}

/* Mobile-specific improvements */
@media (max-width: 480px) {
  /* Improve text readability on small screens */
  body {
    font-size: 16px;
    line-height: 1.6;
    -webkit-text-size-adjust: 100%;
  }
  
  /* Ensure images don't break layout */
  img {
    max-width: 100% !important;
    height: auto !important;
  }
  
  /* Optimize cards for mobile */
  .card, .card-base {
    border-radius: 12px;
    box-shadow: 0 4px 16px rgba(0,0,0,.1);
  }
  
  /* Mobile-friendly buttons */
  .btn-base {
    border-radius: 8px;
    font-size: 16px; /* Prevent iOS zoom */
  }
  
  /* Improve modal sizing on mobile */
  .modal-content-base {
    margin: 10px;
    max-width: calc(100vw - 20px);
    max-height: calc(100vh - 20px);
    overflow-y: auto;
  }
  
  /* Mobile search optimization */
  .searchbar input {
    font-size: 16px; /* Prevents zoom on iOS */
    padding: 12px;
    border-radius: 8px;
  }
}

/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   ğŸ“„ SECTION SELECTION MODAL
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

.section-selection-modal .modal-content {
  max-width: 500px;
  padding: 2rem;
}

.sections-list {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  margin: 1.5rem 0;
}

.section-option {
  display: flex;
  align-items: center;
  gap: 1rem;
  padding: 1rem;
  border: 2px solid var(--rule);
  border-radius: 12px;
  cursor: pointer;
  transition: all var(--transition-normal);
  background: var(--card);
}

.section-option:hover {
  border-color: var(--bronze);
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.1) 0%, 
    rgba(139,69,19,0.05) 100%);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(139,69,19,0.15);
}

.section-option.selected {
  border-color: var(--gold);
  background: linear-gradient(135deg, 
    rgba(212,175,55,0.2) 0%, 
    rgba(139,69,19,0.1) 100%);
  box-shadow: 
    0 0 0 2px rgba(212,175,55,0.3),
    0 4px 16px rgba(139,69,19,0.2);
}

.section-icon {
  font-size: 2rem;
  width: 60px;
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 12px;
  background: linear-gradient(135deg, var(--bronze), var(--gold));
  color: white;
  text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
}

.section-info {
  flex: 1;
}

.section-title {
  font-weight: 600;
  font-size: 1.1em;
  color: var(--accent-ink);
  margin-bottom: 0.25rem;
  font-family: 'Cinzel', serif;
}

.section-description {
  color: var(--paper-muted);
  font-size: 0.9em;
  line-height: 1.4;
}

.page-details {
  padding: 1.5rem;
  background: var(--paper-soft);
  border: 1px solid var(--rule);
  border-radius: 12px;
  margin: 1rem 0;
}

.form-group {
  margin-bottom: 1rem;
}

.form-group:last-child {
  margin-bottom: 0;
}

.form-group label {
  display: block;
  margin-bottom: 0.5rem;
  font-weight: 600;
  color: var(--accent-ink);
}

.form-group input {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid var(--rule);
  border-radius: 8px;
  font-size: 1em;
  background: var(--card);
  color: var(--paper-ink);
}

.form-group input:focus {
  outline: none;
  border-color: var(--bronze);
  box-shadow: 0 0 0 2px rgba(212,175,55,0.2);
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 1rem;
  margin-top: 1.5rem;
}

.btn-primary {
  background: var(--bronze) !important;
  color: white !important;
  border-color: var(--bronze) !important;
}

.btn-primary:hover {
  background: var(--gold) !important;
  border-color: var(--gold) !important;
}

/* Mobile optimization for section selection modal */
@media (max-width: 480px) {
  .section-selection-modal .modal-content {
    padding: 1rem;
    margin: 1rem;
  }
  
  .section-option {
    padding: 0.75rem;
    gap: 0.75rem;
  }
  
  .section-icon {
    width: 48px;
    height: 48px;
    font-size: 1.5rem;
  }
  
  .modal-actions {
    flex-direction: column;
  }
  
  .modal-actions .btn {
    width: 100%;
  }
}
/* Editor and Dev Mode styles */

/* === HIDE ALL EDITING ELEMENTS IN STANDALONE MODE === */
/* Hide all editing elements when dev mode is OFF */

/* ULTRA NUCLEAR OPTION - Hide ALL editing buttons when dev mode is OFF */
/* This rule will override ANY other CSS that might be showing edit buttons */
body.dev-off button[title*="âœï¸"],
body.dev-off *[class*="edit"],
body.dev-off *[class*="Edit"],

body.dev-off button[data-category-name],
body.dev-off button[data-spell-name], 
body.dev-off button[data-don-name],
body.dev-off button[data-section-name],
body.dev-off button[data-section-type],
body.dev-off .btn:is([class*="add"], [class*="delete"], [class*="remove"], [class*="move"], [class*="edit"]),
body.dev-off .add-paragraph-btn,
body.dev-off .section-delete,
body.dev-off .spell-delete,
body.dev-off .don-delete,
body.dev-off .objet-delete,
body.dev-off .spell-category-delete,
body.dev-off .don-category-delete,
body.dev-off .objet-category-delete,
body.dev-off .don-move-up,
body.dev-off .don-move-down,
body.dev-off .remove-section-btn,
body.dev-off .illus .up,
body.dev-off .illus .rm,
body.dev-off .illus label.up,
body.dev-off .illus button.rm,
body.dev-off .illus label,
body.dev-off .illus input[type="file"],
body.dev-off button[class*="add"]:not(.menu-toggle),
body.dev-off button[class*="delete"],
body.dev-off button[class*="remove"],
body.dev-off button[class*="move"],
body.dev-off button[class*="edit"],
body.dev-off .spell-add,
body.dev-off .don-add,
body.dev-off .objet-add,
body.dev-off .category-add,
body.dev-off .add-*,
body.dev-off [data-bound] .up,
body.dev-off [data-bound] .rm,
body.dev-off [data-bound] label,
body.dev-off [data-bound] button,
/* Specific button selectors */
body.dev-off button[data-category-name],
body.dev-off button[data-spell-name],
body.dev-off button[data-don-name],
body.dev-off button[data-section-name],
body.dev-off button[data-section-type],
/* Input file upload elements */
body.dev-off input[type="file"],
body.dev-off label[for*="file"],
/* Additional specific selectors */
body.dev-off .add-subclass-btn,
body.dev-off .add-new-section,
/* COMPREHENSIVE EDIT BUTTON HIDING */
body.dev-off .edit-btn,
body.dev-off .edit-title-btn,
body.dev-off .edit-paragraph-btn,
body.dev-off .edit-list-btn,
body.dev-off .edit-field-btn,
body.dev-off .edit-effect-btn,
body.dev-off .edit-stats-btn,
body.dev-off .edit-section-btn,
body.dev-off button.edit-btn,
body.dev-off button.edit-title-btn,
body.dev-off button.edit-paragraph-btn,
body.dev-off button.edit-list-btn,
body.dev-off button.edit-field-btn,
body.dev-off button.edit-effect-btn,
body.dev-off button.edit-stats-btn,
body.dev-off button.edit-section-btn,
body.dev-off .editable-section .edit-btn,
body.dev-off .editable-section button[class*="edit"],
body.dev-off .card .edit-btn,
body.dev-off .card button[class*="edit"],
body.dev-off .editable-item .edit-btn,
body.dev-off .editable-item button[class*="edit"],
body.dev-off [data-section-type] .edit-btn,
body.dev-off [data-section-type] button[class*="edit"],
body.dev-off .add-*-btn,
/* Very specific selectors for inline styled buttons */
body.dev-off button[style*="background: #ff6b6b"],
body.dev-off button[style*="background: var(--bronze)"],
body.dev-off button[style*="background: #dc2626"],
body.dev-off button[style*="background: var(--accent)"],
/* Target buttons by text content patterns */
body.dev-off .btn.small[data-category-name],
body.dev-off .btn.small[data-spell-name],  
body.dev-off .btn.small[data-don-name],
body.dev-off .btn.small[data-section-name],
body.dev-off .btn.small[data-don-index],
/* Element selectors for spells - Solution ultra-forcÃ©e */
.spell-element-selector,
.spell-element-selector *,
div.spell-element-selector,
.card .spell-element-selector {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  position: absolute !important;
  left: -9999px !important;
  width: 0 !important;
  height: 0 !important;
  overflow: hidden !important;
}

/* SEULEMENT visible en mode dev */
body.dev-on .spell-element-selector,
body.dev-on .spell-element-selector *,
body.dev-on div.spell-element-selector,
body.dev-on .card .spell-element-selector {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  position: static !important;
  left: auto !important;
  width: auto !important;
  height: auto !important;
  overflow: visible !important;
}

body.dev-off .spell-element-display {
  display: block !important;
}

body.dev-on .spell-element-display {
  display: none !important;
}

/* COMPREHENSIVE SHOW RULES FOR DEV MODE - High specificity to override dev-off hiding */
body.dev-on .edit-btn,
body.dev-on button.edit-btn,
body.dev-on button[class*="edit"],
body.dev-on button[class*="add"]:not(.menu-toggle),
body.dev-on button[class*="delete"],
body.dev-on button[class*="remove"],
body.dev-on button[class*="move"],
body.dev-on .section-delete,
body.dev-on .spell-delete,
body.dev-on .don-delete,
body.dev-on .add-subclass-btn,
body.dev-on .delete-subclass-btn,
body.dev-on .add-paragraph-btn,
body.dev-on .remove-section-btn,
body.dev-on .illus .up,
body.dev-on .illus .rm,
body.dev-on .illus label,
body.dev-on .illus input[type="file"],
body.dev-on button[data-category-name],
body.dev-on button[data-spell-name],
body.dev-on button[data-don-name],
body.dev-on button[data-section-name],
body.dev-on button[data-section-type],
/* Extra specific selectors to match the hiding rules exactly */
body.dev-on .spell-add,
body.dev-on .don-add,
body.dev-on .objet-add,
body.dev-on .category-add,
body.dev-on .spell-category-delete,
body.dev-on .don-category-delete,
body.dev-on .objet-category-delete,
body.dev-on .don-move-up,
body.dev-on .don-move-down,
body.dev-on button[title*="Ã‰diter"],
body.dev-on button[title*="Edit"],
body.dev-on button[title*="Supprimer"],
body.dev-on button[title*="Ajouter"] {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  pointer-events: auto !important;
  position: relative !important;
}

/* ULTIMATE SOLUTION: Force dimensions to prevent 0x0 collapse */
html body.dev-on .edit-btn,
html body.dev-on button[class*="edit"],
html body.dev-on button[class*="add"],
html body.dev-on button[class*="delete"],
html body.dev-on .section-delete,
html body.dev-on .add-paragraph-btn {
  display: inline-block !important;
  visibility: visible !important;
  opacity: 1 !important;
  width: 28px !important;
  height: 28px !important;
  min-width: 28px !important;
  min-height: 28px !important;
  background: rgba(139,69,19,0.1) !important;
  border: 1px solid var(--bronze) !important;
  border-radius: 6px !important;
  color: var(--bronze) !important;
  font-size: 14px !important;
  padding: 4px !important;
  margin-left: 8px !important;
  box-sizing: border-box !important;
  line-height: 1 !important;
  cursor: pointer !important;
  position: relative !important;
  top: 0 !important;
  left: 0 !important;
  transform: none !important;
  z-index: 10 !important;
}
/* Target specific button classes from renderer */
body.dev-off .spell-add,
body.dev-off .don-add,
body.dev-off .objet-add,
body.dev-off .spell-delete,
body.dev-off .don-delete,
body.dev-off .objet-delete,
body.dev-off .spell-category-delete,
body.dev-off .don-category-delete,
body.dev-off .objet-category-delete,
body.dev-off .don-move-up,
body.dev-off .don-move-down,
body.dev-off .section-delete,
body.dev-off .remove-section-btn,
/* Universal button selectors with edit-related titles */
body.dev-off button[title*="diter"],
body.dev-off button[title*="Edit"],
body.dev-off button[title*="Supprimer"],
body.dev-off button[title*="Ajouter"],
body.dev-off button[title*="Haut"],
body.dev-off button[title*="Bas"],
/* AJOUT: SÃ©lecteurs pour les boutons add/delete */
body.dev-off button[class*="add"],
body.dev-off button[class*="delete"],
body.dev-off button[class*="remove"],
body.dev-off button[class*="move"],
body.dev-off button[class*="upload"],
body.dev-off button[class*="edit"] {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  pointer-events: none !important;
}

/* SPÃ‰CIFIQUE: RÃ¨gles avec spÃ©cificitÃ© maximale pour forcer le masquage */
body.dev-off button.spell-add.btn,
body.dev-off button.don-add.btn,
body.dev-off button.objet-add.btn,
body.dev-off button.spell-category-delete.btn,
body.dev-off button.don-category-delete.btn,
body.dev-off button.objet-category-delete.btn {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  pointer-events: none !important;
}

/* Ancien systÃ¨me d'agrandissement - dÃ©sactivÃ© */
.illus img.enlarged {
  /* Plus de style ici - gÃ©rÃ© par JavaScript modal */
}

/* Forcer l'Ã©tat stable sur hover pour les images agrandies */
.illus img.enlarged:hover,
article[data-page="guerrier"] .illus img.enlarged:hover,
article[data-page="mage"] .illus img.enlarged:hover,
article[data-page="pretre"] .illus img.enlarged:hover,
article[data-page="rodeur"] .illus img.enlarged:hover,
article[data-page="enchanteur"] .illus img.enlarged:hover,
.illus[data-illus-key^="class:"] img.enlarged:hover,
article[data-page="sorts-mage"] .illus img.enlarged:hover,
article[data-page="sorts-pretre"] .illus img.enlarged:hover,
article[data-page="sorts-enchanteur"] .illus img.enlarged:hover,
.illus[data-illus-key^="spellcategory:"] img.enlarged:hover {
  transform:translate(-50%, -50%) !important;
  transition:none !important;
}

/* Ancien backdrop - plus utilisÃ© */
.image-backdrop {
  display: none !important;
}

/* Interactive buttons */
.btn-action{display:inline-flex;gap:var(--space-sm);align-items:center;padding:var(--space-sm) 10px;border-radius:10px;cursor:pointer;border:1px solid}
.btn-upload{border-color:rgba(0,0,0,.25);border-style:dashed;background:#fff8ee}
.btn-remove{border-color:rgba(120,0,0,.25);background:#fee2e2}
.btn-add{border-color:rgba(0,120,0,.25);background:#f0fff4;margin-bottom:10px}
.btn-delete{padding:var(--space-xs) var(--space-md);border-radius:6px;font-size:12px;margin-left:10px}
.illus .up{border-color:rgba(0,0,0,.25);border-style:dashed;background:#fff8ee}
.illus .rm, .spell-delete{border-color:rgba(120,0,0,.25);background:#fee2e2}
.spell-add{border-color:rgba(0,120,0,.25);background:#f0fff4;margin-bottom:10px}
.spell-delete{padding:var(--space-xs) var(--space-md);border-radius:6px;font-size:12px;margin-left:10px}

/* Bouton d'ajout de paragraphe - seulement dans les articles */
.add-paragraph-btn {
  display:none !important;
}
/* Masquer explicitement dans la sidebar et le sommaire */
.sidebar .add-paragraph-btn,
.toc .add-paragraph-btn,
#toc .add-paragraph-btn {
  display:none !important;
  visibility:hidden !important;
}
/* Afficher SEULEMENT dans les articles actifs en mode dev */
body.dev-on article.active .add-paragraph-btn {
  display:block !important; margin:10px 0; padding:8px 12px; background:var(--card); 
  border:2px dashed var(--bronze); border-radius:8px; cursor:pointer;
  color:var(--bronze); text-align:center; transition:all .2s ease;
}
body.dev-on article.active .add-paragraph-btn:hover {
  background:rgba(139,69,19,.08); border-color:var(--gold);
  color:var(--gold);
}

/* Bouton d'ajout de sous-classe */
.add-subclass-btn {
  display:none; margin:12px 0 4px 0; padding:8px 12px; background:var(--card);
  border:1px dashed var(--bronze); border-radius:8px; cursor:pointer;
  color:var(--bronze); text-align:center; font-size:13px;
  transition:all .2s ease; width:100%;
}
/* Afficher dans les pages de classes en mode dev */
body.dev-on article[data-page="guerrier"] .add-subclass-btn,
body.dev-on article[data-page="mage"] .add-subclass-btn,
body.dev-on article[data-page="pretre"] .add-subclass-btn,
body.dev-on article[data-page="rodeur"] .add-subclass-btn,
body.dev-on article[data-page="enchanteur"] .add-subclass-btn {
  display:block !important;
}
body.dev-on article[data-page="guerrier"] .add-subclass-btn:hover,
body.dev-on article[data-page="mage"] .add-subclass-btn:hover,
body.dev-on article[data-page="pretre"] .add-subclass-btn:hover,
body.dev-on article[data-page="rodeur"] .add-subclass-btn:hover,
body.dev-on article[data-page="enchanteur"] .add-subclass-btn:hover {
  background:rgba(139,69,19,.08); border-color:var(--gold);
  color:var(--gold); transform:translateY(-1px);
  box-shadow:0 4px 8px rgba(0,0,0,.1);
}

/* Modales */
.category-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.category-modal.visible {
  display:flex;
}
.category-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:500px; width:90%; box-shadow:var(--shadow);
  position:relative;
}

/* Modal pour les icÃ´nes */
.icons-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.icons-modal.visible {
  display:flex;
}
.icons-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:600px; width:90%; max-height:80vh; overflow-y:auto;
  box-shadow:var(--shadow); position:relative;
}
.icons-grid {
  display:grid; grid-template-columns:repeat(auto-fill, minmax(60px, 1fr));
  gap:var(--space-md); margin:var(--space-xl) 0; max-height:400px; overflow-y:auto;
  border:1px solid var(--rule); border-radius:var(--space-md); padding:var(--space-xl);
}
.icon-item {
  display:flex; align-items:center; justify-content:center;
  padding:var(--space-lg); border:1px solid var(--rule); border-radius:var(--space-md);
  cursor:pointer; transition:var(--transition-fast); font-size:24px;
  background:var(--paper);
}
.icon-item:hover {
  background:var(--bronze); color:white; transform:scale(1.1);
  box-shadow:0 4px 8px rgba(0,0,0,.2);
}
.icon-item.copied {
  background:var(--gold); color:white; animation:copyFlash .5s ease;
}
@keyframes copyFlash {
  0% { transform:scale(1.1); }
  50% { transform:scale(1.3); }
  100% { transform:scale(1.1); }
}

/* Modal pour les Ã©lÃ©ments */
.elements-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.elements-modal.visible {
  display:flex;
}
.elements-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:400px; width:90%; 
  box-shadow:var(--shadow); position:relative;
}
.elements-list {
  display:flex; flex-direction:column; gap:var(--space-md); margin:var(--space-xl) 0;
}
.element-item {
  display:flex; align-items:center; gap:var(--space-md); padding:var(--space-md);
  border:2px solid var(--rule); border-radius:var(--space-md); cursor:pointer;
  transition:var(--transition-fast); background:var(--card);
}
.element-item:hover {
  background:var(--paper); border-color:var(--bronze); transform:translateY(-2px);
  box-shadow:0 4px 12px rgba(0,0,0,.1);
}
.element-item:active {
  transform:translateY(0) scale(0.98);
}
.element-icon {
  width:24px; height:24px; border-radius:50%; flex-shrink:0;
}
.element-name {
  font-weight:600; flex-grow:1;
}
.copy-indicator {
  font-size:12px; color:var(--paper-muted); opacity:0;
  transition:opacity 0.3s ease;
}
.element-item.copied .copy-indicator {
  opacity:1;
}

/* Ã‰tats modal styles */
.etats-modal {
  position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,.7);
  z-index:99999; display:none; align-items:center; justify-content:center;
}
.etats-modal.visible {
  display:flex;
}
.etats-modal-content {
  background:var(--card); border:2px solid var(--rule); border-radius:16px;
  padding:var(--space-2xl); max-width:500px; width:90%; 
  box-shadow:var(--shadow); position:relative; max-height:80vh; overflow-y:auto;
}
.etats-list {
  display:flex; flex-direction:column; gap:var(--space-md); margin:var(--space-xl) 0;
}
.etat-item {
  display:flex; align-items:flex-start; gap:var(--space-md); padding:var(--space-md);
  border:2px solid var(--rule); border-radius:var(--space-md); cursor:pointer;
  transition:var(--transition-fast); background:var(--card); position:relative;
}
.etat-content {
  flex:1; display:flex; flex-direction:column;
}
.etat-item:hover {
  background:var(--paper); border-color:var(--bronze); transform:translateY(-2px);
  box-shadow:0 4px 12px rgba(0,0,0,.1);
}
.etat-item:active {
  transform:translateY(0) scale(0.98);
}
.etat-icon {
  width:24px; height:24px; border-radius:50%; flex-shrink:0;
  background:var(--bronze); color:white; display:flex; align-items:center;
  justify-content:center; font-size:14px;
}
.etat-name {
  font-weight:600; color:var(--accent-ink); margin-bottom:4px;
}
.etat-description {
  font-size:12px; color:var(--paper-muted); line-height:1.4;
}
.etat-item .copy-indicator {
  position:absolute; top:50%; right:var(--space-md); transform:translateY(-50%);
  font-size:12px; color:var(--bronze); opacity:0; font-weight:600;
  transition:opacity 0.3s ease;
}
.etat-item.copied .copy-indicator {
  opacity:1;
}

/* Styles pour les tooltips d'Ã©tats */
span[title] {
  cursor: help;
  border-bottom: 2px solid var(--bronze);
  position: relative;
  display: inline-block;
  background: linear-gradient(135deg, rgba(205,127,50,0.1), rgba(212,175,55,0.05));
  padding: 2px 4px;
  border-radius: 3px;
  font-weight: 700;
}

span[title]:hover {
  border-bottom-color: var(--gold);
  border-bottom-width: 3px;
  background: linear-gradient(135deg, rgba(212,175,55,0.2), rgba(205,127,50,0.1));
  transform: translateY(-1px);
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* Tooltip personnalisÃ© pour une meilleure visibilitÃ© */
span[title]:hover::after {
  content: attr(title);
  position: absolute;
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: var(--accent-ink);
  color: white;
  padding: 10px 15px;
  border-radius: 8px;
  font-size: 13px;
  white-space: pre-line;
  z-index: 999999;
  box-shadow: 0 8px 24px rgba(0,0,0,0.4);
  pointer-events: none;
  min-width: 200px;
  max-width: 320px;
  text-align: center;
  line-height: 1.5;
  animation: tooltipFadeIn 0.3s ease;
  border: 2px solid var(--gold);
  word-wrap: break-word;
}

span[title]:hover::before {
  content: '';
  position: absolute;
  bottom: calc(100% + 2px);
  left: 50%;
  transform: translateX(-50%);
  border: 6px solid transparent;
  border-top-color: var(--accent-ink);
  z-index: 999999;
  pointer-events: none;
}

/* Forcer l'overflow visible pour les tooltips */
.card:has(span[title]:hover),
.editable:has(span[title]:hover),
article:has(span[title]:hover) {
  overflow: visible !important;
}

/* Fallback pour navigateurs sans :has() */
.card,
.editable,
article {
  position: relative;
}

.card span[title]:hover::after,
.editable span[title]:hover::after,
article span[title]:hover::after {
  z-index: 99999 !important;
}

@keyframes tooltipFadeIn {
  from { opacity: 0; transform: translateX(-50%) translateY(5px); }
  to { opacity: 1; transform: translateX(-50%) translateY(0); }
}

/* === UNIFIED EDIT BUTTONS FOR ALL SECTIONS === */
.editable-section {
  position: relative;
  margin: 8px 0;
}

.edit-btn {
  background: var(--bronze);
  color: white;
  border: none;
  border-radius: 6px;
  padding: 4px 8px;
  cursor: pointer;
  font-size: 12px;
  opacity: 0.7;
  transition: all 0.2s ease;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.edit-btn:hover {
  opacity: 1;
  transform: scale(1.05);
  background: var(--gold);
}

/* Inline edit buttons (titles, etc.) */
.edit-btn.edit-title-btn,
.edit-btn.edit-paragraph-btn {
  position: relative;
  margin-left: 8px;
}

/* Section edit buttons (absolute positioning) */
.editable-section .edit-btn.edit-section-btn,
[style*="position:relative"] .edit-btn.edit-section-btn {
  position: absolute;
  right: 8px;
  top: 8px;
  z-index: 10;
}

.editable-section:hover .edit-btn {
  opacity: 1;
  transform: scale(1.05);
  background: var(--gold);
}

.editable-section .edit-btn:hover {
  background: var(--gold) !important;
  transform: scale(1.1) !important;
  box-shadow: 0 3px 8px rgba(0,0,0,0.2);
}

.editable-section .edit-btn:active {
  transform: scale(0.95) !important;
}

/* Special positioning for different types */
.editable-list-container .edit-btn {
  right: 16px;
  top: 16px;
}

.editable-section[data-section-type="intro"] .edit-btn {
  right: 12px;
  top: 12px;
}

/* Title edit buttons */
.edit-title-btn {
  position: relative !important;
  right: auto !important;
  top: auto !important;
  margin-left: 12px;
  transform: none !important;
}

.edit-title-btn:hover {
  transform: scale(1.1) !important;
}

/* When editing, hide the button and expand content */
.editable-section[data-editing="true"] .edit-btn {
  display: none;
}

/* Visual feedback for editable sections */
.editable-section:hover {
  background: rgba(184, 134, 11, 0.05);
  border-radius: 8px;
  transition: background 0.2s ease;
}

.editable-section[data-editing="true"] {
  background: rgba(255, 255, 0, 0.1);
  border: 1px dashed var(--bronze);
  border-radius: 8px;
  padding: 8px;
}

/* Legacy support for old list items */
.editable-item {
  position: relative;
  padding-right: 40px;
}

.editable-content {
  display: block;
  margin-right: 35px;
}
</style>
</head>
<body class="dev-off">

<div class="shell">
  <button aria-controls="sidebar" aria-expanded="false" aria-label="Ouvrir le sommaire" class="menu-toggle" id="menuToggle" style="display:none">â˜° Sommaire</button>
  <div class="backdrop" hidden="" id="backdrop"></div>
  
  <main class="page">
    <aside class="sidebar" id="sidebar">
      <div class="panel">
        <div class="searchbar">
          <input autocomplete="off" id="search" placeholder="Rechercher une rÃ¨gle, une classeâ€¦">
          <button class="btn" id="clear" title="Effacer">âœ–</button>
        </div>
        <div class="tools">
          <!-- Dev mode disabled in standalone version -->
        </div>
        <div class="toc" id="toc">
          <!-- Table of contents will be generated by JavaScript -->
        </div>
      </div>
    </aside>
    
    <div id="views">
      <!-- Main content will be generated by JavaScript -->
      <div id="app-loading">Chargement...</div>
    </div>
  </main>
  
  <footer>
    <p>JDRâ€‘BAB â€” RÃ¨gles et contenus sous licence libre</p>
  </footer>
</div>

<script>

    // Ensure window object exists
    window = window || {};
    
    // Global data from modular files
    window.SORTS = [
  {
    "nom": "Sorts de Mage",
    "description": "Sorts de destruction.",
    "sorts": [
      {
        "nom": "Boule de Feu",
        "element": "Feu",
        "description": "Lance une boule de feu sur un adversaire, qui peut s'enflammer.",
        "categorie": "Mage",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 20m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 3",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige 5 dÃ©gats de <span style=\"color: #e25822; font-weight: bold;\">Feu</span> Ã  la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Les dÃ©gats passent Ã  7 et la cible s'enflamme, infligeant 5 dÃ©gats de feu au prochain tour du lanceur."
      },
      {
        "nom": "Ã‰clair",
        "element": "Air",
        "description": "Frappe instantannÃ©ment une cible avec un Ã©clair Ã©lectrique, ne laissant aucune chance Ã  l'esquive.",
        "categorie": "Mage",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 2",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 10m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 5",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> &nbsp;Inflige 6 dÃ©gats d'<span style=\"color: #22c55e; font-weight: bold;\">Air</span> Ã  la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> Les dÃ©gÃ¢ts passent Ã  10 et ils sont aussi infligÃ© Ã  un ennemi Ã  moins de 5m de la cible."
      },
      {
        "nom": "Vague dÃ©ferlante",
        "element": "Eau",
        "description": "Une puissante vague d'eau s'abat sur vos ennemis et les repousse.",
        "categorie": "Sorts de Mage",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 3",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 5m",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 6",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> Volant.",
        "effetNormal": "<strong>Effet:</strong> &nbsp;Inflige 6 dÃ©gats d'<span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span> aux crÃ©ature devant le lanceur (largeur 2m distance 5m) et les repousse jusqu'Ã  5m.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> les dÃ©gats passent Ã  10 et les enemis sont touchÃ©s/repoussÃ©s Ã  10m."
      }
    ]
  },
  {
    "nom": "Sorts de PrÃªtre",
    "description": "Sorts de soutiens et anti mort-vivants.",
    "sorts": [
      {
        "nom": "ChÃ¢timent",
        "element": "Divin",
        "description": "Invoque un magie divine qui blesse les morts-vivants",
        "categorie": "Anti-mort-vivant",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 3",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 20m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 3",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> &nbsp;<br>- Non mort-vivant <br>- Esquive.",
        "effetNormal": "<strong>Effet:</strong> Inflige *Intelligence* dÃ©gÃ¢ts <span style=\"color: #d0d0d0; font-weight: bold; background: rgba(0, 0, 0, 0.4); padding: 2px 4px; border-radius: 3px;\">Divin</span> Ã  la cible.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>Double dÃ©gÃ¢ts."
      },
      {
        "nom": "Soin mineur",
        "element": "Divin",
        "description": "Une magie divine soigne les blessures du hÃ©ros ou d'un alliÃ© proche.",
        "categorie": "Sorts de PrÃªtre",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 3m",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 5",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> &nbsp;mort-vivant.",
        "effetNormal": "<strong>Effet:</strong> Soigne la cible de 5 points de vie. Tous les 5 points d'intelligence, augmente le soin de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>Double le soin."
      },
      {
        "nom": "Protection",
        "element": "LumiÃ¨re",
        "description": "ProtÃ¨ge le lanceur ou un alliÃ©.",
        "categorie": "Sorts de PrÃªtre",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 2",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 3m",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 5",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> Augmente l'armure de 2 pendant 5 tours.<br> Tous les 5 d'Intelligence, augmente l'armure de 1 supplÃ©mentaire.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> L'armure est augmentÃ©e de 4."
      },
      {
        "nom": "Arme de lumiÃ¨re",
        "element": "LumiÃ¨re",
        "description": "Une lumiÃ¨re destructrice s'imprÃ¨gne de l'arme du prÃªtre.",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> -",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 5",
        "resistance": "<strong>Sans effet si:</strong> -",
        "effetNormal": "<strong>Effet:</strong> L'arme du prÃªtre infligera 2 dÃ©gats de lumiÃ¨re Ã  chaque coup, pendant 4 tours.<br> Tous les 5 d'intelligence, augmente les dÃ©gats de 1.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>&nbsp;Les dÃ©gats passent Ã  4."
      }
    ]
  },
  {
    "nom": "Sorts d'Enchanteur",
    "description": "Sorts d'amÃ©lioration et d'affaiblissement.",
    "sorts": [
      {
        "nom": "Accroche terrestre",
        "element": "Terre",
        "description": "Le sol se soulÃ¨ve et s'agrippe aux jambes de la cible, alourdissant ses pas d'une Ã©treinte de pierre vivante.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 30m",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 3",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> <br>- RÃ©sistance altÃ©rations &gt; Intelligence du lanceur<br>- LÃ©vitation ou Volant.",
        "effetNormal": "<strong>Effet:</strong>&nbsp;La cible contracte l'Ã©tat <span title=\"Vitesse de dÃ©placement rÃ©duite de moitiÃ©.\n Impossible de sauter ou d'esquiver.\">Ralenti</span> pendant 5 tours.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong>La cible ne peut plus effectuer de dÃ©placement pendant la durÃ©e du sort."
      },
      {
        "nom": "AccÃ©lÃ©ration",
        "element": "Air",
        "description": "Une magie des vents accÃ©lÃ¨re un alliÃ© ou le lanceur.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 5m",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 4",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> Aucune",
        "effetNormal": "<strong>Effet:</strong> &nbsp;La vitesse de dÃ©placement de la cible est augmentÃ©e de 50% pendant 5 tours. Non Cumulable.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> La vitesse est augmentÃ©e de 100%."
      },
      {
        "nom": "Sommeil",
        "element": "Nuit",
        "description": "Un voile d'ombre caresse la cible, l'enveloppant dans un sommeil surnaturel.",
        "categorie": "Sorts d'Enchanteur",
        "prerequis": "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 2",
        "portee": "ğŸ¯ <strong>PortÃ©e:</strong> 5m",
        "coutMana": "ğŸ”µ <strong>CoÃ»t mana:</strong> 8",
        "tempsIncantation": "â° <strong>Temps d'incantation:</strong> 1 tour",
        "duree": "â³ <strong>DurÃ©e:</strong> InstantanÃ©",
        "resistance": "<strong>Sans effet si:</strong> <br>- RÃ©sistance altÃ©rations &gt; Intelligence du lanceur<br>- Element <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span>",
        "effetNormal": "<strong>Effet:</strong> La cible passe dans l'Ã©tat <span title=\"Ne peut plus faire d'actions.\n Ne peut plus esquiver.\n Des dÃ©gats infligÃ©s Ã  la crÃ©ature la sort de son Ã©tat.\">endormi</span> pendant ses 2 prochains tours.",
        "effetCritique": "<strong>Coup Critique:&nbsp;</strong> L'effet dure 4 tours."
      }
    ]
  },
  {
    "nom": "Sorts de Monstres",
    "description": "Sorts divers de monstres.",
    "sorts": []
  }
];
    window.CLASSES = [
  {
    "nom": "Guerrier",
    "resume": "HÃ©ros sans Ã©gal au combat au corp Ã  corp.",
    "capacites": "<ul><li><em>Expert de l'Ã©quipement</em> : Toutes les armes, armures (lÃ©gÃ¨res/lourdes), bouclier.</li><li><em>Hardiesse</em> : Gagne la compÃ©tence Hardiesse rang 1.</li></ul>",
    "sousClasses": [
      {
        "nom": "Nain des montagnes",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>5</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>2</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>7</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>1</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>5</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>1</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +2 Force ğŸ’ª, +3 Endurance ğŸ›¡ï¸, +1 VolontÃ©âš¡   <strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Brise rocher</em>: Gagne 1 de compÃ©tence sur les tests de compÃ©tence Hardiesse pour une destruction d'objet.</li><li><em>VolontÃ© inflexible</em>: Les nains possÃ¨dent une volontÃ© inflexible qui les rendent rÃ©sistants aux sortilÃ¨ges (caractÃ©ristique VolontÃ© Ã©levÃ©e).</li></ul>",
        "description": "<i>Race robuste et inflexible, dotÃ©e dâ€™une endurance exceptionnelle. ForgÃ©s par la roche et les sommets, ils rÃ©sistent aux Ã©preuves et possÃ¨dent une force colossale capable de briser murs, armures et crÃ©atures cuirassÃ©es.</i>"
      },
      {
        "nom": "Berserker",
        "base": {
          "Force": 5,
          "AgilitÃ©": 4,
          "Endurance": 5,
          "Intelligence": 1,
          "VolontÃ©": 1,
          "Chance": 1
        },
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +2 Force ğŸ’ª, +1 AgilitÃ© ğŸƒ, +2 Endurance ğŸ›¡ï¸<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Frappe en chaÃ®ne</em>: Sur un critique au corps Ã  corps, touche aussi un adversaire Ã  moins de 2m.</li><li><em>Risque sauvage</em>: +1 chance de critique physique s'il ne porte pas de bouclier.</li></ul>",
        "description": "<i>Combattant sauvage, maÃ®tre des armes Ã  deux mains. Sa rage dÃ©cuple sa force, lui permettant dâ€™abattre ses ennemis dans un dÃ©chaÃ®nement de puissance brute et de coups imparables.</i>"
      }
    ]
  },
  {
    "nom": "Mage",
    "resume": "SpÃ©cialiste de la magie destructrice.",
    "capacites": "<ul><li><em>Ã‰quipement de mage</em> : bÃ¢tons, robes.</li><li><em>Sorts de mage</em> : Apprend et lance des sorts de mage.</li></ul>",
    "sousClasses": [
      {
        "nom": "Ã‰rudit",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>1</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>1</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>1</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>6</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>3</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>1</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +3 Intelligence ğŸ§ , +2 VolontÃ© âš¡<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Instruit</em> : Gagne la compÃ©tence RÃ©flexion rang 1.</li><li><em>Apprentissage accÃ©lÃ©rÃ©</em> : Le niveau de l'Ã©rudit est considÃ©rÃ© comme deux fois plus Ã©levÃ© pour les prÃ©requis d'apprentissage de sorts.</li></ul>",
        "description": "<i>Mage avide de savoir, dotÃ© dâ€™une mÃ©moire prodigieuse. Il assimile les arcanes avec une rapiditÃ© fulgurante et maÃ®trise de nouveaux sorts bien plus vite que ses pairs.</i>"
      },
      {
        "nom": "Elfe",
        "base": {
          "Force": 2,
          "AgilitÃ©": 2,
          "Endurance": 3,
          "Intelligence": 3,
          "VolontÃ©": 2,
          "Chance": 1
        },
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +1 Force ğŸ’ª, +1 AgilitÃ© ğŸƒ, +1 Endurance ğŸ›¡ï¸, +1 Intelligence ğŸ§ , +1 VolontÃ© âš¡<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Instinct elfique</em> : Gagne la compÃ©tence Coordination rang 1.</li><li><em>Ã‰quipement d'elfe</em> : EpÃ©es Ã  une main, armures lÃ©gÃ¨res.</li><li><em>Briseur de sceaux</em> : Gagne 1 de compÃ©tence sur les tests de compÃ©tence pour comprendre ou ouvrir une porte scellÃ©e magiquement</li></ul>",
        "description": "<i>Guerrier-mage polyvalent, aussi agile quâ€™Ã©lÃ©gant. MaÃ®tre des arcanes comme du combat rapprochÃ©, il allie puissance magique et adresse martiale avec une grÃ¢ce inÃ©galÃ©e.</i>"
      }
    ]
  },
  {
    "nom": "PrÃªtre",
    "resume": "SpÃ©cialiste de la magie de soutien et anti morts-vivants.",
    "capacites": "<ul><li><em>Ã‰quipement de prÃªtre</em> : bÃ¢tons, robes.</li><li><em>Sorts de prÃªtre</em> : Apprend et lance des sorts de PrÃªtre.</li><li><em>Eloquence</em> : Gagne la compÃ©tence Eloquence rang 1.</li></ul>",
    "sousClasses": [
      {
        "nom": "Inquisiteur",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>3</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>1</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>4</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>3</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>5</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>1</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +1 Force ğŸ’ª, +1 Intelligence ğŸ§ , +2 VolontÃ© âš¡, +1 Endurance ğŸ›¡ï¸<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Port du bouclier</em> : Peut s'Ã©quiper d'un bouclier.</li><li><em>FlÃ©au des morts-vivants</em> : Les sorts visant les morts-vivants ne ratent jamais.</li><li><em>LumiÃ¨re purificatrice</em> : Double l'effet de l'intelligence sur les dÃ©gats des sorts d'Ã©lÃ©ment <span style=\"color: #ffd700; font-weight: bold;\">LumiÃ¨re</span> ou <span style=\"color: #f5f5f5; font-weight: bold; background: rgba(100, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;\">Divin</span>.</li></ul>",
        "description": "<i>Champion de la foi, il renforce ses alliÃ©s par la magie sacrÃ©e et traque sans relÃ¢che les morts-vivants. Quand la lumiÃ¨re seule ne suffit plus, il nâ€™hÃ©site pas Ã  prendre les armes et combattre en premiÃ¨re ligne.</i>"
      },
      {
        "nom": "Clerc Divin",
        "base": {
          "Force": 1,
          "AgilitÃ©": 1,
          "Endurance": 2,
          "Intelligence": 3,
          "VolontÃ©": 5,
          "Chance": 5
        },
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +2 Intelligence ğŸ§ , +2 VolontÃ© âš¡, +1 Chance ğŸ€<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>MaÃ®tre des soins</em> : Double l'effet de l'intelligence sur les sorts de soins.</li><li><em> Pieu </em>:  Gagne 1 de compÃ©tence sur les tests de compÃ©tence Reflexion sur un dieu ou une religion.</li><li><em> Protection divine </em>:  Dispose d'une armure Ã©lementaire <span style=\"color: #f5f5f5; font-weight: bold; background: rgba(100, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;\">Divin</span> de 10.</li></ul>",
        "description": "<i>Serviteur sacrÃ©, maÃ®tre des arts de guÃ©rison. Sa puissante magie de soins protÃ¨ge ses alliÃ©s et les relÃ¨ve mÃªme aux portes de la mort.</i>"
      }
    ]
  },
  {
    "nom": "RÃ´deur",
    "resume": "HÃ©ros trÃ¨s agile.",
    "capacites": "<ul><li><em>Ã‰quipement de rÃ´deur</em> : armures lÃ©gÃ¨res, dagues.</li><li><em>Coordination</em> : Gagne la compÃ©tence Coordination rang 1.</li></ul>",
    "sousClasses": [
      {
        "nom": "Voleur",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>3</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>5</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>2</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>2</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>2</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>5</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +2 AgilitÃ© ğŸƒ, +2 Force ğŸ’ª, +1 Endurance ğŸ›¡ï¸<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Mains expertes</em> : Gagne la compÃ©tence Finesse rang 1.</li><li><em>Sprint</em> : Peut utiliser une action secondaire pour doubler sa vitesse.</li><li><em>Vicieux</em> : Une fois par tour, permet d'effectuer une action secondaire supplÃ©mentaire aprÃ©s un coup critique d'une attaque physique au corps Ã  corps.</li></ul>",
        "description": "<i>MaÃ®tre de la finesse et de lâ€™agilitÃ©, il se dÃ©place avec rapiditÃ© fulgurante et frappe lÃ  oÃ¹ Ã§a fait le plus mal. </i>"
      },
      {
        "nom": "Chasseur",
        "base": {
          "Force": 3,
          "AgilitÃ©": 5,
          "Endurance": 2,
          "Intelligence": 4,
          "VolontÃ©": 2,
          "Chance": 1
        },
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +2 AgilitÃ© ğŸƒ, +1 Force ğŸ’ª, +1 Endurance ğŸ›¡ï¸, +1 Intelligence ğŸ§ <strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Armes du Chasseur</em> : Peut utiliser les arcs.</li><li><em>Cueillette</em> : Une fois par jour, lors dâ€™un repos, le personnage peut rÃ©colter 5 plantes locales (au choix du MJ). Leur efficacitÃ© dÃ©pend de lâ€™Intelligence de lâ€™utilisateur.</li><li><em>Connaissance de la faune et la flore</em> : Gagne 1 de compÃ©tence sur les tests de RÃ©flexion liÃ© Ã  animal, un monstre ou une plante.</li></ul>",
        "description": "<i>PrÃ©cis et agile, il complÃ¨te son art de lâ€™arc par la science des herbes anciennes.</i>"
      }
    ]
  },
  {
    "nom": "Enchanteur",
    "resume": "DÃ©tenteur d'une magie singuliÃ¨re, qui fait de lui un alliÃ© prÃ©cieux.",
    "capacites": "<ul><li><em>Ã‰quipement d'enchanteur</em> : robes, bÃ¢tons, baguettes.</li><li><em>Sorts d'enchanteur</em> : Apprend et lance des sorts d'Enchanteur.</li></ul>",
    "sousClasses": [
      {
        "nom": "Esprit de la grande FÃ©e",
        "base": "<div class=\"chips\"><span class=\"chip\">ğŸ’ª Force: <strong>1</strong></span><span class=\"chip\">ğŸƒ AgilitÃ©: <strong>5</strong></span><span class=\"chip\">ğŸ›¡ï¸ Endurance: <strong>2</strong></span><span class=\"chip\">ğŸ§  Intelligence: <strong>5</strong></span><span class=\"chip\">âš¡ VolontÃ©: <strong>2</strong></span><span class=\"chip\">ğŸ€ Chance: <strong>1</strong></span></div>",
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +1 AgilitÃ© ğŸƒ, +1 Intelligence ğŸ§ , +1 Endurance ğŸ›¡ï¸, +1 VolontÃ© âš¡, +1 Chance ğŸ€<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Tatillon</em> : Gagne la compÃ©tence Finesse rang 1.</li><li><em>LÃ©vitation</em> : ignore dÃ©gÃ¢ts/ralentissements venant du sol.</li><li><em>Rayon de l'AmitiÃ©</em> : Par une action secondaire, peut rÃ©pÃ©ter sur une autre cible Ã  portÃ©e un sort bÃ©nÃ©fique qui a ciblÃ© un alliÃ© se tour ci, sans coÃ»t en mana supplÃ©mentaire.</li></ul>",
        "description": "<i>ÃŠtre mystique qui flotte au-dessus du sol, il invoque des sorts imprÃ©visibles pour soutenir ses alliÃ©s.</i>"
      },
      {
        "nom": "Lutin",
        "base": {
          "Force": 1,
          "AgilitÃ©": 1,
          "Endurance": 1,
          "Intelligence": 5,
          "VolontÃ©": 2,
          "Chance": 5
        },
        "progression": "<strong>ğŸ“ˆ Progression par niveau:</strong> +1 Intelligence ğŸ§ , +2 VolontÃ© âš¡, +2 Chance ğŸ€<strong> +2 Au choix</strong>",
        "capacites": "<ul><li><em>Secrets bien gardÃ©s</em> : Gagne la compÃ©tence Reflexion rang 1.</li><li><em>Expert des baguettes</em> : Sur un critique Ã  la baguette, la charge n'est pas consommÃ©e.</li><li><em>Rire malicieux</em> : Par une action secondaire, peut rÃ©pÃ©ter sur une autre cible Ã  portÃ©e un sort d'altÃ©ration qui a ciblÃ© un enemi ce tour ci, sans coÃ»t en mana supplÃ©mentaire.</li></ul>",
        "description": "<i>Esprit espiÃ¨gle et rusÃ©, passÃ© maÃ®tre dans lâ€™art des altÃ©rations magiques. </i>"
      }
    ]
  }
];
    window.DONS = [
  {
    "nom": "Generaux",
    "description": "Dons accessibles Ã  toutes les classes.",
    "dons": [
      {
        "nom": "DouÃ©",
        "description": "Gagne une compÃ©tence rang 1.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 points de don"
      },
      {
        "nom": "Toujours pret",
        "description": "Le maximum d'efforts passe Ã  4.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Brillant",
        "description": "Gagne une compÃ©tence rang 2.",
        "prerequis": "<strong> PrÃ©requis :</strong> La compÃ©tence rang 1.",
        "cout": "2 points de don"
      },
      {
        "nom": "Prodigieux",
        "description": "Gagne une compÃ©tence rang 3.",
        "prerequis": "<strong> PrÃ©requis :</strong> La compÃ©tence rang 2.",
        "cout": "3 point de don"
      },
      {
        "nom": "Hyperactif",
        "description": "Le hÃ©ros dispose maintenant de deux actions secondaires par tour.",
        "prerequis": "<strong> PrÃ©requis :</strong> Niveau 3",
        "cout": "2 points de don"
      },
      {
        "nom": "Equitation",
        "description": "Permet de monter Ã  cheval ou Ã©quivalent.",
        "prerequis": "<strong> PrÃ©requis :</strong> Niveau 5",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Guerrier",
    "description": "Dons accessibles aux guerriers.",
    "dons": [
      {
        "nom": "Expertise du bouclier",
        "description": "Si le hÃ©ros a un bouclier Ã©quipÃ©, il peut utiliser une action secondaire pour doubler l'armure physique du bouclier jusqu'au prochain tour.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Charge",
        "description": "Une fois par combat, peut utiliser une action secondaire pour doubler sa vitesse de dÃ©placement et forcer un coup critique sur la prochaine attaque physique de ce tour (si elle rÃ©ussie).",
        "prerequis": "<strong> PrÃ©requis :</strong> ğŸƒAgilitÃ© 5",
        "cout": "1 point de don"
      },
      {
        "nom": "VolontÃ© de fer",
        "description": "Une fois par jour, le hÃ©ros peut utiliser une action secondaire pour se dÃ©barasser de toutes ses alterations magiques.",
        "prerequis": "<strong> PrÃ©requis :</strong> âš¡VolontÃ© 5",
        "cout": "1 point de don"
      },
      {
        "nom": "Coup de bouclier",
        "description": "Si le hÃ©ros a un bouclier Ã©quipÃ©, lorsque le hÃ©ros subit des dÃ©gats aux corps Ã  corps, il peut choisir d'utiliser une action secondaire pour infliger Ã  l'attaquant des dÃ©gats Ã©quivalents Ã  l'armure du bouclier.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "RÃ´deur",
    "description": "Description de cette catÃ©gorie de dons.",
    "dons": [
      {
        "nom": "Croche-patte",
        "description": "Peut utiliser une action secondaire pour mettre un adversaire au corp Ã  corp, de moins de 2m, dans l'Ã©tat <span title=\"Ne peut plus faire d'actions.\n Ne peut plus esquiver.\n Doit dÃ©penser une action secondaire pour se relever.\">Ã  terre</span>.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Chasse et pÃªche",
        "description": "Le hÃ©ros n'as plus besoin de sa ratio de nourriture quotidienne.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Mage",
    "description": "Description de cette catÃ©gorie de dons.",
    "dons": [
      {
        "nom": "Gemme de mana",
        "description": "Une fois par jour, le hÃ©ros peut rÃ©cupÃ©rer l'intÃ©gralitÃ© de son Mana en utilisant une action secondaire.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Resistance Ã©lÃ©mentaire 1",
        "description": "Le hÃ©ros gagne 5 d'armure Ã©lÃ©mentaire de <span style=\"color: #e25822; font-weight: bold;\">Feu</span>, <span style=\"color: #2b6cb0; font-weight: bold;\">Eau</span>, <span style=\"color: #8b5e34; font-weight: bold;\">Terre</span>, <span style=\"color: #22c55e; font-weight: bold;\">Air</span>.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Resistance magique 1",
        "description": "Le hÃ©ros gagne 5 d'armure Ã©lÃ©mentaire de <span style=\"color: #ffd700; font-weight: bold;\">LumiÃ¨re</span>, <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span>, <span style=\"color: #d0d0d0; font-weight: bold; background: rgba(0, 0, 0, 0.4); padding: 2px 4px; border-radius: 3px;\">Divin</span>, <span style=\"color: #a855f7; font-weight: bold;\">MalÃ©fique</span>.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "SpÃ©cialisation Ã©lÃ©mentaire 1",
        "description": "Le hÃ©ros peut choisir un Ã©lÃ©ment et augmenter de 5 les dÃ©gats infligÃ©s avec les sorts de cet Ã©lÃ©ment.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Infusion Ã©lÃ©mentaire",
        "description": "AprÃ©s avoir lancÃ© un sort, le hÃ©ros peut, en utilisant une action secondaire, imprÃ©gner son arme de l'Ã©lÃ©ment du sort. Elle infligera Ã  sa prochaine attaque des dÃ©gats de cet Ã©lÃ©ment Ã©quivalents au niveau du sort.",
        "prerequis": "<strong> PrÃ©requis :</strong> -",
        "cout": "1 point de don"
      },
      {
        "nom": "Polyglotte",
        "description": "Peut lire et parler toutes les langues.",
        "prerequis": "<strong> PrÃ©requis :</strong> Reflexion rang 2.",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Pretre",
    "description": "Description de cette catÃ©gorie de dons.",
    "dons": [
      {
        "nom": "MÃ©crÃ©ants",
        "description": "Les dÃ©gats physiques infligÃ©s aux crÃ©atures de l'Ã©lÃ©ment <span style=\"color: #0f172a; font-weight: bold;\">Nuit</span> ou <span style=\"color: #a855f7; font-weight: bold;\">MalÃ©fique</span> sont doublÃ©s.",
        "prerequis": "<strong> PrÃ©requis :</strong>-",
        "cout": "1 point de don"
      },
      {
        "nom": "Au milieu du combat",
        "description": "Permet de porter une armure lÃ©gÃ¨re.",
        "prerequis": "<strong> PrÃ©requis :</strong>ğŸ’ªForce 5",
        "cout": "2 point de don"
      },
      {
        "nom": "Jugement Ã©clair",
        "description": "Si le PrÃªtre a effectuÃ© un sort ce tour ci, il peut effectuer une attaque au corp Ã  corp avec une action secondaire.",
        "prerequis": "<strong> PrÃ©requis :</strong>ğŸ’ªForce 3",
        "cout": "1 point de don"
      },
      {
        "nom": "Musique",
        "description": "Permet d'apprendre un instrument de musique (ou de savoir chanter) au choix, gagnant 2 de compÃ©tences sur les tests de compÃ©tence Ã©loquence le nÃ©cÃ©ssitant.",
        "prerequis": "<strong> PrÃ©requis :</strong>-",
        "cout": "1 point de don"
      }
    ]
  },
  {
    "nom": "Enchanteur",
    "description": "Dons accessibles aux enchanteurs.",
    "dons": [
      {
        "nom": "RÃ©parateur de baguettes",
        "description": "Permet de regagner une charge de baguette, une fois par jour.",
        "prerequis": "<strong> PrÃ©requis :</strong>-",
        "cout": "1 point de don"
      },
      {
        "nom": "Magie alÃ©atoire destructrice",
        "description": "Permet de choisir et d'apprendre un sort de mage et de pouvoir le lancer Ã  volontÃ©. Le sort ne peut pas Ãªtre changÃ© par la suite.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Magie alÃ©atoire de soutien",
        "description": "Permet de choisir et d'apprendre un sort de prÃªtre et de pouvoir le lancer Ã  volontÃ©. Le sort ne peut pas Ãªtre changÃ© par la suite.",
        "prerequis": "<strong> PrÃ©requis :</strong> Don unique.",
        "cout": "1 point de don"
      },
      {
        "nom": "Alteration risquÃ©e",
        "description": "Lorsque un sort d'alteration magique est effectuÃ© alors que la cible est au corps Ã  corps, ses chances de critiques sont doublÃ©es.",
        "prerequis": "<strong> PrÃ©requis :</strong>-",
        "cout": "1 point de don"
      }
    ]
  }
];
    window.OBJETS = {
  "objets": [
    {
      "nom": "Ã‰pÃ©e Longue",
      "numero": 1,
      "image": "",
      "description": "Une Ã©pÃ©e longue classique, arme de prÃ©dilection des guerriers.",
      "tags": [
        "Arme",
        "MÃªlÃ©e"
      ],
      "effet": "<strong>DÃ©gÃ¢ts:</strong> 1d8 + Force<br><strong>Type:</strong> Tranchant",
      "prix": "ğŸ’° <strong>Prix:</strong> 50 po",
      "poids": "âš–ï¸ <strong>Poids:</strong> 1,5 kg"
    },
    {
      "nom": "Armure de Cuir",
      "numero": 2,
      "image": "",
      "description": "Une armure lÃ©gÃ¨re en cuir souple, offrant protection et mobilitÃ©.",
      "tags": [
        "Armure",
        "LÃ©gÃ¨re"
      ],
      "effet": "<strong>CA:</strong> 11 + Dex<br><strong>FurtivitÃ©:</strong> Pas de dÃ©savantage",
      "prix": "ğŸ’° <strong>Prix:</strong> 25 po",
      "poids": "âš–ï¸ <strong>Poids:</strong> 5 kg"
    },
    {
      "nom": "Potion de Soin",
      "numero": 3,
      "image": "",
      "description": "Une fiole contenant un liquide rouge qui soigne les blessures.",
      "tags": [
        "Consommable",
        "Magique"
      ],
      "effet": "<strong>Effet:</strong> Restaure 2d4+2 points de vie",
      "prix": "ğŸ’° <strong>Prix:</strong> 100 po",
      "poids": "âš–ï¸ <strong>Poids:</strong> 0,2 kg"
    }
  ],
  "filterSettings": {
    "visibleTags": [
      "Arme",
      "Armure",
      "Consommable"
    ]
  }
};
    window.MONSTRES = [];
    window.IMAGES = {
  "images": {
    "subclass:Guerrier:Nain des montagnes": "https://i.ibb.co/Zpv02X9p/e8c10c36dc90.jpg",
    "subclass:Guerrier:Berserker": "https://i.ibb.co/DPYjyGVd/b85000c2afa4.jpg",
    "subclass:Mage:Ã‰rudit": "https://i.ibb.co/M5pcNmF9/05fa4e535010.jpg",
    "subclass:Mage:Elfe": "https://i.ibb.co/K1SMkgb/d738588e0528.jpg",
    "subclass:PrÃªtre:Inquisiteur": "https://i.ibb.co/dJ02RNMc/c9cd3553df7e.jpg",
    "subclass:PrÃªtre:Clerc Divin": "https://i.ibb.co/8gFGZYqJ/698304cc75ee.jpg",
    "subclass:RÃ´deur:Voleur": "https://i.ibb.co/q3jSxDnQ/90e89c692b47.jpg",
    "subclass:RÃ´deur:Chasseur": "https://i.ibb.co/70wP75z/53de7da9e55c.jpg",
    "subclass:Enchanteur:Esprit de la grande FÃ©e": "https://i.ibb.co/Cswfsyzz/9920a4e75242.jpg",
    "subclass:Enchanteur:Lutin": "https://i.ibb.co/Fbspq9hP/dd5e7b366e0f.jpg",
    "sort:Sorts de Mage:Boule de Feu": "https://i.ibb.co/vCWmgrQ5/Boule-De-Feu.png",
    "sort:Sorts de Mage:Ã‰clair": "https://i.ibb.co/h194qhvd/Eclair.png",
    "sort:Sorts de Mage:Vague dÃ©ferlante": "https://i.ibb.co/BSHtL8K/Vague.png",
    "sort:Sorts de PrÃªtre:ChÃ¢timent": "https://i.ibb.co/JRPyXx1L/Chatiment-Sacr.png",
    "sort:Sorts de PrÃªtre:Soin mineur": "https://i.ibb.co/YBC2HSnK/Soin-Mineur.png",
    "sort:Sorts d'Enchanteur:Accroche terrestre": "https://i.ibb.co/27W4NtSQ/Accroche-Terre.png",
    "sort:Sorts d'Enchanteur:AccÃ©lÃ©ration": "https://i.ibb.co/Vc072qQB/Acceleration.png",
    "sort:Sorts d'Enchanteur:Sommeil": "https://i.ibb.co/rKyTh27C/Sleep.png",
    "sort:Sorts de PrÃªtre:Nouveau Sort": "https://i.ibb.co/cXh57Pdn/ArmeLum.png",
    "sort:Sorts de PrÃªtre:Protection": "https://i.ibb.co/QvK52kxH/Protection.png",
    "subclass:Guerrier:Nain des montagnes:1": "https://i.ibb.co/FL9m5HJn/Nain.png",
    "subclass:Guerrier:Nain des montagnes:2": "https://i.ibb.co/wNnJxSbj/NaineF.png",
    "subclass:Guerrier:Berserker:1": "https://i.ibb.co/YBWFbTKv/berseker.png",
    "subclass:Guerrier:Berserker:2": "https://i.ibb.co/20b74x2R/Berseker-F.png",
    "subclass:Mage:Ã‰rudit:1": "https://i.ibb.co/N8qT2Hf/Mage.png",
    "subclass:Mage:Ã‰rudit:2": "https://i.ibb.co/LdcPDSJQ/MageF.png",
    "subclass:Mage:Elfe:2": "https://i.ibb.co/VWDTjY8H/ElfeF.png",
    "subclass:Mage:Elfe:1": "https://i.ibb.co/gFVKrTcV/Elfe.png",
    "subclass:PrÃªtre:Inquisiteur:1": "https://i.ibb.co/tMcsCB8s/Inquisiteur.png",
    "subclass:PrÃªtre:Clerc Divin:1": "https://i.ibb.co/209W4ZHW/Pr-tre.png",
    "subclass:RÃ´deur:Voleur:1": "https://i.ibb.co/NghMq11n/Voleur-min.png",
    "subclass:RÃ´deur:Voleur:2": "https://i.ibb.co/h1BtkGMX/VoleurF.png",
    "subclass:RÃ´deur:Chasseur:1": "https://i.ibb.co/yF8jrJYr/Chasseur-min.png",
    "subclass:RÃ´deur:Chasseur:2": "https://i.ibb.co/3mQjLJbp/Chasseur-F.png",
    "subclass:Enchanteur:Esprit de la grande FÃ©e:1": "https://i.ibb.co/VY9cQHNh/F-eM.png",
    "subclass:Enchanteur:Esprit de la grande FÃ©e:2": "https://i.ibb.co/pjxDfXBC/F-e.png",
    "subclass:Enchanteur:Lutin:1": "https://i.ibb.co/6cxkMW1d/Lutin.png",
    "subclass:Enchanteur:Lutin:2": "https://i.ibb.co/qLbjJhxw/LutinF.png",
    "subclass:PrÃªtre:Inquisiteur:2": "https://i.ibb.co/LXwmWYR3/Inquisiteur-F.png",
    "subclass:PrÃªtre:Clerc Divin:2": "https://i.ibb.co/HfBVNLM3/PretreF.png",
    "sort:Sorts de PrÃªtre:Arme de lumiÃ¨re": "https://i.ibb.co/cXh57Pdn/ArmeLum.png"
  },
  "meta": {
    "total_images": 41,
    "exported_date": "2025-08-21",
    "note": "Ces images incluent les nouvelles images uploadÃ©es"
  }
};
    
    // TOC Structure for advanced navigation
    window.TOC_STRUCTURE = {
  "sections": [
    {
      "id": "heros",
      "title": "ğŸ¦¸ HÃ©ros",
      "icon": "ğŸ¦¸",
      "description": "CrÃ©ation et dÃ©veloppement des personnages",
      "collapsed": false,
      "items": [
        {
          "type": "page",
          "id": "creation",
          "title": "CrÃ©ation d'un personnage",
          "icon": "ğŸ­"
        },
        {
          "type": "category",
          "id": "classes",
          "title": "Classes",
          "icon": "âš”ï¸",
          "items": "CLASSES"
        },
        {
          "type": "category",
          "id": "dons",
          "title": "Dons",
          "icon": "ğŸ–ï¸",
          "items": "DONS"
        }
      ]
    },
    {
      "id": "arsenal",
      "title": "âš”ï¸ Arsenal",
      "icon": "âš”ï¸",
      "description": "Sorts, objets et Ã©quipements",
      "collapsed": false,
      "items": [
        {
          "type": "category",
          "id": "sorts",
          "title": "Sorts",
          "icon": "ğŸ”®",
          "items": "SORTS"
        },
        {
          "type": "page",
          "id": "objets",
          "title": "Objets",
          "icon": "ğŸ“¦"
        }
      ]
    },
    {
      "id": "regles",
      "title": "ğŸ“š RÃ¨gles",
      "icon": "ğŸ“š",
      "description": "MÃ©caniques de jeu et rÃ©fÃ©rences",
      "collapsed": false,
      "items": [
        {
          "type": "page",
          "id": "elements",
          "title": "Ã‰lÃ©ments",
          "icon": "ğŸŒŸ"
        },
        {
          "type": "page",
          "id": "stats",
          "title": "Statistiques",
          "icon": "ğŸ“Š"
        },
        {
          "type": "page",
          "id": "competences-tests",
          "title": "CompÃ©tences & Tests",
          "icon": "ğŸ¯"
        },
        {
          "type": "page",
          "id": "etats",
          "title": "Ã‰tats",
          "icon": "âš¡"
        }
      ]
    },
    {
      "id": "maitre-de-jeu",
      "title": "ğŸ­ MaÃ®tre de jeu",
      "icon": "ğŸ­",
      "description": "Outils et ressources pour le MaÃ®tre de jeu",
      "collapsed": false,
      "requiresMJ": true,
      "items": [
        {
          "type": "category",
          "id": "monstres",
          "title": "Monstres",
          "icon": "ğŸ‘¹",
          "items": "MONSTRES"
        }
      ]
    }
  ]
};
    
    // Build STATIC_PAGES correctly by combining individual page data
    window.STATIC_PAGES = {
      'creation': {
  "page": "creation",
  "title": "CrÃ©ation d'un personnage",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": "",
      "id": "section-0"
    },
    {
      "type": "card",
      "id": "etapes-creation",
      "title": "Ã‰tapes de crÃ©ation",
      "content": "<ol><li>Choisir une <strong>classe</strong> puis une <strong>sousâ€‘classe</strong>.</li><li>Choisir un <strong>Ã©lÃ©ment</strong> d'affiliation.</li><li>Choisir les <strong>dons</strong> (avec 2 points de dons).</li><li>Choisir l'<strong>Ã©quipement</strong> de dÃ©part (avec 100 Ã©clats).</li><li>Choisir un <strong>mÃ©tier</strong>.</li><li>DÃ©finir le <strong>nom</strong>, l'<strong>histoire</strong> et l'<strong>apparence</strong>.</li><li>Remplir sa feuille de personnage.</li></ol>",
      "deletable": true,
      "sectionName": "Ã‰tapes de crÃ©ation"
    }
  ]
},
      'elements': {
  "page": "elements",
  "title": "Elements",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "elements-system",
      "title": "SystÃ¨me d'Ã©lÃ©ments",
      "content": "<p>Il existe huit Ã©lÃ©ments, chacun ayant un opposÃ©. ChaquÃ© HÃ©ros oÃ¹ monstre possÃ¨de un Ã©lÃ©ment d'affiliation.<br><br> Une crÃ©ature affiliÃ©e Ã  un Ã©lÃ©ment :<br> - ReÃ§oit <strong>deux fois moins </strong>de dÃ©gats venant des sorts et attaques de cet Ã©lÃ©ment, et ne peut pas recevoir d'effet critique d'une alteration magique de cet Ã©lÃ©ment.<br>- Recevra systÃ©matiquement des <strong>effets critiques</strong> venant des sorts et altÃ©rations de l'Ã©lÃ©ment opposÃ©.</p>"
    },
    {
      "type": "card",
      "id": "element-pairs",
      "title": "Paires opposÃ©es",
      "content": "<div class=\"element-pairs\"><div class=\"pair\">ğŸ”¥ <span style=\"color: #ff6b35; font-weight: bold;\">Feu</span> âŸ· ğŸ’§ <span style=\"color: #4682b4; font-weight: bold;\">Eau</span></div><div class=\"pair\">ğŸ¤ <span style=\"color: #8b4513; font-weight: bold;\">Terre</span> âŸ· ğŸŸ¢ <span style=\"color: #22c55e; font-weight: bold;\">Air</span></div><div class=\"pair\">â˜€ï¸ <span style=\"color: #ffd700; font-weight: bold;\">LumiÃ¨re</span> âŸ· âš« <span style=\"color: #1a1a1a; font-weight: bold;\">Nuit</span></div><div class=\"pair\">âšª <span style=\"color: #f5f5f5; font-weight: bold; background: rgba(100, 100, 100, 0.3); padding: 2px 4px; border-radius: 3px;\">Divin</span> âŸ· ğŸŸ£ <span style=\"color: #8b5cf6; font-weight: bold;\">MalÃ©fique</span></div></div>"
    },
    {
      "type": "grid",
      "cols": 2,
      "content": [
        {
          "type": "card",
          "id": "element-defense",
          "title": "DÃ©fense",
          "content": "<p>Certaines armures/objets/bonus peuvent procurer une armure spÃ©cifique Ã  un Ã©lÃ©ment. Il faudra alors dÃ©duire au resultat final. Le calcul de dÃ©gats se fait dans cet ordre :</p><div><strong>DÃ©gats â†’ critique â†’ Ã—0.5 si affiliation Ã©lÃ©ment â†’ rÃ©duction de l'armure</strong></div>",
          "deletable": true,
          "sectionName": "DÃ©fense"
        },
        {
          "type": "card",
          "id": "element-attack",
          "title": "Attaque",
          "content": "<p>Une attaque ne peut avoir qu'<strong>un seul Ã©lÃ©ment</strong> (en plus d'Ã©ventuels dÃ©gats physiques). Si plusieurs sorts/Ã©quipements/bonus donnent un Ã©lÃ©ment Ã  l'attaque, le hÃ©ros devra choisir quel est l'Ã©lÃ©ment utilisÃ©.</p> <br> Plusieurs bonus d'un mÃªme Ã©lÃ©ment peuvent se cumuler.",
          "deletable": true,
          "sectionName": "Attaque"
        }
      ]
    }
  ]
},
      'stats': {
  "page": "stats",
  "title": "Statistiques",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "stats-base",
      "title": "Statistiques de base",
      "content": "<hr><div class=\"stats-grid\"><div class=\"stat-card\"><h4>ğŸ’ª Force</h4><p>AmÃ©liore les dÃ©gÃ¢ts physiques.</p></div><hr><div class=\"stat-card\"><h4>ğŸ›¡ï¸ Endurance</h4><p>Les points de vie maximum sont de : <strong>(10 + 2 x Endurance)</strong></p><p>Un repos rÃ©gÃ©nÃ¨re des points de vie Ã©gaux Ã  l'endurance</p></div><hr><div class=\"stat-card\"><h4>ğŸƒ AgilitÃ©</h4><p>Chaque 5 points ajoutent <strong>+1</strong> aux jets d'esquive et de critique physique.</p></div><hr><div class=\"stat-card\"><h4>ğŸ§  Intelligence</h4><p>DÃ©termine la puissance des sorts.</p></div><hr><div class=\"stat-card\"><h4>âš¡ VolontÃ©</h4><p>Le mana maximum est de : <strong>(20 + 2 x VolontÃ©)</strong></p><p>Augmente la RÃ©sistance altÃ©rations.</p></div><hr><div class=\"stat-card\"><h4>ğŸ€ Chance</h4><p>AmÃ©liore le butin des coffres et les Ã©vÃ©nements alÃ©atoires.</p><p>Chaque 5 points ajoutent <strong>+1</strong> aux chances de coup critique avec les sorts et les baguettes.</p></div></div>",
      "deletable": true,
      "sectionName": "Statistiques de base"
    },
    {
      "type": "card",
      "id": "stats-new-3-1755784997112",
      "title": "Statistiques secondaires",
      "content": "<hr><br><br><strong>Chance de coup critique </strong> : blabla.<br><hr><br><strong>Esquive </strong> : blablabla.<br><hr><br><strong>RÃ©sistance altÃ©rations </strong> : blablabla.<br><hr><br><strong>Armure physique </strong> : blablabla.<br><hr><br><strong>Armure Ã©lÃ©mentaire </strong> : blablabla.<br><hr><br><strong>Mana </strong> : blablabla.<br><hr><br><strong>Vie </strong> : blablabla.<br><hr><br>",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
},
      'competences-tests': {
  "page": "competences-tests",
  "title": "CompÃ©tences & Tests",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "grid",
      "cols": 2,
      "content": [
        {
          "type": "card",
          "id": "efforts",
          "title": "Efforts",
          "content": "<ul><li>Chaque hÃ©ros dispose de 3 Efforts maximum.</li><li>Les hÃ©ros rÃ©cupÃ¨rent des efforts lors de repos courts ou longs.</li><li>Les Efforts peuvent Ãªtre dÃ©pensÃ©s pour amÃ©liorer un test de compÃ©tence.</li></ul>",
          "deletable": true,
          "sectionName": "Efforts"
        },
        {
          "type": "card",
          "id": "competences-list",
          "title": "CompÃ©tences",
          "content": "<ul><li><em>Hardiesse</em>: Pousser, casser, sauterâ€¦</li><li><em>Finesse</em>: Crocheter, fabriquer, Ãªtre discretâ€¦</li><li><em>Coordination</em>: Percevoir, Ã©quilibre, piloterâ€¦</li><li><em>RÃ©flexion</em>: Savoir, comprendre, devinerâ€¦</li><li><em>Ã‰loquence</em>: Persuader, mentir, intimiderâ€¦</li></ul>",
          "deletable": true,
          "sectionName": "CompÃ©tences"
        }
      ]
    },
    {
      "type": "card",
      "id": "tests",
      "title": "Tests de compÃ©tences",
      "content": "<p>Quand un MJ annonce un test de compÃ©tence, un hÃ©ros peut choisir de dÃ©penser des efforts pour booster sa compÃ©tence. La difficultÃ© d'un test est seule connue du MJ, et est entre 1 et 5 (Exigeant, Complexe , Ã‰prouvant, Prodigieux , <strong>Impossible</strong>).</p><p>Une fois le test rÃ©solu, le MaÃ®tre de Jeu annonce le rÃ©sultat. Si le joueur a dÃ©pensÃ© plus d'Efforts que nÃ©cessaire, l'excÃ©dent est perdu.</p><br> A noter que certaines actions sont impossibles Ã  rÃ©aliser et un hÃ©ros peut alors s'Ã©puiser pour rien, s'il n'a pas bien Ã©valuÃ© la difficultÃ© de la tÃ¢che. A l'inverse, les tÃ¢ches simples ne demandent pas de test de compÃ©tences.",
      "deletable": true,
      "sectionName": "Tests de compÃ©tences"
    }
  ]
},
      'etats': {
  "page": "etats",
  "title": "Etats",
  "static": true,
  "sections": [
    {
      "type": "intro",
      "content": ""
    },
    {
      "type": "card",
      "id": "a-terre",
      "title": "A terre",
      "content": "<p>Ne peut plus faire d'actions.</p><p> Ne peut plus esquiver.</p><p> Doit dÃ©penser une action secondaire pour se relever.</p>",
      "deletable": true,
      "sectionName": "A terre"
    },
    {
      "type": "card",
      "id": "endormi-effraye",
      "title": "Endormi/assomÃ©/EffrayÃ©",
      "content": "<p>Ne peut plus faire d'actions.</p><p> Ne peut plus esquiver.</p><p> Des dÃ©gats infligÃ©s Ã  la crÃ©ature la sort de son Ã©tat.</p>",
      "deletable": true,
      "sectionName": "Endormi/assomÃ©/EffrayÃ©"
    },
    {
      "type": "card",
      "id": "etats-new-4-1755725440741",
      "title": "Ralenti",
      "content": "Vitesse de dÃ©placement rÃ©duite de moitiÃ©.<br> Impossible de sauter ou d'esquiver.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-5-1755762657383",
      "title": "EmpoisonnÃ©",
      "content": "Des dÃ©gats sont appliquÃ©s Ã  chaque dÃ©but de tour du lanceur, rÃ©duits ni par l'armure physique ni par l'armure Ã©lÃ©mentaire.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-6-1755762796465",
      "title": "EntravÃ©/EntoilÃ©/EmbourbÃ©",
      "content": "<p>Ne peut plus faire d'actions.</p><p>Ne peut plus esquiver.</p> Le hÃ©ros ou un alliÃ© peut sortir le hÃ©ros de l'Ã©tat via un test de compÃ©tence hardiesse.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    },
    {
      "type": "card",
      "id": "etats-new-7-1755762977439",
      "title": "Affaibli",
      "content": "Les dÃ©gats physiques effectuÃ©s sont rÃ©duits de moitiÃ©s. Les tests de hardiesse ont une difficultÃ© de 2 plus Ã©levÃ©s.",
      "deletable": true,
      "sectionName": "Nouvelle section"
    }
  ]
}
    };
    
    // Static pages configuration
    window.STATIC_PAGES_CONFIG = {};
    
    // Mark as standalone version for renderer
    window.STANDALONE_VERSION = true;
    
    // Initialize app when DOM is ready
    document.addEventListener('DOMContentLoaded', function() {
      // Ensure dev mode is off
      document.body.className = 'dev-off';
      
      // Wait a bit to ensure all modules are loaded
      setTimeout(function() {
        // Initialize JdrApp if it exists
        if (window.JdrApp && window.JdrApp.init) {
          console.log('Initializing JdrApp...');
          window.JdrApp.init();
        } else {
          console.error('JdrApp not found!', window.JdrApp);
        }
      }, 100);
    });
  
// ============================================================================
// JDR-BAB APPLICATION - CORE MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // MAIN APPLICATION NAMESPACE
  // ========================================
  window.JdrApp = {
    // Core data
    data: {
      SORTS: null,
      CLASSES: null,
      DONS: null,
      OBJETS: null,
      MONSTRES: null,
      STATIC_PAGES: {},
      editedData: {}
    },
    
    // Application state
    state: {
      isMJ: false // Boolean pour contrÃ´ler l'accÃ¨s MJ
    },
    
    // Core modules
    modules: {
      router: {},
      renderer: {},
      editor: {},
      storage: {},
      images: {}
    },
    
    // Utilities
    utils: {
      dom: {},
      events: {},
      data: {}
    },

    // Initialization
    async init() {
      try {
        await this.loadData();
        await this.loadContent();
        this.initializeModules();
      } catch (error) {
        console.error('Failed to initialize JdrApp:', error);
      }
    },

    async loadData() {
      try {
        // Check if we're in standalone mode (data already injected)
        if (window.SORTS && window.CLASSES && window.DONS && window.OBJETS && window.STATIC_PAGES) {
          const sorts = window.SORTS;
          const classes = window.CLASSES;
          const dons = window.DONS;
          const objets = window.OBJETS;
          const monstres = window.MONSTRES || [];
          const staticPagesData = window.STATIC_PAGES;
          const staticPagesConfig = window.STATIC_PAGES_CONFIG || {};
          
          this.data.SORTS = sorts;
          this.data.CLASSES = classes;
          this.data.DONS = dons;
          this.data.OBJETS = objets;
          this.data.MONSTRES = monstres;
          this.data.STATIC_PAGES = staticPagesData;
          this.data.STATIC_PAGES_CONFIG = staticPagesConfig;
          
          window.SORTS = sorts;
          window.CLASSES = classes;
          window.DONS = dons;
          window.OBJETS = objets;
          window.MONSTRES = monstres;
          window.STATIC_PAGES = staticPagesData;
          window.STATIC_PAGES_CONFIG = staticPagesConfig;
          
          // Load stored edits AFTER setting up the data structure
          this.loadStoredEditsEarly();
          return;
        }
        
        // Development mode - fetch files
        const [sorts, classes, dons, objets, monstres, staticPagesConfig, tocStructure] = await Promise.all([
          fetch('data/sorts.json').then(r => r.json()),
          fetch('data/classes.json').then(r => r.json()),
          fetch('data/dons.json').then(r => r.json()),
          fetch('data/objets.json').then(r => r.json()),
          fetch('data/monstres.json').then(r => r.json()),
          fetch('data/static-pages-config.json').then(r => r.json()),
          fetch('data/toc-structure.json').then(r => r.json())
        ]);

        const staticPagesData = {};
        const activePages = staticPagesConfig.pages.filter(page => page.active);
        
        for (const pageConfig of activePages) {
          try {
            const pageData = await fetch(`data/${pageConfig.file}`).then(r => r.json());
            staticPagesData[pageConfig.id] = pageData;
          } catch (error) {
            console.warn(`Failed to load static page ${pageConfig.id}:`, error);
          }
        }

        this.data.SORTS = sorts;
        this.data.CLASSES = classes;
        this.data.DONS = dons;
        this.data.OBJETS = objets;
        this.data.MONSTRES = monstres;
        this.data.STATIC_PAGES = staticPagesData;
        this.data.STATIC_PAGES_CONFIG = staticPagesConfig;
        this.data.TOC_STRUCTURE = tocStructure;

        window.SORTS = sorts;
        window.CLASSES = classes;
        window.DONS = dons;
        window.OBJETS = objets;
        window.MONSTRES = monstres;
        window.STATIC_PAGES = this.data.STATIC_PAGES;
        window.STATIC_PAGES_CONFIG = this.data.STATIC_PAGES_CONFIG;
        window.TOC_STRUCTURE = this.data.TOC_STRUCTURE;
        
        // Load stored edits in development mode (after data is loaded)
        this.loadStoredEditsEarly();
      } catch (error) {
        console.error('Failed to load data:', error);
        throw error;
      }
    },

    async loadContent() {
      try {
        const viewsDiv = document.getElementById('views');
        if (viewsDiv) {
          const loadingDiv = document.getElementById('app-loading');
          if (loadingDiv) {
            loadingDiv.innerHTML = '<!-- Content will be generated by renderer -->';
          }
        } else {
          const contentHTML = await this.getContentHTML();
          const loadingDiv = document.getElementById('app-loading');
          if (loadingDiv) {
            loadingDiv.outerHTML = contentHTML;
          }
        }
      } catch (error) {
        console.error('Failed to load content:', error);
        throw error;
      }
    },

    async getContentHTML() {
      // This would ideally load from a separate HTML file
      // For now, we'll return the content structure
      return `
        <div class="shell">
          <button aria-controls="sidebar" aria-expanded="false" aria-label="Ouvrir le sommaire" class="menu-toggle" id="menuToggle" style="display:none">â˜° Sommaire</button>
          <div class="backdrop" hidden="" id="backdrop"></div>
          <main class="page">
            <aside class="sidebar" id="sidebar">
              <div class="panel">
                <div class="searchbar">
                  <input autocomplete="off" id="search" placeholder="Rechercher une rÃ¨gle, une classeâ€¦">
                  <button class="btn" id="clear" title="Effacer">âœ–</button>
                </div>
                <div class="tools">
                  <button class="btn small" id="devToggle" title="Activer/dÃ©sactiver le mode dÃ©veloppeur">ğŸ›  Dev Mode: OFF</button>
                </div>
                <div class="dev-toolbox" id="devToolbox" style="display: none;">
                  <!-- Dev toolbox content will be injected here -->
                </div>
                <div class="toc" id="toc">
                  <!-- Table of contents will be injected here -->
                </div>
              </div>
            </aside>
            <div id="views">
              <!-- Dynamic content will be injected here -->
            </div>
          </main>
          <footer></footer>
        </div>
      `;
    },

    // Load stored edits early in the loading process (before rendering)
    loadStoredEditsEarly() {
      // Ne plus charger automatiquement le localStorage
      // Laisser les JSON files Ãªtre la source de vÃ©ritÃ©
    },

    initializeModules() {
      if (this.utils.events.init) this.utils.events.init();
      if (this.utils.dom.init) this.utils.dom.init();
      if (this.modules.images.init) this.modules.images.init();
      if (this.modules.renderer.init) this.modules.renderer.init();
      if (this.modules.router.init) this.modules.router.init();
      if (this.modules.editor.init) this.modules.editor.init();
      if (this.modules.storage.init) this.modules.storage.init();
      if (this.modules.ui.init) this.modules.ui.init();
    },

    // Force reload JSON data (clear localStorage cache)
    forceReloadData() {
      // Effacer seulement les Ã©ditions temporaires
      localStorage.removeItem('jdr-bab-edits');
      localStorage.removeItem('jdr-bab-last-modified');
      window.location.reload();
    }
  };

  // Auto-initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => window.JdrApp.init());
  } else {
    window.JdrApp.init();
  }

})();
// ============================================================================
// JDR-BAB APPLICATION - CONTENT TYPES CONFIGURATION
// ============================================================================

(() => {
  "use strict";

  window.ContentTypes = {
    spell: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        element: { type: 'select', label: 'Ã‰lÃ©ment', required: true, options: ['Feu', 'Eau', 'Terre', 'Air', 'LumiÃ¨re', 'Nuit', 'Divin', 'MalÃ©fique'] },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'PrÃ©requis', required: true },
        portee: { type: 'richtext', label: 'PortÃ©e', required: true },
        tempsIncantation: { type: 'richtext', label: 'Temps d\'incantation', required: true },
        coutMana: { type: 'richtext', label: 'CoÃ»t mana', required: true },
        resistance: { type: 'richtext', label: 'RÃ©sistance', required: true },
        effetNormal: { type: 'richtext', label: 'Effet normal', required: true },
        effetCritique: { type: 'richtext', label: 'Effet critique', required: false }
      },
      editMapping: {
        'spell-name': 'nom',
        'spell-element': 'element',
        'spell-description': 'description',
        'spell-prerequis': 'prerequis',
        'spell-portee': 'portee',
        'spell-mana': 'coutMana',
        'spell-temps-incantation': 'tempsIncantation',
        'spell-resistance': 'resistance',
        'spell-effect-normal': 'effetNormal',
        'spell-effect-critical': 'effetCritique'
      },
      identifiers: {
        name: 'nom',
        category: 'sorts'
      },
      template: 'spell-card',
      container: 'sorts',
      dataKey: 'SORTS',
      icons: { 
        category: 'ğŸ”®', 
        item: 'âœ¨',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      defaultValues: {
        nom: "Nouveau Sort",
        element: "Feu",
        description: "Lance une boule de Feu sur un adversaire.",
        prerequis: "ğŸ“‹ <strong>PrÃ©requis:</strong> Niveau 1",
        portee: "ğŸ¯ <strong>PortÃ©e:</strong> 20m",
        tempsIncantation: "â° <strong>Temps d'incantation:</strong> 1 tour",
        coutMana: "ğŸ”µ <strong>CoÃ»t mana:</strong> 3",
        resistance: "<strong>Sans effet si:</strong> Esquive.",
        effetNormal: "<strong>Effet:</strong> Inflige 5 dÃ©gats de <span style=\"color: #e25822; font-weight: bold;\">Feu</span> Ã  la cible.<br>&nbsp;Tous les 5 points d'intelligence, augmente les dÃ©gats de 1.",
        effetCritique: "<strong>Coup Critique:&nbsp;</strong>&nbsp;Double les dÃ©gÃ¢ts et enflamme la cible."
      }
    },

    don: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        prerequis: { type: 'richtext', label: 'PrÃ©requis', required: true },
        cout: { type: 'richtext', label: 'CoÃ»t', required: true }
      },
      editMapping: {
        'don-name': 'nom',
        'don-description': 'description',
        'don-prerequis': 'prerequis',
        'don-cout': 'cout'
      },
      identifiers: {
        name: 'nom',
        category: 'dons'
      },
      template: 'don-card',
      container: 'dons',
      dataKey: 'DONS',
      icons: { 
        category: 'ğŸ–ï¸', 
        item: 'ğŸ†',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      defaultValues: {
        nom: "Nouveau Don",
        description: "Description du don.",
        prerequis: "Aucun prÃ©requis",
        cout: "1 point de don"
      }
    },

    class: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        resume: { type: 'textarea', label: 'RÃ©sumÃ©', required: true },
        capacites: { type: 'list', label: 'CapacitÃ©s', required: true }
      },
      editMapping: {
        'class-name': 'nom',
        'class-resume': 'resume',
        'class-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: null
      },
      template: 'class-page',
      container: 'classes',
      dataKey: 'CLASSES',
      icons: { 
        category: 'âš”ï¸', 
        item: 'ğŸ›¡ï¸',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      }
    },

    subclass: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        description: { type: 'textarea', label: 'Description', required: true },
        base: { type: 'stats', label: 'Statistiques de base', required: true },
        progression: { type: 'richtext', label: 'Progression', required: true },
        capacites: { type: 'list', label: 'CapacitÃ©s', required: true }
      },
      editMapping: {
        'subclass-name': 'nom',
        'subclass-description': 'description',
        'subclass-stats': 'base',
        'subclass-progression': 'progression',
        'subclass-capacites': 'capacites'
      },
      identifiers: {
        name: 'nom',
        category: 'sousClasses',
        parent: 'class'
      },
      template: 'subclass-card',
      icons: { 
        item: 'âš¡',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      defaultValues: {
        nom: "Nouvelle sous-classe",
        description: "Description de la sous-classe",
        base: {
          Force: 3,
          AgilitÃ©: 3,
          Endurance: 3,
          Intelligence: 3,
          VolontÃ©: 3,
          Chance: 3
        },
        progression: "<strong>ğŸ“ˆ Progression par niveau:</strong> +1 Force ğŸ’ª, +1 AgilitÃ© ğŸƒ",
        capacites: [
          "<em>CapacitÃ© unique</em>: Description de la capacitÃ© spÃ©ciale de cette sous-classe."
        ]
      }
    },

    objet: {
      fields: {
        nom: { type: 'text', label: 'Nom', required: true },
        numero: { type: 'number', label: 'NumÃ©ro', required: true },
        image: { type: 'text', label: 'Image', required: false },
        description: { type: 'textarea', label: 'Description', required: true },
        tags: { type: 'tags', label: 'Tags', required: true },
        effet: { type: 'richtext', label: 'Effet', required: true },
        prix: { type: 'richtext', label: 'Prix', required: true },
        poids: { type: 'richtext', label: 'Poids', required: true }
      },
      editMapping: {
        'objet-name': 'nom',
        'objet-numero': 'numero',
        'objet-image': 'image',
        'objet-description': 'description',
        'objet-tags': 'tags',
        'objet-effet': 'effet',
        'objet-prix': 'prix',
        'objet-poids': 'poids'
      },
      identifiers: {
        name: 'nom',
        category: 'objets'
      },
      template: 'objet-card',
      container: 'objets',
      dataKey: 'OBJETS',
      pageType: 'single', // Page unique avec filtres
      icons: { 
        category: 'ğŸ“¦', 
        item: 'ğŸ’',
        add: 'â•',
        delete: 'ğŸ—‘ï¸'
      },
      // Configuration des filtres disponibles
      filterConfig: {
        availableTags: [
          'Arme',
          'Armure', 
          'Consommable',
          'Magique',
          'PrÃ©cieux',
          'Outil',
          'Composant',
          'Divers'
        ],
        defaultVisibleTags: ['Arme', 'Armure', 'Consommable'] // Filtres affichÃ©s par dÃ©faut
      },
      defaultValues: {
        nom: "Nouvel Objet",
        numero: 1,
        image: "",
        description: "Description de l'objet.",
        tags: ["Divers"],
        effet: "<strong>Effet:</strong> Description de l'effet de l'objet.",
        prix: "ğŸ’° <strong>Prix:</strong> 10 piÃ¨ces d'or",
        poids: "âš–ï¸ <strong>Poids:</strong> 1 kg"
      }
    },

    staticPage: {
      fields: {
        title: { type: 'text', label: 'Titre', required: true },
        sections: { type: 'sections', label: 'Sections', required: true }
      },
      template: 'static-page',
      icons: { 
        category: 'ğŸ“„', 
        item: 'ğŸ“'
      }
    }
  };

  window.StatIcons = {
    'Force': 'ğŸ’ª',
    'AgilitÃ©': 'ğŸƒ',
    'Endurance': 'ğŸ›¡ï¸',
    'Intelligence': 'ğŸ§ ',
    'VolontÃ©': 'âš¡',
    'Chance': 'ğŸ€'
  };

  window.ElementColors = {
    'Feu': { color: '#ff6b35', weight: 'bold' },
    'Eau': { color: '#4682b4', weight: 'bold' },
    'Terre': { color: '#8b4513', weight: 'bold' },
    'Air': { color: '#22c55e', weight: 'bold' },
    'LumiÃ¨re': { color: '#ffd700', weight: 'bold' },
    'Nuit': { color: '#1a1a1a', weight: 'bold' },
    'Divin': { color: '#f5f5f5', weight: 'bold', background: 'rgba(100, 100, 100, 0.3)', padding: '2px 4px', borderRadius: '3px' },
    'MalÃ©fique': { color: '#8b5cf6', weight: 'bold' }
  };

  window.ElementIcons = {
    'Feu': 'ğŸ”¥',
    'Eau': 'ğŸ’§',
    'Terre': 'ğŸ¤',
    'Air': 'ğŸŸ¢',
    'LumiÃ¨re': 'â˜€ï¸',
    'Nuit': 'âš«',
    'Divin': 'âšª',
    'MalÃ©fique': 'ğŸŸ£'
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - EVENT BUS
// ============================================================================

(() => {
  "use strict";

  class EventBus {
    constructor() {
      this.listeners = new Map();
    }

    static getInstance() {
      if (!EventBus.instance) {
        EventBus.instance = new EventBus();
      }
      return EventBus.instance;
    }

    on(eventType, callback) {
      if (!this.listeners.has(eventType)) {
        this.listeners.set(eventType, []);
      }
      this.listeners.get(eventType).push(callback);
      return () => this.off(eventType, callback);
    }

    off(eventType, callback) {
      const callbacks = this.listeners.get(eventType);
      if (callbacks) {
        const index = callbacks.indexOf(callback);
        if (index > -1) {
          callbacks.splice(index, 1);
        }
      }
    }

    emit(eventType, payload = {}) {
      const callbacks = this.listeners.get(eventType);
      if (callbacks) {
        callbacks.forEach(callback => {
          try {
            callback(payload);
          } catch (error) {
            console.error(`Error in event callback for ${eventType}:`, error);
          }
        });
      }
    }

    once(eventType, callback) {
      const unsubscribe = this.on(eventType, (payload) => {
        callback(payload);
        unsubscribe();
      });
      return unsubscribe;
    }
  }

  window.EventBus = EventBus.getInstance();

  window.Events = {
    CONTENT_ADD: 'content:add',
    CONTENT_DELETE: 'content:delete',
    CONTENT_UPDATE: 'content:update',
    CONTENT_MOVE: 'content:move',
    PAGE_RENDER: 'page:render',
    EDITOR_TOGGLE: 'editor:toggle',
    IMAGE_UPLOAD: 'image:upload',
    IMAGE_DELETE: 'image:delete',
    STORAGE_SAVE: 'storage:save',
    SEARCH_PERFORM: 'search:perform',
    MODAL_OPEN: 'modal:open',
    MODAL_CLOSE: 'modal:close',
    NOTIFICATION_SHOW: 'notification:show'
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - BASE ENTITY
// ============================================================================

(() => {
  "use strict";

  class BaseEntity {
    constructor(type, dataArray) {
      this.type = type;
      this.data = dataArray || [];
      this.config = window.ContentTypes[type];
      
      // Handle special case for objects with new structure
      if (type === 'objet' && this.data && !Array.isArray(this.data) && this.data.objets) {
        // Convert to pseudo-category structure for compatibility
        this.objectsData = this.data; // Keep reference to original structure
        this.data = [{ nom: 'objets', objets: this.data.objets }]; // Wrap in array format
      }
    }

    getAll() {
      return this.data;
    }

    findCategory(categoryName) {
      return this.data.find(category => category.nom === categoryName);
    }

    findItem(itemName, categoryName = null) {
      if (categoryName) {
        const category = this.findCategory(categoryName);
        if (!category || !category[this.getItemsProperty()]) return null;
        
        const item = category[this.getItemsProperty()].find(item => item.nom === itemName);
        return item ? { item, category: category.nom } : null;
      }

      for (const category of this.data) {
        if (!category[this.getItemsProperty()]) continue;
        const item = category[this.getItemsProperty()].find(item => item.nom === itemName);
        if (item) {
          return { item, category: category.nom };
        }
      }
      return null;
    }

    addItem(categoryName, itemData) {
      const category = this.findCategory(categoryName);
      if (!category) return false;

      const itemsProperty = this.getItemsProperty();
      if (!category[itemsProperty]) {
        category[itemsProperty] = [];
      }

      const defaultValues = this.config?.defaultValues || {};
      const newItem = { ...defaultValues, ...itemData };
      category[itemsProperty].push(newItem);

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_ADD, {
        type: this.type,
        category: categoryName,
        item: newItem
      });

      return newItem;
    }

    deleteItem(categoryName, itemName) {
      const category = this.findCategory(categoryName);
      if (!category) return false;

      const itemsProperty = this.getItemsProperty();
      const items = category[itemsProperty];
      if (!items) return false;

      const index = items.findIndex(item => item.nom === itemName);
      if (index === -1) return false;

      const deletedItem = items.splice(index, 1)[0];

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_DELETE, {
        type: this.type,
        category: categoryName,
        item: deletedItem
      });

      return true;
    }

    updateItem(categoryName, itemName, property, value) {
      const result = this.findItem(itemName, categoryName);
      if (!result) return false;

      const { item } = result;
      
      if (property === 'capacites' && Array.isArray(value)) {
        item[property] = value;
      } else if (property === 'base' && typeof value === 'object') {
        item[property] = { ...item[property], ...value };
      } else {
        item[property] = value;
      }

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_UPDATE, {
        type: this.type,
        category: categoryName,
        item: item,
        property: property,
        value: value
      });

      return true;
    }

    moveItem(categoryName, itemName, direction) {
      const category = this.findCategory(categoryName);
      if (!category) return false;

      const itemsProperty = this.getItemsProperty();
      const items = category[itemsProperty];
      if (!items) return false;

      const currentIndex = items.findIndex(item => item.nom === itemName);
      if (currentIndex === -1) return false;

      const newIndex = currentIndex + direction;
      if (newIndex < 0 || newIndex >= items.length) return false;

      [items[currentIndex], items[newIndex]] = [items[newIndex], items[currentIndex]];

      // Sync back to original objects data if needed
      this.syncObjectsData();

      EventBus.emit(Events.CONTENT_MOVE, {
        type: this.type,
        category: categoryName,
        itemName: itemName,
        direction: direction
      });

      return true;
    }

    getItemsProperty() {
      switch (this.type) {
        case 'spell': return 'sorts';
        case 'don': return 'dons';
        case 'objet': return 'objets';
        case 'class': return 'sousClasses';
        default: return 'items';
      }
    }

    search(query) {
      const results = [];
      const normalizedQuery = query.toLowerCase().trim();

      this.data.forEach(category => {
        const itemsProperty = this.getItemsProperty();
        if (!category[itemsProperty]) return;

        category[itemsProperty].forEach(item => {
          const searchableText = Object.values(item).join(' ').toLowerCase();
          if (searchableText.includes(normalizedQuery)) {
            results.push({
              item,
              category: category.nom,
              type: this.type
            });
          }
        });
      });

      return results;
    }

    // Sync changes back to original objects data structure
    syncObjectsData() {
      if (this.type === 'objet' && this.objectsData && this.data.length > 0) {
        const objectsCategory = this.data[0];
        if (objectsCategory && objectsCategory.objets) {
          this.objectsData.objets = objectsCategory.objets;
        }
      }
    }
  }

  window.BaseEntity = BaseEntity;

})();
// ============================================================================
// JDR-BAB APPLICATION - CONTENT FACTORY
// ============================================================================

(() => {
  "use strict";

  class ContentFactory {
    constructor() {
      this.entities = new Map();
      this.initialize();
    }

    static getInstance() {
      if (!ContentFactory.instance) {
        ContentFactory.instance = new ContentFactory();
      }
      return ContentFactory.instance;
    }

    initialize() {
      // Lazy initialization - only create entities when data is available
      if (window.SORTS) {
        this.entities.set('spell', new BaseEntity('spell', window.SORTS));
      }
      if (window.DONS) {
        this.entities.set('don', new BaseEntity('don', window.DONS));
      }
      if (window.CLASSES) {
        this.entities.set('class', new BaseEntity('class', window.CLASSES));
      }
      if (window.OBJETS) {
        this.entities.set('objet', new BaseEntity('objet', window.OBJETS));
      }
    }

    getEntity(type) {
      // Ensure entity exists, create if data is available but entity is missing
      if (!this.entities.has(type)) {
        this.initializeEntity(type);
      }
      return this.entities.get(type);
    }

    initializeEntity(type) {
      switch (type) {
        case 'spell':
          if (window.SORTS) {
            this.entities.set('spell', new BaseEntity('spell', window.SORTS));
          }
          break;
        case 'don':
          if (window.DONS) {
            this.entities.set('don', new BaseEntity('don', window.DONS));
          }
          break;
        case 'class':
          if (window.CLASSES) {
            this.entities.set('class', new BaseEntity('class', window.CLASSES));
          }
          break;
        case 'objet':
          if (window.OBJETS) {
            this.entities.set('objet', new BaseEntity('objet', window.OBJETS));
          }
          break;
      }
    }

    getSpells() {
      return this.getEntity('spell');
    }

    getDons() {
      return this.getEntity('don');
    }

    getClasses() {
      return this.getEntity('class');
    }

    getObjets() {
      return this.getEntity('objet');
    }

    findItem(type, itemName, categoryName = null) {
      const entity = this.getEntity(type);
      return entity ? entity.findItem(itemName, categoryName) : null;
    }

    addItem(type, categoryName, itemData) {
      const entity = this.getEntity(type);
      return entity ? entity.addItem(categoryName, itemData) : false;
    }

    deleteItem(type, categoryName, itemName) {
      const entity = this.getEntity(type);
      return entity ? entity.deleteItem(categoryName, itemName) : false;
    }

    updateItem(type, categoryName, itemName, property, value) {
      const entity = this.getEntity(type);
      return entity ? entity.updateItem(categoryName, itemName, property, value) : false;
    }

    moveItem(type, categoryName, itemName, direction) {
      const entity = this.getEntity(type);
      return entity ? entity.moveItem(categoryName, itemName, direction) : false;
    }

    searchAll(query) {
      const allResults = [];
      
      this.entities.forEach((entity, type) => {
        const results = entity.search(query);
        allResults.push(...results);
      });

      return allResults;
    }

    refreshData() {
      this.entities.clear();
      this.initialize();
    }

    getConfig(type) {
      return window.ContentTypes[type];
    }

    createDefaultItem(type, overrides = {}) {
      const config = this.getConfig(type);
      if (!config?.defaultValues) return {};

      return { ...config.defaultValues, ...overrides };
    }
  }

  window.ContentFactory = ContentFactory.getInstance();

})();
// ============================================================================
// JDR-BAB APPLICATION - CARD BUILDER
// ============================================================================

(() => {
  "use strict";

  class CardBuilder {
    constructor(type, data, categoryName = null, index = null) {
      this.type = type;
      this.data = data;
      this.categoryName = categoryName;
      this.index = index;
      this.config = window.ContentTypes[type];
    }

    static create(type, data, categoryName = null, index = null) {
      return new CardBuilder(type, data, categoryName, index);
    }

    // Simple unified dev mode check
    get shouldShowEditButtons() {
      return JdrApp.utils.isDevMode();
    }

    build() {
      switch (this.type) {
        case 'spell':
          return this.buildSpellCard();
        case 'don':
          return this.buildDonCard();
        case 'subclass':
          return this.buildSubclassCard();
        case 'objet':
          return this.buildObjetCard();
        default:
          return this.buildGenericCard();
      }
    }

    buildSpellCard() {
      return `
        <div class="card editable-section" data-section-type="spell" data-spell-name="${this.data.nom}" data-spell-index="${this.index}" data-category-name="${this.categoryName}">
          ${this.buildEditableTitle(this.data.nom, 'spell-name')}
          ${this.buildSpellElement()}
          ${this.buildIllustration(`sort:${this.categoryName}:${this.data.nom}`, this.data.nom)}
          ${this.buildEditableField(this.data.description, 'spell-description', 'Description', { style: 'text-align: center; font-style: italic; margin: 1rem 0;' })}
          <hr style="margin: 1rem 0; border: none; border-top: 2px solid var(--bronze); opacity: 0.6;">
          ${this.buildEditableField(this.data.prerequis, 'spell-prerequis', 'PrÃ©requis')}
          ${this.buildEditableField(this.data.portee, 'spell-portee', 'PortÃ©e')}
          ${this.buildEditableField(this.data.coutMana, 'spell-mana', 'CoÃ»t mana')}
          ${this.buildEditableField(this.data.tempsIncantation, 'spell-temps-incantation', 'Temps d\'incantation')}
          <hr style="margin: 0.5rem 0; border: none; border-top: 1px solid var(--rule);">
          ${this.buildEditableField(this.data.resistance, 'spell-resistance', 'RÃ©sistance')}
          ${this.buildEditableEffect(this.data.effetNormal, 'spell-effect-normal', 'Effet normal')}
          <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
          ${this.data.effetCritique ? this.buildEditableEffect(this.data.effetCritique, 'spell-effect-critical', 'Effet critique') : ''}
          ${this.buildDeleteButton('spell')}
        </div>
      `;
    }

    buildDonCard() {
      const index = this.index !== null ? this.index : (this.categoryName ? this.getCategoryData().dons?.indexOf(this.data) || 0 : 0);
      const totalItems = this.categoryName ? this.getCategoryData().dons?.length || 1 : 1;

      return `
        <div class="card editable-section" data-section-type="don" data-don-name="${this.data.nom}" data-don-index="${this.index}" data-category-name="${this.categoryName}">
          ${this.buildEditableTitle(this.data.nom, 'don-name')}
          ${this.buildIllustration(`don:${this.data.nom}`, this.data.nom)}
          ${this.buildEditableField(this.data.description, 'don-description', 'Description')}
          ${this.buildEditableField(this.data.prerequis, 'don-prerequis', 'PrÃ©requis')}
          ${this.buildEditableField(this.data.cout, 'don-cout', 'CoÃ»t', { style: 'color: var(--bronze); font-weight: 600;' })}
          ${this.buildMoveButtons('don', index, totalItems)}
        </div>
      `;
    }

    buildSubclassCard() {
      return `
        <div class="card editable-section" data-section-type="subclass" data-class-name="${this.categoryName}" data-subclass-name="${this.data.nom}">
          ${this.buildEditableTitle(this.data.nom, 'subclass-name')}
          ${this.buildEditableField(this.data.description || 'Description de la sous-classe', 'subclass-description', 'Description', { style: 'text-align: center; color: inherit;' })}
          ${this.buildSubclassImages()}
          <div style="margin-bottom: 1rem;">
            ${this.buildStatsSection()}
          </div>
          ${this.buildEditableField(this.data.progression, 'subclass-progression', 'Progression')}
          <div class="rule" style="margin: 1.5rem auto; height: 2px; background: linear-gradient(90deg, transparent, var(--bronze), transparent); opacity: 0.6;"></div>
          ${this.buildEditableList(this.data.capacites, 'subclass-capacites', 'CapacitÃ©s')}
          ${this.buildDeleteButton('subclass')}
        </div>
      `;
    }

    buildObjetCard() {
      // Pour les objets en page unique, l'index est basÃ© sur tous les objets
      const allObjects = window.OBJETS?.objets || [];
      const index = allObjects.indexOf(this.data) || 0;
      const totalItems = allObjects.length;
      
      // Construire l'affichage des tags
      const tagsDisplay = this.data.tags && this.data.tags.length > 0 
        ? this.data.tags.map(tag => `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`).join('')
        : '<span style="font-style: italic; color: #666;">Aucun tag</span>';

      return `
        <div class="card editable-section" data-section-type="objet" data-objet-name="${this.data.nom}" data-category-name="${this.categoryName}">
          ${this.buildEditableTitle(this.data.nom, 'objet-name')}
          ${this.buildIllustration(`objet:${this.data.nom}`, this.data.nom)}
          <div style="display: flex; justify-content: space-between; align-items: center; margin: 0.5rem 0; font-size: 0.9em; color: var(--bronze);">
            ${this.buildEditableField(`NÂ°${this.data.numero}`, 'objet-numero', 'NumÃ©ro', { style: 'font-weight: bold;' })}
            <div style="flex: 1; text-align: right;">
              <div style="margin: 2px 0;">
                ${this.buildEditableTagsField(tagsDisplay, 'objet-tags', 'Tags')}
              </div>
            </div>
          </div>
          ${this.buildEditableField(this.data.description, 'objet-description', 'Description')}
          <hr style="margin: 1rem 0; border: none; border-top: 1px solid var(--rule);">
          ${this.buildEditableField(this.data.effet, 'objet-effet', 'Effet')}
          <div style="display: flex; justify-content: space-between; gap: 1rem; margin: 0.5rem 0;">
            <div style="flex: 1;">${this.buildEditableField(this.data.prix, 'objet-prix', 'Prix')}</div>
            <div style="flex: 1;">${this.buildEditableField(this.data.poids, 'objet-poids', 'Poids')}</div>
          </div>
          ${this.buildMoveButtons('objet', index, totalItems)}
        </div>
      `;
    }

    buildEditableTitle(content, editType, centerAlign = true) {
      const style = centerAlign ? 'margin: 0 0 1rem 0; text-align: center;' : '';
      const spellTitleClass = this.type === 'spell' ? ' spell-title' : '';
      const subclassTitleClass = this.type === 'subclass' ? ' subclass-title' : '';
      
      // Create unique edit section identifier using editType
      const editSection = `${this.data.nom}-${editType}`;
      
      return `
        <div class="editable-section" data-section-type="html">
          <h4 style="${style}" class="editable editable-title${spellTitleClass}${subclassTitleClass}" data-edit-type="generic" data-edit-section="${editSection}">${content}</h4>
          ${this.buildEditButton('title')}
        </div>
      `;
    }

    buildEditableField(content, editType, label, options = {}) {
      const style = options.style ? `style="${options.style}"` : '';
      const className = options.className || 'editable-field';
      
      // Create unique edit section identifier using editType
      const editSection = `${this.data.nom}-${editType}`;
      
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable ${className}" data-edit-type="generic" data-edit-section="${editSection}" ${style}>
            ${content}
          </div>
          ${this.buildEditButton('field')}
        </div>
      `;
    }
    
    buildEditableTagsField(content, editType, label, options = {}) {
      const style = options.style ? `style="${options.style}"` : '';
      
      // Create unique edit section identifier using editType
      const editSection = `${this.data.nom}-${editType}`;
      
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable editable-tags" data-edit-type="tags" data-edit-section="${editSection}" ${style}>
            ${content}
          </div>
          ${this.buildEditButton('field')}
        </div>
      `;
    }

    buildEditableEffect(content, editType, label) {
      // Create unique edit section identifier using editType
      const editSection = `${this.data.nom}-${editType}`;
      
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable editable-effect" data-edit-type="generic" data-edit-section="${editSection}" style="margin: 1rem 0;">
            ${content}
          </div>
          ${this.buildEditButton('effect')}
        </div>
      `;
    }

    buildEditableList(items, editType, label) {
      // Everything should be HTML format only
      let listHTML;
      if (typeof items === 'string') {
        // HTML string format
        listHTML = items;
      } else {
        // Fallback if somehow still array format - convert once
// console.warn('Found array format for capacites, converting to HTML:', items);
        if (Array.isArray(items)) {
          listHTML = '<ul>' + items.map(item => '<li>' + item + '</li>').join('') + '</ul>';
        } else {
          listHTML = '<ul><li>Aucune capacitÃ© dÃ©finie</li></ul>';
        }
      }
      
      // Create unique edit section identifier using editType
      const editSection = `${this.data.nom}-${editType}`;
      
      return `
        <h5>${label}</h5>
        <div class="editable-section" data-section-type="html">
          <div class="editable" data-edit-type="generic" data-edit-section="${editSection}">
            ${listHTML}
          </div>
          ${this.buildEditButton('list')}
        </div>
      `;
    }

    buildStatsSection() {
      // Stats are special - they remain as objects since they're structured data
      // But check if they were converted to HTML string by editing
      let statsHTML;
      
      if (typeof this.data.base === 'string') {
        // Already converted to HTML by editing
        statsHTML = this.data.base;
      } else if (typeof this.data.base === 'object') {
        // Original object format - convert to HTML
        statsHTML = '<div class="chips">' + 
          Object.entries(this.data.base).map(([stat, value]) => {
            const icon = window.StatIcons[stat] || 'âš¡';
            return '<span class="chip">' + icon + ' ' + stat + ': <strong>' + value + '</strong></span>';
          }).join('') + 
          '</div>';
      } else {
        statsHTML = '<div>Aucune statistique dÃ©finie</div>';
      }
      
      // Create unique edit section identifier for stats
      const editSection = `${this.data.nom}-stats`;
      
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable editable-stats" data-edit-type="generic" data-edit-section="${editSection}">
            ${statsHTML}
          </div>
          ${this.buildEditButton('stats')}
        </div>
      `;
    }

    buildSubclassImages() {
      const illusKey1 = `subclass:${this.categoryName}:${this.data.nom}:1`;
      const illusKey2 = `subclass:${this.categoryName}:${this.data.nom}:2`;
      
      return `
        <div class="subclass-images">
          ${this.buildIllustration(illusKey1, `${this.data.nom} (Image 1)`, 'subclass')}
          ${this.buildIllustration(illusKey2, `${this.data.nom} (Image 2)`, 'subclass')}
        </div>
      `;
    }

    buildIllustration(illusKey, altText = '', styleType = 'default') {
      let imageUrl = '';
      let imageStyle = 'display: none;';
      let removeStyle = 'display: none;';
      
      if (window.JdrApp?.modules?.images?.getImageUrl) {
        imageUrl = window.JdrApp.modules.images.getImageUrl(illusKey);
        if (imageUrl) {
          imageUrl = window.JdrApp.modules.images.processImageUrl(imageUrl);
          imageStyle = 'display: inline-block;';
          removeStyle = 'display: inline-flex;';
        }
      }

      let containerClasses = 'illus';
      if (['spell', 'class', 'subclass', 'don', 'objet'].includes(styleType)) {
        containerClasses += ` illus-${styleType}`;
      }

      if (JdrApp.utils.isDevMode()) {
        return `
          <div class="${containerClasses}" data-illus-key="${illusKey}" data-style-type="${styleType}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
            <label class="up">ğŸ“· Ajouter<input accept="image/*" hidden="" type="file"></label>
            <button class="rm" type="button" style="${removeStyle}">ğŸ—‘ Retirer</button>
          </div>
        `;
      }
      
      return `
        <div class="${containerClasses}" data-illus-key="${illusKey}" data-style-type="${styleType}" data-bound="1">
          <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
        </div>
      `;
    }

    buildEditButton(type) {
      const titles = {
        title: 'Ã‰diter le titre',
        field: 'Ã‰diter ce champ',
        effect: 'Ã‰diter cet effet',
        list: 'Ã‰diter cette liste',
        stats: 'Ã‰diter les statistiques'
      };

      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="edit-btn edit-${type}-btn" title="${titles[type] || 'Ã‰diter'}">âœï¸</button>`;
    }

    buildDeleteButton(type) {
      const config = {
        spell: {
          class: 'spell-delete btn small',
          style: 'background: #ff6b6b; color: white; margin-top: 8px;',
          text: 'ğŸ—‘ Supprimer',
          attrs: `data-category-name="${this.categoryName}" data-spell-name="${this.data.nom}" data-spell-index="${this.index}"`
        },
        don: {
          class: 'don-delete btn small',
          style: 'background: #ff6b6b; color: white;',
          text: 'ğŸ—‘ Supprimer',
          attrs: `data-category-name="${this.categoryName}" data-don-name="${this.data.nom}" data-don-index="${this.index}"`
        },
        subclass: {
          class: 'delete-subclass-btn',
          style: '',
          text: 'ğŸ—‘ï¸ Supprimer',
          attrs: `data-class-name="${this.categoryName}" data-subclass-name="${this.data.nom}"`
        },
        objet: {
          class: 'objet-delete btn small',
          style: 'background: #ff6b6b; color: white;',
          text: 'ğŸ—‘ Supprimer',
          attrs: `data-category-name="${this.categoryName}" data-objet-name="${this.data.nom}"`
        }
      };

      const buttonConfig = config[type];
      if (!buttonConfig) return '';

      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="${buttonConfig.class}" ${buttonConfig.attrs} type="button" style="${buttonConfig.style}">${buttonConfig.text}</button>`;
    }

    buildMoveButtons(type, index, totalItems) {
      // Always generate the buttons - CSS will control visibility based on body.dev-on/dev-off
      return `
        <div style="display: flex; gap: 4px; margin-top: 8px; flex-wrap: wrap;">
          ${this.buildDeleteButton(type)}
          <button class="${type}-move-up btn small" data-category-name="${this.categoryName}" data-${type}-name="${this.data.nom}" data-${type}-index="${index}" style="background: var(--bronze); color: white;" ${index === 0 ? 'disabled' : ''}>â¬†ï¸ Haut</button>
          <button class="${type}-move-down btn small" data-category-name="${this.categoryName}" data-${type}-name="${this.data.nom}" data-${type}-index="${index}" style="background: var(--bronze); color: white;" ${index === totalItems - 1 ? 'disabled' : ''}>â¬‡ï¸ Bas</button>
        </div>
      `;
    }

    buildSpellElement() {
      // Get the element (default to 'Feu' if not set)
      const element = this.data.element || 'Feu';
      const icon = window.ElementIcons ? window.ElementIcons[element] : 'ğŸ”¥';
      const colors = window.ElementColors ? window.ElementColors[element] : { color: '#ff6b35', weight: 'bold' };
      
      // Build style string
      let style = `color: ${colors.color}; font-weight: ${colors.weight};`;
      if (colors.background) style += ` background: ${colors.background};`;
      if (colors.padding) style += ` padding: ${colors.padding};`;
      if (colors.borderRadius) style += ` border-radius: ${colors.borderRadius};`;
      
      // VÃ©rifier le mode dev au moment de la gÃ©nÃ©ration
      const isDevMode = JdrApp.utils.isDevMode();
      
      if (isDevMode) {
        // Mode dÃ©veloppement : afficher le sÃ©lecteur
        const options = Object.keys(window.ElementIcons || {});
        const optionsHTML = options.map(elem => 
          `<option value="${elem}" ${elem === element ? 'selected' : ''}>${window.ElementIcons[elem]} ${elem}</option>`
        ).join('');
        
        return `
          <div style="text-align: center; margin: 0.5rem 0;">
            <div class="spell-element-selector" style="font-size: 1.1em;">
              <select data-spell-name="${this.data.nom}" data-spell-index="${this.index}" data-category-name="${this.categoryName}" style="padding: 4px 8px; border: 1px solid var(--rule); border-radius: 6px; background: var(--card); font-size: 0.9em;">
                ${optionsHTML}
              </select>
            </div>
          </div>
        `;
      } else {
        // Mode normal : afficher seulement l'icÃ´ne
        return `
          <div style="text-align: center; margin: 0.5rem 0;">
            <div class="spell-element-display" style="font-size: 1.1em;">
              <span style="${style}">${icon} ${element}</span>
            </div>
          </div>
        `;
      }
    }

    getCategoryData() {
      return window.ContentFactory.getEntity(this.type)?.findCategory(this.categoryName);
    }
  }

  window.CardBuilder = CardBuilder;

})();
// ============================================================================
// JDR-BAB APPLICATION - PAGE BUILDER
// ============================================================================

(() => {
  "use strict";

  class PageBuilder {
    constructor() {
      // Will use unified dev mode check
    }

    // Simple unified dev mode check
    get shouldShowEditButtons() {
      return JdrApp.utils.isDevMode();
    }

    static getInstance() {
      if (!PageBuilder.instance) {
        PageBuilder.instance = new PageBuilder();
      }
      return PageBuilder.instance;
    }

    buildCategoryPage(type, category) {
      const config = window.ContentTypes[type];
      
      // Gestion spÃ©ciale pour les objets (page unique avec filtres)
      if (type === 'objet' && config.pageType === 'single') {
        return this.buildSingleObjectPage(category);
      }
      
      const pageId = `${config.container}-${this.sanitizeId(category.nom)}`;
      const itemsProperty = this.getItemsProperty(type);
      
      // Get items and sort them for spells
      let items = category[itemsProperty] || [];
      if (type === 'spell') {
        items = this.sortSpellsByLevel([...items]);
      }

      return `
        <article class="" data-page="${pageId}">
          <section>
            ${this.buildCategoryHeader(category, type)}
            ${type === 'spell' ? this.buildSpellLevelFilter() : ''}
            <div style="display: flex; gap: 8px; margin-bottom: 1rem; flex-wrap: wrap;">
              ${this.buildAddButton(type, category.nom)}
              ${this.buildDeleteCategoryButton(type, category.nom)}
            </div>
            <div class="grid cols-2" id="${config.container}-container-${this.sanitizeId(category.nom)}">
              ${items.map((item, index) => 
                CardBuilder.create(type, item, category.nom, index).build()
              ).join('')}
            </div>
          </section>
        </article>
      `;
    }
    
    buildSingleObjectPage(objectData) {
      const config = window.ContentTypes['objet'];
      const allObjects = objectData.objets || [];
      const filterSettings = objectData.filterSettings || {};
      const visibleTags = filterSettings.visibleTags || config.filterConfig.defaultVisibleTags;
      
      // Filtrer les objets selon les tags visibles
      const filteredObjects = allObjects.filter(obj => 
        obj.tags && obj.tags.some(tag => visibleTags.includes(tag))
      );
      
      return `
        <article class="" data-page="objets">
          <section>
            <div style="display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap">
              <h2>ğŸ“¦ Objets</h2>
              ${this.buildIllustration('page:objets')}
            </div>
            
            ${this.buildTagFilters(visibleTags, config.filterConfig.availableTags)}
            
            <div style="display: flex; gap: 8px; margin-bottom: 1rem; flex-wrap: wrap;">
              ${this.buildAddButton('objet', 'objets')}
              ${this.buildFilterManagerButton()}
            </div>
            
            <div class="grid cols-2" id="objets-container">
              ${filteredObjects.map((item, index) => 
                CardBuilder.create('objet', item, 'objets', index).build()
              ).join('')}
            </div>
            
            ${filteredObjects.length === 0 ? '<p style="text-align: center; color: #666; margin: 2rem 0;">Aucun objet ne correspond aux filtres sÃ©lectionnÃ©s.</p>' : ''}
          </section>
        </article>
      `;
    }

    buildClassPage(classData) {
      const pageId = this.sanitizeId(classData.nom);
      
      return `
        <article class="" data-page="${pageId}" data-page-title="${classData.nom}">
          <section>
            ${this.buildClassHeader(classData)}
            ${this.buildEditableSection(classData.resume, 'class-resume', 'paragraph', classData.nom)}
            <h3>CapacitÃ©s de classe</h3>
            ${this.buildSimpleEditableContent(classData.capacites, 'class-capacites', classData.nom)}
            <h3>Sous-classes</h3>
            <div class="subclass-stack">
              ${classData.sousClasses ? classData.sousClasses.map(sousClasse => 
                CardBuilder.create('subclass', sousClasse, classData.nom).build()
              ).join('') : ''}
            </div>
            ${this.buildAddSubclassButton()}
          </section>
        </article>
      `;
    }

    buildStaticPage(pageId, pageData) {
      const isActive = pageId === 'creation' ? 'active' : '';
      
      return `
        <article class="${isActive}" data-page="${pageData.page}" data-static-page="true" data-page-title="${pageData.title}">
          <section>
            ${this.buildStaticPageHeader(pageData)}
            ${this.buildSections(pageData.sections)}
            ${this.buildAddSectionButton()}
          </section>
        </article>
      `;
    }

    buildCategoryHeader(category, type) {
      const config = window.ContentTypes[type];
      
      return `
        <div style="text-align:center;margin-bottom:2rem;">
          ${this.buildEditableTitle(category.nom, `${type}-category-name`)}
          ${this.buildIllustration(`${type}category:${category.nom}`)}
        </div>
        ${this.buildEditableSection(category.description, `${type}-category-description`, 'paragraph', category.nom)}
      `;
    }

    buildClassHeader(classData) {
      return `
        <div style="text-align:center;margin-bottom:2rem;">
          ${this.buildEditableTitle(classData.nom, 'class-name', classData.nom)}
          ${this.buildIllustration(`class:${classData.nom}`)}
        </div>
      `;
    }

    buildStaticPageHeader(pageData) {
      return `
        <div style="text-align:center;margin-bottom:2rem;">
          <div style="display:inline-flex;align-items:center;gap:8px;">
            <h2 class="editable editable-title" data-edit-type="generic" data-edit-section="page-title">${pageData.title}</h2>
            ${this.buildEditButton('title')}
          </div>
          ${this.buildIllustration(`page:${pageData.page}`)}
        </div>
      `;
    }

    buildEditableTitle(content, editType, editSection = null) {
      return `
        <div style="display:inline-flex;align-items:center;gap:8px;justify-content:center;">
          <h2 class="editable editable-title" data-edit-type="generic" data-edit-section="${editSection || content}">${content}</h2>
          ${this.buildEditButton('title')}
        </div>
      `;
    }

    buildEditableSection(content, editType, sectionType, editSection) {
      const className = sectionType === 'paragraph' ? 'lead editable editable-paragraph' : 'editable editable-field';
      
      return `
        <div class="editable-section" data-section-type="${editType}">
          <p class="${className}" data-edit-type="generic" data-edit-section="${editSection}">${content}</p>
          ${this.buildEditButton(sectionType)}
        </div>
      `;
    }


    buildSimpleEditableContent(content, editType, editSection) {
      // Everything should be HTML format only
      let htmlContent;
      if (typeof content === 'string') {
        htmlContent = content || '';
      } else {
        // Fallback if somehow still array format - convert once and warn
        console.warn('Found array format in buildSimpleEditableContent, converting to HTML:', content);
        if (Array.isArray(content)) {
          htmlContent = '<ul>' + content.map(item => '<li>' + item + '</li>').join('') + '</ul>';
        } else {
          htmlContent = '';
        }
      }
      
      return `
        <div class="editable-section" data-section-type="html">
          <div class="editable" data-edit-type="generic" data-edit-section="${editSection}">
            ${htmlContent}
          </div>
          ${this.buildEditButton('section')}
        </div>
      `;
    }

    buildSections(sections) {
      return sections.map((section, sectionIndex) => {
        switch (section.type) {
          case 'intro':
            return this.buildIntroSection(section, sectionIndex);
          case 'card':
            return this.buildCardSection(section, sectionIndex);
          case 'grid':
            return this.buildGridSection(section, sectionIndex);
          default:
            return `<div><!-- Unknown section type: ${section.type} --></div>`;
        }
      }).join('');
    }

    buildIntroSection(section, sectionIndex) {
      return `
        <div class="editable-section" data-section-type="intro" data-section-index="${sectionIndex}">
          <p class="editable editable-intro" data-edit-type="generic" data-edit-section="intro">${section.content}</p>
          ${this.buildEditButton('section')}
        </div>
        ${this.buildAddParagraphButton('intro')}
      `;
    }

    buildCardSection(cardData, sectionIndex) {
      let cardHTML = `<div class="card editable-section" data-section-type="card" data-section-index="${sectionIndex}">`;
      
      if (cardData.deletable && cardData.sectionType) {
        cardHTML += `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${cardData.id}-title">${cardData.title}</h3>
            ${this.buildEditButton('title')}
            ${this.buildRemoveSectionButton(cardData.sectionType)}
          </div>
        `;
      } else {
        cardHTML += `
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${cardData.id}-title">${cardData.title}</h3>
            ${this.buildEditButton('title')}
          </div>
        `;
      }

      // Handle different content formats
      let htmlContent = '';
      let editSection = cardData.id || 'card-' + sectionIndex;
      
      if (typeof cardData.content === 'string') {
        // Direct HTML string
        htmlContent = cardData.content;
      } else if (typeof cardData.content === 'object' && cardData.content?.content) {
        // Object with nested content property
        htmlContent = cardData.content.content;
        if (cardData.content.editSection) {
          editSection = cardData.content.editSection;
        }
      } else {
        htmlContent = cardData.content || '';
      }
      
      cardHTML += `
        <div style="position:relative;">
          <div class="editable" data-edit-type="generic" data-edit-section="${editSection}">${htmlContent}</div>
          ${this.buildEditButton('section')}
        </div>
      `;

      if (cardData.deletable && cardData.sectionName) {
        // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
        cardHTML += `
          <div style="margin-top: 1rem; text-align: center;">
            <button class="section-delete btn small" data-section-name="${cardData.sectionName}" type="button" style="background: #ff6b6b; color: white;">ğŸ—‘ Supprimer section</button>
          </div>
        `;
      }
      
      cardHTML += `</div>`;
      return cardHTML;
    }


    buildContentItem(item) {
      if (item.type === 'paragraph') {
        const content = `
          <div class="editable-section" data-section-type="paragraph">
            <p class="editable editable-paragraph" data-edit-type="generic" data-edit-section="${item.editSection}">${item.content}</p>
            ${this.buildEditButton('paragraph')}
          </div>
        `;
        const addBtn = this.buildAddParagraphButton(item.editSection);
        return content + addBtn;
      }
      return `<div>${item.content}</div>`;
    }

    buildGridSection(gridSection, sectionIndex) {
      const items = gridSection.content || gridSection.items || [];
      if (!Array.isArray(items)) {
        return '<div><!-- Grid items is not an array --></div>';
      }

      const cols = gridSection.cols || 2;
      let gridHTML = `<div class="grid" style="display: grid; grid-template-columns: repeat(${cols}, 1fr); gap: 1rem;">`;
      
      items.forEach((item, itemIndex) => {
        gridHTML += this.buildCardSection(item, `${sectionIndex}-${itemIndex}`);
      });
      
      gridHTML += '</div>';
      return gridHTML;
    }

    buildComplexContent(content) {
      // Generic HTML content - no special processing
      return content || '';
    }


    buildIllustration(illusKey, altText = '') {
      let imageUrl = '';
      let imageStyle = 'display: none;';
      let removeStyle = 'display: none;';
      
      if (window.JdrApp?.modules?.images?.getImageUrl) {
        imageUrl = window.JdrApp.modules.images.getImageUrl(illusKey);
        if (imageUrl) {
          imageUrl = window.JdrApp.modules.images.processImageUrl(imageUrl);
          imageStyle = 'display: inline-block;';
          removeStyle = 'display: inline-flex;';
        }
      }

      if (JdrApp.utils.isDevMode()) {
        return `
          <div class="illus" data-illus-key="${illusKey}" data-bound="1">
            <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
            <label class="up">ğŸ“· Ajouter<input accept="image/*" hidden="" type="file"></label>
            <button class="rm" type="button" style="${removeStyle}">ğŸ—‘ Retirer</button>
          </div>
        `;
      }
      
      return `
        <div class="illus" data-illus-key="${illusKey}" data-bound="1">
          <img alt="Illustration ${altText}" class="thumb" style="${imageStyle}"${imageUrl ? ` src="${imageUrl}"` : ''}>
        </div>
      `;
    }

    buildEditButton(type) {
      const titles = {
        title: 'Ã‰diter le titre',
        paragraph: 'Ã‰diter ce paragraphe',
        field: 'Ã‰diter ce champ',
        list: 'Ã‰diter cette liste',
        section: 'Ã‰diter cette section'
      };

      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="edit-btn edit-${type}-btn" title="${titles[type] || 'Ã‰diter'}">âœï¸</button>`;
    }

    buildAddButton(type, categoryName) {
      const config = window.ContentTypes[type];
      const icon = config?.icons?.add || 'â•';
      
      // ALWAYS generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="${type}-add btn" data-category-name="${categoryName}" type="button" style="background: var(--accent); color: white;">${icon} Ajouter un ${type === 'spell' ? 'sort' : type === 'don' ? 'don' : 'Ã©lÃ©ment'}</button>`;
    }

    buildDeleteCategoryButton(type, categoryName) {
      const config = window.ContentTypes[type];
      const deleteIcon = config?.icons?.delete || 'ğŸ—‘ï¸';
      
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="${type}-category-delete btn" data-category-name="${categoryName}" data-category-type="${type}" type="button" style="background: #dc2626; color: white;">${deleteIcon} Supprimer catÃ©gorie</button>`;
    }

    buildAddSubclassButton() {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<div class="add-subclass-btn">â• Ajouter une sous-classe</div>`;
    }

    buildAddSectionButton() {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<div class="add-paragraph-btn" data-target="section">â• Ajouter une nouvelle section</div>`;
    }

    buildAddParagraphButton(target) {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<div class="add-paragraph-btn" data-target="${target}">â• Ajouter un paragraphe</div>`;
    }

    buildRemoveSectionButton(sectionType) {
      // Always generate the button - CSS will control visibility based on body.dev-on/dev-off
      return `<button class="remove-section-btn" data-section-type="${sectionType}" type="button" style="background: #dc2626; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 12px;">ğŸ—‘ Supprimer section</button>`;
    }

    getItemsProperty(type) {
      switch (type) {
        case 'spell': return 'sorts';
        case 'don': return 'dons';
        case 'objet': return 'objets';
        case 'class': return 'sousClasses';
        default: return 'items';
      }
    }

    // Extract level number from prerequis text
    extractLevelFromPrerequisite(prerequis) {
      if (!prerequis) return 0;
      const match = prerequis.match(/Niveau (\d+)/i);
      return match ? parseInt(match[1], 10) : 0;
    }

    // Sort spells by level (prerequisite level)
    sortSpellsByLevel(spells) {
      return spells.sort((a, b) => {
        const levelA = this.extractLevelFromPrerequisite(a.prerequis);
        const levelB = this.extractLevelFromPrerequisite(b.prerequis);
        return levelA - levelB;
      });
    }

    // Build spell level filter UI
    buildSpellLevelFilter() {
      return `
        <div class="spell-level-filter" style="margin: 1rem 0; padding: 1rem; background: var(--card); border: 2px solid var(--rule); border-radius: 12px;">
          <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
            <label style="font-weight: 600; color: var(--accent-ink);">
              ğŸ¯ Filtrer par niveau maximum :
            </label>
            <div style="display: flex; align-items: center; gap: 0.5rem;">
              <input 
                type="number" 
                id="spell-level-filter" 
                min="0" 
                max="20" 
                value="20"
                style="width: 80px; padding: 0.5rem; border: 1px solid var(--rule); border-radius: 6px; text-align: center; font-weight: 600;"
              >
              <button 
                id="reset-spell-filter" 
                class="btn small" 
                style="background: var(--bronze); color: white; padding: 0.5rem 1rem;"
                title="RÃ©initialiser le filtre"
              >
                ğŸ”„ Tout afficher
              </button>
            </div>
          </div>
        </div>
      `;
    }

    buildTagFilters(visibleTags, availableTags) {
      const filterChips = visibleTags.map(tag => 
        `<span class="filter-chip active" data-tag="${tag}">${tag}</span>`
      ).join('');
      
      return `
        <div class="tag-filters" style="margin: 1rem 0; padding: 1rem; background: var(--card); border: 2px solid var(--rule); border-radius: 12px;">
          <div style="display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;">
            <label style="font-weight: 600; color: var(--accent-ink);">
              ğŸ·ï¸ Filtres actifs :
            </label>
            <div class="filter-chips" style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
              ${filterChips}
            </div>
          </div>
        </div>
      `;
    }
    
    buildFilterManagerButton() {
      // Only show in dev mode
      if (!this.shouldShowEditButtons) {
        return '';
      }
      return `<button class="filter-manager-btn btn" type="button" style="background: var(--bronze); color: white;">âš™ï¸ GÃ©rer les filtres</button>`;
    }

    sanitizeId(str) {
      return str.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    }
  }

  window.PageBuilder = PageBuilder.getInstance();

})();
// ============================================================================
// JDR-BAB APPLICATION - UTILITIES MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // DEV MODE UTILITIES
  // ========================================
  JdrApp.utils.isDevMode = function() {
    // Simple check - if it's standalone, dev mode is always false
    if (window.STANDALONE_VERSION) return false;
    
    // Use the editor's actual state instead of CSS classes for reliability
    if (JdrApp.modules && JdrApp.modules.editor) {
      return JdrApp.modules.editor.isDevMode;
    }
    
    // Fallback: check body class if editor not available yet
    return document.body.classList.contains('dev-on');
  };

  // ========================================
  // CENTRALIZED EVENT MANAGEMENT
  // ========================================
  JdrApp.utils.events = {
    listeners: new Map(),
    
    // Centralized event registration
    register(type, selector, handler, options = {}) {
      const key = `${type}-${selector || 'window'}-${Date.now()}`;
      const wrapper = (e) => {
        if (!selector) {
          handler(e);
        } else {
          // GÃ©rer les sÃ©lecteurs spÃ©ciaux comme [class$="-add"]
          if (this.matchesSelector(e.target, selector)) {
            handler(e);
          }
        }
      };
      
      if (selector) {
        document.addEventListener(type, wrapper, options);
      } else {
        window.addEventListener(type, wrapper, options);
      }
      
      this.listeners.set(key, { type, wrapper, options });
      return key;
    },

    // Helper pour matcher les sÃ©lecteurs complexes
    matchesSelector(element, selector) {
      // GÃ©rer les sÃ©lecteurs d'attributs comme [class$="-add"]
      if (selector.startsWith('[class$="') && selector.endsWith('"]')) {
        const suffix = selector.slice(9, -2); // Extraire "-add" de '[class$="-add"]'
        return element.className && element.className.split(' ').some(cls => cls.endsWith(suffix));
      }
      
      // GÃ©rer les sÃ©lecteurs d'attributs comme [class*="something"]
      if (selector.startsWith('[class*="') && selector.endsWith('"]')) {
        const substring = selector.slice(9, -2); // Extraire "something" 
        return element.className && element.className.includes(substring);
      }
      
      // Utiliser la mÃ©thode native pour les autres sÃ©lecteurs
      try {
        return element.matches(selector) || element.closest(selector);
      } catch (e) {
        // Fallback pour les sÃ©lecteurs invalides
        return false;
      }
    },
    
    // Delayed execution manager
    delayed: new Map(),
    timeout(key, fn, delay = 0) {
      if (this.delayed.has(key)) {
        clearTimeout(this.delayed.get(key));
      }
      const id = setTimeout(() => {
        fn();
        this.delayed.delete(key);
      }, delay);
      this.delayed.set(key, id);
    },
    
    // Common event handlers
    onDOMReady(fn) {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', fn);
      } else {
        fn();
      }
    },
    
    onHashChange(fn) {
      window.addEventListener('hashchange', fn);
    },
    
    onRouteChange(fn) {
      this.onHashChange(() => this.timeout('route-change', fn, 0));
      this.onDOMReady(() => this.timeout('dom-ready-route', fn, 0));
    }
  };

  // ========================================
  // DOM UTILITIES LIBRARY
  // ========================================
  JdrApp.utils.dom = {
    // Common selectors
    $(selector) { return document.querySelector(selector); },
    $(selector) { return document.querySelectorAll(selector); },
    
    // Element creation with common patterns
    create(tag, className = '', innerHTML = '', attributes = {}) {
      const el = document.createElement(tag);
      if (className) el.className = className;
      if (innerHTML) el.innerHTML = innerHTML;
      Object.entries(attributes).forEach(([key, value]) => {
        el.setAttribute(key, value);
      });
      return el;
    },
    
    
    // Safe innerHTML replacement
    safeSetHTML(element, html) {
      if (element) {
        element.innerHTML = html;
      }
    },
    
    // Safe text content setting
    safeSetText(element, text) {
      if (element) {
        element.textContent = text;
      }
    },
    
    // Toggle class utility
    toggleClass(element, className, force = null) {
      if (element) {
        if (force !== null) {
          element.classList.toggle(className, force);
        } else {
          element.classList.toggle(className);
        }
      }
    },
    
    // Show/hide utilities
    show(element, display = 'block') {
      if (element) {
        element.style.display = display;
      }
    },
    
    hide(element) {
      if (element) {
        element.style.display = 'none';
      }
    }
  };

  // ========================================
  // DATA UTILITIES
  // ========================================
  JdrApp.utils.data = {
    // Find spell by name across all categories
    findSpell(name) {
      if (!window.SORTS) return null;
      
      for (const category of window.SORTS) {
        const spell = category.sorts.find(s => s.nom === name);
        if (spell) return { spell, category: category.nom };
      }
      return null;
    },
    
    // Find class by name
    findClass(name) {
      if (!window.CLASSES) return null;
      return window.CLASSES.find(c => c.nom === name);
    },
    
    // Find don by name across all categories
    findDon(name) {
      if (!window.DONS) return null;
      
      for (const category of window.DONS) {
        const don = category.dons.find(d => d.nom === name);
        if (don) return { don, category: category.nom };
      }
      return null;
    },
    
    // Get spell category by name
    getSpellCategory(categoryName) {
      if (!window.SORTS) return null;
      return window.SORTS.find(cat => cat.nom === categoryName);
    },
    
    // Get don category by name
    getDonCategory(categoryName) {
      if (!window.DONS) return null;
      return window.DONS.find(cat => cat.nom === categoryName);
    },
    
    // Deep clone object
    deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    },
    
    // Sanitize string for use as identifier
    sanitizeId(str) {
      return str.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    },
    
    // Generate unique ID
    generateId(prefix = 'id') {
      return `${prefix}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    },
    
    // Escape HTML
    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  };

  // ========================================
  // IMAGE UTILITIES
  // ========================================
  
  // Compress image function
  JdrApp.utils.compressImage = function(file, maxWidth = 800, quality = 0.85) {
    return new Promise((resolve, reject) => {
      
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      
      img.onload = function() {
        // Calculate new dimensions
        let { width, height } = img;
        
        if (width > maxWidth) {
          height = (height * maxWidth) / width;
          width = maxWidth;
        }
        
        // Set canvas size
        canvas.width = width;
        canvas.height = height;
        
        // Detect if image has transparency (PNG)
        const isPNG = file.type === 'image/png' || file.name.toLowerCase().endsWith('.png');
        
        if (isPNG) {
          // For PNG, don't compress at all to preserve quality
          resolve(file);
        } else {
          // For JPEG/other formats, use white background
          ctx.fillStyle = '#FFFFFF';
          ctx.fillRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);
          
          canvas.toBlob((blob) => {
            resolve(blob);
          }, 'image/jpeg', quality);
        }
      };
      
      img.onerror = (error) => {
        reject(error);
      };
      
      img.src = URL.createObjectURL(file);
    });
  };

  // Upload to ImageBB function
  JdrApp.utils.uploadToImageBB = function(file) {
    return new Promise((resolve, reject) => {
      // ImageBB API key
      const API_KEY = '06a98f5c0c2dad952e6ab94b03040f36';
      
      const formData = new FormData();
      formData.append('image', file);
      
      fetch(`https://api.imgbb.com/1/upload?key=${API_KEY}`, {
        method: 'POST',
        body: formData
      })
      .then(response => {
        return response.json();
      })
      .then(data => {
        if (data.success) {
          resolve(data.data.url);
        } else {
          throw new Error('Upload failed: ' + (data.error ? data.error.message : 'Unknown error'));
        }
      })
      .catch(error => {
        // Fallback to local storage
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    });
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - IMAGES MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // IMAGES MANAGEMENT MODULE
  // ========================================
  JdrApp.modules.images = {
    // Store for preloaded images
    imageStore: {},
    
    async init() {
      await this.loadImageData();
      this.initImageHandlers();
    },

    // Load image data from JSON file or embedded data
    async loadImageData() {
      try {
        if (window.IMAGES) {
          this.imageStore = window.IMAGES.images || window.IMAGES || {};
          return;
        }
        
        const response = await fetch('./data/images.json');
        if (response.ok) {
          const data = await response.json();
          this.imageStore = data.images || {};
        } else {
          this.imageStore = {};
        }
      } catch (error) {
        this.imageStore = {};
      }
    },

    // Get image URL for a given key
    getImageUrl(illusKey) {
      return this.imageStore[illusKey] || null;
    },

    // Apply image to an illustration element
    applyImage(illusElement, imageUrl) {
      if (!illusElement || !imageUrl) return;

      const img = illusElement.querySelector('img.thumb');
      if (!img) return;

      // Set image source and make it visible
      img.src = this.processImageUrl(imageUrl);
      img.style.display = 'inline-block';
      img.style.opacity = '1'; // Reset opacity after upload
      
      // Show remove button if it exists
      const removeBtn = illusElement.querySelector('.rm');
      if (removeBtn) {
        removeBtn.style.display = 'inline-flex';
      }

    },

    // Process image URL to handle proxying for mobile compatibility
    processImageUrl(originalUrl) {
      // If it's an i.ibb.co URL, use proxy for better mobile compatibility
      if (originalUrl.includes('i.ibb.co') && !originalUrl.includes('images.weserv.nl')) {
        return `https://images.weserv.nl/?url=${encodeURIComponent(originalUrl)}`;
      }
      return originalUrl;
    },

    autoLoadImages() {
      const illusElements = document.querySelectorAll('[data-illus-key]');
      let loadedCount = 0;

      illusElements.forEach(illusElement => {
        const illusKey = illusElement.dataset.illusKey;
        const imageUrl = this.getImageUrl(illusKey);
        
        if (imageUrl) {
          this.applyImage(illusElement, imageUrl);
          loadedCount++;
        }
      });

      return loadedCount;
    },

    // Initialize image upload handlers
    initImageHandlers() {
      // Delegate image upload handling
      document.addEventListener('change', (event) => {
        if (event.target.matches('.illus input[type="file"]')) {
          this.handleImageUpload(event.target);
        }
      });

      // Delegate image removal handling  
      document.addEventListener('click', (event) => {
        if (event.target.matches('.illus .rm')) {
          this.handleImageRemoval(event.target);
        }
      });
    },

    // Handle image upload
    async handleImageUpload(fileInput) {
      const file = fileInput.files[0];
      if (!file) return;

      const illusElement = fileInput.closest('.illus');
      if (!illusElement) return;

      const illusKey = illusElement.dataset.illusKey;
      
      try {
        // Show loading state
        const img = illusElement.querySelector('img.thumb');
        if (img) {
          img.style.opacity = '0.5';
        }

        // Compress and upload image
        const compressedFile = await JdrApp.utils.compressImage(file, 800, 0.8);
        const imageUrl = await JdrApp.utils.uploadToImageBB(compressedFile);
        
        // Apply the uploaded image
        this.applyImage(illusElement, imageUrl);
        
        // Update local store
        this.imageStore[illusKey] = imageUrl;
        
        
      } catch (error) {
        // Reset loading state
        const img = illusElement.querySelector('img.thumb');
        if (img) {
          img.style.opacity = '1';
        }
        
        alert('Erreur lors du tÃ©lÃ©chargement de l\'image. Veuillez rÃ©essayer.');
      }
      
      // Clear file input
      fileInput.value = '';
    },

    // Handle image removal
    handleImageRemoval(removeBtn) {
      const illusElement = removeBtn.closest('.illus');
      if (!illusElement) return;

      const illusKey = illusElement.dataset.illusKey;
      const img = illusElement.querySelector('img.thumb');
      
      if (img) {
        img.src = '';
        img.style.display = 'none';
      }
      
      removeBtn.style.display = 'none';
      
      // Remove from store
      delete this.imageStore[illusKey];
      
    },

    // Manually add/update an image
    setImage(illusKey, imageUrl) {
      this.imageStore[illusKey] = imageUrl;
      
      // Apply to any existing elements with this key
      const illusElements = document.querySelectorAll(`[data-illus-key="${illusKey}"]`);
      illusElements.forEach(element => {
        this.applyImage(element, imageUrl);
      });
    },

    // Get all current images for export
    getAllImages() {
      return { ...this.imageStore };
    },

    // Import images from external data
    importImages(imageData) {
      if (typeof imageData === 'object' && imageData !== null) {
        Object.assign(this.imageStore, imageData);
        this.autoLoadImages();
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - STORAGE MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // STORAGE MODULE
  // ========================================
  JdrApp.modules.storage = {
    
    init() {
      
      // Clear localStorage on startup - JSON files are always source of truth
      this.clearStorageOnStartup();
      
      // Set up save handlers
      JdrApp.utils.events.register('click', '#saveAndExport', () => this.saveAndExportZip());
      
      
      
      // Auto-save functionality
      this.setupAutoSave();
    },

    setupAutoSave() {
      // Auto-save disabled - we save immediately on each edit instead
      // Previously: Auto-save every 30 seconds if in dev mode
    },

    clearStorageOnStartup() {
      // Clear all localStorage data on page load - JSON files are source of truth
      localStorage.removeItem('jdr-bab-edits');
      localStorage.removeItem('jdr-bab-static-pages');
      localStorage.removeItem('jdr-bab-last-modified');
    },

    saveChanges(silent = false) {
      try {
        // Force collect all pending edits
        const editedData = JdrApp.modules.editor ? JdrApp.modules.editor.forceCollectAllEdits() : {};
        
        // Data is already saved in memory (window.STATIC_PAGES, window.SORTS, etc.)
        // No localStorage persistence needed - JSON files are source of truth
        
        if (!silent) {
          this.showNotification('ğŸ’¾ Modifications sauvegardÃ©es en mÃ©moire', 'success');
        }
        
      } catch (error) {
        console.error('âŒ Failed to save changes:', error);
        if (!silent) {
          this.showNotification('âŒ Erreur lors de la sauvegarde', 'error');
        }
      }
    },

    async saveAndExportZip() {
      try {
        this.showNotification('ğŸ“¦ CrÃ©ation de l\'archive ZIP...', 'info');
        
        // Force collect all pending edits
        JdrApp.modules.editor.forceCollectAllEdits();
        
        // Check if JSZip is available
        if (typeof JSZip === 'undefined') {
          await this.loadJSZip();
        }
        
        const zip = new JSZip();
        
        // Add main HTML file
        const mainHTML = await this.getMainHTML();
        zip.file('index.html', mainHTML);
        
        // Add CSS files
        const cssFiles = ['theme.css', 'utilities.css', 'components.css', 'layout.css', 'editor.css'];
        for (const cssFile of cssFiles) {
          const cssContent = await this.fetchFileContent(`css/${cssFile}`);
          if (cssContent) {
            zip.file(`css/${cssFile}`, cssContent);
          }
        }
        
        // Add JS files
        const jsFiles = ['core.js', 'utils.js', 'router.js', 'renderer.js', 'editor.js', 'storage.js', 'ui.js'];
        for (const jsFile of jsFiles) {
          const jsContent = await this.fetchFileContent(`js/${jsFile}`);
          if (jsContent) {
            zip.file(`js/${jsFile}`, jsContent);
          }
        }
        
        // Add modules
        const moduleFiles = ['images.js'];
        for (const moduleFile of moduleFiles) {
          const moduleContent = await this.fetchFileContent(`js/modules/${moduleFile}`);
          if (moduleContent) {
            zip.file(`js/modules/${moduleFile}`, moduleContent);
          }
        }
        
        // Add data files with current edits
        zip.file('data/sorts.json', JSON.stringify(window.SORTS, null, 2));
        zip.file('data/classes.json', JSON.stringify(window.CLASSES, null, 2));
        zip.file('data/dons.json', JSON.stringify(window.DONS, null, 2));
        zip.file('data/objets.json', JSON.stringify(window.OBJETS, null, 2));
        
        // Add static pages config and data
        if (window.STATIC_PAGES_CONFIG) {
          zip.file('data/static-pages-config.json', JSON.stringify(window.STATIC_PAGES_CONFIG, null, 2));
        }
        
        if (window.STATIC_PAGES) {
          for (const [pageId, pageData] of Object.entries(window.STATIC_PAGES)) {
            zip.file(`data/${pageId}.json`, JSON.stringify(pageData, null, 2));
          }
        }
        
        // Note: All static pages are now handled via window.STATIC_PAGES above
        
        // Add current images (including newly uploaded ones)
        if (JdrApp.modules.images && JdrApp.modules.images.getAllImages) {
          const currentImages = JdrApp.modules.images.getAllImages();
          const imagesData = {
            images: currentImages,
            meta: {
              total_images: Object.keys(currentImages).length,
              exported_date: new Date().toISOString().slice(0, 10),
              note: "Ces images incluent les nouvelles images uploadÃ©es"
            }
          };
          zip.file('data/images.json', JSON.stringify(imagesData, null, 2));
        }
        
        // Add package.json and other config files
        const configFiles = ['package.json'];
        for (const configFile of configFiles) {
          const configContent = await this.fetchFileContent(configFile);
          if (configContent) {
            zip.file(configFile, configContent);
          }
        }
        
        // Generate and download ZIP
        const zipBlob = await zip.generateAsync({type: 'blob'});
        const timestamp = new Date().toISOString().slice(0, 16).replace(/[:-]/g, '');
        this.downloadFile(`JdrBab-${timestamp}.zip`, zipBlob, 'application/zip');
        
        this.showNotification('ğŸ“¦ Archive ZIP crÃ©Ã©e et tÃ©lÃ©chargÃ©e!', 'success');
        
      } catch (error) {
        console.error('âŒ Failed to create ZIP:', error);
        this.showNotification('âŒ Erreur lors de la crÃ©ation du ZIP', 'error');
      }
    },

    async loadJSZip() {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    },

    async fetchFileContent(filePath) {
      try {
        const response = await fetch(filePath);
        if (response.ok) {
          return await response.text();
        }
        // Could not fetch file
        return null;
      } catch (error) {
        // Error fetching file
        return null;
      }
    },

    async getMainHTML() {
      // Get the current index.html content or reconstruct it
      try {
        const response = await fetch('index.html');
        if (response.ok) {
          return await response.text();
        }
      } catch (error) {
        // Could not fetch index.html, generating from current state
      }
      
      // Fallback: generate HTML from current document state
      return `<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta name="referrer" content="no-referrer-when-downgrade">
<title>JDRâ€‘BAB â€” Livret de rÃ¨gles</title>
<meta content="Livret web multipages des rÃ¨gles JDRâ€‘BAB, thÃ¨me parchemin, illustrations par catÃ©gorie/classe/sousâ€‘classe, export HTML autonome." name="description">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;500;600&amp;family=Source+Serif+Pro:ital,wght@0,400;0,600;0,700;1,400;1,600&amp;display=swap" rel="stylesheet">

<!-- CSS Modulaire -->
<link rel="stylesheet" href="css/theme.css">
<link rel="stylesheet" href="css/utilities.css">
<link rel="stylesheet" href="css/components.css">
<link rel="stylesheet" href="css/layout.css">
<link rel="stylesheet" href="css/editor.css">
</head>
<body class="dev-off" style="">

<!-- Le contenu HTML complet sera injectÃ© ici par le JavaScript -->
<div id="app-loading">Chargement...</div>

<!-- JavaScript Modulaire -->
</body>
</html>`;
    },


    downloadJSON(filename, data) {
      const json = JSON.stringify(data, null, 2);
      this.downloadFile(filename, json, 'application/json');
    },

    downloadFile(filename, content, mimeType = 'text/html') {
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.style.display = 'none';
      
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      
      URL.revokeObjectURL(url);
    },

    showNotification(message, type = 'info') {
      // Simple notification system
      const notification = document.createElement('div');
      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${type === 'success' ? '#10B981' : type === 'error' ? '#EF4444' : '#3B82F6'};
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        font-weight: 500;
        z-index: 10000;
        animation: slideIn 0.3s ease;
      `;
      
      // Add animation
      const style = document.createElement('style');
      style.textContent = `
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
      `;
      document.head.appendChild(style);
      
      notification.textContent = message;
      document.body.appendChild(notification);
      
      // Auto-remove after 3 seconds
      setTimeout(() => {
        if (notification.parentNode) {
          notification.parentNode.removeChild(notification);
        }
      }, 3000);
    },

    // Load edits from localStorage on startup
    loadStoredEdits() {
      try {
        const storedEdits = localStorage.getItem('jdr-bab-edits');
        
        if (storedEdits && JdrApp.modules.editor) {
          JdrApp.modules.editor.editedData = JSON.parse(storedEdits);
        }
        
        // Load stored static pages data (includes dynamically created sections)
        const storedStaticPages = localStorage.getItem('jdr-bab-static-pages');
        if (storedStaticPages) {
          const staticPagesData = JSON.parse(storedStaticPages);
          
          // Merge with existing STATIC_PAGES data
          if (window.STATIC_PAGES) {
            Object.assign(window.STATIC_PAGES, staticPagesData);
          } else {
            window.STATIC_PAGES = staticPagesData;
          }
          
          console.log('Restored static pages data from localStorage:', Object.keys(staticPagesData));
        }
        
        // Ne plus charger jdr-bab-data - laisser les JSON Ãªtre la source de vÃ©ritÃ©
        
      } catch (error) {
        console.warn('Failed to load stored edits:', error);
      }
    },

    // Handle ZIP file import
    async handleZipImport(event) {
      const file = event.target.files[0];
      if (!file || file.type !== 'application/zip') {
        this.showNotification('âŒ Veuillez sÃ©lectionner un fichier ZIP', 'error');
        return;
      }

      try {
        this.showNotification('ğŸ“¥ Import en cours...', 'info');

        // Check if JSZip is available
        if (typeof JSZip === 'undefined') {
          await this.loadJSZip();
        }

        const zip = new JSZip();
        const contents = await zip.loadAsync(file);

        // Import data files
        const dataFiles = ['sorts.json', 'classes.json', 'dons.json', 'objets.json'];
        for (const dataFile of dataFiles) {
          const zipFile = contents.file(`data/${dataFile}`);
          if (zipFile) {
            const content = await zipFile.async('text');
            const data = JSON.parse(content);
            
            if (dataFile === 'sorts.json') {
              window.SORTS = data;
            } else if (dataFile === 'classes.json') {
              window.CLASSES = data;
            } else if (dataFile === 'dons.json') {
              window.DONS = data;
            } else if (dataFile === 'objets.json') {
              window.OBJETS = data;
            }
          }
        }

        // Import static pages config
        const configFile = contents.file('data/static-pages-config.json');
        if (configFile) {
          const configContent = await configFile.async('text');
          window.STATIC_PAGES_CONFIG = JSON.parse(configContent);
        }

        // Import static pages data
        if (window.STATIC_PAGES_CONFIG && window.STATIC_PAGES_CONFIG.pages) {
          window.STATIC_PAGES = {};
          for (const pageConfig of window.STATIC_PAGES_CONFIG.pages) {
            if (pageConfig.active) {
              const pageFile = contents.file(`data/${pageConfig.file}`);
              if (pageFile) {
                const pageContent = await pageFile.async('text');
                window.STATIC_PAGES[pageConfig.id] = JSON.parse(pageContent);
              }
            }
          }
        }

        // Import images
        const imagesFile = contents.file('data/images.json');
        if (imagesFile && JdrApp.modules.images && JdrApp.modules.images.importImages) {
          const imagesContent = await imagesFile.async('text');
          const imagesData = JSON.parse(imagesContent);
          if (imagesData.images) {
            JdrApp.modules.images.importImages(imagesData.images);
          }
        }

        // Save imported data to localStorage
        this.saveChanges(true);

        this.showNotification('âœ… Import rÃ©ussi! Rechargement...', 'success');

        // Reload page to show imported data
        setTimeout(() => {
          window.location.reload();
        }, 1000);

      } catch (error) {
        this.showNotification('âŒ Erreur lors de l\'import', 'error');
      }

      // Reset file input
      event.target.value = '';
    },


  };

})();
// ============================================================================
// JDR-BAB APPLICATION - ROUTER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // ROUTING SYSTEM
  // ========================================
  JdrApp.modules.router = {
    currentRoute: '',
    
    init() {
      
      // Set up route change listeners
      JdrApp.utils.events.onHashChange(() => this.parseRoute());
      JdrApp.utils.events.onDOMReady(() => this.parseRoute());
    },
    
    parseRoute() {
      const hash = location.hash.replace('#/', '');
      const page = hash || 'creation';
      const exists = JdrApp.utils.dom.$(`article[data-page="${page}"]`);
      
      this.currentRoute = page;
      
      // Handle dynamic category routing
      if (!exists) {
        if (this.handleDynamicRoute(page)) {
          return; // Route was handled dynamically
        }
      }
      
      this.show(exists ? page : 'creation');
    },

    handleDynamicRoute(page) {
      // Handle sorts-* routes
      if (page.startsWith('sorts-')) {
        return this.renderDynamicCategory('sorts', 'spell', page);
      }
      
      // Handle dons-* routes  
      if (page.startsWith('dons-')) {
        return this.renderDynamicCategory('dons', 'don', page);
      }
      
      // Handle single objets page (objects now use unified page with tag filtering)
      if (page === 'objets') {
        return this.renderObjectsPage();
      }
      
      return false; // Route not handled
    },

    renderDynamicCategory(prefix, type, page) {
      const categoryId = page.replace(`${prefix}-`, '');
      const dataKey = prefix.toUpperCase();
      const dataSource = window[dataKey];
      
      if (!dataSource) return false;
      
      const category = dataSource.find(cat => 
        JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
      );
      
      if (category) {
        // Render the category page dynamically
        JdrApp.modules.renderer.renderCategoryPage(type, category);
        
        // Update active states
        this.updateActiveStates(page);
        
        return true;
      }
      
      return false;
    },

    updateActiveStates(page) {
      // Remove active class from all articles and links
      document.querySelectorAll('article').forEach(a => a.classList.remove('active'));
      document.querySelectorAll('.toc a').forEach(a => a.classList.remove('active'));
      
      // Set active link in TOC
      const activeLink = document.querySelector(`a[href="#/${page}"]`);
      if (activeLink) {
        activeLink.classList.add('active');
        
        // Expand parent category if needed
        const category = activeLink.closest('.toc-category');
        if (category) {
          category.classList.remove('collapsed');
        }
      }
    },
    
    show(page) {
      document.querySelectorAll('article').forEach(a => a.classList.remove('active'));
      const target = document.querySelector(`article[data-page="${page}"]`);
      if (target) target.classList.add('active');
      
      document.querySelectorAll('.toc a').forEach(a => a.classList.remove('active'));
      const activeLink = document.querySelector(`a[href="#/${page}"]`);
      if (activeLink) activeLink.classList.add('active');
      
      // Ensure edit buttons state is properly applied after navigation
      if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
        setTimeout(() => {
          if (JdrApp.modules.editor.isDevMode) {
            JdrApp.modules.editor.forceShowAllEditButtons();
          } else {
            JdrApp.modules.editor.forceHideAllEditButtons();
          }
        }, 50);
      }
    },
    
    navigate(route) {
      location.hash = `#/${route}`;
    },
    
    getCurrentRoute() {
      return this.currentRoute;
    },
    
    // Generate table of contents based on hierarchical structure
    generateTOC() {
      const tocContainer = document.querySelector('#toc');
      if (!tocContainer) return;

      if (!window.TOC_STRUCTURE) {
        console.warn('TOC_STRUCTURE not loaded, falling back to basic TOC');
        this.generateBasicTOC();
        return;
      }

      const tocHTML = `
        <h4>Sommaire</h4>
        ${window.TOC_STRUCTURE.sections
          .filter(section => !section.requiresMJ || window.JdrApp.state.isMJ)
          .map(section => this.generateTOCSection(section)).join('')}
        <div class="mj-toggle-container" style="margin: 1rem 0; text-align: center; border-top: 2px solid var(--rule); padding-top: 1rem;">
          <button id="mjToggleBtn" class="btn-base btn-small" style="background: var(--bronze); color: white; border-color: var(--bronze);">
            ğŸ­ MaÃ®tre de jeu
          </button>
        </div>
      `;
      
      tocContainer.innerHTML = tocHTML;
      
      // Attacher les Ã©vÃ©nements directement aux Ã©lÃ©ments aprÃ¨s crÃ©ation
      this.attachFoldoutEvents();
      
      // Ajouter l'event listener pour le bouton MJ
      this.setupMJToggle();
    },

    setupMJToggle() {
      const mjBtn = document.getElementById('mjToggleBtn');
      if (!mjBtn) return;

      const handleMJToggle = () => {
        if (window.JdrApp.state.isMJ) {
          // DÃ©jÃ  en mode MJ, dÃ©sactiver
          window.JdrApp.state.isMJ = false;
          mjBtn.style.background = 'var(--bronze)';
          mjBtn.innerHTML = 'ğŸ­ MaÃ®tre de jeu';
          this.generateTOC(); // RÃ©gÃ©nÃ©rer le TOC pour cacher les sections MJ
        } else {
          // Demander confirmation avant d'activer le mode MJ
          this.showMJConfirmation(() => {
            window.JdrApp.state.isMJ = true;
            mjBtn.style.background = 'var(--gold)';
            mjBtn.innerHTML = 'ğŸ­ Mode MJ activÃ©';
            this.generateTOC(); // RÃ©gÃ©nÃ©rer le TOC pour afficher les sections MJ
          });
        }
      };

      // Ajouter support tactile pour mobile
      mjBtn.addEventListener('click', handleMJToggle);
      mjBtn.addEventListener('touchend', (e) => {
        e.preventDefault();
        handleMJToggle();
      });
    },

    attachFoldoutEvents() {
      // Attacher les Ã©vÃ©nements directement aux headers de section
      document.querySelectorAll('.toc-section-header').forEach(header => {
        header.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const section = header.closest('.toc-section');
          if (section) {
            const wasCollapsed = section.classList.contains('collapsed');
            section.classList.toggle('collapsed');
            const isCollapsed = section.classList.contains('collapsed');
            
            const toggle = section.querySelector('.toc-section-toggle');
            if (toggle) {
              toggle.textContent = isCollapsed ? 'â–¶' : 'â–¼';
            }
            
            const content = section.querySelector('.toc-section-content');
            if (content) {
              // Force les styles directement en JavaScript pour compatibilitÃ© standalone
              if (isCollapsed) {
                content.style.maxHeight = '0px';
                content.style.opacity = '0';
                content.style.paddingTop = '0';
                content.style.paddingBottom = '0';
                content.style.overflow = 'hidden';
              } else {
                content.style.maxHeight = '500px';
                content.style.opacity = '1';
                content.style.paddingTop = '';
                content.style.paddingBottom = '';
                content.style.overflow = 'visible';
              }
            }
          }
        });
      });

      // Attacher les Ã©vÃ©nements aux liens de catÃ©gorie
      document.querySelectorAll('.toc-category > a').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          e.stopPropagation();
          const category = link.closest('.toc-category');
          if (category) {
            category.classList.toggle('collapsed');
          }
        });
      });

      // Attacher les Ã©vÃ©nements aux liens de navigation normaux
      document.querySelectorAll('.toc a:not(.toc-category > a)').forEach(link => {
        link.addEventListener('click', (e) => {
          e.preventDefault();
          const route = link.getAttribute('data-route');
          if (route) {
            JdrApp.modules.router.navigate(route);
          }
        });
      });
    },

    showMJConfirmation(onConfirm) {
      const modal = document.createElement('div');
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0,0,0,0.7);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
      `;
      
      modal.innerHTML = `
        <div style="
          background: var(--card);
          border: 3px solid var(--bronze);
          border-radius: 16px;
          padding: 2rem;
          max-width: 500px;
          margin: 1rem;
          text-align: center;
          box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        ">
          <h3 style="color: var(--bronze); margin-top: 0;">âš ï¸ Mode MaÃ®tre de jeu</h3>
          <p style="margin: 1.5rem 0; line-height: 1.6;">
            ÃŠtes-vous sÃ»r de vouloir activer le mode MaÃ®tre de jeu?<br><br>
            <strong style="color: var(--bronze);">Si vous Ãªtes juste un joueur, vous risquez d'Ãªtre spoilÃ©!</strong>
          </p>
          <div style="display: flex; gap: 1rem; justify-content: center; margin-top: 2rem;">
            <button id="mjConfirmYes" class="btn-base" style="background: var(--bronze); color: white; border-color: var(--bronze);">
              Oui, je suis MJ
            </button>
            <button id="mjConfirmNo" class="btn-base" style="background: var(--rule); color: var(--accent-ink); border-color: var(--rule);">
              Non, annuler
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      modal.querySelector('#mjConfirmYes').addEventListener('click', () => {
        document.body.removeChild(modal);
        onConfirm();
      });
      
      modal.querySelector('#mjConfirmNo').addEventListener('click', () => {
        document.body.removeChild(modal);
      });
      
      // Fermer en cliquant sur le fond
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          document.body.removeChild(modal);
        }
      });
    },

    generateTOCSection(section) {
      const sectionClass = section.collapsed ? 'toc-section collapsed' : 'toc-section';
      const toggleIcon = section.collapsed ? 'â–¶' : 'â–¼';
      
      return `
        <div class="${sectionClass}" data-section="${section.id}">
          <div class="toc-section-header">
            <span class="toc-section-title">${section.title}</span>
            <span class="toc-section-toggle">${toggleIcon}</span>
          </div>
          <div class="toc-section-content">
            ${section.items.map(item => this.generateTOCItem(item)).join('')}
          </div>
        </div>
      `;
    },

    generateTOCItem(item) {
      if (item.type === 'page') {
        return `<a data-route="${item.id}" href="#/${item.id}" class="">${item.icon} ${item.title}</a>`;
      } else if (item.type === 'category') {
        return this.generateTOCCategory(item);
      }
      return '';
    },

    generateTOCCategory(item) {
      const dataSource = window[item.items]; // CLASSES, SORTS, DONS
      if (!dataSource) return '';

      if (item.id === 'classes') {
        return `
          <div class="toc-category">
            <a data-route="classes" href="#/classes" class="">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource.map(classe => 
                `<a data-route="${JdrApp.utils.data.sanitizeId(classe.nom)}" href="#/${JdrApp.utils.data.sanitizeId(classe.nom)}" class="">${this.getClassIcon(classe.nom)} ${classe.nom}</a>`
              ).join('')}
            </div>
          </div>
        `;
      } else if (item.id === 'sorts') {
        return `
          <div class="toc-category">
            <a data-route="sorts" href="#/sorts">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource.map(category => 
                `<a data-route="sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getSortCategoryIcon(category.nom)} ${category.nom}</a>`
              ).join('')}
            </div>
          </div>
        `;
      } else if (item.id === 'dons') {
        return `
          <div class="toc-category">
            <a data-route="dons" href="#/dons" class="">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource.map(category => 
                `<a data-route="dons-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/dons-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getDonCategoryIcon(category.nom)} ${category.nom}</a>`
              ).join('')}
            </div>
          </div>
        `;
      } else if (item.id === 'monstres') {
        return `
          <div class="toc-category">
            <a data-route="monstres" href="#/monstres" class="">${item.icon} ${item.title}</a>
            <div class="toc-sub">
              ${dataSource && dataSource.length > 0 ? dataSource.map(category => 
                `<a data-route="monstres-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/monstres-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getMonstreCategoryIcon(category.nom)} ${category.nom}</a>`
              ).join('') : '<span style="font-style: italic; color: #666; padding-left: 20px;">Aucun monstre dÃ©fini</span>'}
            </div>
          </div>
        `;
      }

      return '';
    },

    generateBasicTOC() {
      const tocContainer = document.querySelector('#toc');
      if (!tocContainer) return;

      const tocHTML = `
        <h4>Sommaire</h4>
        <a class="" data-route="creation" href="#/creation">ğŸ§™â€â™‚ï¸ CrÃ©ation d'un personnage</a>
        
        <div class="toc-category">
          <a data-route="classes" href="#/classes" class="">âš”ï¸ Classes</a>
          <div class="toc-sub">
            ${window.CLASSES ? window.CLASSES.map(classe => 
              `<a data-route="${JdrApp.utils.data.sanitizeId(classe.nom)}" href="#/${JdrApp.utils.data.sanitizeId(classe.nom)}" class="">${this.getClassIcon(classe.nom)} ${classe.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <div class="toc-category">
          <a data-route="sorts" href="#/sorts">ğŸ”® Sorts</a>
          <div class="toc-sub">
            ${window.SORTS ? window.SORTS.map(category => 
              `<a data-route="sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/sorts-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getSortCategoryIcon(category.nom)} ${category.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <div class="toc-category">
          <a data-route="dons" href="#/dons" class="">ğŸ–ï¸ Dons</a>
          <div class="toc-sub">
            ${window.DONS ? window.DONS.map(category => 
              `<a data-route="dons-${JdrApp.utils.data.sanitizeId(category.nom)}" href="#/dons-${JdrApp.utils.data.sanitizeId(category.nom)}" class="">${this.getDonCategoryIcon(category.nom)} ${category.nom}</a>`
            ).join('') : ''}
          </div>
        </div>
        
        <a data-route="objets" href="#/objets" class="">ğŸ“¦ Objets</a>
        
        <a data-route="elements" href="#/elements" class="">ğŸŒŸ Ã‰lÃ©ments</a>
        <a data-route="stats" href="#/stats" class="">ğŸ“Š Statistiques</a>
        <a data-route="competences-tests" href="#/competences-tests" class="">ğŸ¯ CompÃ©tences & Tests</a>
        <a data-route="etats" href="#/etats" class="">âš¡ Etats</a>
      `;
      
      tocContainer.innerHTML = tocHTML;
    },
    
    renderObjectsPage() {
      if (!window.OBJETS) return false;
      
      // Use the existing show() method for consistency
      this.show('objets');
      
      return true;
    },
    
    getClassIcon(className) {
      const icons = {
        'Guerrier': 'ğŸ—¡ï¸',
        'Mage': 'ğŸ”®',
        'PrÃªtre': 'â›ª',
        'RÃ´deur': 'ğŸƒ',
        'Enchanteur': 'âœ¨'
      };
      return icons[className] || 'âš”ï¸';
    },
    
    getSortCategoryIcon(categoryName) {
      const icons = {
        'Sorts de Mage': 'ğŸ”®',
        'Sorts de PrÃªtre': 'â›ª',
        'Sorts d\'Enchanteur': 'âœ¨',
        'Sorts de Monstres': 'ğŸ’€'
      };
      return icons[categoryName] || 'ğŸ”®';
    },
    
    getDonCategoryIcon(categoryName) {
      const icons = {
        'Guerrier': 'ğŸ—¡ï¸',
        'Mage': 'ğŸ”®',
        'Pretre': 'â›ª',  // Sans accent comme dans les donnÃ©es
        'PrÃªtre': 'â›ª',  // Avec accent au cas oÃ¹
        'RÃ´deur': 'ğŸƒ',
        'Enchanteur': 'âœ¨',
        'GÃ©nÃ©raux': 'ğŸ–ï¸',
        'Generaux': 'ğŸ–ï¸'  // Sans accent comme dans les donnÃ©es
      };
      return icons[categoryName] || 'ğŸ–ï¸';
    },

    getMonstreCategoryIcon(categoryName) {
      const icons = {
        'ForÃªt': 'ğŸŒ²',
        'Foret': 'ğŸŒ²',  // Sans accent
        'Donjon': 'ğŸ°',
        'Dragons': 'ğŸ‰',
        'Mort-vivants': 'ğŸ’€',
        'DÃ©mons': 'ğŸ‘¹',
        'Demons': 'ğŸ‘¹',  // Sans accent
        'Animaux': 'ğŸ¦',
        'HumanoÃ¯des': 'ğŸ§Œ',
        'HumanoÃ¯des': 'ğŸ§Œ'  // Sans accent
      };
      return icons[categoryName] || 'ğŸ‘¹';
    },
    
    getObjetCategoryIcon(categoryName) {
      const icons = {
        'Armes': 'âš”ï¸',
        'Armures': 'ğŸ›¡ï¸',
        'Potions': 'ğŸ§ª',
        'Herbes Magiques': 'ğŸŒ¿',
        'Objets Magiques': 'âœ¨',
        'Accessoires': 'ğŸ’',
        'Consommables': 'ğŸ',
        'Composants': 'ğŸ”®',
        'Outils': 'ğŸ”¨'
      };
      return icons[categoryName] || 'ğŸ“¦';
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - RENDERER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // CONTENT RENDERER MODULE
  // ========================================
  JdrApp.modules.renderer = {
    currentSearch: '',
    
    init() {
      this.generateContent();
      this.autoLoadImages();
      this.setupEventListeners();
    },

    setupEventListeners() {
      EventBus.on(Events.PAGE_RENDER, (payload) => {
        if (payload.type === 'category') {
          this.renderCategoryPage(payload.categoryType, payload.category);
        }
      });

      EventBus.on(Events.CONTENT_ADD, () => {
        setTimeout(() => this.autoLoadImages(), 100);
      });
    },

    generateContent() {
      JdrApp.modules.router.generateTOC.call(JdrApp.modules.router);
      this.generateArticles();
      this.generateDevToolbox();
      
      if (JdrApp.modules.editor) {
        setTimeout(() => {
          if (JdrApp.modules.editor.isDevMode) {
            JdrApp.modules.editor.forceShowAllEditButtons();
          } else {
            JdrApp.modules.editor.forceHideAllEditButtons();
          }
        }, 100);
      }
    },

    generateArticles() {
      const viewsContainer = document.querySelector('#views');
      if (!viewsContainer) return;

      let articlesHTML = '';
      articlesHTML += this.generateStaticPages();
      articlesHTML += this.generateClassPages();
      articlesHTML += this.generateCategoryPages();

      viewsContainer.innerHTML = articlesHTML;
      setTimeout(() => {
        this.autoLoadImages();
        // Reapply dev mode state to new elements
        this.applyDevModeToNewContent();
        // Attach image events for standalone compatibility
        if (JdrApp.modules.editor && JdrApp.modules.editor.attachImageEvents) {
          JdrApp.modules.editor.attachImageEvents();
        }
        // Create proxy buttons for new content
        if (JdrApp.modules.editor && JdrApp.modules.editor.isDevMode) {
          setTimeout(() => JdrApp.modules.editor.createProxyButtons(), 100);
        }
      }, 100);
    },

    applyDevModeToNewContent() {
      if (JdrApp.modules.editor) {
        if (JdrApp.utils.isDevMode()) {
          JdrApp.modules.editor.forceShowAllEditButtons();
        } else {
          JdrApp.modules.editor.forceHideAllEditButtons();
        }
      }
    },


    generateStaticPages() {
      let html = '';
      if (window.STATIC_PAGES) {
        Object.entries(window.STATIC_PAGES).forEach(([pageId, pageData]) => {
          html += PageBuilder.buildStaticPage(pageId, pageData);
        });
      }
      return html;
    },

    generateClassPages() {
      if (!window.CLASSES) return '';
      
      return window.CLASSES.map(classe => 
        PageBuilder.buildClassPage(classe)
      ).join('');
    },

    generateCategoryPages() {
      let html = '';
      
      if (window.SORTS) {
        html += window.SORTS.map(category => 
          PageBuilder.buildCategoryPage('spell', category)
        ).join('');
      }

      if (window.DONS) {
        html += window.DONS.map(category => 
          PageBuilder.buildCategoryPage('don', category)
        ).join('');
      }

      // Generate single objects page (different from category pages)
      if (window.OBJETS) {
        html += PageBuilder.buildSingleObjectPage(window.OBJETS);
      }

      return html;
    },

    renderCategoryPage(type, category) {
      const config = window.ContentTypes[type];
      const pageId = `${config.container}-${JdrApp.utils.data.sanitizeId(category.nom)}`;
      let article = document.querySelector(`article[data-page="${pageId}"]`);
      
      // Create article if it doesn't exist (for dynamically created categories)
      if (!article) {
        article = document.createElement('article');
        article.setAttribute('data-page', pageId);
        article.className = 'active'; // Make it active since we're showing it
        
        const viewsContainer = document.querySelector('#views');
        if (viewsContainer) {
          viewsContainer.appendChild(article);
        } else {
          console.warn('Views container not found');
          return;
        }
      }
      
      const newContent = PageBuilder.buildCategoryPage(type, category);
      const parser = new DOMParser();
      const newDoc = parser.parseFromString(newContent, 'text/html');
      const newArticle = newDoc.querySelector('article');
      
      if (newArticle) {
        article.innerHTML = newArticle.innerHTML;
        
        // Make sure only this article is active
        document.querySelectorAll('article').forEach(a => a.classList.remove('active'));
        article.classList.add('active');
        
        // Plus simple et plus fiable
        this.autoLoadImages();
        
        // Attach image events for standalone compatibility
        if (JdrApp.modules.editor && JdrApp.modules.editor.attachImageEvents) {
          JdrApp.modules.editor.attachImageEvents();
        }
        
        // Ensure dev mode state is applied after content change
        setTimeout(() => {
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          }
        }, 50);
      }
    },

    renderSortCategory(page) {
      const categoryId = page.replace('sorts-', '');
      const category = window.SORTS?.find(cat => 
        JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
      );
      
      if (category) {
        this.renderCategoryPage('spell', category);
      }
    },

    generateDevToolbox() {
      const devToolbox = JdrApp.utils.dom.$('#devToolbox');
      if (!devToolbox) return;

      const toolboxHTML = `
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--rule);">
          <span style="font-size: 18px;">ğŸ› </span>
          <strong style="color: var(--accent-ink); font-family: 'Cinzel', serif;">Outils de dÃ©veloppement</strong>
        </div>
        
        <div style="margin-bottom: 12px;">
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">âœï¸ Ã‰dition</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="saveAndExport" title="Sauvegarder et exporter tout en ZIP">ğŸ’¾ Export ZIP</button>
          </div>
        </div>
        
        <div style="margin-bottom: 12px;">
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">ğŸ“ CrÃ©ation</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="addCategory" title="CrÃ©er une nouvelle catÃ©gorie/page">ğŸ“„ Nouvelle page</button>
            <button class="btn small" id="addSpellCategory" title="CrÃ©er une nouvelle catÃ©gorie de sorts">ğŸ”® CatÃ©gorie de sorts</button>
            <button class="btn small" id="addDonCategory" title="CrÃ©er une nouvelle catÃ©gorie de dons">ğŸ–ï¸ CatÃ©gorie de dons</button>
          </div>
        </div>
        
        <div>
          <div style="font-size: 12px; color: var(--paper-muted); margin-bottom: 6px; text-transform: uppercase; letter-spacing: 0.5px;">ğŸ­ Ressources</div>
          <div style="display: flex; gap: 8px; flex-wrap: wrap;">
            <button class="btn small" id="elementsBtn" title="Choisir un Ã©lÃ©ment pour copier sa balise HTML colorÃ©e">ğŸ¨ Ã‰lÃ©ments</button>
            <button class="btn small" id="etatsBtn" title="Choisir un Ã©tat pour copier sa balise HTML avec tooltip">âš¡ Ã‰tats</button>
          </div>
        </div>
      `;

      devToolbox.innerHTML = toolboxHTML;
    },

    autoLoadImages() {
      if (JdrApp.modules.images) {
        return JdrApp.modules.images.autoLoadImages();
      }
      return 0;
    },

    regenerateCurrentPage() {
      // Find the currently active article
      const activeArticle = document.querySelector('article.active');
      if (!activeArticle) return;

      const pageId = activeArticle.dataset.page;
      if (!pageId) return;

      // Determine what type of page it is and regenerate only that page
      if (pageId.startsWith('sorts-')) {
        const categoryId = pageId.replace('sorts-', '');
        const category = window.SORTS?.find(cat => 
          JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
        );
        if (category) {
          this.renderCategoryPage('spell', category);
        }
      } else if (pageId.startsWith('dons-')) {
        const categoryId = pageId.replace('dons-', '');
        const category = window.DONS?.find(cat => 
          JdrApp.utils.data.sanitizeId(cat.nom) === categoryId
        );
        if (category) {
          this.renderCategoryPage('don', category);
        }
      } else if (pageId === 'objets') {
        // Regenerate objects page using the generic approach
        const newHTML = this.generatePageContent(pageId);
        if (newHTML) {
          activeArticle.innerHTML = newHTML;
          this.autoLoadImages();
          
          // Apply dev mode state immediately
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          }
        }
      } else {
        // For class pages, static pages, etc. - regenerate the specific content
        const newHTML = this.generatePageContent(pageId);
        if (newHTML) {
          activeArticle.innerHTML = newHTML;
          this.autoLoadImages();
          
          // Apply dev mode state immediately
          if (!window.STANDALONE_VERSION && JdrApp.modules.editor) {
            if (JdrApp.modules.editor.isDevMode) {
              JdrApp.modules.editor.forceShowAllEditButtons();
            } else {
              JdrApp.modules.editor.forceHideAllEditButtons();
            }
          }
        }
      }
    },

    generatePageContent(pageId) {
      // Generate content for a specific page without affecting navigation
      if (window.CLASSES) {
        const classe = window.CLASSES.find(c => JdrApp.utils.data.sanitizeId(c.nom) === pageId);
        if (classe) {
          const content = PageBuilder.buildClassPage(classe);
          const parser = new DOMParser();
          const doc = parser.parseFromString(content, 'text/html');
          const article = doc.querySelector('article');
          return article ? article.innerHTML : null;
        }
      }

      if (window.STATIC_PAGES && window.STATIC_PAGES[pageId]) {
        const content = PageBuilder.buildStaticPage(pageId, window.STATIC_PAGES[pageId]);
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        const article = doc.querySelector('article');
        return article ? article.innerHTML : null;
      }

      // Handle objects page
      if (pageId === 'objets' && window.OBJETS) {
        const content = PageBuilder.buildSingleObjectPage(window.OBJETS);
        const parser = new DOMParser();
        const doc = parser.parseFromString(content, 'text/html');
        const article = doc.querySelector('article');
        return article ? article.innerHTML : null;
      }

      return null;
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - UNIFIED EDITOR SYSTEM
// ============================================================================

(() => {
  "use strict";

  class UnifiedEditor {
    constructor() {
      this.currentEditSession = null;
    }

    /*
     * IMPORTANT: Content Restoration Best Practices
     * =============================================
     * ALWAYS use restoreElementContent() for any content that has been edited
     * NEVER directly assign to innerHTML in editing contexts
     * This prevents HTML tags from being displayed as visible text
     */

    static getInstance() {
      if (!UnifiedEditor.instance) {
        UnifiedEditor.instance = new UnifiedEditor();
      }
      return UnifiedEditor.instance;
    }

    // Parse edit context from DOM element
    parseEditContext(element) {
      const editableElement = element.classList.contains('editable-section') 
        ? element.querySelector('.editable') 
        : element;

      if (!editableElement) return null;

      const editType = editableElement.dataset.editType;
      const editSection = editableElement.dataset.editSection;
      
      // For simplified HTML editing, everything is treated as HTML content
      if (editType === 'html') {
        return this.parseHtmlEditContext(element, editSection);
      }
      
      // Generic editing - use contextual detection, don't force type
      if (editType === 'generic') {
        // Use the full parsing logic and keep the detected contentType
        return this.parseHtmlEditContext(element, editSection);
      }

      // Tags editing for objects
      if (editType === 'tags') {
        return this.parseTagsEditContext(element, editSection);
      }

      // All legacy edit types have been migrated to 'generic'
      console.warn('Unexpected edit type in parseEditContext:', editType);
      return null;
    }

    parseHtmlEditContext(element, editSection) {
      // Detect context automatically based on page structure
      // Order matters: check most specific first (spells, dons, classes, then static pages)
      
      // Check if we're in a spell card first (most specific)
      const spellCard = element.closest('.card[data-spell-name]');
      if (spellCard) {
        const spellName = spellCard.dataset.spellName;
        const spellIndex = spellCard.dataset.spellIndex;
        const categoryName = spellCard.dataset.categoryName;
        
        // Use index-based detection for spell sections
        const allEditables = Array.from(spellCard.querySelectorAll('.editable'));
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const currentIndex = allEditables.indexOf(editableElement);
        
        // Map index to spell property based on CardBuilder order
        // 0=nom, 1=description, 2=prerequis, 3=portee, 4=coutMana, 5=tempsIncantation, 6=resistance, 7=effetNormal, 8=effetCritique
        const spellSections = ['nom', 'description', 'prerequis', 'portee', 'coutMana', 'tempsIncantation', 'resistance', 'effetNormal', 'effetCritique'];
        const spellEditSection = spellSections[currentIndex] || 'description';
        
        return {
          contentType: 'spell',
          itemIdentifier: spellName,
          itemIndex: spellIndex,
          categoryName: categoryName,
          property: 'html',
          editType: 'html',
          editSection: spellEditSection,
          config: window.ContentTypes.spell,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a don card
      const donCard = element.closest('.card[data-don-name]');
      if (donCard) {
        const donName = donCard.dataset.donName;
        const donIndex = donCard.dataset.donIndex;
        const categoryName = donCard.dataset.categoryName;
        
        // Use index-based detection for don sections
        const allEditables = Array.from(donCard.querySelectorAll('.editable'));
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const currentIndex = allEditables.indexOf(editableElement);
        
        // Map index to don property based on CardBuilder order
        // 0=nom, 1=description, 2=prerequis, 3=cout
        const donSections = ['nom', 'description', 'prerequis', 'cout'];
        const donEditSection = donSections[currentIndex] || 'description';
        
        return {
          contentType: 'don',
          itemIdentifier: donName,
          itemIndex: donIndex,
          categoryName: categoryName,
          property: 'html',
          editType: 'html',
          editSection: donEditSection,
          config: window.ContentTypes.don,
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a class page (before static pages!)
      // IMPORTANT: Exclude static pages even if they have data-page-title
      const classArticle = element.closest('article[data-page-title]:not([data-static-page="true"])');
      if (classArticle) {
        const className = classArticle.dataset.pageTitle;
        
        // Check if we're editing a subclass (look for subclass card)
        const subclassCard = element.closest('.card[data-subclass-name]');
        if (subclassCard) {
          // Determine what part of the subclass we're editing
          let subclassEditSection = 'content';
          
          const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
          
          if (editableElement) {
            const parentSection = editableElement.closest('.editable-section');
            
            // Use index-based detection for subclasses
            const subclassCard = editableElement.closest('.card[data-subclass-name]');
            const allEditables = subclassCard ? Array.from(subclassCard.querySelectorAll('.editable')) : [];
            const currentIndex = allEditables.indexOf(editableElement);
            
            // Map index to property based on subclass structure  
            // UPDATED ORDER: Index 0 = nom (title), Index 1 = description, Index 2 = base (stats), Index 3 = progression, Index 4+ = capacites
            if (element.closest('.stats-grid') || currentIndex === 2) {
              subclassEditSection = 'base';
            } else if (currentIndex === 0) {
              subclassEditSection = 'nom';
            } else if (currentIndex === 1) {
              subclassEditSection = 'description';
            } else if (currentIndex === 3) {
              subclassEditSection = 'progression';  
            } else if (currentIndex >= 4) {
              subclassEditSection = 'capacites';
            }
          }
          
          return {
            contentType: 'subclass',
            itemIdentifier: subclassCard.dataset.subclassName,
            categoryName: className,
            property: 'html',
            editType: 'html',
            editSection: subclassEditSection,
            config: window.ContentTypes.subclass,
            element: element.classList.contains('editable-section') ? element.querySelector('.editable') : element,
            container: element
          };
        }
        
        // Otherwise it's a class - determine what part of the class we're editing
        let classEditSection = 'content';
        
        // More specific detection based on parent elements and content
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        
        if (editableElement) {
          const parentCard = editableElement.closest('.card');
          const parentSection = editableElement.closest('.editable-section');
          
          // Use index-based detection instead of content analysis
          const classArticle = editableElement.closest('article[data-page-title]');
          const allEditables = classArticle ? Array.from(classArticle.querySelectorAll('.editable')) : [];
          const currentIndex = allEditables.indexOf(editableElement);
          
          // Map index to property based on class structure
          // Index 0 = resume (first editable in class)
          // Index 1+ = capacites (subsequent editables are class capabilities)
          if (currentIndex === 0) {
            classEditSection = 'resume';
          } else if (currentIndex >= 1) {
            classEditSection = 'capacites';
          }
        }
        
        return {
          contentType: 'class',
          itemIdentifier: className,
          categoryName: null,
          property: 'html',
          editType: 'html',
          editSection: classEditSection,
          config: window.ContentTypes.class,
          element: element.classList.contains('editable-section') ? element.querySelector('.editable') : element,
          container: element
        };
      }
      
      // Check if we're editing a category description (spell/don category pages)
      const editableSection = element.closest('.editable-section[data-section-type*="-category-description"]');
      if (editableSection) {
        const sectionType = editableSection.dataset.sectionType;
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const editSection = editableElement ? editableElement.dataset.editSection : '';
        
        // Determine the category type (spell/don/etc) and category name
        let contentType = 'spell'; // default
        if (sectionType.includes('spell')) {
          contentType = 'spell';
        } else if (sectionType.includes('don')) {
          contentType = 'don';
        }
        
        return {
          contentType: 'category',
          itemIdentifier: editSection, // This is the category name
          categoryName: editSection,
          property: 'description',
          editType: 'html',
          editSection: 'description',
          categoryType: contentType,
          config: window.ContentTypes[contentType],
          element: editableElement,
          container: element
        };
      }
      
      // Check if we're in a static page (LAST, as fallback)
      // Now we include ALL static pages, regardless of data-page-title
      const staticPageArticle = element.closest('article[data-static-page="true"]');
      if (staticPageArticle) {
        const pageName = staticPageArticle.dataset.page;
        
        // Enhanced page detection with ID-based fallback
        let actualPageName = pageName;
        const elementEditSection = element.dataset?.editSection || 'none';
        
        // If the element's edit section contains a page prefix, use that instead
        if (elementEditSection !== 'none' && elementEditSection.includes('-')) {
          const possiblePageId = elementEditSection.split('-')[0];
          // Check if this matches a known static page
          if (window.STATIC_PAGES && window.STATIC_PAGES[possiblePageId]) {
            actualPageName = possiblePageId;
          }
        }
        
        // Use the corrected page name
        const finalPageName = actualPageName;
        
        // Use index-based detection for static page sections
        const allEditables = Array.from(staticPageArticle.querySelectorAll('.editable'));
        const editableElement = element.classList.contains('editable') ? element : element.querySelector('.editable');
        const currentIndex = allEditables.indexOf(editableElement);
        
        // For static pages, use the actual edit section from the element's data attribute
        const actualEditSection = elementEditSection !== 'none' ? elementEditSection : `section-${currentIndex}`;
        
        return {
          contentType: 'staticPage',
          itemIdentifier: finalPageName,  // Use corrected page name
          categoryName: null,
          property: 'html',
          editType: 'html',
          editSection: actualEditSection,  // Use actual edit section ID
          config: window.ContentTypes.staticPage,
          element: editableElement,
          container: element
        };
      }
      
      // Default fallback
      return {
        contentType: 'unknown',
        itemIdentifier: editSection || 'content',
        categoryName: null,
        property: 'html',
        editType: 'html',
        editSection,
        config: { fields: {} },
        element: element.classList.contains('editable-section') ? element.querySelector('.editable') : element,
        container: element
      };
    }

    parseTagsEditContext(element, editSection) {
      // Check if we're in an object card
      const objetCard = element.closest('.card[data-objet-name]');
      if (objetCard) {
        const objetName = objetCard.dataset.objetName;
        const categoryName = objetCard.dataset.categoryName;
        
        return {
          contentType: 'objet',
          itemIdentifier: objetName,
          categoryName: categoryName,
          property: 'tags',
          editType: 'tags',
          editSection: editSection,
          config: window.ContentTypes.objet,
          element: element.classList.contains('editable') ? element : element.querySelector('.editable'),
          container: element
        };
      }
      
      return null;
    }

    // Start editing session
    startEdit(element) {
      const context = this.parseEditContext(element);
      if (!context) return false;

      if (this.currentEditSession) {
        this.saveCurrentEdit();
      }

      this.currentEditSession = {
        ...context,
        originalContent: context.element.innerHTML,
        startTime: Date.now()
      };

      // Special handling for tags editing
      if (context.editType === 'tags') {
        console.log('ğŸ” DEBUG: Detected tags editing, calling makeTagsEditable');
        this.makeTagsEditable(context.element, context.container);
      } else {
        console.log('ğŸ” DEBUG: Standard editing, calling makeElementEditable');
        this.makeElementEditable(context.element, context.container);
      }
      return true;
    }

    makeElementEditable(editableElement, container) {
      const originalHtml = editableElement.innerHTML;
      container.dataset.originalContent = originalHtml;
      container.dataset.editing = 'true';

      // Decode any encoded HTML before showing for editing
      const decodedHtml = this.decodeHtmlEntities(originalHtml);
      editableElement.textContent = decodedHtml;
      editableElement.contentEditable = true;
      editableElement.style.cssText += `
        background-color: rgba(255, 255, 0, 0.1);
        border: 1px dashed var(--bronze);
        border-radius: 4px;
        padding: 4px;
        font-family: monospace;
        white-space: pre-wrap;
      `;
      editableElement.focus();

      const range = document.createRange();
      range.selectNodeContents(editableElement);
      const selection = window.getSelection();
      selection.removeAllRanges();
      selection.addRange(range);
    }

    makeTagsEditable(editableElement, container) {
      console.log('ğŸ” DEBUG: makeTagsEditable called');
      console.log('ğŸ” DEBUG: editableElement:', editableElement);
      console.log('ğŸ” DEBUG: container:', container);
      console.log('ğŸ” DEBUG: currentEditSession:', this.currentEditSession);
      
      const originalHtml = editableElement.innerHTML;
      container.dataset.originalContent = originalHtml;
      container.dataset.editing = 'true';

      // Get current tags from the object
      const objetName = this.currentEditSession.itemIdentifier;
      console.log('ğŸ” DEBUG: objetName:', objetName);
      
      const objet = window.OBJETS?.objets?.find(obj => obj.nom === objetName);
      console.log('ğŸ” DEBUG: found objet:', objet);
      
      const currentTags = objet?.tags || [];
      const availableTags = window.ContentTypes.objet.filterConfig.availableTags;
      console.log('ğŸ” DEBUG: currentTags:', currentTags);
      console.log('ğŸ” DEBUG: availableTags:', availableTags);

      // Create and show modal instead of inline editor
      this.showTagsModal(objetName, currentTags, availableTags);
    }

    showTagsModal(objetName, currentTags, availableTags) {
      console.log('ğŸ” DEBUG: showTagsModal called for object:', objetName);
      console.log('ğŸ” DEBUG: currentTags:', currentTags);
      console.log('ğŸ” DEBUG: availableTags:', availableTags);
      
      // Remove any existing tags modal
      const existingModal = document.querySelector('#tagsEditModal');
      if (existingModal) {
        console.log('ğŸ” DEBUG: Removing existing modal');
        existingModal.remove();
      }

      // Log DOM structure before creating modal
      console.log('ğŸ” DEBUG: Current body children count:', document.body.children.length);
      console.log('ğŸ” DEBUG: Body z-index elements:', Array.from(document.body.children).map(el => ({
        tagName: el.tagName,
        className: el.className,
        zIndex: window.getComputedStyle(el).zIndex,
        position: window.getComputedStyle(el).position
      })));

      // Use native HTML5 dialog element for proper z-index handling
      const modal = document.createElement('dialog');
      modal.id = 'tagsEditModal';
      modal.style.cssText = `
        max-width: 500px !important;
        width: 90% !important;
        padding: 0 !important;
        border: none !important;
        border-radius: 12px !important;
        background: transparent !important;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5) !important;
      `;
      
      console.log('ğŸ” DEBUG: Created dialog element:', modal);

      const checkboxesHTML = availableTags.map(tag => `
        <div style="display: flex; align-items: center; gap: 0.5rem; margin: 0.5rem 0; padding: 0.5rem; background: #f5f5f5; border-radius: 8px;">
          <input 
            type="checkbox" 
            id="modal-tag-${tag}" 
            value="${tag}" 
            ${currentTags.includes(tag) ? 'checked' : ''}
            style="margin: 0;"
          >
          <label for="modal-tag-${tag}" style="flex: 1; cursor: pointer; font-weight: 500;">
            <span style="background: #8B4513; color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 0.5rem;">${tag}</span>
            ${tag}
          </label>
        </div>
      `).join('');

      modal.innerHTML = `
        <div style="
          background: white; 
          border-radius: 12px; 
          padding: 1.5rem; 
          border: 3px solid #8B4513;
          font-family: inherit;
          font-size: 16px;
          color: #333;
        ">
          <h3 style="margin: 0 0 1rem 0; color: #8B4513; font-size: 1.2em;">ğŸ·ï¸ Ã‰diter les tags de "${objetName}"</h3>
          <p style="margin: 0 0 1rem 0; color: #666; font-size: 0.9em;">SÃ©lectionnez les tags Ã  assigner Ã  cet objet :</p>
          
          <div id="tagsCheckboxes" style="margin: 1rem 0;">
            ${checkboxesHTML}
          </div>
          
          <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem;">
            <button type="button" class="btn-cancel-tags-modal" style="
              background: #666; 
              color: white; 
              border: none; 
              padding: 8px 16px; 
              border-radius: 6px; 
              cursor: pointer;
              font-weight: 500;
              font-size: 14px;
            ">
              âŒ Annuler
            </button>
            <button type="button" class="btn-save-tags-modal" style="
              background: #8B4513; 
              color: white; 
              border: none; 
              padding: 8px 16px; 
              border-radius: 6px; 
              cursor: pointer;
              font-weight: 500;
              font-size: 14px;
            ">
              ğŸ’¾ Sauvegarder
            </button>
          </div>
        </div>
      `;

      // Append to body and show modal using native dialog API
      console.log('ğŸ” DEBUG: Adding modal to body');
      document.body.appendChild(modal);
      
      console.log('ğŸ” DEBUG: Modal added to DOM, calling showModal()');
      console.log('ğŸ” DEBUG: Modal computed styles before showModal:', {
        display: window.getComputedStyle(modal).display,
        position: window.getComputedStyle(modal).position,
        zIndex: window.getComputedStyle(modal).zIndex,
        visibility: window.getComputedStyle(modal).visibility
      });
      
      // Use showModal() for proper top-level display
      try {
        modal.showModal();
        console.log('ğŸ” DEBUG: showModal() called successfully');
        
        console.log('ğŸ” DEBUG: Modal computed styles after showModal:', {
          display: window.getComputedStyle(modal).display,
          position: window.getComputedStyle(modal).position,
          zIndex: window.getComputedStyle(modal).zIndex,
          visibility: window.getComputedStyle(modal).visibility
        });
        
        console.log('ğŸ” DEBUG: Modal bounding rect:', modal.getBoundingClientRect());
        
        // Log all body children with their z-index after modal is shown
        console.log('ğŸ” DEBUG: All body children after modal shown:', Array.from(document.body.children).map(el => ({
          tagName: el.tagName,
          id: el.id,
          className: el.className,
          zIndex: window.getComputedStyle(el).zIndex,
          position: window.getComputedStyle(el).position,
          display: window.getComputedStyle(el).display
        })));
        
      } catch (error) {
        console.error('ğŸ” DEBUG: Error calling showModal():', error);
      }

      // Set up event handlers
      modal.querySelector('.btn-save-tags-modal').addEventListener('click', () => {
        this.saveTagsFromModal(modal);
      });

      modal.querySelector('.btn-cancel-tags-modal').addEventListener('click', () => {
        this.cancelTagsModal(modal);
      });

      // Native dialog handles backdrop clicks and ESC automatically
      modal.addEventListener('cancel', (e) => {
        this.cancelTagsModal(modal);
      });

      // Close on backdrop click (for dialog elements)
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          this.cancelTagsModal(modal);
        }
      });
    }

    saveTagsFromModal(modal) {
      if (!this.currentEditSession) return false;

      const checkboxes = modal.querySelectorAll('input[type="checkbox"]:checked');
      const selectedTags = Array.from(checkboxes).map(cb => cb.value);

      if (selectedTags.length === 0) {
        alert('Veuillez sÃ©lectionner au moins un tag');
        return false;
      }

      // Update the object data
      const objetName = this.currentEditSession.itemIdentifier;
      const objet = window.OBJETS?.objets?.find(obj => obj.nom === objetName);
      
      if (objet) {
        objet.tags = selectedTags;
        
        // Update the display
        const tagsDisplay = selectedTags.map(tag => 
          `<span class="tag-chip" style="background: var(--bronze); color: white; padding: 2px 6px; border-radius: 8px; font-size: 0.8em; margin-right: 4px;">${tag}</span>`
        ).join('');
        
        // Restore the element and update its content
        this.resetEditingState(this.currentEditSession.container);
        this.restoreElementContent(this.currentEditSession, tagsDisplay);
        
        // Save to storage
        EventBus.emit(Events.STORAGE_SAVE);
        
        // Close modal and clear edit session
        modal.close();
        modal.remove();
        this.currentEditSession = null;
        
        // Show success notification
        JdrApp.modules.ui.showNotification(`ğŸ·ï¸ Tags mis Ã  jour : ${selectedTags.join(', ')}`, 'success');
        
        return true;
      }
      
      return false;
    }

    cancelTagsModal(modal) {
      // Close modal without saving
      modal.close();
      modal.remove();
      
      // Cancel the edit session
      this.cancelCurrentEdit();
    }

    // Save current editing session
    saveCurrentEdit() {
      if (!this.currentEditSession) return false;

      const session = this.currentEditSession;
      // Get the edited HTML source from textContent (user edited the raw HTML)
      const newContent = session.element.textContent.trim();
      const normalizedContent = this.normalizeHTMLContent(newContent);

      // Reset editing state first to avoid interfering with content restoration
      this.resetEditingState(session.container);

      if (normalizedContent !== session.originalContent) {
        const success = this.saveContent(session, normalizedContent);
        if (success) {
          // Convert back from text to rendered HTML
          this.restoreElementContent(session, normalizedContent);
          
          EventBus.emit(Events.CONTENT_UPDATE, {
            contentType: session.contentType,
            itemIdentifier: session.itemIdentifier,
            property: session.property,
            value: normalizedContent
          });
        } else {
          // If save failed, restore original content
          this.restoreElementContent(session, session.originalContent);
        }
      } else {
        // Even if no changes, restore HTML rendering
        this.restoreElementContent(session, session.originalContent);
      }

      this.currentEditSession = null;
      return true;
    }

    // Save content using unified system
    saveContent(session, content) {
      try {
        // Determine which JSON category to save to
        let jsonCategory;
        
        switch (session.contentType) {
          case 'spell':
            jsonCategory = 'SORTS';
            break;
          case 'don':
            jsonCategory = 'DONS';
            break;
          case 'class':
            jsonCategory = 'CLASSES';
            break;
          case 'subclass':
            jsonCategory = 'CLASSES';  // Subclasses are stored within CLASSES
            break;
          case 'category':
            // Category descriptions can be in SORTS or DONS, determine from categoryType
            jsonCategory = session.categoryType === 'don' ? 'DONS' : 'SORTS';
            break;
          case 'objet':
            jsonCategory = 'OBJETS';
            break;
          case 'staticPage':
          case 'generic':
            jsonCategory = 'STATIC_PAGES';
            break;
          default:
            console.warn('Unknown content type:', session.contentType);
            return false;
        }
        
        return this.saveToJson(session, content, jsonCategory);
      } catch (error) {
        console.error('Save error:', error);
        return false;
      }
    }

    // Unified save method that takes a JSON category parameter
    saveToJson(session, content, jsonCategory) {
      const jsonData = window[jsonCategory];
      if (!jsonData) {
        console.error(`JSON category ${jsonCategory} not found`);
        return false;
      }


      // Generic save - find the target object and save the content
      let targetObject = null;
      
      if (session.contentType === 'spell' || session.contentType === 'don') {
        // Find in category -> items structure
        for (const category of jsonData) {
          if (category.nom === session.categoryName) {
            const itemsKey = session.contentType === 'spell' ? 'sorts' : 'dons';
            // Use index-based identification if available, fallback to name-based
            if (session.itemIndex !== undefined && session.itemIndex !== null) {
              const index = parseInt(session.itemIndex, 10);
              targetObject = category[itemsKey]?.[index];
            } else {
              targetObject = category[itemsKey]?.find(item => item.nom === session.itemIdentifier);
            }
            break;
          }
        }
      } else if (session.contentType === 'class') {
        // Find class directly
        targetObject = jsonData.find(c => c.nom === session.itemIdentifier);
      } else if (session.contentType === 'subclass') {
        // Find subclass within a class
        const parentClass = jsonData.find(c => c.nom === session.categoryName);
        if (parentClass?.sousClasses) {
          targetObject = parentClass.sousClasses.find(sc => sc.nom === session.itemIdentifier);
        }
      } else if (session.contentType === 'objet') {
        // Find object directly in the objets array
        targetObject = jsonData.objets?.find(obj => obj.nom === session.itemIdentifier);
      } else if (session.contentType === 'category') {
        // Find category by name and update its description
        targetObject = jsonData.find(category => category.nom === session.categoryName);
      } else if (session.contentType === 'staticPage' || session.contentType === 'generic') {
        return this.saveStaticPageToJson(jsonData, session, content);
      }
      
      if (targetObject) {
        targetObject[session.editSection] = content;
        return true;
      } else {
        return false;
      }
    }


    saveStaticPageToJson(jsonData, session, content) {
      const pageData = jsonData[session.itemIdentifier];
      if (!pageData?.sections) {
        console.warn('Page data or sections not found for:', session.itemIdentifier);
        return false;
      }


      // Generic search by section ID or special cases
      const updateSection = (sections) => {
        for (const section of sections) {
          // Direct ID match for content
          if (section.id === session.editSection) {
            section.content = content;
            return true;
          }
          
          // Handle title updates (ID + "-title")
          if (session.editSection.endsWith('-title')) {
            const sectionId = session.editSection.replace('-title', '');
            if (section.id === sectionId) {
              section.title = content;
              return true;
            }
          }
          
          // Handle page title
          if (session.editSection === 'page-title') {
            // Page title is stored in the page data, not sections
            // This will be handled at page level
            return false;
          }
          
          // Handle intro sections
          if (section.type === 'intro' && session.editSection === 'intro') {
            section.content = content;
            return true;
          }

          // Handle nested content arrays (for grid sections)
          if (section.content && Array.isArray(section.content)) {
            if (updateSection(section.content)) {
              return true;
            }
          }
        }
        return false;
      };

      // Special handling for page title
      if (session.editSection === 'page-title') {
        pageData.title = content;
        return true;
      }

      if (updateSection(pageData.sections)) {
        return true;
      }

      console.warn('Section not found for editSection:', session.editSection);
      return false;
    }

    // No special processing - everything is just HTML now
    processContentByType(content, fieldConfig) {
      return content;
    }

    // UNIFIED CONTENT RESTORATION - USE THIS FOR ALL CONTENT TYPES
    // This method ensures that HTML content is always properly rendered
    // and prevents HTML tags from being displayed as visible text
    restoreElementContent(session, content) {
      // IMPORTANT: Always use innerHTML to render HTML content properly
      // Never use textContent for edited content as it will show HTML tags
      session.element.innerHTML = content;
      
      // NOTE FOR DEVELOPERS: 
      // - For ANY new content type, use this method instead of direct innerHTML assignment
      // - This prevents the recurring issue of visible HTML tags after editing
      // - ALL content types (static pages, spells, classes, dons) go through this
    }

    resetEditingState(container) {
      const editableElement = container.querySelector('.editable') || container;
      
      // Standard editing cleanup (modal is handled separately)
      editableElement.contentEditable = false;
      editableElement.style.cssText = editableElement.style.cssText
        .replace(/background-color[^;]*;?/g, '')
        .replace(/border[^;]*;?/g, '')
        .replace(/padding[^;]*;?/g, '')
        .replace(/font-family[^;]*;?/g, '')
        .replace(/white-space[^;]*;?/g, '');
      
      container.dataset.editing = 'false';
      delete container.dataset.originalContent;
    }


    decodeHtmlEntities(html) {
      // Decode HTML entities step by step to prevent double-encoding
      let decoded = html
        .replace(/&amp;lt;/g, '<')  // &amp;lt; -> <
        .replace(/&amp;gt;/g, '>')  // &amp;gt; -> >
        .replace(/&lt;/g, '<')     // &lt; -> <
        .replace(/&gt;/g, '>')     // &gt; -> >
        .replace(/&quot;/g, '"')   // &quot; -> "
        .replace(/&#39;/g, "'")    // &#39; -> '
        .replace(/&amp;/g, '&');   // &amp; -> & (do this last)
      return decoded;
    }

    normalizeHTMLContent(html) {
      // First, unescape any already escaped HTML to prevent double-escaping
      let cleanHtml = html
        .replace(/&amp;lt;/g, '<')  // Handle double-escaped &amp;lt; -> &lt; -> <
        .replace(/&amp;gt;/g, '>')  // Handle double-escaped &amp;gt; -> &gt; -> >
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'");
      
      // Create temp div to parse and clean the HTML
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = cleanHtml;
      
      // Clean up any problematic div elements
      tempDiv.querySelectorAll('div').forEach(div => {
        if (div.innerHTML === '<br>' || div.innerHTML === '<br/>') {
          div.outerHTML = '<br>';
        }
      });
      
      // Return the cleaned HTML
      return tempDiv.innerHTML.trim()
        .replace(/<br\s*\/?>/gi, '<br>')
        .replace(/\u00a0/g, '&nbsp;')
        .replace(/(\w+)\s*=\s*'([^']*)'/g, '$1="$2"');
    }

    // Cancel current edit
    cancelCurrentEdit() {
      if (!this.currentEditSession) return false;

      const session = this.currentEditSession;
      // Reset editing state first to avoid interfering with content restoration
      this.resetEditingState(session.container);
      // Restore original content
      this.restoreElementContent(session, session.originalContent);
      this.currentEditSession = null;
      return true;
    }

    // Check if element is currently being edited
    isEditing(element) {
      return element.dataset.editing === 'true';
    }

    // Save all active edits
    saveAllEdits() {
      if (this.currentEditSession) {
        this.saveCurrentEdit();
      }

      // Handle any remaining editing elements
      document.querySelectorAll('[data-editing="true"]').forEach(element => {
        if (!this.isValidForEdit(element)) {
          this.resetEditingState(element);
        }
      });
    }

    isValidForEdit(element) {
      const context = this.parseEditContext(element);
      return context !== null;
    }
  }

  window.UnifiedEditor = UnifiedEditor.getInstance();

})();
// ============================================================================
// JDR-BAB APPLICATION - EDITOR MODULE (REFACTORED)
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // EDITOR MODULE - Now uses UnifiedEditor
  // ========================================
  JdrApp.modules.editor = {
    editedData: {},
    isDevMode: false,

    init() {
      this.setupEventListeners();
      this.setupEditableHandlers();
      this.setupCreationHandlers();
      this.setupImageHandlers();
      this.updateDevModeState();
    },

    setupEventListeners() {
      JdrApp.utils.events.register('click', '#devToggle', () => this.toggleDevMode());

      EventBus.on(Events.EDITOR_TOGGLE, (payload) => {
        this.isDevMode = payload.enabled;
        this.updateDevModeState();
      });

      EventBus.on(Events.CONTENT_UPDATE, () => {
        this.saveChangesToStorage();
      });

    },

    toggleDevMode() {
      if (window.STANDALONE_VERSION) return;
      
      this.isDevMode = !this.isDevMode;
      EventBus.emit(Events.EDITOR_TOGGLE, { enabled: this.isDevMode });
    },

    updateDevModeState() {
      if (window.STANDALONE_VERSION) {
        document.body.className = 'dev-off';
        this.forceHideAllEditButtons();
        return;
      }
      
      document.body.classList.toggle('dev-on', this.isDevMode);
      document.body.classList.toggle('dev-off', !this.isDevMode);
      
      const devToggle = document.querySelector('#devToggle');
      const devToolbox = document.querySelector('#devToolbox');
      
      if (devToggle) {
        devToggle.textContent = `ğŸ›  Dev Mode: ${this.isDevMode ? 'ON' : 'OFF'}`;
      }
      
      if (devToolbox) {
        devToolbox.style.display = this.isDevMode ? 'block' : 'none';
      }
      
      if (this.isDevMode) {
        this.forceShowAllEditButtons();
      } else {
        this.forceHideAllEditButtons();
      }
      
      this.regenerateCurrentPage();
    },

    forceHideAllEditButtons() {
      if (this.isDevMode) {
        return;
      }
      
      const selectors = [
        '.edit-btn', '[class$="-add"]', '[class$="-delete"]', '[class*="-move-"]',
        '.section-delete', '.remove-section-btn', '.add-paragraph-btn', 
        '.add-subclass-btn', '.delete-subclass-btn',
        '.spell-delete', '.don-delete', // Explicit delete buttons
        '.illus .up', '.illus .rm', '.illus label', '.illus input[type="file"]'
      ];
      
      selectors.forEach(selector => {
        document.querySelectorAll(selector).forEach(element => {
          element.style.display = 'none';
          element.style.visibility = 'hidden';
          element.setAttribute('aria-hidden', 'true');
        });
      });
    },
    
    forceShowAllEditButtons() {
      if (!this.isDevMode) return;
      
      // Ensure body has the correct classes
      document.body.classList.add('dev-on');
      document.body.classList.remove('dev-off');
      
      // Force reset all CSS properties that might be causing 0x0 dimensions
      const selectors = [
        '.edit-btn', '[class$="-add"]', '[class$="-delete"]', '[class*="-move-"]',
        '.section-delete', '.remove-section-btn', '.add-paragraph-btn', 
        '.add-subclass-btn', '.delete-subclass-btn',
        '.spell-delete', '.don-delete', '.objet-delete',
        '.spell-add', '.don-add', '.objet-add',
        '.illus .up', '.illus .rm', '.illus label', '.illus input[type="file"]'
      ];
      
      selectors.forEach(selector => {
        document.querySelectorAll(selector).forEach(element => {
          // Force reset all dimension properties
          element.style.removeProperty('display');
          element.style.removeProperty('visibility');
          element.style.removeProperty('opacity');
          element.style.removeProperty('width');
          element.style.removeProperty('height');
          element.style.removeProperty('min-width');
          element.style.removeProperty('min-height');
          element.style.removeProperty('pointer-events');
          element.removeAttribute('aria-hidden');
          
          // Let CSS handle the styling
          element.style.display = '';
          element.style.visibility = '';
        });
      });
    },

    setupEditableHandlers() {
      // Unified edit button handler
      JdrApp.utils.events.register('click', '.edit-btn', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        if (!this.isDevMode) return;
        
        // Find the editable element near the button
        let editableElement = e.target.previousElementSibling;
        
        // If not found as previous sibling, look in parent
        if (!editableElement || !editableElement.classList.contains('editable')) {
          const parent = e.target.parentElement;
          editableElement = parent.querySelector('.editable');
        }
        
        // Fallback: look for closest editable element
        if (!editableElement || !editableElement.classList.contains('editable')) {
          editableElement = e.target.closest('.editable-section')?.querySelector('.editable') ||
                           e.target.closest('.card')?.querySelector('.editable');
        }
        
        if (editableElement && editableElement.classList.contains('editable')) {
          UnifiedEditor.startEdit(editableElement);
        } else {
          console.warn('No editable element found for edit button');
        }
      });

      // Click outside to save
      JdrApp.utils.events.register('click', 'body', (e) => {
        if (!e.target.closest('.editable') && !e.target.matches('.edit-btn')) {
          UnifiedEditor.saveAllEdits();
        }
      });

      // Keyboard shortcuts
      JdrApp.utils.events.register('keydown', '.editable', (e) => {
        if ((e.key === 'Enter' && !e.shiftKey) || e.key === 'Escape') {
          e.preventDefault();
          UnifiedEditor.saveCurrentEdit();
        }
      });

      // Prevent double-click editing (force button-only editing)
      JdrApp.utils.events.register('dblclick', '.editable', (e) => {
        e.preventDefault();
        e.stopPropagation();
        return false;
      });
    },

    setupCreationHandlers() {
      // Unified subclass management
      JdrApp.utils.events.register('click', '.add-subclass-btn', (e) => {
        if (!this.isDevMode) return;
        this.addNewSubclass(e.target);
      });

      JdrApp.utils.events.register('click', '.delete-subclass-btn', (e) => {
        if (!this.isDevMode) return;
        this.deleteSubclass(e.target);
      });
    },

    addNewSubclass(button) {
      const article = button.closest('article');
      if (!article) return;
      
      let className = article.dataset.pageTitle;
      if (!className) {
        const hash = window.location.hash.match(/#\/([^\/]+)/);
        if (hash) {
          className = hash[1].charAt(0).toUpperCase() + hash[1].slice(1);
        }
      }
      
      console.log('Adding subclass to class:', className);
      
      if (!className || !window.CLASSES) {
        console.log('Missing className or CLASSES:', { className, hasClasses: !!window.CLASSES });
        return;
      }
      
      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe) {
        console.log('Class not found:', className);
        console.log('Available classes:', window.CLASSES.map(c => c.nom));
        return;
      }
      
      const config = window.ContentTypes.subclass;
      const newSubclass = { ...config.defaultValues };
      
      console.log('Creating new subclass:', newSubclass);
      
      if (!classe.sousClasses) classe.sousClasses = [];
      classe.sousClasses.push(newSubclass);
      
      console.log('Class after adding subclass:', classe);
      
      EventBus.emit(Events.CONTENT_ADD, {
        type: 'subclass',
        category: className,
        item: newSubclass
      });
      
      // Recharger juste le contenu de l'article au lieu de toute la page
      this.reloadClassPage(className);
    },

    deleteSubclass(button) {
      const className = button.dataset.className;
      const subclassName = button.dataset.subclassName;
      
      if (!className || !subclassName) return;
      if (!confirm(`ÃŠtes-vous sÃ»r de vouloir supprimer la sous-classe "${subclassName}" ?`)) return;

      const classe = window.CLASSES?.find(c => c.nom === className);
      if (!classe?.sousClasses) return;

      const index = classe.sousClasses.findIndex(sc => sc.nom === subclassName);
      if (index === -1) return;

      const deletedSubclass = classe.sousClasses.splice(index, 1)[0];
      
      EventBus.emit(Events.CONTENT_DELETE, {
        type: 'subclass',
        category: className,
        item: deletedSubclass
      });
      
      // Recharger juste le contenu de l'article au lieu de toute la page  
      this.reloadClassPage(className);
    },

    reloadClassPage(className) {
      // Trouver l'article de la classe
      const article = document.querySelector(`article[data-page-title="${className}"]`);
      if (!article) return;

      // RÃ©gÃ©nÃ©rer le contenu de la classe
      const classe = window.CLASSES.find(c => c.nom === className);
      if (!classe) return;

      // VÃ©rifier que PageBuilder existe
      if (!window.PageBuilder) {
        console.error('PageBuilder not available, falling back to page reload');
        window.location.reload();
        return;
      }

      // Utiliser PageBuilder pour rÃ©gÃ©nÃ©rer le contenu
      const newContent = window.PageBuilder.buildClassPage(classe);
      const parser = new DOMParser();
      const newDoc = parser.parseFromString(newContent, 'text/html');
      const newArticle = newDoc.querySelector('article');
      
      if (newArticle) {
        article.innerHTML = newArticle.innerHTML;
        
        // RÃ©appliquer les images et l'Ã©tat de dev mode
        setTimeout(() => {
          if (JdrApp.modules.renderer?.autoLoadImages) {
            JdrApp.modules.renderer.autoLoadImages();
          }
          // Apply dev mode state properly
          if (this.isDevMode) {
            this.forceShowAllEditButtons();
          } else {
            this.forceHideAllEditButtons();
          }
        }, 50);
      }
    },

    setupImageHandlers() {
      // Fonction pour attacher les Ã©vÃ©nements aux images existantes
      this.attachImageEvents();
      
      // Observer pour attacher les Ã©vÃ©nements aux nouvelles images crÃ©Ã©es dynamiquement
      if (typeof MutationObserver !== 'undefined') {
        const observer = new MutationObserver(() => {
          this.attachImageEvents();
        });
        observer.observe(document.body, { childList: true, subtree: true });
      }
    },

    attachImageEvents() {
      // Attacher aux inputs de fichier
      document.querySelectorAll('.illus input[type="file"]').forEach(input => {
        if (!input.hasAttribute('data-events-attached')) {
          input.addEventListener('change', (e) => this.handleImageUpload(e));
          input.setAttribute('data-events-attached', 'true');
        }
      });

      // Attacher aux boutons de suppression
      document.querySelectorAll('.illus .rm').forEach(button => {
        if (!button.hasAttribute('data-events-attached')) {
          button.addEventListener('click', (e) => this.handleImageRemoval(e));
          button.setAttribute('data-events-attached', 'true');
        }
      });

      // Attacher aux images pour agrandissement - toutes les images, pas seulement celles dans .illus
      document.querySelectorAll('img').forEach(img => {
        // Ã‰viter les images dans les Ã©diteurs ou les inputs
        if (!img.closest('.editor-content') && !img.hasAttribute('data-events-attached')) {
          // Ajouter support tactile pour mobile
          img.addEventListener('click', (e) => this.toggleImageEnlargement(e.target));
          img.addEventListener('touchend', (e) => {
            e.preventDefault();
            this.toggleImageEnlargement(e.target);
          });
          img.setAttribute('data-events-attached', 'true');
          img.style.cursor = 'zoom-in';
        }
      });
    },

    handleImageUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (e) => {
        const illus = event.target.closest('.illus');
        const img = illus.querySelector('img');
        const rmButton = illus.querySelector('.rm');
        const illusKey = illus.dataset.illusKey;

        img.src = e.target.result;
        img.style.display = 'block';
        if (rmButton) rmButton.style.display = 'block';

        if (JdrApp.modules.images?.setImageUrl) {
          JdrApp.modules.images.setImageUrl(illusKey, e.target.result);
        }

        EventBus.emit(Events.IMAGE_UPLOAD, { 
          illusKey, 
          src: e.target.result 
        });
      };
      
      reader.readAsDataURL(file);
    },

    handleImageRemoval(event) {
      const illus = event.target.closest('.illus');
      const img = illus.querySelector('img');
      const rmButton = illus.querySelector('.rm');
      const illusKey = illus.dataset.illusKey;

      img.src = '';
      img.style.display = 'none';
      if (rmButton) rmButton.style.display = 'none';

      if (JdrApp.modules.images?.removeImage) {
        JdrApp.modules.images.removeImage(illusKey);
      }

      EventBus.emit(Events.IMAGE_DELETE, { illusKey });
    },

    toggleImageEnlargement(img) {
      if (img.classList.contains('enlarged')) {
        this.closeEnlargedImage();
      } else {
        this.showEnlargedImage(img);
      }
    },

    showEnlargedImage(img) {
      // Fermer toute image dÃ©jÃ  ouverte
      this.closeEnlargedImage();
      
      // CrÃ©er un conteneur modal complet
      const modal = document.createElement('div');
      modal.id = 'image-enlargement-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0,0,0,0.8);
        z-index: 2147483647;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: zoom-out;
      `;
      
      // CrÃ©er une copie de l'image
      const enlargedImg = img.cloneNode(true);
      enlargedImg.style.cssText = `
        max-width: 90vw;
        max-height: 90vh;
        width: auto;
        height: auto;
        object-fit: contain;
        border: 3px solid var(--gold);
        border-radius: 8px;
        background: white;
        box-shadow: 0 20px 60px rgba(0,0,0,.8), 0 0 20px rgba(212,175,55,.3);
        cursor: zoom-out;
      `;
      
      modal.appendChild(enlargedImg);
      document.body.appendChild(modal);
      
      // Fermer au clic et au touch pour mobile
      modal.onclick = () => this.closeEnlargedImage();
      modal.addEventListener('touchend', (e) => {
        if (e.target === modal) {
          e.preventDefault();
          this.closeEnlargedImage();
        }
      });
      
      // Fermer avec Ã‰chap
      const escapeHandler = (e) => {
        if (e.key === 'Escape') {
          this.closeEnlargedImage();
          document.removeEventListener('keydown', escapeHandler);
        }
      };
      document.addEventListener('keydown', escapeHandler);
      
      // Marquer l'image originale comme agrandie
      img.classList.add('enlarged');
    },

    closeEnlargedImage() {
      const modal = document.getElementById('image-enlargement-modal');
      if (modal) {
        modal.remove();
      }
      
      // Retirer la classe de toutes les images
      document.querySelectorAll('img.enlarged').forEach(img => {
        img.classList.remove('enlarged');
      });
      
      // Nettoyer les anciens backdrops
      const oldBackdrop = document.querySelector('.image-backdrop');
      if (oldBackdrop) {
        oldBackdrop.remove();
      }
    },

    createImageBackdrop() {
      // MÃ©thode obsolÃ¨te - redirigÃ©e vers la nouvelle approche
      console.warn('createImageBackdrop is deprecated, use showEnlargedImage instead');
    },

    removeImageBackdrop() {
      // MÃ©thode obsolÃ¨te - redirigÃ©e vers la nouvelle approche
      this.closeEnlargedImage();
    },

    saveChangesToStorage() {
      try {
        localStorage.setItem('jdr-bab-edits', JSON.stringify(this.editedData));
        localStorage.setItem('jdr-bab-last-modified', Date.now().toString());
        EventBus.emit(Events.STORAGE_SAVE);
      } catch (error) {
        console.error('Failed to save changes:', error);
      }
    },

    forceCollectAllEdits() {
      UnifiedEditor.saveAllEdits();
      return this.editedData;
    },

    // Legacy methods for backward compatibility
    makeEditableSection(element) {
      return UnifiedEditor.startEdit(element);
    },

    saveAllEdits() {
      return UnifiedEditor.saveAllEdits();
    },

    regenerateCurrentPage() {
      // Force regeneration of only the current page content (not all pages)
      if (JdrApp.modules.renderer && JdrApp.modules.renderer.regenerateCurrentPage) {
        JdrApp.modules.renderer.regenerateCurrentPage();
      }
    }
  };

})();
// ============================================================================
// JDR-BAB APPLICATION - SPELL FILTER MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // SPELL FILTER MODULE
  // ========================================
  const SpellFilter = {
    
    init() {
      this.setupEventListeners();
    },

    setupEventListeners() {
      // Use direct event delegation on document to catch dynamically added elements
      document.addEventListener('input', (e) => {
        if (e.target && e.target.id === 'spell-level-filter') {
          this.filterSpellsByLevel(parseInt(e.target.value, 10));
        }
      });

      document.addEventListener('click', (e) => {
        if (e.target && e.target.id === 'reset-spell-filter') {
          e.preventDefault();
          this.resetFilter();
        }
      });

      // Setup when page changes (router events)
      if (window.EventBus && window.Events) {
        EventBus.on(Events.PAGE_RENDER, (payload) => {
          if (payload.type === 'category' && payload.categoryType === 'spell') {
            // Re-setup filter after page render
            setTimeout(() => this.initializeFilter(), 200);
          }
        });
      }

      // Also listen to hash changes for direct navigation
      window.addEventListener('hashchange', () => {
        setTimeout(() => this.initializeFilter(), 200);
      });
    },

    initializeFilter() {
      const filterInput = document.querySelector('#spell-level-filter');
      if (!filterInput) return;
      
      console.log('SpellFilter: Initializing filter with value', filterInput.value);
      
      // Set initial value and apply filter
      const initialValue = parseInt(filterInput.value, 10) || 20;
      this.filterSpellsByLevel(initialValue);
    },

    filterSpellsByLevel(maxLevel) {
      console.log('SpellFilter: Filtering spells with maxLevel', maxLevel);
      
      // Get current page from URL hash
      const currentHash = window.location.hash.replace('#/', '');
      
      if (!currentHash.startsWith('sorts-')) {
        console.log('SpellFilter: Not on a spells page, hash is', currentHash);
        return;
      }
      
      // Find all spell cards in the current page
      const spellCards = document.querySelectorAll('.card[data-spell-name]');
      console.log('SpellFilter: Found', spellCards.length, 'spell cards');
      
      if (spellCards.length === 0) return;

      let visibleCount = 0;

      spellCards.forEach((card) => {
        const spellName = card.dataset.spellName;
        const categoryName = card.dataset.categoryName;
        
        // Find the spell data to get its level
        const spellLevel = this.getSpellLevel(spellName, categoryName);
        
        if (spellLevel <= maxLevel) {
          card.style.display = '';
          visibleCount++;
        } else {
          card.style.display = 'none';
        }
      });

      
      // Update filter display with count
      this.updateFilterDisplay(maxLevel, visibleCount, spellCards.length);
    },

    getSpellLevel(spellName, categoryName) {
      if (!window.SORTS) return 0;

      // Find the category
      const category = window.SORTS.find(cat => cat.nom === categoryName);
      if (!category || !category.sorts) return 0;

      // Find the spell
      const spell = category.sorts.find(sort => sort.nom === spellName);
      if (!spell || !spell.prerequis) return 0;

      // Extract level from prerequisite
      const match = spell.prerequis.match(/Niveau (\d+)/i);
      return match ? parseInt(match[1], 10) : 0;
    },

    updateFilterDisplay(maxLevel, visibleCount, totalCount) {
      const filterContainer = document.querySelector('.spell-level-filter');
      if (!filterContainer) return;

      // Remove existing count display
      let countDisplay = filterContainer.querySelector('.filter-count');
      if (countDisplay) {
        countDisplay.remove();
      }

      // Add new count display
      const countText = `ğŸ“Š ${visibleCount}/${totalCount} sorts affichÃ©s (niveau â‰¤ ${maxLevel})`;
      countDisplay = document.createElement('div');
      countDisplay.className = 'filter-count';
      countDisplay.style.cssText = 'margin-top: 0.5rem; font-size: 0.9rem; color: var(--bronze); font-weight: 500;';
      countDisplay.textContent = countText;
      
      filterContainer.appendChild(countDisplay);
    },

    resetFilter() {
      const filterInput = document.querySelector('#spell-level-filter');
      if (filterInput) {
        filterInput.value = '20';
        this.filterSpellsByLevel(20);
      }
    }
  };

  // Initialize the spell filter when the app is ready
  function initializeSpellFilter() {
    console.log('SpellFilter: Initializing module...');
    
    if (window.JdrApp) {
      if (JdrApp.modules) {
        JdrApp.modules.spellFilter = SpellFilter;
      }
    }
    
    // Initialize the filter
    SpellFilter.init();
    
    // Try to initialize the filter after a delay to ensure DOM is ready
    setTimeout(() => {
      if (window.location.hash.includes('sorts-')) {
        SpellFilter.initializeFilter();
      }
    }, 500);
  }

  // Initialize on DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeSpellFilter);
  } else {
    // DOM is already ready
    initializeSpellFilter();
  }

  window.SpellFilter = SpellFilter;

})();
// ============================================================================
// JDR-BAB APPLICATION - UI MODULE
// ============================================================================

(() => {
  "use strict";

  // ========================================
  // UI INTERACTIONS MODULE
  // ========================================
  JdrApp.modules.ui = {
    
    init() {
      this.setupEventListeners();
      this.setupSearch();
      this.setupModals();
      this.setupResponsive();
      this.setupNewPageHandler();
    },

    setupEventListeners() {
      // Content management via EventBus
      EventBus.on(Events.CONTENT_ADD, (payload) => {
        this.handleContentAdd(payload.type, payload.category, payload.item);
      });

      EventBus.on(Events.CONTENT_DELETE, (payload) => {
        this.handleContentDelete(payload.type, payload.category, payload.item);
      });

      EventBus.on(Events.CONTENT_MOVE, (payload) => {
        this.handleContentMove(payload.type, payload.category, payload.itemName, payload.direction);
      });

      // UI event handlers
      this.setupContentHandlers();
    },

    setupContentHandlers() {
      // Generic content addition
      JdrApp.utils.events.register('click', '[class$="-add"]', (e) => {
        const type = this.extractTypeFromClass(e.target.className);
        const categoryName = e.target.dataset.categoryName;
        
        if (type && categoryName) {
          this.addContent(type, categoryName);
        }
      });

      // Generic content deletion - using multiple specific selectors
      JdrApp.utils.events.register('click', '.spell-delete, .don-delete, .delete-subclass-btn, .objet-delete', (e) => {
        const type = this.extractTypeFromClass(e.target.className);
        const categoryName = e.target.dataset.categoryName;
        
        // Handle different dataset attribute naming patterns
        let itemName;
        if (type === 'spell') {
          itemName = e.target.dataset.spellName;
        } else if (type === 'don') {
          itemName = e.target.dataset.donName;
        } else if (type === 'objet') {
          itemName = e.target.dataset.objetName;
        } else if (type === 'class') {
          itemName = e.target.dataset.className || e.target.dataset.subclassName;
        } else {
          itemName = e.target.dataset[`${type}Name`];
        }
        
        if (type && categoryName && itemName) {
          this.deleteContent(type, categoryName, itemName);
        }
      });

      // Generic content movement
      JdrApp.utils.events.register('click', '[class*="-move-"]', (e) => {
        const type = this.extractTypeFromClass(e.target.className);
        const categoryName = e.target.dataset.categoryName;
        
        // Handle different dataset attribute naming patterns
        let itemName;
        if (type === 'spell') {
          itemName = e.target.dataset.spellName;
        } else if (type === 'don') {
          itemName = e.target.dataset.donName;
        } else if (type === 'objet') {
          itemName = e.target.dataset.objetName;
        } else if (type === 'class') {
          itemName = e.target.dataset.className || e.target.dataset.subclassName;
        } else {
          itemName = e.target.dataset[`${type}Name`];
        }
        
        const direction = e.target.className.includes('move-up') ? -1 : 1;
        
        if (type && categoryName && itemName) {
          this.moveContent(type, categoryName, itemName, direction);
        }
      });

      // Filter manager button for objects
      JdrApp.utils.events.register('click', '.filter-manager-btn', () => {
        this.showFilterManagementModal();
      });

      // Filter chip toggle for objects
      JdrApp.utils.events.register('click', '.filter-chip', (e) => {
        this.toggleFilter(e.target);
      });

      // Spell element change
      JdrApp.utils.events.register('change', '.spell-element-selector select', (e) => {
        this.updateSpellElement(e.target);
      });

      // Paragraph addition
      JdrApp.utils.events.register('click', '.add-paragraph-btn', (e) => {
        const target = e.target.dataset.target;
        this.addParagraph(target, e.target);
      });

      // Section deletion for static pages
      JdrApp.utils.events.register('click', '.section-delete', (e) => {
        const sectionName = e.target.dataset.sectionName;
        if (sectionName && confirm(`Supprimer la section "${sectionName}" ?`)) {
          this.deleteSection(sectionName, e.target);
        }
      });

      // Dev toolbox category creation buttons
      JdrApp.utils.events.register('click', '#addSpellCategory', () => {
        this.createNewCategory('spell');
      });

      JdrApp.utils.events.register('click', '#addDonCategory', () => {
        this.createNewCategory('don');
      });

      // Category deletion buttons
      JdrApp.utils.events.register('click', '[class$="-category-delete"]', (e) => {
        const categoryName = e.target.dataset.categoryName;
        const categoryType = e.target.dataset.categoryType;
        
        if (categoryName && categoryType) {
          this.deleteCategory(categoryType, categoryName);
        }
      });

      // Filter management for objects page
      JdrApp.utils.events.register('click', '.filter-manager-btn', (e) => {
        this.showFilterManagementModal();
      });

      // Filter chip toggling (if dev mode allows interactive filters)
      JdrApp.utils.events.register('click', '.filter-chip', (e) => {
        if (document.body.classList.contains('dev-on')) {
          this.toggleFilter(e.target);
        }
      });

      // Element selector for spells (dev mode)
      JdrApp.utils.events.register('change', '.spell-element-selector', (e) => {
        this.updateSpellElement(e.target);
      });
    },

    extractTypeFromClass(className) {
      if (className.includes('spell')) return 'spell';
      if (className.includes('don')) return 'don';
      if (className.includes('class')) return 'class';
      if (className.includes('objet')) return 'objet';
      return null;
    },

    addContent(type, categoryName) {
      const config = window.ContentTypes[type];
      if (!config) return;

      const defaultItem = ContentFactory.createDefaultItem(type);
      const success = ContentFactory.addItem(type, categoryName, defaultItem);
      
      if (success) {
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: type,
          category: ContentFactory.getEntity(type).findCategory(categoryName)
        });
        
        this.showNotification(`${config.icons.item} Nouvel Ã©lÃ©ment ajoutÃ©`);
      }
    },

    deleteContent(type, categoryName, itemName) {
      if (!confirm(`Supprimer "${itemName}" ?`)) return;

      const success = ContentFactory.deleteItem(type, categoryName, itemName);
      
      if (success) {
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: type,
          category: ContentFactory.getEntity(type).findCategory(categoryName)
        });
        
        this.showNotification('ğŸ—‘ Ã‰lÃ©ment supprimÃ©');
      }
    },

    moveContent(type, categoryName, itemName, direction) {
      const success = ContentFactory.moveItem(type, categoryName, itemName, direction);
      
      if (success) {
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: type,
          category: ContentFactory.getEntity(type).findCategory(categoryName)
        });
        
        const directionText = direction > 0 ? 'descendu' : 'montÃ©';
        this.showNotification(`ğŸ”„ Ã‰lÃ©ment ${directionText}`);
      }
    },

    addParagraph(target, button) {
      // Handle different types of additions based on target
      if (target === 'section') {
        this.addNewSection(button);
      } else {
        this.addParagraphToSection(target, button);
      }
    },

    addNewSection(button) {
      // Generate a unique but readable ID
      const pageId = this.getCurrentPageId();
      const sectionCount = this.countExistingSections();
      const sectionId = `${pageId}-new-${sectionCount + 1}-${Date.now()}`;
      
      const newSection = document.createElement('div');
      newSection.className = 'card editable-section';
      newSection.dataset.sectionType = 'card';
      newSection.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${sectionId}-title">Nouvelle section</h3>
            <button class="edit-btn edit-title-btn" title="Ã‰diter le titre">âœï¸</button>
          </div>
        </div>
        <div style="position:relative;">
          <div class="editable" data-edit-type="generic" data-edit-section="${sectionId}">
            <p>Contenu de la nouvelle section.</p>
          </div>
          <button class="edit-btn edit-section-btn" title="Ã‰diter cette section">âœï¸</button>
        </div>
        <div style="margin-top: 1rem; text-align: center;">
          <button class="section-delete btn small" data-section-name="Nouvelle section" type="button" style="background: #ff6b6b; color: white;">ğŸ—‘ Supprimer section</button>
        </div>
      `;
      
      button.parentNode.insertBefore(newSection, button);
      
      // Immediately save the new section to JSON
      this.saveNewSectionToJSON(sectionId, "Nouvelle section", "<p>Contenu de la nouvelle section.</p>");
      
      // No need to recalculate indices - unique IDs prevent conflicts
      // this.recalculateSectionIndices();
      
      // Trigger persistent storage save
      this.triggerDataSave();
      
      this.showNotification('â• Nouvelle section ajoutÃ©e et sauvegardÃ©e');
    },

    addParagraphToSection(target, button) {
      // Generate a unique but readable ID
      const pageId = this.getCurrentPageId();
      const sectionCount = this.countExistingSections();
      const paragraphId = `${pageId}-para-${sectionCount + 1}-${Date.now()}`;
      
      const container = document.createElement('div');
      container.className = 'editable-paragraph card';
      container.dataset.sectionType = 'card';
      container.style.position = 'relative';
      container.style.marginTop = '1rem';
      
      container.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <h3 class="editable editable-card-title" data-edit-type="generic" data-edit-section="${paragraphId}-title">Nouveau paragraphe</h3>
            <button class="edit-btn edit-title-btn" title="Ã‰diter le titre">âœï¸</button>
          </div>
        </div>
        <div style="position:relative;">
          <div class="editable" data-edit-type="generic" data-edit-section="${paragraphId}">
            <p>Contenu du nouveau paragraphe.</p>
          </div>
          <button class="edit-btn edit-section-btn" title="Ã‰diter cette section">âœï¸</button>
        </div>
        <div style="margin-top: 1rem; text-align: center;">
          <button class="section-delete btn small" data-section-name="Nouveau paragraphe" type="button" style="background: #ff6b6b; color: white;">ğŸ—‘ Supprimer section</button>
        </div>
      `;
      
      button.parentNode.insertBefore(container, button);
      
      // Immediately save the new paragraph as a section to JSON
      this.saveNewSectionToJSON(paragraphId, "Nouveau paragraphe", "<p>Contenu du nouveau paragraphe.</p>");
      
      // No need to recalculate indices - unique IDs prevent conflicts
      // this.recalculateSectionIndices();
      
      // Trigger persistent storage save
      this.triggerDataSave();
      
      this.showNotification('â• Paragraphe ajoutÃ© et sauvegardÃ©');
    },

    deleteSection(sectionName, button) {
      // Find and remove the section
      const section = button.closest('.card');
      if (section) {
        // Extract the section ID from the editable elements
        const editableElement = section.querySelector('[data-edit-section]');
        let sectionId = null;
        if (editableElement) {
          sectionId = editableElement.dataset.editSection;
          // Remove "-title" suffix if present to get base ID
          if (sectionId.endsWith('-title')) {
            sectionId = sectionId.replace('-title', '');
          }
        }
        
        section.remove();
        
        // Save the deletion to JSON
        if (sectionId) {
          this.deleteSectionFromJSON(sectionId);
        }
        
        // Recalculate all section indices after deletion
        this.recalculateSectionIndices();
        
        // Trigger persistent storage save
        this.triggerDataSave();
        
        this.showNotification(`ğŸ—‘ï¸ Section "${sectionName}" supprimÃ©e et mise Ã  jour JSON`);
      }
    },

    // ========================================
    // CONTENT MANIPULATION METHODS 
    // ========================================
    
    addContent(type, categoryName) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`âŒ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Create new item with default values
      const defaultItem = ContentFactory.createDefaultItem(type);
      
      // Special handling for objects (add to single array)
      if (type === 'objet') {
        if (!window.OBJETS.objets) {
          window.OBJETS.objets = [];
        }
        
        // Get next number
        const existingNumbers = window.OBJETS.objets.map(obj => obj.numero || 0);
        const nextNumber = existingNumbers.length > 0 ? Math.max(...existingNumbers) + 1 : 1;
        defaultItem.numero = nextNumber;
        
        window.OBJETS.objets.push(defaultItem);
        this.refreshObjectsPage();
      } else {
        // Standard category-based addition
        const success = ContentFactory.addItem(type, categoryName, defaultItem);
        if (success) {
          EventBus.emit(Events.CONTENT_ADD, {
            type: type,
            category: categoryName,
            item: defaultItem
          });
          
          EventBus.emit(Events.PAGE_RENDER, {
            type: 'category',
            categoryType: type,
            category: ContentFactory.getEntity(type).findCategory(categoryName)
          });
        }
      }
      
      EventBus.emit(Events.STORAGE_SAVE);
      this.showNotification(`${config.icons.add} Nouvel Ã©lÃ©ment ajoutÃ©`, 'success');
    },

    deleteContent(type, categoryName, itemName) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`âŒ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      if (!confirm(`Supprimer "${itemName}" ?`)) {
        return;
      }

      // Special handling for objects
      if (type === 'objet') {
        if (window.OBJETS?.objets) {
          const itemIndex = window.OBJETS.objets.findIndex(obj => obj.nom === itemName);
          if (itemIndex >= 0) {
            window.OBJETS.objets.splice(itemIndex, 1);
            this.refreshObjectsPage();
          }
        }
      } else {
        // Standard category-based deletion
        const success = ContentFactory.deleteItem(type, categoryName, itemName);
        if (success) {
          EventBus.emit(Events.CONTENT_DELETE, {
            type: type,
            category: categoryName,
            item: itemName
          });
          
          EventBus.emit(Events.PAGE_RENDER, {
            type: 'category',
            categoryType: type,
            category: ContentFactory.getEntity(type).findCategory(categoryName)
          });
        }
      }
      
      EventBus.emit(Events.STORAGE_SAVE);
      this.showNotification(`${config.icons.delete} "${itemName}" supprimÃ©`, 'success');
    },

    moveContent(type, categoryName, itemName, direction) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`âŒ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Special handling for objects
      if (type === 'objet') {
        if (window.OBJETS?.objets) {
          const itemIndex = window.OBJETS.objets.findIndex(obj => obj.nom === itemName);
          if (itemIndex >= 0) {
            const newIndex = itemIndex + direction;
            if (newIndex >= 0 && newIndex < window.OBJETS.objets.length) {
              const item = window.OBJETS.objets.splice(itemIndex, 1)[0];
              window.OBJETS.objets.splice(newIndex, 0, item);
              this.refreshObjectsPage();
            }
          }
        }
      } else {
        // Standard category-based movement
        const success = ContentFactory.moveItem(type, categoryName, itemName, direction);
        if (success) {
          EventBus.emit(Events.CONTENT_MOVE, {
            type: type,
            category: categoryName,
            itemName: itemName,
            direction: direction
          });
          
          EventBus.emit(Events.PAGE_RENDER, {
            type: 'category',
            categoryType: type,
            category: ContentFactory.getEntity(type).findCategory(categoryName)
          });
        }
      }
      
      EventBus.emit(Events.STORAGE_SAVE);
      const directionText = direction > 0 ? 'descendu' : 'montÃ©';
      this.showNotification(`ğŸ”„ "${itemName}" ${directionText}`, 'success');
    },

    handleContentAdd(type, category, item) {
      // Additional handling after content is added
      setTimeout(() => {
        if (JdrApp.modules.renderer?.autoLoadImages) {
          JdrApp.modules.renderer.autoLoadImages();
        }
      }, 100);
    },

    handleContentDelete(type, category, item) {
      // Cleanup after content deletion
    },

    handleContentMove(type, category, itemName, direction) {
      // Additional handling after content is moved
    },

    setupSearch() {
      const searchInput = JdrApp.utils.dom.$('#search');
      const clearButton = JdrApp.utils.dom.$('#clear');
      let searchTimeout;
      
      if (searchInput) {
        // Only search on Enter key press
        JdrApp.utils.events.register('keydown', '#search', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            const query = e.target.value.trim();
            if (query.length > 0) {
              this.performSearch(query);
            } else {
              this.clearMainSearchResults();
            }
          } else if (e.key === 'Escape') {
            this.clearMainSearchResults();
            e.target.value = '';
            e.target.blur();
          }
        });
      }
      
      if (clearButton) {
        JdrApp.utils.events.register('click', '#clear', () => {
          if (searchInput) {
            searchInput.value = '';
            this.clearMainSearchResults();
          }
        });
      }

      // Remove click outside handler since we're not using dropdown anymore
      // JdrApp.utils.events.register('click', 'body', (e) => {
      //   if (!e.target.closest('.searchbar') && !e.target.closest('#search-results')) {
      //     this.hideSearchResults();
      //   }
      // });

      // Remove EventBus listener that may cause issues
      // EventBus.on(Events.SEARCH_PERFORM, (payload) => {
      //   this.performSearch(payload.query);
      // });
    },

    performSearch(query) {
      const normalizedQuery = query.toLowerCase().trim();
      
      if (!normalizedQuery) {
        this.showAllContent();
        this.clearMainSearchResults();
        return;
      }

      // Search without minimum character limit since user has to press Enter
      const results = this.searchInData(normalizedQuery);
      this.displaySearchResultsInMain(results, normalizedQuery);
      
      // Keep existing TOC search for compatibility
      this.searchInTOC(normalizedQuery);
    },

    searchInData(query) {
      const results = [];
      
      // Search in SORTS
      if (window.SORTS) {
        window.SORTS.forEach(category => {
          if (category.sorts) {
            category.sorts.forEach(sort => {
              if (this.matchesSearch(sort, query)) {
                const url = `#/sorts-${JdrApp.utils.data.sanitizeId(category.nom)}`;
                
                results.push({
                  type: 'spell',
                  category: category.nom,
                  item: sort,
                  url: url,
                  summary: this.generateSpellSummary(sort)
                });
              }
            });
          }
        });
      }

      // Search in DONS
      if (window.DONS) {
        window.DONS.forEach(category => {
          if (category.dons) {
            category.dons.forEach(don => {
              if (this.matchesSearch(don, query)) {
                results.push({
                  type: 'don',
                  category: category.nom,
                  item: don,
                  url: `#/dons-${JdrApp.utils.data.sanitizeId(category.nom)}`,
                  summary: this.generateDonSummary(don)
                });
              }
            });
          }
        });
      }

      // Search in CLASSES
      if (window.CLASSES) {
        window.CLASSES.forEach(classe => {
          if (this.matchesSearch(classe, query)) {
            results.push({
              type: 'class',
              category: null,
              item: classe,
              url: `#/${JdrApp.utils.data.sanitizeId(classe.nom)}`,
              summary: this.generateClassSummary(classe)
            });
          }
          
          // Search in subclasses
          if (classe.sousClasses) {
            classe.sousClasses.forEach(sousClasse => {
              if (this.matchesSearch(sousClasse, query)) {
                results.push({
                  type: 'subclass',
                  category: classe.nom,
                  item: sousClasse,
                  url: `#/${JdrApp.utils.data.sanitizeId(classe.nom)}`,
                  summary: this.generateSubclassSummary(sousClasse, classe.nom)
                });
              }
            });
          }
        });
      }

      // Search in static pages
      this.searchInStaticPages(query, results);
      
      return results.slice(0, 10); // Limit to 10 results
    },

    searchInStaticPages(query, results) {
      // Search in static pages data
      if (window.STATIC_PAGES) {
        Object.keys(window.STATIC_PAGES).forEach(pageId => {
          const pageData = window.STATIC_PAGES[pageId];
          if (this.matchesStaticPage(pageData, query)) {
            results.push({
              type: 'staticPage',
              category: null,
              item: pageData,
              url: `#/${pageId}`,
              summary: this.generateStaticPageSummary(pageData)
            });
          }
        });
      }

      // Also search in static page config if available
      if (window.STATIC_PAGE_CONFIG?.pages) {
        window.STATIC_PAGE_CONFIG.pages.forEach(pageConfig => {
          if (pageConfig.active && this.matchesPageConfig(pageConfig, query)) {
            // Only add if we haven't already found this page
            const alreadyExists = results.some(r => 
              r.type === 'staticPage' && r.url === `#/${pageConfig.id}`
            );
            
            if (!alreadyExists) {
              results.push({
                type: 'staticPage',
                category: null,
                item: { 
                  title: pageConfig.title, 
                  page: pageConfig.id,
                  description: `Page sur ${pageConfig.title.toLowerCase()}`
                },
                url: `#/${pageConfig.id}`,
                summary: this.generatePageConfigSummary(pageConfig)
              });
            }
          }
        });
      }
    },

    matchesStaticPage(pageData, query) {
      const searchText = [
        pageData.title || '',
        pageData.page || '',
        this.extractStaticPageContent(pageData.sections || [])
      ].join(' ').toLowerCase();
      
      return searchText.includes(query);
    },

    matchesPageConfig(pageConfig, query) {
      const searchText = [
        pageConfig.title || '',
        pageConfig.id || ''
      ].join(' ').toLowerCase();
      
      return searchText.includes(query);
    },

    extractStaticPageContent(sections) {
      return sections.map(section => {
        let content = '';
        if (section.content) {
          if (typeof section.content === 'string') {
            content += section.content;
          } else if (section.content.content) {
            // New HTML format: extract text from HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = section.content.content;
            content += tempDiv.textContent || tempDiv.innerText || '';
          } else if (section.content.items && Array.isArray(section.content.items)) {
            // Legacy format
            content += section.content.items.join(' ');
          }
        }
        return content;
      }).join(' ');
    },

    matchesSearch(item, query) {
      // Fonction pour nettoyer le HTML et extraire le texte
      const stripHtml = (text) => {
        if (!text) return '';
        if (typeof text !== 'string') text = String(text);
        return text.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
      };

      // Fonction pour traiter les listes/arrays
      const processArray = (arr) => {
        if (!arr) return '';
        if (Array.isArray(arr)) {
          return arr.map(item => stripHtml(item)).join(' ');
        }
        return stripHtml(arr);
      };

      // Collecter TOUS les champs textuels possibles
      const searchFields = [
        // Champs communs
        item.nom,
        item.description,
        item.prerequis,
        item.resume,
        
        // Champs spÃ©cifiques aux sorts
        item.element,
        item.portee,
        item.tempsIncantation,
        item.coutMana,
        item.resistance,
        item.effetNormal,
        item.effetCritique,
        
        // Champs spÃ©cifiques aux dons
        item.cout,
        
        // Champs spÃ©cifiques aux classes/sous-classes
        item.progression,
        processArray(item.capacites),
        
        // Champs spÃ©cifiques aux objets
        item.effet,
        item.prix,
        item.poids,
        item.tags ? item.tags.join(' ') : '',
        
        // Champs de statistiques (si c'est un objet)
        item.base ? Object.entries(item.base || {}).map(([key, value]) => `${key} ${value}`).join(' ') : '',
        
        // Autres champs possibles
        item.title,
        item.content,
        item.type
      ];

      // Joindre tous les champs et nettoyer
      const searchText = searchFields
        .filter(field => field !== null && field !== undefined)
        .map(field => stripHtml(field))
        .join(' ')
        .toLowerCase();
      
      // Chercher chaque mot de la requÃªte
      const queryWords = query.toLowerCase().split(/\s+/).filter(word => word.length > 0);
      
      // Tous les mots doivent Ãªtre trouvÃ©s (recherche ET logique)
      return queryWords.every(word => searchText.includes(word));
    },

    generateSpellSummary(spell) {
      // Strip HTML tags from fields to avoid breaking template
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `ğŸ”® ${stripHtml(spell.nom)} - ${stripHtml(spell.prerequis || 'Aucun prÃ©requis')} | ${stripHtml(spell.coutMana || 'CoÃ»t inconnu')}`;
    },

    generateDonSummary(don) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `ğŸ† ${stripHtml(don.nom)} - ${stripHtml(don.prerequis || 'Aucun prÃ©requis')} | ${stripHtml(don.cout || 'CoÃ»t inconnu')}`;
    },

    generateClassSummary(classe) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `âš”ï¸ ${stripHtml(classe.nom)} - ${stripHtml(classe.resume || 'Classe de combat')}`;
    },

    generateSubclassSummary(sousClasse, parentClass) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `âš¡ ${stripHtml(sousClasse.nom)} (${stripHtml(parentClass)}) - Sous-classe spÃ©cialisÃ©e`;
    },

    generateStaticPageSummary(pageData) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `ğŸ“„ ${stripHtml(pageData.title)} - ${stripHtml(pageData.description || 'Page d\'information du jeu')}`;
    },

    generatePageConfigSummary(pageConfig) {
      const stripHtml = (text) => {
        if (!text) return '';
        return String(text).replace(/<[^>]*>/g, '').trim();
      };
      
      return `ğŸ“„ ${stripHtml(pageConfig.title)} - Guide et informations sur ${stripHtml(pageConfig.title.toLowerCase())}`;
    },

    slugify(text) {
      return text.toLowerCase()
        .replace(/[Ã Ã¡Ã¢Ã£Ã¤Ã¥]/g, 'a')
        .replace(/[Ã¨Ã©ÃªÃ«]/g, 'e')
        .replace(/[Ã¬Ã­Ã®Ã¯]/g, 'i')
        .replace(/[Ã²Ã³Ã´ÃµÃ¶]/g, 'o')
        .replace(/[Ã¹ÃºÃ»Ã¼]/g, 'u')
        .replace(/[Ã§]/g, 'c')
        .replace(/[^a-z0-9]/g, '-')
        .replace(/-+/g, '-')
        .replace(/^-|-$/g, '');
    },

    showAllContent() {
      JdrApp.utils.dom.$('article, .toc a').forEach(el => {
        el.style.display = '';
      });
    },

    displaySearchResultsInMain(results, query) {
      const main = document.querySelector('main');
      if (!main) return;

      // Create search results page content
      const searchPageHTML = this.generateSearchResultsPage(results, query);
      
      // Replace main content with search results
      main.innerHTML = searchPageHTML;
      
      // Quick debug to see card dimensions
      setTimeout(() => {
        const cards = main.querySelectorAll('.search-result-card');
        console.log('Cards found:', cards.length);
        cards.forEach((card, i) => {
          console.log(`Card ${i+1} dimensions:`, {
            height: card.offsetHeight,
            width: card.offsetWidth,
            display: getComputedStyle(card).display,
            visibility: getComputedStyle(card).visibility
          });
        });
      }, 100);
      
      // Setup click handlers for results
      this.setupMainSearchHandlers();
      
      // Also setup direct handlers as fallback
      this.setupDirectHandlers();
    },

    generateSearchResultsPage(results, query) {
      if (results.length === 0) {
        return `
          <div class="search-page">
            <div class="search-page-header">
              <h1>ğŸ” Recherche: "${query}"</h1>
              <p class="search-no-results">Aucun rÃ©sultat trouvÃ©</p>
              <button class="btn small" onclick="JdrApp.modules.ui.clearMainSearchResults()">
                â† Retour au sommaire
              </button>
            </div>
          </div>
        `;
      }
      
      let resultsHTML = '';
      
      try {
        resultsHTML = results.map((result, index) => {
          const itemName = result.item.nom || result.item.title || 'Sans nom';
          
          
          // Generate preview safely
          let preview;
          try {
            preview = this.generatePreview(result.item, result.type);
          } catch (previewError) {
            console.error('Preview error:', previewError);
            preview = '<div class="preview-field">Erreur dans l\'aperÃ§u</div>';
          }
          
          // Escape potentially problematic text
          const escapeAttr = (text) => {
            if (!text) return '';
            return String(text).replace(/"/g, '&quot;');
          };
          
          const escapeText = (text) => {
            if (!text) return '';
            return String(text)
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;');
          };

          const cardHTML = `
            <article class="search-result-card" data-url="${result.url}">
              <div class="search-result-header">
                <h3>${this.getTypeIcon(result.type)} ${itemName}</h3>
                <div class="search-result-type">${this.getTypeName(result.type)}</div>
              </div>
              <div class="search-result-content">
                <div class="search-result-summary">${escapeText(result.summary || 'Pas de rÃ©sumÃ©')}</div>
                ${result.category ? `<div class="search-result-category">ğŸ“‚ CatÃ©gorie: ${escapeText(result.category)}</div>` : ''}
                <div class="search-result-preview">
                  ${preview}
                </div>
              </div>
              <div class="search-result-footer">
                <button class="btn small search-result-btn" data-url="${result.url}">
                  Voir la page â†’
                </button>
              </div>
            </article>
          `;
          
          return cardHTML;
        }).join('');
      } catch (error) {
        console.error('Error generating results HTML:', error);
        resultsHTML = '<div class="error">Erreur lors de la gÃ©nÃ©ration des rÃ©sultats</div>';
      }

      const finalHTML = `
        <div class="search-page">
          <div class="search-page-header">
            <h1>ğŸ” Recherche: "${query}"</h1>
            <p class="search-results-count">${results.length} rÃ©sultat${results.length > 1 ? 's' : ''} trouvÃ©${results.length > 1 ? 's' : ''}</p>
            <button class="btn small" onclick="JdrApp.modules.ui.clearMainSearchResults()">
              â† Retour au sommaire
            </button>
          </div>
          <div class="search-results-grid">
            ${resultsHTML}
          </div>
        </div>
      `;
      
      return finalHTML;
    },

    getTypeIcon(type) {
      const icons = {
        'spell': 'ğŸ”®',
        'don': 'ğŸ†', 
        'class': 'âš”ï¸',
        'subclass': 'âš¡',
        'staticPage': 'ğŸ“„'
      };
      return icons[type] || 'ğŸ“„';
    },

    getTypeName(type) {
      const names = {
        'spell': 'Sort',
        'don': 'Don',
        'class': 'Classe',
        'subclass': 'Sous-classe',
        'staticPage': 'Page'
      };
      return names[type] || 'Contenu';
    },

    generatePreview(item, type) {
      // Strip all HTML and clean text completely
      const cleanText = (text) => {
        if (!text) return '';
        return String(text)
          .replace(/<[^>]*>/g, '') // Remove HTML tags
          .replace(/&[^;]+;/g, ' ') // Remove HTML entities
          .replace(/\s+/g, ' ') // Normalize whitespace
          .trim()
          .substring(0, 100); // Limit length
      };

      switch (type) {
        case 'spell':
          const desc = cleanText(item.description || 'Non spÃ©cifiÃ©e');
          const portee = cleanText(item.portee || 'Non spÃ©cifiÃ©e');
          return `<div class="preview-field">Description: ${desc}</div><div class="preview-field">PortÃ©e: ${portee}</div>`;
          
        case 'don':
          const donDesc = cleanText(item.description || 'Non spÃ©cifiÃ©e');
          return `<div class="preview-field">Description: ${donDesc}</div>`;
          
        case 'class':
          const resume = cleanText(item.resume || 'Non spÃ©cifiÃ©');
          return `<div class="preview-field">RÃ©sumÃ©: ${resume}</div>`;
          
        case 'subclass':
          const progression = cleanText(item.progression || 'Non spÃ©cifiÃ©e');
          return `<div class="preview-field">Progression: ${progression}</div>`;
          
        case 'staticPage':
          const content = this.extractStaticPageContent(item.sections || []);
          const preview = cleanText(content || 'Page d\'information');
          return `<div class="preview-field">Contenu: ${preview}</div>`;
          
        default:
          return '<div class="preview-field">AperÃ§u non disponible</div>';
      }
    },

    setupMainSearchHandlers() {
      // Handle click on entire card
      JdrApp.utils.events.register('click', '.search-result-card', (e) => {
        console.log('Card clicked, currentTarget:', e.currentTarget);
        if (e.target.closest('.search-result-btn')) return; // Let button handle it
        
        const url = e.currentTarget ? e.currentTarget.dataset.url : null;
        console.log('Card URL:', url);
        
        if (url && url !== '#test') {
          console.log('Navigating to:', url);
          window.location.hash = url;
          // Force page reload to trigger router
          window.location.reload();
        } else {
          console.warn('No valid URL found on card');
        }
      });

      // Handle button clicks
      JdrApp.utils.events.register('click', '.search-result-btn', (e) => {
        console.log('Button clicked, target:', e.target);
        e.stopPropagation();
        
        const url = e.target ? e.target.dataset.url : null;
        console.log('Button URL:', url);
        
        if (url && url !== '#test') {
          console.log('Navigating to:', url);
          window.location.hash = url;
          // Force page reload to trigger router
          window.location.reload();
        } else {
          console.warn('No valid URL found on button');
        }
      });
    },

    setupDirectHandlers() {
      // Direct event listeners on the elements themselves
      setTimeout(() => {
        const cards = document.querySelectorAll('.search-result-card');
        const buttons = document.querySelectorAll('.search-result-btn');
        
        console.log('Setting up direct handlers for', cards.length, 'cards and', buttons.length, 'buttons');
        
        cards.forEach((card, index) => {
          const url = card.dataset.url;
          console.log(`Card ${index + 1} URL:`, url);
          
          card.addEventListener('click', (e) => {
            if (e.target.closest('.search-result-btn')) return;
            console.log('Direct card click, URL:', url);
            if (url && url !== '#test') {
              window.location.hash = url;
              window.location.reload();
            }
          });
        });
        
        buttons.forEach((button, index) => {
          const url = button.dataset.url;
          console.log(`Button ${index + 1} URL:`, url);
          
          button.addEventListener('click', (e) => {
            e.stopPropagation();
            console.log('Direct button click, URL:', url);
            if (url && url !== '#test') {
              window.location.hash = url;
              window.location.reload();
            }
          });
        });
      }, 200);
    },

    clearMainSearchResults() {
      // Reload the current page or go back to homepage
      if (window.location.hash && window.location.hash !== '#/') {
        window.location.reload();
      } else {
        window.location.hash = '#/creation';
      }
    },

    searchInTOC(query) {
      JdrApp.utils.dom.$('.toc a').forEach(link => {
        const text = link.textContent.toLowerCase();
        const isMatch = text.includes(query);
        link.style.display = isMatch ? '' : 'none';
        
        if (isMatch) {
          const category = link.closest('.toc-category');
          if (category) {
            category.classList.remove('collapsed');
          }
        }
      });
    },

    searchInContent(query) {
      JdrApp.utils.dom.$('article').forEach(article => {
        const text = article.textContent.toLowerCase();
        const isMatch = text.includes(query);
        
        if (isMatch) {
          this.highlightSearchTerms(article, query);
        }
      });
    },

    highlightSearchTerms(container, query) {
      const walker = document.createTreeWalker(
        container,
        NodeFilter.SHOW_TEXT,
        null,
        false
      );

      const textNodes = [];
      let node;
      while (node = walker.nextNode()) {
        if (node.textContent.toLowerCase().includes(query)) {
          textNodes.push(node);
        }
      }

      textNodes.forEach(textNode => {
        const regex = new RegExp(`(${query})`, 'gi');
        const content = textNode.textContent;
        
        if (regex.test(content)) {
          const highlightedContent = content.replace(regex, '<mark>$1</mark>');
          const wrapper = document.createElement('span');
          wrapper.innerHTML = highlightedContent;
          textNode.parentNode.replaceChild(wrapper, textNode);
        }
      });
    },

    setupModals() {
      JdrApp.utils.events.register('click', '.modal-overlay, .modal-close', (e) => {
        const modal = e.target.closest('.modal') || document.querySelector('.modal.visible');
        if (modal) {
          this.closeModal(modal);
        }
      });

      JdrApp.utils.events.register('click', '.modal-content', (e) => {
        e.stopPropagation();
      });

      JdrApp.utils.events.register('keydown', 'body', (e) => {
        if (e.key === 'Escape') {
          const openModal = document.querySelector('.modal.visible');
          if (openModal) {
            this.closeModal(openModal);
          }
        }
      });

      // Resource tools
      JdrApp.utils.events.register('click', '#elementsBtn', () => {
        this.showElementsModal();
      });

      JdrApp.utils.events.register('click', '#etatsBtn', () => {
        this.showEtatsModal();
      });


      EventBus.on(Events.MODAL_OPEN, (payload) => {
        this.openModal(payload.modalId);
      });

      EventBus.on(Events.MODAL_CLOSE, (payload) => {
        const modal = payload.modal || document.querySelector('.modal.visible');
        if (modal) {
          this.closeModal(modal);
        }
      });
    },

    openModal(modalId) {
      const modal = JdrApp.utils.dom.$(`#${modalId}`);
      if (modal) {
        modal.classList.add('visible');
        modal.style.display = 'flex';
        
        const firstInput = modal.querySelector('input, textarea, select');
        if (firstInput) {
          firstInput.focus();
        }
      }
    },

    closeModal(modal) {
      if (modal) {
        modal.classList.remove('visible');
        modal.style.display = 'none';
        
        const form = modal.querySelector('form');
        if (form) {
          form.reset();
        }
      }
    },

    showElementsModal() {
      let modal = JdrApp.utils.dom.$('#elementsModal');
      if (!modal) {
        modal = this.createElementsModal();
        document.body.appendChild(modal);
      }
      
      this.openModal('elementsModal');
    },

    createElementsModal() {
      const elements = Object.entries(window.ElementColors).map(([name, config]) => ({
        name,
        color: config.color,
        icon: this.getElementIcon(name)
      }));

      const elementsHTML = elements.map(element => `
        <div class="element-item" data-element="${element.name}" data-color="${element.color}">
          <div class="element-icon" style="background: ${element.color};">${element.icon}</div>
          <div class="element-name">${element.name}</div>
          <div class="copy-indicator">CopiÃ©!</div>
        </div>
      `).join('');

      const modal = JdrApp.utils.dom.create('div', 'modal elements-modal', `
        <div class="modal-content elements-modal-content">
          <h3>ğŸ¨ Ã‰lÃ©ments</h3>
          <p>Cliquez sur un Ã©lÃ©ment pour copier sa balise HTML colorÃ©e.</p>
          <div class="elements-list">
            ${elementsHTML}
          </div>
          <button class="modal-close btn">Fermer</button>
        </div>
      `, { id: 'elementsModal' });

      modal.addEventListener('click', (e) => {
        const elementItem = e.target.closest('.element-item');
        if (elementItem) {
          const elementName = elementItem.dataset.element;
          
          // Get the full style configuration from ElementColors
          const style = window.ElementColors[elementName];
          if (style) {
            // Build the complete style string
            let styleString = `color: ${style.color}; font-weight: ${style.weight || 'bold'};`;
            if (style.background) styleString += ` background: ${style.background};`;
            if (style.padding) styleString += ` padding: ${style.padding};`;
            if (style.borderRadius) styleString += ` border-radius: ${style.borderRadius};`;
            
            const html = `<span style="${styleString}">${elementName}</span>`;
            this.copyToClipboard(html);
          } else {
            // Fallback for elements not found
            const html = `<span style="color: ${elementItem.dataset.color}; font-weight: bold;">${elementName}</span>`;
            this.copyToClipboard(html);
          }
          
          elementItem.classList.add('copied');
          setTimeout(() => {
            elementItem.classList.remove('copied');
          }, 1000);
        }
      });

      return modal;
    },

    getElementIcon(elementName) {
      const icons = {
        'Feu': 'ğŸ”¥',
        'Air': 'ğŸ’¨',
        'Eau': 'ğŸ’§',
        'Terre': 'ğŸŒ',
        'Divin': 'âœ¨',
        'LumiÃ¨re': 'â˜€ï¸',
        'MalÃ©fique': 'ğŸ’€'
      };
      return icons[elementName] || 'âš¡';
    },

    showEtatsModal() {
      // TOUJOURS recrÃ©er la modal pour avoir les donnÃ©es Ã  jour
      let modal = JdrApp.utils.dom.$('#etatsModal');
      if (modal) {
        document.body.removeChild(modal);
      }
      
      modal = this.createEtatsModal();
      document.body.appendChild(modal);
      
      this.openModal('etatsModal');
    },

    createEtatsModal() {
      // RÃ©cupÃ©rer les donnÃ©es d'Ã©tats depuis window.STATIC_PAGES.etats
      const etatsData = window.STATIC_PAGES?.etats;
      const etats = [];
      
      if (etatsData?.sections) {
        etatsData.sections.forEach(section => {
          if (section.type === 'card' && section.title && section.content) {
            // Convertir le HTML en texte en prÃ©servant les sauts de ligne
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = section.content;
            
            // Remplacer les balises de saut de ligne par des \n avant d'extraire le texte
            tempDiv.innerHTML = tempDiv.innerHTML
              .replace(/<\/p>/gi, '\n')
              .replace(/<br\s*\/?>/gi, '\n')
              .replace(/<\/li>/gi, '\n')
              .replace(/<\/div>/gi, '\n');
            
            const description = (tempDiv.textContent || tempDiv.innerText || section.content)
              .replace(/\n\s*\n/g, '\n') // Supprimer les doubles sauts de ligne
              .trim();
            
            etats.push({
              name: section.title,
              description: description
            });
          }
        });
      }

      const etatsHTML = etats.map(etat => `
        <div class="etat-item" data-etat-name="${etat.name}" data-etat-description="${etat.description}">
          <div class="etat-icon">âš¡</div>
          <div class="etat-content">
            <div class="etat-name">${etat.name}</div>
            <div class="etat-description">${etat.description.length > 60 ? etat.description.substring(0, 60) + '...' : etat.description}</div>
          </div>
          <div class="copy-indicator">CopiÃ©!</div>
        </div>
      `).join('');

      const modal = JdrApp.utils.dom.create('div', 'modal etats-modal', `
        <div class="modal-content etats-modal-content">
          <h3>âš¡ Ã‰tats</h3>
          <p>Cliquez sur un Ã©tat pour copier sa balise HTML avec tooltip.</p>
          <div class="etats-list">
            ${etatsHTML || '<div style="text-align: center; color: #666; padding: 2rem;">Aucun Ã©tat trouvÃ©</div>'}
          </div>
          <button class="modal-close btn">Fermer</button>
        </div>
      `, { id: 'etatsModal' });

      modal.addEventListener('click', (e) => {
        const etatItem = e.target.closest('.etat-item');
        if (etatItem) {
          const etatName = etatItem.dataset.etatName;
          const etatDescription = etatItem.dataset.etatDescription;
          
          const html = `<span title="${etatDescription}">${etatName}</span>`;
          this.copyToClipboard(html);
          
          etatItem.classList.add('copied');
          setTimeout(() => {
            etatItem.classList.remove('copied');
          }, 1000);
        }
      });

      return modal;
    },

    copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        this.showNotification('ğŸ“‹ CopiÃ© dans le presse-papiers', 'success');
      }).catch(() => {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        this.showNotification('ğŸ“‹ CopiÃ© dans le presse-papiers', 'success');
      });
    },

    setupResponsive() {
      this.setupMobileNavigation();
      this.setupLegacyResponsive();
    },

    setupMobileNavigation() {
      // Create mobile navigation toggle button immediately and on resize
      this.createMobileNavToggle();
      
      // Handle mobile nav toggle with delegation
      document.addEventListener('click', (e) => {
        if (e.target.closest('.mobile-nav-toggle')) {
          e.preventDefault();
          this.toggleMobileNav();
        }
      });

      // Auto-close navigation when selecting a page
      document.addEventListener('click', (e) => {
        if (e.target.closest('.toc a') && window.innerWidth <= 980) {
          this.closeMobileNav();
        }
      });

      // Handle window resize
      window.addEventListener('resize', () => {
        if (window.innerWidth <= 980) {
          this.createMobileNavToggle();
        } else {
          this.closeMobileNav();
          const existingButton = document.querySelector('.mobile-nav-toggle');
          if (existingButton) {
            existingButton.remove();
          }
        }
      });
      
      // Also create on DOM content loaded
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
          this.createMobileNavToggle();
        });
      }
    },

    createMobileNavToggle() {
      // Only create if it doesn't exist and we're on mobile
      if (window.innerWidth <= 980 && !document.querySelector('.mobile-nav-toggle')) {
        const toggleButton = document.createElement('button');
        toggleButton.className = 'mobile-nav-toggle';
        toggleButton.innerHTML = `
          <span class="icon">ğŸ“œ</span>
          <span class="text">Menu</span>
        `;
        toggleButton.setAttribute('aria-label', 'Ouvrir/fermer le menu de navigation');
        toggleButton.setAttribute('title', 'Navigation');
        toggleButton.type = 'button';
        
        // Insert at the beginning of body
        if (document.body) {
          document.body.insertBefore(toggleButton, document.body.firstChild);
        }
      }
    },

    toggleMobileNav() {
      const sidebar = document.querySelector('.sidebar');
      const toggleButton = document.querySelector('.mobile-nav-toggle');
      
      if (sidebar && toggleButton) {
        const isOpen = sidebar.classList.contains('mobile-open');
        
        if (isOpen) {
          this.closeMobileNav();
        } else {
          this.openMobileNav();
        }
      }
    },

    openMobileNav() {
      const sidebar = document.querySelector('.sidebar');
      const toggleButton = document.querySelector('.mobile-nav-toggle');
      
      if (sidebar && toggleButton) {
        sidebar.classList.add('mobile-open');
        toggleButton.classList.add('open');
        
        const textSpan = toggleButton.querySelector('.text');
        if (textSpan) {
          textSpan.textContent = 'Fermer';
        }
        
        // Add event listener to close on outside click
        setTimeout(() => {
          document.addEventListener('click', this.handleOutsideClick);
        }, 100);
      }
    },

    closeMobileNav() {
      const sidebar = document.querySelector('.sidebar');
      const toggleButton = document.querySelector('.mobile-nav-toggle');
      
      if (sidebar && toggleButton) {
        sidebar.classList.remove('mobile-open');
        toggleButton.classList.remove('open');
        
        const textSpan = toggleButton.querySelector('.text');
        if (textSpan) {
          textSpan.textContent = 'Menu';
        }
        
        // Remove outside click listener
        document.removeEventListener('click', this.handleOutsideClick);
      }
    },

    handleOutsideClick: (e) => {
      const sidebar = document.querySelector('.sidebar');
      const toggleButton = document.querySelector('.mobile-nav-toggle');
      
      // Close if clicking outside sidebar and toggle button
      if (sidebar && toggleButton && 
          !sidebar.contains(e.target) && 
          !toggleButton.contains(e.target)) {
        JdrApp.modules.ui.closeMobileNav();
      }
    },

    setupLegacyResponsive() {
      // Keep existing responsive handlers for compatibility
      JdrApp.utils.events.register('click', '#menuToggle', () => {
        const sidebar = JdrApp.utils.dom.$('#sidebar');
        const backdrop = JdrApp.utils.dom.$('#backdrop');
        
        if (sidebar && backdrop) {
          sidebar.classList.toggle('mobile-open');
          backdrop.hidden = !sidebar.classList.contains('mobile-open');
        }
      });

      JdrApp.utils.events.register('click', '#backdrop', () => {
        const sidebar = JdrApp.utils.dom.$('#sidebar');
        const backdrop = JdrApp.utils.dom.$('#backdrop');
        
        if (sidebar && backdrop) {
          sidebar.classList.remove('mobile-open');
          backdrop.hidden = true;
        }
      });
    },

    showNotification(message, type = 'info') {
      EventBus.emit(Events.NOTIFICATION_SHOW, { message, type });
      
      // Fallback notification if storage module is not available
      if (!JdrApp.modules.storage?.showNotification) {
        const notification = document.createElement('div');
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: ${type === 'success' ? '#10B981' : type === 'error' ? '#EF4444' : '#3B82F6'};
          color: white;
          padding: 12px 16px;
          border-radius: 8px;
          font-weight: 500;
          z-index: 10000;
          animation: slideIn 0.3s ease;
        `;
        
        notification.textContent = message;
        document.body.appendChild(notification);
        
        setTimeout(() => {
          if (notification.parentNode) {
            notification.parentNode.removeChild(notification);
          }
        }, 3000);
      } else {
        JdrApp.modules.storage.showNotification(message, type);
      }
    },

    // Get current page ID from DOM
    getCurrentPageId() {
      // Find the currently visible article (not hidden)
      const articles = document.querySelectorAll('article[data-static-page="true"]');
      let visibleArticle = null;
      
      for (const article of articles) {
        const style = window.getComputedStyle(article);
        if (style.display !== 'none' && style.visibility !== 'hidden') {
          visibleArticle = article;
          break;
        }
      }
      
      // Fallback: find by active class or current hash
      if (!visibleArticle) {
        const hash = window.location.hash.replace('#/', '');
        if (hash) {
          visibleArticle = document.querySelector(`article[data-page="${hash}"]`);
        }
      }
      
      // Last fallback: any visible article
      if (!visibleArticle) {
        visibleArticle = document.querySelector('article[data-static-page="true"]:not([style*="display: none"])');
      }
      
      const pageId = visibleArticle ? visibleArticle.dataset.page : null;
      console.log('ğŸ” DEBUG getCurrentPageId: Found visible article:', !!visibleArticle);
      console.log('ğŸ” DEBUG getCurrentPageId: Page ID:', pageId);
      if (visibleArticle) {
        console.log('ğŸ” DEBUG getCurrentPageId: Article attributes:', {
          'data-static-page': visibleArticle.dataset.staticPage,
          'data-page': visibleArticle.dataset.page,
          'data-page-title': visibleArticle.dataset.pageTitle
        });
      }
      return pageId;
    },

    // Count existing sections for unique ID generation
    countExistingSections() {
      const pageId = this.getCurrentPageId();
      if (!pageId || !window.STATIC_PAGES || !window.STATIC_PAGES[pageId]) {
        return 0;
      }
      const pageData = window.STATIC_PAGES[pageId];
      return pageData.sections ? pageData.sections.length : 0;
    },

    // Save new section to JSON data
    saveNewSectionToJSON(sectionId, title, content) {
      const pageId = this.getCurrentPageId();
      console.log('ğŸ” DEBUG SAVE: getCurrentPageId() returned:', pageId);
      console.log('ğŸ” DEBUG SAVE: Available pages in STATIC_PAGES:', Object.keys(window.STATIC_PAGES || {}));
      
      if (!pageId || !window.STATIC_PAGES || !window.STATIC_PAGES[pageId]) {
        console.warn('Cannot save new section - page not found:', pageId);
        console.warn('window.STATIC_PAGES exists:', !!window.STATIC_PAGES);
        console.warn('pageId exists in STATIC_PAGES:', pageId && window.STATIC_PAGES && !!window.STATIC_PAGES[pageId]);
        return false;
      }

      const pageData = window.STATIC_PAGES[pageId];
      
      // Create new section object
      const newSection = {
        type: "card",
        id: sectionId,
        title: title,
        content: content,
        deletable: true,
        sectionName: title
      };

      // Add to sections array
      if (!pageData.sections) {
        pageData.sections = [];
      }
      
      pageData.sections.push(newSection);
      
      return true;
    },

    // Delete section from JSON data
    deleteSectionFromJSON(sectionId) {
      const pageId = this.getCurrentPageId();
      if (!pageId || !window.STATIC_PAGES || !window.STATIC_PAGES[pageId]) {
        console.warn('Cannot delete section - page not found:', pageId);
        return false;
      }

      const pageData = window.STATIC_PAGES[pageId];
      if (!pageData.sections) {
        console.warn('No sections found in page data');
        return false;
      }

      console.log(`ğŸ—‘ï¸ SUPPRESSION JSON: Tentative de suppression "${sectionId}" de ${pageId}.json`);
      console.log('ğŸ“Š Ã‰tat JSON avant suppression:', {
        pageId,
        totalSections: pageData.sections.length,
        sectionIds: pageData.sections.map(s => s.id)
      });

      // Remove section by ID
      const initialLength = pageData.sections.length;
      pageData.sections = pageData.sections.filter(section => section.id !== sectionId);
      
      // Check if section was found and removed
      const removed = pageData.sections.length < initialLength;
      if (removed) {
        console.log(`âœ… SUPPRESSION JSON: Section "${sectionId}" supprimÃ©e de ${pageId}.json`);
        console.log('ğŸ“Š Ã‰tat JSON aprÃ¨s suppression:', {
          pageId,
          totalSections: pageData.sections.length,
          sectionIds: pageData.sections.map(s => s.id)
        });
        return true;
      } else {
        // Try to find in nested grid content
        for (let section of pageData.sections) {
          if (section.type === 'grid' && section.content) {
            const gridInitialLength = section.content.length;
            section.content = section.content.filter(item => item.id !== sectionId);
            if (section.content.length < gridInitialLength) {
              console.log(`âœ… SUPPRESSION JSON: Section "${sectionId}" supprimÃ©e de grille dans ${pageId}.json`);
              return true;
            }
          }
        }
        
        console.error(`âŒ ERREUR: Section "${sectionId}" introuvable pour suppression`);
        console.log('ğŸ” Sections disponibles:', pageData.sections.map(s => ({id: s.id, title: s.title})));
        return false;
      }
    },

    // Recalculate all section indices in the current page to prevent conflicts
    recalculateSectionIndices() {
      // Disable index recalculation for now - it causes ID mismatches
      // The current approach of using timestamp-based unique IDs is more stable
      console.log('Index recalculation disabled - using stable unique IDs');
      return true;
    },

    // OLD VERSION - kept for reference but disabled
    _recalculateSectionIndicesOld() {
      const pageId = this.getCurrentPageId();
      if (!pageId) {
        console.warn('Cannot recalculate indices - no current page');
        return false;
      }

      // Update DOM data-edit-section attributes to match JSON structure
      const article = document.querySelector('article[data-static-page="true"]');
      if (!article) {
        console.warn('No static page article found');
        return false;
      }

      // Get the JSON data for this page
      const pageData = window.STATIC_PAGES?.[pageId];
      if (!pageData?.sections) {
        console.warn('No page data found for recalculation');
        return false;
      }

      // Build a mapping of DOM sections to JSON sections
      const sections = article.querySelectorAll('.editable-section, .card');
      let sectionIndex = 0;

      sections.forEach((domSection, domIndex) => {
        // Skip sections that don't have editable content
        const editableElements = domSection.querySelectorAll('[data-edit-section]');
        if (editableElements.length === 0) return;

        // Find corresponding JSON section
        let jsonSection = null;
        let jsonIndex = sectionIndex;

        // Try to match by existing ID first
        const firstEditable = editableElements[0];
        let currentId = firstEditable.dataset.editSection;
        if (currentId.endsWith('-title')) {
          currentId = currentId.replace('-title', '');
        }

        // Look for matching JSON section
        for (let i = 0; i < pageData.sections.length; i++) {
          const section = pageData.sections[i];
          if (section.id === currentId || section.type === 'intro') {
            jsonSection = section;
            jsonIndex = i;
            break;
          }
        }

        // If no match found, assign next available index
        if (!jsonSection && sectionIndex < pageData.sections.length) {
          jsonSection = pageData.sections[sectionIndex];
          jsonIndex = sectionIndex;
        }

        if (jsonSection) {
          // Update DOM attributes to match JSON structure
          editableElements.forEach(editable => {
            const currentEditSection = editable.dataset.editSection;
            
            // Determine the new ID based on JSON section
            let newEditSection;
            if (currentEditSection.endsWith('-title')) {
              newEditSection = `${jsonSection.id}-title`;
            } else {
              newEditSection = jsonSection.id;
            }

            // Update the data attribute
            editable.dataset.editSection = newEditSection;
            
            console.log(`Updated section ${domIndex}: ${currentEditSection} â†’ ${newEditSection}`);
          });

          sectionIndex++;
        }
      });

      // Also update section indices in JSON to ensure consistency
      pageData.sections.forEach((section, index) => {
        // Ensure each section has a proper ID
        if (!section.id || section.id.startsWith('section-')) {
          // Generate a stable ID based on title or position
          const baseId = section.title ? 
            section.title.toLowerCase().replace(/[^a-z0-9]/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '') :
            `section-${index}`;
          section.id = baseId;
        }
      });

      console.log(`Recalculated indices for ${sectionIndex} sections in page ${pageId}`);
      return true;
    },

    // Trigger data save to localStorage/persistent storage
    triggerDataSave() {
      // Data is already saved in window.STATIC_PAGES in memory
    },

    createNewCategory(type) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`âŒ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Demander le nom de la catÃ©gorie
      const categoryName = prompt(`Nom de la nouvelle catÃ©gorie de ${config.container} :`);
      if (!categoryName || !categoryName.trim()) {
        return;
      }

      const trimmedName = categoryName.trim();

      // VÃ©rifier que la catÃ©gorie n'existe pas dÃ©jÃ 
      const entity = ContentFactory.getEntity(type);
      if (entity && entity.findCategory(trimmedName)) {
        this.showNotification(`âŒ Une catÃ©gorie "${trimmedName}" existe dÃ©jÃ `, 'error');
        return;
      }

      // Demander la description et spoilAlert pour les objets
      let description = prompt(`Description de la catÃ©gorie "${trimmedName}" :`);
      if (!description) description = '';

      let spoilAlert = false;
      if (type === 'objet') {
        spoilAlert = confirm('Cette catÃ©gorie contient-elle des Ã©lÃ©ments de spoil ?');
      }

      // CrÃ©er la nouvelle catÃ©gorie
      const newCategory = {
        nom: trimmedName,
        description: description.trim(),
        [config.identifiers.category]: []
      };

      // Ajouter spoilAlert pour les objets
      if (type === 'objet') {
        newCategory.spoilAlert = spoilAlert;
      }

      // Ajouter Ã  la structure de donnÃ©es
      const dataKey = config.dataKey;
      if (!window[dataKey]) {
        window[dataKey] = [];
      }

      window[dataKey].push(newCategory);

      // RafraÃ®chir ContentFactory
      ContentFactory.refreshData();

      // RafraÃ®chir le router TOC
      if (JdrApp.modules.router && JdrApp.modules.router.generateTOC) {
        JdrApp.modules.router.generateTOC();
      }

      // Naviguer vers la nouvelle catÃ©gorie
      const categoryRoute = `${config.container}-${JdrApp.utils.data.sanitizeId(trimmedName)}`;
      JdrApp.modules.router.navigate(categoryRoute);

      this.showNotification(`${config.icons.category} CatÃ©gorie "${trimmedName}" crÃ©Ã©e avec succÃ¨s!`, 'success');
    },

    deleteCategory(type, categoryName) {
      const config = window.ContentTypes[type];
      if (!config) {
        this.showNotification(`âŒ Configuration manquante pour le type ${type}`, 'error');
        return;
      }

      // Confirmation avec dÃ©tails
      const entity = ContentFactory.getEntity(type);
      const category = entity?.findCategory(categoryName);
      
      if (!category) {
        this.showNotification(`âŒ CatÃ©gorie "${categoryName}" introuvable`, 'error');
        return;
      }

      const itemsProperty = this.getItemsProperty(type);
      const itemCount = category[itemsProperty]?.length || 0;
      
      const confirmMessage = itemCount > 0 
        ? `Supprimer la catÃ©gorie "${categoryName}" et ses ${itemCount} Ã©lÃ©ments ?`
        : `Supprimer la catÃ©gorie vide "${categoryName}" ?`;
        
      if (!confirm(confirmMessage)) {
        return;
      }

      // Supprimer de la structure de donnÃ©es
      const dataKey = config.dataKey;
      if (window[dataKey]) {
        const categoryIndex = window[dataKey].findIndex(cat => cat.nom === categoryName);
        
        if (categoryIndex >= 0) {
          window[dataKey].splice(categoryIndex, 1);
          
          // RafraÃ®chir ContentFactory
          ContentFactory.refreshData();

          // RafraÃ®chir le router TOC
          if (JdrApp.modules.router && JdrApp.modules.router.generateTOC) {
            JdrApp.modules.router.generateTOC();
          }

          // Naviguer vers la page principale du type
          JdrApp.modules.router.navigate(config.container);

          this.showNotification(`${config.icons.delete} CatÃ©gorie "${categoryName}" supprimÃ©e`, 'success');
        } else {
          this.showNotification(`âŒ Erreur lors de la suppression`, 'error');
        }
      }
    },

    getItemsProperty(type) {
      switch (type) {
        case 'spell': return 'sorts';
        case 'don': return 'dons';
        case 'objet': return 'objets';
        case 'class': return 'sousClasses';
        default: return 'items';
      }
    },

    // ==== FILTER MANAGEMENT METHODS ====

    showFilterManagementModal() {
      if (!window.OBJETS || !window.ContentTypes.objet) return;
      
      const config = window.ContentTypes.objet.filterConfig;
      const currentSettings = window.OBJETS.filterSettings || { visibleTags: config.defaultVisibleTags };
      
      let modal = document.querySelector('#filterModal');
      if (!modal) {
        modal = this.createFilterModal();
        document.body.appendChild(modal);
      }
      
      // Update modal content with current settings
      this.updateFilterModalContent(modal, config, currentSettings);
      this.openModal('filterModal');
    },

    createFilterModal() {
      const modal = document.createElement('div');
      modal.className = 'modal';
      modal.id = 'filterModal';
      modal.innerHTML = `
        <div class="modal-content" style="max-width: 500px;">
          <h3>âš™ï¸ Gestion des filtres d'objets</h3>
          <p>Choisissez quels tags d'objets afficher sur la page :</p>
          <div id="filterCheckboxes" style="margin: 1rem 0;">
            <!-- Content will be populated by updateFilterModalContent -->
          </div>
          <div style="display: flex; gap: 1rem; justify-content: flex-end; margin-top: 1.5rem;">
            <button class="btn" id="resetFiltersBtn" style="background: var(--bronze); color: white;">
              ğŸ”„ RÃ©initialiser
            </button>
            <button class="btn" id="saveFiltersBtn" style="background: var(--accent); color: white;">
              ğŸ’¾ Sauvegarder
            </button>
            <button class="btn modal-close" style="background: #666; color: white;">
              âŒ Annuler
            </button>
          </div>
        </div>
      `;

      // Add event listeners
      modal.addEventListener('click', (e) => {
        if (e.target.id === 'saveFiltersBtn') {
          this.saveFilterSettings(modal);
        } else if (e.target.id === 'resetFiltersBtn') {
          this.resetFilterSettings(modal);
        }
      });

      return modal;
    },

    updateFilterModalContent(modal, config, currentSettings) {
      const checkboxContainer = modal.querySelector('#filterCheckboxes');
      if (!checkboxContainer) return;

      const checkboxHTML = config.availableTags.map(tag => {
        const isVisible = currentSettings.visibleTags.includes(tag);
        return `
          <div style="display: flex; align-items: center; gap: 0.5rem; margin: 0.5rem 0; padding: 0.5rem; background: var(--card); border-radius: 8px;">
            <input 
              type="checkbox" 
              id="filter-${tag}" 
              value="${tag}" 
              ${isVisible ? 'checked' : ''}
              style="margin: 0;"
            >
            <label for="filter-${tag}" style="flex: 1; cursor: pointer; font-weight: 500;">
              <span class="tag-chip" style="margin-right: 0.5rem;">${tag}</span>
              ${tag}
            </label>
          </div>
        `;
      }).join('');

      checkboxContainer.innerHTML = checkboxHTML;
    },

    saveFilterSettings(modal) {
      const checkboxes = modal.querySelectorAll('input[type="checkbox"]');
      const visibleTags = Array.from(checkboxes)
        .filter(cb => cb.checked)
        .map(cb => cb.value);

      if (visibleTags.length === 0) {
        this.showNotification('âŒ Veuillez sÃ©lectionner au moins un tag', 'error');
        return;
      }

      // Update the data structure
      if (!window.OBJETS.filterSettings) {
        window.OBJETS.filterSettings = {};
      }
      window.OBJETS.filterSettings.visibleTags = visibleTags;

      // Trigger page re-render
      this.refreshObjectsPage();
      
      // Close modal and show notification
      this.closeModal(modal);
      this.showNotification(`ğŸ·ï¸ Filtres mis Ã  jour : ${visibleTags.join(', ')}`, 'success');
    },

    resetFilterSettings(modal) {
      const config = window.ContentTypes.objet.filterConfig;
      const defaultSettings = { visibleTags: config.defaultVisibleTags };
      
      this.updateFilterModalContent(modal, config, defaultSettings);
      this.showNotification('ğŸ”„ Filtres rÃ©initialisÃ©s aux valeurs par dÃ©faut', 'info');
    },

    toggleFilter(chipElement) {
      const tag = chipElement.dataset.tag;
      if (!tag || !window.OBJETS) return;

      const currentSettings = window.OBJETS.filterSettings || { 
        visibleTags: window.ContentTypes.objet.filterConfig.defaultVisibleTags 
      };

      const isActive = chipElement.classList.contains('active');
      
      if (isActive) {
        // Remove from visible tags if not the last one
        if (currentSettings.visibleTags.length > 1) {
          currentSettings.visibleTags = currentSettings.visibleTags.filter(t => t !== tag);
          chipElement.classList.remove('active');
          this.showNotification(`ğŸ·ï¸ Tag "${tag}" masquÃ©`, 'info');
        } else {
          this.showNotification('âŒ Impossible de masquer le dernier tag actif', 'error');
          return;
        }
      } else {
        // Add to visible tags
        if (!currentSettings.visibleTags.includes(tag)) {
          currentSettings.visibleTags.push(tag);
          chipElement.classList.add('active');
          this.showNotification(`ğŸ·ï¸ Tag "${tag}" affichÃ©`, 'info');
        }
      }

      // Update the data structure
      window.OBJETS.filterSettings = currentSettings;
      
      // Refresh the page
      this.refreshObjectsPage();
    },

    refreshObjectsPage() {
      // Check if we're currently on the objects page
      if (window.location.hash === '#/objets' || window.location.hash === '#/objet') {
        EventBus.emit(Events.PAGE_RENDER, {
          type: 'category',
          categoryType: 'objet',
          category: window.OBJETS
        });
      }
    },

    // ==== SPELL ELEMENT MANAGEMENT ====

    updateSpellElement(selectElement) {
      // Get the selected element
      const newElement = selectElement.value;
      const spellName = selectElement.dataset.spellName;
      const categoryName = selectElement.dataset.categoryName;

      if (!newElement || !spellName || !categoryName) {
        this.showNotification('âŒ Erreur : donnÃ©es du sort manquantes', 'error');
        return;
      }

      // Find and update the spell data
      const spellEntity = ContentFactory.getEntity('spell');
      const category = spellEntity?.findCategory(categoryName);
      
      if (!category) {
        this.showNotification(`âŒ CatÃ©gorie "${categoryName}" introuvable`, 'error');
        return;
      }

      const spell = category.sorts?.find(s => s.nom === spellName);
      if (!spell) {
        this.showNotification(`âŒ Sort "${spellName}" introuvable`, 'error');
        return;
      }

      // Update the spell element
      spell.element = newElement;

      // Save the changes to storage
      EventBus.emit(Events.STORAGE_SAVE);

      // Update the visual display
      const spellCard = selectElement.closest('.card');
      if (spellCard) {
        const elementDisplay = spellCard.querySelector('.spell-element-selector').parentNode;
        if (elementDisplay) {
          // Find the icon and colors for the new element
          const icon = window.ElementIcons ? window.ElementIcons[newElement] : 'ğŸ”¥';
          const colors = window.ElementColors ? window.ElementColors[newElement] : { color: '#ff6b35', weight: 'bold' };
          
          // Build style string
          let style = `color: ${colors.color}; font-weight: ${colors.weight};`;
          if (colors.background) style += ` background: ${colors.background};`;
          if (colors.padding) style += ` padding: ${colors.padding};`;
          if (colors.borderRadius) style += ` border-radius: ${colors.borderRadius};`;
          
          // Update the dropdown options to reflect the selection
          const options = Object.keys(window.ElementIcons || {});
          const optionsHTML = options.map(elem => 
            `<option value="${elem}" ${elem === newElement ? 'selected' : ''}>${window.ElementIcons[elem]} ${elem}</option>`
          ).join('');
          
          selectElement.innerHTML = optionsHTML;
        }
      }

      // Trigger page re-render to update all spell displays
      EventBus.emit(Events.PAGE_RENDER, {
        type: 'category',
        categoryType: 'spell',
        category: category
      });

      // Show success notification
      const elementIcon = window.ElementIcons ? window.ElementIcons[newElement] : 'ğŸ”¥';
      this.showNotification(`${elementIcon} Ã‰lÃ©ment du sort "${spellName}" mis Ã  jour : ${newElement}`, 'success');
    },

    // ========================================
    // NEW PAGE CREATION WITH SECTION SELECTION
    // ========================================
    setupNewPageHandler() {
      // Set up event listener for "Nouvelle page" button
      document.addEventListener('click', (e) => {
        if (e.target && e.target.id === 'addCategory') {
          e.preventDefault();
          this.showSectionSelectionModal();
        }
      });
    },

    showSectionSelectionModal() {
      const modal = this.createSectionSelectionModal();
      document.body.appendChild(modal);
      this.openModal('sectionSelectionModal');
    },

    createSectionSelectionModal() {
      // Get available sections from TOC structure
      const sections = window.TOC_STRUCTURE?.sections || [
        { id: 'heros', title: 'ğŸ¦¸ HÃ©ros', icon: 'ğŸ¦¸' },
        { id: 'arsenal', title: 'âš”ï¸ Arsenal', icon: 'âš”ï¸' },
        { id: 'regles', title: 'ğŸ“š RÃ¨gles', icon: 'ğŸ“š' }
      ];

      // Filter sections based on MJ access if needed
      const availableSections = sections.filter(section => 
        !section.requiresMJ || window.JdrApp?.state?.isMJ
      );

      const sectionsHTML = availableSections.map(section => `
        <div class="section-option" data-section-id="${section.id}">
          <div class="section-icon">${section.icon}</div>
          <div class="section-info">
            <div class="section-title">${section.title}</div>
            <div class="section-description">${section.description || 'Section de contenu'}</div>
          </div>
        </div>
      `).join('');

      const modal = document.createElement('div');
      modal.className = 'modal section-selection-modal';
      modal.id = 'sectionSelectionModal';
      modal.innerHTML = `
        <div class="modal-overlay"></div>
        <div class="modal-content">
          <h3>ğŸ“„ Nouvelle page</h3>
          <p>Dans quelle section souhaitez-vous crÃ©er la nouvelle page ?</p>
          
          <div class="sections-list">
            ${sectionsHTML}
          </div>
          
          <div class="page-details" style="display: none;">
            <div class="form-group">
              <label for="pageTitle">Titre de la page :</label>
              <input type="text" id="pageTitle" placeholder="Nom de la nouvelle page" required>
            </div>
            <div class="form-group">
              <label for="pageIcon">IcÃ´ne (optionnel) :</label>
              <input type="text" id="pageIcon" placeholder="ğŸ“„" maxlength="2">
            </div>
          </div>
          
          <div class="modal-actions">
            <button type="button" class="btn modal-close">Annuler</button>
            <button type="button" class="btn btn-primary" id="createPageBtn" style="display: none;">CrÃ©er la page</button>
          </div>
        </div>
      `;

      // Set up event handlers
      this.setupSectionSelectionHandlers(modal);

      return modal;
    },

    setupSectionSelectionHandlers(modal) {
      let selectedSectionId = null;

      // Section selection
      modal.addEventListener('click', (e) => {
        const sectionOption = e.target.closest('.section-option');
        if (sectionOption) {
          // Remove previous selection
          modal.querySelectorAll('.section-option').forEach(opt => opt.classList.remove('selected'));
          
          // Select this section
          sectionOption.classList.add('selected');
          selectedSectionId = sectionOption.dataset.sectionId;
          
          // Show page details form
          const pageDetails = modal.querySelector('.page-details');
          const createBtn = modal.querySelector('#createPageBtn');
          pageDetails.style.display = 'block';
          createBtn.style.display = 'inline-block';
          
          // Focus on title input
          modal.querySelector('#pageTitle').focus();
        }
      });

      // Create page button
      modal.querySelector('#createPageBtn').addEventListener('click', () => {
        const titleInput = modal.querySelector('#pageTitle');
        const iconInput = modal.querySelector('#pageIcon');
        
        const pageTitle = titleInput.value.trim();
        const pageIcon = iconInput.value.trim() || 'ğŸ“„';
        
        if (!pageTitle) {
          this.showNotification('Veuillez saisir un titre pour la page', 'error');
          titleInput.focus();
          return;
        }

        if (!selectedSectionId) {
          this.showNotification('Veuillez sÃ©lectionner une section', 'error');
          return;
        }

        this.createNewPage(selectedSectionId, pageTitle, pageIcon);
        this.closeModal(modal);
      });

      // Handle Enter key in form
      modal.querySelector('#pageTitle').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && selectedSectionId) {
          modal.querySelector('#createPageBtn').click();
        }
      });
    },

    createNewPage(sectionId, pageTitle, pageIcon) {
      // Generate page ID from title
      const pageId = this.slugify(pageTitle);
      
      // Create new page object
      const newPage = {
        type: 'page',
        id: pageId,
        title: pageTitle,
        icon: pageIcon
      };

      // Add to TOC structure
      if (window.TOC_STRUCTURE) {
        const section = window.TOC_STRUCTURE.sections.find(s => s.id === sectionId);
        if (section) {
          section.items.push(newPage);
          
          // Create default page data
          const defaultPageData = {
            page: pageId,
            title: pageTitle,
            sections: [
              {
                type: 'intro',
                content: `Contenu de la page ${pageTitle}. Vous pouvez Ã©diter ce texte en mode dÃ©veloppement.`
              }
            ]
          };

          // Add to static pages
          if (!window.STATIC_PAGES) {
            window.STATIC_PAGES = {};
          }
          window.STATIC_PAGES[pageId] = defaultPageData;

          // Regenerate TOC to include new page
          if (JdrApp.modules.router) {
            JdrApp.modules.router.generateTOC();
          }

          // Navigate to new page
          window.location.hash = `#/${pageId}`;

          this.showNotification(`ğŸ“„ Page "${pageTitle}" crÃ©Ã©e avec succÃ¨s dans la section ${this.getSectionTitle(sectionId)}`, 'success');
        }
      }
    },

    getSectionTitle(sectionId) {
      if (window.TOC_STRUCTURE) {
        const section = window.TOC_STRUCTURE.sections.find(s => s.id === sectionId);
        return section ? section.title : sectionId;
      }
      return sectionId;
    }
  };

})();

</script>
</body>
</html>